<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="ea3c4fdc7ae483f6eeee71767d6d7c25afd3b747" translate="yes" xml:space="preserve">
          <source>ULLK</source>
          <target state="translated">ULLK</target>
        </trans-unit>
        <trans-unit id="bd9c57578a5fa70fa2923dfa1948bb1047652950" translate="yes" xml:space="preserve">
          <source>ULLR</source>
          <target state="translated">ULLR</target>
        </trans-unit>
        <trans-unit id="181f09b6cf6ff48fe2bced4f8717c409974c7ccb" translate="yes" xml:space="preserve">
          <source>ULR</source>
          <target state="translated">ULR</target>
        </trans-unit>
        <trans-unit id="fdf943dd853f60e8f066b9ff1db365525dfa7714" translate="yes" xml:space="preserve">
          <source>UR</source>
          <target state="translated">UR</target>
        </trans-unit>
        <trans-unit id="b92dcc34c6f88a2b085f0fcf11324b5c2cf08f22" translate="yes" xml:space="preserve">
          <source>Unary absolute value.</source>
          <target state="translated">単項絶対値。</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">単項否定。</target>
        </trans-unit>
        <trans-unit id="5b74b98336e7267fb4f37f0b361c833e21dc0aa0" translate="yes" xml:space="preserve">
          <source>Unary square root operation.</source>
          <target state="translated">単項平方根演算。</target>
        </trans-unit>
        <trans-unit id="00399f106390204b9e8a47f8e8e78be426150d13" translate="yes" xml:space="preserve">
          <source>Unbounded uses, on the other hand, are uses of &lt;code&gt;alloca&lt;/code&gt; with no controlling predicate constraining its integer argument. For example:</source>
          <target state="translated">一方、無制限の使用は、整数引数を制約する制御述語のない &lt;code&gt;alloca&lt;/code&gt; の使用です。例えば：</target>
        </trans-unit>
        <trans-unit id="d6ba59d2b5ffc5c4e08397a280a30fb560e8436a" translate="yes" xml:space="preserve">
          <source>Undefining &lt;code id=&quot;index-std-3&quot;&gt;__STDC__&lt;/code&gt; when</source>
          <target state="translated">いつ &lt;code id=&quot;index-std-3&quot;&gt;__STDC__&lt;/code&gt; を未定義にするか</target>
        </trans-unit>
        <trans-unit id="f070a98f1b801c2b6e78c0be33c88683a70671cf" translate="yes" xml:space="preserve">
          <source>Undefining &lt;code&gt;__STDC__&lt;/code&gt; in C++.</source>
          <target state="translated">C ++で &lt;code&gt;__STDC__&lt;/code&gt; を未定義にする。</target>
        </trans-unit>
        <trans-unit id="ca3f9bb4feba0ac0f3a9b154b20506b4c489b2f4" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your &lt;code&gt;asm&lt;/code&gt; code defines symbols or labels. Using &amp;lsquo;</source>
          <target state="translated">特定の状況下では、最適化時にGCCがアセンブリコードを複製（または複製を削除）する場合があります。これにより、 &lt;code&gt;asm&lt;/code&gt; コードでシンボルまたはラベルが定義されている場合、コンパイル中に予期しない重複シンボルエラーが発生する可能性があります。を使用して</target>
        </trans-unit>
        <trans-unit id="199aae5416e814ba38647e12711c671c6b6db5a1" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your assembly code defines symbols or labels.</source>
          <target state="translated">特定の状況下では、最適化の際にGCCがアセンブリコードを重複させる(または重複したものを削除する)ことがあります。これは、アセンブリコードがシンボルやラベルを定義している場合、コンパイル時に予期せぬ重複シンボルエラーを引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="72b29a25fd6f124cae730e139b0e10b10a80e560" translate="yes" xml:space="preserve">
          <source>Unfortunately, historically GCC used to have a number of bugs in its encoding code. The NeXT runtime expects GCC to emit type encodings in this historical format (compatible with GCC-3.3), so when using the NeXT runtime, GCC will introduce on purpose a number of incorrect encodings:</source>
          <target state="translated">残念なことに、歴史的にGCCはそのエンコーディングコードに多くのバグを持っていました。NeXTランタイムは、GCCがこの歴史的なフォーマット(GCC-3.3と互換性がある)で型エンコーディングを出力することを期待しているので、NeXTランタイムを使用すると、GCCは意図的に多くの不正なエンコーディングを導入してしまいます。</target>
        </trans-unit>
        <trans-unit id="aeee418a8137652ee6d9ab3008a38b4d74bc2a2f" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are some characters allowed in identifiers by ISO C and ISO C++ that, when turned into NFC, are not allowed in identifiers. That is, there&amp;rsquo;s no way to use these symbols in portable ISO C or C++ and have all your identifiers in NFC.</source>
          <target state="translated">残念ながら、ISO CおよびISO C ++の識別子で許可されている文字の中には、NFCに変換すると識別子で許可されないものがあります。つまり、これらのシンボルをポータブルISO CまたはC ++で使用して、すべての識別子をNFCに含める方法はありません。</target>
        </trans-unit>
        <trans-unit id="5ddc1e63d4f989177759a83df41bd4b7dad20371" translate="yes" xml:space="preserve">
          <source>Unix C compilers have traditionally allocated storage for uninitialized global variables in a common block. This allows the linker to resolve all tentative definitions of the same variable in different compilation units to the same object, or to a non-tentative definition. This is the behavior specified by</source>
          <target state="translated">Unix Cコンパイラは伝統的に、初期化されていないグローバル変数のためのストレージを共通のブロックに割り当ててきました。これにより、リンカは、異なるコンパイル単位での同じ変数のすべての暫定的な定義を同じオブジェクトに解決したり、非暫定的な定義に解決したりすることができます。これは</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="d6a3e0eb54ec1efd8ae1e1735e817354b9b6421f" translate="yes" xml:space="preserve">
          <source>Unless &lt;var&gt;*ptr&lt;/var&gt; and &lt;var&gt;vobj&lt;/var&gt; can be aliased, it is not guaranteed that the write to &lt;var&gt;*ptr&lt;/var&gt; occurs by the time the update of &lt;var&gt;vobj&lt;/var&gt; happens. If you need this guarantee, you must use a stronger memory barrier such as:</source>
          <target state="translated">ない限り &lt;var&gt;*ptr&lt;/var&gt; と &lt;var&gt;vobj&lt;/var&gt; をエイリアスすることができ、への書き込みは保証されません &lt;var&gt;*ptr&lt;/var&gt; はの更新時間によって発生し &lt;var&gt;vobj&lt;/var&gt; が起こります。この保証が必要な場合は、次のようなより強力なメモリバリアを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c9e3382936f0af0d7125a8bf9b98d564d02b82c4" translate="yes" xml:space="preserve">
          <source>Unless specified explicitly (with</source>
          <target state="translated">明示的に指定されていない限り(</target>
        </trans-unit>
        <trans-unit id="5eaa8563a22dc64db7ac666eb5d3e5ba11cc1996" translate="yes" xml:space="preserve">
          <source>Unlike Java, Objective-C does not allow for entire methods to be marked &lt;code&gt;@synchronized&lt;/code&gt;. Note that throwing exceptions out of &lt;code&gt;@synchronized&lt;/code&gt; blocks is allowed, and will cause the guarding object to be unlocked properly.</source>
          <target state="translated">Javaとは異なり、Objective-Cでは、メソッド全体を &lt;code&gt;@synchronized&lt;/code&gt; とマークすることはできません。 &lt;code&gt;@synchronized&lt;/code&gt; ブロックから例外をスローすることは許可されており、保護オブジェクトが適切にロック解除されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0cd317bbd72a217068977127c104995a9862be9b" translate="yes" xml:space="preserve">
          <source>Unlike for floating-point numbers in the decimal notation the exponent is always required in the hexadecimal notation. Otherwise the compiler would not be able to resolve the ambiguity of, e.g., &lt;code&gt;0x1.f&lt;/code&gt;. This could mean &lt;code&gt;1.0f&lt;/code&gt; or &lt;code&gt;1.9375&lt;/code&gt; since &amp;lsquo;</source>
          <target state="translated">10進表記の浮動小数点数とは異なり、16進表記では常に指数が必要です。そうでない場合、コンパイラーは、例えば &lt;code&gt;0x1.f&lt;/code&gt; のあいまいさを解決できません。これが意味するかもしれません &lt;code&gt;1.0f&lt;/code&gt; または &lt;code&gt;1.9375&lt;/code&gt; を &quot;ので、</target>
        </trans-unit>
        <trans-unit id="c540371c5127336fc94b6b29fa3c46f81c44897b" translate="yes" xml:space="preserve">
          <source>Unlike in C, in C++, flowing off the end of a non-&lt;code&gt;void&lt;/code&gt; function other than &lt;code&gt;main&lt;/code&gt; results in undefined behavior even when the value of the function is not used.</source>
          <target state="translated">Cとは異なり、C ++では、 &lt;code&gt;main&lt;/code&gt; 以外の &lt;code&gt;void&lt;/code&gt; 以外の関数の最後からフローすると、関数の値が使用されていない場合でも、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="2a830c95434f7db0cbf0fd8fd9277c1d051a3f31" translate="yes" xml:space="preserve">
          <source>Unnamed struct/union fields within structs/unions.</source>
          <target state="translated">構造体/ユニオン内の名前のない構造体/ユニオン・フィールド。</target>
        </trans-unit>
        <trans-unit id="205edf29824c8a0cb244fc56417458952c504c66" translate="yes" xml:space="preserve">
          <source>Unrecognized input files, not requiring compilation or assembly, are ignored.</source>
          <target state="translated">認識されていない入力ファイルは、コンパイルやアセンブリを必要としないため無視されます。</target>
        </trans-unit>
        <trans-unit id="a51fd22f926dc0631cc272a22033e9d7fec59c36" translate="yes" xml:space="preserve">
          <source>Unroll all loops, even if their number of iterations is uncertain when the loop is entered. This usually makes programs run more slowly.</source>
          <target state="translated">ループに入ったときに反復回数が不確定であっても、すべてのループをアンロールします。これは通常、プログラムの実行をより遅くします。</target>
        </trans-unit>
        <trans-unit id="fc450b83181b0c2161a73acfdbf2dc658513bec3" translate="yes" xml:space="preserve">
          <source>Unroll loops whose number of iterations can be determined at compile time or upon entry to the loop.</source>
          <target state="translated">反復回数がコンパイル時またはループへの入力時に決定されるループをアンロールします。</target>
        </trans-unit>
        <trans-unit id="ad4d059f80e723b4d81766ec66adc71e8b2e5c48" translate="yes" xml:space="preserve">
          <source>Unsigned 12-bit constant (0&amp;ndash;4095)</source>
          <target state="translated">符号なし12ビット定数（0〜4095）</target>
        </trans-unit>
        <trans-unit id="aec081f8e4cecc49f843970cd77df1a02a1c1643" translate="yes" xml:space="preserve">
          <source>Unsigned 16 bit integer (in the range 0 to 65535)</source>
          <target state="translated">符号なし16ビット整数(0~65535の範囲)</target>
        </trans-unit>
        <trans-unit id="01dcb67eb6663625a6596ec55251e6ebe419078e" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit constant</source>
          <target state="translated">符号なし16ビット定数</target>
        </trans-unit>
        <trans-unit id="005d69054eb4a9d53e3d7fc838909272fcdf1d1e" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit constant shifted left 16 bits (use &amp;lsquo;</source>
          <target state="translated">符号なし16ビット定数を左に16ビットシフト（ 'を使用</target>
        </trans-unit>
        <trans-unit id="803ea2cff434611bd7a889a5f8f4e2a80e2f6534" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit integer constant.</source>
          <target state="translated">符号なし16ビット整数定数。</target>
        </trans-unit>
        <trans-unit id="baffe105924a920d4f7c404a4974ebe483612051" translate="yes" xml:space="preserve">
          <source>Unsigned 3 bit integer (in the range 0 to 7)</source>
          <target state="translated">符号なし3ビット整数(0~7の範囲内</target>
        </trans-unit>
        <trans-unit id="5d0b43b79f775a23c99274c057849b2132918314" translate="yes" xml:space="preserve">
          <source>Unsigned 5 bit integer (in the range 0 to 31)</source>
          <target state="translated">符号なし5ビット整数(0~31の範囲内</target>
        </trans-unit>
        <trans-unit id="ee9e535a39880e194545226484f376dc9293656d" translate="yes" xml:space="preserve">
          <source>Unsigned 7 bit integer (in the range 0 to 127)</source>
          <target state="translated">符号なし7ビット整数(0~127の範囲内</target>
        </trans-unit>
        <trans-unit id="64587bc80a139da54c64da1869304a4854d6ae7d" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit constant (0&amp;ndash;255)</source>
          <target state="translated">符号なし8ビット定数（0〜255）</target>
        </trans-unit>
        <trans-unit id="389b98b2eb7e556938b37c1b397214bf77e480bb" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit integer constant (for &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; instructions).</source>
          <target state="translated">（符号なし8ビット整数定数 &lt;code&gt;in&lt;/code&gt; 及び &lt;code&gt;out&lt;/code&gt; 命令）。</target>
        </trans-unit>
        <trans-unit id="8f0359d8e4b83d3d17663b1351a70fc1f8166d35" translate="yes" xml:space="preserve">
          <source>Unsigned constant that fits in 4 bits</source>
          <target state="translated">4ビットに収まる符号なし定数</target>
        </trans-unit>
        <trans-unit id="2b90c224883efa79af0519ac0faa9b9d93afd6a8" translate="yes" xml:space="preserve">
          <source>Unsigned constant valid for BccUI instructions</source>
          <target state="translated">BccUI 命令で有効な符号なし定数</target>
        </trans-unit>
        <trans-unit id="6f39b25ebfb39b4238321ae23982857dd100a843" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 15-bit value.</source>
          <target state="translated">符号なしの即時15ビット値。</target>
        </trans-unit>
        <trans-unit id="643476a0dd6f53437ba7e1cc7fb664b7f588a51c" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 3-bit value.</source>
          <target state="translated">符号なしの即時3ビット値。</target>
        </trans-unit>
        <trans-unit id="45a42311f5f53acd8a7d22cb085352156026813a" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 4-bit value.</source>
          <target state="translated">符号なしの即時4ビット値。</target>
        </trans-unit>
        <trans-unit id="39b8bb86545b9e829db3c4d0a8f246e834af0861" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 5-bit value for movpi45 instruction with range 16&amp;ndash;47.</source>
          <target state="translated">範囲16〜47のmovpi45命令の符号なし即値5ビット値。</target>
        </trans-unit>
        <trans-unit id="899fe6e57441b37398096e6133a6ef0bf027d95b" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 5-bit value.</source>
          <target state="translated">符号なしの即時5ビット値。</target>
        </trans-unit>
        <trans-unit id="deb14acda231f891d200f45725f5e7e68bae6ef4" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 6-bit value constraint for addri36.sp instruction.</source>
          <target state="translated">addri36.sp命令のための符号なしの即時6ビット値制約。</target>
        </trans-unit>
        <trans-unit id="4d84bf34896cf4e54d3ca29c18d4eaac197e6b98" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 8-bit value.</source>
          <target state="translated">符号なしの即時8ビット値。</target>
        </trans-unit>
        <trans-unit id="0063ff83a123db3db2d8d12d6f824ef8fd590f5b" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 9-bit value.</source>
          <target state="translated">符号なしの即時9ビット値。</target>
        </trans-unit>
        <trans-unit id="39e06dafd3f0aedfc6583e0a42cd32ba3116cfa2" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;Executing code before main&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">上：&lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;メインの前にコードを実行する&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目次&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="a632eb28fbdc638221eda735f91ebefbd97cd0d5" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;MIPS SIMD Architecture (MSA) Support&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Up：&lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;MIPS SIMDアーキテクチャ（MSA）サポート&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;目次&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;索引&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="62c310f2ecc602f87c21d2fd813dc1c5d88ab539" translate="yes" xml:space="preserve">
          <source>Upon entering the &lt;code&gt;@synchronized&lt;/code&gt; block, a thread of execution shall first check whether a lock has been placed on the corresponding &lt;code&gt;guard&lt;/code&gt; object by another thread. If it has, the current thread shall wait until the other thread relinquishes its lock. Once &lt;code&gt;guard&lt;/code&gt; becomes available, the current thread will place its own lock on it, execute the code contained in the &lt;code&gt;@synchronized&lt;/code&gt; block, and finally relinquish the lock (thereby making &lt;code&gt;guard&lt;/code&gt; available to other threads).</source>
          <target state="translated">&lt;code&gt;@synchronized&lt;/code&gt; ブロックに入ると、実行スレッドはまず、対応する &lt;code&gt;guard&lt;/code&gt; オブジェクトが別のスレッドによってロックされているかどうかを確認します。持っている場合、現在のスレッドは、他のスレッドがロックを解放するまで待機します。一度 &lt;code&gt;guard&lt;/code&gt; 使用可能になる、現在のスレッドは、それに独自のロックを置くに含まれるコードを実行します &lt;code&gt;@synchronized&lt;/code&gt; ブロックを、そして最後に（それによって作るロックを放棄 &lt;code&gt;guard&lt;/code&gt; 他のスレッドに利用可能）。</target>
        </trans-unit>
        <trans-unit id="b8aaa5b821490b029c1a6fe5ed310256ca59552f" translate="yes" xml:space="preserve">
          <source>Upper floating point register (32-bit), floating point register (64-bit)</source>
          <target state="translated">上位浮動小数点レジスタ(32ビット)、浮動小数点レジスタ(64ビット</target>
        </trans-unit>
        <trans-unit id="06ee1205db8b9a4061f4febc2c51ef1b19f3d539" translate="yes" xml:space="preserve">
          <source>Usage of ISO string concatenation is detected.</source>
          <target state="translated">ISO 文字列連結の使用が検出されました。</target>
        </trans-unit>
        <trans-unit id="89c2b631459be5cbc1277d90f51cb2dcbd76dfd6" translate="yes" xml:space="preserve">
          <source>Use (do not use) &amp;lsquo;</source>
          <target state="translated">使用する（使用しない） '</target>
        </trans-unit>
        <trans-unit id="6c996ac92914ff016f27df663925672950a9f247" translate="yes" xml:space="preserve">
          <source>Use (do not use) GP-relative accesses for symbols that are known to be in a small data section; see</source>
          <target state="translated">小規模データセクションにあることがわかっているシンボルには、GP-相対アクセスを使用します(使用しないでください)。</target>
        </trans-unit>
        <trans-unit id="841162f62263bc7378cda3013dbe47b1df4ab93e" translate="yes" xml:space="preserve">
          <source>Use (do not use) MIPS Digital Media Extension instructions. This option can only be used when generating 64-bit code and requires hardware floating-point support to be enabled.</source>
          <target state="translated">MIPS Digital Media Extension 命令を使用します(使用しないでください)。このオプションは、64 ビット コードを生成する場合にのみ使用でき、ハードウェア浮動小数点サポートを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="b20024dc2d601c71b4e717f07d0f9b2a6822d063" translate="yes" xml:space="preserve">
          <source>Use (do not use) MT Multithreading instructions.</source>
          <target state="translated">MTマルチスレッド命令を使用する(使用しない)。</target>
        </trans-unit>
        <trans-unit id="4c4c87eb21af6765217c1c52b2b2d0c31fe5b0c7" translate="yes" xml:space="preserve">
          <source>Use (do not use) assembler relocation operators when dealing with symbolic addresses. The alternative, selected by</source>
          <target state="translated">シンボリックアドレスを扱う場合は、アセンブラの再配置演算子を使用してください(使用しないでください)。で選択された代替手段は</target>
        </trans-unit>
        <trans-unit id="e2fb9fc1fd117af3b437fc4e8c7a5214e20addd7" translate="yes" xml:space="preserve">
          <source>Use (do not use) paired-single floating-point instructions. See &lt;a href=&quot;mips-paired_002dsingle-support#MIPS-Paired_002dSingle-Support&quot;&gt;MIPS Paired-Single Support&lt;/a&gt;. This option requires hardware floating-point support to be enabled.</source>
          <target state="translated">ペアの単一浮動小数点命令を使用します（使用しません）。&lt;a href=&quot;mips-paired_002dsingle-support#MIPS-Paired_002dSingle-Support&quot;&gt;MIPSペアシングルサポートを&lt;/a&gt;参照してください。このオプションでは、ハードウェア浮動小数点サポートを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="f6259aa651c4c62a1528ed119090031f79dd3a9c" translate="yes" xml:space="preserve">
          <source>Use (do not use) revision 1 of the MIPS DSP ASE. See &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP Built-in Functions&lt;/a&gt;. This option defines the preprocessor macro &lt;code&gt;__mips_dsp&lt;/code&gt;. It also defines &lt;code&gt;__mips_dsp_rev&lt;/code&gt; to 1.</source>
          <target state="translated">MIPS DSP ASEのリビジョン1を使用します（使用しません）。&lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP組み込み関数を&lt;/a&gt;参照してください。このオプションは、プリプロセッサマクロ &lt;code&gt;__mips_dsp&lt;/code&gt; を定義します。また、 &lt;code&gt;__mips_dsp_rev&lt;/code&gt; を1に定義します。</target>
        </trans-unit>
        <trans-unit id="84f11c6cd6e5cf30011af44cf15833421d85ad29" translate="yes" xml:space="preserve">
          <source>Use (do not use) revision 2 of the MIPS DSP ASE. See &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP Built-in Functions&lt;/a&gt;. This option defines the preprocessor macros &lt;code&gt;__mips_dsp&lt;/code&gt; and &lt;code&gt;__mips_dspr2&lt;/code&gt;. It also defines &lt;code&gt;__mips_dsp_rev&lt;/code&gt; to 2.</source>
          <target state="translated">MIPS DSP ASEのリビジョン2を使用します（使用しません）。&lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP組み込み関数を&lt;/a&gt;参照してください。このオプションは、プリプロセッサマクロ &lt;code&gt;__mips_dsp&lt;/code&gt; および &lt;code&gt;__mips_dspr2&lt;/code&gt; を定義します。また、 &lt;code&gt;__mips_dsp_rev&lt;/code&gt; を2に定義します。</target>
        </trans-unit>
        <trans-unit id="f05f23d689cc06c1b3087b4a4cee4ab4e3b531c1" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Cyclic Redundancy Check (CRC) instructions.</source>
          <target state="translated">MIPS 巡回冗長検査(CRC)命令を使用する(使用しない)。</target>
        </trans-unit>
        <trans-unit id="41957dbedef9adbd80884a4e90cb75e57229baa1" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Enhanced Virtual Addressing instructions.</source>
          <target state="translated">MIPS 拡張仮想アドレス指定命令を使用します(使用しないでください)。</target>
        </trans-unit>
        <trans-unit id="d449a2af21b4cd68389988954d474d0704ce78ae" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Global INValidate (GINV) instructions.</source>
          <target state="translated">MIPS Global INValidate(GINV)命令を使用する(使用しない)。</target>
        </trans-unit>
        <trans-unit id="321d2808ff8ddfa8d27e08fae5ef2b18bb82a26d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson EXTensions (EXT) instructions.</source>
          <target state="translated">MIPS Loongson EXTensions (EXT)の説明書を使用してください(使用しないでください)。</target>
        </trans-unit>
        <trans-unit id="7e1498ad7af62c3d7182f6f503ffa752981eda71" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson EXTensions r2 (EXT2) instructions.</source>
          <target state="translated">MIPS Loongson EXTensions r2(EXT2)の命令を使用する(使用しない)。</target>
        </trans-unit>
        <trans-unit id="2dd360e823e7db9203619f4657c5c205b972d79d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson MultiMedia extensions Instructions (MMI).</source>
          <target state="translated">MIPS Loongson MultiMedia extensions Instructions(MMI)を使用してください(使用しないでください)。</target>
        </trans-unit>
        <trans-unit id="5f61baef9b142c63c1358980a670d3440a0eab96" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS MCU ASE instructions.</source>
          <target state="translated">MIPS MCU ASE命令を使用してください(使用しないでください)。</target>
        </trans-unit>
        <trans-unit id="8ec8692f1855f7387d01c2d894055d7cd55aa28a" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS SmartMIPS ASE.</source>
          <target state="translated">MIPS SmartMIPS ASEを使用する(使用しない)。</target>
        </trans-unit>
        <trans-unit id="5ea0be9e9db2179c015e95d8d46f2c8b505a9fe4" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Virtualization (VZ) instructions.</source>
          <target state="translated">MIPS Virtualization (VZ)の指示を使用します(使用しないでください)。</target>
        </trans-unit>
        <trans-unit id="a2cdb6f5e1b2e85269c8ddd06af937bfeb499e18" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS eXtended Physical Address (XPA) instructions.</source>
          <target state="translated">MIPS eXtended Physical Address (XPA)命令を使用します (使用しないでください)。</target>
        </trans-unit>
        <trans-unit id="36354659118438f767b17fe9c67973e669f59454" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS-3D ASE. See &lt;a href=&quot;mips_002d3d-built_002din-functions#MIPS_002d3D-Built_002din-Functions&quot;&gt;MIPS-3D Built-in Functions&lt;/a&gt;. The option</source>
          <target state="translated">MIPS-3D ASEを使用します（使用しません）。&lt;a href=&quot;mips_002d3d-built_002din-functions#MIPS_002d3D-Built_002din-Functions&quot;&gt;MIPS-3D組み込み関数を&lt;/a&gt;参照してください。オプション</target>
        </trans-unit>
        <trans-unit id="9ef75b208cd56b64585639240694bc21bc152e3d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware decimal-floating-point instructions for decimal-floating-point operations. When</source>
          <target state="translated">10進浮動小数点演算には、ハードウェアの10進浮動小数点命令を使用してください(使用しないでください)。以下のような場合には</target>
        </trans-unit>
        <trans-unit id="bf41f711c39d909ef84416fdb9864104894d7725" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware floating-point instructions and registers for floating-point operations. When</source>
          <target state="translated">浮動小数点演算には、ハードウェアの浮動小数点命令とレジスタを使用してください(使用しないでください)。演算を行う際には</target>
        </trans-unit>
        <trans-unit id="de7cd0fb38e7a6dbf8bf51e3e0d617effe989eb9" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware floating-point instructions for floating-point operations. When</source>
          <target state="translated">浮動小数点演算には、ハードウェア浮動小数点命令を使用してください(使用しないでください)。演算を行う際には</target>
        </trans-unit>
        <trans-unit id="bd5d0dcb1bead4c9931bcc516462cf8c519e7f83" translate="yes" xml:space="preserve">
          <source>Use (do not use) the packed stack layout. When</source>
          <target state="translated">パックされたスタックレイアウトを使用する(使用しない)。を使用する場合は</target>
        </trans-unit>
        <trans-unit id="cbc7bc66fe33b21f66fff87d1b33e82b9091e241" translate="yes" xml:space="preserve">
          <source>Use (do not use) the probable-branch instructions, when static branch prediction indicates a probable branch.</source>
          <target state="translated">静的な分岐予測が分岐の可能性があることを示している場合は、分岐可能性のある命令を使用してください(使用しないでください)。</target>
        </trans-unit>
        <trans-unit id="f319b3952ec422e138086d2e7e1d3e6616dd87b3" translate="yes" xml:space="preserve">
          <source>Use 16-bit &lt;code&gt;int&lt;/code&gt;. This is the default.</source>
          <target state="translated">16ビット &lt;code&gt;int&lt;/code&gt; 使用します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="89aa31a04c6ac47e58631515dc9a5eacae0d2be9" translate="yes" xml:space="preserve">
          <source>Use 32-bit &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">32ビット &lt;code&gt;int&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="41a727b715072a7a83f64450d014d46413f9d7b5" translate="yes" xml:space="preserve">
          <source>Use 32-bit offsets in &lt;code&gt;switch&lt;/code&gt; tables. The default is to use 16-bit offsets.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; テーブルで32ビットオフセットを使用します。デフォルトでは、16ビットのオフセットを使用します。</target>
        </trans-unit>
        <trans-unit id="88f9f3c158d922b7a42c33cd301395b97a6091ab" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;brk_interrupt&lt;/code&gt; instead of &lt;code&gt;interrupt&lt;/code&gt; for handlers intended to be used with the &lt;code&gt;BRK&lt;/code&gt; opcode (i.e. those that must end with &lt;code&gt;RETB&lt;/code&gt; instead of &lt;code&gt;RETI&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;BRK&lt;/code&gt; オペコードで使用することを目的としたハンドラー（つまり、 &lt;code&gt;RETI&lt;/code&gt; ではなく &lt;code&gt;RETB&lt;/code&gt; で終了する必要があるハンドラー）については、 &lt;code&gt;interrupt&lt;/code&gt; 代わりに &lt;code&gt;brk_interrupt&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a90fcb500090afb38bb3e24622641ed3199bfbe3" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;class-name&lt;/var&gt; as the name of the class to instantiate for each literal string specified with the syntax &lt;code&gt;@&quot;&amp;hellip;&quot;&lt;/code&gt;. The default class name is &lt;code&gt;NXConstantString&lt;/code&gt; if the GNU runtime is being used, and &lt;code&gt;NSConstantString&lt;/code&gt; if the NeXT runtime is being used (see below). The</source>
          <target state="translated">構文 &lt;code&gt;@&quot;&amp;hellip;&quot;&lt;/code&gt; 指定されたリテラル文字列ごとにインスタンス化する &lt;var&gt;class-name&lt;/var&gt; としてclass-nameを使用します。デフォルトのクラス名がされ &lt;code&gt;NXConstantString&lt;/code&gt; GNUランタイムが使用されている場合、および &lt;code&gt;NSConstantString&lt;/code&gt; NeXTのランタイムが使用されている場合（下記参照します）。の</target>
        </trans-unit>
        <trans-unit id="eb4639975214bd02baed9aee7811250d9713b6c2" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as a subdirectory of the directory containing target-specific C++ headers.</source>
          <target state="translated">ターゲット固有のC ++ヘッダーを含むディレクトリのサブディレクトリとして &lt;var&gt;dir&lt;/var&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="6e0e3e325ab15f9c4ea6c1c5a12adf0dc5651ccc" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as the logical root directory for headers and libraries. For example, if the compiler normally searches for headers in</source>
          <target state="translated">ヘッダーとライブラリの論理ルートディレクトリとして &lt;var&gt;dir&lt;/var&gt; を使用します。たとえば、コンパイラが通常ヘッダーを検索する場合</target>
        </trans-unit>
        <trans-unit id="6f28e148765dfa527c350e4d6f8a2d064b3f5447" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;script&lt;/var&gt; as the linker script. This option is supported by most systems using the GNU linker. On some targets, such as bare-board targets without an operating system, the</source>
          <target state="translated">リンカー &lt;var&gt;script&lt;/var&gt; としてスクリプトを使用します。このオプションは、GNUリンカーを使用するほとんどのシステムでサポートされています。オペレーティングシステムのないベアボードターゲットなど、一部のターゲットでは、</target>
        </trans-unit>
        <trans-unit id="603c63161e45119aff170517df5f944adaf08316" translate="yes" xml:space="preserve">
          <source>Use Bionic C library. This is the default on &amp;lsquo;</source>
          <target state="translated">Bionic Cライブラリを使用します。これは 'のデフォルトです</target>
        </trans-unit>
        <trans-unit id="e1b7e66656ee6fc5c3b9eff78bd1af4ab51c4a01" translate="yes" xml:space="preserve">
          <source>Use DEC assembler syntax.</source>
          <target state="translated">DECアセンブラ構文を使用します。</target>
        </trans-unit>
        <trans-unit id="cf5c1a8e637cc6c211fb5b791033642a96c7344a" translate="yes" xml:space="preserve">
          <source>Use GNU assembler syntax. This is the default.</source>
          <target state="translated">GNU アセンブラ構文を使用します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="4ca68a7754f649f50b2ce419251af4261f6f0855" translate="yes" xml:space="preserve">
          <source>Use GP-relative &lt;code&gt;.sdata&lt;/code&gt;/&lt;code&gt;.sbss&lt;/code&gt; sections.</source>
          <target state="translated">GP相対の &lt;code&gt;.sdata&lt;/code&gt; / &lt;code&gt;.sbss&lt;/code&gt; セクションを使用します。</target>
        </trans-unit>
        <trans-unit id="5a4f813886fea8ad38a8f2df1482e30df599c3e3" translate="yes" xml:space="preserve">
          <source>Use IRA to evaluate register pressure in loops for decisions to move loop invariants. This option usually results in generation of faster and smaller code on machines with large register files (&amp;gt;= 32 registers), but it can slow the compiler down.</source>
          <target state="translated">IRAを使用して、ループ内のレジスター圧力を評価し、ループ不変量を移動する決定を行います。このオプションを使用すると、通常、大きなレジスタファイル（32以上のレジスタ）を備えたマシンでより高速で小さなコードが生成されますが、コンパイラの速度が低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9fa83817840cfc83225757a8f388ff5927c560a5" translate="yes" xml:space="preserve">
          <source>Use IRA to evaluate register pressure in the code hoisting pass for decisions to hoist expressions. This option usually results in smaller code, but it can slow the compiler down.</source>
          <target state="translated">IRA を使用して、式をホイストするかどうかを決定するためのコード・ホイスト・パスのレジスタ圧を評価します。このオプションを使用すると、通常はコードが小さくなりますが、コンパイラの動作が遅くなることがあります。</target>
        </trans-unit>
        <trans-unit id="cf05afd7829c886cb42acb12e1e8f5c401d38cca" translate="yes" xml:space="preserve">
          <source>Use PC-relative switch case tables to enable case table shortening. This is the default for</source>
          <target state="translated">PC 相対スイッチのケーステーブルを使用して、ケーステーブルの短縮を有効にします。のデフォルトです。</target>
        </trans-unit>
        <trans-unit id="00b72e087f73e29c719a0c570f2c43c4886f6d49" translate="yes" xml:space="preserve">
          <source>Use PUSH operations to store outgoing parameters. This method is shorter and usually equally fast as method using SUB/MOV operations and is enabled by default. In some cases disabling it may improve performance because of improved scheduling and reduced dependencies.</source>
          <target state="translated">PUSH 操作を使用して、送信パラメータを保存します。この方法は、SUB/MOV 演算を使用する方法と同じくらい短く、通常は同じくらい高速で、デフォルトで有効になっています。場合によっては、これを無効にすると、スケジューリングが改善され、依存関係が減るため、パフォーマンスが向上することがあります。</target>
        </trans-unit>
        <trans-unit id="3d45d39c4ac78022d817a61ee97d331c721c6435" translate="yes" xml:space="preserve">
          <source>Use SSE register passing conventions for float and double arguments and return values. You can control this behavior for a specific function by using the function attribute &lt;code&gt;sseregparm&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">floatおよびdoubleの引数と戻り値には、SSEレジスター引き渡し規則を使用します。関数属性 &lt;code&gt;sseregparm&lt;/code&gt; を使用して、特定の関数のこの動作を制御できます。&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b404c19baa5a518d1cdcd1a18e31cedc71ed3a2b" translate="yes" xml:space="preserve">
          <source>Use TLS descriptors as the thread-local storage mechanism for dynamic accesses of TLS variables. This is the default.</source>
          <target state="translated">TLS 変数の動的アクセスのスレッドローカルストレージメカニズムとして TLS 記述子を使用します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="e3576757916332969b16cf2fe6a0dad2cf57cc25" translate="yes" xml:space="preserve">
          <source>Use Unix assembler syntax.</source>
          <target state="translated">Unixアセンブラの構文を使用します。</target>
        </trans-unit>
        <trans-unit id="203b2b8006e8188de9ec3c4dca584f80e20ca5d1" translate="yes" xml:space="preserve">
          <source>Use a different function-calling convention, in which functions that take a fixed number of arguments return with the &lt;code&gt;ret &lt;var&gt;num&lt;/var&gt;&lt;/code&gt; instruction, which pops their arguments while returning. This saves one instruction in the caller since there is no need to pop the arguments there.</source>
          <target state="translated">別の関数呼び出し規約を使用します。固定数の引数を取る関数は、 &lt;code&gt;ret &lt;var&gt;num&lt;/var&gt;&lt;/code&gt; 引数をポップするret num命令で戻ります。これにより、引数をポップする必要がないため、呼び出し元の1つの命令が節約されます。</target>
        </trans-unit>
        <trans-unit id="da4193d8552139570f953ba462e87b5070659dde" translate="yes" xml:space="preserve">
          <source>Use a different function-calling convention, in which functions that take a fixed number of arguments return with the &lt;code&gt;rtd&lt;/code&gt; instruction, which pops their arguments while returning. This saves one instruction in the caller since there is no need to pop the arguments there.</source>
          <target state="translated">別の関数呼び出し規約を使用します。この場合、一定数の引数を取る関数は、戻り中に引数をポップする &lt;code&gt;rtd&lt;/code&gt; 命令で戻ります。これにより、引数をポップする必要がないため、呼び出し元の1つの命令が節約されます。</target>
        </trans-unit>
        <trans-unit id="331cc29755f1e26195a1d5ecc670eb6f5d017ee2" translate="yes" xml:space="preserve">
          <source>Use a simple check for control speculation. This option is on by default.</source>
          <target state="translated">制御投機のための簡単なチェックを使用します。このオプションはデフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="d6f85727b6057ae83760d6f97594f9ace81b0f7f" translate="yes" xml:space="preserve">
          <source>Use a simple data speculation check. This option is on by default.</source>
          <target state="translated">単純なデータ推測チェックを使用します。このオプションはデフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="ca6587349df9a9ae271539d7763d513420cd65bb" translate="yes" xml:space="preserve">
          <source>Use a suffix in a fixed-point literal constant:</source>
          <target state="translated">固定小数点リテラル定数で接尾辞を使用します。</target>
        </trans-unit>
        <trans-unit id="0eca7aa56a0b3e6cf63ecaa0b25877af246ac580" translate="yes" xml:space="preserve">
          <source>Use address register &lt;code&gt;X&lt;/code&gt; in a way proposed by the hardware. This means that &lt;code&gt;X&lt;/code&gt; is only used in indirect, post-increment or pre-decrement addressing.</source>
          <target state="translated">ハードウェアが提案する方法でアドレスレジスタ &lt;code&gt;X&lt;/code&gt; を使用します。つまり、 &lt;code&gt;X&lt;/code&gt; は、間接、インクリメント後、またはデクリメント前のアドレス指定でのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="3b89385a22047536803090fc547fb07c50377d4f" translate="yes" xml:space="preserve">
          <source>Use all 64 floating-point registers.</source>
          <target state="translated">64個の浮動小数点レジスタをすべて使用します。</target>
        </trans-unit>
        <trans-unit id="feaeb911667dc1becc91e63f2c1dd1a8d7da1545" translate="yes" xml:space="preserve">
          <source>Use all 64 general-purpose registers.</source>
          <target state="translated">64個の汎用レジスタをすべて使用します。</target>
        </trans-unit>
        <trans-unit id="b82e484b31c31a6751f032044a77e4b8d923804b" translate="yes" xml:space="preserve">
          <source>Use all eight media accumulator registers.</source>
          <target state="translated">8つのメディアアキュムレータレジスタをすべて使用します。</target>
        </trans-unit>
        <trans-unit id="2f6df81f72a01bee304049bedcc53aa9e70e7e34" translate="yes" xml:space="preserve">
          <source>Use all functions as a single region. This typically results in the smallest code size, and is enabled by default for</source>
          <target state="translated">すべての関数を単一の領域として使用します。これは一般的にコードサイズを最小にすることができ、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="ba424a2a390669d654a999945050b535cb620662" translate="yes" xml:space="preserve">
          <source>Use all loops as register allocation regions. This can give the best results for machines with a small and/or irregular register set.</source>
          <target state="translated">すべてのループをレジスタ割り当て領域として使用します。これは、レジスタセットが小さいおよび/または不規則なレジスタセットを持つマシンに最適な結果を与えることができます。</target>
        </trans-unit>
        <trans-unit id="a043a5ff8ff9ce3ddafabde6a2ea3b417ae65cc6" translate="yes" xml:space="preserve">
          <source>Use all loops except for loops with small register pressure as the regions. This value usually gives the best results in most cases and for most architectures, and is enabled by default when compiling with optimization for speed (</source>
          <target state="translated">レジスタ圧が小さいループを除くすべてのループをリージョンとして使用します。この値は通常、ほとんどの場合とほとんどのアーキテクチャで最良の結果をもたらします。</target>
        </trans-unit>
        <trans-unit id="812a6d3805650c2a1098b0f9c55012ae713394e0" translate="yes" xml:space="preserve">
          <source>Use caller save registers for allocation if those registers are not used by any called function. In that case it is not necessary to save and restore them around calls. This is only possible if called functions are part of same compilation unit as current function and they are compiled before it.</source>
          <target state="translated">呼び出された関数で使用されない場合は、呼び出し元のセーブレジスタを使用して割り当てを行います。その場合、呼び出しの際にレジスタを保存したり復元したりする必要はありません。これは、呼び出された関数が現在の関数と同じコンパイルユニットの一部であり、その前にコンパイルされている場合にのみ可能です。</target>
        </trans-unit>
        <trans-unit id="4382016563c1274a421ee87c295b12ebd4559c24" translate="yes" xml:space="preserve">
          <source>Use color in diagnostics. &lt;var&gt;WHEN&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">診断に色を使用します。 &lt;var&gt;WHEN&lt;/var&gt; は '</target>
        </trans-unit>
        <trans-unit id="40d7328de5846368928e724db703acd82494276b" translate="yes" xml:space="preserve">
          <source>Use colors for lines of code that have zero coverage. We use red color for non-exceptional lines and cyan for exceptional. Same colors are used for basic blocks with</source>
          <target state="translated">カバレッジがゼロのコード行には色を使います。非例外的な行には赤、例外的な行にはシアンを使用します。基本的なブロックには同じ色を使用します。</target>
        </trans-unit>
        <trans-unit id="b78480b3c04e31f02a22c6b9fc0432c39f656a99" translate="yes" xml:space="preserve">
          <source>Use conditional execution (where available) to transform conditional jumps into branch-less equivalents.</source>
          <target state="translated">条件付きジャンプをブランチレスの等価物に変換するために、条件付き実行を使用します(利用可能な場合)。</target>
        </trans-unit>
        <trans-unit id="cfd175a21aedd34017c2ac1e6f5bcb8597ba832d" translate="yes" xml:space="preserve">
          <source>Use features of, and schedule code for, the given CPU. Supported values are in the format &amp;lsquo;</source>
          <target state="translated">指定されたCPUの機能を使用し、コードをスケジュールします。サポートされている値の形式は '</target>
        </trans-unit>
        <trans-unit id="3784fc1428664a00120c0092c2a68e1d52938803" translate="yes" xml:space="preserve">
          <source>Use floating-point coprocessor instructions.</source>
          <target state="translated">浮動小数点コプロセッサ命令を使用します。</target>
        </trans-unit>
        <trans-unit id="b74dc5c253b5d41873111acddddd0a6e12b4df73" translate="yes" xml:space="preserve">
          <source>Use floating-point double instructions.</source>
          <target state="translated">浮動小数点倍数命令を使用します。</target>
        </trans-unit>
        <trans-unit id="92af032aeee5f8e42b7b1aaa0f92eee3c63e96e3" translate="yes" xml:space="preserve">
          <source>Use full-set registers for register allocation.</source>
          <target state="translated">レジスタの割り当てにはフルセットレジスタを使用します。</target>
        </trans-unit>
        <trans-unit id="16451ea3ea1710752acecdfbc9b28aca9f971795" translate="yes" xml:space="preserve">
          <source>Use hardware FPP floating point. This is the default. (FIS floating point on the PDP-11/40 is not supported.) Implies -m45.</source>
          <target state="translated">ハードウェアFPP浮動小数点を使用します。これがデフォルトです。(PDP-11/40 の FIS 浮動小数点はサポートされていません。)-m45 を意味します。</target>
        </trans-unit>
        <trans-unit id="1d53b0a05bad4ee0582a36e272217d96ad44c641" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point conversion instructions.</source>
          <target state="translated">ハードウェア浮動小数点変換命令を使用します。</target>
        </trans-unit>
        <trans-unit id="7c8d9f72c2a09e8bf637992aee381f0538cc91ce" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point instructions.</source>
          <target state="translated">ハードウェア浮動小数点命令を使用します。</target>
        </trans-unit>
        <trans-unit id="0a53c63d0196fe12e50c8354a0f08f23a9436376" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point square root instruction.</source>
          <target state="translated">ハードウェア浮動小数点平方根命令を使用します。</target>
        </trans-unit>
        <trans-unit id="9299be4448e9c807bf8ea8d91a628cfcd14cfa8d" translate="yes" xml:space="preserve">
          <source>Use hardware instructions for floating-point operations.</source>
          <target state="translated">浮動小数点演算にはハードウェア命令を使用します。</target>
        </trans-unit>
        <trans-unit id="d1208904e1c443035a1b8ffe0c523b26cf7b7a8b" translate="yes" xml:space="preserve">
          <source>Use indirect addressing to call functions outside the current compilation unit. This allows the functions to be placed anywhere within the 32-bit address space.</source>
          <target state="translated">間接アドレッシングを使用して、現在のコンパイル・ユニットの外にある関数を呼び出すことができます。これにより、32ビットアドレス空間内の任意の場所に関数を配置することができます。</target>
        </trans-unit>
        <trans-unit id="78fc9788b47e65039b1b1b871970de2bb141152a" translate="yes" xml:space="preserve">
          <source>Use large-model addressing (20-bit pointers, 32-bit &lt;code&gt;size_t&lt;/code&gt;).</source>
          <target state="translated">大規模モデルのアドレス指定（20ビットポインター、32ビット &lt;code&gt;size_t&lt;/code&gt; ）を使用します。</target>
        </trans-unit>
        <trans-unit id="da84f773a2b422eeb1cc59880ada32d1f5127685" translate="yes" xml:space="preserve">
          <source>Use library routines for floating-point operations.</source>
          <target state="translated">浮動小数点演算にはライブラリルーチンを使用します。</target>
        </trans-unit>
        <trans-unit id="089ac39a7bb68a3ed32ee7b6986eee393acae4e9" translate="yes" xml:space="preserve">
          <source>Use media instructions.</source>
          <target state="translated">メディアの指示を使用してください。</target>
        </trans-unit>
        <trans-unit id="0eb15f40fe2c97b8f815cbb7844e284b610d0dac" translate="yes" xml:space="preserve">
          <source>Use multiply and add/subtract instructions.</source>
          <target state="translated">掛け算と加減算の指示を使用します。</target>
        </trans-unit>
        <trans-unit id="3113eba3d237f18c9452620ae8a871803037c9fe" translate="yes" xml:space="preserve">
          <source>Use multiply high instructions for high part of 32x32 multiply.</source>
          <target state="translated">32x32乗算の上位部分には乗算上位命令を使用します。</target>
        </trans-unit>
        <trans-unit id="274542aa04ed64b151c2d6a22c787feacea52bb1" translate="yes" xml:space="preserve">
          <source>Use of ISO C style function definitions. This warning intentionally is &lt;em&gt;not&lt;/em&gt; issued for prototype declarations or variadic functions because these ISO C features appear in your code when using libiberty&amp;rsquo;s traditional C compatibility macros, &lt;code&gt;PARAMS&lt;/code&gt; and &lt;code&gt;VPARAMS&lt;/code&gt;. This warning is also bypassed for nested functions because that feature is already a GCC extension and thus not relevant to traditional C compatibility.</source>
          <target state="translated">ISO Cスタイルの関数定義の使用。libibertyの従来のC互換マクロである &lt;code&gt;PARAMS&lt;/code&gt; および &lt;code&gt;VPARAMS&lt;/code&gt; を使用すると、これらのISO C機能がコードに表示されるため、この警告はプロトタイプ宣言または可変関数に対して意図的に発行され&lt;em&gt;ません&lt;/em&gt;。この警告は、ネストされた関数についてもバイパスされます。その機能はすでにGCC拡張であり、従来のCの互換性には関係がないためです。</target>
        </trans-unit>
        <trans-unit id="158fc2002245113de73abd265a7ea7ceaec3a883" translate="yes" xml:space="preserve">
          <source>Use of these options requires the</source>
          <target state="translated">これらのオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="c4cc269c9473450b3919e9b442477125758842d4" translate="yes" xml:space="preserve">
          <source>Use only (or not only) &lt;code&gt;JSR&lt;/code&gt; instructions to access functions. This option can be used when code size exceeds the range of &lt;code&gt;BSR&lt;/code&gt; instructions. Note that</source>
          <target state="translated">関数にアクセスするには、 &lt;code&gt;JSR&lt;/code&gt; 命令のみ（またはそれだけではない）を使用します。このオプションは、コードサイズが &lt;code&gt;BSR&lt;/code&gt; 命令の範囲を超える場合に使用できます。ご了承ください</target>
        </trans-unit>
        <trans-unit id="3d7a23d4b8552ff506438fdaad793f73e9ba8b5c" translate="yes" xml:space="preserve">
          <source>Use only the first 32 floating-point registers.</source>
          <target state="translated">最初の32個の浮動小数点レジスタのみを使用します。</target>
        </trans-unit>
        <trans-unit id="514349ebdaf390b152f0baa20866afbb16f28603" translate="yes" xml:space="preserve">
          <source>Use only the first four media accumulator registers.</source>
          <target state="translated">最初の4つのメディアアキュムレータレジスタのみを使用します。</target>
        </trans-unit>
        <trans-unit id="dbcdb22850ebf5d2eaa31bb7774cbe3b9ea3b9b1" translate="yes" xml:space="preserve">
          <source>Use options specific to GNU &lt;code&gt;ld&lt;/code&gt;. This passes</source>
          <target state="translated">GNU &lt;code&gt;ld&lt;/code&gt; 固有のオプションを使用します。これは合格</target>
        </trans-unit>
        <trans-unit id="d0990e1967b634e363212e972c2e0f4cff8a380b" translate="yes" xml:space="preserve">
          <source>Use options specific to HP &lt;code&gt;ld&lt;/code&gt;. This passes</source>
          <target state="translated">HP &lt;code&gt;ld&lt;/code&gt; 固有のオプションを使用します。これは合格</target>
        </trans-unit>
        <trans-unit id="b612fc229c98c8b45507f89276f4127d6c212de2" translate="yes" xml:space="preserve">
          <source>Use or do not use assembler relocation operators when dealing with symbolic addresses. The alternative is to use assembler macros instead, which may limit optimization.</source>
          <target state="translated">シンボリックアドレスを扱う際には、アセンブラの再配置演算子を使用するかしないかを指定します。代わりにアセンブラマクロを使用することもできますが、これは最適化を制限する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0d238a2890f95ffe47564d56929f04ca231d7f2f" translate="yes" xml:space="preserve">
          <source>Use ordinarily cached memory accesses for volatile references. This is the default.</source>
          <target state="translated">揮発性参照には、通常のキャッシュされたメモリアクセスを使用します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="561289d64c63454cbaa3cc42d60da8f4f3023750" translate="yes" xml:space="preserve">
          <source>Use pattern compare instructions.</source>
          <target state="translated">パターン比較の指示を使用します。</target>
        </trans-unit>
        <trans-unit id="040518cc797faf0101d0aa9c313c620444e4ee87" translate="yes" xml:space="preserve">
          <source>Use pipes rather than temporary files for communication between the various stages of compilation. This fails to work on some systems where the assembler is unable to read from a pipe; but the GNU assembler has no trouble.</source>
          <target state="translated">コンパイルの様々な段階間の通信に一時ファイルではなくパイプを使ってください。これは、アセンブラがパイプから読むことができないシステムでは動作しませんが、GNUアセンブラでは問題ありません。</target>
        </trans-unit>
        <trans-unit id="f48e58d8b4ccb76ce170698e169b17f602f7b800" translate="yes" xml:space="preserve">
          <source>Use reduced-set registers for register allocation.</source>
          <target state="translated">レジスタの割り当てには、リダクションセットレジスタを使用します。</target>
        </trans-unit>
        <trans-unit id="2593d8520ea117d76ab84232fac04161f6934239" translate="yes" xml:space="preserve">
          <source>Use reorder instructions (swap and byte reversed load/store).</source>
          <target state="translated">並び替え指示(スワップとバイト反転ロード/ストア)を使用します。</target>
        </trans-unit>
        <trans-unit id="e07ac16585fa1254cfa0cb9da67063979e26bb7c" translate="yes" xml:space="preserve">
          <source>Use scalar floating-point instructions present in the SSE instruction set. This instruction set is supported by Pentium III and newer chips, and in the AMD line by Athlon-4, Athlon XP and Athlon MP chips. The earlier version of the SSE instruction set supports only single-precision arithmetic, thus the double and extended-precision arithmetic are still done using 387. A later version, present only in Pentium 4 and AMD x86-64 chips, supports double-precision arithmetic too.</source>
          <target state="translated">SSE 命令セットに含まれるスカラー浮動小数点命令を使用します。この命令セットはPentium III以降のチップでサポートされており、AMDラインではAthlon-4、Athlon XP、Athlon MPチップでサポートされています。以前のバージョンのSSE命令セットは単精度演算のみをサポートしており、倍精度演算や拡張精度演算は387を使用して行われます。後のバージョンでは、Pentium 4 と AMD x86-64 チップにのみ搭載されており、倍精度演算もサポートしています。</target>
        </trans-unit>
        <trans-unit id="d6e4ef6e570b37c45555a81f6cdc377b4bae049b" translate="yes" xml:space="preserve">
          <source>Use small-model addressing (16-bit pointers, 16-bit &lt;code&gt;size_t&lt;/code&gt;).</source>
          <target state="translated">小規模モデルのアドレス指定（16ビットポインター、16ビット &lt;code&gt;size_t&lt;/code&gt; ）を使用します。</target>
        </trans-unit>
        <trans-unit id="427046297d0e2e2fa23aa9bbce2f51b1069e5680" translate="yes" xml:space="preserve">
          <source>Use software emulation for divides (default).</source>
          <target state="translated">分割にはソフトウェアエミュレーションを使用します(デフォルト)。</target>
        </trans-unit>
        <trans-unit id="28d4c98240044920040873705d9156aeeb423961" translate="yes" xml:space="preserve">
          <source>Use software emulation for floating point (default).</source>
          <target state="translated">浮動小数点用のソフトウェアエミュレーションを使用します(デフォルト)。</target>
        </trans-unit>
        <trans-unit id="1da6f7e54a7af9cc7e53be95e1caa19cec640f21" translate="yes" xml:space="preserve">
          <source>Use software multiply emulation (default).</source>
          <target state="translated">ソフトウェアの乗算エミュレーション(デフォルト)を使用します。</target>
        </trans-unit>
        <trans-unit id="51ebd4110af8f919b9d1120fda4a348de24109ee" translate="yes" xml:space="preserve">
          <source>Use specified regions for the integrated register allocator. The &lt;var&gt;region&lt;/var&gt; argument should be one of the following:</source>
          <target state="translated">統合レジスタアロケータに指定された領域を使用します。 &lt;var&gt;region&lt;/var&gt; 引数は、次のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="8bf48e2b51779d631071d9653fad6d3f53bf023b" translate="yes" xml:space="preserve">
          <source>Use table lookup optimization for small signed integer divisions.</source>
          <target state="translated">小さな符号付き整数除算のためのテーブルルックアップ最適化を使用します。</target>
        </trans-unit>
        <trans-unit id="22aeb5074275903d6cc2bc285a95ec6de6392b7d" translate="yes" xml:space="preserve">
          <source>Use the &amp;lsquo;</source>
          <target state="translated">使用 '</target>
        </trans-unit>
        <trans-unit id="4c08ac9947cb5cb5ba71955417b6bbe576595e7e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;bfd&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">デフォルトのリンカーの代わりに &lt;code&gt;bfd&lt;/code&gt; リンカーを使用します。</target>
        </trans-unit>
        <trans-unit id="49f654b96f5c6203d75686fb510717eb4b09cb8c" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;dcpl&lt;/code&gt; instruction to load the contents of address &lt;var&gt;x&lt;/var&gt; into the data cache.</source>
          <target state="translated">&lt;code&gt;dcpl&lt;/code&gt; 命令を使用して、アドレス &lt;var&gt;x&lt;/var&gt; の内容をデータキャッシュにロードします。</target>
        </trans-unit>
        <trans-unit id="bf6f4ab92454be3b8a7530a2bda919c27587ed37" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;gold&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">デフォルトのリンカーの代わりに &lt;code&gt;gold&lt;/code&gt; リンカーを使用します。</target>
        </trans-unit>
        <trans-unit id="6ce5962b43b6bd52ef348d693006572a8183c27a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;nldub&lt;/code&gt; instruction to load the contents of address &lt;var&gt;x&lt;/var&gt; into the data cache. The instruction is issued in slot I1.</source>
          <target state="translated">&lt;code&gt;nldub&lt;/code&gt; 命令を使用して、アドレス &lt;var&gt;x&lt;/var&gt; の内容をデータキャッシュにロードします。命令はスロットI1で発行されます。</target>
        </trans-unit>
        <trans-unit id="867d5a75d613034d3b5e7a22efb5a5d5d0038d5f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;section&lt;/code&gt; attribute with &lt;em&gt;global&lt;/em&gt; variables and not &lt;em&gt;local&lt;/em&gt; variables, as shown in the example.</source>
          <target state="translated">例に示すように、&lt;em&gt;ローカル&lt;/em&gt;変数ではなく&lt;em&gt;グローバル&lt;/em&gt;変数で &lt;code&gt;section&lt;/code&gt; 属性を使用します。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9a7c0df6001ba89f4adccf5164b3cb2c7ebaeebd" translate="yes" xml:space="preserve">
          <source>Use the GNU C library. This is the default except on &amp;lsquo;</source>
          <target state="translated">GNU Cライブラリを使用します。これは '以外のデフォルトです</target>
        </trans-unit>
        <trans-unit id="750d7f5d1705c279b333b6c74a4ba7e65ef492b9" translate="yes" xml:space="preserve">
          <source>Use the Graphite data dependence analysis to identify loops that can be parallelized. Parallelize all the loops that can be analyzed to not contain loop carried dependences without checking that it is profitable to parallelize the loops.</source>
          <target state="translated">Graphiteのデータ依存性解析を使って、並列化できるループを特定する。並列化しても利益があるかどうかを確認せずに、解析可能なすべてのループを並列化して、ループが運ばれた依存関係を含まないようにします。</target>
        </trans-unit>
        <trans-unit id="7a211de8053eb75fc4551a2253a98b04c844e3fd" translate="yes" xml:space="preserve">
          <source>Use the LLVM &lt;code&gt;lld&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">デフォルトのリンカーの代わりにLLVM &lt;code&gt;lld&lt;/code&gt; リンカーを使用します。</target>
        </trans-unit>
        <trans-unit id="04b872414955ba2ec914569c9ca7e852388533f1" translate="yes" xml:space="preserve">
          <source>Use the divide instruction. (Enabled by default).</source>
          <target state="translated">divide 命令を使用します。(デフォルトでは有効)。</target>
        </trans-unit>
        <trans-unit id="558e68bc0e42df73038edd83e1eeba8d09d26633" translate="yes" xml:space="preserve">
          <source>Use the hardware barrel shifter.</source>
          <target state="translated">ハードウェアのバレルシフターを使用します。</target>
        </trans-unit>
        <trans-unit id="3ddc7c28193ef0a55228689dee7a52062a4edc76" translate="yes" xml:space="preserve">
          <source>Use the musl C library. This is the default on &amp;lsquo;</source>
          <target state="translated">musl Cライブラリを使用します。これは 'のデフォルトです</target>
        </trans-unit>
        <trans-unit id="1f0e93cc02e9fe65de10db69a6186e0dc79df964" translate="yes" xml:space="preserve">
          <source>Use the new LRA register allocator. By default, the old &amp;ldquo;reload&amp;rdquo; allocator is used.</source>
          <target state="translated">新しいLRAレジスタアロケータを使用します。デフォルトでは、古い「リロード」アロケーターが使用されます。</target>
        </trans-unit>
        <trans-unit id="b8160c2417cc8a5cdcd5adcb2b4ace153689638e" translate="yes" xml:space="preserve">
          <source>Use the pc-relative addressing mode of the 68000 directly, instead of using a global offset table. At present, this option implies</source>
          <target state="translated">グローバルオフセットテーブルを使用するのではなく、68000 の pc 相対アドレッシングモードを直接使用します。現在のところ、このオプションは</target>
        </trans-unit>
        <trans-unit id="f07a2b31cfd22ad424266d7caad833e89dee9597" translate="yes" xml:space="preserve">
          <source>Use the portable calling conventions proposed by HP for ELF systems.</source>
          <target state="translated">ELFシステム用にHPが提案しているポータブル通話規約を使用してください。</target>
        </trans-unit>
        <trans-unit id="0b4db49c13b2cd9f44e64e88aadae4892b55bc28" translate="yes" xml:space="preserve">
          <source>Use the simulator runtime. The default is to use the libgloss board-specific runtime.</source>
          <target state="translated">シミュレータのランタイムを使用します。デフォルトでは libgloss ボード固有のランタイムを使用します。</target>
        </trans-unit>
        <trans-unit id="41338fd388f1668b19ad991f249f38977077076b" translate="yes" xml:space="preserve">
          <source>Use the small address space model. This can produce smaller code, but it does assume that all symbolic values and addresses fit into a 20-bit range.</source>
          <target state="translated">小さなアドレス空間モデルを使用します。これはより小さなコードを生成することができますが、すべてのシンボリック値とアドレスが20ビットの範囲に収まることを前提としています。</target>
        </trans-unit>
        <trans-unit id="13568366d19d7f746b8b97efedd41fb9de7088bc" translate="yes" xml:space="preserve">
          <source>Use the specified algorithm for basic block reordering. The &lt;var&gt;algorithm&lt;/var&gt; argument can be &amp;lsquo;</source>
          <target state="translated">基本的なブロックの並べ替えには、指定されたアルゴリズムを使用します。 &lt;var&gt;algorithm&lt;/var&gt; 引数は、 &quot;することができ</target>
        </trans-unit>
        <trans-unit id="ab53cd8c99a5cd67bf095646da8562b04af28820" translate="yes" xml:space="preserve">
          <source>Use the specified coloring algorithm for the integrated register allocator. The &lt;var&gt;algorithm&lt;/var&gt; argument can be &amp;lsquo;</source>
          <target state="translated">統合レジスタアロケータに指定されたカラーリングアルゴリズムを使用します。 &lt;var&gt;algorithm&lt;/var&gt; 引数は、 &quot;することができ</target>
        </trans-unit>
        <trans-unit id="c25bc5036e9135cfbfa139415172d379794c44f1" translate="yes" xml:space="preserve">
          <source>Use the standard 387 floating-point coprocessor present on the majority of chips and emulated otherwise. Code compiled with this option runs almost everywhere. The temporary results are computed in 80-bit precision instead of the precision specified by the type, resulting in slightly different results compared to most of other chips. See</source>
          <target state="translated">大部分のチップに搭載されている標準の 387 浮動小数点コプロセッサを使用し、それ以外の場合はエミュレートします。このオプションでコンパイルされたコードは、ほぼすべての場所で実行されます。一時的な結果は、型で指定された精度ではなく 80 ビットの精度で計算されるため、他のほとんどのチップと比較して結果が若干異なります。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="5c3eebf40b38ef456cf7b33dffd08d0bed4ad5c6" translate="yes" xml:space="preserve">
          <source>Use the string argument if you want a single implementation file to include code from multiple header files. (You must also use &amp;lsquo;</source>
          <target state="translated">単一の実装ファイルに複数のヘッダーファイルのコードを含める場合は、文字列引数を使用します。（ 'も使用する必要があります</target>
        </trans-unit>
        <trans-unit id="8b250eb8bd58bde677af68374494bb2406d4bfb9" translate="yes" xml:space="preserve">
          <source>Use the timing characteristics of the indicated CPU type when scheduling instructions. This does not change the targeted processor type. The CPU type must be one of &amp;lsquo;</source>
          <target state="translated">命令をスケジュールするときは、示されたCPUタイプのタイミング特性を使用してください。これにより、ターゲットプロセッサの種類は変更されません。CPUタイプは '</target>
        </trans-unit>
        <trans-unit id="e509cf065cb591da77c6d1b119a1c9955ae2884c" translate="yes" xml:space="preserve">
          <source>Use these attributes on the Blackfin to place the variable into L1 Data SRAM. Variables with &lt;code&gt;l1_data&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data&lt;/code&gt;. Those with &lt;code&gt;l1_data_A&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data.A&lt;/code&gt;. Those with &lt;code&gt;l1_data_B&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data.B&lt;/code&gt;.</source>
          <target state="translated">Blackfinでこれらの属性を使用して、変数をL1データSRAMに配置します。 &lt;code&gt;l1_data&lt;/code&gt; 属性を持つ変数は、.l1.dataという名前の特定のセクションに配置され &lt;code&gt;.l1.data&lt;/code&gt; 。 &lt;code&gt;l1_data_A&lt;/code&gt; 属性を持つものは、.l1.data.Aという名前の特定のセクションに配置され &lt;code&gt;.l1.data.A&lt;/code&gt; 。 &lt;code&gt;l1_data_B&lt;/code&gt; 属性を持つものは、.l1.data.Bという名前の特定のセクションに配置され &lt;code&gt;.l1.data.B&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="160cca57d4e5e0f9858135c86f73f6c1abb97d0c" translate="yes" xml:space="preserve">
          <source>Use these attributes to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when either attribute is present.</source>
          <target state="translated">これらの属性を使用して、指定された関数が割り込みハンドラであることを示します。いずれかの属性が存在する場合、コンパイラは割り込みハンドラで使用するのに適した関数のエントリ・シーケンスとエグジット・シーケンスを生成します。</target>
        </trans-unit>
        <trans-unit id="bf93b175e1b39a6bc44235ab705a17a9dd4f6b45" translate="yes" xml:space="preserve">
          <source>Use these attributes to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when either of these attributes are present.</source>
          <target state="translated">これらの属性を使用して、指定された関数が割り込みハンドラであることを示します。これらの属性のいずれかが存在する場合、コンパイラは割り込みハンドラで使用するのに適した関数のエントリ・シーケンスとエグジット・シーケンスを生成します。</target>
        </trans-unit>
        <trans-unit id="713ae23784c01f8e2dec060c72284704315954a7" translate="yes" xml:space="preserve">
          <source>Use these options on systems where the linker can perform optimizations to improve locality of reference in the instruction space. Most systems using the ELF object format have linkers with such optimizations. On AIX, the linker rearranges sections (CSECTs) based on the call graph. The performance impact varies.</source>
          <target state="translated">これらのオプションは、リンカが命令空間での参照のロカリティを向上させるための最適化を実行できるシステムで使用します。ELF オブジェクト・フォーマットを使用するほとんどのシステムには、このような最適化機能を備えたリンカがあります。AIX では、リンカはコール・グラフに基づいてセクション (CSECT)を再配置します。性能への影響は様々です。</target>
        </trans-unit>
        <trans-unit id="78e3ee99ed9959a22e988df0584ccd7d00c7b9a6" translate="yes" xml:space="preserve">
          <source>Use this attribute on ARM to write Interrupt Service Routines. This is an alias to the &lt;code&gt;interrupt&lt;/code&gt; attribute above.</source>
          <target state="translated">ARMでこの属性を使用して、割り込みサービスルーチンを記述します。これは、上記の &lt;code&gt;interrupt&lt;/code&gt; 属性のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="6c570cb3577b10adeb554e34c1e75804adbd4ff0" translate="yes" xml:space="preserve">
          <source>Use this attribute on SH targets to indicate that an &lt;code&gt;interrupt_handler&lt;/code&gt; function should not save and restore registers R0..R7. This can be used on SH3* and SH4* targets that have a second R0..R7 register bank for non-reentrant interrupt handlers.</source>
          <target state="translated">SHターゲットでこの属性を使用して、 &lt;code&gt;interrupt_handler&lt;/code&gt; 関数がレジスタR0..R7を保存および復元しないことを示します。これは、非再入可能割り込みハンドラー用の2番目のR0..R7レジスターバンクを持つSH3 *およびSH4 *ターゲットで使用できます。</target>
        </trans-unit>
        <trans-unit id="f5c77347991d0824e6e1b28414143e53ed7d053c" translate="yes" xml:space="preserve">
          <source>Use this attribute on fido, a subarchitecture of the m68k, to indicate that the specified function is an interrupt handler that is designed to run as a thread. The compiler omits generate prologue/epilogue sequences and replaces the return instruction with a &lt;code&gt;sleep&lt;/code&gt; instruction. This attribute is available only on fido.</source>
          <target state="translated">m68kのサブアーキテクチャであるfidoでこの属性を使用して、指定した関数がスレッドとして実行するように設計された割り込みハンドラであることを示します。コンパイラはプロローグ/エピローグシーケンスの生成を省略し、リターン命令を &lt;code&gt;sleep&lt;/code&gt; 命令に置き換えます。この属性は、fidoでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="d1f324113425943e40b53dec4caee6bc8c992d2f" translate="yes" xml:space="preserve">
          <source>Use this attribute on the AVR to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">AVR上でこの属性を使用して、指定された関数が割り込みハンドラであることを示します。この属性が存在する場合、コンパイラは割り込みハンドラで使用するのに適した関数入口と出口シーケンスを生成します。</target>
        </trans-unit>
        <trans-unit id="a5bf0a65e4d4990ce1711a80366a15b5a93d0b22" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to indicate that the specified function is an NMI handler. The compiler generates function entry and exit sequences suitable for use in an NMI handler when this attribute is present.</source>
          <target state="translated">Blackfin でこの属性を使用して、指定された関数が NMI ハンドラであることを示します。この属性がある場合、コンパイラは、NMI ハンドラで使用するのに適した関数のエントリおよびエグジット・シーケンスを生成します。</target>
        </trans-unit>
        <trans-unit id="dfb0dab0829881fae4719db2bc2a5d4b0371e0d9" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to indicate that the specified function is an exception handler. The compiler generates function entry and exit sequences suitable for use in an exception handler when this attribute is present.</source>
          <target state="translated">Blackfin でこの属性を使用して、指定された関数が例外ハンドラであることを示します。この属性が存在する場合、コンパイラは例外ハンドラで使用するのに適した関数のエントリおよびエグジット・シーケンスを生成します。</target>
        </trans-unit>
        <trans-unit id="8869ad65102c3d5175ee58c9a5d4d12dd9377ae3" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to place the variable into L2 SRAM. Variables with &lt;code&gt;l2&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l2.data&lt;/code&gt;.</source>
          <target state="translated">Blackfinでこの属性を使用して、変数をL2 SRAMに配置します。 &lt;code&gt;l2&lt;/code&gt; 属性を持つ変数は、 &lt;code&gt;.l2.data&lt;/code&gt; という名前の特定のセクションに配置されます。</target>
        </trans-unit>
        <trans-unit id="77ba6ef03647597caec122d43f2ce8b19030a7ba" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not.</source>
          <target state="translated">H8/300、H8/300H、およびH8Sでこの属性を使用して、スタックポインタを除くすべてのレジスタが使用されるかどうかにかかわらず、プロローグに保存されるべきであることを示す。</target>
        </trans-unit>
        <trans-unit id="df02a088eeed2ddabe9512b735b51f56751782bf" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">H8/300、H8/300H、およびH8Sでこの属性を使用して、指定された関数が割り込みハンドラであることを示します。この属性がある場合、コンパイラは割り込みハンドラで使用するのに適した関数のエントリシーケンスとエグジットシーケンスを生成します。</target>
        </trans-unit>
        <trans-unit id="fd7a5bf8f68787afcff36ce2f74606dfa6e83fb2" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function should be called through the function vector. Calling a function through the function vector reduces code size; however, the function vector has a limited size (maximum 128 entries on the H8/300 and 64 entries on the H8/300H and H8S) and shares space with the interrupt vector.</source>
          <target state="translated">H8/300、H8/300H、および H8S でこの属性を使用して、指定された関数を関数ベクタを通して呼び出すことを示します。関数ベクタを通して関数を呼び出すとコードサイズが小さくなりますが、関数ベクタのサイズには制限があり(H8/300では最大128エントリ、H8/300HとH8Sでは64エントリ)、割り込みベクタとスペースを共有しています。</target>
        </trans-unit>
        <trans-unit id="599c44ccc726a6980df5cc0406dd5d4d98bf81c0" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified variable should be placed into the eight-bit data section. The compiler generates more efficient code for certain operations on data in the eight-bit data area. Note the eight-bit data area is limited to 256 bytes of data.</source>
          <target state="translated">H8/300、H8/300H、および H8S でこの属性を使用して、指定された変数を 8 ビット・データ・セクションに配置する必要があることを示します。コンパイラは、8 ビット・データ・エリアのデータに対する特定の操作に対して、より効率的なコードを生成します。8 ビット・データ・エリアは 256 バイトのデータに制限されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a601987d8058a933f8472ba9226cb9a2f96a02f6" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300H and H8S to indicate that the specified variable should be placed into the tiny data section. The compiler generates more efficient code for loads and stores on data in the tiny data section. Note the tiny data area is limited to slightly under 32KB of data.</source>
          <target state="translated">H8/300H および H8S でこの属性を使用して、指定された変数を小さなデータ・セクションに配置することを示します。コンパイラは、小さなデータ・セクションにデータをロードしたり保存したりするために、より効率的なコードを生成します。小さなデータ領域は、32KB弱のデータに制限されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="85d60dec57fe15c501fdf7e341a3a258fde629e1" translate="yes" xml:space="preserve">
          <source>Use this attribute on the M32C port to indicate that the specified function is a fast interrupt handler. This is just like the &lt;code&gt;interrupt&lt;/code&gt; attribute, except that &lt;code&gt;freit&lt;/code&gt; is used to return instead of &lt;code&gt;reit&lt;/code&gt;.</source>
          <target state="translated">M32Cポートでこの属性を使用して、指定された関数が高速割り込みハンドラーであることを示します。これはただのようなものです &lt;code&gt;interrupt&lt;/code&gt; ことを除いて、属性 &lt;code&gt;freit&lt;/code&gt; 代わりに返すために使用されている &lt;code&gt;reit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="297c80fc49a65c78b7920bfb2bee0762b9925dea" translate="yes" xml:space="preserve">
          <source>Use this attribute on the M32R/D to set the addressability of an object. The identifier &lt;var&gt;model-name&lt;/var&gt; is one of &lt;code&gt;small&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, or &lt;code&gt;large&lt;/code&gt;, representing each of the code models.</source>
          <target state="translated">M32R / Dでこの属性を使用して、オブジェクトのアドレス可能度を設定します。識別子 &lt;var&gt;model-name&lt;/var&gt; は、各コードモデルを表す &lt;code&gt;small&lt;/code&gt; 、 &lt;code&gt;medium&lt;/code&gt; 、または &lt;code&gt;large&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="96da4205ef51f9f643ebc02b337015bd75a20bc4" translate="yes" xml:space="preserve">
          <source>Use this attribute on the NDS32 target to indicate that the specified function is a reset handler. The compiler will generate corresponding sections for use in a reset handler. You can use the following attributes to provide extra exception handling:</source>
          <target state="translated">NDS32 ターゲットでこの属性を使用して、指定された関数がリセット・ハンドラであることを示します。コンパイラは、リセット・ハンドラで使用するための対応するセクションを生成します。以下の属性を使用して、追加の例外処理を提供することができます。</target>
        </trans-unit>
        <trans-unit id="baa8e68af06ff2588951a9683b9bf9ad21db1c70" translate="yes" xml:space="preserve">
          <source>Use this attribute on the NDS32 target to indicate that the specified function is an exception handler. The compiler will generate corresponding sections for use in an exception handler.</source>
          <target state="translated">NDS32 ターゲットでこの属性を使用して、指定された関数が例外ハンドラであることを示します。コンパイラは、例外ハンドラで使用するための対応するセクションを生成します。</target>
        </trans-unit>
        <trans-unit id="420b4fa6a036410c655f106a939e0146c5f824c7" translate="yes" xml:space="preserve">
          <source>Use this attribute on the RX port to indicate that the specified function is a fast interrupt handler. This is just like the &lt;code&gt;interrupt&lt;/code&gt; attribute, except that &lt;code&gt;freit&lt;/code&gt; is used to return instead of &lt;code&gt;reit&lt;/code&gt;.</source>
          <target state="translated">RXポートでこの属性を使用して、指定された関数が高速割り込みハンドラーであることを示します。これはただのようなものです &lt;code&gt;interrupt&lt;/code&gt; ことを除いて、属性 &lt;code&gt;freit&lt;/code&gt; 代わりに返すために使用されている &lt;code&gt;reit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8551dfbdf943cb7774be60c5de8ba39aba7167f2" translate="yes" xml:space="preserve">
          <source>Use this attribute on the SH for an &lt;code&gt;interrupt_handler&lt;/code&gt; to return using &lt;code&gt;trapa&lt;/code&gt; instead of &lt;code&gt;rte&lt;/code&gt;. This attribute expects an integer argument specifying the trap number to be used.</source>
          <target state="translated">&lt;code&gt;interrupt_handler&lt;/code&gt; が &lt;code&gt;trapa&lt;/code&gt; ではなく &lt;code&gt;rte&lt;/code&gt; を使用して戻るには、SHでこの属性を使用します。この属性は、使用されるトラップ番号を指定する整数の引数を予期します。</target>
        </trans-unit>
        <trans-unit id="96f131ead8b3e83868bdd55e3669cea512c61c77" translate="yes" xml:space="preserve">
          <source>Use this attribute on the SH to indicate an &lt;code&gt;interrupt_handler&lt;/code&gt; function should switch to an alternate stack. It expects a string argument that names a global variable holding the address of the alternate stack.</source>
          <target state="translated">SHでこの属性を使用して、 &lt;code&gt;interrupt_handler&lt;/code&gt; 関数が代替スタックに切り替える必要があることを示します。代替スタックのアドレスを保持するグローバル変数を指定する文字列引数が必要です。</target>
        </trans-unit>
        <trans-unit id="7835a2a9ca1e1170ad95a6f19a530b6da32924fa" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the first 32 kilobytes of memory.</source>
          <target state="translated">この属性を使用して、メモリの最初の32キロバイトに変数を明示的に配置します。</target>
        </trans-unit>
        <trans-unit id="6f81bc7b08ff6f3b4d15b67ecb7306d1b4cac77a" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the small data area, which can hold up to 64 kilobytes.</source>
          <target state="translated">この属性を使用して、最大64キロバイトまで保持できる小さなデータ領域に変数を明示的に配置します。</target>
        </trans-unit>
        <trans-unit id="25a478a508b894220fe0716716b37246794c924f" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the tiny data area, which can hold up to 256 bytes in total.</source>
          <target state="translated">この属性を使用して、小さなデータ領域に変数を明示的に配置します。</target>
        </trans-unit>
        <trans-unit id="236f15e780f5078ecf100afe1366fac4aadd1410" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not.</source>
          <target state="translated">この属性を使用して、スタックポインタを除くすべてのレジスタが使用されるかどうかにかかわらず、プロローグに保存されるべきであることを示す。</target>
        </trans-unit>
        <trans-unit id="764c3380316fc59c0e08f071dd7a44fb3d9e29ae" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the function is an interrupt handler. All volatile registers (in addition to non-volatile registers) are saved in the function prologue. If the function is a leaf function, only volatiles used by the function are saved. A normal function return is generated instead of a return from interrupt.</source>
          <target state="translated">この属性を使用して、関数が割り込みハンドラであることを示します。すべての揮発性レジスタ(不揮発性レジスタに加えて)は、関数のプロローグに保存されます。関数がリーフ関数の場合は、その関数で使用される揮発性レジスタのみが保存されます。割り込みからのリターンではなく、通常の関数のリターンが生成されます。</target>
        </trans-unit>
        <trans-unit id="e7371ecf2ac4e4a5beb340500a4170b79e5aeb2e" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function has no caller-saved registers. That is, all registers are callee-saved. For example, this attribute can be used for a function called from an interrupt handler. The compiler generates proper function entry and exit sequences to save and restore any modified registers, except for the EFLAGS register. Since GCC doesn&amp;rsquo;t preserve SSE, MMX nor x87 states, the GCC option</source>
          <target state="translated">この属性を使用して、指定された関数に呼び出し元が保存したレジスタがないことを示します。つまり、すべてのレジスタが呼び出し先に保存されます。たとえば、この属性は、割り込みハンドラーから呼び出される関数に使用できます。コンパイラーは、EFLAGSレジスター以外の変更されたレジスターを保存および復元するために、適切な関数の入り口と出口のシーケンスを生成します。GCCはSSE、MMX、x87状態を保持しないため、GCCオプション</target>
        </trans-unit>
        <trans-unit id="7d075359795fbb683e03390ae2ab96a3eb2f08a2" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is a break handler. The compiler generates function entry and exit sequences suitable for use in an break handler when this attribute is present. The return from &lt;code&gt;break_handler&lt;/code&gt; is done through the &lt;code&gt;rtbd&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="translated">この属性を使用して、指定された関数がブレークハンドラであることを示します。コンパイラーは、この属性が存在する場合に、ブレークハンドラーでの使用に適した関数の入り口と出口のシーケンスを生成します。以下からのリターン &lt;code&gt;break_handler&lt;/code&gt; を介して行われ &lt;code&gt;rtbd&lt;/code&gt; 代わりの &lt;code&gt;rtsd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2edc9f687349668f0ff9d21a9fd536ad89ad9e2f" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler or an exception handler (depending on parameters passed to the function, explained further). The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. The &lt;code&gt;IRET&lt;/code&gt; instruction, instead of the &lt;code&gt;RET&lt;/code&gt; instruction, is used to return from interrupt handlers. All registers, except for the EFLAGS register which is restored by the &lt;code&gt;IRET&lt;/code&gt; instruction, are preserved by the compiler. Since GCC doesn&amp;rsquo;t preserve SSE, MMX nor x87 states, the GCC option</source>
          <target state="translated">この属性を使用して、指定された関数が割り込みハンドラーまたは例外ハンドラーであることを示します（関数に渡されるパラメーターに応じて、さらに説明します）。コンパイラーは、この属性が存在する場合、割り込みハンドラーでの使用に適した関数の入り口と出口のシーケンスを生成します。 &lt;code&gt;IRET&lt;/code&gt; の代わりの命令、 &lt;code&gt;RET&lt;/code&gt; の命令は、割り込みハンドラから復帰するために使用されます。 &lt;code&gt;IRET&lt;/code&gt; 命令によって復元されるEFLAGSレジスタを除くすべてのレジスタは、コンパイラによって保持されます。 GCCはSSE、MMX、x87状態を保持しないため、GCCオプション</target>
        </trans-unit>
        <trans-unit id="0c30254e85a0958ba0ac7ce6feb29ae31661d530" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">この属性を使用して、指定された関数が割り込みハンドラであることを示します。この属性がある場合、コンパイラは割り込みハンドラで使用するのに適した関数のエントリシーケンスとエグジットシーケンスを生成します。</target>
        </trans-unit>
        <trans-unit id="d47a65245a7242658fd94eba35172dfdbe8eccc4" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. An optional argument is supported for the interrupt attribute which allows the interrupt mode to be described. By default GCC assumes the external interrupt controller (EIC) mode is in use, this can be explicitly set using &lt;code&gt;eic&lt;/code&gt;. When interrupts are non-masked then the requested Interrupt Priority Level (IPL) is copied to the current IPL which has the effect of only enabling higher priority interrupts. To use vectored interrupt mode use the argument &lt;code&gt;vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]&lt;/code&gt;, this will change the behavior of the non-masked interrupt support and GCC will arrange to mask all interrupts from sw0 up to and including the specified interrupt vector.</source>
          <target state="translated">この属性を使用して、指定された関数が割り込みハンドラであることを示します。コンパイラーは、この属性が存在する場合、割り込みハンドラーでの使用に適した関数の入り口と出口のシーケンスを生成します。オプションの引数は、割り込みモードを記述できるようにする割り込み属性でサポートされています。デフォルトでは、GCCは外部割り込みコントローラー（EIC）モードが使用中であると &lt;code&gt;eic&lt;/code&gt; ます。これは、eicを使用して明示的に設定できます。割り込みがマスクされていない場合、要求された割り込み優先度レベル（IPL）が現在のIPLにコピーされ、優先度の高い割り込みのみを有効にする効果があります。ベクトル割り込みモードを使用するには、引数 &lt;code&gt;vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]&lt;/code&gt; 、これはマスクされていない割り込みサポートの動作を変更し、GCCはsw0から指定された割り込みベクトルまでのすべての割り込みをマスクするように調整します。</target>
        </trans-unit>
        <trans-unit id="0ace02ca61dedf94a751682f5d4174fdf42f160d" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. Either name may be used.</source>
          <target state="translated">この属性を使用して、指定された関数が割り込みハンドラであることを示します。この属性がある場合、コンパイラは割り込みハンドラで使用するのに適した関数のエントリとエグジット・シーケンスを生成します。どちらの名前を使用しても構いません。</target>
        </trans-unit>
        <trans-unit id="bb60152fa1da7627a1b21880311cc9395167dfd1" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. It may also generate a special section with code to initialize the interrupt vector table.</source>
          <target state="translated">この属性を使用して、指定された関数が割り込みハンドラであることを示します。この属性がある場合、コンパイラは割り込みハンドラで使用するのに適した関数のエントリシーケンスとエグジットシーケンスを生成します。また、割り込みベクタ・テーブルを初期化するコードを含む特別なセクションを生成することもあります。</target>
        </trans-unit>
        <trans-unit id="ea92b79a9f3c03589b9a2bec6c52bb535643eb63" translate="yes" xml:space="preserve">
          <source>Use this attribute to place a variable in the &lt;code&gt;.shared&lt;/code&gt; memory space. This memory space is private to each cooperative thread array; only threads within one thread block refer to the same instance of the variable. The runtime does not initialize variables in this memory space.</source>
          <target state="translated">この属性を使用して、 &lt;code&gt;.shared&lt;/code&gt; メモリー空間に変数を配置します。このメモリ空間は、協調スレッドアレイごとにプライベートです。1つのスレッドブロック内のスレッドのみが変数の同じインスタンスを参照します。ランタイムは、このメモリ空間の変数を初期化しません。</target>
        </trans-unit>
        <trans-unit id="b1ecdb3757207ea0940932cf33695720d7e7f73c" translate="yes" xml:space="preserve">
          <source>Use this attribute together with &lt;code&gt;interrupt_handler&lt;/code&gt;, &lt;code&gt;exception_handler&lt;/code&gt; or &lt;code&gt;nmi_handler&lt;/code&gt; to indicate that the function entry code should enable nested interrupts or exceptions.</source>
          <target state="translated">この属性を &lt;code&gt;interrupt_handler&lt;/code&gt; 、 &lt;code&gt;exception_handler&lt;/code&gt; または &lt;code&gt;nmi_handler&lt;/code&gt; と一緒に使用して、関数のエントリコードでネストされた割り込みまたは例外を有効にする必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="01448e4d9272cc29bf3907d177e8611ce1e38ee0" translate="yes" xml:space="preserve">
          <source>Use this directive in &lt;em&gt;header files&lt;/em&gt; that define object classes, to save space in most of the object files that use those classes. Normally, local copies of certain information (backup copies of inline member functions, debugging information, and the internal tables that implement virtual functions) must be kept in each object file that includes class definitions. You can use this pragma to avoid such duplication. When a header file containing &amp;lsquo;</source>
          <target state="translated">オブジェクトクラスを定義する&lt;em&gt;ヘッダーファイル&lt;/em&gt;でこのディレクティブを使用して、それらのクラスを使用するほとんどのオブジェクトファイルのスペースを節約します。通常、特定の情報のローカルコピー（インラインメンバー関数のバックアップコピー、デバッグ情報、および仮想関数を実装する内部テーブル）は、クラス定義を含む各オブジェクトファイルに保持する必要があります。このプラグマを使用して、このような重複を回避できます。ヘッダーファイルが '</target>
        </trans-unit>
        <trans-unit id="d280eeca70b31bee4ab8a083eaebf1bfa7fbe798" translate="yes" xml:space="preserve">
          <source>Use this option for microcontroller with a 5200 core, including the MCF5202, MCF5203, MCF5204 and MCF5206.</source>
          <target state="translated">MCF5202、MCF5203、MCF5204、MCF5206を含む5200コアのマイクロコントローラに使用します。</target>
        </trans-unit>
        <trans-unit id="a112527843e5614605b4e3f46e7e6138969c47d8" translate="yes" xml:space="preserve">
          <source>Use this option for microcontrollers with a 68000 or EC000 core, including the 68008, 68302, 68306, 68307, 68322, 68328 and 68356.</source>
          <target state="translated">このオプションは、68000またはEC000コアを搭載したマイクロコントローラ(68008、68302、68306、68307、68322、68328、68356など)に使用します。</target>
        </trans-unit>
        <trans-unit id="63187c5307bd577a4586510b3b1f06b54dea5f9f" translate="yes" xml:space="preserve">
          <source>Use this option for microcontrollers with a CPU32 or CPU32+ core, including the 68330, 68331, 68332, 68333, 68334, 68336, 68340, 68341, 68349 and 68360.</source>
          <target state="translated">このオプションは、68330、68331、68332、68333、68334、68336、68340、68341、68349、68360などのCPU32またはCPU32+コアを搭載したマイクロコントローラに使用します。</target>
        </trans-unit>
        <trans-unit id="41f23198542e0d6a3a5d2900310d1b7abe9d3260" translate="yes" xml:space="preserve">
          <source>Use this option to require GCC to construct &lt;em&gt;all&lt;/em&gt; integer constants using code, even if it takes more instructions (the maximum is six).</source>
          <target state="translated">このオプションを使用して、GCCがコードを使用して&lt;em&gt;すべての&lt;/em&gt;整数定数を構築するように要求します（命令がさらに多くても（最大は6））。</target>
        </trans-unit>
        <trans-unit id="6aa829df1806f0740110776091d0764dbe5ca6cc" translate="yes" xml:space="preserve">
          <source>Use this pragma in a &lt;em&gt;main input file&lt;/em&gt;, when you want full output from included header files to be generated (and made globally visible). The included header file, in turn, should use &amp;lsquo;</source>
          <target state="translated">インクルードされたヘッダーファイルから完全な出力を生成する（およびグローバルに表示する）には、このプラグマを&lt;em&gt;メイン入力ファイル&lt;/em&gt;で使用します。含まれているヘッダーファイルは、次に使用する必要があります '</target>
        </trans-unit>
        <trans-unit id="cf5e8f8ca29a0892846d7e7fbb28cf80ccb1a6dd" translate="yes" xml:space="preserve">
          <source>Use traditional TLS as the thread-local storage mechanism for dynamic accesses of TLS variables.</source>
          <target state="translated">TLS 変数の動的アクセスのためのスレッドローカルストレージメカニズムとして従来の TLS を使用します。</target>
        </trans-unit>
        <trans-unit id="d8a60407e03b2ced230c36ef1b80cb979fd89c1c" translate="yes" xml:space="preserve">
          <source>Use uClibc C library. This is the default on &amp;lsquo;</source>
          <target state="translated">uClibc Cライブラリを使用します。これは 'のデフォルトです</target>
        </trans-unit>
        <trans-unit id="5a7b4e094ebc57080c3754943807a6fa36611b6e" translate="yes" xml:space="preserve">
          <source>Use uids starting at this parameter for nondebug insns. The range below the parameter is reserved exclusively for debug insns created by</source>
          <target state="translated">非デバッグインスーンには、このパラメータから始まる uid を使用します。このパラメータ以下の範囲は</target>
        </trans-unit>
        <trans-unit id="5c902a2c872ceeb654d592edec56cf917fe25417" translate="yes" xml:space="preserve">
          <source>Use version &lt;var&gt;n&lt;/var&gt; of the C++ ABI. The default is version 0.</source>
          <target state="translated">C ++ ABIのバージョン &lt;var&gt;n&lt;/var&gt; を使用します。デフォルトはバージョン0です。</target>
        </trans-unit>
        <trans-unit id="80654292da05f375c19f860e1835e2717583ea50" translate="yes" xml:space="preserve">
          <source>Use version &lt;var&gt;n&lt;/var&gt; of the Objective-C ABI for the selected runtime. This option is currently supported only for the NeXT runtime. In that case, Version 0 is the traditional (32-bit) ABI without support for properties and other Objective-C 2.0 additions. Version 1 is the traditional (32-bit) ABI with support for properties and other Objective-C 2.0 additions. Version 2 is the modern (64-bit) ABI. If nothing is specified, the default is Version 0 on 32-bit target machines, and Version 2 on 64-bit target machines.</source>
          <target state="translated">選択したランタイムにObjective-C ABIのバージョン &lt;var&gt;n&lt;/var&gt; を使用します。このオプションは現在、NeXTランタイムでのみサポートされています。その場合、バージョン0は従来の（32ビット）ABIであり、プロパティやその他のObjective-C 2.0の追加をサポートしていません。バージョン1は、プロパティおよびその他のObjective-C 2.0の追加をサポートする従来の（32ビット）ABIです。バージョン2は、最新の（64ビット）ABIです。何も指定されていない場合、デフォルトは32ビットターゲットマシンではバージョン0、64ビットターゲットマシンではバージョン2です。</target>
        </trans-unit>
        <trans-unit id="60277ce820e41f7e776a5ef4d10492797080b9c8" translate="yes" xml:space="preserve">
          <source>User defined libraries may want to implement their own constant string class. To be able to support them, the GNU Objective-C compiler provides a new command line options</source>
          <target state="translated">ユーザー定義ライブラリは、独自の定数文字列クラスを実装したい場合があります。これをサポートするために、GNU Objective-Cコンパイラは新しいコマンドラインオプションを提供します。</target>
        </trans-unit>
        <trans-unit id="6d924128c5dfe7331fc4ebe7adabf4aa651b95c3" translate="yes" xml:space="preserve">
          <source>Users often think it is a bug when GCC reports an error for code like this:</source>
          <target state="translated">GCCがこのようなコードのエラーを報告すると、ユーザーはバグだと思うことがよくあります。</target>
        </trans-unit>
        <trans-unit id="af3138cc282360a8600ef75867abc1b680f535c7" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;</source>
          <target state="translated">を使用して</target>
        </trans-unit>
        <trans-unit id="c673f0c8f99a2c8acaf1de1f7743b24ea2d61bf5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;__auto_type&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt; has two advantages:</source>
          <target state="translated">使用 &lt;code&gt;__auto_type&lt;/code&gt; の代わりに &lt;code&gt;typeof&lt;/code&gt; 演算は、 2つの利点があります。</target>
        </trans-unit>
        <trans-unit id="ae16306fd8fc8ae70da39e8eba7d569ba5d4c5f6" translate="yes" xml:space="preserve">
          <source>Using extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) typically produces smaller, safer, and more efficient code, and in most cases it is a better solution than basic &lt;code&gt;asm&lt;/code&gt;. However, there are two situations where only basic &lt;code&gt;asm&lt;/code&gt; can be used:</source>
          <target state="translated">拡張 &lt;code&gt;asm&lt;/code&gt; （「&lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;拡張Asm&lt;/a&gt;」を参照）を使用すると、通常、より小さく、より安全で、より効率的なコードが生成され、ほとんどの場合、基本的な &lt;code&gt;asm&lt;/code&gt; よりも優れたソリューションです。ただし、基本的な &lt;code&gt;asm&lt;/code&gt; しか使用できない状況が2つあります。</target>
        </trans-unit>
        <trans-unit id="fdb3b64210e267abb96c2653531b3f456e595b0e" translate="yes" xml:space="preserve">
          <source>Using floating point parameters for indirect calls to static functions will not work when using the HP assembler. There simply is no way for GCC to specify what registers hold arguments for static functions when using the HP assembler. GAS for the PA does not have this problem.</source>
          <target state="translated">浮動小数点パラメータを使用してスタティック関数を間接的に呼び出すことは、HP アセンブラを使用している場合には動作しません。HP アセンブラを使用している場合、GCC がスタティック関数の引数を保持するレジスタを指定する方法はありません。PA 用の GAS にはこの問題はありません。</target>
        </trans-unit>
        <trans-unit id="7f26807350569d85ac77ce79b84cf07a635bf81a" translate="yes" xml:space="preserve">
          <source>Using gcov with GCC optimization.</source>
          <target state="translated">GCC最適化でgcovを使用します。</target>
        </trans-unit>
        <trans-unit id="057195ec8f49950ab0bbd7ddf35c8adeaad3604e" translate="yes" xml:space="preserve">
          <source>Using that same compiler, this code:</source>
          <target state="translated">同じコンパイラを使うと、このコードは</target>
        </trans-unit>
        <trans-unit id="2e7015f3209d38900be9cab70f20fe385b6b0e2e" translate="yes" xml:space="preserve">
          <source>Using the GNU Compiler Collection (GCC)</source>
          <target state="translated">GNUコンパイラ・コレクションを使う (GCC)</target>
        </trans-unit>
        <trans-unit id="e084cdbad1b5de611e7b01b9c20a68e2bf4e6eb3" translate="yes" xml:space="preserve">
          <source>Using the argument forms of the &lt;code&gt;constructor&lt;/code&gt; and &lt;code&gt;destructor&lt;/code&gt; attributes on targets where the feature is not supported is rejected with an error.</source>
          <target state="translated">機能がサポートされていないターゲットで &lt;code&gt;constructor&lt;/code&gt; と &lt;code&gt;destructor&lt;/code&gt; 属性の引数形式を使用すると、エラーが発生して拒否されます。</target>
        </trans-unit>
        <trans-unit id="b7a3e4a21bb4f065c09ef23587c979ac36262bbb" translate="yes" xml:space="preserve">
          <source>Using the built-in functions described below, you can record the arguments a function received, and call another function with the same arguments, without knowing the number or types of the arguments.</source>
          <target state="translated">以下に説明する組み込み関数を使用すると、関数が受け取った引数を記録し、引数の数や型を知らなくても、同じ引数を持つ別の関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="4a1d87094917525e3f4fb29e2aa35aa01c301737" translate="yes" xml:space="preserve">
          <source>Using the cast as the right-hand side of an assignment to a variable of union type is equivalent to storing in a member of the union with the same type</source>
          <target state="translated">ユニオン型の変数への代入の右辺としてキャストを使用することは、同じ型のユニオンのメンバに格納することと同じです。</target>
        </trans-unit>
        <trans-unit id="db9a503a051e32ac0fce6e9c55331f5affaaa22c" translate="yes" xml:space="preserve">
          <source>Using the variable</source>
          <target state="translated">変数を使用して</target>
        </trans-unit>
        <trans-unit id="b34c5d037644130f54f15d5f39b3ad23e6aef200" translate="yes" xml:space="preserve">
          <source>Using these common set of HTM inline functions, we can create a more portable version of the HTM example in the previous section that will work on either PowerPC or S/390:</source>
          <target state="translated">これらの共通の HTM インライン関数を使用して、前節の HTM の例のよりポータブルなバージョンを作成し、PowerPC または S/390 のどちらでも動作するようにします。</target>
        </trans-unit>
        <trans-unit id="e5427ab978358d5a7992aa85bab4f2f802b870d2" translate="yes" xml:space="preserve">
          <source>Using this attribute can improve optimization. Compiler predicts that a function with the attribute returns non-null in most cases. Functions like &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;calloc&lt;/code&gt; have this property because they return a pointer to uninitialized or zeroed-out storage. However, functions like &lt;code&gt;realloc&lt;/code&gt; do not have this property, as they can return a pointer to storage containing pointers.</source>
          <target state="translated">この属性を使用すると、最適化を改善できます。コンパイラは、属性を持つ関数がほとんどの場合null以外を返すと予測します。 &lt;code&gt;malloc&lt;/code&gt; や &lt;code&gt;calloc&lt;/code&gt; などの関数は、初期化されていない、またはゼロに設定されたストレージへのポインターを返すため、このプロパティがあります。ただし、 &lt;code&gt;realloc&lt;/code&gt; などの関数には、ポインターを含むストレージへのポインターを返すことができるため、このプロパティはありません。</target>
        </trans-unit>
        <trans-unit id="1b49b124c3d34a77d39d66c92e391e732c60826d" translate="yes" xml:space="preserve">
          <source>Using vector instructions through built-in functions.</source>
          <target state="translated">内蔵機能によるベクトル命令の使用</target>
        </trans-unit>
        <trans-unit id="2dfe46da755d749792dfc6596d3900b7c7d1225d" translate="yes" xml:space="preserve">
          <source>Usually, the more IPA optimizations enabled, the larger the number of impacted functions for each function. In order to control the number of impacted functions and more easily compute the list of impacted function, IPA optimizations can be partially enabled at two different levels.</source>
          <target state="translated">通常、IPA 最適化を有効にするほど、各関数の影響を受ける関数の数が多くなります。影響を受ける関数の数を制御し、影響を受ける関数のリストをより簡単に計算するために、IPA最適化を2つの異なるレベルで部分的に有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="75ec5cdb7f54185163f339da83a6bb1078cb8cdf" translate="yes" xml:space="preserve">
          <source>Usually, the specified type of a compound literal is a structure. Assume that &lt;code&gt;struct foo&lt;/code&gt; and &lt;code&gt;structure&lt;/code&gt; are declared as shown:</source>
          <target state="translated">通常、複合リテラルの指定されたタイプは構造です。仮定し &lt;code&gt;struct foo&lt;/code&gt; と &lt;code&gt;structure&lt;/code&gt; 示されているように宣言されています。</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="574d16a752ab33d0cef891f9de30707743042305" translate="yes" xml:space="preserve">
          <source>V850E2V3</source>
          <target state="translated">V850E2V3</target>
        </trans-unit>
        <trans-unit id="18daea8d25a1ff1128b31b35345423541b18cfb9" translate="yes" xml:space="preserve">
          <source>VFP floating-point registers &lt;code&gt;d0&lt;/code&gt;-&lt;code&gt;d31&lt;/code&gt; and the appropriate subset &lt;code&gt;d0&lt;/code&gt;-&lt;code&gt;d15&lt;/code&gt; based on command line options. Used for 64 bit values only. Not valid for Thumb1.</source>
          <target state="translated">コマンドラインオプションに基づくVFP浮動小数点レジスタ &lt;code&gt;d0&lt;/code&gt; - &lt;code&gt;d31&lt;/code&gt; および適切なサブセット &lt;code&gt;d0&lt;/code&gt; - &lt;code&gt;d15&lt;/code&gt; 。64ビット値にのみ使用されます。Thumb1では無効です。</target>
        </trans-unit>
        <trans-unit id="9cbb2d892b07e55db914e77fcb2ce30c1ce00bae" translate="yes" xml:space="preserve">
          <source>VFP floating-point registers &lt;code&gt;s0&lt;/code&gt;-&lt;code&gt;s31&lt;/code&gt;. Used for 32 bit values.</source>
          <target state="translated">VFP浮動小数点レジスタ &lt;code&gt;s0&lt;/code&gt; - &lt;code&gt;s31&lt;/code&gt; 。32ビット値に使用されます。</target>
        </trans-unit>
        <trans-unit id="3d910167fb4f24dfbb3904aef13e596ce47de5f7" translate="yes" xml:space="preserve">
          <source>VGPR register</source>
          <target state="translated">VGPRレジスタ</target>
        </trans-unit>
        <trans-unit id="d5387553aab64197b27321b5224709eacf46c07a" translate="yes" xml:space="preserve">
          <source>VIA C3 CPU with MMX and 3DNow! instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA C3 CPUはMMXと3DNow!命令セットをサポートしています。(このチップにはスケジューリングは実装されていません)</target>
        </trans-unit>
        <trans-unit id="488b543fd950a74701b966446818fb5fe7d6e4bc" translate="yes" xml:space="preserve">
          <source>VIA C3-2 (Nehemiah/C5XL) CPU with MMX and SSE instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA C3-2 (Nehemiah/C5XL)MMXおよびSSE命令セットをサポートするCPU。(このチップにはスケジューリングは実装されていません)</target>
        </trans-unit>
        <trans-unit id="ea585482eb4a4acc3a6360d2898743a7c9373beb" translate="yes" xml:space="preserve">
          <source>VIA C7 (Esther) CPU with MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA C7 (Esther)CPUはMMX、SSE、SSE2、SSE3命令セットをサポートしています。(このチップにはスケジューリングは実装されていません)</target>
        </trans-unit>
        <trans-unit id="f935a35014da34c94c36f4bd8a1a050285f9d495" translate="yes" xml:space="preserve">
          <source>VIA Eden Esther CPU with MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden Esther CPUはMMX、SSE、SSE2、SSE3命令セットをサポートしています。(このチップにはスケジューリングは実装されていません)</target>
        </trans-unit>
        <trans-unit id="c111443ef87aeb29107b8a68909620c76e8f94c1" translate="yes" xml:space="preserve">
          <source>VIA Eden Nehemiah CPU with MMX and SSE instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden Nehemiah CPUでMMXとSSE命令セットをサポートしています。(このチップにはスケジューリングは実装されていません)</target>
        </trans-unit>
        <trans-unit id="8cce1c624bb9c2543acc6d544b6d1ed27c2158a4" translate="yes" xml:space="preserve">
          <source>VIA Eden Samuel 2 CPU with MMX and 3DNow! instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden Samuel 2 CPU、MMXと3DNow!命令セットをサポートしています。(このチップにはスケジューリングは実装されていません)</target>
        </trans-unit>
        <trans-unit id="2151cc7927e87e8f1c1dda8e6327ac4e0a64b7a2" translate="yes" xml:space="preserve">
          <source>VIA Eden X2 CPU with x86-64, MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden X2 CPU、x86-64、MMX、SSE、SSE2およびSSE3命令セットをサポート。(このチップにはスケジューリングは実装されていません)。</target>
        </trans-unit>
        <trans-unit id="1d98ef012706e83dddd4d35e5d791491017f3e46" translate="yes" xml:space="preserve">
          <source>VIA Eden X4 CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX and AVX2 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Eden X4 CPU、x86-64、MMX、SSE、SSE2、SSE3、SSE3、SSE4.1、SSE4.2、AVX、AVX2命令セットをサポート。(このチップにはスケジューリングは実装されていません)</target>
        </trans-unit>
        <trans-unit id="b8b4d4a862d49f8ff0f8c10fa3fdc814a539ab87" translate="yes" xml:space="preserve">
          <source>VIA Nano 1xxx CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Nano 1xxx CPU、x86-64、MMX、SSE、SSE2、SSE3、SSSE3命令セットをサポート。(このチップにはスケジューリングは実装されていません)。</target>
        </trans-unit>
        <trans-unit id="dd719c7a93195bbf6d07de4c172b28d8c80267d3" translate="yes" xml:space="preserve">
          <source>VIA Nano 2xxx CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Nano 2xxx CPU、x86-64、MMX、SSE、SSE2、SSE3、SSSE3命令セットをサポート。(このチップにはスケジューリングは実装されていません)。</target>
        </trans-unit>
        <trans-unit id="01f9fedc3d4f11e857e6f0d9dcaa2b13176b8f56" translate="yes" xml:space="preserve">
          <source>VIA Nano 3xxx CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Nano 3xxx CPU、x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1命令セットをサポート。(このチップにはスケジューリングは実装されていません)。</target>
        </trans-unit>
        <trans-unit id="06b544d4bdd7d18ca4149d3c750f4127e9f983b2" translate="yes" xml:space="preserve">
          <source>VIA Nano Dual Core CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Nano デュアルコアCPU、x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1命令セットをサポート。(このチップにはスケジューリングは実装されていません)。</target>
        </trans-unit>
        <trans-unit id="a67ea4083339300c1d547f346d07c9d5764525af" translate="yes" xml:space="preserve">
          <source>VIA Nano Quad Core CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">VIA Nano Nano Quad Core CPU、x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1命令セットをサポート。(このチップにはスケジューリングは実装されていません)。</target>
        </trans-unit>
        <trans-unit id="04026107ef9bdc35c4d06c69d4d8d9bd034df2b9" translate="yes" xml:space="preserve">
          <source>VPCLMULQDQ instructions.</source>
          <target state="translated">VPCLMULQDQ命令。</target>
        </trans-unit>
        <trans-unit id="47b598fadc542503a4dfb3ab0e7c08963d810a39" translate="yes" xml:space="preserve">
          <source>VRSAVE</source>
          <target state="translated">VRSAVE</target>
        </trans-unit>
        <trans-unit id="55aa2f856c0f4ab3cdcac26a348778a588a6f8d7" translate="yes" xml:space="preserve">
          <source>VSIB address operand.</source>
          <target state="translated">VSIB アドレスのオペランド。</target>
        </trans-unit>
        <trans-unit id="1e028c813fc89395b126781b62fe740e1e2e5612" translate="yes" xml:space="preserve">
          <source>VSX register if direct move instructions are enabled, or NO_REGS.</source>
          <target state="translated">直接移動命令が有効な場合はVSXレジスタ、またはNO_REGS。</target>
        </trans-unit>
        <trans-unit id="b1bf4ce917ea0e342c5ba87416d3c1425045396d" translate="yes" xml:space="preserve">
          <source>VSX register if the</source>
          <target state="translated">の場合はVSXレジスタ</target>
        </trans-unit>
        <trans-unit id="fa37e771ee1559b7e1a74968d2d6f9d21bbad3f8" translate="yes" xml:space="preserve">
          <source>VSX register to use for IEEE 128-bit floating point TFmode, or NO_REGS.</source>
          <target state="translated">IEEE 128ビット浮動小数点TFmodeに使用するVSXレジスタ、またはNO_REGS。</target>
        </trans-unit>
        <trans-unit id="dceb09e56dc6976e2ceb44b306b90d48c16cdbfa" translate="yes" xml:space="preserve">
          <source>VSX register to use for IEEE 128-bit floating point, or NO_REGS.</source>
          <target state="translated">IEEE 128ビット浮動小数点に使用するVSXレジスタ、またはNO_REGS。</target>
        </trans-unit>
        <trans-unit id="5f2931cf969db5dec892ea6c97702a431f737f4f" translate="yes" xml:space="preserve">
          <source>VSX register to use for ISA 3.0 vector instructions, or NO_REGS.</source>
          <target state="translated">ISA 3.0 ベクトル命令に使用する VSX レジスタ、または NO_REGS。</target>
        </trans-unit>
        <trans-unit id="e1e2b74202b4df2a34423d711c880f4bed5b3b14" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold 128 bit integer or NO_REGS.</source>
          <target state="translated">128ビット整数またはNO_REGSを保持するVSXベクトルレジスタ。</target>
        </trans-unit>
        <trans-unit id="f3dc5e0d7bbebef3893829b42a25b08c256dd4d8" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold scalar double values or NO_REGS.</source>
          <target state="translated">スカラ倍値またはNO_REGSを保持するためのVSXベクトルレジスタ。</target>
        </trans-unit>
        <trans-unit id="dc350e1093c1db7d408d43c001ed04b73c029f23" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold vector double data or NO_REGS.</source>
          <target state="translated">ベクトルダブルデータまたはNO_REGSを保持するためのVSXベクトルレジスタ。</target>
        </trans-unit>
        <trans-unit id="167ef2a892b4ddc57b82f58074b39f524e5008e6" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold vector float data or NO_REGS.</source>
          <target state="translated">ベクトルフロートデータまたはNO_REGSを保持するVSXベクトルレジスタ。</target>
        </trans-unit>
        <trans-unit id="81969f619b07a96e38c916b9993cc433143a784f" translate="yes" xml:space="preserve">
          <source>VTables</source>
          <target state="translated">VTables</target>
        </trans-unit>
        <trans-unit id="f5f8e1247b6f26b263b34207afe669cb4ac9de15" translate="yes" xml:space="preserve">
          <source>Valid ISO C and ISO C++ programs should compile properly with or without this option (though a rare few require</source>
          <target state="translated">有効な ISO C および ISO C++プログラムは、このオプションの有無にかかわらず適切にコンパイルされなければなりません (ただし、ごく少数のプログラムでは、このオプションを必要とします)。</target>
        </trans-unit>
        <trans-unit id="6c1f687862693a87865ad97fba05738669eac5ce" translate="yes" xml:space="preserve">
          <source>Valid alignment values other than those returned by an _Alignof expression for fundamental types, if any (C11 6.2.8).</source>
          <target state="translated">もしあれば、基本型に対する_Alignof式によって返される値以外の有効なアラインメント値を返します (C11 6.2.8)。</target>
        </trans-unit>
        <trans-unit id="b8f1ffda93c672ca444e36a4f56d16e63e5832c4" translate="yes" xml:space="preserve">
          <source>Valid alignments are powers of 2 up to and including &lt;em&gt;2^{28}&lt;/em&gt;.</source>
          <target state="translated">有効な配置は、2の累乗から&lt;em&gt;2 ^ {28}まで&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="e0567df87b1ea75cda27929ada4a4306a0c755cd" translate="yes" xml:space="preserve">
          <source>Valid options for &lt;var&gt;time&lt;/var&gt; are</source>
          <target state="translated">&lt;var&gt;time&lt;/var&gt; 有効なオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="bd15e3ace5dbddf7a0573a3f99038d776bddea91" translate="yes" xml:space="preserve">
          <source>Value appropriate as displacement.</source>
          <target state="translated">変位として適切な値。</target>
        </trans-unit>
        <trans-unit id="bb6561e8ab01989a094611590f0602e85a6c5513" translate="yes" xml:space="preserve">
          <source>Values &amp;lsquo;</source>
          <target state="translated">値 '</target>
        </trans-unit>
        <trans-unit id="d206078a63cff7bace258bb1f4bb9507b5cf8d12" translate="yes" xml:space="preserve">
          <source>Variable, function, and type attributes for C++ only.</source>
          <target state="translated">C++専用の変数、関数、型属性。</target>
        </trans-unit>
        <trans-unit id="02b16fb34038c0c62719510ede0c2e29dc2b90fc" translate="yes" xml:space="preserve">
          <source>Variable-length automatic arrays are allowed in ISO C99, and as an extension GCC accepts them in C90 mode and in C++. These arrays are declared like any other automatic arrays, but with a length that is not a constant expression. The storage is allocated at the point of declaration and deallocated when the block scope containing the declaration exits. For example:</source>
          <target state="translated">ISO C99では可変長の自動配列が許可されており,その拡張としてGCCではC90モードとC++で許可されています.これらの配列は他の自動配列と同様に宣言されますが、長さは定数式ではありません。ストレージは宣言時に確保され、宣言を含むブロックスコープが終了すると解放されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c1cafb0eff03f52681f175e65218139665f9ce2c" translate="yes" xml:space="preserve">
          <source>Variables declared at global scope.</source>
          <target state="translated">グローバルスコープで宣言された変数。</target>
        </trans-unit>
        <trans-unit id="5c01cb4a8cb1760f9b45c63f7213bd015da5c74c" translate="yes" xml:space="preserve">
          <source>Variables declared within a function.</source>
          <target state="translated">関数内で宣言された変数。</target>
        </trans-unit>
        <trans-unit id="b8da0198222d30500868466badddd4041e14cce0" translate="yes" xml:space="preserve">
          <source>Variables of size &lt;var&gt;n&lt;/var&gt; bytes or smaller are placed in the &lt;code&gt;.based&lt;/code&gt; section by default. Based variables use the &lt;code&gt;$tp&lt;/code&gt; register as a base register, and there is a 128-byte limit to the &lt;code&gt;.based&lt;/code&gt; section.</source>
          <target state="translated">サイズが &lt;var&gt;n&lt;/var&gt; バイト以下の変数は、デフォルトで &lt;code&gt;.based&lt;/code&gt; セクションに配置されます。ベース変数は &lt;code&gt;$tp&lt;/code&gt; レジスタをベースレジスタとして使用し、 &lt;code&gt;.based&lt;/code&gt; セクションには128バイトの制限があります。</target>
        </trans-unit>
        <trans-unit id="10abea2eed8c32edbb792ccf39c883573091a3b2" translate="yes" xml:space="preserve">
          <source>Variables that are &lt;var&gt;n&lt;/var&gt; bytes or smaller are allocated to the &lt;code&gt;.tiny&lt;/code&gt; section. These variables use the &lt;code&gt;$gp&lt;/code&gt; base register. The default for this option is 4, but note that there&amp;rsquo;s a 65536-byte limit to the &lt;code&gt;.tiny&lt;/code&gt; section.</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; バイト以下の変数は &lt;code&gt;.tiny&lt;/code&gt; セクションに割り当てられます。これらの変数は、 &lt;code&gt;$gp&lt;/code&gt; ベースレジスタを使用します。このオプションのデフォルトは4ですが、 &lt;code&gt;.tiny&lt;/code&gt; セクションには65536バイトの制限があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fd3f9d35c079daab2745eafe9db9775e6794913e" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;cb&lt;/code&gt; attribute are used to access the control bus, using special instructions. &lt;code&gt;addr&lt;/code&gt; indicates the control bus address. Example:</source>
          <target state="translated">&lt;code&gt;cb&lt;/code&gt; 属性を持つ変数は、特別な命令を使用して、制御バスにアクセスするために使用されます。 &lt;code&gt;addr&lt;/code&gt; は制御バスアドレスを示します。例：</target>
        </trans-unit>
        <trans-unit id="de934aeb77c58838cc9846aadb82fbd1b8f30e96" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;far&lt;/code&gt; attribute are addressed using a full 32-bit address. Since this covers the entire memory space, this allows modules to make no assumptions about where variables might be stored.</source>
          <target state="translated">&lt;code&gt;far&lt;/code&gt; 属性を持つ変数は、完全な32ビットアドレスを使用してアドレス指定されます。これはメモリ空間全体をカバーするので、これにより、モジュールは変数が格納される可能性がある場所について想定を行うことができません。</target>
        </trans-unit>
        <trans-unit id="36905cf24c84385c4961b4619b30de52faf8e512" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;io&lt;/code&gt; attribute are used to address memory-mapped peripherals. If an address is specified, the variable is assigned that address, else it is not assigned an address (it is assumed some other module assigns an address). Example:</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 属性を持つ変数は、メモリマップされたペリフェラルをアドレス指定するために使用されます。アドレスが指定されている場合、変数にはそのアドレスが割り当てられます。それ以外の場合、変数にはアドレスが割り当てられません（他のモジュールがアドレスを割り当てると想定されます）。例：</target>
        </trans-unit>
        <trans-unit id="8908399e90d6597694e9414404cf146058083fc2" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;near&lt;/code&gt; attribute are assumed to have addresses that fit in a 24-bit addressing mode. This is the default for large variables (&lt;code&gt;-mtiny=4&lt;/code&gt; is the default) but this attribute can override &lt;code&gt;-mtiny=&lt;/code&gt; for small variables, or override &lt;code&gt;-ml&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;near&lt;/code&gt; 属性を持つ変数は、24ビットアドレッシングモードに適合するアドレスを持つと想定されます。これは、大規模な変数のデフォルトである（ &lt;code&gt;-mtiny=4&lt;/code&gt; がデフォルトです）が、この属性は無効にすることができ &lt;code&gt;-mtiny=&lt;/code&gt; 小さな変数のために、または上書き &lt;code&gt;-ml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f34701193da16d128be7840c2b5e27cdc6209c0" translate="yes" xml:space="preserve">
          <source>Variadic functions always use the &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; calling convention and the compiler rejects attempts to specify an alternative.</source>
          <target state="translated">可変個引数関数は常に &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; 呼び出し規約を使用し、コンパイラーは代替を指定する試みを拒否します。</target>
        </trans-unit>
        <trans-unit id="c34add3442e320001d71a4acf459f90b84551e3c" translate="yes" xml:space="preserve">
          <source>Variations on C++.</source>
          <target state="translated">C++のバリエーション。</target>
        </trans-unit>
        <trans-unit id="0125a3430008ecbd7c8a33ef91916cf2ea436c9e" translate="yes" xml:space="preserve">
          <source>Variations on Objective-C and Objective-C++.</source>
          <target state="translated">Objective-CとObjective-C++のバリエーション。</target>
        </trans-unit>
        <trans-unit id="eb5d846c7919ee0bdc2338a4cc38cee42f3c00b6" translate="yes" xml:space="preserve">
          <source>Vector comparison is supported with standard comparison operators: &lt;code&gt;==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt;. Comparison operands can be vector expressions of integer-type or real-type. Comparison between integer-type vectors and real-type vectors are not supported. The result of the comparison is a vector of the same width and number of elements as the comparison operands with a signed integral element type.</source>
          <target state="translated">ベクトル比較は、標準の比較演算子である &lt;code&gt;==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt; サポートされています。比較オペランドは、整数型または実数型のベクトル式にすることができます。整数型ベクトルと実数型ベクトルの比較はサポートされていません。比較の結果は、符号付き整数要素型の比較オペランドと同じ幅と要素数のベクトルです。</target>
        </trans-unit>
        <trans-unit id="5abc95e73e06fb4a5dc5582edf5afa312b0850ca" translate="yes" xml:space="preserve">
          <source>Vector condition register: VCC, VCC_LO, VCC_HI</source>
          <target state="translated">ベクトル条件レジスタです。vcc、vcc_lo、vcc_hi</target>
        </trans-unit>
        <trans-unit id="53804d00035aa75837541b3ccf479dca992da7d5" translate="yes" xml:space="preserve">
          <source>Vector constant that can be loaded with XXSPLTIB &amp;amp; sign extension.</source>
          <target state="translated">XXSPLTIB＆符号拡張でロードできるベクトル定数。</target>
        </trans-unit>
        <trans-unit id="82f741b1697518a50ba54947e1a23cae2eaec1c0" translate="yes" xml:space="preserve">
          <source>Vector constant that can be loaded with the XXSPLTIB instruction.</source>
          <target state="translated">XXSPLTIB 命令でロードできるベクトル定数。</target>
        </trans-unit>
        <trans-unit id="46e517c61990308718dcf40277ed1d92f620280a" translate="yes" xml:space="preserve">
          <source>Vector constant that does not require memory</source>
          <target state="translated">メモリを必要としないベクトル定数</target>
        </trans-unit>
        <trans-unit id="b42c5127757a32ed5d06d2b5cf09ce9893f82ec9" translate="yes" xml:space="preserve">
          <source>Vector constant that is all zeros.</source>
          <target state="translated">すべてゼロであるベクトル定数。</target>
        </trans-unit>
        <trans-unit id="9c36bdfc3b8d0b06a49e5ef972497ba956ef9bbc" translate="yes" xml:space="preserve">
          <source>Vector conversion is available using the &lt;code&gt;__builtin_convertvector (vec, vectype)&lt;/code&gt; function. &lt;var&gt;vec&lt;/var&gt; must be an expression with integral or floating vector type and &lt;var&gt;vectype&lt;/var&gt; an integral or floating vector type with the same number of elements. The result has &lt;var&gt;vectype&lt;/var&gt; type and value of a C cast of every element of &lt;var&gt;vec&lt;/var&gt; to the element type of &lt;var&gt;vectype&lt;/var&gt;.</source>
          <target state="translated">ベクトル変換は &lt;code&gt;__builtin_convertvector (vec, vectype)&lt;/code&gt; 関数を使用して利用できます。 &lt;var&gt;vec&lt;/var&gt; は、整数型または浮動小数点型の式である必要があり、 &lt;var&gt;vectype&lt;/var&gt; は、要素数が同じ整数型または浮動小数点型である必要があります。結果は、 &lt;var&gt;vectype&lt;/var&gt; 型とvectypeの要素型への &lt;var&gt;vec&lt;/var&gt; のすべての要素のCキャストの値を &lt;var&gt;vectype&lt;/var&gt; ます。</target>
        </trans-unit>
        <trans-unit id="d3bad6bdbaf23ec0df51bc6d85940b036ecbab94" translate="yes" xml:space="preserve">
          <source>Vector registers.</source>
          <target state="translated">ベクトルレジスタ。</target>
        </trans-unit>
        <trans-unit id="8e0df7cd51c0d162c1fce7156e6eae770327c8c2" translate="yes" xml:space="preserve">
          <source>Vector shuffling is available using functions &lt;code&gt;__builtin_shuffle (vec, mask)&lt;/code&gt; and &lt;code&gt;__builtin_shuffle (vec0, vec1, mask)&lt;/code&gt;. Both functions construct a permutation of elements from one or two vectors and return a vector of the same type as the input vector(s). The &lt;var&gt;mask&lt;/var&gt; is an integral vector with the same width (&lt;var&gt;W&lt;/var&gt;) and element count (&lt;var&gt;N&lt;/var&gt;) as the output vector.</source>
          <target state="translated">ベクトルのシャッフルは、関数 &lt;code&gt;__builtin_shuffle (vec, mask)&lt;/code&gt; および &lt;code&gt;__builtin_shuffle (vec0, vec1, mask)&lt;/code&gt; を使用して利用できます。どちらの関数も、1つまたは2つのベクトルから要素の順列を構築し、入力ベクトルと同じタイプのベクトルを返します。 &lt;var&gt;mask&lt;/var&gt; 同じ幅（と一体ベクトルで &lt;var&gt;W&lt;/var&gt; ）と要素数（ &lt;var&gt;N&lt;/var&gt; 出力ベクトルとして）。</target>
        </trans-unit>
        <trans-unit id="58128c4d1de4d0a51bf04fac4cddbc549bd01efb" translate="yes" xml:space="preserve">
          <source>Vector zero</source>
          <target state="translated">ベクトルゼロ</target>
        </trans-unit>
        <trans-unit id="73c5f8f62b1af06d2d8df3f66347a1a059d5cf24" translate="yes" xml:space="preserve">
          <source>Vectors are compared element-wise producing 0 when comparison is false and -1 (constant of the appropriate type where all bits are set) otherwise. Consider the following example.</source>
          <target state="translated">ベクトルは要素ごとに比較され,比較が false の場合は 0 を生成し,そうでない場合は -1 (すべてのビットが設定されている適切な型の定数)を生成します.次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="fcd23bd0a88ba1a503b10ed5edf55ece81978ffc" translate="yes" xml:space="preserve">
          <source>Vectors can be subscripted as if the vector were an array with the same number of elements and base type. Out of bound accesses invoke undefined behavior at run time. Warnings for out of bound accesses for vector subscription can be enabled with</source>
          <target state="translated">ベクトルは、ベクトルが同じ要素数と基底型を持つ配列であるかのように添え字を付けることができます。束縛外アクセスは、実行時に未定義の動作を引き起こします。ベクトルのサブスクリプションに対するアウトオブバウンドアクセスの警告は</target>
        </trans-unit>
        <trans-unit id="e368f0bdb096cdc80b942de26edde7361d633b14" translate="yes" xml:space="preserve">
          <source>Version 0 refers to the version conforming most closely to the C++ ABI specification. Therefore, the ABI obtained using version 0 will change in different versions of G++ as ABI bugs are fixed.</source>
          <target state="translated">バージョン 0 とは、C++の ABI 仕様に最も近いバージョンを指します。そのため、バージョン 0 を使用して得られる ABI は、ABI のバグが修正されると、G++の異なるバージョンでも変化します。</target>
        </trans-unit>
        <trans-unit id="4d24a59e560f384b23499b32746ec055716a43ab" translate="yes" xml:space="preserve">
          <source>Version 1 is the version of the C++ ABI that first appeared in G++ 3.2.</source>
          <target state="translated">バージョン1は、G++3.2で初めて登場したC++ABIのバージョンです。</target>
        </trans-unit>
        <trans-unit id="3c0b003b505c0ed05512e30de5602e0fe9cf92cd" translate="yes" xml:space="preserve">
          <source>Version 10, which first appeared in G++ 6.1, adds mangling of attributes that affect type identity, such as ia32 calling convention attributes (e.g. &amp;lsquo;</source>
          <target state="translated">バージョン10は、G ++ 6.1で最初に登場し、ia32呼び出し規約属性（たとえば、 '</target>
        </trans-unit>
        <trans-unit id="663092bb020840a15939c0d6a393bb5154dcf611" translate="yes" xml:space="preserve">
          <source>Version 11, which first appeared in G++ 7, corrects the mangling of sizeof... expressions and operator names. For multiple entities with the same name within a function, that are declared in different scopes, the mangling now changes starting with the twelfth occurrence. It also implies</source>
          <target state="translated">G++7 で初めて登場したバージョン 11 では、sizeof...式と演算子名の乱れが修正されました。関数内で同じ名前を持つ複数のエンティティが異なるスコープで宣言されている場合、12 番目の出現から混同が変更されるようになりました。また、以下のような意味もあります。</target>
        </trans-unit>
        <trans-unit id="0ca6a1ee7b0905689803a926babe92130837b997" translate="yes" xml:space="preserve">
          <source>Version 12, which first appeared in G++ 8, corrects the calling conventions for empty classes on the x86_64 target and for classes with only deleted copy/move constructors. It accidentally changes the calling convention for classes with a deleted copy constructor and a trivial move constructor.</source>
          <target state="translated">G++8 で初めて登場したバージョン 12 では、x86_64 ターゲット上の空のクラスと削除されたコピー/移動コンストラクタのみを持つクラスの呼び出し規約が修正されました。これは、削除されたコピー・コンストラクタと些細な移動コンストラクタを持つクラスの呼び出し規約を誤って変更してしまいました。</target>
        </trans-unit>
        <trans-unit id="50a009d60ade6b341d095db62ce8f2e0c4f1391a" translate="yes" xml:space="preserve">
          <source>Version 13, which first appeared in G++ 8.2, fixes the accidental change in version 12.</source>
          <target state="translated">G++8.2で初めて登場したバージョン13では、バージョン12での偶発的な変更が修正されています。</target>
        </trans-unit>
        <trans-unit id="3b38c5970d57d0e95ac144e09f14ebe98042886d" translate="yes" xml:space="preserve">
          <source>Version 2 is the version of the C++ ABI that first appeared in G++ 3.4, and was the default through G++ 4.9.</source>
          <target state="translated">バージョン 2 は、G++3.4 で最初に登場した C++ABI のバージョンで、G++4.9 まではデフォルトでした。</target>
        </trans-unit>
        <trans-unit id="b724fbb5aa7b15b70d72eb03063512067a94eeca" translate="yes" xml:space="preserve">
          <source>Version 3 corrects an error in mangling a constant address as a template argument.</source>
          <target state="translated">バージョン3では、テンプレートの引数として定数アドレスが混同されていたエラーが修正されました。</target>
        </trans-unit>
        <trans-unit id="01a6ae459293959ae77cf0ff9e1fc859781779ed" translate="yes" xml:space="preserve">
          <source>Version 4 may require GDB 7.0 and</source>
          <target state="translated">バージョン4ではGDB 7.0と</target>
        </trans-unit>
        <trans-unit id="dd83630f9225432d363943045fc9c9e3da8fa1fd" translate="yes" xml:space="preserve">
          <source>Version 4, which first appeared in G++ 4.5, implements a standard mangling for vector types.</source>
          <target state="translated">G++4.5で初めて登場したバージョン4は、ベクトル型の標準的なマングリングを実装しています。</target>
        </trans-unit>
        <trans-unit id="bcd8e454766585098e98a3f378e25d4a3a094eb0" translate="yes" xml:space="preserve">
          <source>Version 5, which first appeared in G++ 4.6, corrects the mangling of attribute const/volatile on function pointer types, decltype of a plain decl, and use of a function parameter in the declaration of another parameter.</source>
          <target state="translated">G++4.6で初めて登場したバージョン5では、関数ポインタ型での属性const/volatileの乱れ、plain declのdectype、別のパラメータの宣言での関数パラメータの使用が修正されました。</target>
        </trans-unit>
        <trans-unit id="b60149f703c30d6cd13e3a5cac7ff5559e1b4439" translate="yes" xml:space="preserve">
          <source>Version 6, which first appeared in G++ 4.7, corrects the promotion behavior of C++11 scoped enums and the mangling of template argument packs, const/static_cast, prefix ++ and &amp;ndash;, and a class scope function used as a template argument.</source>
          <target state="translated">G ++ 4.7で最初に登場したバージョン6は、C ++ 11スコープ列挙型のプロモーション動作、テンプレート引数パック、const / static_cast、プレフィックス++および&amp;ndash;、およびテンプレート引数として使用されるクラススコープ関数のマングリングを修正します。</target>
        </trans-unit>
        <trans-unit id="4782295af04ef7af5fe54b3ee6d18f5a34a794e5" translate="yes" xml:space="preserve">
          <source>Version 7, which first appeared in G++ 4.8, that treats nullptr_t as a builtin type and corrects the mangling of lambdas in default argument scope.</source>
          <target state="translated">G++4.8で初めて登場したバージョン7では、nullptr_tを組み込み型として扱い、デフォルトの引数スコープでのラムダの乱れを修正しています。</target>
        </trans-unit>
        <trans-unit id="d1c84e5d1ca1394d2ffa2a327b111624fb731bc7" translate="yes" xml:space="preserve">
          <source>Version 8, which first appeared in G++ 4.9, corrects the substitution behavior of function types with function-cv-qualifiers.</source>
          <target state="translated">G++4.9で初めて登場したバージョン8では、function-cv修飾子を持つ関数型の置換動作が修正されました。</target>
        </trans-unit>
        <trans-unit id="4ac00f95e84165203755f6a82a57d89ac3c1bab9" translate="yes" xml:space="preserve">
          <source>Version 9, which first appeared in G++ 5.2, corrects the alignment of &lt;code&gt;nullptr_t&lt;/code&gt;.</source>
          <target state="translated">G ++ 5.2で最初に登場したバージョン9は、 &lt;code&gt;nullptr_t&lt;/code&gt; の配置を修正します。</target>
        </trans-unit>
        <trans-unit id="1cbaf9a36f9cc94b3082b235b02920043f217806" translate="yes" xml:space="preserve">
          <source>Visium&amp;mdash;</source>
          <target state="translated">Visium&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="ea87a96f76fbda4a0ceea67f5b82b7da4f4e2ed4" translate="yes" xml:space="preserve">
          <source>Volatile memory access bypass the cache using the I/O variants of the load and store instructions. The default is not to bypass the cache.</source>
          <target state="translated">揮発性メモリアクセスは、ロードおよびストア命令のI/Oバリアントを使用してキャッシュをバイパスします。デフォルトではキャッシュをバイパスしません。</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="1b1d16cb93f0aa2689c3eb4f6494e062863aa127" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011, e.g., identifiers in ISO C++ 1998 that are keywords in ISO C++ 2011. This warning turns on</source>
          <target state="translated">ISO C++1998 と ISO C++2011 の間で意味が異なる C++構成体(例えば、ISO C++1998 の識別子が ISO C++2011 のキーワードになっているなど)について警告します。この警告がオンになります。</target>
        </trans-unit>
        <trans-unit id="a16be8e81dda2e7fc6c8f9439ff0fc768831de14" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2011 and ISO C++ 2014. This warning is enabled by</source>
          <target state="translated">ISO C++2011 と ISO C++2014 の間で意味が異なる C++構成についての警告。この警告は</target>
        </trans-unit>
        <trans-unit id="7632b789c4deefeb017ad2d53cdd4160afd5fe89" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2014 and ISO C++ 2017. This warning is enabled by</source>
          <target state="translated">ISO C++2014 と ISO C++2017 の間で意味が異なる C++構成についての警告。この警告は</target>
        </trans-unit>
        <trans-unit id="53b51f298dc17e10801636bad5bebb8011117716" translate="yes" xml:space="preserve">
          <source>Warn about ISO C constructs that are outside of the common subset of ISO C and ISO C++, e.g. request for implicit conversion from &lt;code&gt;void *&lt;/code&gt; to a pointer to non-&lt;code&gt;void&lt;/code&gt; type.</source>
          <target state="translated">ISO CおよびISO C ++の一般的なサブセットの外にあるISO C構造体について警告します。たとえば、 &lt;code&gt;void *&lt;/code&gt; から非 &lt;code&gt;void&lt;/code&gt; 型へのポインターへの暗黙的な変換を要求します。</target>
        </trans-unit>
        <trans-unit id="4f7de69bb81f9d506bfb6d47f928c946ab6b330c" translate="yes" xml:space="preserve">
          <source>Warn about One Definition Rule violations during link-time optimization. Requires</source>
          <target state="translated">リンク時間の最適化中のOne Definition Ruleの違反について警告します。必要なのは</target>
        </trans-unit>
        <trans-unit id="f7cf98ad983fadf59ea9d8e55fff149a4d55f39b" translate="yes" xml:space="preserve">
          <source>Warn about a comparison between values of different enumerated types. In C++ enumerated type mismatches in conditional expressions are also diagnosed and the warning is enabled by default. In C this warning is enabled by</source>
          <target state="translated">異なる列挙型の値の比較について警告します。C++では、条件式の列挙型の不一致も診断され、この警告はデフォルトで有効になっています。C言語では、この警告は</target>
        </trans-unit>
        <trans-unit id="5887fb5f81adf7425e8f523309718b847865d42f" translate="yes" xml:space="preserve">
          <source>Warn about a definition of an unsized deallocation function</source>
          <target state="translated">サイズ指定されていない解放関数の定義についての警告</target>
        </trans-unit>
        <trans-unit id="a4b22fdd430cf26b4eb0550ba2a6437e719969f1" translate="yes" xml:space="preserve">
          <source>Warn about a new-expression of a type that requires greater alignment than the &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; but uses an allocation function without an explicit alignment parameter. This option is enabled by</source>
          <target state="translated">&lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; よりも大きいアライメントが必要であるが、明示的なアライメントパラメータなしの割り当て関数を使用するタイプの新しい式について警告します。このオプションは、</target>
        </trans-unit>
        <trans-unit id="57392da628b0c1cb78f8e90a0ce56848a537dcc1" translate="yes" xml:space="preserve">
          <source>Warn about anything that depends on the &amp;ldquo;size of&amp;rdquo; a function type or of &lt;code&gt;void&lt;/code&gt;. GNU C assigns these types a size of 1, for convenience in calculations with &lt;code&gt;void *&lt;/code&gt; pointers and pointers to functions. In C++, warn also when an arithmetic operation involves &lt;code&gt;NULL&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">関数タイプまたは &lt;code&gt;void&lt;/code&gt; の「サイズ」に依存するものについて警告します。GNU Cは、 &lt;code&gt;void *&lt;/code&gt; ポインターおよび関数へのポインターを使用した計算を容易にするために、これらのタイプにサイズ1を割り当てます。C ++では、算術演算に &lt;code&gt;NULL&lt;/code&gt; が含まれる場合にも警告します。この警告は、</target>
        </trans-unit>
        <trans-unit id="a808a76d216f717246383427b89eff52c9b874ec" translate="yes" xml:space="preserve">
          <source>Warn about boolean expression compared with an integer value different from &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;. For instance, the following comparison is always false:</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; とは異なる整数値と比較されるブール式について警告します。たとえば、次の比較は常にfalseです。</target>
        </trans-unit>
        <trans-unit id="a9d532ae5e4af7c1749f0187b9a6c681cd5f881a" translate="yes" xml:space="preserve">
          <source>Warn about calls to allocation functions decorated with attribute &lt;code&gt;alloc_size&lt;/code&gt; that specify zero bytes, including those to the built-in forms of the functions &lt;code&gt;aligned_alloc&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, and &lt;code&gt;realloc&lt;/code&gt;. Because the behavior of these functions when called with a zero size differs among implementations (and in the case of &lt;code&gt;realloc&lt;/code&gt; has been deprecated) relying on it may result in subtle portability bugs and should be avoided.</source>
          <target state="translated">属性で飾ら割り当て関数の呼び出しについて警告 &lt;code&gt;alloc_size&lt;/code&gt; 機能の組み込みのフォームにそれらを含め、ゼロバイトを指定することを &lt;code&gt;aligned_alloc&lt;/code&gt; 、 &lt;code&gt;alloca&lt;/code&gt; を、 &lt;code&gt;calloc&lt;/code&gt; 、 &lt;code&gt;malloc&lt;/code&gt; 関数、および &lt;code&gt;realloc&lt;/code&gt; を。サイズがゼロで呼び出されたときのこれらの関数の動作は実装間で異なるため（そして &lt;code&gt;realloc&lt;/code&gt; の場合は非推奨になっています）、これに依存すると微妙な移植性のバグが発生する可能性があるため、回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="3cff65779e3725cfbc2854d42263f2ace49a0bba" translate="yes" xml:space="preserve">
          <source>Warn about calls to formatted input/output functions such as &lt;code&gt;snprintf&lt;/code&gt; and &lt;code&gt;vsnprintf&lt;/code&gt; that might result in output truncation. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the &lt;var&gt;level&lt;/var&gt; argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives. Except as noted otherwise, the option uses the same logic</source>
          <target state="translated">出力の切り捨てが発生する可能性がある &lt;code&gt;snprintf&lt;/code&gt; や &lt;code&gt;vsnprintf&lt;/code&gt; などのフォーマット済み入出力関数の呼び出しについて警告します。 formatディレクティブによって書き込まれた正確なバイト数がコンパイル時に判別できない場合、 &lt;var&gt;level&lt;/var&gt; 引数と最適化に依存するヒューリスティックに基づいて推定されます。最適化を有効にすると、ほとんどの場合警告の精度が向上しますが、誤検知が発生する場合もあります。特に明記しない限り、オプションは同じロジックを使用します</target>
        </trans-unit>
        <trans-unit id="66472dc4cd87cc63c73cb46419c0fd90cf1906ba" translate="yes" xml:space="preserve">
          <source>Warn about calls to formatted input/output functions such as &lt;code&gt;sprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; that might overflow the destination buffer. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the &lt;var&gt;level&lt;/var&gt; argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives.</source>
          <target state="translated">宛先バッファがオーバーフローする可能性がある &lt;code&gt;sprintf&lt;/code&gt; や &lt;code&gt;vsprintf&lt;/code&gt; などのフォーマットされた入出力関数の呼び出しについて警告します。formatディレクティブによって書き込まれた正確なバイト数がコンパイル時に判別できない場合、 &lt;var&gt;level&lt;/var&gt; 引数と最適化に依存するヒューリスティックに基づいて推定されます。最適化を有効にすると、ほとんどの場合警告の精度が向上しますが、誤検知が発生する場合もあります。</target>
        </trans-unit>
        <trans-unit id="8986e7105a9ec8665e2dbbf6296adf8b057bee04" translate="yes" xml:space="preserve">
          <source>Warn about calls to functions decorated with attribute &lt;code&gt;alloc_size&lt;/code&gt; that attempt to allocate objects larger than the specified number of bytes, or where the result of the size computation in an integer type with infinite precision would exceed the value of &amp;lsquo;</source>
          <target state="translated">指定されたバイト数より大きいオブジェクトを &lt;code&gt;alloc_size&lt;/code&gt; うとする属性alloc_sizeで修飾された関数の呼び出し、または無限精度の整数型のサイズ計算の結果が 'の値を超える場合に警告します</target>
        </trans-unit>
        <trans-unit id="88c937d55912c756c7716e6f943b38520ff30020" translate="yes" xml:space="preserve">
          <source>Warn about cases that are both questionable and easy to avoid. For example the compiler simplifies &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;. This level of</source>
          <target state="translated">疑わしく、簡単に回避できるケースについて警告します。たとえば、コンパイラは &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt; を &lt;code&gt;1&lt;/code&gt; に簡略化します。このレベルの</target>
        </trans-unit>
        <trans-unit id="179fecfde091b7cc90c5093c0b77e7c3ec453920" translate="yes" xml:space="preserve">
          <source>Warn about catch handlers that do not catch via reference. With</source>
          <target state="translated">参照を介してキャッチしないキャッチハンドラについて警告します。このような場合は</target>
        </trans-unit>
        <trans-unit id="5d56df9ae38e57af735866e84e0cdb01862c2396" translate="yes" xml:space="preserve">
          <source>Warn about certain constructs that behave differently in traditional and ISO C. Also warn about ISO C constructs that have no traditional C equivalent, and/or problematic constructs that should be avoided.</source>
          <target state="translated">また、伝統的なC言語とISO C言語では異なる振る舞いをする特定の構成要素について警告します。</target>
        </trans-unit>
        <trans-unit id="208feed4ba7b2db7b751737e5df71463aa2d59a9" translate="yes" xml:space="preserve">
          <source>Warn about code that may have undefined semantics because of violations of sequence point rules in the C and C++ standards.</source>
          <target state="translated">C および C++標準のシーケンスポイントルールに違反しているため、セマンティクスが未定義の可能性があるコードについて警告します。</target>
        </trans-unit>
        <trans-unit id="120296c8df6378a5551d4a8157d2634bb8869dc7" translate="yes" xml:space="preserve">
          <source>Warn about constructions where there may be confusion to which &lt;code&gt;if&lt;/code&gt; statement an &lt;code&gt;else&lt;/code&gt; branch belongs. Here is an example of such a case:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 文に &lt;code&gt;else&lt;/code&gt; 分岐が属していると混乱する可能性がある構文について警告します。そのような場合の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="5a68fb773b2ee57c56ecf208d21e354737b77e2a" translate="yes" xml:space="preserve">
          <source>Warn about conversions between address spaces in the case where the resulting address space is not contained in the incoming address space.</source>
          <target state="translated">結果のアドレス空間が受信アドレス空間に含まれていない場合のアドレス空間間の変換について警告します。</target>
        </trans-unit>
        <trans-unit id="0761a82a1e056ee411ecf4ae535a9dfad8b30dfc" translate="yes" xml:space="preserve">
          <source>Warn about declarations using the &lt;code&gt;alias&lt;/code&gt; and similar attributes whose target is incompatible with the type of the alias. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;.</source>
          <target state="translated">ターゲットがエイリアスのタイプと互換性がない &lt;code&gt;alias&lt;/code&gt; および同様の属性を使用した宣言について警告します。&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性の宣言を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f643480f69fb1c621533ba0cdd904776e7e1ef4b" translate="yes" xml:space="preserve">
          <source>Warn about duplicated conditions in an if-else-if chain. For instance, warn for the following code:</source>
          <target state="translated">if-else-if チェーンで条件が重複していることを警告します。例えば、以下のコードに対して警告を出します。</target>
        </trans-unit>
        <trans-unit id="f7359f7ae633c3c242379554307ef603621fed1e" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C90, but present in ISO C99. For instance, warn about use of variable length arrays, &lt;code&gt;long long&lt;/code&gt; type, &lt;code&gt;bool&lt;/code&gt; type, compound literals, designated initializers, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;.</source>
          <target state="translated">ISO C90にはないがISO C99にはある機能について警告します。たとえば、可変長配列、 &lt;code&gt;long long&lt;/code&gt; 型、 &lt;code&gt;bool&lt;/code&gt; 型、複合リテラル、指定された初期化子などの使用について警告します。このオプションは、標準モードから独立しています。警告は、 &lt;code&gt;__extension__&lt;/code&gt; に続く式では無効になっています。</target>
        </trans-unit>
        <trans-unit id="626c854c9715d516c67e89068f1bb76234cf669a" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C99, but present in ISO C11. For instance, warn about use of anonymous structures and unions, &lt;code&gt;_Atomic&lt;/code&gt; type qualifier, &lt;code&gt;_Thread_local&lt;/code&gt; storage-class specifier, &lt;code&gt;_Alignas&lt;/code&gt; specifier, &lt;code&gt;Alignof&lt;/code&gt; operator, &lt;code&gt;_Generic&lt;/code&gt; keyword, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;.</source>
          <target state="translated">ISO C99にはないがISO C11にはある機能について警告します。たとえば、匿名の構造体と共用体、 &lt;code&gt;_Atomic&lt;/code&gt; 型修飾子、 &lt;code&gt;_Thread_local&lt;/code&gt; ストレージクラス指定子、 &lt;code&gt;_Alignas&lt;/code&gt; 指定子、 &lt;code&gt;Alignof&lt;/code&gt; 演算子、 &lt;code&gt;_Generic&lt;/code&gt; キーワードなどの使用について警告します。このオプションは、標準モードから独立しています。警告は、 &lt;code&gt;__extension__&lt;/code&gt; に続く式では無効になっています。</target>
        </trans-unit>
        <trans-unit id="643ea2b6cbf0ea1bcfec495e08e3195164382b91" translate="yes" xml:space="preserve">
          <source>Warn about function pointers that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Note these are only possible candidates, not absolute ones. GCC guesses that function pointers with &lt;code&gt;format&lt;/code&gt; attributes that are used in assignment, initialization, parameter passing or return statements should have a corresponding &lt;code&gt;format&lt;/code&gt; attribute in the resulting type. I.e. the left-hand side of the assignment or initialization, the type of the parameter variable, or the return type of the containing function respectively should also have a &lt;code&gt;format&lt;/code&gt; attribute to avoid the warning.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 属性の候補となる可能性のある関数ポインターについて警告します。これらは単なる候補であり、絶対的な候補ではないことに注意してください。 GCC は、割り当て、初期化、パラメーターの受け渡し、またはreturnステートメントで使用される &lt;code&gt;format&lt;/code&gt; 属性を持つ関数ポインターは、結果の型に対応する &lt;code&gt;format&lt;/code&gt; 属性を持つ必要があると推測します。つまり、割り当てまたは初期化の左側、パラメーター変数のタイプ、または包含関数の戻りタイプにも、警告を回避するための &lt;code&gt;format&lt;/code&gt; 属性が必要です。</target>
        </trans-unit>
        <trans-unit id="ff3534585cbc01893459375a2f73a721f1390a46" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for &lt;code&gt;cold&lt;/code&gt; attribute. This is based on static detection and generally will only warn about functions which always leads to a call to another &lt;code&gt;cold&lt;/code&gt; function such as wrappers of C++ &lt;code&gt;throw&lt;/code&gt; or fatal error reporting functions leading to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; 属性の候補となる可能性がある関数について警告します。これは静的検出に基づいており、通常は、C ++ &lt;code&gt;throw&lt;/code&gt; ラッパーなどの別の &lt;code&gt;cold&lt;/code&gt; 関数の呼び出しや、 &lt;code&gt;abort&lt;/code&gt; つながる致命的なエラー報告関数に常につながる関数についてのみ警告します。</target>
        </trans-unit>
        <trans-unit id="ad5773c66378dee79865728b1022e5f1ddb94781" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for attributes &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;noreturn&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt;. The compiler only warns for functions visible in other compilation units or (in the case of &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;) if it cannot prove that the function returns normally. A function returns normally if it doesn&amp;rsquo;t contain an infinite loop or return abnormally by throwing, calling &lt;code&gt;abort&lt;/code&gt; or trapping. This analysis requires option</source>
          <target state="translated">属性 &lt;code&gt;pure&lt;/code&gt; 、 &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;noreturn&lt;/code&gt; 、または &lt;code&gt;malloc&lt;/code&gt; の候補となる可能性がある関数について警告します。コンパイラーは、関数が正常に戻ることを証明できない場合にのみ、他のコンパイル単位または（ &lt;code&gt;pure&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; の場合）に表示される関数について警告します。関数は、無限ループが含まれていない場合は正常に戻るか、スロー、 &lt;code&gt;abort&lt;/code&gt; またはトラップの呼び出しによって異常に戻ります。この分析にはオプションが必要です</target>
        </trans-unit>
        <trans-unit id="97272a64aa6772a9d1f50422c6dbb8adfe294518" translate="yes" xml:space="preserve">
          <source>Warn about left shift overflows. This warning is enabled by default in C99 and C++11 modes (and newer).</source>
          <target state="translated">左シフトオーバーフローについて警告します。この警告は、C99 および C++11 モード(およびそれ以降)ではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="cab17a3fd72f34df7821e30e584c4c51a37bba48" translate="yes" xml:space="preserve">
          <source>Warn about logical not used on the left hand side operand of a comparison. This option does not warn if the right operand is considered to be a boolean expression. Its purpose is to detect suspicious code like the following:</source>
          <target state="translated">比較の左側のオペランドで論理が使用されていないことを警告します。このオプションは、右側のオペランドがブーリアン式であると考えられる場合には警告しません。その目的は、以下のような疑わしいコードを検出することです。</target>
        </trans-unit>
        <trans-unit id="48b82c0283a2915829a3ee6a3436cc1017b5ea05" translate="yes" xml:space="preserve">
          <source>Warn about macros defined in the main file that are unused. A macro is &lt;em&gt;used&lt;/em&gt; if it is expanded or tested for existence at least once. The preprocessor also warns if the macro has not been used at the time it is redefined or undefined.</source>
          <target state="translated">メインファイルで定義されている未使用のマクロについて警告します。マクロは、少なくとも1回は展開またはテストされて存在する場合に&lt;em&gt;使用され&lt;/em&gt;ます。プリプロセッサは、マクロが再定義または未定義のときに使用されなかった場合にも警告します。</target>
        </trans-unit>
        <trans-unit id="b4b8fd61bdb1f1846bd01a97a7bd276155ea4f4c" translate="yes" xml:space="preserve">
          <source>Warn about overriding virtual functions that are not marked with the override keyword.</source>
          <target state="translated">override キーワードでマークされていない仮想関数のオーバーライドについて警告します。</target>
        </trans-unit>
        <trans-unit id="b83b9745dc97dfb351a27bd912c00da1a8c7a2f9" translate="yes" xml:space="preserve">
          <source>Warn about passing a null pointer for arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="translated">でNULL以外の値を必要とするものとしてマークされた引数にNULLポインタを渡すことについて警告 &lt;code&gt;nonnull&lt;/code&gt; 関数属性。</target>
        </trans-unit>
        <trans-unit id="6aa9959edf6bc4922ebb912c9a250384b3090f7c" translate="yes" xml:space="preserve">
          <source>Warn about placement new expressions with undefined behavior, such as constructing an object in a buffer that is smaller than the type of the object. For example, the placement new expression below is diagnosed because it attempts to construct an array of 64 integers in a buffer only 64 bytes large.</source>
          <target state="translated">オブジェクトの型よりも小さいバッファにオブジェクトを構築するなど、定義されていない動作を持つ配置新規式について警告します。例えば、以下の配置新規式は、64 バイトしかないバッファに 64 個の整数の配列を構築しようとするために診断されます。</target>
        </trans-unit>
        <trans-unit id="185c654029973156a2e707b7e9ffcc02226e09a9" translate="yes" xml:space="preserve">
          <source>Warn about redundant semicolon after in-class function definition.</source>
          <target state="translated">クラス内関数定義の後にセミコロンが重複していることについて警告する。</target>
        </trans-unit>
        <trans-unit id="083bdeb1c857ab3b93f3cbf9b4f7687d0f51ffb4" translate="yes" xml:space="preserve">
          <source>Warn about string constants that are longer than the &amp;ldquo;minimum maximum&amp;rdquo; length specified in the C standard. Modern compilers generally allow string constants that are much longer than the standard&amp;rsquo;s minimum limit, but very portable programs should avoid using longer strings.</source>
          <target state="translated">C標準で指定された「最小最大」長より長い文字列定数について警告します。最新のコンパイラーは、標準の最小制限よりもはるかに長い文字列定数を許可しますが、非常に移植性の高いプログラムは、より長い文字列の使用を避ける必要があります。</target>
        </trans-unit>
        <trans-unit id="e453618f3508cc5c8f222f7ad7869db1fe428a6f" translate="yes" xml:space="preserve">
          <source>Warn about suspicious operations on expressions of a boolean type. For instance, bitwise negation of a boolean is very likely a bug in the program. For C, this warning also warns about incrementing or decrementing a boolean, which rarely makes sense. (In C++, decrementing a boolean is always invalid. Incrementing a boolean is invalid in C++17, and deprecated otherwise.)</source>
          <target state="translated">ブール値型の式に対する不審な操作について警告します。例えば、ブーリアン型のビット単位の否定は、プログラムのバグである可能性が高いです。Cの場合、この警告はブーリアンのインクリメントやデクリメントについても警告しますが、これはほとんど意味がありません。(C++では、ブーリアンのデクリメントは常に無効です。C++17では、ブーリアンのインクリメントは無効です。)</target>
        </trans-unit>
        <trans-unit id="2336eb6d6105fde77f9d067a2cdcc81228032540" translate="yes" xml:space="preserve">
          <source>Warn about suspicious uses of logical operators in expressions. This includes using logical operators in contexts where a bit-wise operator is likely to be expected. Also warns when the operands of a logical operator are the same:</source>
          <target state="translated">式での論理演算子の不審な使用について警告します。これには、ビットワイズ演算子が期待される可能性が高いコンテキストで論理演算子を使用することが含まれます。また、論理演算子のオペランドが同じである場合も警告します。</target>
        </trans-unit>
        <trans-unit id="47cf408f4ecd083d50c4f6fada7dd8bdd9b93bb0" translate="yes" xml:space="preserve">
          <source>Warn about suspicious uses of memory addresses. These include using the address of a function in a conditional expression, such as &lt;code&gt;void func(void); if (func)&lt;/code&gt;, and comparisons against the memory address of a string literal, such as &lt;code&gt;if (x == &quot;abc&quot;)&lt;/code&gt;. Such uses typically indicate a programmer error: the address of a function always evaluates to true, so their use in a conditional usually indicate that the programmer forgot the parentheses in a function call; and comparisons against string literals result in unspecified behavior and are not portable in C, so they usually indicate that the programmer intended to use &lt;code&gt;strcmp&lt;/code&gt;. This warning is enabled by</source>
          <target state="translated">メモリアドレスの不審な使用について警告します。これらには、関数のアドレスを &lt;code&gt;void func(void); if (func)&lt;/code&gt; などの条件式で使用することが含まれます。 if（func）、および &lt;code&gt;if (x == &quot;abc&quot;)&lt;/code&gt; などの文字列リテラルのメモリアドレスとの比較。通常、このような使用法はプログラマエラーを示します。関数のアドレスは常にtrueと評価されるため、条件での使用は通常、プログラマが関数呼び出しで括弧を忘れたことを示します。文字列リテラルとの比較は不特定の動作をもたらし、Cへの移植性がないため、通常、プログラマが &lt;code&gt;strcmp&lt;/code&gt; を使用することを意図していたことを示します。この警告は</target>
        </trans-unit>
        <trans-unit id="693b5ffe72b40cbff2e2c2d99e95d2c139392a00" translate="yes" xml:space="preserve">
          <source>Warn about the use of an uncasted &lt;code&gt;NULL&lt;/code&gt; as sentinel. When compiling only with GCC this is a valid sentinel, as &lt;code&gt;NULL&lt;/code&gt; is defined to &lt;code&gt;__null&lt;/code&gt;. Although it is a null pointer constant rather than a null pointer, it is guaranteed to be of the same size as a pointer. But this use is not portable across different compilers.</source>
          <target state="translated">センチネルとしてキャストされていない &lt;code&gt;NULL&lt;/code&gt; の使用について警告します。唯一のGCCでコンパイルした場合のように、これは、有効なセンチネルで &lt;code&gt;NULL&lt;/code&gt; がに定義されて &lt;code&gt;__null&lt;/code&gt; 。これはnullポインターではなくnullポインター定数ですが、ポインターと同じサイズであることが保証されています。ただし、この使用は、異なるコンパイラ間で移植できません。</target>
        </trans-unit>
        <trans-unit id="047e09655cbc00205404926996b3c4d4165e9649" translate="yes" xml:space="preserve">
          <source>Warn about trampolines generated for pointers to nested functions. A trampoline is a small piece of data or code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. For some targets, it is made up of data only and thus requires no special treatment. But, for most targets, it is made up of code and thus requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">入れ子になった関数へのポインタのために生成されるトランポリンについての警告。トランポリンは、入れ子になった関数のアドレスを取得したときに実行時にスタック上に生成される小さなデータやコードで、入れ子になった関数を間接的に呼び出すために使用されます。ターゲットによっては、データのみで構成されているため、特別な処理は必要ありません。しかし、ほとんどのターゲットでは、これはコードで構成されているため、プログラムが正しく動作するためには、スタックを実行可能にする必要があります。</target>
        </trans-unit>
        <trans-unit id="038f9bc926635b6b8fb6c2afe2d9bffe1c8b0f31" translate="yes" xml:space="preserve">
          <source>Warn about types with virtual methods where code quality would be improved if the type were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, declared in an anonymous namespace. This allows GCC to more aggressively devirtualize the polymorphic calls. This warning is more effective with link time optimization, where the information about the class hierarchy graph is more complete.</source>
          <target state="translated">型がC ++ 11 &lt;code&gt;final&lt;/code&gt; 指定子で宣言された場合、または可能であれば匿名の名前空間で宣言された場合にコード品質が向上する仮想メソッドを持つ型について警告します。これにより、GCCはポリモーフィックな呼び出しをより積極的に仮想化解除できます。この警告は、クラス階層グラフに関する情報がより完全なリンク時最適化でより効果的です。</target>
        </trans-unit>
        <trans-unit id="ebb96b1bde565bfb0748c8483dc57189a3190e4d" translate="yes" xml:space="preserve">
          <source>Warn about uninitialized variables that are initialized with themselves. Note this option can only be used with the</source>
          <target state="translated">初期化されていない変数が自分自身で初期化されていることを警告します。このオプションは</target>
        </trans-unit>
        <trans-unit id="3e4a4254c8cb8b052f1898488cd3d24c1bac24c2" translate="yes" xml:space="preserve">
          <source>Warn about unsafe multiple statement macros that appear to be guarded by a clause such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, or &lt;code&gt;while&lt;/code&gt;, in which only the first statement is actually guarded after the macro is expanded.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;else&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;switch&lt;/code&gt; 、または &lt;code&gt;while&lt;/code&gt; のような句によって保護されていると思われる安全でない複数のステートメントマクロについて警告します。マクロは展開された後、最初のステートメントのみが実際に保護されます。</target>
        </trans-unit>
        <trans-unit id="c815119ab8450282a6819d07553d786431d0bc98" translate="yes" xml:space="preserve">
          <source>Warn about violations of the following style guidelines from Scott Meyers&amp;rsquo; Effective C++ series of books:</source>
          <target state="translated">Scott Meyersの効果的なC ++シリーズの本からの次のスタイルガイドラインの違反について警告します。</target>
        </trans-unit>
        <trans-unit id="44cda8e3e380e8f31dd971fc6b0f31b237513dcc" translate="yes" xml:space="preserve">
          <source>Warn about virtual methods where code quality would be improved if the method were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, its type were declared in an anonymous namespace or with the &lt;code&gt;final&lt;/code&gt; specifier. This warning is more effective with link-time optimization, where the information about the class hierarchy graph is more complete. It is recommended to first consider suggestions of</source>
          <target state="translated">方法は、C ++ 11で宣言された場合、コードの品質が改善される仮想メソッドについて警告 &lt;code&gt;final&lt;/code&gt; 指定子、または、可能な場合、その型は、匿名の名前空間またはで宣言された &lt;code&gt;final&lt;/code&gt; 指定子。この警告は、クラス階層グラフに関する情報がより完全なリンク時最適化でより効果的です。最初に次の提案を検討することをお勧めします</target>
        </trans-unit>
        <trans-unit id="be3e052e75298edad5e44ae2d0677574dff86d7c" translate="yes" xml:space="preserve">
          <source>Warn for calls to bounded string manipulation functions such as &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, and &lt;code&gt;stpncpy&lt;/code&gt; that may either truncate the copied string or leave the destination unchanged.</source>
          <target state="translated">&lt;code&gt;strncat&lt;/code&gt; 、 &lt;code&gt;strncpy&lt;/code&gt; 、 &lt;code&gt;stpncpy&lt;/code&gt; などのバインドされた文字列操作関数の呼び出しを警告します。これらの関数は、コピーされた文字列を切り捨てるか、宛先を変更せずに残します。</target>
        </trans-unit>
        <trans-unit id="97f52c63875e1d71f753bc97c51fe3992eac28f3" translate="yes" xml:space="preserve">
          <source>Warn for calls to standard functions that compute the absolute value of an argument when a more appropriate standard function is available. For example, calling &lt;code&gt;abs(3.14)&lt;/code&gt; triggers the warning because the appropriate function to call to compute the absolute value of a double argument is &lt;code&gt;fabs&lt;/code&gt;. The option also triggers warnings when the argument in a call to such a function has an unsigned type. This warning can be suppressed with an explicit type cast and it is also enabled by</source>
          <target state="translated">より適切な標準関数が利用可能な場合に、引数の絶対値を計算する標準関数の呼び出しを警告します。たとえば、double引数の絶対値を計算するために呼び出す適切な関数は &lt;code&gt;fabs&lt;/code&gt; であるため、 &lt;code&gt;abs(3.14)&lt;/code&gt; を呼び出すと警告がトリガーされます。このオプションは、そのような関数の呼び出しの引数が符号なしの型である場合にも警告をトリガーします。この警告は、明示的な型キャストで抑制できます。これは、</target>
        </trans-unit>
        <trans-unit id="c5733f483a0e2d12a12ef399d58192ff21069495" translate="yes" xml:space="preserve">
          <source>Warn for calls to string manipulation functions such as &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;strcpy&lt;/code&gt; that are determined to overflow the destination buffer. The optional argument is one greater than the type of Object Size Checking to perform to determine the size of the destination. See &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;Object Size Checking&lt;/a&gt;. The argument is meaningful only for functions that operate on character arrays but not for raw memory functions like &lt;code&gt;memcpy&lt;/code&gt; which always make use of Object Size type-0. The option also warns for calls that specify a size in excess of the largest possible object or at most &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; bytes. The option produces the best results with optimization enabled but can detect a small subset of simple buffer overflows even without optimization in calls to the GCC built-in functions like &lt;code&gt;__builtin_memcpy&lt;/code&gt; that correspond to the standard functions. In any case, the option warns about just a subset of buffer overflows detected by the corresponding overflow checking built-ins. For example, the option will issue a warning for the &lt;code&gt;strcpy&lt;/code&gt; call below because it copies at least 5 characters (the string &lt;code&gt;&quot;blue&quot;&lt;/code&gt; including the terminating NUL) into the buffer of size 4.</source>
          <target state="translated">宛先バッファをオーバーフローすると判断された &lt;code&gt;memcpy&lt;/code&gt; や &lt;code&gt;strcpy&lt;/code&gt; などの文字列操作関数の呼び出しを警告します。オプションの引数は、宛先のサイズを決定するために実行するオブジェクトサイズチェックのタイプよりも1つ大きくなります。&lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;オブジェクトサイズチェックを&lt;/a&gt;参照してください。引数は、文字配列を操作する関数に対してのみ意味がありますが、常にオブジェクトサイズタイプ0を使用する &lt;code&gt;memcpy&lt;/code&gt; のような生のメモリ関数には意味がありません。このオプションは、可能な最大のオブジェクトを超えるサイズ、または最大で &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; を指定する呼び出しについても警告しますバイト。このオプションは、最適化を有効にして最良の結果を生成しますが、標準関数に対応する &lt;code&gt;__builtin_memcpy&lt;/code&gt; などのGCC組み込み関数の呼び出しで最適化を行わなくても、単純なバッファーオーバーフローの小さなサブセットを検出できます。いずれの場合でも、このオプションは、対応するオーバーフローチェックビルトインによって検出されたバッファーオーバーフローのサブセットについてのみ警告します。たとえば、このオプションは、サイズ5のバッファーに少なくとも5文字（終端のNULを含む文字列 &lt;code&gt;&quot;blue&quot;&lt;/code&gt; をコピーするため、以下の &lt;code&gt;strcpy&lt;/code&gt; 呼び出しに対して警告を発行します。</target>
        </trans-unit>
        <trans-unit id="ea89d9fe51cb214a220766e4af0abed7f830d316" translate="yes" xml:space="preserve">
          <source>Warn for cases where adding an attribute may be beneficial. The attributes currently supported are listed below.</source>
          <target state="translated">属性を追加することが有益である可能性がある場合に警告します。現在サポートされている属性は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8436e41e82368d15262acc8884e5704ddb1ce7dc" translate="yes" xml:space="preserve">
          <source>Warn for conditionally-supported (C++11 [intro.defs]) constructs.</source>
          <target state="translated">条件付きでサポートされている(C++11 [intro.defs])構成体の警告。</target>
        </trans-unit>
        <trans-unit id="ddd0db7c59c0ac572b0cd3ff62ca85c741d9e547" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that may alter a value. This includes conversions between real and integer, like &lt;code&gt;abs (x)&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;double&lt;/code&gt;; conversions between signed and unsigned, like &lt;code&gt;unsigned ui = -1&lt;/code&gt;; and conversions to smaller types, like &lt;code&gt;sqrtf (M_PI)&lt;/code&gt;. Do not warn for explicit casts like &lt;code&gt;abs
((int) x)&lt;/code&gt; and &lt;code&gt;ui = (unsigned) -1&lt;/code&gt;, or if the value is not changed by the conversion like in &lt;code&gt;abs (2.0)&lt;/code&gt;. Warnings about conversions between signed and unsigned integers can be disabled by using</source>
          <target state="translated">値を変更する可能性のある暗黙の変換について警告します。これには、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;double&lt;/code&gt; の場合の &lt;code&gt;abs (x)&lt;/code&gt; ように、実数と整数の間の変換が含まれます。 &lt;code&gt;unsigned ui = -1&lt;/code&gt; ように、符号付きと符号なしの間の変換。そして &lt;code&gt;sqrtf (M_PI)&lt;/code&gt; ようなより小さな型への変換。 &lt;code&gt;abs ((int) x)&lt;/code&gt; や &lt;code&gt;ui = (unsigned) -1&lt;/code&gt; ような明示的なキャスト、または &lt;code&gt;abs (2.0)&lt;/code&gt; ような変換によって値が変更されない場合は警告しません。符号付き整数と符号なし整数の間の変換に関する警告は、</target>
        </trans-unit>
        <trans-unit id="ec1638cbd7bdbbe5cf0d16d8253b596c446311e3" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that may change the sign of an integer value, like assigning a signed integer expression to an unsigned integer variable. An explicit cast silences the warning. In C, this option is enabled also by</source>
          <target state="translated">符号付き整数式を符号なし整数変数に代入するような、整数値の符号を変更する可能性のある暗黙の変換について警告します。明示的にキャストされた場合、警告は表示されません。C言語では、このオプションは</target>
        </trans-unit>
        <trans-unit id="97be0057bd1773b0bcfe31a7fd58f64b07846102" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that reduce the precision of a real value. This includes conversions from real to integer, and from higher precision real to lower precision real values. This option is also enabled by</source>
          <target state="translated">実数値の精度を低下させる暗黙の変換について警告します。これには、実数から整数への変換や、高精度の実数から低精度の実数への変換が含まれます。このオプションは</target>
        </trans-unit>
        <trans-unit id="fba779234a6e85d8e28133f5b96c546a4b460be1" translate="yes" xml:space="preserve">
          <source>Warn for invocations of &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;, &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the &lt;code&gt;memory_order&lt;/code&gt; enumeration. For example, since the &lt;code&gt;__atomic_store&lt;/code&gt; and &lt;code&gt;__atomic_store_n&lt;/code&gt; built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed:</source>
          <target state="translated">&lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;、&lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;、および操作に対して無効であるか、 &lt;code&gt;memory_order&lt;/code&gt; 列挙の値の範囲外であるメモリ整合性引数を持つC11アトミックジェネリック関数の呼び出しについて警告します。たとえば、 &lt;code&gt;__atomic_store&lt;/code&gt; および &lt;code&gt;__atomic_store_n&lt;/code&gt; ビルトインは、リラックスした、解放された、順次一貫したメモリオーダーに対してのみ定義されているため、次のコードが診断されます。</target>
        </trans-unit>
        <trans-unit id="588f265a9e502d85c1dc2042e355d13326591d0f" translate="yes" xml:space="preserve">
          <source>Warn for obsolescent usages, according to the C Standard, in a declaration. For example, warn if storage-class specifiers like &lt;code&gt;static&lt;/code&gt; are not the first things in a declaration. This warning is also enabled by</source>
          <target state="translated">宣言で、C標準に従って、廃止された使用法について警告します。たとえば、 &lt;code&gt;static&lt;/code&gt; のようなストレージクラス指定子が宣言の最初のものでない場合に警告します。この警告は、</target>
        </trans-unit>
        <trans-unit id="e259b4649f2c39d620aa79263dfa4900b1e91328" translate="yes" xml:space="preserve">
          <source>Warn for pointer argument passing or assignment with different signedness. This option is only supported for C and Objective-C. It is implied by</source>
          <target state="translated">ポインタの引数渡しや代入で符号化が異なる場合に警告を出します。このオプションは C と Objective-C でのみサポートされています。このオプションは</target>
        </trans-unit>
        <trans-unit id="9ff91ea12bc4958bf94b9d94062e90a35c47ff2b" translate="yes" xml:space="preserve">
          <source>Warn for suspicious calls to the &lt;code&gt;memset&lt;/code&gt; built-in function where the second argument is not zero and the third argument is zero. For example, the call &lt;code&gt;memset (buf, sizeof buf, 0)&lt;/code&gt; is diagnosed because &lt;code&gt;memset (buf, 0, sizeof buf)&lt;/code&gt; was meant instead. The diagnostic is only emitted if the third argument is a literal zero. Otherwise, if it is an expression that is folded to zero, or a cast of zero to some type, it is far less likely that the arguments have been mistakenly transposed and no warning is emitted. This warning is enabled by</source>
          <target state="translated">2番目の引数がゼロではなく、3番目の引数がゼロである &lt;code&gt;memset&lt;/code&gt; 組み込み関数の不審な呼び出しについて警告します。たとえば、 &lt;code&gt;memset (buf, 0, sizeof buf)&lt;/code&gt; が代わりに意図されていたため &lt;code&gt;memset (buf, sizeof buf, 0)&lt;/code&gt; の呼び出しが診断されます。診断は、3番目の引数がリテラル0の場合にのみ発行されます。それ以外の場合、それがゼロに折りたたまれている式、またはゼロからある型へのキャストである場合、引数が誤って転置されて警告が出されない可能性ははるかに低くなります。この警告は</target>
        </trans-unit>
        <trans-unit id="bc6dbae9a566682d74e9a96f0ac749b8042dc5bb" translate="yes" xml:space="preserve">
          <source>Warn for suspicious calls to the &lt;code&gt;memset&lt;/code&gt; built-in function, if the first argument references an array, and the third argument is a number equal to the number of elements, but not equal to the size of the array in memory. This indicates that the user has omitted a multiplication by the element size. This warning is enabled by</source>
          <target state="translated">最初の引数が配列を参照し、3番目の引数が要素の数に等しいが、メモリ内の配列のサイズに等しくない場合、 &lt;code&gt;memset&lt;/code&gt; 組み込み関数の不審な呼び出しについて警告します。これは、ユーザーが要素サイズによる乗算を省略したことを示しています。この警告は</target>
        </trans-unit>
        <trans-unit id="d71f136265b6596c9fcf21bacafb65164bba32b6" translate="yes" xml:space="preserve">
          <source>Warn for suspicious divisions of two sizeof expressions that divide the pointer size by the element size, which is the usual way to compute the array size but won&amp;rsquo;t work out correctly with pointers. This warning warns e.g. about &lt;code&gt;sizeof (ptr) / sizeof (ptr[0])&lt;/code&gt; if &lt;code&gt;ptr&lt;/code&gt; is not an array, but a pointer. This warning is enabled by</source>
          <target state="translated">ポインタのサイズを要素のサイズで除算する2つのsizeof式の疑わしい除算について警告します。これは、配列のサイズを計算する通常の方法ですが、ポインタでは正しく機能しません。この警告は、 &lt;code&gt;ptr&lt;/code&gt; が配列ではなくポインタである場合、たとえば &lt;code&gt;sizeof (ptr) / sizeof (ptr[0])&lt;/code&gt; について警告します。この警告は</target>
        </trans-unit>
        <trans-unit id="eb46193b49397250439f9bab61fa46107f1cb89b" translate="yes" xml:space="preserve">
          <source>Warn for suspicious length parameters to certain string and memory built-in functions if the argument uses &lt;code&gt;sizeof&lt;/code&gt;. This warning triggers for example for &lt;code&gt;memset (ptr, 0, sizeof (ptr));&lt;/code&gt; if &lt;code&gt;ptr&lt;/code&gt; is not an array, but a pointer, and suggests a possible fix, or about &lt;code&gt;memcpy (&amp;amp;foo, ptr, sizeof (&amp;amp;foo));&lt;/code&gt;.</source>
          <target state="translated">引数が &lt;code&gt;sizeof&lt;/code&gt; を使用する場合、特定の文字列とメモリの組み込み関数に疑わしい長さパラメーターを警告します。この警告は、たとえば &lt;code&gt;memset (ptr, 0, sizeof (ptr));&lt;/code&gt; に対してトリガーされます。場合 &lt;code&gt;ptr&lt;/code&gt; がアレイが、ポインタではなく、可能な修正を示唆している、または約 &lt;code&gt;memcpy (&amp;amp;foo, ptr, sizeof (&amp;amp;foo));&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="474691b4f69f5e3fa5e5d8572e94d30c04b806ca" translate="yes" xml:space="preserve">
          <source>Warn for suspicious use of integer values where boolean values are expected, such as conditional expressions (?:) using non-boolean integer constants in boolean context, like &lt;code&gt;if (a &amp;lt;= b ? 2 : 3)&lt;/code&gt;. Or left shifting of signed integers in boolean context, like &lt;code&gt;for (a = 0; 1 &amp;lt;&amp;lt; a; a++);&lt;/code&gt;. Likewise for all kinds of multiplications regardless of the data type. This warning is enabled by</source>
          <target state="translated">&lt;code&gt;if (a &amp;lt;= b ? 2 : 3)&lt;/code&gt; ように、ブール値のコンテキストで非ブール整数定数を使用する条件式（？:)など、ブール値が予想される整数値の疑わしい使用について警告します。または &lt;code&gt;for (a = 0; 1 &amp;lt;&amp;lt; a; a++);&lt;/code&gt; ように、ブールコンテキストで符号付き整数を左シフトします。。同様に、データ型に関係なく、すべての種類の乗算について。この警告は</target>
        </trans-unit>
        <trans-unit id="ef3f0d67d9be730bb5bb60eec12cdf29a3590cd3" translate="yes" xml:space="preserve">
          <source>Warn for variables that might be changed by &lt;code&gt;longjmp&lt;/code&gt; or &lt;code&gt;vfork&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">&lt;code&gt;longjmp&lt;/code&gt; または &lt;code&gt;vfork&lt;/code&gt; によって変更される可能性のある変数について警告します。この警告は、</target>
        </trans-unit>
        <trans-unit id="dd2e7578a65337ecde9cfa288e81a35cf44426a6" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;long long&lt;/code&gt; type is used. This is enabled by either</source>
          <target state="translated">&lt;code&gt;long long&lt;/code&gt; タイプが使用されている場合に警告します。これは、</target>
        </trans-unit>
        <trans-unit id="e19f1630667f871b7fea15d47a722bf79ecb0d1d" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression, either explicitly in an &lt;code&gt;@interface&lt;/code&gt; or &lt;code&gt;@protocol&lt;/code&gt; declaration, or implicitly in an &lt;code&gt;@implementation&lt;/code&gt; section. This option always performs its checks as soon as a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression is found, while</source>
          <target state="translated">宣言されていないセレクターを参照する &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 式が見つかった場合に警告します。セレクタは、その名前のメソッドは、以前に宣言されていない場合、宣言されていないと考えられている &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 表現、明示的に &lt;code&gt;@interface&lt;/code&gt; または &lt;code&gt;@protocol&lt;/code&gt; で暗黙的に宣言、または &lt;code&gt;@implementation&lt;/code&gt; のセクション。このオプションは常に &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 式が見つかるとすぐにチェックを実行しますが、</target>
        </trans-unit>
        <trans-unit id="004d33c975e481dfebbcb509835b3167b8da9eba" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;goto&lt;/code&gt; statement or a &lt;code&gt;switch&lt;/code&gt; statement jumps forward across the initialization of a variable, or jumps backward to a label after the variable has been initialized. This only warns about variables that are initialized when they are declared. This warning is only supported for C and Objective-C; in C++ this sort of branch is an error in any case.</source>
          <target state="translated">&lt;code&gt;goto&lt;/code&gt; ステートメントまたは &lt;code&gt;switch&lt;/code&gt; ステートメントが変数の初期化を前方にジャンプするか、変数が初期化された後にラベルに後方にジャンプする場合に警告します。これは、宣言時に初期化される変数についてのみ警告します。この警告は、CおよびObjective-Cでのみサポートされています。 C ++では、この種の分岐はいずれの場合もエラーです。</target>
        </trans-unit>
        <trans-unit id="70a205e11ff52468e2abea9748f0e8471729efe0" translate="yes" xml:space="preserve">
          <source>Warn if a built-in function is declared with an incompatible signature or as a non-function, or when a built-in function declared with a type that does not include a prototype is called with arguments whose promoted types do not match those expected by the function. When</source>
          <target state="translated">組込み関数が互換性のないシグネチャで宣言されていたり、非関数として宣言されていたり、プロトタイプを含まない型で宣言された組込み関数が、その関数が期待する型と一致しない昇格型を持つ引数で呼び出された場合に警告が出ます。以下のような場合</target>
        </trans-unit>
        <trans-unit id="7e0b0c17d1b6ef946e72a0839cb1ce3047e47301" translate="yes" xml:space="preserve">
          <source>Warn if a class type has a base or a field whose type uses the anonymous namespace or depends on a type with no linkage. If a type A depends on a type B with no or internal linkage, defining it in multiple translation units would be an ODR violation because the meaning of B is different in each translation unit. If A only appears in a single translation unit, the best way to silence the warning is to give it internal linkage by putting it in an anonymous namespace as well. The compiler doesn&amp;rsquo;t give this warning for types defined in the main .C file, as those are unlikely to have multiple definitions.</source>
          <target state="translated">クラス型に、匿名名前空間を使用する型またはリンケージのない型に依存する型のベースまたはフィールドがある場合に警告します。タイプAがタイプBに依存しているか、内部リンケージがない場合、複数の変換単位で定義すると、Bの意味が各変換単位で異なるため、ODR違反になります。 Aが単一の翻訳単位にのみ表示される場合、警告を止める最良の方法は、匿名の名前空間にも配置することで内部リンクを提供することです。コンパイラーは、メインの.Cファイルで定義されているタイプに対して、この警告を出しません。タイプが複数の定義を持つ可能性は低いからです。</target>
        </trans-unit>
        <trans-unit id="f50d7f18228e548a744dc4a11054b6259740a50d" translate="yes" xml:space="preserve">
          <source>Warn if a comparison is always true or always false due to the limited range of the data type, but do not warn for constant expressions. For example, warn if an unsigned variable is compared against zero with &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">データ型の範囲が限られているために比較が常にtrueまたは常にfalseである場合に警告しますが、定数式については警告しません。たとえば、符号なし変数が &lt;code&gt;&amp;lt;&lt;/code&gt; または &lt;code&gt;&amp;gt;=&lt;/code&gt; でゼロと比較された場合に警告します。この警告は、</target>
        </trans-unit>
        <trans-unit id="2a11d0f858be1c6e9bc24aa3b844f38a2b441160" translate="yes" xml:space="preserve">
          <source>Warn if a declaration has duplicate &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restrict&lt;/code&gt; or &lt;code&gt;_Atomic&lt;/code&gt; specifier. This warning is enabled by</source>
          <target state="translated">宣言に重複する &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;volatile&lt;/code&gt; 、 &lt;code&gt;restrict&lt;/code&gt; または &lt;code&gt;_Atomic&lt;/code&gt; 指定子がある場合に警告します。この警告は</target>
        </trans-unit>
        <trans-unit id="435844d61c42ac3708481fd4e2d3779e1e2c4fcb" translate="yes" xml:space="preserve">
          <source>Warn if a function is declared or defined without specifying the argument types. (An old-style function definition is permitted without a warning if preceded by a declaration that specifies the argument types.)</source>
          <target state="translated">引数の型を指定せずに関数を宣言または定義した場合に警告を出します。(旧式の関数定義でも、引数の型を指定する宣言が先行している場合は警告なしで許可されます)</target>
        </trans-unit>
        <trans-unit id="a760172e23a18bb5477be698491bcdf520546606" translate="yes" xml:space="preserve">
          <source>Warn if a function that is declared as inline cannot be inlined. Even with this option, the compiler does not warn about failures to inline functions declared in system headers.</source>
          <target state="translated">インラインとして宣言された関数をインライン化できない場合に警告します。このオプションを指定しても、コンパイラはシステム・ヘッダで宣言された関数のインライン化の失敗を警告しません。</target>
        </trans-unit>
        <trans-unit id="8022445f9b194569635957ab8997ae493df541b3" translate="yes" xml:space="preserve">
          <source>Warn if a global function is defined without a previous declaration. Do so even if the definition itself provides a prototype. Use this option to detect global functions that are not declared in header files. In C, no warnings are issued for functions with previous non-prototype declarations; use</source>
          <target state="translated">グローバル関数が以前の宣言なしに定義されている場合に警告を出します。定義自体がプロトタイプを提供している場合でも警告します。ヘッダファイルで宣言されていないグローバル関数を検出するには、このオプションを使用します。C言語では、以前にプロトタイプではない宣言をした関数に対しては警告を発しません。</target>
        </trans-unit>
        <trans-unit id="8accbb9b2caefa3a198b26af7aaf7ecef01e8cb3" translate="yes" xml:space="preserve">
          <source>Warn if a global function is defined without a previous prototype declaration. This warning is issued even if the definition itself provides a prototype. Use this option to detect global functions that do not have a matching prototype declaration in a header file. This option is not valid for C++ because all function declarations provide prototypes and a non-matching declaration declares an overload rather than conflict with an earlier declaration. Use</source>
          <target state="translated">グローバル関数が以前のプロトタイプ宣言なしで定義されている場合の警告。この警告は、定義自体がプロトタイプを提供している場合でも発生します。このオプションを使用すると、ヘッダーファイルに一致するプロトタイプ宣言がないグローバル関数を検出できます。すべての関数宣言はプロトタイプを提供し、一致しない宣言は以前の宣言と衝突するのではなくオーバーロードを宣言するため、このオプションは C++では有効ではありません。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="158841ec1502166264ebd7700487b8265d3a7024" translate="yes" xml:space="preserve">
          <source>Warn if a pointer is compared with a zero character constant. This usually means that the pointer was meant to be dereferenced. For example:</source>
          <target state="translated">ポインタがゼロ文字定数と比較された場合に警告が表示されます。これは通常、ポインタが参照されていないことを意味します。例えば</target>
        </trans-unit>
        <trans-unit id="cc6737ba51245ef04a02acb681eeef00c75f1a8a" translate="yes" xml:space="preserve">
          <source>Warn if a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) is found in the search path but cannot be used.</source>
          <target state="translated">プリコンパイル済みヘッダー（「&lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;プリ&lt;/a&gt;コンパイル済みヘッダー」を参照）が検索パスで見つかったが使用できない場合に警告します。</target>
        </trans-unit>
        <trans-unit id="0939e5ffcf8a00c23be50c55ee10373ce78e992e" translate="yes" xml:space="preserve">
          <source>Warn if a prototype causes a type conversion that is different from what would happen to the same argument in the absence of a prototype. This includes conversions of fixed point to floating and vice versa, and conversions changing the width or signedness of a fixed-point argument except when the same as the default promotion.</source>
          <target state="translated">プロトタイプがない場合に同じ引数に何が起こるかとは異なる型変換がプロトタイプによって引き起こされた場合に警告します。これには、固定小数点から浮動小数点への変換やその逆の変換、デフォルトの昇格と同じ場合を除いて固定小数点引数の幅や符号化を変更する変換が含まれます。</target>
        </trans-unit>
        <trans-unit id="f0026b1975a3aa571d75e5560f23067faee1ed8d" translate="yes" xml:space="preserve">
          <source>Warn if a register variable is declared volatile. The volatile modifier does not inhibit all optimizations that may eliminate reads and/or writes to register variables. This warning is enabled by</source>
          <target state="translated">レジスタ変数がvolatileと宣言されている場合に警告します。volatile修飾子は、レジスタ変数への読み取りおよび/または書き込みを排除する可能性のあるすべての最適化を抑制するものではありません。この警告は</target>
        </trans-unit>
        <trans-unit id="3798bc740d5ed1fe194f654e04bcdb3d1c47efb1" translate="yes" xml:space="preserve">
          <source>Warn if a requested optimization pass is disabled. This warning does not generally indicate that there is anything wrong with your code; it merely indicates that GCC&amp;rsquo;s optimizers are unable to handle the code effectively. Often, the problem is that your code is too big or too complex; GCC refuses to optimize programs when the optimization itself is likely to take inordinate amounts of time.</source>
          <target state="translated">要求された最適化パスが無効になっている場合に警告します。この警告は通常、コードに問題があることを示すものではありません。GCCのオプティマイザがコードを効果的に処理できないことを示しているだけです。多くの場合、問題はコードが大きすぎるか複雑すぎることです。GCCは、最適化自体に膨大な時間がかかる可能性がある場合、プログラムの最適化を拒否します。</target>
        </trans-unit>
        <trans-unit id="13c5db18900b8a64496f744ccfd5e2648bd6cc79" translate="yes" xml:space="preserve">
          <source>Warn if a self-comparison always evaluates to true or false. This warning detects various mistakes such as:</source>
          <target state="translated">自己比較が常に真か偽かを評価している場合に警告します。この警告は、以下のような様々な間違いを検出します。</target>
        </trans-unit>
        <trans-unit id="3ddcbce9d2796dc0f4331ea0e609fc2579e95907" translate="yes" xml:space="preserve">
          <source>Warn if a structure field with explicitly specified alignment in a packed struct or union is misaligned. For example, a warning will be issued on &lt;code&gt;struct S&lt;/code&gt;, like, &lt;code&gt;warning: alignment 1 of
'struct S' is less than 8&lt;/code&gt;, in this code:</source>
          <target state="translated">パックされた構造体または共用体で明示的に指定された配置の構造体フィールドが正しく配置されていない場合に警告します。たとえば、次の警告のように、警告が &lt;code&gt;struct S&lt;/code&gt; に対して発行されます。このコードで &lt;code&gt;warning: alignment 1 of 'struct S' is less than 8&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4090da0abd58db5d6b3c1df786fa78fbd44ccb0c" translate="yes" xml:space="preserve">
          <source>Warn if a structure is given the packed attribute, but the packed attribute has no effect on the layout or size of the structure. Such structures may be mis-aligned for little benefit. For instance, in this code, the variable &lt;code&gt;f.x&lt;/code&gt; in &lt;code&gt;struct bar&lt;/code&gt; is misaligned even though &lt;code&gt;struct bar&lt;/code&gt; does not itself have the packed attribute:</source>
          <target state="translated">構造体にpack属性が指定されている場合に警告しますが、packed属性は構造のレイアウトやサイズに影響しません。このような構造は、メリットがほとんどないために位置がずれている場合があります。たとえば、次のコードでは、 &lt;code&gt;struct bar&lt;/code&gt; 自体にpack属性がない場合でも、 &lt;code&gt;struct bar&lt;/code&gt; の変数 &lt;code&gt;f.x&lt;/code&gt; 位置がずれています。</target>
        </trans-unit>
        <trans-unit id="25445489d5b31008c73b432793637e0936c19aa4" translate="yes" xml:space="preserve">
          <source>Warn if a structure&amp;rsquo;s initializer has some fields missing. For example, the following code causes such a warning, because &lt;code&gt;x.h&lt;/code&gt; is implicitly zero:</source>
          <target state="translated">構造体の初期化子に欠落しているフィールドがある場合に警告します。たとえば、次のコードでは、 &lt;code&gt;x.h&lt;/code&gt; が暗黙的にゼロであるため、このような警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="ff8391aca57a7124434de4ac423b8ea2b9835ac5" translate="yes" xml:space="preserve">
          <source>Warn if a user-supplied include directory does not exist.</source>
          <target state="translated">ユーザが指定したインクルードディレクトリが存在しない場合に警告を表示します。</target>
        </trans-unit>
        <trans-unit id="3fc14a4903f34179ede0f1ca4ae1ec5c8d1b70b1" translate="yes" xml:space="preserve">
          <source>Warn if a variable-length array is used in the code.</source>
          <target state="translated">コード内で可変長の配列が使用されている場合に警告します。</target>
        </trans-unit>
        <trans-unit id="36f8e0d2c860d788d014b0fd6079fd78b6555ede" translate="yes" xml:space="preserve">
          <source>Warn if an &lt;code&gt;extern&lt;/code&gt; declaration is encountered within a function.</source>
          <target state="translated">関数内で &lt;code&gt;extern&lt;/code&gt; 宣言があった場合に警告します。</target>
        </trans-unit>
        <trans-unit id="2a938c70ebc261d86f7b298216ca1b2a1c719c46" translate="yes" xml:space="preserve">
          <source>Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for &lt;code&gt;a&lt;/code&gt; is not fully bracketed, but that for &lt;code&gt;b&lt;/code&gt; is fully bracketed. This warning is enabled by</source>
          <target state="translated">集約または共用体の初期化子が完全に括弧で囲まれていない場合に警告します。次の例では、 &lt;code&gt;a&lt;/code&gt; の初期化子は完全に括弧で囲まれていませんが、 &lt;code&gt;b&lt;/code&gt; の初期化子は完全に括弧で囲まれています。この警告は</target>
        </trans-unit>
        <trans-unit id="13b8026e8132cdf11c73019d5520d0d0def0ca31" translate="yes" xml:space="preserve">
          <source>Warn if an array subscript has type &lt;code&gt;char&lt;/code&gt;. This is a common cause of error, as programmers often forget that this type is signed on some machines. This warning is enabled by</source>
          <target state="translated">配列の添字の型が &lt;code&gt;char&lt;/code&gt; の場合に警告します。プログラマーがこのタイプが一部のマシンで署名されていることをしばしば忘れるので、これはエラーの一般的な原因です。この警告は</target>
        </trans-unit>
        <trans-unit id="4eadd49680011e5fcccbd2afb576905c49ae4f6b" translate="yes" xml:space="preserve">
          <source>Warn if an automatic variable is used without first being initialized or if a variable may be clobbered by a &lt;code&gt;setjmp&lt;/code&gt; call. In C++, warn if a non-static reference or non-static &lt;code&gt;const&lt;/code&gt; member appears in a class without constructors.</source>
          <target state="translated">最初に初期化されずに自動変数が使用された場合、または変数が &lt;code&gt;setjmp&lt;/code&gt; 呼び出しによって破壊される可能性がある場合に警告します。C ++では、非静的参照または非静的 &lt;code&gt;const&lt;/code&gt; メンバーがコンストラクターなしのクラスに出現する場合に警告します。</target>
        </trans-unit>
        <trans-unit id="dc1ee512cf2decbbe83cea7bedf87603b46e0326" translate="yes" xml:space="preserve">
          <source>Warn if an empty body occurs in an &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; or &lt;code&gt;do
while&lt;/code&gt; statement. This warning is also enabled by</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;else&lt;/code&gt; 、または &lt;code&gt;do while&lt;/code&gt; ステートメントで空のボディが発生した場合に警告します。この警告は、</target>
        </trans-unit>
        <trans-unit id="383fdc3973b7b5cc3531ea392827d8edfbd6eb85" translate="yes" xml:space="preserve">
          <source>Warn if an initialized field with side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;). This warning is enabled by default.</source>
          <target state="translated">副作用の初期化フィールドが指定された初期化子を使用するときに上書きされた場合に警告します（参照&lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;指定イニシャライザ&lt;/a&gt;）。この警告はデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="fdf68e08c13104db975e1e1b5bfffcc9f671b2dc" translate="yes" xml:space="preserve">
          <source>Warn if an initialized field without side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;).</source>
          <target state="translated">副作用なしに初期化されたフィールドが指定された初期化子を使用するときに上書きされた場合に警告します（参照&lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;指定イニシャライザ&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d80a9ebeceb31bde1433b7b0306e206a1d5169eb" translate="yes" xml:space="preserve">
          <source>Warn if an old-style (C-style) cast to a non-void type is used within a C++ program. The new-style casts (&lt;code&gt;dynamic_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, &lt;code&gt;reinterpret_cast&lt;/code&gt;, and &lt;code&gt;const_cast&lt;/code&gt;) are less vulnerable to unintended effects and much easier to search for.</source>
          <target state="translated">C ++プログラム内で非void型にキャストされた古いスタイル（Cスタイル）が使用されている場合に警告します。新しいスタイルのキャスト（ &lt;code&gt;dynamic_cast&lt;/code&gt; を、 &lt;code&gt;static_cast&lt;/code&gt; を、 &lt;code&gt;reinterpret_cast&lt;/code&gt; は、と &lt;code&gt;const_cast&lt;/code&gt; ）意図しない影響を受けにくくしての検索がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="c7f9169958964ae3bf708d5e9fc733f1b6f3d079" translate="yes" xml:space="preserve">
          <source>Warn if an old-style function definition is used. A warning is given even if there is a previous prototype.</source>
          <target state="translated">旧式の関数定義が使用されている場合に警告を出す。以前のプロトタイプがあっても警告が出ます。</target>
        </trans-unit>
        <trans-unit id="da6e0c7f139a454bc8182dc0ec55a473f639305f" translate="yes" xml:space="preserve">
          <source>Warn if an undefined identifier is evaluated in an &lt;code&gt;#if&lt;/code&gt; directive. Such identifiers are replaced with zero.</source>
          <target state="translated">&lt;code&gt;#if&lt;/code&gt; ディレクティブで未定義の識別子が評価された場合に警告します。このような識別子はゼロに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="ac1c57ed34616373c808e98ba1a7016be9451740" translate="yes" xml:space="preserve">
          <source>Warn if any functions that return structures or unions are defined or called. (In languages where you can return an array, this also elicits a warning.)</source>
          <target state="translated">構造体や結合を返す関数が定義されていたり、呼び出されたりした場合に警告を出します。(配列を返すことができる言語では、これも警告を発します)。</target>
        </trans-unit>
        <trans-unit id="51dd1d087c6f2f3e06e53605399888ad9deb557f" translate="yes" xml:space="preserve">
          <source>Warn if any trigraphs are encountered that might change the meaning of the program. Trigraphs within comments are not warned about, except those that would form escaped newlines.</source>
          <target state="translated">プログラムの意味を変更する可能性のあるトリグラフがあった場合に警告します。コメント内のトリグラフは、エスケープされた改行を形成するものを除いては警告されません。</target>
        </trans-unit>
        <trans-unit id="4ffcebae22b64bc0188075323e253a892fb2c53e" translate="yes" xml:space="preserve">
          <source>Warn if anything is declared more than once in the same scope, even in cases where multiple declaration is valid and changes nothing.</source>
          <target state="translated">同じスコープ内で何かが複数回宣言された場合、複数回の宣言が有効で何も変わらない場合でも警告します。</target>
        </trans-unit>
        <trans-unit id="e116ff785f520c78cab89ec80c259fd9b971e9a1" translate="yes" xml:space="preserve">
          <source>Warn if feedback profiles are missing when using the</source>
          <target state="translated">を使用しているときに、フィードバックプロファイルが見つからない場合に警告を表示します。</target>
        </trans-unit>
        <trans-unit id="159621fc69892b60a8932abc53e5e7077fd3432a" translate="yes" xml:space="preserve">
          <source>Warn if feedback profiles do not match when using the</source>
          <target state="translated">を使用しているときにフィードバックプロファイルが一致しない場合に警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="4484a988d285daa67ba50d8d0068eac8b9c3b671" translate="yes" xml:space="preserve">
          <source>Warn if floating-point values are used in equality comparisons.</source>
          <target state="translated">浮動小数点値が等値比較で使用されている場合に警告します。</target>
        </trans-unit>
        <trans-unit id="5905365a7243693b281255e7cd734a616d419731" translate="yes" xml:space="preserve">
          <source>Warn if in a loop with constant number of iterations the compiler detects undefined behavior in some statement during one or more of the iterations.</source>
          <target state="translated">反復回数が一定のループで、1 回以上の反復の間にコンパイラが文の中で未定義の動作を検出した場合に警告します。</target>
        </trans-unit>
        <trans-unit id="30ffd0486ea9b42613bc7458b80c284dea250c07" translate="yes" xml:space="preserve">
          <source>Warn if left shifting a negative value. This warning is enabled by</source>
          <target state="translated">負の値を左にシフトした場合に警告します。この警告は</target>
        </trans-unit>
        <trans-unit id="59ffb10f60449caf44bc018fb1547abe48a875a4" translate="yes" xml:space="preserve">
          <source>Warn if multiple methods of different types for the same selector are found during compilation. The check is performed on the list of methods in the final stage of compilation. Additionally, a check is performed for each selector appearing in a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression, and a corresponding method for that selector has been found during compilation. Because these checks scan the method table only at the end of compilation, these warnings are not produced if the final stage of compilation is not reached, for example because an error is found during compilation, or because the</source>
          <target state="translated">コンパイル中に同じセレクターの異なるタイプの複数のメソッドが見つかった場合に警告します。チェックは、コンパイルの最終段階でメソッドのリストに対して実行されます。さらに、 &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 式に現れる各セレクターに対してチェックが実行され、そのセレクターに対応するメソッドがコンパイル中に見つかりました。これらのチェックはコンパイルの最後にのみメソッドテーブルをスキャンするため、コンパイル中にエラーが検出されたため、または</target>
        </trans-unit>
        <trans-unit id="cd90c2f7bb5d921c657a205bebfbd186d1fe38a6" translate="yes" xml:space="preserve">
          <source>Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;Class&lt;/code&gt;. When this flag is off (which is the default behavior), the compiler omits such warnings if any differences found are confined to types that share the same size and alignment.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; または &lt;code&gt;Class&lt;/code&gt; タイプのレシーバーにこのセレクターを使用してメッセージを送信しようとしたときに、指定されたセレクターに対して引数や戻り値のタイプが異なる複数のメソッドが見つかった場合に警告します。このフラグがオフ（デフォルトの動作）の場合、検出された差異が同じサイズと配置を共有する型に限定されている場合、コンパイラーはそのような警告を省略します。</target>
        </trans-unit>
        <trans-unit id="b4a4ef5836fcd4eb9eae356fd7d365383ac64fa2" translate="yes" xml:space="preserve">
          <source>Warn if padding is included in a structure, either to align an element of the structure or to align the whole structure. Sometimes when this happens it is possible to rearrange the fields of the structure to reduce the padding and so make the structure smaller.</source>
          <target state="translated">構造体にパディングが含まれている場合、構造体の要素を整列させたり、構造体全体を整列させたりすると警告が出ます。このような場合、構造体のフィールドを再配置してパディングを減らし、構造体を小さくすることができることがあります。</target>
        </trans-unit>
        <trans-unit id="cd9ef45fbb8d72f1831fd326b4e220df7e2faf4b" translate="yes" xml:space="preserve">
          <source>Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence people often get confused about.</source>
          <target state="translated">真理値が期待されるコンテキストで代入がある場合や、演算子が入れ子になっていて優先順位がよくわからない場合など、特定のコンテキストで括弧が省略されている場合に警告します。</target>
        </trans-unit>
        <trans-unit id="3dceb1e23a828c2f0ba0a906a334b86bd9449ace" translate="yes" xml:space="preserve">
          <source>Warn if shift count &amp;gt;= width of type. This warning is enabled by default.</source>
          <target state="translated">シフトカウント&amp;gt; =タイプの幅の場合に警告します。この警告はデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="782b64d027fe58cf65d8d3d5a2401f820f146ca7" translate="yes" xml:space="preserve">
          <source>Warn if shift count is negative. This warning is enabled by default.</source>
          <target state="translated">シフトカウントが負の場合に警告を表示します。この警告はデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="9c75b9200e1a12aae1dc4d040bec33d9a26d867e" translate="yes" xml:space="preserve">
          <source>Warn if the C++17 feature making &lt;code&gt;noexcept&lt;/code&gt; part of a function type changes the mangled name of a symbol relative to C++14. Enabled by</source>
          <target state="translated">関数タイプの &lt;code&gt;noexcept&lt;/code&gt; 部分を作成するC ++ 17機能が、C ++ 14に関連する記号の符号化された名前を変更する場合に警告します。によって有効化</target>
        </trans-unit>
        <trans-unit id="46702f45847b2104b177e9b694f3c3f7e2226105" translate="yes" xml:space="preserve">
          <source>Warn if the ISR is misspelled, i.e. without __vector prefix. Enabled by default.</source>
          <target state="translated">ISR のスペルに間違いがある場合、つまり __vector の接頭辞がない場合に警告します。デフォルトでは有効になっています。</target>
        </trans-unit>
        <trans-unit id="33d88165f92bdb2b45ff7a297ce9db7215dfa02b" translate="yes" xml:space="preserve">
          <source>Warn if the compiler detects paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. This option is only active when</source>
          <target state="translated">NULL ポインタの参照が原因で誤った動作や未定義の動作を引き起こすパスをコンパイラが検出した場合に警告します。このオプションは</target>
        </trans-unit>
        <trans-unit id="201bd84a1d08c6c2787e78691ed2f3f92ff20d03" translate="yes" xml:space="preserve">
          <source>Warn if the loop cannot be optimized because the compiler cannot assume anything on the bounds of the loop indices. With</source>
          <target state="translated">コンパイラがループインデックスの境界を何も仮定できないため、ループを最適化できない場合に警告します。このような場合には</target>
        </trans-unit>
        <trans-unit id="6ce9dcfeb56e93b36f3824efcafb3fac2f89db30" translate="yes" xml:space="preserve">
          <source>Warn if the return type of a function has a type qualifier such as &lt;code&gt;const&lt;/code&gt;. For ISO C such a type qualifier has no effect, since the value returned by a function is not an lvalue. For C++, the warning is only emitted for scalar types or &lt;code&gt;void&lt;/code&gt;. ISO C prohibits qualified &lt;code&gt;void&lt;/code&gt; return types on function definitions, so such return types always receive a warning even without this option.</source>
          <target state="translated">関数の戻り型に &lt;code&gt;const&lt;/code&gt; などの型修飾子がある場合に警告します。 ISO Cの場合、関数によって返される値は左辺値ではないため、このような型修飾子は効果がありません。 C ++の場合、警告はスカラー型または &lt;code&gt;void&lt;/code&gt; に対してのみ発行されます。 ISO C は関数定義での限定された &lt;code&gt;void&lt;/code&gt; 戻り型を禁止しているため、そのような戻り型はこのオプションがなくても常に警告を受け取ります。</target>
        </trans-unit>
        <trans-unit id="84e834ec069e09da87cddcf3972bf0a3064670e4" translate="yes" xml:space="preserve">
          <source>Warn if the size of a function frame exceeds &lt;var&gt;byte-size&lt;/var&gt;. The computation done to determine the stack frame size is approximate and not conservative. The actual requirements may be somewhat greater than &lt;var&gt;byte-size&lt;/var&gt; even if you do not get a warning. In addition, any space allocated via &lt;code&gt;alloca&lt;/code&gt;, variable-length arrays, or related constructs is not included by the compiler when determining whether or not to issue a warning.</source>
          <target state="translated">関数フレームの &lt;var&gt;byte-size&lt;/var&gt; がbyte-sizeを超えた場合に警告します。スタックフレームサイズを決定するために行われる計算は概算であり、保守的ではありません。警告が表示されない場合でも、実際の要件は &lt;var&gt;byte-size&lt;/var&gt; より多少大きい場合があります。さらに、 &lt;code&gt;alloca&lt;/code&gt; 、可変長配列、または関連する構造を介して割り当てられたスペースは、警告を発行するかどうかを決定するときにコンパイラーに含まれません。</target>
        </trans-unit>
        <trans-unit id="5b03e969a133a7f61dfd42668c90fbd199dc871d" translate="yes" xml:space="preserve">
          <source>Warn if the stack usage of a function might exceed &lt;var&gt;byte-size&lt;/var&gt;. The computation done to determine the stack usage is conservative. Any space allocated via &lt;code&gt;alloca&lt;/code&gt;, variable-length arrays, or related constructs is included by the compiler when determining whether or not to issue a warning.</source>
          <target state="translated">関数のスタック使用量が &lt;var&gt;byte-size&lt;/var&gt; を超える可能性がある場合に警告します。スタック使用量を決定するために行われる計算は控えめです。 &lt;code&gt;alloca&lt;/code&gt; 、可変長配列、または関連する構成要素を介して割り当てられたスペースは、警告を発行するかどうかを決定するときにコンパイラによって含まれます。</target>
        </trans-unit>
        <trans-unit id="949e7c4b1e5fd9dd73b3df3e4dd44a3a50fb46cc" translate="yes" xml:space="preserve">
          <source>Warn if the type of &lt;code&gt;main&lt;/code&gt; is suspicious. &lt;code&gt;main&lt;/code&gt; should be a function with external linkage, returning int, taking either zero arguments, two, or three arguments of appropriate types. This warning is enabled by default in C++ and is enabled by either</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; のタイプが疑わしい場合は警告します。 &lt;code&gt;main&lt;/code&gt; は、外部リンケージを持つ関数で、intを返し、適切な型の引数を0個、2個、または3個取る必要があります。この警告は、C ++ではデフォルトで有効になっており、次のいずれかで有効になります</target>
        </trans-unit>
        <trans-unit id="6da28b5dec8555c7e8c577e4ad18fb400e3b7e57" translate="yes" xml:space="preserve">
          <source>Warn if the vectorizer cost model overrides the OpenMP simd directive set by user. The</source>
          <target state="translated">ベクタライザのコストモデルがユーザが設定したOpenMPのsimd指令を上書きした場合に警告します。これは、ユーザが設定した</target>
        </trans-unit>
        <trans-unit id="cd147a815b47d8a61a481259e6bec92f6328c4b1" translate="yes" xml:space="preserve">
          <source>Warn if variadic macros are used in ISO C90 mode, or if the GNU alternate syntax is used in ISO C99 mode. This is enabled by either</source>
          <target state="translated">ISO C90 モードで変種マクロが使われている場合や、 ISO C99 モードで GNU 代替構文が使われている場合に警告します。これは、以下のいずれかの方法で有効になります。</target>
        </trans-unit>
        <trans-unit id="55d977b102dea3867bcd6836e9a2eac79a9f6018" translate="yes" xml:space="preserve">
          <source>Warn if vector operation is not implemented via SIMD capabilities of the architecture. Mainly useful for the performance tuning. Vector operation can be implemented &lt;code&gt;piecewise&lt;/code&gt;, which means that the scalar operation is performed on every vector element; &lt;code&gt;in parallel&lt;/code&gt;, which means that the vector operation is implemented using scalars of wider type, which normally is more performance efficient; and &lt;code&gt;as a single scalar&lt;/code&gt;, which means that vector fits into a scalar type.</source>
          <target state="translated">アーキテクチャのSIMD機能を介してベクトル演算が実装されていない場合に警告します。主にパフォーマンス調整に役立ちます。ベクトル演算は &lt;code&gt;piecewise&lt;/code&gt; に実装できます。つまり、すべてのベクトル要素に対してスカラー演算が実行されます。 &lt;code&gt;in parallel&lt;/code&gt; 、つまりより広い型のスカラーを使用してベクトル演算が実装されることを意味します。これは通常、パフォーマンスがより効率的です。そして &lt;code&gt;as a single scalar&lt;/code&gt; スカラー型にそのベクターの適合を意味します。</target>
        </trans-unit>
        <trans-unit id="d552f4c46cc5d3bd7e299e5496e695efcda3d372" translate="yes" xml:space="preserve">
          <source>Warn on uses of the &lt;code&gt;register&lt;/code&gt; storage class specifier, except when it is part of the GNU &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; extension. The use of the &lt;code&gt;register&lt;/code&gt; keyword as storage class specifier has been deprecated in C++11 and removed in C++17. Enabled by default with</source>
          <target state="translated">GNU &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;拡張の一部である場合を除き、 &lt;code&gt;register&lt;/code&gt; ストレージクラス指定子の使用について警告します。記憶域クラス指定子としての &lt;code&gt;register&lt;/code&gt; キーワードの使用は、C ++ 11では非推奨になり、C ++ 17では削除されました。デフォルトで有効</target>
        </trans-unit>
        <trans-unit id="77c0caa2b84a54b5bcf764add54f563ae56b7071" translate="yes" xml:space="preserve">
          <source>Warn that the implicit declaration of a copy constructor or copy assignment operator is deprecated if the class has a user-provided copy constructor or copy assignment operator, in C++11 and up. This warning is enabled by</source>
          <target state="translated">C++11 以降では、クラスにユーザー提供のコピー コンストラクタまたはコピー代入演算子がある場合、コピー コンストラクタまたはコピー代入演算子の暗黙の宣言は非推奨であることを警告します。この警告は</target>
        </trans-unit>
        <trans-unit id="4d2e76892f19022181f5882885c8f72e1722da44" translate="yes" xml:space="preserve">
          <source>Warn upon questionable usage of the macros used to handle variable arguments like &lt;code&gt;va_start&lt;/code&gt;. This is default. To inhibit the warning messages, use</source>
          <target state="translated">&lt;code&gt;va_start&lt;/code&gt; のような変数の引数を処理するために使用されるマクロの疑わしい使用について警告します。これがデフォルトです。警告メッセージを抑制するには、</target>
        </trans-unit>
        <trans-unit id="3abec5289cdc959e5a13fe23b53843308a01da72" translate="yes" xml:space="preserve">
          <source>Warn when &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; and &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; built-in functions are used. These functions changed semantics in GCC 4.4.</source>
          <target state="translated">&lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; および &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; 組み込み関数が使用されている場合に警告します。これらの関数は、GCC 4.4でセマンティクスを変更しました。</target>
        </trans-unit>
        <trans-unit id="2aa9b92f65cbea3024eccc7e04605b70f951ef46" translate="yes" xml:space="preserve">
          <source>Warn when &lt;code&gt;delete&lt;/code&gt; is used to destroy an instance of a class that has virtual functions and non-virtual destructor. It is unsafe to delete an instance of a derived class through a pointer to a base class if the base class does not have a virtual destructor. This warning is enabled by</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; を使用して、仮想関数と非仮想デストラクタを持つクラスのインスタンスを破棄するときに警告します。基本クラスに仮想デストラクタがない場合、基本クラスへのポインタを介して派生クラスのインスタンスを削除するのは安全ではありません。この警告は</target>
        </trans-unit>
        <trans-unit id="f21bdb487f01146075a954516a5aced86463b3d2" translate="yes" xml:space="preserve">
          <source>Warn when G++ it generates code that is probably not compatible with the vendor-neutral C++ ABI. Since G++ now defaults to updating the ABI with each major release, normally</source>
          <target state="translated">G++がベンダーニュートラルな C++ABI と互換性のないコードを生成するときに警告が表示されます。G++は現在、メジャーリリースごとに ABI を更新することをデフォルトとしているため、通常は</target>
        </trans-unit>
        <trans-unit id="35e0de5085f6b803ca5c49ba47e5ebe4c1616823" translate="yes" xml:space="preserve">
          <source>Warn when a &lt;code&gt;#pragma&lt;/code&gt; directive is encountered that is not understood by GCC. If this command-line option is used, warnings are even issued for unknown pragmas in system header files. This is not the case if the warnings are only enabled by the</source>
          <target state="translated">GCCによって理解されていない &lt;code&gt;#pragma&lt;/code&gt; ディレクティブが検出されたときに警告します。このコマンドラインオプションを使用すると、システムヘッダーファイル内の不明なプラグマに対しても警告が発行されます。これは、警告が</target>
        </trans-unit>
        <trans-unit id="62d4dab62f762a61b2f522842ea9ed134dd06936" translate="yes" xml:space="preserve">
          <source>Warn when a class has virtual functions and an accessible non-virtual destructor itself or in an accessible polymorphic base class, in which case it is possible but unsafe to delete an instance of a derived class through a pointer to the class itself or base class. This warning is automatically enabled if</source>
          <target state="translated">クラスが仮想関数とアクセス可能な非仮想デストラクタを持っている場合、あるいはアクセス可能な多相基底クラスにある場合に警告が表示されます。この警告は、以下の場合に自動的に有効になります。</target>
        </trans-unit>
        <trans-unit id="2cb7e95f48120a523e19a1fdc36b0b8e1ca72f8b" translate="yes" xml:space="preserve">
          <source>Warn when a class is defined with a virtual direct base class. Some coding rules disallow multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also define classes that indirectly use virtual inheritance.</source>
          <target state="translated">クラスが仮想直接基底クラスで定義されている場合に警告します。コーディングルールの中には多重継承を禁止しているものがあり、これはそのルールを強制するために使用されることがあります。警告は STL のようなシステムヘッダファイル内では非アクティブなので、STL を使用することができます。また、間接的に仮想継承を使用するクラスを定義することもできます。</target>
        </trans-unit>
        <trans-unit id="856d4cae226810333db6e35bc2ec148c4f408659" translate="yes" xml:space="preserve">
          <source>Warn when a class is defined with multiple direct base classes. Some coding rules disallow multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also define classes that indirectly use multiple inheritance.</source>
          <target state="translated">クラスが複数の直接基底クラスで定義されている場合に警告します。コーディングルールの中には、複数の継承を禁止しているものがあり、これはそのルールを強制するために使用されることがあります。警告は STL のようなシステムヘッダファイル内では無効なので、STL を使用することができます。また、間接的に多重継承を使用するクラスを定義することもできます。</target>
        </trans-unit>
        <trans-unit id="62d55cbfe764766f5f6f7218d2c7a740a50c90ce" translate="yes" xml:space="preserve">
          <source>Warn when a class seems unusable because all the constructors or destructors in that class are private, and it has neither friends nor public static member functions. Also warn if there are no non-private methods, and there&amp;rsquo;s at least one private member function that isn&amp;rsquo;t a constructor or destructor.</source>
          <target state="translated">クラス内のすべてのコンストラクタまたはデストラクタがプライベートであり、そのクラスにフレンドもパブリックスタティックメンバー関数もないため、クラスが使用できないように見えるときに警告します。非プライベートメソッドがなく、コンストラクタまたはデストラクタではないプライベートメンバー関数が少なくとも1つある場合にも警告します。</target>
        </trans-unit>
        <trans-unit id="3da6bed540b8c798c01ac10e6f991d33a93d7840" translate="yes" xml:space="preserve">
          <source>Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned. In C++, this warning is also enabled by</source>
          <target state="translated">符号付き値が符号なし値に変換されたときに、符号付き値と符号なし値の比較が正しくない結果になる可能性がある場合に警告が表示されます。C++では、この警告は</target>
        </trans-unit>
        <trans-unit id="d0d230a7b94f00a257ce101a92be2d7094f8073f" translate="yes" xml:space="preserve">
          <source>Warn when a declaration does not specify a type. This warning is enabled by</source>
          <target state="translated">宣言が型を指定していない場合の警告 この警告は</target>
        </trans-unit>
        <trans-unit id="65d83d710bdf5c622a92b858d79d70755ab8010e" translate="yes" xml:space="preserve">
          <source>Warn when a declaration is found after a statement in a block. This construct, known from C++, was introduced with ISO C99 and is by default allowed in GCC. It is not supported by ISO C90. See &lt;a href=&quot;mixed-declarations#Mixed-Declarations&quot;&gt;Mixed Declarations&lt;/a&gt;.</source>
          <target state="translated">ブロック内のステートメントの後に宣言が見つかったときに警告します。C ++から知られているこの構造はISO C99で導入され、GCCではデフォルトで許可されています。ISO C90ではサポートされていません。&lt;a href=&quot;mixed-declarations#Mixed-Declarations&quot;&gt;混合宣言を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a51fcbd164dc3089b47299b1d3b6f2732c7c6fcc" translate="yes" xml:space="preserve">
          <source>Warn when a declaration of a function is missing one or more attributes that a related function is declared with and whose absence may adversely affect the correctness or efficiency of generated code. For example, the warning is issued for declarations of aliases that use attributes to specify less restrictive requirements than those of their targets. This typically represents a potential optimization opportunity. By contrast, the</source>
          <target state="translated">関数の宣言に、関連する関数が宣言されている属性が1つ以上欠けており、その属性が存在しないと、生成されたコードの正確性や効率性に悪影響を及ぼす可能性がある場合に警告が出されます。例えば、ターゲットの属性よりも制限の少ない要件を指定するために属性を使用するエイリアスの宣言に対して警告が出されます。これは通常、潜在的な最適化の機会を表しています。対照的に</target>
        </trans-unit>
        <trans-unit id="4f18983de88b8950abf6205674919e5d25d36a1f" translate="yes" xml:space="preserve">
          <source>Warn when a function call is cast to a non-matching type. For example, warn if a call to a function returning an integer type is cast to a pointer type.</source>
          <target state="translated">関数呼び出しがマッチしない型にキャストされた場合に警告します。例えば、整数型を返す関数の呼び出しがポインタ型にキャストされると警告します。</target>
        </trans-unit>
        <trans-unit id="1fee5efa47b570695ab661666c6e4fee9e9b04a8" translate="yes" xml:space="preserve">
          <source>Warn when a function declaration hides virtual functions from a base class. For example, in:</source>
          <target state="translated">関数宣言で仮想関数が基底クラスから隠されている場合に警告が表示されます。例えば、イン</target>
        </trans-unit>
        <trans-unit id="e0dab17ca245164b1ca8348967e2bf698b2a4654" translate="yes" xml:space="preserve">
          <source>Warn when a function pointer is cast to an incompatible function pointer. In a cast involving function types with a variable argument list only the types of initial arguments that are provided are considered. Any parameter of pointer-type matches any other pointer-type. Any benign differences in integral types are ignored, like &lt;code&gt;int&lt;/code&gt; vs. &lt;code&gt;long&lt;/code&gt; on ILP32 targets. Likewise type qualifiers are ignored. The function type &lt;code&gt;void (*) (void)&lt;/code&gt; is special and matches everything, which can be used to suppress this warning. In a cast involving pointer to member types this warning warns whenever the type cast is changing the pointer to member type. This warning is enabled by</source>
          <target state="translated">関数ポインタが互換性のない関数ポインタにキャストされたときに警告します。可変引数リストを持つ関数タイプを含むキャストでは、提供される初期引数のタイプのみが考慮されます。ポインター型のパラメーターは、他のポインター型と一致します。ILP32ターゲットの &lt;code&gt;int&lt;/code&gt; と &lt;code&gt;long&lt;/code&gt; のように、整数型の良性の違いは無視されます。同様に、型修飾子は無視されます。関数タイプ &lt;code&gt;void (*) (void)&lt;/code&gt; は特別であり、すべてに一致するため、この警告を抑制するために使用できます。メンバー型へのポインターを含むキャストでは、型キャストがメンバー型へのポインターを変更するたびにこの警告が警告します。この警告は</target>
        </trans-unit>
        <trans-unit id="1c95c86068b8b8d1d8a72bc94ef016e54d5ce483" translate="yes" xml:space="preserve">
          <source>Warn when a literal &amp;lsquo;</source>
          <target state="translated">リテラルのときに警告する '</target>
        </trans-unit>
        <trans-unit id="fc5d5783ac1277dfc41a8a050b298452017de063" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter whose type is compatible with that of the shadowing variable. In C++, type compatibility here means the type of the shadowing variable can be converted to that of the shadowed variable. The creation of this flag (in addition to</source>
          <target state="translated">ローカル変数がシャドウイング変数の型と互換性のある別のローカル変数またはパラメータのシャドウイングを行う場合に警告が表示されます。C++では、ここでいう型互換性とは、シャドウイング変数の型をシャドウイング変数の型に変換できることを意味します。このフラグの作成は</target>
        </trans-unit>
        <trans-unit id="15ad15a27db9c39d53d6f814ef18cd0f426f15bd" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter. This warning is enabled by</source>
          <target state="translated">ローカル変数が他のローカル変数やパラメータの影になっている場合に警告を表示します。この警告は</target>
        </trans-unit>
        <trans-unit id="7332bfdf0522cbf64f5e187ed28df9e9bbf190d7" translate="yes" xml:space="preserve">
          <source>Warn when a namespace definition is opened. Some coding rules disallow namespaces, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also use using directives and qualified names.</source>
          <target state="translated">名前空間の定義が開かれたときに警告します。コーディング規則の中には名前空間を許可しないものがあり、これはその規則を強制するために使用されることがあります。警告は STL などのシステムヘッダファイル内では無効なので、STL を使用することができます。また、ディレクティブや修飾名を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="0c68af853608801bfccea4375c872dd95f8c2c74" translate="yes" xml:space="preserve">
          <source>Warn when a noexcept-expression evaluates to false because of a call to a function that does not have a non-throwing exception specification (i.e. &lt;code&gt;throw()&lt;/code&gt; or &lt;code&gt;noexcept&lt;/code&gt;) but is known by the compiler to never throw an exception.</source>
          <target state="translated">&lt;code&gt;throw()&lt;/code&gt; しない例外指定（すなわち、throw（）または &lt;code&gt;noexcept&lt;/code&gt; ）を持たないが例外をスローしないことがコンパイラーに認識されている関数の呼び出しのためにnoexcept-expressionがfalseと評価されたときに警告します。</target>
        </trans-unit>
        <trans-unit id="64beb2070ebf4a8be0aefd1a955c78bef9d98677" translate="yes" xml:space="preserve">
          <source>Warn when a primary template declaration is encountered. Some coding rules disallow templates, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also instantiate or specialize templates.</source>
          <target state="translated">プライマリテンプレート宣言に遭遇したときに警告します。コーディングルールの中にはテンプレートを禁止するものがあり、これはそのルールを強制するために使用されることがあります。警告は STL などのシステムヘッダファイル内では非アクティブなので、STL を使用することができます。テンプレートをインスタンス化したり、特殊化したりすることもできます。</target>
        </trans-unit>
        <trans-unit id="ecfd63f7bf76274a278010015f443553fb311275" translate="yes" xml:space="preserve">
          <source>Warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore. As a conforming extension, GCC treats such suffixes as separate preprocessing tokens in order to maintain backwards compatibility with code that uses formatting macros from &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">文字列または文字リテラルの後に、アンダースコアで始まらないud-suffixが続く場合に警告します。準拠する拡張機能として、GCCは &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; のフォーマットマクロを使用するコードとの下位互換性を維持するために、このようなサフィックスを個別の前処理トークンとして扱います。例えば：</target>
        </trans-unit>
        <trans-unit id="af55e43f2240ead9470434a0686aeb1f0a48afd9" translate="yes" xml:space="preserve">
          <source>Warn when a switch case falls through. For example:</source>
          <target state="translated">スイッチケースが貫通したときに警告します。例えば</target>
        </trans-unit>
        <trans-unit id="fae5e5411e11c5c48526329b8f085ab67410eafc" translate="yes" xml:space="preserve">
          <source>Warn when a type with an ABI tag is used in a context that does not have that ABI tag. See &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C++ Attributes&lt;/a&gt; for more information about ABI tags.</source>
          <target state="translated">ABIタグを持つ型が、そのABIタグを持たないコンテキストで使用されたときに警告します。ABIタグの詳細については、&lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C ++属性&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b81088e3c7de4ba5e43b90938614126c8743c79a" translate="yes" xml:space="preserve">
          <source>Warn when a typedef locally defined in a function is not used. This warning is enabled by</source>
          <target state="translated">関数内でローカルに定義されたtypedefが使用されていない場合の警告。この警告は</target>
        </trans-unit>
        <trans-unit id="7f92b37eeb1fc74d56bfb3de4e40a33e9756c1f8" translate="yes" xml:space="preserve">
          <source>Warn when an attribute is ignored. This is different from the</source>
          <target state="translated">属性が無視されたときに警告を出します。とは異なります。</target>
        </trans-unit>
        <trans-unit id="69d8172c43b83e36a9fc251e2742504cc5f07f18" translate="yes" xml:space="preserve">
          <source>Warn when an expression is casted to its own type.</source>
          <target state="translated">式が独自の型にキャストされている場合に警告します。</target>
        </trans-unit>
        <trans-unit id="68276b3f14c999ac5fd8362dd7f4c1eb0d25507e" translate="yes" xml:space="preserve">
          <source>Warn when an if-else has identical branches. This warning detects cases like</source>
          <target state="translated">if-else が同一のブランチを持つ場合の警告。この警告は</target>
        </trans-unit>
        <trans-unit id="4eaddac0ef918127a66832ad98be3ebdfc801bcd" translate="yes" xml:space="preserve">
          <source>Warn when an object referenced by a &lt;code&gt;restrict&lt;/code&gt;-qualified parameter (or, in C++, a &lt;code&gt;__restrict&lt;/code&gt;-qualified parameter) is aliased by another argument, or when copies between such objects overlap. For example, the call to the &lt;code&gt;strcpy&lt;/code&gt; function below attempts to truncate the string by replacing its initial characters with the last four. However, because the call writes the terminating NUL into &lt;code&gt;a[4]&lt;/code&gt;, the copies overlap and the call is diagnosed.</source>
          <target state="translated">&lt;code&gt;restrict&lt;/code&gt; 修飾パラメーター（またはC ++では &lt;code&gt;__restrict&lt;/code&gt; -qualifiedパラメーター）によって参照されるオブジェクトが別の引数によってエイリアスされている場合、またはそのようなオブジェクト間のコピーが重複している場合に警告します。たとえば、以下の &lt;code&gt;strcpy&lt;/code&gt; 関数の呼び出しは、最初の文字を最後の4文字に置き換えることで文字列を切り捨てようとします。ただし、呼び出しによって終了NULが &lt;code&gt;a[4]&lt;/code&gt; に書き込まれるため、コピーが重複し、呼び出しが診断されます。</target>
        </trans-unit>
        <trans-unit id="48e014515a7db6fc79ef0eeec4d6a1ef40fdd1b6" translate="yes" xml:space="preserve">
          <source>Warn when comparing an argument marked with the &lt;code&gt;nonnull&lt;/code&gt; function attribute against null inside the function.</source>
          <target state="translated">null &lt;code&gt;nonnull&lt;/code&gt; 関数属性でマークされた引数を関数内のnull と比較するときに警告します。</target>
        </trans-unit>
        <trans-unit id="448f3542d0488bfdc3c401daf34114424d62966e" translate="yes" xml:space="preserve">
          <source>Warn when deleting a pointer to incomplete type, which may cause undefined behavior at runtime. This warning is enabled by default.</source>
          <target state="translated">不完全な型へのポインタを削除すると、実行時に未定義の動作を引き起こす可能性があるため、警告が表示されます。この警告はデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="4aead77201e88b8231585b494878f47ece446b42" translate="yes" xml:space="preserve">
          <source>Warn when macros &lt;code&gt;__TIME__&lt;/code&gt;, &lt;code&gt;__DATE__&lt;/code&gt; or &lt;code&gt;__TIMESTAMP__&lt;/code&gt; are encountered as they might prevent bit-wise-identical reproducible compilations.</source>
          <target state="translated">マクロ &lt;code&gt;__TIME__&lt;/code&gt; 、 &lt;code&gt;__DATE__&lt;/code&gt; または &lt;code&gt;__TIMESTAMP__&lt;/code&gt; が検出されると、ビット単位で同一の再現可能なコンパイルを妨げる可能性があるため、警告します。</target>
        </trans-unit>
        <trans-unit id="f416313a5d687fda4c349efcccdbcd43185983e0" translate="yes" xml:space="preserve">
          <source>Warn when overload resolution chooses a promotion from unsigned or enumerated type to a signed type, over a conversion to an unsigned type of the same size. Previous versions of G++ tried to preserve unsignedness, but the standard mandates the current behavior.</source>
          <target state="translated">オーバーロード解決が、同じサイズの符号なし型への変換よりも、符号なし型または列挙型から符号付き型への昇格を選択した場合に警告が表示されます。G++の以前のバージョンでは、符号なしを保持しようとしていましたが、標準では現在の動作を強制しています。</target>
        </trans-unit>
        <trans-unit id="6b26cc3f03f85ab2638c4cf2001a077d93732070" translate="yes" xml:space="preserve">
          <source>Warn when the &amp;lsquo;</source>
          <target state="translated">「ときに警告</target>
        </trans-unit>
        <trans-unit id="8090e980ff3867e87fe893e55e71d464e21173ec" translate="yes" xml:space="preserve">
          <source>Warn when the &lt;code&gt;sizeof&lt;/code&gt; operator is applied to a parameter that is declared as an array in a function definition. This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">関数定義で配列として宣言されているパラメーターに &lt;code&gt;sizeof&lt;/code&gt; 演算子が適用されたときに警告します。この警告は、CおよびC ++プログラムではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="9e36c088ae2b71459782ca704065537e9a26901f" translate="yes" xml:space="preserve">
          <source>Warn when the address of packed member of struct or union is taken, which usually results in an unaligned pointer value. This is enabled by default.</source>
          <target state="translated">構造体やユニオンのパックされたメンバのアドレスが取られた場合に警告が表示されます。これはデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="99f87649fa1908434c721b9cad02a2282152635b" translate="yes" xml:space="preserve">
          <source>Warn when the destination of a call to a raw memory function such as &lt;code&gt;memset&lt;/code&gt; or &lt;code&gt;memcpy&lt;/code&gt; is an object of class type, and when writing into such an object might bypass the class non-trivial or deleted constructor or copy assignment, violate const-correctness or encapsulation, or corrupt virtual table pointers. Modifying the representation of such objects may violate invariants maintained by member functions of the class. For example, the call to &lt;code&gt;memset&lt;/code&gt; below is undefined because it modifies a non-trivial class object and is, therefore, diagnosed. The safe way to either initialize or clear the storage of objects of such types is by using the appropriate constructor or assignment operator, if one is available.</source>
          <target state="translated">&lt;code&gt;memset&lt;/code&gt; や &lt;code&gt;memcpy&lt;/code&gt; などのrawメモリ関数の呼び出し先がクラス型のオブジェクトである場合に警告し、そのようなオブジェクトへの書き込みがクラスの非自明または削除されたコンストラクターまたはコピー割り当てをバイパスする可能性がある場合、const-correctnessまたはカプセル化、または破損した仮想テーブルポインタ。このようなオブジェクトの表現を変更すると、クラスのメンバー関数によって維持される不変条件に違反する可能性があります。たとえば、以下の &lt;code&gt;memset&lt;/code&gt; の呼び出しは、重要なクラスオブジェクトを変更し、したがって診断されるため、未定義です。このような型のオブジェクトのストレージを初期化またはクリアする安全な方法は、適切なコンストラクターまたは割り当て演算子（使用可能な場合）を使用することです。</target>
        </trans-unit>
        <trans-unit id="40608df8d0fb171d8c9fd495ba5d5a7b32bd842d" translate="yes" xml:space="preserve">
          <source>Warn when the indentation of the code does not reflect the block structure. Specifically, a warning is issued for &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt; clauses with a guarded statement that does not use braces, followed by an unguarded statement with the same indentation.</source>
          <target state="translated">コードのインデントがブロック構造を反映していないときに警告します。具体的には、 &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;else&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; 、および中括弧を使用しない保護されたステートメント &lt;code&gt;for&lt;/code&gt; 句に対して警告が発行され、その後に同じインデントを持つ保護されていないステートメントが発行されます。</target>
        </trans-unit>
        <trans-unit id="ccf62a55eeac02e2a52c16724b5155a1eb1a630e" translate="yes" xml:space="preserve">
          <source>Warn when the order of member initializers given in the code does not match the order in which they must be executed. For instance:</source>
          <target state="translated">コードで指定されたメンバ初期化子の順番が、実行される順番と一致しない場合に警告が表示されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="761311d3e33c39156d8e3725fcf020a8f1821794" translate="yes" xml:space="preserve">
          <source>Warn when the stack frame of a function exceeds &lt;var&gt;n&lt;/var&gt; bytes.</source>
          <target state="translated">関数のスタックフレームが &lt;var&gt;n&lt;/var&gt; バイトを超えたときに警告します。</target>
        </trans-unit>
        <trans-unit id="837d376bd42b01ca86e7606408854284b9f96c39" translate="yes" xml:space="preserve">
          <source>Warn whenever &amp;lsquo;</source>
          <target state="translated">いつでも警告する '</target>
        </trans-unit>
        <trans-unit id="0c2135b897d3d5641cf8e18388c032eb11d6e43a" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement contains statements between the controlling expression and the first case label, which will never be executed. For example:</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; ステートメントに制御式と最初のケースラベルの間のステートメントが含まれている場合は常に警告します。例えば：</target>
        </trans-unit>
        <trans-unit id="3eb686177c30ed2e6e5f5f2664f95e4bb53041fa" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement does not have a &lt;code&gt;default&lt;/code&gt; case.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; ステートメントに &lt;code&gt;default&lt;/code&gt; ケースがない場合は常に警告します。</target>
        </trans-unit>
        <trans-unit id="3ee15f4deaad963ee59e6e25cbd36a97c1a0b6f8" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of boolean type and the case values are outside the range of a boolean type. It is possible to suppress this warning by casting the controlling expression to a type other than &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; ステートメントにブール型のインデックスがあり、ケース値がブール型の範囲外である場合は常に警告します。制御式を &lt;code&gt;bool&lt;/code&gt; 以外の型にキャストすることにより、この警告を抑制することができます。例えば：</target>
        </trans-unit>
        <trans-unit id="d226ed0209ee1c2fb6432b4c47bf17b27b050c76" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of enumerated type and lacks a &lt;code&gt;case&lt;/code&gt; for one or more of the named codes of that enumeration. (The presence of a &lt;code&gt;default&lt;/code&gt; label prevents this warning.) &lt;code&gt;case&lt;/code&gt; labels outside the enumeration range also provoke warnings when this option is used (even if there is a &lt;code&gt;default&lt;/code&gt; label). This warning is enabled by</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; ステートメントに列挙型のインデックスがあり、その列挙の名前付きコードの1つ以上の &lt;code&gt;case&lt;/code&gt; が欠けている場合は常に警告します。（ &lt;code&gt;default&lt;/code&gt; ラベルが存在すると、この警告は回避されます。）このオプションを使用すると、列挙型の範囲外の &lt;code&gt;case&lt;/code&gt; ラベルでも警告が表示されます（ &lt;code&gt;default&lt;/code&gt; ラベルがある場合でも）。この警告は</target>
        </trans-unit>
        <trans-unit id="de11d7b668ccdb23ca7bd8a246e58548a37f3260" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of enumerated type and lacks a &lt;code&gt;case&lt;/code&gt; for one or more of the named codes of that enumeration. &lt;code&gt;case&lt;/code&gt; labels outside the enumeration range also provoke warnings when this option is used. The only difference between</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; ステートメントに列挙型のインデックスがあり、その列挙の名前付きコードの1つ以上の &lt;code&gt;case&lt;/code&gt; が欠けている場合は常に警告します。このオプションを使用すると、列挙範囲外の &lt;code&gt;case&lt;/code&gt; ラベルでも警告が表示されます。唯一の違いは</target>
        </trans-unit>
        <trans-unit id="2d59fb66fde78bda0a4dd35cce84a5db357b0d28" translate="yes" xml:space="preserve">
          <source>Warn whenever a comment-start sequence &amp;lsquo;</source>
          <target state="translated">コメント開始シーケンスのたびに警告する '</target>
        </trans-unit>
        <trans-unit id="017d9dfe987bf5077b04f6ad0db50c54e128c51c" translate="yes" xml:space="preserve">
          <source>Warn whenever a constant static variable is unused aside from its declaration.</source>
          <target state="translated">定数の静的変数が宣言以外で使われていない場合に警告を出します。</target>
        </trans-unit>
        <trans-unit id="44c2f3d6fa32cff8b5706f1e4a38180d5b65ee57" translate="yes" xml:space="preserve">
          <source>Warn whenever a function is defined with a return type that defaults to &lt;code&gt;int&lt;/code&gt;. Also warn about any &lt;code&gt;return&lt;/code&gt; statement with no return value in a function whose return type is not &lt;code&gt;void&lt;/code&gt; (falling off the end of the function body is considered returning without a value).</source>
          <target state="translated">関数がデフォルトで &lt;code&gt;int&lt;/code&gt; に設定されている戻り値の型で定義されている場合は常に警告します。また、戻り値の型が &lt;code&gt;void&lt;/code&gt; でない関数で戻り値のない &lt;code&gt;return&lt;/code&gt; ステートメントについて警告します（関数本体の最後から落ちると、値なしで戻ると見なされます）。</target>
        </trans-unit>
        <trans-unit id="89fb51e22730b538a06b8e80540c16d1c3734cc8" translate="yes" xml:space="preserve">
          <source>Warn whenever a function parameter is assigned to, but otherwise unused (aside from its declaration).</source>
          <target state="translated">関数パラメータが代入されているが、それ以外の場合には(その宣言は別として)使用されていない場合に警告を出します。</target>
        </trans-unit>
        <trans-unit id="7522f02e51d59309d9911182c3c068a365219bc7" translate="yes" xml:space="preserve">
          <source>Warn whenever a function parameter is unused aside from its declaration.</source>
          <target state="translated">関数のパラメータが宣言以外で使用されていない場合に警告を出します。</target>
        </trans-unit>
        <trans-unit id="c0a7eb9ab9f17ff83adfaf6aff2a67a4af1e6664" translate="yes" xml:space="preserve">
          <source>Warn whenever a label is declared but not used. This warning is enabled by</source>
          <target state="translated">ラベルが宣言されているが使用されていない場合に警告を表示します。この警告は</target>
        </trans-unit>
        <trans-unit id="2d58d8f5ceb022d5ba0d30591a67aed1db06f84d" translate="yes" xml:space="preserve">
          <source>Warn whenever a local or static variable is unused aside from its declaration. This option implies</source>
          <target state="translated">ローカル変数やスタティック変数が宣言以外で使用されていない場合に警告を出します。このオプションは</target>
        </trans-unit>
        <trans-unit id="6e4150091f2d91d35b21758f7af8935b067c74b6" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable is assigned to, but otherwise unused (aside from its declaration). This warning is enabled by</source>
          <target state="translated">ローカル変数が代入されているが、それ以外では使用されていない場合に警告を表示します (宣言は別として)。この警告は</target>
        </trans-unit>
        <trans-unit id="79ce592a35665d53c155cc3462735224db9a9571" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable or type declaration shadows another variable, parameter, type, class member (in C++), or instance variable (in Objective-C) or whenever a built-in function is shadowed. Note that in C++, the compiler warns if a local variable shadows an explicit typedef, but not if it shadows a struct/class/enum. Same as</source>
          <target state="translated">ローカル変数や型宣言が他の変数、パラメータ、型、クラス・メンバ (C++)、インスタンス変数 (Objective-C)の影になったり、組み込み関数の影になったりすると警告が表示されます。C++では、ローカル変数が明示的な型定義の影になるとコンパイラが警告しますが、構造体/クラス/enum の影になると警告しないことに注意してください。と同じです。</target>
        </trans-unit>
        <trans-unit id="05ffb9a97b76e12ea54aaaeb8badea77adb678ae" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast so as to remove a type qualifier from the target type. For example, warn if a &lt;code&gt;const char *&lt;/code&gt; is cast to an ordinary &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">ターゲット型から型修飾子を削除するためにポインターがキャストされたときに警告します。たとえば、 &lt;code&gt;const char *&lt;/code&gt; が通常の &lt;code&gt;char *&lt;/code&gt; にキャストされた場合に警告します。</target>
        </trans-unit>
        <trans-unit id="9c63ef9e66f9b18bee95bf1723987dfd5d11a58f" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a &lt;code&gt;char *&lt;/code&gt; is cast to an &lt;code&gt;int *&lt;/code&gt; on machines where integers can only be accessed at two- or four-byte boundaries.</source>
          <target state="translated">ターゲットの必要な配置が増加するようにポインターがキャストされたときに警告します。たとえば、整数が2バイトまたは4バイト境界でのみアクセスできるマシンで、 &lt;code&gt;char *&lt;/code&gt; が &lt;code&gt;int *&lt;/code&gt; にキャストされた場合に警告します。</target>
        </trans-unit>
        <trans-unit id="ef7fc95a5c54b16b21f690678e6321f329b8c724" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a &lt;code&gt;char *&lt;/code&gt; is cast to an &lt;code&gt;int *&lt;/code&gt; regardless of the target machine.</source>
          <target state="translated">ターゲットの必要な配置が増加するようにポインターがキャストされたときに警告します。たとえば、ターゲットマシンに関係なく、 &lt;code&gt;char *&lt;/code&gt; が &lt;code&gt;int *&lt;/code&gt; にキャストされた場合に警告します。</target>
        </trans-unit>
        <trans-unit id="f17199fabf0d6edb5e8d9320d9584ee47f24d757" translate="yes" xml:space="preserve">
          <source>Warn whenever a statement computes a result that is explicitly not used. To suppress this warning cast the unused expression to &lt;code&gt;void&lt;/code&gt;. This includes an expression-statement or the left-hand side of a comma expression that contains no side effects. For example, an expression such as &lt;code&gt;x[i,j]&lt;/code&gt; causes a warning, while &lt;code&gt;x[(void)i,j]&lt;/code&gt; does not.</source>
          <target state="translated">ステートメントが明示的に使用されていない結果を計算するときに警告します。この警告を抑制するには、未使用の式を &lt;code&gt;void&lt;/code&gt; にキャストします。これには、式ステートメントまたは副作用のないコンマ式の左側が含まれます。たとえば、 &lt;code&gt;x[i,j]&lt;/code&gt; などの式では警告が発生しますが、 &lt;code&gt;x[(void)i,j]&lt;/code&gt; では発生しません。</target>
        </trans-unit>
        <trans-unit id="e9ed26895683fb69327818c06ae2df9969d8a9f1" translate="yes" xml:space="preserve">
          <source>Warn whenever a static function is declared but not defined or a non-inline static function is unused. This warning is enabled by</source>
          <target state="translated">静的関数が宣言されているが定義されていない場合や、インラインではない静的関数が使用されていない場合に警告が表示されます。この警告は</target>
        </trans-unit>
        <trans-unit id="682ef1b46b2728b71e94a89b2010ca06ceb12456" translate="yes" xml:space="preserve">
          <source>Warn whenever an Objective-C assignment is being intercepted by the garbage collector.</source>
          <target state="translated">Objective-C の割り当てがガベージコレクタによって傍受されているときに警告する。</target>
        </trans-unit>
        <trans-unit id="5f84fae543b9699e7c995142a54b65f353ecae8d" translate="yes" xml:space="preserve">
          <source>Warn whenever an object is defined whose size exceeds &lt;var&gt;byte-size&lt;/var&gt;.</source>
          <target state="translated">サイズが &lt;var&gt;byte-size&lt;/var&gt; を超えるオブジェクトが定義されたときに警告します。</target>
        </trans-unit>
        <trans-unit id="ea0ef30fd9bda293d78af05a20b81fc75c62d811" translate="yes" xml:space="preserve">
          <source>Warning Options</source>
          <target state="translated">警告オプション</target>
        </trans-unit>
        <trans-unit id="986ddebcadb3fa23d23a5b826b014fe8f130debb" translate="yes" xml:space="preserve">
          <source>Warning about assigning a signed value to an unsigned variable.</source>
          <target state="translated">符号付き値を符号なし変数に代入する際の警告。</target>
        </trans-unit>
        <trans-unit id="e9e66e7d69e59ab3855b10526f1e61fff27e7187" translate="yes" xml:space="preserve">
          <source>Warning about using an expression whose type is signed as a shift count.</source>
          <target state="translated">型がシフトカウントとして符号化されている式の使用に関する警告。</target>
        </trans-unit>
        <trans-unit id="418dee8a9f5c36e0b14dc254214604e6561b0bc6" translate="yes" xml:space="preserve">
          <source>Warning when a non-void function value is ignored.</source>
          <target state="translated">非ボイド関数の値が無視された場合の警告</target>
        </trans-unit>
        <trans-unit id="6016747760c907aec70fe12b355cb7c681c5c0db" translate="yes" xml:space="preserve">
          <source>Warnings are diagnostic messages that report constructions that are not inherently erroneous but that are risky or suggest there may have been an error.</source>
          <target state="translated">警告は、本質的に誤っているわけではありませんが、リスクがあるか、エラーが発生している可能性があることを示唆するような構造を報告する診断メッセージです。</target>
        </trans-unit>
        <trans-unit id="0dd982bec66fde4c74400108fddfd5cb384244af" translate="yes" xml:space="preserve">
          <source>Warnings may indicate danger points where you should check to make sure that your program really does what you intend; or the use of obsolete features; or the use of nonstandard features of GNU C or C++. Many warnings are issued only if you ask for them, with one of the</source>
          <target state="translated">警告は、あなたのプログラムが本当にあなたの意図した通りの動作をするかどうかを確認するためにチェックすべき危険なポイントを示しているかもしれません。多くの警告は、あなたがそれらを要求した場合にのみ、以下のいずれかを用いて発行されます。</target>
        </trans-unit>
        <trans-unit id="774110e2ee23eade4be0249d185f9d3f531f461a" translate="yes" xml:space="preserve">
          <source>Weak pointers are supported through a new type character specifier represented by the &amp;lsquo;</source>
          <target state="translated">弱いポインタは、 'で表される新しいタイプの文字指定子を通じてサポートされます</target>
        </trans-unit>
        <trans-unit id="833f5330898dc442fd023004015464621900910e" translate="yes" xml:space="preserve">
          <source>What constitutes an access to a volatile object.</source>
          <target state="translated">揮発性オブジェクトへのアクセスを構成するもの。</target>
        </trans-unit>
        <trans-unit id="29d1640b5550a77154368675da8078c8ec35026f" translate="yes" xml:space="preserve">
          <source>What constitutes an access to an object that has volatile-qualified type (C90 6.5.3, C99 and C11 6.7.3).</source>
          <target state="translated">揮発性修飾型を有するオブジェクトへのアクセスを構成するもの(C90 6.5.3、C99及びC11 6.7.3)。</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="73ab9ffb5b7365deaf1034842a4b9d0c5073a1f3" translate="yes" xml:space="preserve">
          <source>When G++ and another C++ compiler conform to the same C++ ABI, but the implementations of the Standard C++ Library that they normally use do not follow the same ABI for the Standard C++ Library, object files built with those compilers can be used in the same program only if they use the same C++ library. This requires specifying the location of the C++ library header files when invoking the compiler whose usual library is not being used. The location of GCC&amp;rsquo;s C++ header files depends on how the GCC build was configured, but can be seen by using the G++</source>
          <target state="translated">G ++と別のC ++コンパイラが同じC ++ ABIに準拠しているが、通常使用する標準C ++ライブラリの実装が標準C ++ライブラリの同じABIに従っていない場合、これらのコンパイラでビルドされたオブジェクトファイルを同じプログラムで使用できます。同じC ++ライブラリを使用する場合のみ。これには、通常のライブラリが使用されていないコンパイラを呼び出すときに、C ++ライブラリのヘッダーファイルの場所を指定する必要があります。GCCのC ++ヘッダーファイルの場所は、GCCビルドの構成方法によって異なりますが、G ++を使用して確認できます。</target>
        </trans-unit>
        <trans-unit id="25b318e1653c6b6dda339c34d9872ce5b96093ce" translate="yes" xml:space="preserve">
          <source>When IPA-CP determines that a cloning candidate would make the index of an array access known, it adds a bonus of</source>
          <target state="translated">IPA-CPは,クローニング候補が配列アクセスのインデックスを既知にすると判断した場合,ボーナスとして</target>
        </trans-unit>
        <trans-unit id="3fbfba2a71ffaa54417e4d873e33ec3bbc19a7e4" translate="yes" xml:space="preserve">
          <source>When IPA-CP determines that a cloning candidate would make the number of iterations of a loop known, it adds a bonus of</source>
          <target state="translated">IPA-CPは、クローニング候補がループの反復回数を既知にすると判断した場合、ボーナスとして</target>
        </trans-unit>
        <trans-unit id="0b074b049fd7c7f48c6da34e1272635cac52856d" translate="yes" xml:space="preserve">
          <source>When a base class is virtual, only one subobject of the base class belongs to each full object. Also, the constructors and destructors are invoked only once, and called from the most-derived class. However, such objects behave unspecified when being assigned. For example:</source>
          <target state="translated">基底クラスが仮想の場合、基底クラスのサブオブジェクトは各フルオブジェクトに1つしか属しません。また、コンストラクタとデストラクタは一度だけ呼び出され、最も派生したクラスから呼び出されます。しかし、そのようなオブジェクトは、割り当てられたときには不特定の振る舞いをします。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="67be4830f6cdd00004022ad6db1aaae5471c2589" translate="yes" xml:space="preserve">
          <source>When a class has static data members, it is not enough to &lt;em&gt;declare&lt;/em&gt; the static member; you must also &lt;em&gt;define&lt;/em&gt; it. For example:</source>
          <target state="translated">クラスに静的データメンバーがある場合、静的メンバーを&lt;em&gt;宣言する&lt;/em&gt;だけでは不十分です。それも&lt;em&gt;定義する&lt;/em&gt;必要があり&lt;em&gt;ます&lt;/em&gt;。例えば：</target>
        </trans-unit>
        <trans-unit id="d927dabaa85a2fec9fca96ddc5e395f531b27e67" translate="yes" xml:space="preserve">
          <source>When a division strategy has not been specified the default strategy is selected based on the current target. For SH2A the default strategy is to use the &lt;code&gt;divs&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions instead of library function calls.</source>
          <target state="translated">分割戦略が指定されていない場合、デフォルトの戦略は現在のターゲットに基づいて選択されます。SH2Aのデフォルトの戦略は、ライブラリー関数呼び出しの代わりに &lt;code&gt;divs&lt;/code&gt; および &lt;code&gt;divu&lt;/code&gt; 命令を使用することです。</target>
        </trans-unit>
        <trans-unit id="0a75adb840378c14dc9a655e4aba002e527f73a2" translate="yes" xml:space="preserve">
          <source>When a file is compiled with</source>
          <target state="translated">でコンパイルされている場合</target>
        </trans-unit>
        <trans-unit id="0cd90cdfd69b208961a20a866e993339b4b5f840" translate="yes" xml:space="preserve">
          <source>When a function is both inline and &lt;code&gt;static&lt;/code&gt;, if all calls to the function are integrated into the caller, and the function&amp;rsquo;s address is never used, then the function&amp;rsquo;s own assembler code is never referenced. In this case, GCC does not actually output assembler code for the function, unless you specify the option</source>
          <target state="translated">関数がインラインと &lt;code&gt;static&lt;/code&gt; 両方である場合、関数へのすべての呼び出しが呼び出し元に統合され、関数のアドレスが使用されない場合、関数自体のアセンブラコードは参照されません。この場合、オプションを指定しない限り、GCCは実際には関数のアセンブラコードを出力しません。</target>
        </trans-unit>
        <trans-unit id="678a6d73dd419ef65f8fe5fe05b5c39fad57f23c" translate="yes" xml:space="preserve">
          <source>When a list constructor stores the &lt;code&gt;begin&lt;/code&gt; pointer from the &lt;code&gt;initializer_list&lt;/code&gt; argument, this doesn&amp;rsquo;t extend the lifetime of the array, so if a class variable is constructed from a temporary &lt;code&gt;initializer_list&lt;/code&gt;, the pointer is left dangling by the end of the variable declaration statement.</source>
          <target state="translated">リストコンストラクターが &lt;code&gt;initializer_list&lt;/code&gt; 引数からの &lt;code&gt;begin&lt;/code&gt; ポインターを格納する場合、これは配列の存続期間を延長しません。そのため、クラス変数が一時的な &lt;code&gt;initializer_list&lt;/code&gt; から構築される場合、ポインターは変数宣言ステートメントの終わりまでぶら下がります。</target>
        </trans-unit>
        <trans-unit id="00f542136163060bf7630e6166417f9110c29edb" translate="yes" xml:space="preserve">
          <source>When a lock acquire fails, it is required for good performance to abort the transaction quickly. This can be done with a &lt;code&gt;_mm_pause&lt;/code&gt;.</source>
          <target state="translated">ロックの取得に失敗した場合、良好なパフォーマンスを得るには、トランザクションをすばやく中止する必要があります。これは &lt;code&gt;_mm_pause&lt;/code&gt; で実行できます。</target>
        </trans-unit>
        <trans-unit id="8f7415b6c4bfc3b8582a73345fc35229f98c2491" translate="yes" xml:space="preserve">
          <source>When a type involving an ABI tag is used as the type of a variable or return type of a function where that tag is not already present in the signature of the function, the tag is automatically applied to the variable or function.</source>
          <target state="translated">ABIタグを含む型が変数の型や関数の戻り値の型として使用され、そのタグが関数のシグネチャにまだ存在していない場合、そのタグは自動的に変数や関数に適用されます。</target>
        </trans-unit>
        <trans-unit id="6dad89b8cb0d35ea0fd46b863a5983c0e559d839" translate="yes" xml:space="preserve">
          <source>When added to an interrupt handler with the M32C port, causes the prologue and epilogue to use bank switching to preserve the registers rather than saving them on the stack.</source>
          <target state="translated">M32Cポートの割り込みハンドラに追加すると、プロローグとエピローグではスタック上にレジスタを保存するのではなく、バンク切り替えを使用してレジスタを保存するようになります。</target>
        </trans-unit>
        <trans-unit id="f8717fcf897c9e046dd756abc024e5f7d502ccd8" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;initializer_list&lt;/code&gt; variable is assigned from a brace-enclosed initializer list, the temporary array created for the right side of the assignment only lives until the end of the full-expression, so at the next statement the &lt;code&gt;initializer_list&lt;/code&gt; variable has a dangling pointer.</source>
          <target state="translated">とき &lt;code&gt;initializer_list&lt;/code&gt; 変数は括弧で囲まれたリスト初期化子から割り当てられ、割り当ての右側のために作成された一時的な配列は、だけなので次のステートメントで、フル式の終わりまで住ん &lt;code&gt;initializer_list&lt;/code&gt; 変数はダングリングポインタを持っています。</target>
        </trans-unit>
        <trans-unit id="f82873b6d13dce7be3f4357951354ec118469799" translate="yes" xml:space="preserve">
          <source>When an error message refers to a specialization of a function template, the compiler normally prints the signature of the template followed by the template arguments and any typedefs or typenames in the signature (e.g. &lt;code&gt;void f(T) [with T = int]&lt;/code&gt; rather than &lt;code&gt;void f(int)&lt;/code&gt;) so that it&amp;rsquo;s clear which template is involved. When an error message refers to a specialization of a class template, the compiler omits any template arguments that match the default template arguments for that template. If either of these behaviors make it harder to understand the error message rather than easier, you can use</source>
          <target state="translated">エラーメッセージが関数テンプレートの特殊化に言及している場合、コンパイラーは通常、テンプレートのシグニチャーに続いて、テンプレート引数と、シグニチャー内のすべてのtypedefまたはタイプ名を出力します（例： &lt;code&gt;void f(T) [with T = int]&lt;/code&gt; ではなく &lt;code&gt;void f(int)&lt;/code&gt; ）これにより、どのテンプレートが関係しているかが明確になります。エラーメッセージがクラステンプレートの特殊化に言及している場合、コンパイラーは、そのテンプレートのデフォルトのテンプレート引数と一致するすべてのテンプレート引数を省略します。これらの動作のいずれかがエラーメッセージを理解するのを容易にするのではなく困難にする場合は、</target>
        </trans-unit>
        <trans-unit id="4a0782c5484322bfadd7fe79666979332dd01a38" translate="yes" xml:space="preserve">
          <source>When an executable is run in a massive parallel environment, it is recommended to save profile to different folders. That can be done with variables in &lt;var&gt;path&lt;/var&gt; that are exported during run-time:</source>
          <target state="translated">大規模な並列環境で実行可能ファイルを実行する場合、プロファイルを別のフォルダーに保存することをお勧めします。これは、実行時にエクスポートされる &lt;var&gt;path&lt;/var&gt; 変数を使用して行うことができます。</target>
        </trans-unit>
        <trans-unit id="d2c4f8c7d6b26eab60b9d9e100920ff031a8aaf4" translate="yes" xml:space="preserve">
          <source>When an inline function is not &lt;code&gt;static&lt;/code&gt;, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-&lt;code&gt;static&lt;/code&gt; inline function is always compiled on its own in the usual fashion.</source>
          <target state="translated">インライン関数が &lt;code&gt;static&lt;/code&gt; ではない場合、コンパイラーは他のソースファイルからの呼び出しがあると想定する必要があります。グローバルシンボルはどのプログラムでも1度しか定義できないので、関数を他のソースファイルで定義してはならず、その中での呼び出しは統合できません。したがって、非 &lt;code&gt;static&lt;/code&gt; インライン関数は常に通常の方法で単独でコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="b338539fbe33495121e46c5661e5bc16f008a3e0" translate="yes" xml:space="preserve">
          <source>When an insn has two alternative constraint-patterns.</source>
          <target state="translated">insnが2つの代替制約パターンを持っている場合。</target>
        </trans-unit>
        <trans-unit id="4cbff59218859bab09c21980b2597e3d4c6294f2" translate="yes" xml:space="preserve">
          <source>When an unrecognized warning option is requested (e.g.,</source>
          <target state="translated">認識されていない警告オプションが要求された場合(例)</target>
        </trans-unit>
        <trans-unit id="537d39cd77a447e897b80dd75224237bdc4e0719" translate="yes" xml:space="preserve">
          <source>When applicable, enable (disable) the generation of 4-operand &lt;code&gt;madd.s&lt;/code&gt;, &lt;code&gt;madd.d&lt;/code&gt; and related instructions. Enabled by default.</source>
          <target state="translated">該当する場合は、4オペランドの &lt;code&gt;madd.s&lt;/code&gt; 、 &lt;code&gt;madd.d&lt;/code&gt; 、および関連する命令の生成を有効（無効）にします。デフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="4c26cdde33cc06bf31aab1a7bf63c69c29f00704" translate="yes" xml:space="preserve">
          <source>When applicable, enable (disable) the generation of &lt;code&gt;lwxc1&lt;/code&gt;, &lt;code&gt;swxc1&lt;/code&gt;, &lt;code&gt;ldxc1&lt;/code&gt;, &lt;code&gt;sdxc1&lt;/code&gt; instructions. Enabled by default.</source>
          <target state="translated">該当する場合は、 &lt;code&gt;lwxc1&lt;/code&gt; 、 &lt;code&gt;swxc1&lt;/code&gt; 、 &lt;code&gt;ldxc1&lt;/code&gt; 、 &lt;code&gt;sdxc1&lt;/code&gt; 命令の生成を有効（無効）にします。デフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="7184e15e5684528f54729686834cdf00887683be" translate="yes" xml:space="preserve">
          <source>When applied to C++ classes, the attribute marks defined non-inlined member functions and static data members as exports. Static consts initialized in-class are not marked unless they are also defined out-of-class.</source>
          <target state="translated">C++クラスに適用すると、この属性は、定義された非インライン・メンバ関数および静的データ・メンバをエクスポートとしてマークします。クラス内で初期化された静的定数は、クラス外で定義されていない限りマークされません。</target>
        </trans-unit>
        <trans-unit id="7d9feaafaf97b8f7fe46d8b6b598964809d89431" translate="yes" xml:space="preserve">
          <source>When applied to C++ classes, the attribute marks non-inlined member functions and static data members as imports. However, the attribute is ignored for virtual methods to allow creation of vtables using thunks.</source>
          <target state="translated">C++クラスに適用すると、この属性は非インライン・メンバ関数と静的データ・メンバをインポートとしてマークします。ただし、Thunks を使用して vtables を作成できるようにするための仮想メソッドでは、この属性は無視されます。</target>
        </trans-unit>
        <trans-unit id="bbf180b63c03eb34a3aba311a968f02d5135ed3e" translate="yes" xml:space="preserve">
          <source>When applied to a member function of a C++ class template, the attribute also means that the function is instantiated if the class itself is instantiated.</source>
          <target state="translated">C++クラス・テンプレートのメンバ関数に適用される場合、この属性は、クラス自体がインスタンス化されている場合に、その関数がインスタンス化されていることも意味します。</target>
        </trans-unit>
        <trans-unit id="cabddb6e825602d843a117fb734ca3aff3112d1a" translate="yes" xml:space="preserve">
          <source>When applied to a static data member of a C++ class template, the attribute also means that the member is instantiated if the class itself is instantiated.</source>
          <target state="translated">C++クラス・テンプレートの静的データ・メンバに適用される場合、この属性は、クラス自体がインスタンス化されている場合にメンバがインスタンス化されることも意味します。</target>
        </trans-unit>
        <trans-unit id="59f0e6f1d8d71dac3701cee27ca42c33aae99e5f" translate="yes" xml:space="preserve">
          <source>When attached to a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;, this attribute sets the storage order, aka endianness, of the scalar fields of the type, as well as the array fields whose component is scalar. The supported endiannesses are &lt;code&gt;big-endian&lt;/code&gt; and &lt;code&gt;little-endian&lt;/code&gt;. The attribute has no effects on fields which are themselves a &lt;code&gt;union&lt;/code&gt;, a &lt;code&gt;struct&lt;/code&gt; or an array whose component is a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;, and it is possible for these fields to have a different scalar storage order than the enclosing type.</source>
          <target state="translated">この属性は、 &lt;code&gt;union&lt;/code&gt; &lt;code&gt;struct&lt;/code&gt; または構造体にアタッチされると、型のスカラーフィールドの格納順序（別名エンディアン）と、コンポーネントがスカラーである配列フィールドを設定します。サポートされるエンディアンは、 &lt;code&gt;big-endian&lt;/code&gt; と &lt;code&gt;little-endian&lt;/code&gt; です。属性は、それ自体が &lt;code&gt;union&lt;/code&gt; 、 &lt;code&gt;struct&lt;/code&gt; 、またはそのコンポーネントが &lt;code&gt;union&lt;/code&gt; または &lt;code&gt;struct&lt;/code&gt; である配列であるフィールドには影響を与えません。これらのフィールドは、それを囲む型とは異なるスカラーストレージ順序を持つことができます。</target>
        </trans-unit>
        <trans-unit id="5370f9b64efe5c0ffe3fe15dfade832ac9be14df" translate="yes" xml:space="preserve">
          <source>When attached to a type (including a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;), this attribute means that variables of that type are meant to appear possibly unused. GCC does not produce a warning for any variables of that type, even if the variable appears to do nothing. This is often the case with lock or thread classes, which are usually defined and then not referenced, but contain constructors and destructors that have nontrivial bookkeeping functions.</source>
          <target state="translated">型（ &lt;code&gt;union&lt;/code&gt; または &lt;code&gt;struct&lt;/code&gt; を含む）にアタッチされている場合、この属性は、その型の変数が未使用の可能性があるように見えることを意味します。変数が何もしないように見えても、GCCはそのタイプの変数に対して警告を生成しません。これは多くの場合、ロッククラスまたはスレッドクラスに当てはまります。これらは通常定義され、その後参照されませんが、重要な簿記関数を持つコンストラクターとデストラクタが含まれています。</target>
        </trans-unit>
        <trans-unit id="607b6b9a753f4dcb8aa6e646687045411231d9db" translate="yes" xml:space="preserve">
          <source>When attached to an &lt;code&gt;enum&lt;/code&gt; definition, the &lt;code&gt;packed&lt;/code&gt; attribute indicates that the smallest integral type should be used. Specifying the</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 定義に関連付けられている場合、 &lt;code&gt;packed&lt;/code&gt; 属性は、最小の整数型を使用する必要があることを示します。の指定</target>
        </trans-unit>
        <trans-unit id="3212c36750452527c536dd1eddfa9228aa24bc41" translate="yes" xml:space="preserve">
          <source>When branch is predicted to be taken with probability lower than this threshold (in percent), then it is considered well predictable.</source>
          <target state="translated">このしきい値よりも低い確率で枝が取られると予測された場合(単位はパーセント)、それは十分に予測可能であると考えられます。</target>
        </trans-unit>
        <trans-unit id="f92818ac1f6c1cf9820bd7ad2460f0b770895e75" translate="yes" xml:space="preserve">
          <source>When branch probabilities are given, include those of unconditional branches. Unconditional branches are normally not interesting.</source>
          <target state="translated">分岐確率が与えられている場合は、無条件分岐の確率も含めてください。無条件分岐は、通常は面白くありません。</target>
        </trans-unit>
        <trans-unit id="0ae42b215512052c2cadc23355c16f5c5dd443cf" translate="yes" xml:space="preserve">
          <source>When calling routines that are not aware of the reservation, be cautious if those routines call back into code which uses them. As an example, if you call the system library version of &lt;code&gt;qsort&lt;/code&gt;, it may clobber your registers during execution, but (if you have selected appropriate registers) it will restore them before returning. However it will &lt;em&gt;not&lt;/em&gt; restore them before calling &lt;code&gt;qsort&lt;/code&gt;&amp;rsquo;s comparison function. As a result, global values will not reliably be available to the comparison function unless the &lt;code&gt;qsort&lt;/code&gt; function itself is rebuilt.</source>
          <target state="translated">予約を認識しないルーチンを呼び出す場合、それらのルーチンがそれらを使用するコードをコールバックする場合は注意が必要です。例として、システムライブラリバージョンの &lt;code&gt;qsort&lt;/code&gt; を呼び出すと、実行中にレジスタが破壊される可能性がありますが、（適切なレジスタを選択している場合）戻る前にそれらを復元します。ただし、 &lt;code&gt;qsort&lt;/code&gt; の比較関数を呼び出す前にそれらを復元することはあり&lt;em&gt;ません&lt;/em&gt;。その結果、 &lt;code&gt;qsort&lt;/code&gt; 関数自体が再構築されない限り、比較関数でグローバル値を確実に使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="6ce64a23abaaddcfa5831e43098fffe47be4e539" translate="yes" xml:space="preserve">
          <source>When casting from pointer to integer and back again, the resulting pointer must reference the same object as the original pointer, otherwise the behavior is undefined. That is, one may not use integer arithmetic to avoid the undefined behavior of pointer arithmetic as proscribed in C99 and C11 6.5.6/8.</source>
          <target state="translated">ポインタから整数へキャストして再びキャストする場合、結果として得られるポインタは元のポインタと同じオブジェクトを参照しなければならず、そうでない場合の動作は未定義です。つまり、C99とC11 6.5.6.6/8で禁止されているようなポインタ演算の未定義の動作を避けるために整数演算を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="4a6770a95cb182eb94130a66a137214e2a89e539" translate="yes" xml:space="preserve">
          <source>When code compiled with</source>
          <target state="translated">でコンパイルされたコードを</target>
        </trans-unit>
        <trans-unit id="2694a5fd19642dc29f67abfd4afa306ec8d78457" translate="yes" xml:space="preserve">
          <source>When compiling C++, warn about the deprecated conversion from string literals to &lt;code&gt;char *&lt;/code&gt;. This warning is enabled by default for C++ programs.</source>
          <target state="translated">C ++のコンパイル時に、文字列リテラルから &lt;code&gt;char *&lt;/code&gt; への非推奨の変換について警告します。この警告は、C ++プログラムではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="b58e8f8f470141f0b7d65fa2b304a55713649c15" translate="yes" xml:space="preserve">
          <source>When compiling C, give string constants the type &lt;code&gt;const
char[&lt;var&gt;length&lt;/var&gt;]&lt;/code&gt; so that copying the address of one into a non-&lt;code&gt;const&lt;/code&gt;&lt;code&gt;char *&lt;/code&gt; pointer produces a warning. These warnings help you find at compile time code that can try to write into a string constant, but only if you have been very careful about using &lt;code&gt;const&lt;/code&gt; in declarations and prototypes. Otherwise, it is just a nuisance. This is why we did not make</source>
          <target state="translated">Cをコンパイルするとき、文字列定数に &lt;code&gt;const char[&lt;var&gt;length&lt;/var&gt;]&lt;/code&gt; 型を指定して、1のアドレスを非 &lt;code&gt;const&lt;/code&gt; &lt;code&gt;char *&lt;/code&gt; ポインターにコピーすると警告が生成されるようにします。これらの警告は、コンパイル時に文字列定数に書き込もうとする可能性のあるコードを見つけるのに役立ちますが、宣言とプロトタイプで &lt;code&gt;const&lt;/code&gt; を使用することに非常に注意を払った場合に限られます。そうでなければ、それは単に迷惑です。これが私たちが作らなかった理由です</target>
        </trans-unit>
        <trans-unit id="cd87062968fd1ca6c15b5a9b85fba86d8a5ccfc2" translate="yes" xml:space="preserve">
          <source>When compiling code for single processor systems, it is generally safe to use &lt;code&gt;synci&lt;/code&gt;. However, on many multi-core (SMP) systems, it does not invalidate the instruction caches on all cores and may lead to undefined behavior.</source>
          <target state="translated">シングルプロセッサシステム用のコードをコンパイルする場合、一般的に &lt;code&gt;synci&lt;/code&gt; を使用しても安全です。ただし、多くのマルチコア（SMP）システムでは、すべてのコアの命令キャッシュが無効になるわけではなく、動作が未定義になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7c10c0020a810534faa4083bee532dbff326c982" translate="yes" xml:space="preserve">
          <source>When compiling files containing mixed MIPS16 and non-MIPS16 code, the preprocessor symbol &lt;code&gt;__mips16&lt;/code&gt; reflects the setting on the command line, not that within individual functions. Mixed MIPS16 and non-MIPS16 code may interact badly with some GCC extensions such as &lt;code&gt;__builtin_apply&lt;/code&gt; (see &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Constructing Calls&lt;/a&gt;).</source>
          <target state="translated">MIPS16とMIPS16以外のコードが混在するファイルをコンパイルする場合、プリプロセッサシンボル &lt;code&gt;__mips16&lt;/code&gt; は、個々の関数内ではなく、コマンドラインの設定を反映します。混合MIPS16と非MIPS16コードは、次のようないくつかのGCCの拡張でひどく相互作用することができる &lt;code&gt;__builtin_apply&lt;/code&gt; （参照&lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;構築コール&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="60deff215e04b72131ce496d836442fb3376a9ed" translate="yes" xml:space="preserve">
          <source>When compiling files containing mixed microMIPS and non-microMIPS code, the preprocessor symbol &lt;code&gt;__mips_micromips&lt;/code&gt; reflects the setting on the command line, not that within individual functions. Mixed microMIPS and non-microMIPS code may interact badly with some GCC extensions such as &lt;code&gt;__builtin_apply&lt;/code&gt; (see &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Constructing Calls&lt;/a&gt;).</source>
          <target state="translated">microMIPSとmicroMIPS以外のコードが混在するファイルをコンパイルする場合、プリプロセッサシンボル &lt;code&gt;__mips_micromips&lt;/code&gt; は、個々の関数内の設定ではなく、コマンドラインの設定を反映します。混合microMIPSと非microMIPSコードは、次のようないくつかのGCCの拡張でひどく相互作用することができる &lt;code&gt;__builtin_apply&lt;/code&gt; （参照&lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;構築コール&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3b21353af5c286cba09d175d058607a98bab9646" translate="yes" xml:space="preserve">
          <source>When compiling files residing in directory</source>
          <target state="translated">ディレクトリにあるファイルをコンパイルする場合</target>
        </trans-unit>
        <trans-unit id="fb1c662fe80e2a5daa84889e9b20929141a1f39e" translate="yes" xml:space="preserve">
          <source>When compiling for Nios II, the following options are allowed:</source>
          <target state="translated">Nios II用にコンパイルする場合、以下のオプションが許可されています。</target>
        </trans-unit>
        <trans-unit id="47a745ce02eda6e5b8af0283813b8d27ac893e5a" translate="yes" xml:space="preserve">
          <source>When compiling for the NeXT runtime, the compiler ordinarily replaces calls to &lt;code&gt;objc_getClass(&quot;&amp;hellip;&quot;)&lt;/code&gt; (when the name of the class is known at compile time) with static class references that get initialized at load time, which improves run-time performance. Specifying the</source>
          <target state="translated">NeXTランタイム用にコンパイルする場合、コンパイラーは通常、 &lt;code&gt;objc_getClass(&quot;&amp;hellip;&quot;)&lt;/code&gt; への呼び出し（コンパイル時にクラスの名前がわかっている場合）を、ロード時に初期化される静的クラス参照に置き換えます。これにより、実行時のパフォーマンスが向上します。の指定</target>
        </trans-unit>
        <trans-unit id="7acd9f9e9a72745fc09c352c58646de2d43a5f5e" translate="yes" xml:space="preserve">
          <source>When compiling functions that return &lt;code id=&quot;index-float-as-function-value-type&quot;&gt;float&lt;/code&gt;, PCC converts it to a double. GCC actually returns a &lt;code&gt;float&lt;/code&gt;. If you are concerned with PCC compatibility, you should declare your functions to return &lt;code&gt;double&lt;/code&gt;; you might as well say what you mean.</source>
          <target state="translated">&lt;code id=&quot;index-float-as-function-value-type&quot;&gt;float&lt;/code&gt; を返す関数をコンパイルすると、PCCはそれをdoubleに変換します。GCCは実際には &lt;code&gt;float&lt;/code&gt; を返します。PCCの互換性が気になる場合は、 &lt;code&gt;double&lt;/code&gt; を返すように関数を宣言する必要があります。あなたはあなたが何を意味するかを言うのもよいでしょう。</target>
        </trans-unit>
        <trans-unit id="d5db0043541449725fbfb6c49474d3dea04ea8f6" translate="yes" xml:space="preserve">
          <source>When compiling functions that return structures or unions, GCC output code normally uses a method different from that used on most versions of Unix. As a result, code compiled with GCC cannot call a structure-returning function compiled with PCC, and vice versa.</source>
          <target state="translated">構造体やユニオンを返す関数をコンパイルする場合、GCCの出力コードは通常、ほとんどのバージョンのUnixで使用されているものとは異なるメソッドを使用します。その結果、GCCでコンパイルされたコードは、PCCでコンパイルされた構造体を返す関数を呼び出すことができません。</target>
        </trans-unit>
        <trans-unit id="42802196182be1a26f30e794627d93f753ad7250" translate="yes" xml:space="preserve">
          <source>When compiling using the AAPCS ABI (or a variant of it) then valid values for the argument are &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; and &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt;. In order to use a variant other than &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; then the compiler must be permitted to use the appropriate co-processor registers (i.e., the VFP registers must be available in order to use &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt;). For example,</source>
          <target state="translated">AAPCS ABI（またはそのバリアント）を使用してコンパイルする場合、引数の有効な値は &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; および &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt; です。 &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; 以外のバリアントを使用するには、適切なコプロセッサレジスタの使用をコンパイラに許可する必要があります（つまり、 &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt; を使用するには、VFPレジスタが使用可能である必要があります）。例えば、</target>
        </trans-unit>
        <trans-unit id="6f269c2c80bc0b6cd00bdccd1a4ad395d3f1e317" translate="yes" xml:space="preserve">
          <source>When compiling, this option enables</source>
          <target state="translated">コンパイル時に、このオプションを使用すると</target>
        </trans-unit>
        <trans-unit id="315f128e4ce30c782f28bfb565507bc8d99b6552" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps (see</source>
          <target state="translated">デバッグダンプを行う場合(</target>
        </trans-unit>
        <trans-unit id="dce8f6e7dddb2ada38853381a56083f98e91e173" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps, suppress address output. This makes it more feasible to use diff on debugging dumps for compiler invocations with different compiler binaries and/or different text / bss / data / heap / stack / dso start locations.</source>
          <target state="translated">デバッグダンプを行う際に、アドレス出力を抑制します。これにより、異なるコンパイラバイナリや text/bss/data/heap/stack/dso の開始位置が異なるコンパイラの起動に対して、デバッグダンプで diff を使用することが可能になります。</target>
        </trans-unit>
        <trans-unit id="5cb94325a71b749cb8e5d8b4041d1d7a131d0f11" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps, suppress instruction numbers and address output. This makes it more feasible to use diff on debugging dumps for compiler invocations with different options, in particular with and without</source>
          <target state="translated">デバッグダンプを行う際には、命令番号とアドレス出力を抑制します。これにより、異なるオプションを持つコンパイラの起動に対して、デバッグダンプで diff を使用することが可能になります。</target>
        </trans-unit>
        <trans-unit id="6a3f0b550d9291ec66729667f3f7ca83fd2f4d8b" translate="yes" xml:space="preserve">
          <source>When dumping RTL, print the RTL in slim (condensed) form instead of the default LISP-like representation.</source>
          <target state="translated">RTLをダンプする場合、デフォルトのLISPライクな表現ではなく、スリムな(凝縮された)形式でRTLを表示します。</target>
        </trans-unit>
        <trans-unit id="74301d6d6862291588f10bf29b45b4967ce13d2f" translate="yes" xml:space="preserve">
          <source>When dumping front-end intermediate representations, inhibit dumping of members of a scope or body of a function merely because that scope has been reached. Only dump such items when they are directly reachable by some other path.</source>
          <target state="translated">フロントエンドの中間表現をダンプする際には、関数のスコープやボディのメンバがスコープに到達したという理由だけでダンプすることを禁止します。そのような項目は、他のパスで直接到達可能な場合にのみダンプするようにしてください。</target>
        </trans-unit>
        <trans-unit id="f945883699fc9792ba3afeb26f744a7773586ecc" translate="yes" xml:space="preserve">
          <source>When dumping pretty-printed trees, this option inhibits dumping the bodies of control structures.</source>
          <target state="translated">プリティプリントされた木をダンピングする場合、このオプションは制御構造体の本体をダンピングすることを抑制します。</target>
        </trans-unit>
        <trans-unit id="6fc1555729570caee324aa057f7026754c896f3e" translate="yes" xml:space="preserve">
          <source>When enabled, perform interprocedural bitwise constant propagation. This flag is enabled by default at</source>
          <target state="translated">有効にすると、手順間のビット毎の定数伝播を実行します。このフラグはデフォルトでは</target>
        </trans-unit>
        <trans-unit id="bf82f180e269afc159377aa835c2b162d457aecd" translate="yes" xml:space="preserve">
          <source>When enabled, perform interprocedural propagation of value ranges. This flag is enabled by default at</source>
          <target state="translated">有効にすると、値範囲の手順間伝播を実行します。このフラグはデフォルトでは</target>
        </trans-unit>
        <trans-unit id="5a6db9d98413978e8951a290a39c293b6dbce38a" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler ensures that the generated code does not contain CSYNC or SSYNC instructions too soon after conditional branches. If this option is used, &lt;code&gt;__WORKAROUND_SPECULATIVE_SYNCS&lt;/code&gt; is defined.</source>
          <target state="translated">有効にすると、コンパイラーは、条件付き分岐の直後に生成されたコードにCSYNCまたはSSYNC命令が含まれないようにします。このオプションを使用すると、 &lt;code&gt;__WORKAROUND_SPECULATIVE_SYNCS&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="5cabeafae5f5d65fb548beb5767960c04d9a35b8" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler ensures that the generated code does not contain speculative loads after jump instructions. If this option is used, &lt;code&gt;__WORKAROUND_SPECULATIVE_LOADS&lt;/code&gt; is defined.</source>
          <target state="translated">有効にすると、コンパイラーは、生成されたコードにジャンプ命令の後に投機的なロードが含まれないようにします。このオプションを使用すると、 &lt;code&gt;__WORKAROUND_SPECULATIVE_LOADS&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="177174ed256fb1fc5ac1ff6e0a69365e95922527" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler is free to take advantage of the knowledge that the entire program fits into the low 64k of memory.</source>
          <target state="translated">この機能を有効にすると、コンパイラはプログラム全体が64kの低いメモリに収まるという知識を自由に利用することができます。</target>
        </trans-unit>
        <trans-unit id="f1158beec156e6a8ecff5cd217a56a66d53e95d9" translate="yes" xml:space="preserve">
          <source>When enabled, this option states that a range reduction step is not needed when performing complex division. Also, there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case. The default is</source>
          <target state="translated">このオプションを有効にすると、複雑な除算を実行するときに範囲縮小ステップが不要になることが示されます。また、複雑な乗算または除算の結果が &lt;code&gt;NaN + I*NaN&lt;/code&gt; であるかどうかのチェックは行われず、その場合は状況を救うための試みが行われます。デフォルトは</target>
        </trans-unit>
        <trans-unit id="5c41cf550423b99323059ab9102f75c243821bb0" translate="yes" xml:space="preserve">
          <source>When estimated performance improvement of caller + callee runtime exceeds this threshold (in percent), the function can be inlined regardless of the limit on</source>
          <target state="translated">呼び出し元+呼び出し元の実行時の性能向上の推定値がこのしきい値を超えた場合(単位はパーセント)、関数は</target>
        </trans-unit>
        <trans-unit id="0546498041d4ec0ccfc5ce36934cf27647842a41" translate="yes" xml:space="preserve">
          <source>When generating PIC code, do or don&amp;rsquo;t allow the use of PLTs. Ignored for non-PIC. The default is</source>
          <target state="translated">PICコードを生成するときは、PLTの使用を許可または禁止します。PIC以外では無視されます。デフォルトは</target>
        </trans-unit>
        <trans-unit id="511bcbbf68adbe04ec79792863471cde6b014863" translate="yes" xml:space="preserve">
          <source>When generating a function that returns a pointer, return the pointer in both &lt;code&gt;a0&lt;/code&gt; and &lt;code&gt;d0&lt;/code&gt;. Otherwise, the pointer is returned only in &lt;code&gt;a0&lt;/code&gt;, and attempts to call such functions without a prototype result in errors. Note that this option is on by default; use</source>
          <target state="translated">ポインターを返す関数を生成するときは、 &lt;code&gt;a0&lt;/code&gt; と &lt;code&gt;d0&lt;/code&gt; の両方でポインターを返します。そうでない場合、ポインタは &lt;code&gt;a0&lt;/code&gt; でのみ返され、プロトタイプなしでそのような関数を呼び出そうとすると、エラーが発生します。このオプションはデフォルトでオンになっていることに注意してください。使用する</target>
        </trans-unit>
        <trans-unit id="dd2029500976920c4504065ca16226229e4f7c22" translate="yes" xml:space="preserve">
          <source>When generating assembler output use a syntax that is compatible with Renesas&amp;rsquo;s AS100 assembler. This syntax can also be handled by the GAS assembler, but it has some restrictions so it is not generated by default.</source>
          <target state="translated">アセンブラ出力を生成するときは、ルネサスのAS100アセンブラと互換性のある構文を使用してください。この構文はGASアセンブラーでも処理できますが、いくつかの制限があるため、デフォルトでは生成されません。</target>
        </trans-unit>
        <trans-unit id="34010eecdc80bda1996b3453a5842eca5948c6ad" translate="yes" xml:space="preserve">
          <source>When generating code for shared libraries,</source>
          <target state="translated">共有ライブラリのコードを生成する場合</target>
        </trans-unit>
        <trans-unit id="ee57ba558572772d8e7d0fd148c855146cc649ba" translate="yes" xml:space="preserve">
          <source>When generating code for the x86-64 architecture with SSE extensions disabled,</source>
          <target state="translated">SSE拡張機能を無効にしてx86-64アーキテクチャ用のコードを生成する場合。</target>
        </trans-unit>
        <trans-unit id="8c85713507dce4f24637fdca8c9dd42ecd242b3b" translate="yes" xml:space="preserve">
          <source>When generating position-independent code for ColdFire, generate code that works if the GOT has more than 8192 entries. This code is larger and slower than code generated without this option. On M680x0 processors, this option is not needed;</source>
          <target state="translated">ColdFire用の位置に依存しないコードを生成する場合、GOTに8192以上のエントリがある場合に動作するコードを生成します。このコードは、このオプションがない場合に生成されたコードよりも大きく、遅くなります。M680x0 プロセッサでは、このオプションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="ddb821edf6cd4d8eabb391980c4305801a4dd35b" translate="yes" xml:space="preserve">
          <source>When generating position-independent code, emit function calls using the Global Offset Table instead of the Procedure Linkage Table.</source>
          <target state="translated">位置に依存しないコードを生成する場合は、プロシージャ・リンケージ・テーブルの代わりにグローバル・オフセット・テーブルを使用して関数呼び出しをエミットします。</target>
        </trans-unit>
        <trans-unit id="58318867846389e3f00483e730d9cdc45f04b844" translate="yes" xml:space="preserve">
          <source>When implementing patterns for these built-in functions, the memory order parameter can be ignored as long as the pattern implements the most restrictive &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; memory order. Any of the other memory orders execute correctly with this memory order but they may not execute as efficiently as they could with a more appropriate implementation of the relaxed requirements.</source>
          <target state="translated">これらの組み込み関数のパターンを実装する場合、パターンが最も制限的な &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; メモリ順序を実装している限り、メモリ順序パラメータは無視できます。他のメモリの順序は、このメモリの順序で正しく実行されますが、緩和された要件のより適切な実装の場合ほど効率的に実行されない場合があります。</target>
        </trans-unit>
        <trans-unit id="e9af953ed4f40761c964f415712e4b881671dfb2" translate="yes" xml:space="preserve">
          <source>When linking a big-endian image select between BE8 and BE32 formats. The option has no effect for little-endian images and is ignored. The default is dependent on the selected target architecture. For ARMv6 and later architectures the default is BE8, for older architectures the default is BE32. BE32 format has been deprecated by ARM.</source>
          <target state="translated">ビ ッ グエンディアン画像をリンクする際には、BE8 と BE32 のいずれかの形式を選択します。このオプションはリトルエンディアン画像には効果がなく、無視されます。デフォルトは、選択したターゲット・アーキテクチャに依存します。ARMv6以降のアーキテクチャではデフォルトはBE8で、それより古いアーキテクチャではデフォルトはBE32です。BE32フォーマットはARMによって非推奨とされています。</target>
        </trans-unit>
        <trans-unit id="920068058745daad77bac4500e9d9b0ac2200c05" translate="yes" xml:space="preserve">
          <source>When making copies of thread-local variables in a transaction, this parameter specifies the size in bytes after which variables are saved with the logging functions as opposed to save/restore code sequence pairs. This option only applies when using</source>
          <target state="translated">トランザクションでスレッドローカル変数のコピーを作成する場合、このパラメータは、保存/復元コードシーケンスペアとは対照的に、ロギング関数で変数が保存された後のサイズをバイト単位で指定します。このオプションは</target>
        </trans-unit>
        <trans-unit id="20fd5eb54a80ab92bcf13e1600542aa28ff5d13b" translate="yes" xml:space="preserve">
          <source>When mangling a function type with function-cv-qualifiers, the un-qualified function type was incorrectly treated as a substitution candidate.</source>
          <target state="translated">関数型を function-cv-修飾子でマングルすると、修飾されていない関数型が誤って置換候補として扱われていました。</target>
        </trans-unit>
        <trans-unit id="6e16f38a870c014c4bf05a4ba66aff0d8f015c53" translate="yes" xml:space="preserve">
          <source>When not using an &lt;var&gt;asmSymbolicName&lt;/var&gt;, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are three output operands, use &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;asmSymbolicName&lt;/var&gt; を使用しない場合は、アセンブラテンプレートのオペランドのリストで、オペランドの（ゼロから始まる）位置を使用します。たとえば、3つの出力オペランドがある場合は、「</target>
        </trans-unit>
        <trans-unit id="f7f108470bcf6e6b304f3263a3362bac9bf0990f" translate="yes" xml:space="preserve">
          <source>When not using an &lt;var&gt;asmSymbolicName&lt;/var&gt;, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are two output operands and three inputs, use &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;asmSymbolicName&lt;/var&gt; を使用しない場合は、アセンブラテンプレートのオペランドのリストで、オペランドの（ゼロから始まる）位置を使用します。たとえば、2つの出力オペランドと3つの入力がある場合は、「</target>
        </trans-unit>
        <trans-unit id="9ab94547949a5e4c3215ae42df94303adb7916f4" translate="yes" xml:space="preserve">
          <source>When optimizing for size (using</source>
          <target state="translated">サイズを最適化する場合(</target>
        </trans-unit>
        <trans-unit id="97bc78492cc0f58dc12735620055de6a1daa4843" translate="yes" xml:space="preserve">
          <source>When passed this option, GCC produces a dynamic library instead of an executable when linking, using the Darwin</source>
          <target state="translated">このオプションを渡すと、GCCはリンク時に実行ファイルの代わりにダイナミックライブラリを生成します。</target>
        </trans-unit>
        <trans-unit id="f2411855bc2157c02295a4d406d5bb74f6ed2885" translate="yes" xml:space="preserve">
          <source>When performing a stack backtrace, code can inspect the value of &lt;code&gt;pc&lt;/code&gt; stored at &lt;code&gt;fp + 0&lt;/code&gt;. If the trace function then looks at location &lt;code&gt;pc - 12&lt;/code&gt; and the top 8 bits are set, then we know that there is a function name embedded immediately preceding this location and has length &lt;code&gt;((pc[-3]) &amp;amp; 0xff000000)&lt;/code&gt;.</source>
          <target state="translated">スタックバックトレースを実行する場合、コードは &lt;code&gt;fp + 0&lt;/code&gt; 保存されている &lt;code&gt;pc&lt;/code&gt; の値を検査できます。次にトレース関数が場所 &lt;code&gt;pc - 12&lt;/code&gt; を調べ、上位8ビットが設定されている場合、この場所の直前に埋め込まれた関数名があり、長さが &lt;code&gt;((pc[-3]) &amp;amp; 0xff000000)&lt;/code&gt; であることがわかります。</target>
        </trans-unit>
        <trans-unit id="f597a9e8b63ff1121b0842bcdb388264d1b3c5ff" translate="yes" xml:space="preserve">
          <source>When performing branch target register load optimization, don&amp;rsquo;t reuse branch target registers within any basic block.</source>
          <target state="translated">分岐ターゲットレジスタロードの最適化を実行する場合、基本ブロック内で分岐ターゲットレジスタを再利用しないでください。</target>
        </trans-unit>
        <trans-unit id="9c01537a52102dd8946fc5982208fe491740f320" translate="yes" xml:space="preserve">
          <source>When pipelining loops during selective scheduling, also pipeline outer loops. This option has no effect unless</source>
          <target state="translated">選択的スケジューリング中にループをパイプライン化する場合、外側のループもパイプライン化します。このオプションは</target>
        </trans-unit>
        <trans-unit id="1280e31b08d3497c525b6d236dd8d4d87c36c837" translate="yes" xml:space="preserve">
          <source>When preprocessing files residing in directory</source>
          <target state="translated">ディレクトリにあるファイルを前処理する場合</target>
        </trans-unit>
        <trans-unit id="18019b7cb63563a2a1382c41adbfffdfc589112f" translate="yes" xml:space="preserve">
          <source>When preprocessing, do not shorten system header paths with canonicalization.</source>
          <target state="translated">前処理を行う際には、canonicalizationでシステムヘッダパスを短縮しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="2727468a8d8ea18794592843d12955ca0144b622" translate="yes" xml:space="preserve">
          <source>When preprocessing, handle directives, but do not expand macros.</source>
          <target state="translated">前処理を行う際には、ディレクティブを扱うが、マクロを展開しないようにする。</target>
        </trans-unit>
        <trans-unit id="bb09a7ade548f20e19021a30661ff4362be9b030" translate="yes" xml:space="preserve">
          <source>When printing percentages, 0% and 100% are only printed when the values are &lt;em&gt;exactly&lt;/em&gt; 0% and 100% respectively. Other values which would conventionally be rounded to 0% or 100% are instead printed as the nearest non-boundary value.</source>
          <target state="translated">パーセンテージを印刷するときの値である場合、0％と100％のみ印刷され&lt;em&gt;、正確に&lt;/em&gt; 0％と100％でした。通常は0％または100％に丸められる他の値は、代わりに最も近い非境界値として印刷されます。</target>
        </trans-unit>
        <trans-unit id="814abd66e9c273530f2d56ad0a0cd6cc246294fd" translate="yes" xml:space="preserve">
          <source>When producing the final binary, GCC only applies link-time optimizations to those files that contain bytecode. Therefore, you can mix and match object files and libraries with GIMPLE bytecodes and final object code. GCC automatically selects which files to optimize in LTO mode and which files to link without further processing.</source>
          <target state="translated">最終的なバイナリを生成する際、GCC はバイトコードを含むファイルにのみリンク時間の最適化を適用します。そのため、オブジェクトファイルやライブラリとGIMPLEのバイトコードと最終的なオブジェクトコードを混在させることができます。GCCは、LTOモードで最適化するファイルと、それ以上の処理をせずにリンクするファイルを自動的に選択します。</target>
        </trans-unit>
        <trans-unit id="b96765bcbef2cdc563af58e2e7b14e500edcf025" translate="yes" xml:space="preserve">
          <source>When profile feedback is available (see</source>
          <target state="translated">プロフィールフィードバックが利用可能な場合(</target>
        </trans-unit>
        <trans-unit id="21ec7c5b40c9ae6af5acdf4a048ad5c0d3bce4e5" translate="yes" xml:space="preserve">
          <source>When profile feedback is available, via</source>
          <target state="translated">プロフィールのフィードバックが可能な場合は</target>
        </trans-unit>
        <trans-unit id="2f272057236473f0d19fb086d6183a38dfbd5bad" translate="yes" xml:space="preserve">
          <source>When reading data from memory in sizes shorter than 64 bits, use (do not use) zero-extending load instructions by default, rather than sign-extending ones.</source>
          <target state="translated">64 ビットより短いサイズのメモリからデータを読み出す場合、デフォルトでは符号拡張のロード命令ではなく、ゼロ拡張のロード命令を使用してください(使用しないでください)。</target>
        </trans-unit>
        <trans-unit id="f96511339203319c533d1e5bb317204cec489683" translate="yes" xml:space="preserve">
          <source>When scheduling after register allocation, use superblock scheduling. This allows motion across basic block boundaries, resulting in faster schedules. This option is experimental, as not all machine descriptions used by GCC model the CPU closely enough to avoid unreliable results from the algorithm.</source>
          <target state="translated">レジスタ割り当て後にスケジューリングする場合は、スーパーブロックスケジューリングを使用します。これにより、基本ブロックの境界を越えた動きが可能になり、より高速なスケジューリングが可能になります。このオプションは実験的なものであり、GCCで使用されているすべてのマシン記述が、アルゴリズムからの信頼性の低い結果を避けるためにCPUを十分に詳細にモデル化しているわけではないため、このオプションを使用します。</target>
        </trans-unit>
        <trans-unit id="711283accf977e698dde3a25dc400a61116947e3" translate="yes" xml:space="preserve">
          <source>When selecting a register, choose one that is normally saved and restored by function calls on your machine. This ensures that code which is unaware of this reservation (such as library routines) will restore it before returning.</source>
          <target state="translated">レジスタを選択する際には、通常はマシン上の関数呼び出しによって保存・復元されるものを選択してください。これにより、この予約を認識していないコード(ライブラリルーチンなど)は、戻る前に予約を復元することができます。</target>
        </trans-unit>
        <trans-unit id="935d1b181ddc0bd3e6f68299a5752f8a09580e76" translate="yes" xml:space="preserve">
          <source>When selecting this option, be aware that the standard library headers do not obey all of these guidelines; use &amp;lsquo;</source>
          <target state="translated">このオプションを選択するときは、標準ライブラリヘッダーがこれらのガイドラインのすべてに従っていないことに注意してください。使用する '</target>
        </trans-unit>
        <trans-unit id="30da98647c378a61b9ead522311838c64d97cf26" translate="yes" xml:space="preserve">
          <source>When supplied with a 128-bit first argument, the &lt;code&gt;scalar_insert_exp&lt;/code&gt; built-in function returns a quad-precision ieee floating point value. The sign bit of the result is copied from the most significant bit of the &lt;code&gt;significand&lt;/code&gt; argument. The significand and exponent components of the result are composed of the least significant 15 bits of the &lt;code&gt;exponent&lt;/code&gt; argument and the least significant 112 bits of the &lt;code&gt;significand&lt;/code&gt; argument respectively.</source>
          <target state="translated">128ビットの最初の引数を指定すると、 &lt;code&gt;scalar_insert_exp&lt;/code&gt; 組み込み関数は4倍精度のieee浮動小数点値を返します。結果の符号ビットは最上位ビットからコピーされた &lt;code&gt;significand&lt;/code&gt; 引数。結果の仮数と指数の構成要素は、最下位15ビットで構成されている &lt;code&gt;exponent&lt;/code&gt; 引数との最下位112ビット &lt;code&gt;significand&lt;/code&gt; それぞれ引数。</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">になったときに</target>
        </trans-unit>
        <trans-unit id="82085de4f0e784cd78a6493470847db57c3b16cf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;g++&lt;/code&gt; program is used to link a C++ program, it normally automatically links against</source>
          <target state="translated">とき &lt;code&gt;g++&lt;/code&gt; プログラムはC ++プログラムをリンクするために使用され、それは通常は自動的にリンク</target>
        </trans-unit>
        <trans-unit id="9d1f5e646a4aa7fceb07c0207db652e826f24dbb" translate="yes" xml:space="preserve">
          <source>When the address-of operator is applied to a thread-local variable, it is evaluated at run time and returns the address of the current thread&amp;rsquo;s instance of that variable. An address so obtained may be used by any thread. When a thread terminates, any pointers to thread-local variables in that thread become invalid.</source>
          <target state="translated">address-of演算子がスレッドローカル変数に適用されると、実行時に評価され、その変数の現在のスレッドのインスタンスのアドレスを返します。このようにして取得されたアドレスは、どのスレッドでも使用できます。スレッドが終了すると、そのスレッド内のスレッドローカル変数へのポインターはすべて無効になります。</target>
        </trans-unit>
        <trans-unit id="0b679da0a8fd732962aaaa73513d25a32daf4775" translate="yes" xml:space="preserve">
          <source>When the compiled program exits it saves this data to a file called</source>
          <target state="translated">コンパイルされたプログラムが終了すると、このデータは</target>
        </trans-unit>
        <trans-unit id="ba14367decd6810d3de98e37ab796a274e5fcb83" translate="yes" xml:space="preserve">
          <source>When the compiler creates the statically allocated constant string object, the &lt;code&gt;c_string&lt;/code&gt; field will be filled by the compiler with the string; the &lt;code&gt;length&lt;/code&gt; field will be filled by the compiler with the string length; the &lt;code&gt;isa&lt;/code&gt; pointer will be filled with &lt;code&gt;NULL&lt;/code&gt; by the compiler, and it will later be fixed up automatically at runtime by the GNU Objective-C runtime library to point to the class which was set by the</source>
          <target state="translated">コンパイラーが静的に割り当てられた定数文字列オブジェクトを作成すると、 &lt;code&gt;c_string&lt;/code&gt; フィールドはコンパイラーによって文字列で埋められます。 &lt;code&gt;length&lt;/code&gt; フィールドは、文字列の長さで、コンパイラによって入力されます。 &lt;code&gt;isa&lt;/code&gt; ポインタを用いて充填される &lt;code&gt;NULL&lt;/code&gt; コンパイラによって、それは後により設定されたクラスを指すようにGNU Objective-Cランタイムライブラリによって実行時に自動的に固定します</target>
        </trans-unit>
        <trans-unit id="75d541d9bedf275908dc64ccacf78982bc497338" translate="yes" xml:space="preserve">
          <source>When the compiler fixes up the operands to satisfy the constraints, it needs to know which operands are read by the instruction and which are written by it. &amp;lsquo;</source>
          <target state="translated">コンパイラーが制約を満たすためにオペランドを修正するとき、どのオペランドが命令によって読み取られ、どれがそれによって書き込まれるかを知る必要があります。」</target>
        </trans-unit>
        <trans-unit id="fe9038c60a954d7fa872648aae2a7292450a7e26" translate="yes" xml:space="preserve">
          <source>When the compiler selects the registers to use to represent the input operands, it does not use any of the clobbered registers (see &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;).</source>
          <target state="translated">コンパイラーは、入力オペランドを表すために使用するレジスターを選択するときに、クロバー化されたレジスターを使用しません（&lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;クロバーとスクラッチレジスターを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="fc0664d7c952e60ae422d980b70454766a66b5fe" translate="yes" xml:space="preserve">
          <source>When the compiler selects the registers to use to represent the output operands, it does not use any of the clobbered registers (see &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;).</source>
          <target state="translated">コンパイラーが出力オペランドを表すために使用するレジスターを選択するとき、それは、クロバー化されたレジスターを使用しません（&lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;クロバーとスクラッチレジスターを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="9af3756142eed3c562da1e3a657ce9b62976062a" translate="yes" xml:space="preserve">
          <source>When the compiler selects which registers to use to represent input and output operands, it does not use any of the clobbered registers. As a result, clobbered registers are available for any use in the assembler code.</source>
          <target state="translated">コンパイラが入力と出力のオペランドを表現するために使用するレジスタを選択した場合、 クロッバされたレジスタは使用されません。その結果、アセンブラ・コードではクローバされたレジスタが利用可能になります。</target>
        </trans-unit>
        <trans-unit id="c3d75a61bee977e603b0ea8873c523597d8f39fa" translate="yes" xml:space="preserve">
          <source>When the garbage collector is used, the objects are allocated using the so-called typed memory allocation mechanism available in the Boehm-Demers-Weiser collector. This mode requires precise information on where pointers are located inside objects. This information is computed once per class, immediately after the class has been initialized.</source>
          <target state="translated">ガベージコレクタが使用されているとき、オブジェクトは Boehm-Demers-Weiser コレクタで利用可能な、いわゆる型付きメモリ割り当てメカニズムを使用して割り当てられます。このモードでは、オブジェクト内のポインタがどこにあるかについての正確な情報が必要です。この情報は、クラスが初期化された直後に、クラスごとに一度計算されます。</target>
        </trans-unit>
        <trans-unit id="ce04df43b58d0607f55d930a3e25d2b0c0d86fd3" translate="yes" xml:space="preserve">
          <source>When the instructions are enabled GCC defines the C preprocessor symbol &lt;code&gt;__RX_ALLOW_STRING_INSNS__&lt;/code&gt;, otherwise it defines the symbol &lt;code&gt;__RX_DISALLOW_STRING_INSNS__&lt;/code&gt;.</source>
          <target state="translated">命令が有効な場合、GCCはCプリプロセッサシンボル &lt;code&gt;__RX_ALLOW_STRING_INSNS__&lt;/code&gt; を定義します。それ以外の場合は、シンボル &lt;code&gt;__RX_DISALLOW_STRING_INSNS__&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="237034d602a7895e4b871df52b8d8208437c1b5e" translate="yes" xml:space="preserve">
          <source>When the option</source>
          <target state="translated">オプションを選択した場合</target>
        </trans-unit>
        <trans-unit id="f59a2028d7f7059c14cfbb4f7cac2e937416cda2" translate="yes" xml:space="preserve">
          <source>When the value of a decimal floating type cannot be represented in the integer type to which it is being converted, the result is undefined rather than the result value specified by the draft technical report.</source>
          <target state="translated">10進浮動型の値が変換先の整数型で表現できない場合,技術報告書草案で指定された結果値ではなく,結果が未定義となる。</target>
        </trans-unit>
        <trans-unit id="43dfcc6f2fffee0a3a2515bfa1a37e71e51242de" translate="yes" xml:space="preserve">
          <source>When this flag is set, the macros &lt;code&gt;__pic__&lt;/code&gt; and &lt;code&gt;__PIC__&lt;/code&gt; are defined to 1.</source>
          <target state="translated">このフラグが設定されると、マクロ &lt;code&gt;__pic__&lt;/code&gt; および &lt;code&gt;__PIC__&lt;/code&gt; は1に定義されます。</target>
        </trans-unit>
        <trans-unit id="44c57deb401735025dc176c7c63debf58618c2fc" translate="yes" xml:space="preserve">
          <source>When this flag is set, the macros &lt;code&gt;__pic__&lt;/code&gt; and &lt;code&gt;__PIC__&lt;/code&gt; are defined to 2.</source>
          <target state="translated">このフラグが設定されている場合、マクロ &lt;code&gt;__pic__&lt;/code&gt; および &lt;code&gt;__PIC__&lt;/code&gt; は2に定義されます。</target>
        </trans-unit>
        <trans-unit id="4a1317c4b8d2af979d94b62164c9d7ecd9184a36" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC inserts &lt;code&gt;MEMW&lt;/code&gt; instructions before &lt;code&gt;volatile&lt;/code&gt; memory references to guarantee sequential consistency. The default is</source>
          <target state="translated">このオプションを有効にすると、GCCは &lt;code&gt;volatile&lt;/code&gt; メモリ参照の前に &lt;code&gt;MEMW&lt;/code&gt; 命令を挿入して、順次一貫性を保証します。デフォルトは</target>
        </trans-unit>
        <trans-unit id="4f8fad713a34ff4dd67014e2a8d65e863876b686" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC instructs the assembler to automatically align instructions to reduce branch penalties at the expense of some code density. The assembler attempts to widen density instructions to align branch targets and the instructions following call instructions. If there are not enough preceding safe density instructions to align a target, no widening is performed. The default is</source>
          <target state="translated">このオプションを有効にすると、GCC はアセンブラに命令を自動的に揃えるように指示し、コード密度をある程度犠牲にして分岐ペナルティを軽減します。アセンブラは、分岐ターゲットと呼び出し命令に続く命令を整列させるために密度命令を広げようとします。ターゲットを整列させるのに十分な先行安全密度命令がない場合、拡張は実行されません。デフォルトは</target>
        </trans-unit>
        <trans-unit id="6aace4cd615149f89dea8fcd082fb55d9878fa43" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC instructs the assembler to translate direct calls to indirect calls unless it can determine that the target of a direct call is in the range allowed by the call instruction. This translation typically occurs for calls to functions in other source files. Specifically, the assembler translates a direct &lt;code&gt;CALL&lt;/code&gt; instruction into an &lt;code&gt;L32R&lt;/code&gt; followed by a &lt;code&gt;CALLX&lt;/code&gt; instruction. The default is</source>
          <target state="translated">このオプションを有効にすると、GCCは、直接呼び出しのターゲットが呼び出し命令で許可されている範囲内にあると判断できない限り、直接呼び出しを間接呼び出しに変換するようにアセンブラーに指示します。この変換は通常、他のソースファイル内の関数の呼び出しに対して行われます。具体的には、アセンブラは直接 &lt;code&gt;CALL&lt;/code&gt; 命令を &lt;code&gt;L32R&lt;/code&gt; に変換し、その後に &lt;code&gt;CALLX&lt;/code&gt; 命令が続きます。デフォルトは</target>
        </trans-unit>
        <trans-unit id="932f419fffb4962ea09a2d68b7d48f6dd70fbe9a" translate="yes" xml:space="preserve">
          <source>When this option is not used, GCC optimizes for the processor specified by</source>
          <target state="translated">このオプションを使用しない場合、GCC は</target>
        </trans-unit>
        <trans-unit id="d8e1351858aa322f0a55264f24813443d8991eb4" translate="yes" xml:space="preserve">
          <source>When this option is passed to the compiler driver, it causes the &lt;em&gt;first&lt;/em&gt; compilation to be skipped, which makes it useful for little other than debugging the compiler proper.</source>
          <target state="translated">このオプションがコンパイラー・ドライバーに渡されると、&lt;em&gt;最初の&lt;/em&gt;コンパイルがスキップされるため、コンパイラーを適切にデバッグする以外にほとんど役に立ちません。</target>
        </trans-unit>
        <trans-unit id="9e23f54eaa8f9101922e305be1e7015dd6fc78fe" translate="yes" xml:space="preserve">
          <source>When this version of the ABI is enabled the C preprocessor symbol &lt;code&gt;__V850_GCC_ABI__&lt;/code&gt; is defined.</source>
          <target state="translated">このバージョンのABIを有効にすると、Cプリプロセッサシンボル &lt;code&gt;__V850_GCC_ABI__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="2a3a63e7e68adaacd52d22d0fef6ef4e247546c7" translate="yes" xml:space="preserve">
          <source>When this version of the ABI is enabled the C preprocessor symbol &lt;code&gt;__V850_RH850_ABI__&lt;/code&gt; is defined.</source>
          <target state="translated">このバージョンのABIを有効にすると、Cプリプロセッサシンボル &lt;code&gt;__V850_RH850_ABI__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="ffcbc5063df93d534e3fd1a9be3948f3d608cc53" translate="yes" xml:space="preserve">
          <source>When trying to fill delay slots, the maximum number of instructions to consider when searching for a block with valid live register information. Increasing this arbitrarily chosen value means more aggressive optimization, increasing the compilation time. This parameter should be removed when the delay slot code is rewritten to maintain the control-flow graph.</source>
          <target state="translated">遅延スロットを埋めようとするときに、有効なライブ レジスタ情報を持つブロックを検索するときに考慮すべき命令の最大数。この任意に選ばれた値を大きくすると、より積極的な最適化を意味し、コンパイル時間が長くなります。このパラメータは、コントロールフローグラフを維持するために遅延スロットコードを書き換える場合には削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="ca1100086e04f30d15e50b0b6ef7fef7de69d02a" translate="yes" xml:space="preserve">
          <source>When used as part of the register variable extension, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">レジスタ変数拡張の一部として使用する場合は、&lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;明示的なレジスタ変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="106a6c1a466d5af73cd467f48ab954141e8dae1a" translate="yes" xml:space="preserve">
          <source>When used as the pattern of a pack expansion within a template definition, expands to a template argument pack containing integers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt;. This is provided for efficient implementation of &lt;code&gt;std::make_integer_sequence&lt;/code&gt;.</source>
          <target state="translated">テンプレート定義内のパック展開のパターンとして使用すると、 &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;length-1&lt;/code&gt; までの整数を含むテンプレート引数パックに展開されます。これは &lt;code&gt;std::make_integer_sequence&lt;/code&gt; 効率的な実装のために提供されています。</target>
        </trans-unit>
        <trans-unit id="780fee7b38bbbc14d6460730fc730c12ac99a32c" translate="yes" xml:space="preserve">
          <source>When used from GCC without</source>
          <target state="translated">なしでGCCから使用する場合</target>
        </trans-unit>
        <trans-unit id="0e9e8833e240e4ed56f0fb1a36eb014753411cc2" translate="yes" xml:space="preserve">
          <source>When used in combination with</source>
          <target state="translated">併用して使用する場合</target>
        </trans-unit>
        <trans-unit id="4ec2dc1132b93e0ccc417d346f716fa8317dce1d" translate="yes" xml:space="preserve">
          <source>When used in combination with the</source>
          <target state="translated">と組み合わせて使用する場合</target>
        </trans-unit>
        <trans-unit id="7e7b12188944613e3ecc2fd00ed8b819fb8ad2ca" translate="yes" xml:space="preserve">
          <source>When used in conjunction with</source>
          <target state="translated">と組み合わせて使用する場合</target>
        </trans-unit>
        <trans-unit id="49cb60ae0da0fc7302708101bdf54d1b69871514" translate="yes" xml:space="preserve">
          <source>When used on a struct, or struct member, the &lt;code&gt;aligned&lt;/code&gt; attribute can only increase the alignment; in order to decrease it, the &lt;code&gt;packed&lt;/code&gt; attribute must be specified as well. When used as part of a typedef, the &lt;code&gt;aligned&lt;/code&gt; attribute can both increase and decrease alignment, and specifying the &lt;code&gt;packed&lt;/code&gt; attribute generates a warning.</source>
          <target state="translated">構造体または構造体メンバーで使用する場合、 &lt;code&gt;aligned&lt;/code&gt; 属性は位置合わせを増やすことしかできません。これを減らすには、 &lt;code&gt;packed&lt;/code&gt; 属性も指定する必要があります。typedefの一部として使用した場合、 &lt;code&gt;aligned&lt;/code&gt; 属性は位置合わせを増減でき、 &lt;code&gt;packed&lt;/code&gt; 属性を指定すると警告が生成されます。</target>
        </trans-unit>
        <trans-unit id="9e5e1c3d3ae3ca589eb9e745a2edd3f0de6b0b04" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;interrupt_handler&lt;/code&gt;, &lt;code&gt;exception_handler&lt;/code&gt; or &lt;code&gt;nmi_handler&lt;/code&gt;, code is generated to load the stack pointer from the USP register in the function prologue.</source>
          <target state="translated">&lt;code&gt;interrupt_handler&lt;/code&gt; 、 &lt;code&gt;exception_handler&lt;/code&gt; または &lt;code&gt;nmi_handler&lt;/code&gt; と一緒に使用すると、関数プロローグのUSPレジスタからスタックポインタをロードするコードが生成されます。</target>
        </trans-unit>
        <trans-unit id="0fa555d9978b74bbd46ce823e883fc5dc96ece10" translate="yes" xml:space="preserve">
          <source>When used together,</source>
          <target state="translated">併用する場合。</target>
        </trans-unit>
        <trans-unit id="dd9e3fff8e9f3de600aeb120c0ac434ae6e8fd7f" translate="yes" xml:space="preserve">
          <source>When used with</source>
          <target state="translated">と一緒に使用する場合</target>
        </trans-unit>
        <trans-unit id="92cecb0d71e3d06f0f2ee726aec0670791ccea60" translate="yes" xml:space="preserve">
          <source>When used with GNU ld version 2.8 or later on an ELF system such as GNU/Linux or Solaris 2, or on Microsoft Windows, duplicate copies of these constructs will be discarded at link time. This is known as COMDAT support.</source>
          <target state="translated">GNU/LinuxやSolaris 2などのELFシステムやMicrosoft Windows上でGNU ldバージョン2.8以降で使用された場合、これらの構成要素の重複コピーはリンク時に破棄されます。これはCOMDATサポートとして知られています。</target>
        </trans-unit>
        <trans-unit id="3e4af787046ae7ade38ea86db68f50943f9b708f" translate="yes" xml:space="preserve">
          <source>When used with the driver options</source>
          <target state="translated">ドライバオプションで使用する場合</target>
        </trans-unit>
        <trans-unit id="c37b9bb49622ff1b2c39fa2ca14e91b87c1c3e6e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;__vector&lt;/code&gt; instead of &lt;code&gt;vector&lt;/code&gt;; for example,</source>
          <target state="translated">使用する場合 &lt;code&gt;__vector&lt;/code&gt; 代わりの &lt;code&gt;vector&lt;/code&gt; 、例えば、</target>
        </trans-unit>
        <trans-unit id="6b2bcfc1c3c9cde870c3782ea70e6faf69a223bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;gcov&lt;/code&gt;, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; を使用する場合、最初に特別なGCCオプションを使用してプログラムをコンパイルする必要があります '</target>
        </trans-unit>
        <trans-unit id="813ae21e068ea720242cb9123e52a1c2bfc86b90" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vector&lt;/code&gt; in keyword-and-predefine mode; for example,</source>
          <target state="translated">キーワードと事前定義モードで &lt;code&gt;vector&lt;/code&gt; を使用する場合。例えば、</target>
        </trans-unit>
        <trans-unit id="5643f8856029d91e0b316af45e590b017e03b023" translate="yes" xml:space="preserve">
          <source>When using &lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt;, gcov uses the full pathname of the source files to create an output filename. This can lead to long filenames that can overflow filesystem limits. This option creates names of the form</source>
          <target state="translated">&lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt; を使用する場合、gcovはソースファイルの完全パス名を使用して出力ファイル名を作成します。これにより、長いファイル名がファイルシステムの制限をオーバーフローする可能性があります。このオプションはフォームの名前を作成します</target>
        </trans-unit>
        <trans-unit id="86e384abcdbbd0ac6dda953fb252a5fa852b9cab" translate="yes" xml:space="preserve">
          <source>When using DWARF Version 4 or higher, type DIEs can be put into their own &lt;code&gt;.debug_types&lt;/code&gt; section instead of making them part of the &lt;code&gt;.debug_info&lt;/code&gt; section. It is more efficient to put them in a separate comdat section since the linker can then remove duplicates. But not all DWARF consumers support &lt;code&gt;.debug_types&lt;/code&gt; sections yet and on some objects &lt;code&gt;.debug_types&lt;/code&gt; produces larger instead of smaller debugging information.</source>
          <target state="translated">DWARFバージョン4以降を使用する場合は、タイプのダイは、独自に入れることができる &lt;code&gt;.debug_types&lt;/code&gt; の代わりにその一部作るのセクション &lt;code&gt;.debug_info&lt;/code&gt; のセクションを。リンカは重複を削除できるため、別のcomdatセクションに配置する方が効率的です。ただし、すべてのDWARFコンシューマーが &lt;code&gt;.debug_types&lt;/code&gt; セクションをまだサポートしている &lt;code&gt;.debug_types&lt;/code&gt; はなく、一部のオブジェクトでは.debug_typesが小さいデバッグ情報ではなく大きいデバッグ情報を生成します。</target>
        </trans-unit>
        <trans-unit id="7fb27cfc2abe0d594f6b16d8710a96a8aeba9d2c" translate="yes" xml:space="preserve">
          <source>When using a reference to volatile, G++ does not treat equivalent expressions as accesses to volatiles, but instead issues a warning that no volatile is accessed. The rationale for this is that otherwise it becomes difficult to determine where volatile access occur, and not possible to ignore the return value from functions returning volatile references. Again, if you wish to force a read, cast the reference to an rvalue.</source>
          <target state="translated">volatileへの参照を使用する場合、G++は等価な式をvolatileへのアクセスとして扱わず、代わりにvolatileにアクセスされていないという警告を出します。この理由は、そうしないとどこでvolatileアクセスが発生したかを判断することが難しくなり、volatile参照を返す関数からの戻り値を無視することができなくなるからです。繰り返しになりますが、強制的に読み込みを行いたい場合は、参照をrvalueにキャストしてください。</target>
        </trans-unit>
        <trans-unit id="ffb95a64a466d2bd4851566c5320aa64fa40418e" translate="yes" xml:space="preserve">
          <source>When using a type that occupies multiple registers, such as &lt;code&gt;long
long&lt;/code&gt; on a 32-bit system, split the registers apart and allocate them independently. This normally generates better code for those types, but may make debugging more difficult.</source>
          <target state="translated">32ビットシステムで &lt;code&gt;long long&lt;/code&gt; など、複数のレジスタを占有するタイプを使用する場合は、レジスタを分割して、個別に割り当てます。これは通常、これらのタイプに適したコードを生成しますが、デバッグがより困難になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f38f792e072335436a4ef70d8d149701336de24f" translate="yes" xml:space="preserve">
          <source>When using any of the register constraints (&lt;code&gt;wa&lt;/code&gt;, &lt;code&gt;wd&lt;/code&gt;, &lt;code&gt;wf&lt;/code&gt;, &lt;code&gt;wg&lt;/code&gt;, &lt;code&gt;wh&lt;/code&gt;, &lt;code&gt;wi&lt;/code&gt;, &lt;code&gt;wj&lt;/code&gt;, &lt;code&gt;wk&lt;/code&gt;, &lt;code&gt;wl&lt;/code&gt;, &lt;code&gt;wm&lt;/code&gt;, &lt;code&gt;wo&lt;/code&gt;, &lt;code&gt;wp&lt;/code&gt;, &lt;code&gt;wq&lt;/code&gt;, &lt;code&gt;ws&lt;/code&gt;, &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;wu&lt;/code&gt;, &lt;code&gt;wv&lt;/code&gt;, &lt;code&gt;ww&lt;/code&gt;, or &lt;code&gt;wy&lt;/code&gt;) that take VSX registers, you must use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; in the template so that the correct register is used. Otherwise the register number output in the assembly file will be incorrect if an Altivec register is an operand of a VSX instruction that expects VSX register numbering.</source>
          <target state="translated">VSXを取るレジスター制約（ &lt;code&gt;wa&lt;/code&gt; 、 &lt;code&gt;wd&lt;/code&gt; 、 &lt;code&gt;wf&lt;/code&gt; 、 &lt;code&gt;wg&lt;/code&gt; 、 &lt;code&gt;wh&lt;/code&gt; 、 &lt;code&gt;wi&lt;/code&gt; 、 &lt;code&gt;wj&lt;/code&gt; 、 &lt;code&gt;wk&lt;/code&gt; 、 &lt;code&gt;wl&lt;/code&gt; 、 &lt;code&gt;wm&lt;/code&gt; 、 &lt;code&gt;wo&lt;/code&gt; 、 &lt;code&gt;wp&lt;/code&gt; 、 &lt;code&gt;wq&lt;/code&gt; 、 &lt;code&gt;ws&lt;/code&gt; 、 &lt;code&gt;wt&lt;/code&gt; 、 &lt;code&gt;wu&lt;/code&gt; 、 &lt;code&gt;wv&lt;/code&gt; 、 &lt;code&gt;ww&lt;/code&gt; 、または &lt;code&gt;wy&lt;/code&gt; ）のいずれかを使用する場合レジスタ、 &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; 使用する必要がありますテンプレートで正しいレジスタが使用されるようにします。そうしないと、Altivecレジスタが、VSXレジスタの番号付けを予期するVSX命令のオペランドである場合、アセンブリファイルに出力されるレジスタ番号が正しくなくなります。</target>
        </trans-unit>
        <trans-unit id="c184ccdd41991ac034a44b8741c7f1fabbb85a41" translate="yes" xml:space="preserve">
          <source>When using precompiled headers (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;), this flag causes the dependency-output flags to also list the files from the precompiled header&amp;rsquo;s dependencies. If not specified, only the precompiled header are listed and not the files that were used to create it, because those files are not consulted when a precompiled header is used.</source>
          <target state="translated">プリコンパイル済みヘッダーを使用する場合（「&lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;プリ&lt;/a&gt;コンパイル済みヘッダー」を参照）、このフラグにより​​、依存関係出力フラグは、プリコンパイル済みヘッダーの依存関係からのファイルもリストします。指定しない場合は、プリコンパイル済みヘッダーが使用されるときに参照されないため、プリコンパイル済みヘッダーのみがリストされ、作成に使用されたファイルはリストされません。</target>
        </trans-unit>
        <trans-unit id="4d73200be5ca0030ca174cac8ec7eb66631895c5" translate="yes" xml:space="preserve">
          <source>When using the GNU linker, it is usually more convenient to pass arguments to linker options using the</source>
          <target state="translated">GNUリンカを使う場合、通常は</target>
        </trans-unit>
        <trans-unit id="07d62f57e8744ee5ede23dc9a1e4cfca2395afa4" translate="yes" xml:space="preserve">
          <source>When you are using the &lt;code&gt;goto&lt;/code&gt; form of &lt;code&gt;asm&lt;/code&gt;, this section contains the list of all C labels to which the code in the &lt;var&gt;AssemblerTemplate&lt;/var&gt; may jump. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; の &lt;code&gt;goto&lt;/code&gt; フォームを使用している場合、このセクションには、 &lt;var&gt;AssemblerTemplate&lt;/var&gt; のコードがジャンプする可能性があるすべてのCラベルのリストが含まれます。&lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabelsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b1da9d83d815287fc18f851fe43c98fefdf50af5" translate="yes" xml:space="preserve">
          <source>When you compile C++ programs, you may specify many of the same command-line options that you use for compiling programs in any language; or command-line options meaningful for C and related languages; or options that are meaningful only for C++ programs. See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;, for explanations of options for languages related to C. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;, for explanations of options that are meaningful only for C++ programs.</source>
          <target state="translated">C ++プログラムをコンパイルするとき、任意の言語でプログラムをコンパイルするために使用するものと同じコマンドラインオプションの多くを指定できます。または、Cおよび関連言語にとって意味のあるコマンドラインオプション。またはC ++プログラムでのみ意味のあるオプション。参照してください&lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;制御するオプションC方言を&lt;/a&gt; C.を参照してくださいに関連する言語のオプションの説明については、&lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;オプションの制御C ++方言&lt;/a&gt;だけC ++プログラムに対して意味のあるオプションの説明については、。</target>
        </trans-unit>
        <trans-unit id="628daae8697f91bc17f481bc0199bf74cc7f3f93" translate="yes" xml:space="preserve">
          <source>When you invoke GCC, it normally does preprocessing, compilation, assembly and linking. The &amp;ldquo;overall options&amp;rdquo; allow you to stop this process at an intermediate stage. For example, the</source>
          <target state="translated">GCCを呼び出すと、通常は前処理、コンパイル、アセンブリ、リンクを行います。「全体的なオプション」を使用すると、このプロセスを中間段階で停止できます。たとえば、</target>
        </trans-unit>
        <trans-unit id="dc4bcf9de739295968f25374fa0b9b82393e8d47" translate="yes" xml:space="preserve">
          <source>When you use</source>
          <target state="translated">を使用する場合</target>
        </trans-unit>
        <trans-unit id="8bb9a5cb938f4f893dfe56300e7991ff5d9ac371" translate="yes" xml:space="preserve">
          <source>When you use &lt;code id=&quot;index-longjmp-incompatibilities&quot;&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;, the only automatic variables guaranteed to remain valid are those declared &lt;code&gt;volatile&lt;/code&gt;. This is a consequence of automatic register allocation. Consider this function:</source>
          <target state="translated">&lt;code id=&quot;index-longjmp-incompatibilities&quot;&gt;setjmp&lt;/code&gt; と &lt;code&gt;longjmp&lt;/code&gt; を使用する場合、有効であり続けることが保証されている自動変数は、 &lt;code&gt;volatile&lt;/code&gt; と宣言されているものだけです。これは、自動レジスタ割り当ての結果です。この関数を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="4f5a87979f362a282d672c1cd391334d27dc161a" translate="yes" xml:space="preserve">
          <source>When you use the</source>
          <target state="translated">を使用する場合は</target>
        </trans-unit>
        <trans-unit id="cef8b3831d50a66f25ff90c61c375348a6eba6bf" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should use the general-purpose constraint letters in &lt;code&gt;asm&lt;/code&gt; arguments, since they will convey meaning more readily to people reading your code. Failing that, use the constraint letters that usually have very similar meanings across architectures. The most commonly used constraints are &amp;lsquo;</source>
          <target state="translated">汎用の制約文字は、コードを読む人にとってより容易に意味を伝えるため、できるだけ &lt;code&gt;asm&lt;/code&gt; 引数で使用する必要があります。それができない場合は、アーキテクチャ全体で通常非常によく似た意味を持つ制約文字を使用してください。最も一般的に使用される制約は '</target>
        </trans-unit>
        <trans-unit id="3a4007ba3fafc819a7924ea3b2d8632c8709039c" translate="yes" xml:space="preserve">
          <source>Whenever you leave out the alignment factor in an &lt;code&gt;aligned&lt;/code&gt; attribute specification, the compiler automatically sets the alignment for the type to the largest alignment that is ever used for any data type on the target machine you are compiling for. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables that have types that you have aligned this way.</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 属性指定で整列係数を省略すると、コンパイラーは自動的に、型の整列を、コンパイル対象のターゲットマシンのデータ型に使用される最大の整列に自動的に設定します。これにより、コンパイラーは、この方法で整列した型を持つ変数との間でコピーを実行するときに、メモリの最大のチャンクをコピーする命令を使用できるため、コピー操作がより効率的になります。</target>
        </trans-unit>
        <trans-unit id="08306a1126e7ec7f2d356c52bfc279fbbf71d360" translate="yes" xml:space="preserve">
          <source>Where &lt;var&gt;op&lt;/var&gt; is the name of the instruction. Refer to the ISA manual for the complete list of instructions.</source>
          <target state="translated">ここで、 &lt;var&gt;op&lt;/var&gt; は命令の名前です。手順の完全なリストについては、ISAのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="a66402f17809117f1d29c4b80df406d4e2f11bba" translate="yes" xml:space="preserve">
          <source>Where G++ puts inlines, vtables and such.</source>
          <target state="translated">G++はインラインや vtables などを置く場所です。</target>
        </trans-unit>
        <trans-unit id="f97bcbccf23129ffc3f54b71abd0f18cfe88a7d0" translate="yes" xml:space="preserve">
          <source>Where none of</source>
          <target state="translated">何もないところ</target>
        </trans-unit>
        <trans-unit id="18ba47ae48773e2f3f0699ad79e05aa7bd3185d2" translate="yes" xml:space="preserve">
          <source>Where the standard specified with</source>
          <target state="translated">で指定された規格の場合</target>
        </trans-unit>
        <trans-unit id="7c95dc097ed9e81e390e81810c6f3d829c025cc5" translate="yes" xml:space="preserve">
          <source>Where the unused arguments lie between used arguments that are specified with &amp;lsquo;</source>
          <target state="translated">未使用の引数が 'で指定された使用済みの引数の間にある場合</target>
        </trans-unit>
        <trans-unit id="b3e4d8bab3e588a9e2b728940ccf589c5438a70e" translate="yes" xml:space="preserve">
          <source>Where the value in &lt;var&gt;dest&lt;/var&gt; will be the result returned from the built-in.</source>
          <target state="translated">&lt;var&gt;dest&lt;/var&gt; の値は組み込みから返される結果になります。</target>
        </trans-unit>
        <trans-unit id="e57ba6952af402ae437a5e3309d0cfb54d03b1f3" translate="yes" xml:space="preserve">
          <source>Where to find header files and libraries. Where to find the compiler executable files.</source>
          <target state="translated">ヘッダーファイルとライブラリの場所 コンパイラの実行ファイルの場所</target>
        </trans-unit>
        <trans-unit id="3c00f7db25c9cf9b37e3952008b0e2f58aade5fa" translate="yes" xml:space="preserve">
          <source>Whether a &amp;ldquo;plain&amp;rdquo; &lt;code&gt;int&lt;/code&gt; bit-field is treated as a &lt;code&gt;signed int&lt;/code&gt; bit-field or as an &lt;code&gt;unsigned int&lt;/code&gt; bit-field (C90 6.5.2, C90 6.5.2.1, C99 and C11 6.7.2, C99 and C11 6.7.2.1).</source>
          <target state="translated">「プレーン」な &lt;code&gt;int&lt;/code&gt; ビットフィールドを、 &lt;code&gt;signed int&lt;/code&gt; ビットフィールドとして扱うか、 &lt;code&gt;unsigned int&lt;/code&gt; ビットフィールドとして扱うか（C90 6.5.2、C90 6.5.2.1、C99およびC11 6.7.2、C99およびC11 6.7.2.1） ）。</target>
        </trans-unit>
        <trans-unit id="7531059d0a25c98e7ca278e75f82acc76daa9a55" translate="yes" xml:space="preserve">
          <source>Whether a bit-field can straddle a storage-unit boundary (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">ビットフィールドが蓄積ユニット境界をまたぐことができるかどうか(C90 6.5.2.1、C99、C11 6.7.2.1)。</target>
        </trans-unit>
        <trans-unit id="fe2aebfc599d584921175261d958d43ef0f0aec0" translate="yes" xml:space="preserve">
          <source>Whether a function in a binary built by one set of tools can call a function in a binary built by a different set of tools is a subset of interoperability.</source>
          <target state="translated">あるツールセットによって構築されたバイナリ内の関数が、異なるツールセットによって構築されたバイナリ内の関数を呼び出すことができるかどうかは、相互運用性のサブセットです。</target>
        </trans-unit>
        <trans-unit id="c06b8898733d76cc9dce4e56a21efa3845ac1918" translate="yes" xml:space="preserve">
          <source>Whether an argument of class type with a non-trivial copy constructor or destructor can be passed to ... (C++0x 5.2.2).</source>
          <target state="translated">非自明コピー コンストラクタまたはデストラクタを持つクラス型の引数を ...に渡すことができるかどうか。(C++0x 5.2.2)。</target>
        </trans-unit>
        <trans-unit id="f086235b38a936fb8979e808d23b4c24d86f5d9b" translate="yes" xml:space="preserve">
          <source>Whether and how floating expressions are contracted when not disallowed by the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 and C11 6.5).</source>
          <target state="translated">&lt;code&gt;FP_CONTRACT&lt;/code&gt; プラグマ（C99およびC11 6.5）で許可されていない場合に、浮動式を縮小するかどうか、およびその方法。</target>
        </trans-unit>
        <trans-unit id="f8840ea94992b3ba6df4412ec15b47848948aba5" translate="yes" xml:space="preserve">
          <source>Whether any extended alignments are supported and the contexts in which they are supported (C11 6.2.8).</source>
          <target state="translated">拡張アラインメントがサポートされているかどうかと、それがサポートされているコンテキスト(C11 6.2.8)。</target>
        </trans-unit>
        <trans-unit id="5e7ac927cf9e33f4c488cef419402e9a193f27f2" translate="yes" xml:space="preserve">
          <source>Whether atomic types are permitted for bit-fields (C11 6.7.2.1).</source>
          <target state="translated">ビットフィールドに対してアトミック型が許可されているかどうか(C11 6.7.2.1)。</target>
        </trans-unit>
        <trans-unit id="1b73e138d1b7cf4eb52da0986b7749369200c235" translate="yes" xml:space="preserve">
          <source>Whether case distinctions are significant in an identifier with external linkage (C90 6.1.2).</source>
          <target state="translated">外部リンクを持つ識別子において、大文字小文字の区別が重要かどうか(C90 6.1.2)。</target>
        </trans-unit>
        <trans-unit id="f11ebb9d3de47abc2e0ca0f87e800f9634ac636f" translate="yes" xml:space="preserve">
          <source>Whether codegen errors should be ICEs when</source>
          <target state="translated">の場合、コードゲンエラーはICEであるべきかどうか</target>
        </trans-unit>
        <trans-unit id="354a46344b75f29340cafb16fbb91450a8587db2" translate="yes" xml:space="preserve">
          <source>Whether differently-prefixed wide string literal tokens can be concatenated and, if so, the treatment of the resulting multibyte character sequence (C11 6.4.5).</source>
          <target state="translated">接頭辞の異なる幅広文字列リテラルトークンを連結できるかどうか、連結できる場合には、結果として得られるマルチバイト文字列の扱い(C11 6.4.5)。</target>
        </trans-unit>
        <trans-unit id="3b5528cb4a8a2228a3304685d15fcf34a763a7fb" translate="yes" xml:space="preserve">
          <source>Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character in translation phase 3 (C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">翻訳フェーズ3(C90、C99及びC11 5.1.1.2)において、改行以外の空白文字以外の各空白文字列を保持するか、1つの空白文字に置き換えるか。</target>
        </trans-unit>
        <trans-unit id="599547a438479475d1d2cda798d15d3f35866c27" translate="yes" xml:space="preserve">
          <source>Whether signed integer types are represented using sign and magnitude, two&amp;rsquo;s complement, or one&amp;rsquo;s complement, and whether the extraordinary value is a trap representation or an ordinary value (C99 and C11 6.2.6.2).</source>
          <target state="translated">符号付き整数型が符号と絶対値、2の補数、または1の補数を使用して表されるかどうか、および異常値がトラップ表現か通常値か（C99およびC11 6.2.6.2）。</target>
        </trans-unit>
        <trans-unit id="40b6d1461dda1b8f55b388b60612f0a1c5dc15ae" translate="yes" xml:space="preserve">
          <source>Whether the &amp;ldquo;inexact&amp;rdquo; floating-point exception can be raised when the rounded result actually does equal the mathematical result in an IEC 60559 conformant implementation (C99 F.9).</source>
          <target state="translated">丸められた結果が実際にIEC 60559準拠の実装での数学的結果と等しい場合に、「不正確な」浮動小数点例外を発生させることができるかどうか（C99 F.9）。</target>
        </trans-unit>
        <trans-unit id="c1f63f009e459571f2431bd617b7dca64a11adca" translate="yes" xml:space="preserve">
          <source>Whether the &amp;ldquo;underflow&amp;rdquo; (and &amp;ldquo;inexact&amp;rdquo;) floating-point exception can be raised when a result is tiny but not inexact in an IEC 60559 conformant implementation (C99 F.9).</source>
          <target state="translated">IEC 60559準拠の実装（C99 F.9）で結果が小さいが不正確ではない場合に、「アンダーフロー」（および「不正確」）浮動小数点例外を発生させることができるかどうか。</target>
        </trans-unit>
        <trans-unit id="945b6d4fa9a5ecbaf6bafbdb8d0d89ae5b700edc" translate="yes" xml:space="preserve">
          <source>Whether the &amp;lsquo;</source>
          <target state="translated">かどうか</target>
        </trans-unit>
        <trans-unit id="bba97b060da98c792876d4d0754d818ca89f0204" translate="yes" xml:space="preserve">
          <source>Whether the compiler should use the &amp;ldquo;canonical&amp;rdquo; type system. Should always be 1, which uses a more efficient internal mechanism for comparing types in C++ and Objective-C++. However, if bugs in the canonical type system are causing compilation failures, set this value to 0 to disable canonical types.</source>
          <target state="translated">コンパイラが「標準」型システムを使用するかどうか。常に1である必要があります。これにより、C ++とObjective-C ++の型を比較す​​るためのより効率的な内部メカニズムが使用されます。ただし、正規型システムのバグがコンパイルの失敗の原因となっている場合は、この値を0に設定して正規型を無効にします。</target>
        </trans-unit>
        <trans-unit id="9bf07719435931f48daf3148b7f591b08eee6622" translate="yes" xml:space="preserve">
          <source>Whether the loop array prefetch pass should issue software prefetch hints for strides that are non-constant. In some cases this may be beneficial, though the fact the stride is non-constant may make it hard to predict when there is clear benefit to issuing these hints.</source>
          <target state="translated">ループ配列のプリフェッチパスは、一定ではないストライドに対してソフトウェアプリフェッチヒントを発行すべきかどうか。場合によってはこれが有益であるかもしれませんが、 ストライドが不変であるという事実は、これらのヒントを発行することに明確な利益があるときに予測することを困難にするかもしれません。</target>
        </trans-unit>
        <trans-unit id="3783705a05be7fc566fd28d14a20893e46a49fb1" translate="yes" xml:space="preserve">
          <source>Whether the value of a character constant in a constant expression that controls conditional inclusion matches the value of the same character constant in the execution character set (C90 6.8.1, C99 and C11 6.10.1).</source>
          <target state="translated">条件付き包含を制御する定数式の中の文字定数の値が、実行文字集合の中の同じ文字定数の値と一致するかどうか(C90 6.8.1、C99、C11 6.10.1)。</target>
        </trans-unit>
        <trans-unit id="c36d4d5da07291b1b8267749102489e31d3d638e" translate="yes" xml:space="preserve">
          <source>Whether the value of a single-character character constant in a constant expression that controls conditional inclusion may have a negative value (C90 6.8.1, C99 and C11 6.10.1).</source>
          <target state="translated">条件付き包含を制御する定数式の一文字文字定数の値が負の値を持つことがあるかどうか(C90 6.8.1、C99、C11 6.10.1)。</target>
        </trans-unit>
        <trans-unit id="9cb3bdf69d2ad24cba5875ebe4f0cafed80a2719" translate="yes" xml:space="preserve">
          <source>Which additional multibyte characters may appear in identifiers and their correspondence to universal character names (C99 and C11 6.4.2).</source>
          <target state="translated">識別子に出現する可能性のある追加のマルチバイト文字と、その対応関係(C99及びC11 6.4.2)。</target>
        </trans-unit>
        <trans-unit id="d42124c28b1baab39d06e79c2e6fbc80bcb8c3b0" translate="yes" xml:space="preserve">
          <source>Which of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; has the same range, representation, and behavior as &amp;ldquo;plain&amp;rdquo; &lt;code&gt;char&lt;/code&gt; (C90 6.1.2.5, C90 6.2.1.1, C99 and C11 6.2.5, C99 and C11 6.3.1.1).</source>
          <target state="translated">どの &lt;code&gt;signed char&lt;/code&gt; 型または &lt;code&gt;unsigned char&lt;/code&gt; 型は「普通」と同じ範囲、表現、および動作を有する &lt;code&gt;char&lt;/code&gt; （C90 6.1.2.5、C90 6.2.1.1、C99及びC11 6.2.5、C99及びC11 6.3.1.1）。</target>
        </trans-unit>
        <trans-unit id="a3f8e01950ee5a5eeec136d809212bfccead4676" translate="yes" xml:space="preserve">
          <source>Which problems in your code get warnings, and which get errors.</source>
          <target state="translated">コードのどの問題が警告を受け、どの問題がエラーになるか。</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="78cfea135064bce5a81b5bd15458f3f64f56702d" translate="yes" xml:space="preserve">
          <source>While it is possible to leave the function undefined and thus invoke a link failure (to define the function with a message in &lt;code&gt;.gnu.warning*&lt;/code&gt; section), when using these attributes the problem is diagnosed earlier and with exact location of the call even in presence of inline functions or when not emitting debugging information.</source>
          <target state="translated">関数を未定義のままにして、リンク障害を呼び出す（ &lt;code&gt;.gnu.warning*&lt;/code&gt; セクションのメッセージで関数を定義する）ことは可能ですが、これらの属性を使用すると、問題はより早く診断され、インライン関数の存在、またはデバッグ情報を出力しない場合。</target>
        </trans-unit>
        <trans-unit id="652d59cea2004903b4f313a4a1b258897728e71e" translate="yes" xml:space="preserve">
          <source>While the compiler is aware of changes to entries listed in the output operands, the inline &lt;code&gt;asm&lt;/code&gt; code may modify more than just the outputs. For example, calculations may require additional registers, or the processor may overwrite a register as a side effect of a particular assembler instruction. In order to inform the compiler of these changes, list them in the clobber list. Clobber list items are either register names or the special clobbers (listed below). Each clobber list item is a string constant enclosed in double quotes and separated by commas.</source>
          <target state="translated">コンパイラーは、出力オペランドにリストされているエントリーへの変更を認識していますが、インライン &lt;code&gt;asm&lt;/code&gt; コードは、出力以外のものも変更する可能性があります。たとえば、計算で追加のレジスタが必要になる場合や、特定のアセンブラ命令の副作用としてプロセッサがレジスタを上書きする場合があります。これらの変更をコンパイラに通知するには、それらをクロバーリストにリストします。 Clobberリストアイテムは、レジスタ名または特別なClobber（以下にリスト）のいずれかです。各Clobberリストアイテムは、二重引用符で囲まれ、カンマで区切られた文字列定数です。</target>
        </trans-unit>
        <trans-unit id="e21fa2c7a90a60eea68201dc97480d9a5390c69c" translate="yes" xml:space="preserve">
          <source>While the uses of &lt;code&gt;asm&lt;/code&gt; are many and varied, it may help to think of an &lt;code&gt;asm&lt;/code&gt; statement as a series of low-level instructions that convert input parameters to output parameters. So a simple (if not particularly useful) example for i386 using &lt;code&gt;asm&lt;/code&gt; might look like this:</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; の使用法は多種多様ですが、 &lt;code&gt;asm&lt;/code&gt; ステートメントを、入力パラメーターを出力パラメーターに変換する一連の低レベルの命令と考えると役立つ場合があります。したがって、 &lt;code&gt;asm&lt;/code&gt; を使用したi386の簡単な（特に便利でない場合）例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="39d000e8aa5910f6d9ef12595235838dbefbbb8c" translate="yes" xml:space="preserve">
          <source>While transforming the program out of the SSA representation, attempt to reduce copying by coalescing versions of different user-defined variables, instead of just compiler temporaries. This may severely limit the ability to debug an optimized program compiled with</source>
          <target state="translated">プログラムを SSA 表現から変換する際には、コンパイラのテンポラリではなく、異なるユーザー定義変数のバージョンを合体させてコピーを減らすようにしてください。これは、最適化されたプログラムを</target>
        </trans-unit>
        <trans-unit id="91e29563eb1f68f27cd54dba1d78ec9cc5f02f0e" translate="yes" xml:space="preserve">
          <source>Whitespace characters are ignored and can be inserted at any position except the first. This enables each alternative for different operands to be visually aligned in the machine description even if they have different number of constraints and modifiers.</source>
          <target state="translated">空白文字は無視され、最初の位置以外の任意の位置に挿入することができます。これにより、異なるオペランドに対する各代替案は、制約や修飾子の数が異なっていても、マシン記述で視覚的に整列させることができます。</target>
        </trans-unit>
        <trans-unit id="45faa4599697b06106508c630a671752d1b455fb" translate="yes" xml:space="preserve">
          <source>Wint-to-pointer-cast</source>
          <target state="translated">Wint-to-pointer-cast</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="db41302cf4b363b4a1378448e9a36c920e1a7fca" translate="yes" xml:space="preserve">
          <source>With both</source>
          <target state="translated">両方の</target>
        </trans-unit>
        <trans-unit id="a29e68e9d153083133283a2db9d7b73482a032a4" translate="yes" xml:space="preserve">
          <source>With extended &lt;code&gt;asm&lt;/code&gt; you can read and write C variables from assembler and perform jumps from assembler code to C labels. Extended &lt;code&gt;asm&lt;/code&gt; syntax uses colons (&amp;lsquo;</source>
          <target state="translated">拡張 &lt;code&gt;asm&lt;/code&gt; を使用すると、アセンブラーからC変数を読み書きしたり、アセンブラーコードからCラベルにジャンプしたりできます。拡張 &lt;code&gt;asm&lt;/code&gt; 構文ではコロン（ '</target>
        </trans-unit>
        <trans-unit id="b2027ec70d531c569c806c46a0ed0d35bbfbe374" translate="yes" xml:space="preserve">
          <source>With no modifiers, this is what the output from the operands would be for the &amp;lsquo;</source>
          <target state="translated">修飾子がない場合、これは、オペランドの出力が '</target>
        </trans-unit>
        <trans-unit id="d8a4b9d08d97e45adb4da87468c9bc15fb87e195" translate="yes" xml:space="preserve">
          <source>With the</source>
          <target state="translated">を使用しています。</target>
        </trans-unit>
        <trans-unit id="9cd37ca8139ba8f0077df8728d69e1509b46cb93" translate="yes" xml:space="preserve">
          <source>With the GNU C++ front end, for x86 targets, you may specify multiple versions of a function, where each function is specialized for a specific target feature. At runtime, the appropriate version of the function is automatically executed depending on the characteristics of the execution platform. Here is an example.</source>
          <target state="translated">GNU C++フロントエンドでは、x86ターゲットの場合、ある関数の複数のバージョンを指定することができます。実行時には、実行プラットフォームの特性に応じて、適切なバージョンの関数が自動的に実行されます。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="872450a8fc748ddfde2cdc81d3d1bdedfaa16509" translate="yes" xml:space="preserve">
          <source>With the GNU runtime, exceptions are always implemented as &amp;ldquo;native&amp;rdquo; exceptions and it is recommended that the</source>
          <target state="translated">GNUランタイムでは、例外は常に「ネイティブ」例外として実装されます。</target>
        </trans-unit>
        <trans-unit id="ede352de48f14dbfe64db09513e522c73f079435" translate="yes" xml:space="preserve">
          <source>With the NeXT runtime, although currently designed to be binary compatible with &lt;code&gt;NS_HANDLER&lt;/code&gt;-style idioms provided by the &lt;code&gt;NSException&lt;/code&gt; class, the new exceptions can only be used on Mac OS X 10.3 (Panther) and later systems, due to additional functionality needed in the NeXT Objective-C runtime.</source>
          <target state="translated">NeXTランタイムでは、現在、 &lt;code&gt;NSException&lt;/code&gt; クラスによって提供される &lt;code&gt;NS_HANDLER&lt;/code&gt; スタイルのイディオムとバイナリ互換になるように設計されていますが、新しい例外は、NeXTで必要な追加機能により、Mac OS X 10.3（Panther）以降のシステムでのみ使用できます。 Objective-Cランタイム。</target>
        </trans-unit>
        <trans-unit id="dab61d2e9aaa3623f28b2c32d76967b2c680ed03" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;__thread&lt;/code&gt;, at most one &lt;var&gt;storage-class-specifier&lt;/var&gt; shall appear in a given &lt;var&gt;decl-specifier-seq&lt;/var&gt;. The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, or immediately following the &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; specifiers. [&amp;hellip;]</source>
          <target state="translated">除いて &lt;code&gt;__thread&lt;/code&gt; 、多くても1つの &lt;var&gt;storage-class-specifier&lt;/var&gt; 一定に現れるものと &lt;var&gt;decl-specifier-seq&lt;/var&gt; 。 &lt;code&gt;__thread&lt;/code&gt; 指定子は、単独で使用、または直後にしてもよい &lt;code&gt;extern&lt;/code&gt; または &lt;code&gt;static&lt;/code&gt; 指定子を。[&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="292a47839ebc29dbb70ec7b25cc162b60e68673e" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;__thread&lt;/code&gt;, at most one storage-class specifier may be given [&amp;hellip;]. The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, or immediately following &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">除いて &lt;code&gt;__thread&lt;/code&gt; 、多くても1つのストレージ・クラス指定子で[...]与えてもよいです。 &lt;code&gt;__thread&lt;/code&gt; 指定子は、単独で使用、または直後にすることができる &lt;code&gt;extern&lt;/code&gt; または &lt;code&gt;static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a3f5b76de67732f25dfbe9b7ab3c5b977a603b2" translate="yes" xml:space="preserve">
          <source>With the exception of built-ins that have library equivalents such as the standard C library functions discussed below, or that expand to library calls, GCC built-in functions are always expanded inline and thus do not have corresponding entry points and their address cannot be obtained. Attempting to use them in an expression other than a function call results in a compile-time error.</source>
          <target state="translated">GCC の組み込み関数は、後述する標準 C ライブラリ関数のようなライブラリ相当の関数や、ライブラリ呼び出しに展開される組み込み関数を除いて、常にインラインで展開されるため、対応するエントリポイントがなく、そのアドレスを取得することができません。これらを関数呼び出し以外の式で使おうとするとコンパイル時エラーになります。</target>
        </trans-unit>
        <trans-unit id="e736ee71288d11d1b230f0b89bdd35b5282b45ac" translate="yes" xml:space="preserve">
          <source>With the latter choice the options</source>
          <target state="translated">後者の選択肢では</target>
        </trans-unit>
        <trans-unit id="a6637ce41dda1dbfc19245d823fa7fce4d91f90f" translate="yes" xml:space="preserve">
          <source>With the linker plugin enabled, the linker extracts the needed GIMPLE files from</source>
          <target state="translated">リンカープラグインを有効にすると、 リンカは必要な GIMPLE ファイルを</target>
        </trans-unit>
        <trans-unit id="8b0e7753b83f2f64fc1212f98878b05c847daa5e" translate="yes" xml:space="preserve">
          <source>With the specification of an output file, the output is appended to the named file, and it looks like this:</source>
          <target state="translated">出力ファイルの指定では、名前のついたファイルに出力が追記され、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="51ee435d4a40a1b09c0e1be2e1a80aec4607b86e" translate="yes" xml:space="preserve">
          <source>With this interface, &lt;code&gt;wait&lt;/code&gt;&amp;rsquo;s implementation might look like this:</source>
          <target state="translated">このインターフェースを使用すると、 &lt;code&gt;wait&lt;/code&gt; の実装は次のようになります。</target>
        </trans-unit>
        <trans-unit id="901e3b5288c53d25410e3fbe70a050954297b494" translate="yes" xml:space="preserve">
          <source>With this option, the compiler creates multiple copies of some local variables when unrolling a loop, which can result in superior code.</source>
          <target state="translated">このオプションを使用すると、ループを展開する際にコンパイラがいくつかのローカル変数の複数のコピーを作成し、より優れたコードを作成することができます。</target>
        </trans-unit>
        <trans-unit id="ce8a418995461de4210630163f948f5da9423e89" translate="yes" xml:space="preserve">
          <source>With this option, the compiler turns the &lt;code&gt;__builtin_unreachable&lt;/code&gt; call into a diagnostics message call instead. When reaching the &lt;code&gt;__builtin_unreachable&lt;/code&gt; call, the behavior is undefined.</source>
          <target state="translated">このオプションを使用すると、コンパイラは代わりに &lt;code&gt;__builtin_unreachable&lt;/code&gt; 呼び出しを診断メッセージ呼び出しに変換します。 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 呼び出しに到達したときの動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="756db1c4a886455bb3e77429e2aacb2477c5e4e1" translate="yes" xml:space="preserve">
          <source>With this pragma, the programmer asserts that there are no loop-carried dependencies which would prevent consecutive iterations of the following loop from executing concurrently with SIMD (single instruction multiple data) instructions.</source>
          <target state="translated">このプラグマを使用して、プログラマは、SIMD(単一命令複数データ)命令と同時に実行される次のループの連続した反復を妨げるループキャリー依存関係が存在しないことを主張します。</target>
        </trans-unit>
        <trans-unit id="a8d9a31f26b7d1b3f16e1e66c83efb3ffbd755c5" translate="yes" xml:space="preserve">
          <source>Within either execution environment, a &lt;em&gt;thread&lt;/em&gt; is a flow of control within a program. It is implementation defined whether or not there may be more than one thread associated with a program. It is implementation defined how threads beyond the first are created, the name and type of the function called at thread startup, and how threads may be terminated. However, objects with thread storage duration shall be initialized before thread startup.</source>
          <target state="translated">どちらの実行環境でも、&lt;em&gt;スレッド&lt;/em&gt;はプログラム内の制御の流れです。プログラムに関連付けられているスレッドが複数あるかどうかは、実装で定義されます。これは、最初のスレッドを超えたスレッドの作成方法、スレッドの起動時に呼び出される関数の名前とタイプ、およびスレッドの終了方法を定義した実装です。ただし、スレッドストレージ期間を持つオブジェクトは、スレッドの起動前に初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e894809a49c1ed8c2eb1cfd50b560eb03dca15f" translate="yes" xml:space="preserve">
          <source>Within the body of &lt;code&gt;T::fn&lt;/code&gt;, &lt;var&gt;this&lt;/var&gt; has the effective definition &lt;code&gt;T *__restrict__ const this&lt;/code&gt;. Notice that the interpretation of a &lt;code&gt;__restrict__&lt;/code&gt; member function qualifier is different to that of &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt; qualifier, in that it is applied to the pointer rather than the object. This is consistent with other compilers that implement restricted pointers.</source>
          <target state="translated">&lt;code&gt;T::fn&lt;/code&gt; 本体内で、 &lt;var&gt;this&lt;/var&gt; は有効な定義 &lt;code&gt;T *__restrict__ const this&lt;/code&gt; 持っています。 &lt;code&gt;__restrict__&lt;/code&gt; メンバー関数修飾子の解釈は、オブジェクトではなくポインターに適用されるという点で、 &lt;code&gt;const&lt;/code&gt; または &lt;code&gt;volatile&lt;/code&gt; 修飾子の解釈とは異なります。これは、制限付きポインタを実装する他のコンパイラと一致しています。</target>
        </trans-unit>
        <trans-unit id="06d91320f48b09da02ef917261dcfd59521156ff" translate="yes" xml:space="preserve">
          <source>Without a value specified, pack all structure members together without holes. When a value is specified (which must be a small power of two), pack structure members according to this value, representing the maximum alignment (that is, objects with default alignment requirements larger than this are output potentially unaligned at the next fitting location.</source>
          <target state="translated">値を指定しない場合は、すべての構造体メンバーを穴をあけずに詰めます。値が指定されると(これは2の小さいべき乗でなければなりません)、この値に従って構造体のメンバをパックし、最大のアライメントを表します(つまり、これよりも大きいデフォルトのアライメント要件を持つオブジェクトは、次のフィッティング位置で潜在的にアライメントされていない状態で出力されます)。</target>
        </trans-unit>
        <trans-unit id="4610e8cd3674760f9e34246c3335f6375dea470e" translate="yes" xml:space="preserve">
          <source>Without any optimization option, the compiler&amp;rsquo;s goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you expect from the source code.</source>
          <target state="translated">最適化オプションがない場合、コンパイラーの目標は、コンパイルのコストを削減し、デバッグで期待どおりの結果が生成されるようにすることです。ステートメントは独立しています：ステートメント間のブレークポイントでプログラムを停止すると、新しい値を変数に割り当てたり、プログラムカウンターを関数内の他のステートメントに変更したりして、ソースコードから期待どおりの結果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="d8d4a33aae2a07ecc8c812bfec17c5e5d451e08a" translate="yes" xml:space="preserve">
          <source>Without the specification of an output file, the output looks like this:</source>
          <target state="translated">出力ファイルを指定しないと、こんな感じで出力されます。</target>
        </trans-unit>
        <trans-unit id="5f36069c670576f1745c3bcd64036649a26fba3f" translate="yes" xml:space="preserve">
          <source>Without this option, &amp;lsquo;</source>
          <target state="translated">このオプションがない場合、 '</target>
        </trans-unit>
        <trans-unit id="810b49b99b225fdb366e04ce850176fc78b9dace" translate="yes" xml:space="preserve">
          <source>Without this option, the &lt;code&gt;X&lt;/code&gt; register may be used in the same way as &lt;code&gt;Y&lt;/code&gt; or &lt;code&gt;Z&lt;/code&gt; which then is emulated by additional instructions. For example, loading a value with &lt;code&gt;X+const&lt;/code&gt; addressing with a small non-negative &lt;code&gt;const &amp;lt; 64&lt;/code&gt; to a register &lt;var&gt;Rn&lt;/var&gt; is performed as</source>
          <target state="translated">このオプションがない場合、 &lt;code&gt;X&lt;/code&gt; レジスタは &lt;code&gt;Y&lt;/code&gt; または &lt;code&gt;Z&lt;/code&gt; と同じ方法で使用でき、追加の命令によってエミュレートされます。たとえば、値が負でない小さな &lt;code&gt;const &amp;lt; 64&lt;/code&gt; &lt;code&gt;X+const&lt;/code&gt; アドレッシングでレジスタ &lt;var&gt;Rn&lt;/var&gt; にロードすると、次のように実行されます。</target>
        </trans-unit>
        <trans-unit id="4c7069fd8666957ba9eac9efad054fa1d2f74644" translate="yes" xml:space="preserve">
          <source>Work around a bug in the &lt;code&gt;muls&lt;/code&gt; and &lt;code&gt;mulu&lt;/code&gt; instructions for CPU models where it applies. This option is active by default.</source>
          <target state="translated">該当するCPUモデルの &lt;code&gt;muls&lt;/code&gt; および &lt;code&gt;mulu&lt;/code&gt; 命令のバグを回避します。このオプションはデフォルトでアクティブになっています。</target>
        </trans-unit>
        <trans-unit id="9517982144bf04b0b47a4d85a09581d177ba1cbb" translate="yes" xml:space="preserve">
          <source>Work around a hardware bug that causes the SPU to stall indefinitely. By default, GCC inserts the &lt;code&gt;hbrp&lt;/code&gt; instruction to make sure this stall won&amp;rsquo;t happen.</source>
          <target state="translated">SPUを無期限に停止させるハードウェアのバグを回避します。デフォルトでは、GCCは &lt;code&gt;hbrp&lt;/code&gt; 命令を挿入して、このストールが発生しないようにします。</target>
        </trans-unit>
        <trans-unit id="8c4b8e3f13ae11240c809eb84fd3edb5d1bba62a" translate="yes" xml:space="preserve">
          <source>Work around certain R10000 errata:</source>
          <target state="translated">特定のR10000正誤表を回避できるようにしました。</target>
        </trans-unit>
        <trans-unit id="9074be04c7616416ed213f212eeb7c6c7c183d4c" translate="yes" xml:space="preserve">
          <source>Work around certain R4000 CPU errata:</source>
          <target state="translated">特定のR4000 CPUエラッタを回避できるようにしました。</target>
        </trans-unit>
        <trans-unit id="fd709a4ced203846b02db64672dd131b123d5504" translate="yes" xml:space="preserve">
          <source>Work around certain R4400 CPU errata:</source>
          <target state="translated">特定のR4400 CPUのエラッタを回避するようにしました。</target>
        </trans-unit>
        <trans-unit id="9c76802dfaf86b35388bb6eac2a9a428f20a7a39" translate="yes" xml:space="preserve">
          <source>Work around certain SB-1 CPU core errata. (This flag currently works around the SB-1 revision 2 &amp;ldquo;F1&amp;rdquo; and &amp;ldquo;F2&amp;rdquo; floating-point errata.)</source>
          <target state="translated">特定のSB-1 CPUコアのエラッタを回避します。（このフラグは現在、SB-1リビジョン2の「F1」および「F2」浮動小数点エラータを回避します。）</target>
        </trans-unit>
        <trans-unit id="f1322c2c26c7f8a2ae0c4abcf920ab6e36d8883e" translate="yes" xml:space="preserve">
          <source>Work around certain VR4120 errata:</source>
          <target state="translated">特定の VR4120 正誤表を回避できるようにしました。</target>
        </trans-unit>
        <trans-unit id="70f65ee28d3f60e1570e5c0565d3bacdc0372408" translate="yes" xml:space="preserve">
          <source>Work around the 24K E48 (lost data on stores during refill) errata. The workarounds are implemented by the assembler rather than by GCC.</source>
          <target state="translated">24K E48 (リフィル中にストアのデータが失われる)のエラッタを回避します。回避策はGCCではなくアセンブラで実装されています。</target>
        </trans-unit>
        <trans-unit id="eecdf3e0ad9c1e4373885008c446ef1d15e0de5a" translate="yes" xml:space="preserve">
          <source>Work around the RM7000 &lt;code&gt;dmult&lt;/code&gt;/&lt;code&gt;dmultu&lt;/code&gt; errata. The workarounds are implemented by the assembler rather than by GCC.</source>
          <target state="translated">RM7000 &lt;code&gt;dmult&lt;/code&gt; / &lt;code&gt;dmultu&lt;/code&gt; errataを回避します。回避策は、GCCではなくアセンブラによって実装されます。</target>
        </trans-unit>
        <trans-unit id="f514e8f6d3c8232406871016402b0b519b9f1bff" translate="yes" xml:space="preserve">
          <source>Work around the VR4130 &lt;code&gt;mflo&lt;/code&gt;/&lt;code&gt;mfhi&lt;/code&gt; errata. The workarounds are implemented by the assembler rather than by GCC, although GCC avoids using &lt;code&gt;mflo&lt;/code&gt; and &lt;code&gt;mfhi&lt;/code&gt; if the VR4130 &lt;code&gt;macc&lt;/code&gt;, &lt;code&gt;macchi&lt;/code&gt;, &lt;code&gt;dmacc&lt;/code&gt; and &lt;code&gt;dmacchi&lt;/code&gt; instructions are available instead.</source>
          <target state="translated">VR4130 &lt;code&gt;mflo&lt;/code&gt; / &lt;code&gt;mfhi&lt;/code&gt; errataを回避します。回避策はGCCではなくアセンブラによって実装されますが、VR4130 &lt;code&gt;macc&lt;/code&gt; 、 &lt;code&gt;macchi&lt;/code&gt; 、 &lt;code&gt;dmacc&lt;/code&gt; 、および &lt;code&gt;dmacchi&lt;/code&gt; 命令が代わりに使用可能な場合、GCCは &lt;code&gt;mflo&lt;/code&gt; および &lt;code&gt;mfhi&lt;/code&gt; の使用を回避します。</target>
        </trans-unit>
        <trans-unit id="0a937c64e2a5b7eba62b666d7ca837eb48731984" translate="yes" xml:space="preserve">
          <source>Write &lt;var&gt;src1&lt;/var&gt; into Y.</source>
          <target state="translated">&lt;var&gt;src1&lt;/var&gt; をYに書き込みます。</target>
        </trans-unit>
        <trans-unit id="b99c5ddd130a32b9357572f70d99408237dc24f1" translate="yes" xml:space="preserve">
          <source>Write &lt;var&gt;src1&lt;/var&gt; into the least significant half of X and &lt;var&gt;src2&lt;/var&gt; into the most significant half of X.</source>
          <target state="translated">Xの最下位半分に &lt;var&gt;src1&lt;/var&gt; を書き込み、X の最上位半分に &lt;var&gt;src2&lt;/var&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="282a09ed773c8ef9852a2c6377ed12597d3a9c69" translate="yes" xml:space="preserve">
          <source>Write a SRCFILE.opt-record.json.gz file detailing what optimizations were performed, for those optimizations that support</source>
          <target state="translated">SRCFILE.opt-record.json.gz ファイルに、どのような最適化が行われたかを詳細に記述します。</target>
        </trans-unit>
        <trans-unit id="40d1ca8852e0dec6c7d4fad7e6bc0514fe5d1c54" translate="yes" xml:space="preserve">
          <source>Write branch frequencies as the number of branches taken, rather than the percentage of branches taken.</source>
          <target state="translated">枝の頻度は、取られた枝の割合ではなく、取られた枝の数として書きます。</target>
        </trans-unit>
        <trans-unit id="1423ee2af8243360b137ebe26d7ad382ca0b3b1e" translate="yes" xml:space="preserve">
          <source>Write branch frequencies to the output file, and write branch summary info to the standard output. This option allows you to see how often each branch in your program was taken. Unconditional branches will not be shown, unless the</source>
          <target state="translated">分岐の頻度を出力ファイルに書き込み、分岐のサマリー情報を標準出力に書き込みます。このオプションを使うと、プログラムの各ブランチがどのくらいの頻度で実行されたかを見ることができます。無条件分岐は</target>
        </trans-unit>
        <trans-unit id="1fecc6871d15f561a1a398ebd76fa3a7a1663e9e" translate="yes" xml:space="preserve">
          <source>Write counts in human readable format (like 24.6k).</source>
          <target state="translated">人間が読める形式(24.6kなど)でカウントを書き込む。</target>
        </trans-unit>
        <trans-unit id="e00e26a5662df1b01236462f99618d8089824cf9" translate="yes" xml:space="preserve">
          <source>Write individual execution counts for every basic block. Normally gcov outputs execution counts only for the main blocks of a line. With this option you can determine if blocks within a single line are not being executed.</source>
          <target state="translated">基本ブロックごとに個別の実行カウントを書き込む 通常、gcovは行のメインブロックのみに実行カウントを出力します。このオプションを使用すると、単一行内のブロックが実行されていないかどうかを判断することができます。</target>
        </trans-unit>
        <trans-unit id="27b79e5dd909fed4a63697002ecabe6d4fcefd2b" translate="yes" xml:space="preserve">
          <source>Write the name of each function into the text section, directly preceding the function prologue. The generated code is similar to this:</source>
          <target state="translated">各関数の名前を、関数のプロローグの前のテキストセクションに書きます。生成されたコードはこのようになります。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="2c144edd2dd673b9ae13db81c4f7c41356844426" translate="yes" xml:space="preserve">
          <source>XER[CA]</source>
          <target state="translated">XER[CA]</target>
        </trans-unit>
        <trans-unit id="edd05eca97855bc49145e43cb3ab5438e61cd98b" translate="yes" xml:space="preserve">
          <source>XOP instructions.</source>
          <target state="translated">XOPの指示。</target>
        </trans-unit>
        <trans-unit id="e69dd5b634eb9535ab5de7682e5d1e10df284ccf" translate="yes" xml:space="preserve">
          <source>Xstormy16&amp;mdash;</source>
          <target state="translated">Xstormy16&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8341de0a85a327eb2d7c97b77086eb0bff937ecb" translate="yes" xml:space="preserve">
          <source>Xtensa&amp;mdash;</source>
          <target state="translated">Xtensa&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="cbfadbe232364f5b4cd1f9250a9cda7fadbb0042" translate="yes" xml:space="preserve">
          <source>You can additionally specify a string parameter: &amp;lsquo;</source>
          <target state="translated">さらに、文字列パラメータを指定できます： '</target>
        </trans-unit>
        <trans-unit id="37f047474bb2991bbc870836a4b1dc7ea6a7e179" translate="yes" xml:space="preserve">
          <source>You can also construct an array, though this is dangerous in C++, as explained below. If all the elements of the compound literal are (made up of) simple constant expressions suitable for use in initializers of objects of static storage duration, then the compound literal can be coerced to a pointer to its first element and used in such an initializer, as shown here:</source>
          <target state="translated">配列を構築することもできますが、これは以下で説明するように、C++では危険です。複合リテラルのすべての要素が、静的記憶期間のオブジェクトのイニシャライザでの使用に適した(構成された)単純な定数式である場合、複合リテラルはその最初の要素へのポインタを強制的に持たせることができ、ここに示すように、そのようなイニシャライザで使用することができます。</target>
        </trans-unit>
        <trans-unit id="7e3923b44bbc7d66662628b3637d89fe21e428bc" translate="yes" xml:space="preserve">
          <source>You can also include type attributes in a &lt;code&gt;typedef&lt;/code&gt; declaration. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes.</source>
          <target state="translated">&lt;code&gt;typedef&lt;/code&gt; 宣言に型属性を含めることもできます。&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性&lt;/a&gt;を使用するための正確な構文の詳細については、「属性の構文」を参照してください。</target>
        </trans-unit>
        <trans-unit id="c36aaae0a5a83266e8e76c432773d2ebb3588799" translate="yes" xml:space="preserve">
          <source>You can also override the ARM and Thumb mode for each function by using the &lt;code&gt;target(&quot;thumb&quot;)&lt;/code&gt; and &lt;code&gt;target(&quot;arm&quot;)&lt;/code&gt; function attributes (see &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;) or pragmas (see &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;).</source>
          <target state="translated">また、 &lt;code&gt;target(&quot;thumb&quot;)&lt;/code&gt; および &lt;code&gt;target(&quot;arm&quot;)&lt;/code&gt; 関数属性（&lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM関数属性を&lt;/a&gt;参照）またはプラグマ（&lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;関数固有のオプションプラグマを&lt;/a&gt;参照）を使用して、各関数のARMモードとThumbモードをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="70f9f23d58cf9ce6f889493d1bc7a0c90625f3a7" translate="yes" xml:space="preserve">
          <source>You can also record the return value of that function call, and later return that value, without knowing what data type the function tried to return (as long as your caller expects that data type).</source>
          <target state="translated">また、関数呼び出しの戻り値を記録しておき、後でその値を返すこともできます。</target>
        </trans-unit>
        <trans-unit id="1165641e4d4b9af84b909635ee9d9e9c442957c3" translate="yes" xml:space="preserve">
          <source>You can also set the fpu name at function level by using the &lt;code&gt;target(&quot;fpu=&quot;)&lt;/code&gt; function attributes (see &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;) or pragmas (see &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;target(&quot;fpu=&quot;)&lt;/code&gt; 関数属性（&lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM関数属性を&lt;/a&gt;参照）またはプラグマ（&lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;関数固有のオプションプラグマを&lt;/a&gt;参照）を使用して、関数レベルでfpu名を設定することもできます。</target>
        </trans-unit>
        <trans-unit id="7268dd0eaeb17935e5094a8029ba22d93c31a1ac" translate="yes" xml:space="preserve">
          <source>You can also specify</source>
          <target state="translated">を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="08bf03c9c6ff7624c857011e74954c5c6f9f4300" translate="yes" xml:space="preserve">
          <source>You can also specify the alignment of structure fields. For example, to create a double-word aligned &lt;code&gt;int&lt;/code&gt; pair, you could write:</source>
          <target state="translated">構造体フィールドの配置を指定することもできます。たとえば、ダブルワードで整列された &lt;code&gt;int&lt;/code&gt; ペアを作成するには、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">また、以下のような使い方もできます。</target>
        </trans-unit>
        <trans-unit id="282b6d022cb9c27fb3bb9103220d6eb51129f71a" translate="yes" xml:space="preserve">
          <source>You can also use attributes to control memory placement, code generation options or call/return conventions within the function being annotated. Many of these attributes are target-specific. For example, many targets support attributes for defining interrupt handler functions, which typically must follow special register usage and return conventions. Such attributes are described in the subsection for each target. However, a considerable number of attributes are supported by most, if not all targets. Those are described in the &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt; section.</source>
          <target state="translated">属性を使用して、注釈が付けられている関数内のメモリ配置、コード生成オプション、または呼び出し/戻り規則を制御することもできます。これらの属性の多くはターゲット固有です。たとえば、多くのターゲットは割り込みハンドラー関数を定義するための属性をサポートします。これは通常、特殊なレジスターの使用法と戻り規則に従う必要があります。このような属性については、各ターゲットのサブセクションで説明しています。ただし、すべてではないにしても、ほとんどの属性がかなりの数の属性をサポートしています。これらについては、「&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;共通の関数属性」&lt;/a&gt;セクションで説明しています。</target>
        </trans-unit>
        <trans-unit id="972bfbc14b560aee91d8b7d5cfbc635d959441aa" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;asm&lt;/code&gt; keyword to override the assembler name for a C symbol, or to place a C variable in a specific register.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; キーワードを使用して、Cシンボルのアセンブラー名をオーバーライドしたり、C変数を特定のレジスターに配置したりすることもできます。</target>
        </trans-unit>
        <trans-unit id="354710c3fd8ed8d70c6d2f210156da0243dc4ade" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;nocf_check&lt;/code&gt; attribute to identify which functions and calls should be skipped from instrumentation (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;nocf_check&lt;/code&gt; 属性を使用して、インスツルメンテーションからスキップする必要がある関数と呼び出しを識別することもできます（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d1c6ca2bbbe80bcabecefea25be4aa8fafd6e4d0" translate="yes" xml:space="preserve">
          <source>You can also use the union cast as a function argument:</source>
          <target state="translated">また、関数の引数としてユニオンキャストを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="66b750e5491b307807c28732748047266dbd8e2a" translate="yes" xml:space="preserve">
          <source>You can also use variable-length arrays as arguments to functions:</source>
          <target state="translated">関数の引数として可変長の配列を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="3ed04a1e1ec2d18dcef36c3f37e8523ec33398b1" translate="yes" xml:space="preserve">
          <source>You can also write a series of &amp;lsquo;</source>
          <target state="translated">一連の「</target>
        </trans-unit>
        <trans-unit id="9a5d42d9b4feab1feb11ac3d7558132f70441d15" translate="yes" xml:space="preserve">
          <source>You can combine this technique of naming elements with ordinary C initialization of successive elements. Each initializer element that does not have a designator applies to the next consecutive element of the array or structure. For example,</source>
          <target state="translated">要素に名前を付けるこのテクニックを、連続する要素の通常のC言語の初期化と組み合わせることができます。指定子を持たない各イニシャライザ要素は、配列や構造体の次の連続した要素に適用されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="dafe9f6d4d43d75c6afd7b0ee12396460454db2d" translate="yes" xml:space="preserve">
          <source>You can compile C or C++ programs.</source>
          <target state="translated">CやC++のプログラムをコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="54a148541552bb61abf1cc1bf716d6d5d34812ff" translate="yes" xml:space="preserve">
          <source>You can declare variables and use them in function calls and returns, as well as in assignments and some casts. You can specify a vector type as a return type for a function. Vector types can also be used as function arguments. It is possible to cast from one vector type to another, provided they are of the same size (in fact, you can also cast vectors to and from other datatypes of the same size).</source>
          <target state="translated">変数を宣言して、関数の呼び出しや戻り値、代入や一部のキャストで使用することができます。関数の戻り値の型としてベクトル型を指定することができます。ベクトル型は関数の引数としても使用できます。同じサイズであれば、あるベクトル型から別のベクトル型へのキャストが可能です(実際、同じサイズの他のデータ型との間でベクトルをキャストすることもできます)。</target>
        </trans-unit>
        <trans-unit id="1ab5d021681ed2c7cdd4c44a866c9249ac2dea29" translate="yes" xml:space="preserve">
          <source>You can define a global register variable and associate it with a specified register like this:</source>
          <target state="translated">グローバルレジスタ変数を定義して、このように指定したレジスタに関連付けることができます。</target>
        </trans-unit>
        <trans-unit id="77ca46933320ecebc543d5687d368957991075a9" translate="yes" xml:space="preserve">
          <source>You can define a local register variable and associate it with a specified register like this:</source>
          <target state="translated">ローカルレジスタ変数を定義して、このように指定したレジスタに関連付けることができます。</target>
        </trans-unit>
        <trans-unit id="ca45e2aac1a5f53872ccff8b57eb4700a2d304e0" translate="yes" xml:space="preserve">
          <source>You can define an &lt;code&gt;enum&lt;/code&gt; tag without specifying its possible values. This results in an incomplete type, much like what you get if you write &lt;code&gt;struct foo&lt;/code&gt; without describing the elements. A later declaration that does specify the possible values completes the type.</source>
          <target state="translated">可能な値を指定せずに &lt;code&gt;enum&lt;/code&gt; タグを定義できます。これにより、要素を記述せずに &lt;code&gt;struct foo&lt;/code&gt; を記述した場合と同様に、不完全な型になります。可能な値を指定する後の宣言で型が完成します。</target>
        </trans-unit>
        <trans-unit id="fb2a1d08a5c520db79d7874dd1dd146adad124cb" translate="yes" xml:space="preserve">
          <source>You can easily find more examples by running the &amp;ldquo;strings&amp;rdquo; program on an Objective-C object file compiled by GCC. You&amp;rsquo;ll see a lot of strings that look very much like &lt;code&gt;i8@0:4&lt;/code&gt;. They are signatures of Objective-C methods.</source>
          <target state="translated">GCCによってコンパイルされたObjective-Cオブジェクトファイルに対して「strings」プログラムを実行することで、より多くの例を簡単に見つけることができます。 &lt;code&gt;i8@0:4&lt;/code&gt; ように見える多くの文字列が表示されます。これらはObjective-Cメソッドのシグネチャです。</target>
        </trans-unit>
        <trans-unit id="c91ff1d5bc0072fabb3f73c5cf99e1426b54e8b7" translate="yes" xml:space="preserve">
          <source>You can extract a function pointer to the method denoted by a &amp;lsquo;</source>
          <target state="translated">'で示されるメソッドへの関数ポインタを抽出できます</target>
        </trans-unit>
        <trans-unit id="8a467dff38136e5694516c0b9fa42d9b5384c2d1" translate="yes" xml:space="preserve">
          <source>You can get the address of a label defined in the current function (or a containing function) with the unary operator &amp;lsquo;</source>
          <target state="translated">単項演算子を使用して、現在の関数（または包含関数）で定義されているラベルのアドレスを取得できます '</target>
        </trans-unit>
        <trans-unit id="66a39a597ab8644152ae7afe5488f241a221884a" translate="yes" xml:space="preserve">
          <source>You can locally override stack limit checking by using the &lt;code&gt;no_stack_limit&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;no_stack_limit&lt;/code&gt; 関数属性を使用して、スタック制限チェックをローカルでオーバーライドできます（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="017844d9ef74d08a2197a10acca046c6aa9a28bc" translate="yes" xml:space="preserve">
          <source>You can make</source>
          <target state="translated">作ることができます。</target>
        </trans-unit>
        <trans-unit id="f287c383d16164fdc862549b5e329c619384b24c" translate="yes" xml:space="preserve">
          <source>You can mix options and other arguments. For the most part, the order you use doesn&amp;rsquo;t matter. Order does matter when you use several options of the same kind; for example, if you specify</source>
          <target state="translated">オプションと他の引数を混在させることができます。ほとんどの場合、使用する順序は重要ではありません。同じ種類のオプションをいくつか使用する場合、順序は重要です。たとえば、次のように指定した場合</target>
        </trans-unit>
        <trans-unit id="a60d360fa80936234f5b0e4eae813689b9ce29d9" translate="yes" xml:space="preserve">
          <source>You can partially avoid this problem by using the</source>
          <target state="translated">この問題を部分的に回避するには</target>
        </trans-unit>
        <trans-unit id="dd9e0967154278910b1a4d13c152f96dcaf35354" translate="yes" xml:space="preserve">
          <source>You can pass options to the assembler.</source>
          <target state="translated">アセンブラにオプションを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="394017d54ef624457656b3872471fba70d98d59b" translate="yes" xml:space="preserve">
          <source>You can provide an argument to the interrupt attribute which specifies a name or number. If the argument is a number it indicates the slot in the interrupt vector table (0 - 31) to which this handler should be assigned. If the argument is a name it is treated as a symbolic name for the vector slot. These names should match up with appropriate entries in the linker script. By default the names &lt;code&gt;watchdog&lt;/code&gt; for vector 26, &lt;code&gt;nmi&lt;/code&gt; for vector 30 and &lt;code&gt;reset&lt;/code&gt; for vector 31 are recognized.</source>
          <target state="translated">名前または番号を指定する割り込み属性に引数を提供できます。引数が数値の場合、これは、このハンドラーを割り当てる必要がある割り込みベクターテーブル内のスロット（0〜31）を示します。引数が名前の場合、それはベクタースロットのシンボリック名として扱われます。これらの名前は、リンカースクリプトの適切なエントリと一致する必要があります。デフォルトでは、ベクトル26の &lt;code&gt;watchdog&lt;/code&gt; 、ベクトル30の &lt;code&gt;nmi&lt;/code&gt; 、およびベクトル31の &lt;code&gt;reset&lt;/code&gt; という名前が認識されます。</target>
        </trans-unit>
        <trans-unit id="21a34f7c6e1539af9716888a85e0e6ebdfedbecf" translate="yes" xml:space="preserve">
          <source>You can request many specific warnings with options beginning with &amp;lsquo;</source>
          <target state="translated">'で始まるオプションを使用して、多くの特定の警告を要求できます。</target>
        </trans-unit>
        <trans-unit id="7fbbe3966a5814f26c4830b1276b72ab5f2dc01c" translate="yes" xml:space="preserve">
          <source>You can specify a range of consecutive values in a single &lt;code&gt;case&lt;/code&gt; label, like this:</source>
          <target state="translated">次のように、単一の &lt;code&gt;case&lt;/code&gt; ラベルで連続する値の範囲を指定できます。</target>
        </trans-unit>
        <trans-unit id="97b79ea591cef9266e325e711531c14dffd1c998" translate="yes" xml:space="preserve">
          <source>You can specify any number or combination of these options on the command line to search for header files in several directories. The lookup order is as follows:</source>
          <target state="translated">コマンドラインでこれらのオプションの任意の数または組み合わせを指定することで、複数のディレクトリ内のヘッダファイルを検索することができます。検索順序は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="0856d34db6c364c78838eb5dc1f8a6703a890626" translate="yes" xml:space="preserve">
          <source>You can specify that an individual function is called with this calling sequence with the function attribute &lt;code&gt;stdcall&lt;/code&gt;. You can also override the</source>
          <target state="translated">関数属性 &lt;code&gt;stdcall&lt;/code&gt; を使用して、この呼び出しシーケンスで個々の関数が呼び出されるように指定できます。また、</target>
        </trans-unit>
        <trans-unit id="e32757ea6fc6362ed46b9b724d574c0143bee986" translate="yes" xml:space="preserve">
          <source>You can specify the input language explicitly with the</source>
          <target state="translated">入力言語を明示的に指定するには</target>
        </trans-unit>
        <trans-unit id="5a6c68a45d3cab174002900881189fc68df355b1" translate="yes" xml:space="preserve">
          <source>You can specify the kind of interrupt to be handled by adding an optional parameter to the interrupt attribute like this:</source>
          <target state="translated">このようにinterrupt属性にオプションのパラメータを追加することで、処理する割り込みの種類を指定することができます。</target>
        </trans-unit>
        <trans-unit id="eee1f7bf9410ab86d8dd30e2bec2be1b2b043010" translate="yes" xml:space="preserve">
          <source>You can specify the name to be used in the assembler code for a C function or variable by writing the &lt;code&gt;asm&lt;/code&gt; (or &lt;code&gt;__asm__&lt;/code&gt;) keyword after the declarator. It is up to you to make sure that the assembler names you choose do not conflict with any other assembler symbols, or reference registers.</source>
          <target state="translated">宣言子の後に &lt;code&gt;asm&lt;/code&gt; （または &lt;code&gt;__asm__&lt;/code&gt; ）キーワードを記述することにより、C関数または変数のアセンブラコードで使用する名前を指定できます。選択したアセンブラ名が他のアセンブラシンボルまたは参照レジスタと競合しないことを確認するのは、あなた次第です。</target>
        </trans-unit>
        <trans-unit id="30703f7905f24c8604a78167a64a5e3a31da9d67" translate="yes" xml:space="preserve">
          <source>You can switch the warning off for all characters by writing</source>
          <target state="translated">と記述することで、すべての文字に対して警告をオフにすることができます。</target>
        </trans-unit>
        <trans-unit id="95dff15ddf46fdf8429aae6e46c8c16ce4977196" translate="yes" xml:space="preserve">
          <source>You can tell GCC to use a compatible convention for all structure and union returning with the option</source>
          <target state="translated">GCC に、構造体とユニオンのすべての返り値に互換性のある規約を使用するように指示するには</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">を使用することができます。</target>
        </trans-unit>
        <trans-unit id="4f81d4b126c2797fc5e8e7dc1694c11a9c296047" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;__declspec(dllexport)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((dllexport))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">他のコンパイラとの互換性のために、 &lt;code&gt;__attribute__ ((dllexport))&lt;/code&gt; &lt;code&gt;__declspec(dllexport)&lt;/code&gt; を__attribute__（（dllexport））の同義語として使用できます。</target>
        </trans-unit>
        <trans-unit id="50005d4562495b37fc24571844dc1743ca746f4c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;__declspec(dllimport)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((dllimport))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">他のコンパイラとの互換性のために、 &lt;code&gt;__attribute__ ((dllimport))&lt;/code&gt; &lt;code&gt;__declspec(dllimport)&lt;/code&gt; を__attribute__（（dllimport））の同義語として使用できます。</target>
        </trans-unit>
        <trans-unit id="86cd667b81efa67cbffa6feec930a1fbdb8eae9f" translate="yes" xml:space="preserve">
          <source>You can use a single C++ header file for both declarations and definitions.</source>
          <target state="translated">宣言と定義の両方に 1 つの C++ヘッダーファイルを使用できます。</target>
        </trans-unit>
        <trans-unit id="9d208552bb3a27bb1eed945c45c53009e9054861" translate="yes" xml:space="preserve">
          <source>You can use any combination of these attributes, as shown below:</source>
          <target state="translated">以下に示すように、これらの属性を任意の組み合わせで使用することができます。</target>
        </trans-unit>
        <trans-unit id="db76755964be4e6b6be71f9e85d1a8d93663640f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;copy&lt;/code&gt; attribute to apply the same set of attributes to a declaration as that on another declaration without explicitly enumerating the attributes. This attribute can be applied to declarations of functions (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;), or types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 属性を使用すると、明示的に属性を列挙せずに、同じ属性セットを別の宣言と同じ属性セットに適用できます。この属性は、関数の宣言（「&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;共通の関数属性&lt;/a&gt;」を参照）、変数（「&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;共通の変数属性&lt;/a&gt;」を参照）、または型（「&lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;共通の型属性&lt;/a&gt;」を参照）に適用できます。</target>
        </trans-unit>
        <trans-unit id="89b5b15d997a3489b69c6b152372fee0f86bbdac" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_choose_expr&lt;/code&gt; to evaluate code depending on the value of a constant expression. This built-in function returns &lt;var&gt;exp1&lt;/var&gt; if &lt;var&gt;const_exp&lt;/var&gt;, which is an integer constant expression, is nonzero. Otherwise it returns &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">組み込み関数 &lt;code&gt;__builtin_choose_expr&lt;/code&gt; を使用して、定数式の値に応じてコードを評価できます。これは、組み込み関数の戻り &lt;var&gt;exp1&lt;/var&gt; 場合 &lt;var&gt;const_exp&lt;/var&gt; 整数定数式であり、非ゼロです。それ以外の場合は、 &lt;var&gt;exp2&lt;/var&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="5fd9fec295629e67098066cf6cb3c9ec92e5bb68" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_constant_p&lt;/code&gt; to determine if a value is known to be constant at compile time and hence that GCC can perform constant-folding on expressions involving that value. The argument of the function is the value to test. The function returns the integer 1 if the argument is known to be a compile-time constant and 0 if it is not known to be a compile-time constant. A return of 0 does not indicate that the value is &lt;em&gt;not&lt;/em&gt; a constant, but merely that GCC cannot prove it is a constant with the specified value of the</source>
          <target state="translated">組み込み関数 &lt;code&gt;__builtin_constant_p&lt;/code&gt; を使用して、コンパイル時に値が定数であることがわかっているかどうか、したがってGCCがその値を含む式で定数折りたたみを実行できるかどうかを判断できます。関数の引数は、テストする値です。この関数は、引数がコンパイル時定数であることがわかっている場合は整数1を返し、コンパイル時定数であることがわかっていない場合は0を返します。0の戻り値は、値が定数ではないことを示すのでは&lt;em&gt;なく&lt;/em&gt;、GCCが値が</target>
        </trans-unit>
        <trans-unit id="9782a2381707d838ed59767d72501592b95036b5" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; to determine whether two types are the same.</source>
          <target state="translated">組み込み関数 &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; を使用して、2つの型が同じかどうかを判断できます。</target>
        </trans-unit>
        <trans-unit id="43fa60b9360490e7ba0b03452edb689c2650070f" translate="yes" xml:space="preserve">
          <source>You can use the following attributes to modify the behavior of an interrupt handler:</source>
          <target state="translated">以下の属性を使用して、割り込みハンドラの動作を変更することができます。</target>
        </trans-unit>
        <trans-unit id="02c72ec7b7bacac9ecd4a1fee983fedeb76ad118" translate="yes" xml:space="preserve">
          <source>You can use the function &lt;code&gt;alloca&lt;/code&gt; to get an effect much like variable-length arrays. The function &lt;code&gt;alloca&lt;/code&gt; is available in many other C implementations (but not in all). On the other hand, variable-length arrays are more elegant.</source>
          <target state="translated">関数 &lt;code&gt;alloca&lt;/code&gt; を使用して、可変長配列のような効果を得ることができます。関数 &lt;code&gt;alloca&lt;/code&gt; は、他の多くのC実装で使用できます（すべてではありません）。一方、可変長配列はよりエレガントです。</target>
        </trans-unit>
        <trans-unit id="50e67953531648188b117541d8b8b4fa30e96296" translate="yes" xml:space="preserve">
          <source>You can use the function attribute &lt;code&gt;no_instrument_function&lt;/code&gt; to suppress profiling of individual functions when compiling with these options. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">関数属性 &lt;code&gt;no_instrument_function&lt;/code&gt; を使用すると、これらのオプションを使用してコンパイルするときに、個々の関数のプロファイリングを抑制できます。&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e0525436fc5cc0248b7f78e573bd26eb006c5427" translate="yes" xml:space="preserve">
          <source>You can use the sequence &amp;lsquo;</source>
          <target state="translated">シーケンスを使用できます '</target>
        </trans-unit>
        <trans-unit id="25c48302e37cab0b76739d2efc98f5300353b6c4" translate="yes" xml:space="preserve">
          <source>You can use these attributes on Microsoft Windows targets. &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; for additional Windows compatibility attributes available on all x86 targets.</source>
          <target state="translated">これらの属性は、Microsoft Windowsターゲットで使用できます。すべてのx86ターゲットで使用可能な追加のWindows互換属性の&lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86変数属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="349076840f0960c3892315d6f39c00e2e8d77252" translate="yes" xml:space="preserve">
          <source>You can use these types in arithmetic like any other integer types. Addition, subtraction, and bitwise boolean operations on these types are open-coded on all types of machines. Multiplication is open-coded if the machine supports a fullword-to-doubleword widening multiply instruction. Division and shifts are open-coded only on machines that provide special support. The operations that are not open-coded use special library routines that come with GCC.</source>
          <target state="translated">これらの型は、他の整数型と同様に算術で使用できます。これらの型に対する加算、減算、およびビット単位のブール演算は、すべての型のマシンでオープンコード化されています。乗算は、マシンがフルワードからダブルワードへの拡大乗算命令をサポートしている場合、オープンコード化されます。除算とシフトは、特別なサポートを提供するマシンでのみオープンコード化されます。オープンコード化されていない演算は、GCC に付属の特別なライブラリルーチンを使用します。</target>
        </trans-unit>
        <trans-unit id="5aa1044e05ab82d1a453a9feb88c6b31c8d70c35" translate="yes" xml:space="preserve">
          <source>You can use this pragma to control how many times a loop should be unrolled. It must be placed immediately before a &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt; loop or a &lt;code&gt;#pragma GCC ivdep&lt;/code&gt;, and applies only to the loop that follows. &lt;var&gt;n&lt;/var&gt; is an integer constant expression specifying the unrolling factor. The values of &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;1&lt;/em&gt; block any unrolling of the loop.</source>
          <target state="translated">このプラグマを使用して、ループを展開する回数を制御できます。これは、 &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; 、 &lt;code&gt;do&lt;/code&gt; ループ、または &lt;code&gt;#pragma GCC ivdep&lt;/code&gt; の直前に配置する必要があり、後続のループにのみ適用されます。 &lt;var&gt;n&lt;/var&gt; は、展開係数を指定する整数定数式です。&lt;em&gt;0&lt;/em&gt;と&lt;em&gt;1&lt;/em&gt;の値は、ループの展開をブロックします。</target>
        </trans-unit>
        <trans-unit id="d29715d375c9f43b63580c5f152e79229b459a6b" translate="yes" xml:space="preserve">
          <source>You can write any number of such parameter forward declarations in the parameter list. They can be separated by commas or semicolons, but the last one must end with a semicolon, which is followed by the &amp;ldquo;real&amp;rdquo; parameter declarations. Each forward declaration must match a &amp;ldquo;real&amp;rdquo; declaration in parameter name and data type. ISO C99 does not support parameter forward declarations.</source>
          <target state="translated">パラメータリストには、このようなパラメータの前方宣言をいくつでも書き込むことができます。それらはコンマまたはセミコロンで区切ることができますが、最後のものはセミコロンで終了する必要があり、その後に「実際の」パラメーター宣言が続きます。各前方宣言は、パラメーター名とデータ型の「実際の」宣言と一致する必要があります。ISO C99はパラメーターの前方宣言をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="4d285fcb57d29c445f5c75a81399654db437434b" translate="yes" xml:space="preserve">
          <source>You cannot allocate variables or storage using the type while it is incomplete. However, you can work with pointers to that type.</source>
          <target state="translated">型が不完全な状態では、その型を使用して変数やストレージを割り当てることはできません。しかし、その型へのポインタを使って作業することはできます。</target>
        </trans-unit>
        <trans-unit id="53335da409471fbe7935a617fd9f6ebf473abc26" translate="yes" xml:space="preserve">
          <source>You cannot operate between vectors of different lengths or different signedness without a cast.</source>
          <target state="translated">長さの異なるベクトル間や符号の異なるベクトル間は、キャストがないと操作できません。</target>
        </trans-unit>
        <trans-unit id="13abf1800307e25590d2602f0489f433955f9bc6" translate="yes" xml:space="preserve">
          <source>You have freedom to copy and modify this GNU Manual, like GNU software. Copies published by the Free Software Foundation raise funds for GNU development.</source>
          <target state="translated">あなたには、GNUソフトウェアのように、このGNUマニュアルをコピーしたり変更したりする自由があります。フリーソフトウェアファウンデーションによって発行されたコピーは、GNU開発のための資金を調達します。</target>
        </trans-unit>
        <trans-unit id="35918096a4cd3290ec21ef1581f71b03f35bc6de" translate="yes" xml:space="preserve">
          <source>You have the following options for dealing with template instantiations:</source>
          <target state="translated">テンプレートのインスタンスを扱うには、以下のオプションがあります。</target>
        </trans-unit>
        <trans-unit id="83ae29ebda55f943f2de3641f83fdea66157c750" translate="yes" xml:space="preserve">
          <source>You have to expect a certain amount of disagreement between the executable and your source code, when you use optimization.</source>
          <target state="translated">最適化を使用する際には、実行ファイルとソースコードの間にある程度の不一致があることを想定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="c18143538d54c0195224945ef42bc5ea23853737" translate="yes" xml:space="preserve">
          <source>You may also specify whether a member function&amp;rsquo;s &lt;var&gt;this&lt;/var&gt; pointer is unaliased by using &lt;code&gt;__restrict__&lt;/code&gt; as a member function qualifier.</source>
          <target state="translated">また、メンバ関数のかどうかを指定することもでき &lt;var&gt;this&lt;/var&gt; ポインタは使用して非エイリアスです &lt;code&gt;__restrict__&lt;/code&gt; メンバ関数修飾子として。</target>
        </trans-unit>
        <trans-unit id="3c9c1785a9b73c6c0c84000e89963aae3de9c571" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;__builtin_constant_p&lt;/code&gt; in initializers for static data. For instance, you can write</source>
          <target state="translated">静的データの初期化子で &lt;code&gt;__builtin_constant_p&lt;/code&gt; を使用することもできます。例えば、あなたは書くことができます</target>
        </trans-unit>
        <trans-unit id="77816405062bcfbd54b0c2d088c0cfe9f5a2c604" translate="yes" xml:space="preserve">
          <source>You may mark a method as having a visibility explicitly to negate the effect of the switch for that method. For example, if you do want to compare pointers to a particular inline method, you might mark it as having default visibility. Marking the enclosing class with explicit visibility has no effect.</source>
          <target state="translated">メソッドのスイッチの効果を否定するために、明示的に可視性を持つメソッドとしてマークすることができます。例えば、特定のインライン・メソッドへのポインタを比較したい場合は、デフォルトの可視性を持つようにマークすることができます。囲むクラスを明示的な可視性でマークしても何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="e445da5feb655d87cca8dbc770cb3f7e24dc970f" translate="yes" xml:space="preserve">
          <source>You may need to experiment to determine the best settings for your application.</source>
          <target state="translated">お使いのアプリケーションに最適な設定を決定するために、実験が必要な場合があります。</target>
        </trans-unit>
        <trans-unit id="bad95174418ab8218d171a6375d9166859a034cf" translate="yes" xml:space="preserve">
          <source>You may need to specify</source>
          <target state="translated">を指定する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="48a08602699410d27da97f57d05daf9841a17a43" translate="yes" xml:space="preserve">
          <source>You may not use this mechanism to jump to code in a different function. If you do that, totally unpredictable things happen. The best way to avoid this is to store the label address only in automatic variables and never pass it as an argument.</source>
          <target state="translated">このメカニズムを使って、別の関数のコードにジャンプすることはできません。そうすると、まったく予測できないことが起こります。これを避ける最善の方法は、ラベルアドレスを自動変数にのみ格納し、決して引数として渡さないことです。</target>
        </trans-unit>
        <trans-unit id="bff5113fa76e9e5005f3a00a7843919b5149c765" translate="yes" xml:space="preserve">
          <source>You may only specify the &lt;code&gt;packed&lt;/code&gt; attribute on the definition of an &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;class&lt;/code&gt;, not on a &lt;code&gt;typedef&lt;/code&gt; that does not also define the enumerated type, structure, union, or class.</source>
          <target state="translated">あなただけ指定することも &lt;code&gt;packed&lt;/code&gt; の定義に属性を &lt;code&gt;enum&lt;/code&gt; 、 &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; 、または &lt;code&gt;class&lt;/code&gt; ではない上、 &lt;code&gt;typedef&lt;/code&gt; でも列挙型、構造体、共用体、またはクラスを定義していません。</target>
        </trans-unit>
        <trans-unit id="54442d3018c5bf124a5cec286579f5b0f4a37809" translate="yes" xml:space="preserve">
          <source>You may only use the &lt;code&gt;shared&lt;/code&gt; attribute along with &lt;code&gt;section&lt;/code&gt; attribute with a fully-initialized global definition because of the way linkers work. See &lt;code&gt;section&lt;/code&gt; attribute for more information.</source>
          <target state="translated">リンカの動作方法のため、完全に初期化されたグローバル定義を持つ &lt;code&gt;section&lt;/code&gt; 属性と一緒にのみ &lt;code&gt;shared&lt;/code&gt; 属性を使用できます。詳細については、 &lt;code&gt;section&lt;/code&gt; 属性を参照してください。</target>
        </trans-unit>
        <trans-unit id="9c7b80e390300159d4993b9cd813e610830fb794" translate="yes" xml:space="preserve">
          <source>You may optionally specify attribute names with &amp;lsquo;</source>
          <target state="translated">オプションで 'で属性名を指定できます</target>
        </trans-unit>
        <trans-unit id="b744bc45d5f9c7b517250c91d7d9ce559fd58615" translate="yes" xml:space="preserve">
          <source>You may place multiple assembler instructions together in a single &lt;code&gt;asm&lt;/code&gt; string, separated by the characters normally used in assembly code for the system. A combination that works in most places is a newline to break the line, plus a tab character (written as &amp;lsquo;</source>
          <target state="translated">複数のアセンブラー命令を1つの &lt;code&gt;asm&lt;/code&gt; 文字列にまとめて、システムのアセンブリコードで通常使用される文字で区切って配置できます。ほとんどの場所で機能する組み合わせは、行を改行する改行とタブ文字（「</target>
        </trans-unit>
        <trans-unit id="c17cdd78fed8e2f19f13ed7c6a72d4082d16e577" translate="yes" xml:space="preserve">
          <source>You may place multiple assembler instructions together in a single &lt;code&gt;asm&lt;/code&gt; string, separated by the characters normally used in assembly code for the system. A combination that works in most places is a newline to break the line, plus a tab character to move to the instruction field (written as &amp;lsquo;</source>
          <target state="translated">複数のアセンブラー命令を1つの &lt;code&gt;asm&lt;/code&gt; 文字列にまとめて、システムのアセンブリコードで通常使用される文字で区切って配置できます。ほとんどの場所で機能する組み合わせは、改行する改行と、命令フィールドに移動するタブ文字（「</target>
        </trans-unit>
        <trans-unit id="f0570114f2ecbb2dbeed78e2cafecfaebd377566" translate="yes" xml:space="preserve">
          <source>You may specify type attributes in an enum, struct or union type declaration or definition by placing them immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword. You can also place them just past the closing curly brace of the definition, but this is less preferred because logically the type should be fully defined at the closing brace.</source>
          <target state="translated">列挙型、構造体、または共用体の型宣言または定義で型属性を指定するには、それらを &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; 、または &lt;code&gt;enum&lt;/code&gt; キーワードの直後に配置します。また、定義の右中括弧のすぐ後ろに配置することもできますが、論理的には右中括弧で型を完全に定義する必要があるため、これはあまり好ましくありません。</target>
        </trans-unit>
        <trans-unit id="1fcc73998e38d45743d93a8c5804d34b2fb5bae5" translate="yes" xml:space="preserve">
          <source>You may use &lt;code&gt;__builtin_expect&lt;/code&gt; to provide the compiler with branch prediction information. In general, you should prefer to use actual profile feedback for this (</source>
          <target state="translated">&lt;code&gt;__builtin_expect&lt;/code&gt; を使用して、コンパイラに分岐予測情報を提供できます。一般に、これには実際のプロファイルフィードバックを使用することをお勧めします（</target>
        </trans-unit>
        <trans-unit id="dd9213edd154d9e31cb91aff441ba460289ac018" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;section&lt;/code&gt; attribute with initialized or uninitialized global variables but the linker requires each object be defined once, with the exception that uninitialized variables tentatively go in the &lt;code&gt;common&lt;/code&gt; (or &lt;code&gt;bss&lt;/code&gt;) section and can be multiply &amp;ldquo;defined&amp;rdquo;. Using the &lt;code&gt;section&lt;/code&gt; attribute changes what section the variable goes into and may cause the linker to issue an error if an uninitialized variable has multiple definitions. You can force a variable to be initialized with the</source>
          <target state="translated">あなたは使用することができます &lt;code&gt;section&lt;/code&gt; 初期化または初期化されていないグローバル変数を持つ属性をしかし、リンカは、各オブジェクトが初期化されていない変数は、暫定的に行くことを除いて、一度定義する必要があり &lt;code&gt;common&lt;/code&gt; （または &lt;code&gt;bss&lt;/code&gt; ）セクションと乗算「定義された」ことができます。 &lt;code&gt;section&lt;/code&gt; 属性を使用すると、変数が入るセクションが変更され、初期化されていない変数に複数の定義がある場合にリンカーがエラーを発行する可能性があります。変数を強制的に初期化することができます</target>
        </trans-unit>
        <trans-unit id="0897ffec25d2d3e9ff5e4c9a12cc715a05821b36" translate="yes" xml:space="preserve">
          <source>You may use this built-in function in either a macro or an inline function. However, if you use it in an inlined function and pass an argument of the function as the argument to the built-in, GCC never returns 1 when you call the inline function with a string constant or compound literal (see &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Compound Literals&lt;/a&gt;) and does not return 1 when you pass a constant numeric value to the inline function unless you specify the</source>
          <target state="translated">この組み込み関数は、マクロまたはインライン関数で使用できます。ただし、インライン関数で使用し、組み込み関数の引数として関数の引数を渡した場合、文字列定数または複合リテラル（&lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;複合リテラルを&lt;/a&gt;参照）を使用してインライン関数を呼び出しても、GCCは1を返しません。を指定しない限り、インライン関数に定数数値を渡しても1を返しません。</target>
        </trans-unit>
        <trans-unit id="179c17b93d49191ff63b1b0b1b00b166383a79b3" translate="yes" xml:space="preserve">
          <source>You must move the data files to the expected directory tree in order to use them for profile directed optimizations (</source>
          <target state="translated">プロファイル指向の最適化にデータファイルを使用するためには、期待されるディレクトリツリーにデータファイルを移動しなければなりません (</target>
        </trans-unit>
        <trans-unit id="65535d14a26d4547fe9b855313a51330599397c9" translate="yes" xml:space="preserve">
          <source>You must never create such structures that cause ambiguous field definitions. For example, in this structure:</source>
          <target state="translated">このような構造体を作成して、フィールド定義が曖昧になるようなことは絶対にしてはいけません。例えば、この構造体では</target>
        </trans-unit>
        <trans-unit id="364d53586a93cb7dd4166336e04c54defad73c15" translate="yes" xml:space="preserve">
          <source>You must specify</source>
          <target state="translated">を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="a0fd70e362d1f4b760a9cd038d96c07ea7f21b49" translate="yes" xml:space="preserve">
          <source>You must use GAS and GLD from GNU binutils version 2.7 or later for this attribute to work correctly.</source>
          <target state="translated">この属性が正しく動作するためには、GNU binutils バージョン 2.7 以降の GAS と GLD を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="6993ebfa9e3b6b6d6560ac8997eeb7ede6d0e9b1" translate="yes" xml:space="preserve">
          <source>You need this special case of the</source>
          <target state="translated">のこの特殊なケースが必要です。</target>
        </trans-unit>
        <trans-unit id="5a83a0c884ced5b1afbf8e0b73de9c85e4e8c7bb" translate="yes" xml:space="preserve">
          <source>You should be prepared for side effects when using</source>
          <target state="translated">を使用する際には、副作用を覚悟しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="fc2603d33fd81fe37c5c600db9786f0599bb7f89" translate="yes" xml:space="preserve">
          <source>You should compile your code without optimization if you plan to use &lt;code&gt;gcov&lt;/code&gt; because the optimization, by combining some lines of code into one function, may not give you as much information as you need to look for &amp;lsquo;hot spots&amp;rsquo; where the code is using a great deal of computer time. Likewise, because &lt;code&gt;gcov&lt;/code&gt; accumulates statistics by line (at the lowest resolution), it works best with a programming style that places only one statement on each line. If you use complicated macros that expand to loops or to other control structures, the statistics are less helpful&amp;mdash;they only report on the line where the macro call appears. If your complex macros behave like functions, you can replace them with inline functions to solve this problem.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; を使用する場合は、最適化せずにコードをコンパイルする必要があります。コードのいくつかの行を1つの関数に結合することによる最適化では、コードが使用している「ホットスポット」を探すために必要な情報が得られないためです。大量のコンピュータ時間。同様に、 &lt;code&gt;gcov&lt;/code&gt; は（最低の解像度で）行ごとに統計を蓄積するため、各行に1つのステートメントのみを配置するプログラミングスタイルで最適に機能します。ループやその他の制御構造に展開される複雑なマクロを使用する場合、統計はあまり役に立ちません。マクロ呼び出しが表示される行についてのみ報告します。複雑なマクロが関数のように動作する場合は、それらをインライン関数に置き換えて、この問題を解決できます。</target>
        </trans-unit>
        <trans-unit id="fe80fe3d98f647e191798f4bf1cd85c0708a7905" translate="yes" xml:space="preserve">
          <source>You should declare the jump buffer argument &lt;var&gt;buf&lt;/var&gt; to the built-in functions as:</source>
          <target state="translated">組み込み関数へのジャンプバッファ引数 &lt;var&gt;buf&lt;/var&gt; を次のように宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="7d1fbba229a2654e9c51633205d301f0603b772d" translate="yes" xml:space="preserve">
          <source>You should make no assumptions about receiving &lt;code&gt;+load&lt;/code&gt; in sibling classes when you write &lt;code&gt;+load&lt;/code&gt; of a class. The order in which sibling classes receive &lt;code&gt;+load&lt;/code&gt; is not guaranteed.</source>
          <target state="translated">クラスの &lt;code&gt;+load&lt;/code&gt; を作成するとき、兄弟クラスで &lt;code&gt;+load&lt;/code&gt; を受け取ることを前提にしないでください。兄弟クラスが &lt;code&gt;+load&lt;/code&gt; を受け取る順序は保証されていません。</target>
        </trans-unit>
        <trans-unit id="3a466242a3e9760eaada5a308649a4f792fde67b" translate="yes" xml:space="preserve">
          <source>You should not write this &lt;code&gt;#pragma&lt;/code&gt; in your own code, but it is safe to edit the filename if the PCH file is available in a different location. The filename may be absolute or it may be relative to GCC&amp;rsquo;s current directory.</source>
          <target state="translated">この &lt;code&gt;#pragma&lt;/code&gt; を独自のコードで記述しないでください。ただし、PCHファイルが別の場所にある場合は、ファイル名を編集しても安全です。ファイル名は絶対的なものでも、GCCの現在のディレクトリからの相対ファイルでもかまいません。</target>
        </trans-unit>
        <trans-unit id="b5b58bacb34de248a5caa9e1d70684a5e3e9e81a" translate="yes" xml:space="preserve">
          <source>You should rewrite your code to avoid these warnings if you are concerned about the fact that code generated by G++ may not be binary compatible with code generated by other compilers.</source>
          <target state="translated">G++で生成されたコードが他のコンパイラで生成されたコードとバイナリ互換性がないかもしれないという事実が気になる場合は、これらの警告を回避するためにコードを書き換えるべきです。</target>
        </trans-unit>
        <trans-unit id="3200321f5c777dbbacc4f9ef21ac598c37fa6c47" translate="yes" xml:space="preserve">
          <source>You typically use this function in an embedded application where memory is a critical resource. If you have some complex calculation, you may want it to be folded if it involves constants, but need to call a function if it does not. For example:</source>
          <target state="translated">この関数は通常、メモリが重要なリソースである組み込みアプリケーションで使用します。複雑な計算を行う場合、定数を含む場合は畳み込みたいが、定数を含まない場合は関数を呼び出す必要があるかもしれません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b1963db30d39d58a295ec397d230925d0854ee73" translate="yes" xml:space="preserve">
          <source>You typically use this function in code whose execution varies depending on the arguments&amp;rsquo; types. For example:</source>
          <target state="translated">通常、この関数は、引数の型によって実行が異なるコードで使用します。例えば：</target>
        </trans-unit>
        <trans-unit id="a382ebf878d522cc46ae079d7811d40f2d546d5e" translate="yes" xml:space="preserve">
          <source>You typically use this option to build a shared library dynamic loader. Itself a shared library, it must relocate itself in memory before it can find the variables and constants in its own data segment.</source>
          <target state="translated">通常、このオプションを使用して共有ライブラリ・ダイナミック・ローダを構築します。それ自身が共有ライブラリであるため、それ自身のデータセグメント内の変数や定数を見つける前に、それ自身をメモリ内で再配置しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ff2858040c7368b4f7687d2e4605dbe04fb48ce1" translate="yes" xml:space="preserve">
          <source>You use these options to specify which instructions are available on the processor you are using. The default value of these options is determined when configuring GCC. Specifying the</source>
          <target state="translated">これらのオプションを使用して、使用しているプロセッサで利用可能な命令を指定します。これらのオプションの既定値は、GCC の構成時に決定されます。を指定します。</target>
        </trans-unit>
        <trans-unit id="afc6c45769ec18ef9f8f79510ff88d4f56540059" translate="yes" xml:space="preserve">
          <source>Zero</source>
          <target state="translated">Zero</target>
        </trans-unit>
        <trans-unit id="553f12b0c01c796a9c01fbfbed6d38920ed5b259" translate="yes" xml:space="preserve">
          <source>Zero-length arrays.</source>
          <target state="translated">長さ0の配列。</target>
        </trans-unit>
        <trans-unit id="258478ec83495aa79136f18ffc9233ee1f0db5ed" translate="yes" xml:space="preserve">
          <source>Zero-length bit-fields following non-bit-field members are ignored:</source>
          <target state="translated">ビットフィールド以外のメンバーに続く長さゼロのビットフィールドは無視されます。</target>
        </trans-unit>
        <trans-unit id="0c2ceddaf3c2e5b315ce6df93a6d703e090097e2" translate="yes" xml:space="preserve">
          <source>[.A-Za-z]*</source>
          <target state="translated">[.A-Za-z]*</target>
        </trans-unit>
        <trans-unit id="abf3f56fd4893df51cec0f301e1d141ec4cf5a54" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;first&lt;/var&gt; ... &lt;var&gt;last&lt;/var&gt;] = &lt;var&gt;value&lt;/var&gt;</source>
          <target state="translated">[&lt;var&gt;first&lt;/var&gt; ... &lt;var&gt;last&lt;/var&gt;] = &lt;var&gt;value&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="893b2523426b47e65f5145303772e8166d192d46" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;index&lt;/var&gt;]</source>
          <target state="translated">[&lt;var&gt;index&lt;/var&gt;]</target>
        </trans-unit>
        <trans-unit id="96a90e0b102b000a44c98efbcdab9b6dee99bbd8" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;index&lt;/var&gt;] =</source>
          <target state="translated">[&lt;var&gt;index&lt;/var&gt;] =</target>
        </trans-unit>
        <trans-unit id="aaf8c573d70607ca295cc0cde78f8a6154aa6363" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;suffix&lt;/var&gt;] spec</source>
          <target state="translated">[&lt;var&gt;suffix&lt;/var&gt;] spec</target>
        </trans-unit>
        <trans-unit id="323d9668ca564c93e740198e5fd45fcacecbe669" translate="yes" xml:space="preserve">
          <source>[dir/]include</source>
          <target state="translated">[dir/]include</target>
        </trans-unit>
        <trans-unit id="14aee59b80f3ae18852c214fd35ef6a55a3b42a6" translate="yes" xml:space="preserve">
          <source>[dir/]stage&lt;var&gt;N&lt;/var&gt;/</source>
          <target state="translated">[dir/]stage&lt;var&gt;N&lt;/var&gt;/</target>
        </trans-unit>
        <trans-unit id="08534f33c201a45017b502e90a800f1b708ebcb3" translate="yes" xml:space="preserve">
          <source>\</source>
          <target state="translated">\</target>
        </trans-unit>
        <trans-unit id="ec24514fcd2c759e6e733c1219e798f6a27080dd" translate="yes" xml:space="preserve">
          <source>\,</source>
          <target state="translated">\,</target>
        </trans-unit>
        <trans-unit id="80bcc8b02cd875c9c7b9dc9e6159a6cd886a4b36" translate="yes" xml:space="preserve">
          <source>\e</source>
          <target state="translated">\e</target>
        </trans-unit>
        <trans-unit id="ef7e6794ca9c6a06b54b66f279237fb8daaaeea8" translate="yes" xml:space="preserve">
          <source>\n</source>
          <target state="translated">\n</target>
        </trans-unit>
        <trans-unit id="5260fdfe19fbab22b26fb10a5b1cdaa4e4d5fa1f" translate="yes" xml:space="preserve">
          <source>\n\t</source>
          <target state="translated">\n\t</target>
        </trans-unit>
        <trans-unit id="dd56ac3bfe32e89d0b9eada9071564fe17a96c3a" translate="yes" xml:space="preserve">
          <source>_&lt;var&gt;L&lt;/var&gt;</source>
          <target state="translated">_&lt;var&gt;L&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="f2b8017c21a3fa06728ebdd896c9f0840460e437" translate="yes" xml:space="preserve">
          <source>_&lt;var&gt;n&lt;/var&gt;</source>
          <target state="translated">_&lt;var&gt;n&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="bef0f1b1eda1a69cc6d7593689c6ad7764f8486b" translate="yes" xml:space="preserve">
          <source>_Complex double x;</source>
          <target state="translated">_Complex double x;</target>
        </trans-unit>
        <trans-unit id="be1a596019bc728455ca6e661ae186a03fbaf2a6" translate="yes" xml:space="preserve">
          <source>_Complex short int y;</source>
          <target state="translated">_Complex short int y;</target>
        </trans-unit>
        <trans-unit id="4efeab93d874226b7c2975a5130348c4a300a2cf" translate="yes" xml:space="preserve">
          <source>_MAX</source>
          <target state="translated">_MAX</target>
        </trans-unit>
        <trans-unit id="dde95929ec72357d1a78e9ef9086ad031a0699b2" translate="yes" xml:space="preserve">
          <source>_MIN</source>
          <target state="translated">_MIN</target>
        </trans-unit>
        <trans-unit id="9624af4051d439e5359b9152ec698ceaa0261659" translate="yes" xml:space="preserve">
          <source>__atomic</source>
          <target state="translated">__atomic</target>
        </trans-unit>
        <trans-unit id="011657d58155e0e3541069c651cbe40aace6f116" translate="yes" xml:space="preserve">
          <source>__atomic_thread_fence</source>
          <target state="translated">__atomic_thread_fence</target>
        </trans-unit>
        <trans-unit id="b5190ca2a20962ff5fe42fd3d915ec20ed74f142" translate="yes" xml:space="preserve">
          <source>__attribute__ ((aligned (16), packed))</source>
          <target state="translated">__attribute__ ((aligned (16), packed))</target>
        </trans-unit>
        <trans-unit id="9763de6eac5cd7741fca26ac575ae576079de73c" translate="yes" xml:space="preserve">
          <source>__builtin_</source>
          <target state="translated">__builtin_</target>
        </trans-unit>
        <trans-unit id="9ffdd3b639dbcc260c36604d951401b356ebdfa9" translate="yes" xml:space="preserve">
          <source>__builtin_frame_address</source>
          <target state="translated">__builtin_frame_address</target>
        </trans-unit>
        <trans-unit id="77d71c429ddc63ee19bd5fc63e5f0770c3745449" translate="yes" xml:space="preserve">
          <source>__builtin_return_address</source>
          <target state="translated">__builtin_return_address</target>
        </trans-unit>
        <trans-unit id="090f89da9d6d5b98fdd005c2ae6006ce69c1facf" translate="yes" xml:space="preserve">
          <source>__f</source>
          <target state="translated">__f</target>
        </trans-unit>
        <trans-unit id="3535355516b8a7449fdf619b53778778636b0eea" translate="yes" xml:space="preserve">
          <source>__int128</source>
          <target state="translated">__int128</target>
        </trans-unit>
        <trans-unit id="39a41d9f01352f9be126d019a0f55223b6f117ec" translate="yes" xml:space="preserve">
          <source>__sync</source>
          <target state="translated">__sync</target>
        </trans-unit>
        <trans-unit id="36fb58f934823421b6f9498810790aeee97de129" translate="yes" xml:space="preserve">
          <source>__v850*__</source>
          <target state="translated">__v850*__</target>
        </trans-unit>
        <trans-unit id="e748065bbc4c0e6c0efc4285894458b89aaf5dff" translate="yes" xml:space="preserve">
          <source>_flush_cache</source>
          <target state="translated">_flush_cache</target>
        </trans-unit>
        <trans-unit id="43bf149a9ed61bc94557723db25e4af7f39d8d75" translate="yes" xml:space="preserve">
          <source>_foo</source>
          <target state="translated">_foo</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="20276f54b2fb0d6340042fdc1e284afc48a41106" translate="yes" xml:space="preserve">
          <source>a hard limit, disallowing more than that number in an instruction group. Otherwise, the limit is &amp;ldquo;soft&amp;rdquo;, meaning that non-memory operations are preferred when the limit is reached, but memory operations may still be scheduled.</source>
          <target state="translated">命令グループではその数を超えることを許可しないハードリミット。それ以外の場合、制限は「ソフト」です。つまり、制限に達したときに非メモリ操作が優先されますが、メモリ操作は引き続きスケジュールされます。</target>
        </trans-unit>
        <trans-unit id="4d45fbf9e18e03187144f653f6c867ab6a4cb2ce" translate="yes" xml:space="preserve">
          <source>a signed doubleword</source>
          <target state="translated">符号付き二重語</target>
        </trans-unit>
        <trans-unit id="9efaa9ee2486d205847ff7f6eb2734e13064b3d6" translate="yes" xml:space="preserve">
          <source>a signed word</source>
          <target state="translated">書き言葉</target>
        </trans-unit>
        <trans-unit id="2e5e828ebf29441ab1d17abe9b59440764703bd5" translate="yes" xml:space="preserve">
          <source>a.c</source>
          <target state="translated">a.c</target>
        </trans-unit>
        <trans-unit id="2ef04052181a3bcb9eb40398327d275b7122b76b" translate="yes" xml:space="preserve">
          <source>a.c##x.h.gcov</source>
          <target state="translated">a.c##x.h.gcov</target>
        </trans-unit>
        <trans-unit id="937373b898e354572539c11778b8369b6021d02b" translate="yes" xml:space="preserve">
          <source>a.out</source>
          <target state="translated">a.out</target>
        </trans-unit>
        <trans-unit id="b9f85daa6f83cf02ce5c31913d1f64d3f5c8fade" translate="yes" xml:space="preserve">
          <source>a2</source>
          <target state="translated">a2</target>
        </trans-unit>
        <trans-unit id="62352d3d034a492b743d85067daad3ede5b2104b" translate="yes" xml:space="preserve">
          <source>aapcs</source>
          <target state="translated">aapcs</target>
        </trans-unit>
        <trans-unit id="cb76f70bd27803c92785136c45fbc376f9dd2652" translate="yes" xml:space="preserve">
          <source>aapcs-linux</source>
          <target state="translated">aapcs-linux</target>
        </trans-unit>
        <trans-unit id="973eb567623a16af6cc4b072efcf2388a12b9404" translate="yes" xml:space="preserve">
          <source>aarch64-*-*</source>
          <target state="translated">aarch64-*-*</target>
        </trans-unit>
        <trans-unit id="c10ebf10559ad9cfd389b344d22aa0551d5fd166" translate="yes" xml:space="preserve">
          <source>aarch64_be-*-*</source>
          <target state="translated">aarch64_be-*-*</target>
        </trans-unit>
        <trans-unit id="715a5d4d840064196cfa2f6763ef29067adb4d87" translate="yes" xml:space="preserve">
          <source>abi</source>
          <target state="translated">abi</target>
        </trans-unit>
        <trans-unit id="dcd67d1087e07b87a59bb90a9324a369479ccb75" translate="yes" xml:space="preserve">
          <source>abm</source>
          <target state="translated">abm</target>
        </trans-unit>
        <trans-unit id="f3bf4a18bc12d3fd665f34273aa77398ca033388" translate="yes" xml:space="preserve">
          <source>about invoking</source>
          <target state="translated">呼び出しについて</target>
        </trans-unit>
        <trans-unit id="de671ae4cf4c6f58efe6bf4db141ff43ea23375f" translate="yes" xml:space="preserve">
          <source>above). Currently, the following sets are defined:</source>
          <target state="translated">上記)のように定義されています。)現在、以下のセットが定義されています。</target>
        </trans-unit>
        <trans-unit id="614cd09c5357289d30936d7b18d4378a9149026f" translate="yes" xml:space="preserve">
          <source>above, generate Ada specs as child units of parent &lt;var&gt;unit&lt;/var&gt;.</source>
          <target state="translated">上記では、Ada仕様を親 &lt;var&gt;unit&lt;/var&gt; 子ユニットとして生成します。</target>
        </trans-unit>
        <trans-unit id="76726f07acaef7a675fe282314fc6d7f44669323" translate="yes" xml:space="preserve">
          <source>accidentally contains floating-point operations, it is likely to suffer a link-time or run-time failure.</source>
          <target state="translated">が誤って浮動小数点演算を含んでいる場合、リンクタイムやランタイムの障害が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="466afffe5fc6585663064937defed67d00d3e3b4" translate="yes" xml:space="preserve">
          <source>acml</source>
          <target state="translated">acml</target>
        </trans-unit>
        <trans-unit id="c662180230cad14787d4ab7e77aa08681ce783fa" translate="yes" xml:space="preserve">
          <source>address</source>
          <target state="translated">address</target>
        </trans-unit>
        <trans-unit id="798db27fb8836547e7eae5cbf51a015317e5a479" translate="yes" xml:space="preserve">
          <source>adds keywords &lt;code&gt;__vector&lt;/code&gt;, &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;__pixel&lt;/code&gt;, &lt;code&gt;pixel&lt;/code&gt;, &lt;code&gt;__bool&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt;. When compiling ISO C, the context-sensitive substitution of the keywords &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;pixel&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; is disabled. To use them, you must include &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">キーワード &lt;code&gt;__vector&lt;/code&gt; 、 &lt;code&gt;vector&lt;/code&gt; 、 &lt;code&gt;__pixel&lt;/code&gt; 、 &lt;code&gt;pixel&lt;/code&gt; 、 &lt;code&gt;__bool&lt;/code&gt; &lt;code&gt;bool&lt;/code&gt; およびboolを追加します。ISO Cをコンパイルするとき、キーワード &lt;code&gt;vector&lt;/code&gt; 、 &lt;code&gt;pixel&lt;/code&gt; 、および &lt;code&gt;bool&lt;/code&gt; の状況依存の置換は無効になります。それらを使用するには、代わりに &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; をインクルードする必要があります。</target>
        </trans-unit>
        <trans-unit id="6a4611cf85989cfb032315de1816f14ac9f3517b" translate="yes" xml:space="preserve">
          <source>adiw</source>
          <target state="translated">adiw</target>
        </trans-unit>
        <trans-unit id="70115ea66975f8392735da74af10a532c95caaf7" translate="yes" xml:space="preserve">
          <source>adx</source>
          <target state="translated">adx</target>
        </trans-unit>
        <trans-unit id="9b214a0fbc91794f9b2f7c03b2ffdadc705bb106" translate="yes" xml:space="preserve">
          <source>aes</source>
          <target state="translated">aes</target>
        </trans-unit>
        <trans-unit id="1ba7d6d2d5d6b99ecac4784439f26289cba856d4" translate="yes" xml:space="preserve">
          <source>align-stringops</source>
          <target state="translated">align-stringops</target>
        </trans-unit>
        <trans-unit id="3bea4606b8381d936b8f862d721bc4422652b565" translate="yes" xml:space="preserve">
          <source>aligned</source>
          <target state="translated">aligned</target>
        </trans-unit>
        <trans-unit id="a8d2e4967b2627fcbbcd7bab5490853d70874e12" translate="yes" xml:space="preserve">
          <source>aligns &lt;code&gt;long double&lt;/code&gt; to a 16-byte boundary by padding the &lt;code&gt;long double&lt;/code&gt; with an additional 32-bit zero.</source>
          <target state="translated">&lt;code&gt;long double&lt;/code&gt; に32ビットのゼロを追加して埋め込むことにより、 &lt;code&gt;long double&lt;/code&gt; を16バイト境界に揃えます。</target>
        </trans-unit>
        <trans-unit id="3efdc33c698275c6bba0bfe0a5cc4bb1ae2af995" translate="yes" xml:space="preserve">
          <source>aligns functions to the next 32-byte boundary,</source>
          <target state="translated">関数を次の32バイト境界に配置します。</target>
        </trans-unit>
        <trans-unit id="244280ce7bd1f8e5d39e22b8ef0ce1ca3d784e6f" translate="yes" xml:space="preserve">
          <source>aligns to the next 32-byte boundary only if this can be done by skipping 23 bytes or less,</source>
          <target state="translated">23バイト以下のバイトをスキップすることで可能な場合にのみ、次の32バイト境界に整列します。</target>
        </trans-unit>
        <trans-unit id="cfa7e3dfee8e7262fa433d58f986a5d3347143cb" translate="yes" xml:space="preserve">
          <source>aligns to the next 32-byte boundary only if this can be done by skipping 6 bytes or less.</source>
          <target state="translated">これが6バイト以下でスキップできる場合にのみ、次の32バイト境界に整列します。</target>
        </trans-unit>
        <trans-unit id="79635748432e8322454f167c344ee1a5dee023d5" translate="yes" xml:space="preserve">
          <source>aligns to the next 64-byte boundary if this can be done by skipping 6 bytes or less, otherwise aligns to the next 32-byte boundary if this can be done by skipping 2 bytes or less. If &lt;var&gt;m2&lt;/var&gt; is not specified, it defaults to &lt;var&gt;n2&lt;/var&gt;.</source>
          <target state="translated">6バイト以下のスキップで実行できる場合は、次の64バイト境界に整列します。2バイト以下のスキップで実行できる場合は、次の32バイト境界に整列します。 &lt;var&gt;m2&lt;/var&gt; が指定されていない場合、デフォルトで &lt;var&gt;n2&lt;/var&gt; になります。</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="a8901683ad5f4f61f902c68d29d69c8b1ad5d90d" translate="yes" xml:space="preserve">
          <source>all external symbols are resolved at load time.</source>
          <target state="translated">すべての外部シンボルはロード時に解決されます。</target>
        </trans-unit>
        <trans-unit id="bbe28b8276e31a373247e1c8a94a3beb37c5b6fa" translate="yes" xml:space="preserve">
          <source>all.h</source>
          <target state="translated">all.h</target>
        </trans-unit>
        <trans-unit id="3b0a792c2b1703577a069f12d469a0473536a471" translate="yes" xml:space="preserve">
          <source>all.h.gch</source>
          <target state="translated">all.h.gch</target>
        </trans-unit>
        <trans-unit id="b9bf38b9b4d225abc840bc0ee7480fcc2434e2b3" translate="yes" xml:space="preserve">
          <source>allclass.cc</source>
          <target state="translated">allclass.cc</target>
        </trans-unit>
        <trans-unit id="ca4599448f2501f9fa384de7b7038a3e242e0dfb" translate="yes" xml:space="preserve">
          <source>allocation of or sending messages to arbitrary objects;</source>
          <target state="translated">任意のオブジェクトへのメッセージの割り当てまたは送信。</target>
        </trans-unit>
        <trans-unit id="32b74672543fdbbdcfc868ba07acb1ff2110d200" translate="yes" xml:space="preserve">
          <source>allocation of or sending messages to objects whose classes have a category implemented in the same file;</source>
          <target state="translated">同じファイルにカテゴリが実装されているクラスを持つオブジェクトへのメッセージの割り当てまたは送信。</target>
        </trans-unit>
        <trans-unit id="453b7342a6d3f523c8d652e090720e4f47db0bd8" translate="yes" xml:space="preserve">
          <source>allow you to switch between producing output that works with the GNU Objective-C runtime library and output that works with the Apple/NeXT Objective-C runtime library.</source>
          <target state="translated">GNU Objective-C ランタイム・ライブラリで動作する出力と Apple/NeXT Objective-C ランタイム・ライブラリで動作する出力を切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="dd4aebec0f6653650ee91987b02de80dc8963201" translate="yes" xml:space="preserve">
          <source>allowing the user to call &lt;code&gt;memcpy&lt;/code&gt; as a regular function, unaware of the actual implementation. Finally, the indirect function needs to be defined in the same translation unit as the resolver function:</source>
          <target state="translated">実際の実装を意識せずに、ユーザーが &lt;code&gt;memcpy&lt;/code&gt; を通常の関数として呼び出せるようにします。最後に、間接関数はリゾルバー関数と同じ変換単位で定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="66438aaa4bea9ecc573f56890befc19245624f30" translate="yes" xml:space="preserve">
          <source>allows GCC to generate code that may not run at all on processors other than the one indicated. Specifying</source>
          <target state="translated">を使用すると、指定されたプロセッサ以外のプロセッサでは全く実行されないコードを GCC で生成することができます。指定されたプロセッサ以外のプロセッサでは</target>
        </trans-unit>
        <trans-unit id="cf49e111caf7da05b98404623112872b82a367f9" translate="yes" xml:space="preserve">
          <source>allows GCC to use the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root. Specifying</source>
          <target state="translated">は、浮動小数点平方根を含む汎用グループのオプションのPowerPCアーキテクチャ命令をGCCで使用できるようにします。を指定することができます。</target>
        </trans-unit>
        <trans-unit id="f5666aaba4ff4d9843997efb2fce32365976d352" translate="yes" xml:space="preserve">
          <source>allows GCC to use the optional PowerPC architecture instructions in the Graphics group, including floating-point select.</source>
          <target state="translated">GCCは、浮動小数点選択を含むグラフィックスグループのオプションのPowerPCアーキテクチャ命令を使用することができます。</target>
        </trans-unit>
        <trans-unit id="2abc9f7d66d3a1198b14bbaa01458338cdf813bd" translate="yes" xml:space="preserve">
          <source>allows some nonconforming code to compile.</source>
          <target state="translated">は、いくつかの不適合コードのコンパイルを可能にします。</target>
        </trans-unit>
        <trans-unit id="bedf43ad0a95e8d3ef4a98d57277220a9905abdc" translate="yes" xml:space="preserve">
          <source>along with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec221c0b71d49bdac9cb852917ed960c85ad0a8" translate="yes" xml:space="preserve">
          <source>also being enabled.</source>
          <target state="translated">も有効になっています。</target>
        </trans-unit>
        <trans-unit id="5fad31864ed398f45dae03d45460e898d7d29f7e" translate="yes" xml:space="preserve">
          <source>also being specified, the code is tuned to perform well across a range of target processors implementing the target architecture.</source>
          <target state="translated">また、指定されている場合は、ターゲット・アーキテクチャを実装したターゲット・プロセッサの範囲で良好に動作するようにコードが調整されています。</target>
        </trans-unit>
        <trans-unit id="8d6a07b9735308ca8e95431227809c536d7831ad" translate="yes" xml:space="preserve">
          <source>also by</source>
          <target state="translated">傍らに</target>
        </trans-unit>
        <trans-unit id="187a158ae4568f3cc3e2b692351e6276268ce95b" translate="yes" xml:space="preserve">
          <source>also checks for null format arguments for several functions,</source>
          <target state="translated">は、いくつかの関数のヌル形式の引数もチェックします。</target>
        </trans-unit>
        <trans-unit id="f587f4ff38f8c2cccf85ae4104732656fd8bb96d" translate="yes" xml:space="preserve">
          <source>also diagnoses cases where the attributes of the alias declaration are more restrictive than the attributes applied to its target. These mismatches can potentially result in incorrect code generation. In other cases they may be benign and could be resolved simply by adding the missing attribute to the target. For comparison, see the</source>
          <target state="translated">は、エイリアス宣言の属性がターゲットに適用される属性よりも制限的な場合も診断します。これらの不一致は、誤ったコード生成を引き起こす可能性があります。他のケースでは、これらの不一致は良性のものであり、単に欠けている属性をターゲットに追加するだけで解決することができます。比較のために</target>
        </trans-unit>
        <trans-unit id="cb860f8821c8635791611ff058e7157ab855da31" translate="yes" xml:space="preserve">
          <source>also implies</source>
          <target state="translated">も意味する</target>
        </trans-unit>
        <trans-unit id="6f42e4ce494f5b76f2544a0f03b983119cfbce78" translate="yes" xml:space="preserve">
          <source>also includes dependence info.</source>
          <target state="translated">依存関係の情報も含まれています。</target>
        </trans-unit>
        <trans-unit id="be3f59c6748c3a9b4a7ae21f5715d657a72eeb15" translate="yes" xml:space="preserve">
          <source>also prints warning messages for the following cases:</source>
          <target state="translated">また、以下の場合の警告メッセージも表示されます。</target>
        </trans-unit>
        <trans-unit id="2e5682119037273f933c083ad00d7701aba2cf5c" translate="yes" xml:space="preserve">
          <source>also provides equivalent macros called &lt;code&gt;_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; that can be used for programming ease and improved readability. The following macros for DMA control are also provided:</source>
          <target state="translated">また、プログラミングを容易にし、読みやすさを向上させるために使用できる &lt;code&gt;_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; と呼ばれる同等のマクロも提供します。DMA制御用の次のマクロも提供されています。</target>
        </trans-unit>
        <trans-unit id="f34eaf4f6ae89eb9588e134559245afad4e138e4" translate="yes" xml:space="preserve">
          <source>also sets</source>
          <target state="translated">もセットになっています。</target>
        </trans-unit>
        <trans-unit id="e117a2e5dfc7efe817347989346d6cd665ab904c" translate="yes" xml:space="preserve">
          <source>also suppresses preprocessed output, as a missing header file renders this useless.</source>
          <target state="translated">また、ヘッダファイルがない場合は、前処理された出力を抑制します。</target>
        </trans-unit>
        <trans-unit id="63a0640542d5918d3932396f482586803338d771" translate="yes" xml:space="preserve">
          <source>also takes into account control flow statements, such as ifs, and only warns when appropriate. E.g.</source>
          <target state="translated">また、ifなどの制御フロー文を考慮に入れ、適切な場合にのみ警告を行います。例えば</target>
        </trans-unit>
        <trans-unit id="30f35ed6e318ea969ed59edf47b9b26381d2be26" translate="yes" xml:space="preserve">
          <source>also warns about calls to bounded string copy functions like &lt;code&gt;strncat&lt;/code&gt; or &lt;code&gt;strncpy&lt;/code&gt; that specify as the bound a &lt;code&gt;sizeof&lt;/code&gt; expression of the source array. For example, in the following function the call to &lt;code&gt;strncat&lt;/code&gt; specifies the size of the source string as the bound. That is almost certainly a mistake and so the call is diagnosed.</source>
          <target state="translated">また、ソース配列の &lt;code&gt;sizeof&lt;/code&gt; 式をバインドとして指定する &lt;code&gt;strncat&lt;/code&gt; や &lt;code&gt;strncpy&lt;/code&gt; などのバインドされた文字列コピー関数の呼び出しについても警告します。たとえば、次の関数では、 &lt;code&gt;strncat&lt;/code&gt; の呼び出しでソース文字列のサイズをバインドとして指定しています。これはほぼ間違いなく間違いなので、通話は診断されます。</target>
        </trans-unit>
        <trans-unit id="4f244ab7b0dd86244a85d676a4e7e6a378a2f85e" translate="yes" xml:space="preserve">
          <source>also warns about class member allocation functions.</source>
          <target state="translated">また、クラスメンバの割り当て関数についても警告しています。</target>
        </trans-unit>
        <trans-unit id="b62db011fc5c4e0ddffda8c03fb7a1020abe09e6" translate="yes" xml:space="preserve">
          <source>also warns about this situation; this warning can be avoided by explicitly tagging the variable or function or moving it into a tagged inline namespace.</source>
          <target state="translated">この警告は、変数や関数を明示的にタグ付けするか、タグ付けされたインライン名前空間に移動することで回避できます。</target>
        </trans-unit>
        <trans-unit id="816d63e63c53fbbcdc73b605731fb850111597ab" translate="yes" xml:space="preserve">
          <source>alternative</source>
          <target state="translated">alternative</target>
        </trans-unit>
        <trans-unit id="cbcd5fa05a97da31161499a40e885c28da334f58" translate="yes" xml:space="preserve">
          <source>altivec</source>
          <target state="translated">altivec</target>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="a17ce9b6918e1f1ff5f858aa6106831fa7297c8c" translate="yes" xml:space="preserve">
          <source>always has a large stack. Support for this is implemented in the gold linker in GNU binutils release 2.21 and later.</source>
          <target state="translated">は常に大きなスタックを持っています。このサポートは GNU binutils リリース 2.21 以降の gold リンカに実装されています。</target>
        </trans-unit>
        <trans-unit id="80e7ce3e370a6dda4a9fb0810b8685ac34fc5708" translate="yes" xml:space="preserve">
          <source>always_inline</source>
          <target state="translated">always_inline</target>
        </trans-unit>
        <trans-unit id="8dbe12ece6858c4818dac43b3d526c9a1f59fee3" translate="yes" xml:space="preserve">
          <source>am33</source>
          <target state="translated">am33</target>
        </trans-unit>
        <trans-unit id="11b883c428dac39d27e1d63b6df041f0638d659b" translate="yes" xml:space="preserve">
          <source>am33-2</source>
          <target state="translated">am33-2</target>
        </trans-unit>
        <trans-unit id="534aa547f58efe57e7088bffcb38a66eaac8a75f" translate="yes" xml:space="preserve">
          <source>am34</source>
          <target state="translated">am34</target>
        </trans-unit>
        <trans-unit id="1ea0b794e1acd33fc0e733b79c72bf9252569c11" translate="yes" xml:space="preserve">
          <source>amd</source>
          <target state="translated">amd</target>
        </trans-unit>
        <trans-unit id="2395059e740ec74ddaadf44ba1fd6be5abeb4f3f" translate="yes" xml:space="preserve">
          <source>amd64</source>
          <target state="translated">amd64</target>
        </trans-unit>
        <trans-unit id="b35a515e5c6e1bbc58411f2be892a9ab16847ea8" translate="yes" xml:space="preserve">
          <source>amdfam10</source>
          <target state="translated">amdfam10</target>
        </trans-unit>
        <trans-unit id="3a6d03b94ef74592e176a5d5190e78a646119762" translate="yes" xml:space="preserve">
          <source>amdfam10h</source>
          <target state="translated">amdfam10h</target>
        </trans-unit>
        <trans-unit id="261cb5d6b8474d348d7cc4b9daa4299477e3581e" translate="yes" xml:space="preserve">
          <source>amdfam15h</source>
          <target state="translated">amdfam15h</target>
        </trans-unit>
        <trans-unit id="77c479bd3bd5a6e9817c756457f45b3383bfda8b" translate="yes" xml:space="preserve">
          <source>amdfam17h</source>
          <target state="translated">amdfam17h</target>
        </trans-unit>
        <trans-unit id="fd4a625a31a18d16fe04662ffe5a54c9d06947f3" translate="yes" xml:space="preserve">
          <source>an &lt;code&gt;enum&lt;/code&gt; is encoded exactly as the integer type that the compiler uses for it, which depends on the enumeration values. Often the compiler users &lt;code&gt;unsigned int&lt;/code&gt;, which is then encoded as &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 整数型と全く符号化される列挙値に依存し、そのためコンパイラ使用、その。多くの場合、コンパイラーは &lt;code&gt;unsigned int&lt;/code&gt; を使用し、それは次に &lt;code&gt;I&lt;/code&gt; としてエンコードされます。</target>
        </trans-unit>
        <trans-unit id="4a2ad1f0fd30a224aa1740e4739fe7eb9ee94f86" translate="yes" xml:space="preserve">
          <source>an ACC register number</source>
          <target state="translated">ACCレジスタ番号</target>
        </trans-unit>
        <trans-unit id="45bc278ac53a1060e69cab091ecac756552d2721" translate="yes" xml:space="preserve">
          <source>an IACC register number</source>
          <target state="translated">IACC レジスタ番号</target>
        </trans-unit>
        <trans-unit id="0666bd4cf85f6a8a3d638122033f89aff472392a" translate="yes" xml:space="preserve">
          <source>an integer constant</source>
          <target state="translated">整数定数</target>
        </trans-unit>
        <trans-unit id="6d3c084323cc6197a38855b1039213d1fa5e3a22" translate="yes" xml:space="preserve">
          <source>an unsigned doubleword</source>
          <target state="translated">符号なしダブルワード</target>
        </trans-unit>
        <trans-unit id="3657f24217b612273b00133ebb412d287de01a77" translate="yes" xml:space="preserve">
          <source>an unsigned halfword</source>
          <target state="translated">符号なしハーフワード</target>
        </trans-unit>
        <trans-unit id="1773204396a38972d97d6f1c14d98973abbaa970" translate="yes" xml:space="preserve">
          <source>an unsigned word</source>
          <target state="translated">無名語</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="70913d37024f402445c0df52a7fadf651367bc49" translate="yes" xml:space="preserve">
          <source>and &amp;ldquo;on&amp;rdquo; for</source>
          <target state="translated">そして「オン」</target>
        </trans-unit>
        <trans-unit id="16ef79c113045b4dd6e920ca55a6a62dad230d8e" translate="yes" xml:space="preserve">
          <source>and 2 for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8bd910160e77b35630d8e9ecd21b71ad3f3f1e" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;__attribute__ ((visibility(&quot;default&quot;)))&lt;/code&gt; instead of &lt;code&gt;__declspec(dllexport)&lt;/code&gt; you get almost identical semantics with identical syntax. This is a great boon to those working with cross-platform projects.</source>
          <target state="translated">および &lt;code&gt;__attribute__ ((visibility(&quot;default&quot;)))&lt;/code&gt; では、 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; の代わりに、同じ構文でほぼ同じセマンティクスが得られます。これは、クロスプラットフォームプロジェクトで作業する人にとって大きな恩恵です。</target>
        </trans-unit>
        <trans-unit id="ecd7bafc40d24575da004f86f8a90c2aaf8b6d10" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;gold&lt;/code&gt; is used as the linker plugin, &lt;code&gt;externally_visible&lt;/code&gt; attributes are automatically added to functions (not variable yet due to a current &lt;code&gt;gold&lt;/code&gt; issue) that are accessed outside of LTO objects according to resolution file produced by &lt;code&gt;gold&lt;/code&gt;. For other linkers that cannot generate resolution file, explicit &lt;code&gt;externally_visible&lt;/code&gt; attributes are still necessary.</source>
          <target state="translated">そして &lt;code&gt;gold&lt;/code&gt; リンカープラグインとして使用され、 &lt;code&gt;externally_visible&lt;/code&gt; 属性は自動的に（現在の変数はまだによるものではない機能に追加され &lt;code&gt;gold&lt;/code&gt; LTOの外側にアクセスしている問題は）によって生成される解像度ファイルに従ってオブジェクト &lt;code&gt;gold&lt;/code&gt; 。解決ファイルを生成できない他のリンカーの場合、明示的な &lt;code&gt;externally_visible&lt;/code&gt; 属性が引き続き必要です。</target>
        </trans-unit>
        <trans-unit id="bc057aa007baa6ea326398d0908a19dee419f14d" translate="yes" xml:space="preserve">
          <source>and CSE is often sufficient to obtain the same effect. However, that is not reliable in cases where the loop body is more complicated than a single basic block. It also does not work at all on some architectures due to restrictions in the CSE pass.</source>
          <target state="translated">とCSEで十分な場合が多く、同じ効果を得ることができます。しかし、ループ本体が単一の基本ブロックよりも複雑な場合には、それは信頼できません。また、CSEパスの制限により、一部のアーキテクチャでは全く機能しません。</target>
        </trans-unit>
        <trans-unit id="2d730a90936bf795bf3e3ee8f9ba908c353e4fdf" translate="yes" xml:space="preserve">
          <source>and PowerPC64 ELFv1 (big-endian) do not support inline PLT calls.</source>
          <target state="translated">および PowerPC64 ELFv1 (ビッグエンディアン)はインライン PLT 呼び出しをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="b187d89af0f244b0d50df4ccd6e399a3d2177284" translate="yes" xml:space="preserve">
          <source>and above).</source>
          <target state="translated">以上)であることを確認しました。</target>
        </trans-unit>
        <trans-unit id="540943c2bc2692326429df85dfa3348df4f1b753" translate="yes" xml:space="preserve">
          <source>and above). It warns about subscripts to arrays that are always out of bounds. This warning is enabled by</source>
          <target state="translated">およびそれ以上)。これは、常に範囲外の配列への添え字について警告します。この警告は</target>
        </trans-unit>
        <trans-unit id="3763092639f876f5583517a9d0eb30243e45a887" translate="yes" xml:space="preserve">
          <source>and above.</source>
          <target state="translated">と上に書いてあります。</target>
        </trans-unit>
        <trans-unit id="e116e2dfbcfa1008e272a76654ceabd0ae9dcd52" translate="yes" xml:space="preserve">
          <source>and above. For some sorts of source code the enhanced partial redundancy elimination optimization can run away, consuming all of the memory available on the host machine. This parameter sets a limit on the length of the sets that are computed, which prevents the runaway behavior. Setting a value of 0 for this parameter allows an unlimited set length.</source>
          <target state="translated">とそれ以上のバージョンでは、部分的な冗長性を排除するための最適化が必要です。一部のソース・コードでは、拡張された部分的冗長性除去最適化が暴走し、ホスト・マシンで使用可能なメモリをすべて消費することがあります。このパラメータでは、計算されるセットの長さに制限を設定し、暴走を防止します。このパラメータに 0 を設定すると、セットの長さに制限はありません。</target>
        </trans-unit>
        <trans-unit id="d4c36d2256d758a63a43d0d687d1ad18856d0f48" translate="yes" xml:space="preserve">
          <source>and above. It is included in</source>
          <target state="translated">と上に書いてあります。に含まれています。</target>
        </trans-unit>
        <trans-unit id="8ca6f8b65a307f3565d2bdeac5195f1e6675246e" translate="yes" xml:space="preserve">
          <source>and above. It works in tandem with the</source>
          <target state="translated">と上に書いてあります。と連動して動作します。</target>
        </trans-unit>
        <trans-unit id="196478f2d301e69e64852ded07da61f6a1994c32" translate="yes" xml:space="preserve">
          <source>and above. The flag</source>
          <target state="translated">と上に書いてあります。旗の</target>
        </trans-unit>
        <trans-unit id="16cca3a59f077ac790f119f67104a42b8a0ffc3d" translate="yes" xml:space="preserve">
          <source>and accordingly for the postamble of the epilogue &amp;mdash; no matter whether the mentioned registers are actually used in the ISR or not. Situations where you might want to use this attribute include:</source>
          <target state="translated">したがって、エピローグのポストアンブルについては、前述のレジスタがISRで実際に使用されているかどうかに関係なく。この属性を使用する可能性のある状況は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0cba2aa225bdda89770493d09134f7ac4e9d6a51" translate="yes" xml:space="preserve">
          <source>and all C files starting with &amp;rsquo;module&amp;rsquo;.</source>
          <target state="translated">'module'で始まるすべてのCファイル。</target>
        </trans-unit>
        <trans-unit id="bab3e293e424c711fb965241b4ac9719742de334" translate="yes" xml:space="preserve">
          <source>and all the</source>
          <target state="translated">とすべての</target>
        </trans-unit>
        <trans-unit id="c05c88d23f63de9b36f3b812e4c3b3636aa4477a" translate="yes" xml:space="preserve">
          <source>and also turns on the following optimization flags:</source>
          <target state="translated">また、以下の最適化フラグもオンにします。</target>
        </trans-unit>
        <trans-unit id="2ebde484284695bea6e3641a94d76fb9524875f9" translate="yes" xml:space="preserve">
          <source>and another with</source>
          <target state="translated">ともう一つの</target>
        </trans-unit>
        <trans-unit id="a66594753907e18391761122d0c6251f7905b621" translate="yes" xml:space="preserve">
          <source>and another with the default options. GCC must be configured to use GLIBC 2.23 or newer in order to use the &lt;code&gt;target_clones&lt;/code&gt; attribute.</source>
          <target state="translated">もう1つはデフォルトのオプションです。 &lt;code&gt;target_clones&lt;/code&gt; 属性を使用するには、GCCがGLIBC 2.23以降を使用するように設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="be06f33f42d5fdd847c8ef1a054178ef64e8d724" translate="yes" xml:space="preserve">
          <source>and by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd91aa685e568528bf96de5c3a56f0d28ba7fac2" translate="yes" xml:space="preserve">
          <source>and by default a cost model defined with</source>
          <target state="translated">で定義されたコストモデルで、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="b58b6b69e9a6e2dffafda6e336f4d4562a450054" translate="yes" xml:space="preserve">
          <source>and code compiled with</source>
          <target state="translated">でコンパイルされたコードと</target>
        </trans-unit>
        <trans-unit id="5f781abb49c37ac3e1988d7f276013bdf87a40b0" translate="yes" xml:space="preserve">
          <source>and either</source>
          <target state="translated">とどちらかの</target>
        </trans-unit>
        <trans-unit id="db999ebc24b4a98f48dfa65e6948013de37b01d1" translate="yes" xml:space="preserve">
          <source>and emitting the result direct to stdout via</source>
          <target state="translated">を経由して標準出力に直接出力します。</target>
        </trans-unit>
        <trans-unit id="1769c9699ef4ab291d81bfc70d0f12e25b85fd42" translate="yes" xml:space="preserve">
          <source>and export those classes that are intended to be externally visible. Unfortunately it is possible for code to rely, perhaps accidentally, on the Visual Studio behavior.</source>
          <target state="translated">を使用して、外部から見えるように意図されたクラスをエクスポートします。残念ながら、コードが誤って Visual Studio の動作に依存してしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="36b302c13ab3c153e6cac498496443414d3fce07" translate="yes" xml:space="preserve">
          <source>and finally</source>
          <target state="translated">そして最後に</target>
        </trans-unit>
        <trans-unit id="8b3b299fce213f2a1e237365ea4fcb9e5607c1e3" translate="yes" xml:space="preserve">
          <source>and higher and depends on</source>
          <target state="translated">に依存しています。</target>
        </trans-unit>
        <trans-unit id="d3ee9cb1836394c3283e4bf670015859583e15fc" translate="yes" xml:space="preserve">
          <source>and higher as well as</source>
          <target state="translated">とより高いだけでなく</target>
        </trans-unit>
        <trans-unit id="5a9bec14cd65cb6407309dcf8b220e22883b3c85" translate="yes" xml:space="preserve">
          <source>and higher if</source>
          <target state="translated">より高い場合は</target>
        </trans-unit>
        <trans-unit id="bcbf9cf724baaa2c05cb8d8ef447ba9db9b1d32e" translate="yes" xml:space="preserve">
          <source>and higher on architectures that support this.</source>
          <target state="translated">これをサポートしているアーキテクチャでは</target>
        </trans-unit>
        <trans-unit id="5652f51541248dfcd407bf27224a828b6323954d" translate="yes" xml:space="preserve">
          <source>and higher,</source>
          <target state="translated">と高くなっています。</target>
        </trans-unit>
        <trans-unit id="20df9f0858c9d558bdf3ec73ab7b30c8be3693c7" translate="yes" xml:space="preserve">
          <source>and higher, and also at</source>
          <target state="translated">とそれ以上に、また</target>
        </trans-unit>
        <trans-unit id="d997e6f0b5d9397ce43f624b10d7171a88e8eab8" translate="yes" xml:space="preserve">
          <source>and higher, except for</source>
          <target state="translated">とそれ以上のものを除いて</target>
        </trans-unit>
        <trans-unit id="de9609e65fe8304aa2b84c02990d0ddd0b347ca8" translate="yes" xml:space="preserve">
          <source>and higher.</source>
          <target state="translated">と高くなっています。</target>
        </trans-unit>
        <trans-unit id="4822df6fd07924d846e61249bdf13788d9ead31a" translate="yes" xml:space="preserve">
          <source>and higher. Higher optimization levels improve the accuracy of the analysis.</source>
          <target state="translated">とより高いレベルになります。最適化レベルが高いほど解析の精度が向上します。</target>
        </trans-unit>
        <trans-unit id="afc0a14fb13d8311f68301c0ecd98042f1e9800d" translate="yes" xml:space="preserve">
          <source>and higher. It is not enabled for</source>
          <target state="translated">とそれ以上になります。には有効ではありません。</target>
        </trans-unit>
        <trans-unit id="a76fab721d9a45aaff56d37fa7059d4d07c6bf05" translate="yes" xml:space="preserve">
          <source>and higher. Null pointer check elimination is only done if</source>
          <target state="translated">とそれ以上の場合に使用します。ヌルポインタチェックの排除は、以下の場合にのみ行われます。</target>
        </trans-unit>
        <trans-unit id="17f12a1567309243f3153a113c5c9b0dc8b04f9a" translate="yes" xml:space="preserve">
          <source>and higher. The compilation time in this pass can be limited using</source>
          <target state="translated">とそれ以上になります。このパスのコンパイル時間は</target>
        </trans-unit>
        <trans-unit id="1352c6defb413a9629f8a883262aafbdf1d73c3e" translate="yes" xml:space="preserve">
          <source>and if the variable arguments are omitted or empty, the &amp;lsquo;</source>
          <target state="translated">変数の引数が省略されているか空の場合、 '</target>
        </trans-unit>
        <trans-unit id="97253136342a86d551cb8f938043a04fa09b8e17" translate="yes" xml:space="preserve">
          <source>and in the</source>
          <target state="translated">と、その中で</target>
        </trans-unit>
        <trans-unit id="71e7f852efd77608e67d67f4769c27771f643624" translate="yes" xml:space="preserve">
          <source>and in the cases of</source>
          <target state="translated">の場合と</target>
        </trans-unit>
        <trans-unit id="8e1a25c4625f2b80697437af8a97194c0476ac2c" translate="yes" xml:space="preserve">
          <source>and introduces new signatures for user-defined literals:</source>
          <target state="translated">と、ユーザー定義リテラルのための新しいシグネチャを導入しました。</target>
        </trans-unit>
        <trans-unit id="4a1b1d4b275aa98ab0a4a65283ca64d508b23283" translate="yes" xml:space="preserve">
          <source>and is defined for compatibility with Diab.</source>
          <target state="translated">とDiabとの互換性のために定義されています。</target>
        </trans-unit>
        <trans-unit id="b6b1e55ec15f2cb25e78716d325961ca33806bb5" translate="yes" xml:space="preserve">
          <source>and is deprecated.</source>
          <target state="translated">は非推奨です。</target>
        </trans-unit>
        <trans-unit id="9c32e4dd09aae4d64ecbad3933f8c85c732ca5ff" translate="yes" xml:space="preserve">
          <source>and is enabled by</source>
          <target state="translated">で有効になります。</target>
        </trans-unit>
        <trans-unit id="60f868f3a7c169f71793f02a83a16555d3150a50" translate="yes" xml:space="preserve">
          <source>and is enabled by default in C99 and C++11 modes (and newer). This warning level does not warn about left-shifting 1 into the sign bit. (However, in C, such an overflow is still rejected in contexts where an integer constant expression is required.) No warning is emitted in C++2A mode (and newer), as signed left shifts always wrap.</source>
          <target state="translated">この警告レベルは、C99 および C++11 モード (およびそれ以降)ではデフォルトで有効になっています。この警告レベルは、1 を符号ビットに左シフトしても警告しません。(ただし、C では、整数定数式が必要なコンテキストでは、このようなオーバーフローは依然として拒否されます)。C++2A モード (およびそれ以降)では、符号付き左シフトは常に折り返されるため、警告は発生しません。</target>
        </trans-unit>
        <trans-unit id="18a6194526a99bc8a75aa2625ef50b249a3cc54a" translate="yes" xml:space="preserve">
          <source>and is ignored at link time.</source>
          <target state="translated">であり、リンク時には無視されます。</target>
        </trans-unit>
        <trans-unit id="8cdd0a931822d69709608b564b7f6b552ac906b1" translate="yes" xml:space="preserve">
          <source>and its related options. Both absolute and relative paths can be used. By default, GCC uses the current directory as &lt;var&gt;path&lt;/var&gt;, thus the profile data file appears in the same directory as the object file. In order to prevent the file name clashing, if the object file name is not an absolute path, we mangle the absolute path of the</source>
          <target state="translated">およびその関連オプション。絶対パスと相対パスの両方を使用できます。デフォルトでは、GCCは現在のディレクトリを &lt;var&gt;path&lt;/var&gt; として使用するため、プロファイルデータファイルはオブジェクトファイルと同じディレクトリに表示されます。ファイル名の衝突を防ぐために、オブジェクトファイル名が絶対パスでない場合は、</target>
        </trans-unit>
        <trans-unit id="8aaeb495a9e5b482acebee2f5a8a0a37a7e8745c" translate="yes" xml:space="preserve">
          <source>and joined by spaces. This list is intended to be passed to the LTO linker plugin.</source>
          <target state="translated">とスペースで結合されています。このリストは、LTO リンカープラグインに渡されることを意図しています。</target>
        </trans-unit>
        <trans-unit id="c7acf5a5b05ac0929c1671052424680580734fbc" translate="yes" xml:space="preserve">
          <source>and let the driver handle the options instead.</source>
          <target state="translated">で、代わりにドライバがオプションを処理するようにします。</target>
        </trans-unit>
        <trans-unit id="bfccb2c5c250efe79e7d9930697e9b24c391e2ac" translate="yes" xml:space="preserve">
          <source>and libraries in</source>
          <target state="translated">と図書館の</target>
        </trans-unit>
        <trans-unit id="f0e01a5c55ee31dbcc71234d1f7dd13b04392356" translate="yes" xml:space="preserve">
          <source>and must be explicitly requested since in C++ this isn&amp;rsquo;t an error and in C it might be harder to clean up all headers included.</source>
          <target state="translated">C ++ではエラーではなく、Cでは含まれているすべてのヘッダーをクリーンアップするのが難しいため、明示的に要求する必要があります。</target>
        </trans-unit>
        <trans-unit id="c8b774402ab6984eabd550c359a10ea00ca9ffbe" translate="yes" xml:space="preserve">
          <source>and optimization options should be specified at compile time and during the final link. It is recommended that you compile all the files participating in the same link with the same options and also specify those options at link time. For example:</source>
          <target state="translated">と最適化オプションは、コンパイル時と最終リンク時に指定する必要があります。同じリンクに参加するすべてのファイルを同じオプションでコンパイルし、リンク時にそれらのオプションを指定することをお勧めします。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c7904d214a56c9420eebba683732a4bd59f75475" translate="yes" xml:space="preserve">
          <source>and other options cause warnings for many GNU C extensions. You can prevent such warnings within one expression by writing &lt;code&gt;__extension__&lt;/code&gt; before the expression. &lt;code&gt;__extension__&lt;/code&gt; has no effect aside from this.</source>
          <target state="translated">その他のオプションは、多くのGNU C拡張に対して警告を引き起こします。式の前に &lt;code&gt;__extension__&lt;/code&gt; を記述することにより、1つの式内でこのような警告を防ぐことができます。これ以外に &lt;code&gt;__extension__&lt;/code&gt; は効果がありません。</target>
        </trans-unit>
        <trans-unit id="737b71e6d8426b3fda4249cd8c1165da4988f20d" translate="yes" xml:space="preserve">
          <source>and outputs the command-line option</source>
          <target state="translated">を出力し、コマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="4a51075a2d63bdd9c031332e64282ebb86738b8f" translate="yes" xml:space="preserve">
          <source>and passes them on to the running GCC to make them part of the aggregated GIMPLE image to be optimized.</source>
          <target state="translated">の集合画像の一部として最適化されます。</target>
        </trans-unit>
        <trans-unit id="b7483c73e6a38e6274495270d12341498eeacbbb" translate="yes" xml:space="preserve">
          <source>and prevents linking with the shared libraries. On other systems, this option has no effect.</source>
          <target state="translated">を使用して、共有ライブラリとのリンクを防止します。他のシステムでは、このオプションは何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="123217ee99d19efe020f3f3466fda26930ff804c" translate="yes" xml:space="preserve">
          <source>and remove the</source>
          <target state="translated">を削除してください。</target>
        </trans-unit>
        <trans-unit id="d0ba1984262756dc3e97eba7054a343cd95b906e" translate="yes" xml:space="preserve">
          <source>and sets the start address of the program to 0x800.</source>
          <target state="translated">を設定し、プログラムの開始アドレスを 0x800 に設定します。</target>
        </trans-unit>
        <trans-unit id="ca533d5e239b86c5bce8e5223c75d9799ce24658" translate="yes" xml:space="preserve">
          <source>and so on. Most of these have both positive and negative forms; the negative form of</source>
          <target state="translated">といったようなものがあります。これらのほとんどは、正の形と負の形の両方を持っており、負の形の</target>
        </trans-unit>
        <trans-unit id="8448c2525daee3e2e6799cb7b66fc64c9ee09e88" translate="yes" xml:space="preserve">
          <source>and that the standard C libraries are</source>
          <target state="translated">と、標準のCライブラリが</target>
        </trans-unit>
        <trans-unit id="673968187c298fea9b969fc56a05d8e49cf79c7d" translate="yes" xml:space="preserve">
          <source>and the Fortran-specific</source>
          <target state="translated">とFortran固有の</target>
        </trans-unit>
        <trans-unit id="584bb0d053da62487d41fcb63d90a5569011ef09" translate="yes" xml:space="preserve">
          <source>and the application be linked with</source>
          <target state="translated">とアプリケーションがリンクされています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
