<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="2f76b920d411b7e136fa4f9061e5e0a37ad6c0c4" translate="yes" xml:space="preserve">
          <source>For example, since the declaration of the primary function template below makes use of both attribute &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;alloc_size&lt;/code&gt; the declaration of the explicit specialization of the template is diagnosed because it is missing one of the attributes.</source>
          <target state="translated">たとえば、以下のプライマリ関数テンプレートの宣言は属性 &lt;code&gt;malloc&lt;/code&gt; と &lt;code&gt;alloc_size&lt;/code&gt; の両方を使用するため、テンプレートの明示的な特殊化の宣言は、属性の1つが欠落しているために診断されます。</target>
        </trans-unit>
        <trans-unit id="c1b19cb164dc1a4ab8a759ac490b8fde220e9c5e" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;struct A&lt;/code&gt; below is defined in some third party library header to have the alignment requirement &lt;code&gt;N&lt;/code&gt; and to force a warning whenever a variable of the type is not so aligned due to attribute &lt;code&gt;packed&lt;/code&gt;. Specifying the &lt;code&gt;copy&lt;/code&gt; attribute on the definition on the unrelated &lt;code&gt;struct B&lt;/code&gt; has the effect of copying all relevant attributes from the type referenced by the pointer expression to &lt;code&gt;struct B&lt;/code&gt;.</source>
          <target state="translated">たとえば、以下の &lt;code&gt;struct A&lt;/code&gt; が、サードパーティのライブラリヘッダーで整列要件 &lt;code&gt;N&lt;/code&gt; を持ち、タイプの変数が属性が &lt;code&gt;packed&lt;/code&gt; いるために整列されない場合は常に警告を出すように定義されているとします。無関係な &lt;code&gt;struct B&lt;/code&gt; 定義に &lt;code&gt;copy&lt;/code&gt; 属性を指定すると、ポインター式によって参照される型から &lt;code&gt;struct B&lt;/code&gt; すべての関連属性がコピーされます。</target>
        </trans-unit>
        <trans-unit id="f0be048f3761817dd96f745d3c57100422574646" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sprintf&lt;/code&gt; function on SunOS 4.1.3 returns &lt;code&gt;char *&lt;/code&gt; while the C standard says that &lt;code&gt;sprintf&lt;/code&gt; returns an &lt;code&gt;int&lt;/code&gt;. The &lt;code&gt;fixincludes&lt;/code&gt; program could make the prototype for this function match the Standard, but that would be wrong, since the function will still return &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">たとえば、SunOS 4.1.3の &lt;code&gt;sprintf&lt;/code&gt; 関数は &lt;code&gt;char *&lt;/code&gt; を返しますが、C標準では &lt;code&gt;sprintf&lt;/code&gt; は &lt;code&gt;int&lt;/code&gt; を返すとしています。 &lt;code&gt;fixincludes&lt;/code&gt; のプログラムでは、この関数のプロトタイプは、標準に一致させることができますが、機能はまだ返されますので、それは、間違っているだろう &lt;code&gt;char *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd82a792fa22143d94897d2b758fc399175bbe0e" translate="yes" xml:space="preserve">
          <source>For example, the &lt;var&gt;StrongAlias&lt;/var&gt; macro below makes use of the &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;copy&lt;/code&gt; attributes to define an alias named &lt;var&gt;alloc&lt;/var&gt; for function &lt;var&gt;allocate&lt;/var&gt; declared with attributes &lt;var&gt;alloc_size&lt;/var&gt;, &lt;var&gt;malloc&lt;/var&gt;, and &lt;var&gt;nothrow&lt;/var&gt;. Thanks to the &lt;code&gt;__typeof__&lt;/code&gt; operator the alias has the same type as the target function. As a result of the &lt;code&gt;copy&lt;/code&gt; attribute the alias also shares the same attributes as the target.</source>
          <target state="translated">例えば、 &lt;var&gt;StrongAlias&lt;/var&gt; なります以下のマクロは、の使用 &lt;code&gt;alias&lt;/code&gt; と &lt;code&gt;copy&lt;/code&gt; という別名を定義する属性を &lt;var&gt;alloc&lt;/var&gt; 機能については、 &lt;var&gt;allocate&lt;/var&gt; 属性で宣言を &lt;var&gt;alloc_size&lt;/var&gt; 、 &lt;var&gt;malloc&lt;/var&gt; 関数、および &lt;var&gt;nothrow&lt;/var&gt; 。 &lt;code&gt;__typeof__&lt;/code&gt; 演算子のおかげで、エイリアスはターゲット関数と同じ型になります。 &lt;code&gt;copy&lt;/code&gt; 属性の結果として、エイリアスはターゲットと同じ属性も共有します。</target>
        </trans-unit>
        <trans-unit id="5df659eda3281e74be2356574e1b1c1a2ec73bd0" translate="yes" xml:space="preserve">
          <source>For example, the call to &lt;code&gt;memset&lt;/code&gt; below is diagnosed by the warning because the function expects a value of type &lt;code&gt;size_t&lt;/code&gt; as its argument but the type of &lt;code&gt;32&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;. With</source>
          <target state="translated">たとえば、以下の &lt;code&gt;memset&lt;/code&gt; への呼び出しは、関数が &lt;code&gt;size_t&lt;/code&gt; 型の値を引数として想定しているが、 &lt;code&gt;32&lt;/code&gt; 型は &lt;code&gt;int&lt;/code&gt; であるため、警告によって診断されます。と</target>
        </trans-unit>
        <trans-unit id="aa585d900b6a1decabca1b2daabff17e2775d789" translate="yes" xml:space="preserve">
          <source>For example, the compiler can only unconditionally vectorize the following loop with the pragma:</source>
          <target state="translated">例えば、コンパイラは次のループを無条件にベクトル化することができるのは、プラグマを使用した場合のみです。</target>
        </trans-unit>
        <trans-unit id="99f069ed5ba8ea293548f32b787eaedf45bdbd11" translate="yes" xml:space="preserve">
          <source>For example, the declaration:</source>
          <target state="translated">例えば、宣言。</target>
        </trans-unit>
        <trans-unit id="b9ea9d42bbb55f00657375149871784a78c15592" translate="yes" xml:space="preserve">
          <source>For example, the following function allocates eight objects of &lt;code&gt;n&lt;/code&gt; bytes each on the stack, storing a pointer to each in consecutive elements of the array &lt;code&gt;a&lt;/code&gt;. It then passes the array to function &lt;code&gt;g&lt;/code&gt; which can safely use the storage pointed to by each of the array elements.</source>
          <target state="translated">たとえば、次の関数は、それぞれ &lt;code&gt;n&lt;/code&gt; バイトの8つのオブジェクトをスタックに割り当て、それぞれへのポインターを配列 &lt;code&gt;a&lt;/code&gt; の連続する要素に格納します。次に、配列を関数 &lt;code&gt;g&lt;/code&gt; に渡します。関数gは、各配列要素が指すストレージを安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="46ff8877e2ba5b3ad38e512c93a9f9393792e49a" translate="yes" xml:space="preserve">
          <source>For example, the following macro can be used to portably check, at compile-time, whether or not adding two constant integers will overflow, and perform the addition only when it is known to be safe and not to trigger a</source>
          <target state="translated">例えば、以下のマクロを使用すると、コンパイル時に 2 つの定数整数の加算がオーバーフローするかどうかを可搬的にチェックし、安全であり</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="translated">例えば、以下のようなものです。</target>
        </trans-unit>
        <trans-unit id="f3e3332c2d5e42f3076c20bce36d2593f9127ee9" translate="yes" xml:space="preserve">
          <source>For example, the implementation of the following function &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">たとえば、次の関数 &lt;code&gt;foo&lt;/code&gt; の実装です。</target>
        </trans-unit>
        <trans-unit id="71a4e8c7eb0a1fa15ef7a86f7ffb6699626c80d0" translate="yes" xml:space="preserve">
          <source>For example, this function has to be used in &lt;code&gt;ifunc&lt;/code&gt; resolvers that check for CPU type using the built-in functions &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, or in constructors on targets that don&amp;rsquo;t support constructor priority.</source>
          <target state="translated">たとえば、この関数は、組み込み関数 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; および &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; を使用してCPUタイプをチェックする &lt;code&gt;ifunc&lt;/code&gt; リゾルバー、またはコンストラクターの優先度をサポートしないターゲットのコンストラクターで使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="1dddf36660113e27ff669ff510c160e144321d93" translate="yes" xml:space="preserve">
          <source>For example, when the compiler encounters a method invocation such as &lt;code&gt;[object init]&lt;/code&gt;, it compiles it into a call to &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; followed by a cast of the returned value to the appropriate function pointer type, and then it calls it.</source>
          <target state="translated">たとえば、コンパイラは &lt;code&gt;[object init]&lt;/code&gt; などのメソッド呼び出しを &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; すると、それをobjc_msg_lookup（object、@selector（init））への呼び出しにコンパイルし、その後に戻り値を適切な関数ポインタ型にキャストします。次にそれを呼び出します。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="25bb7aced1792aec854f4198d7d0398ca1d4713d" translate="yes" xml:space="preserve">
          <source>For full documentation of the struct attributes please see the documentation in &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">struct属性の完全なドキュメントについては、&lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86変数属性の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="3dc81c80b4604ccbc276f437a5ccc2aaa2515f6c" translate="yes" xml:space="preserve">
          <source>For indirect calls to functions and computed goto, the linker generates &lt;em&gt;stubs&lt;/em&gt;. Stubs are jump pads sometimes also called &lt;em&gt;trampolines&lt;/em&gt;. Thus, the indirect call/jump jumps to such a stub. The stub contains a direct jump to the desired address.</source>
          <target state="translated">関数と計算されたgotoへの間接呼び出しの場合、リンカは&lt;em&gt;スタブを&lt;/em&gt;生成します。スタブは、&lt;em&gt;トランポリン&lt;/em&gt;とも呼ばれるジャンプパッドです。したがって、間接呼び出し/ジャンプはそのようなスタブにジャンプします。スタブには、目的のアドレスへの直接ジャンプが含まれています。</target>
        </trans-unit>
        <trans-unit id="b91d6fa4ba31d00f68a512834bc7eb5f8c52df71" translate="yes" xml:space="preserve">
          <source>For information about the O64 ABI, see &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt;.</source>
          <target state="translated">O64 ABIについては、http://gcc.gnu.org/projects/mipso64-abi.htmlを参照して&lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56ee49f1a1b16838ed8d136422788b22655be9ea" translate="yes" xml:space="preserve">
          <source>For input files in any language, generate corresponding Go declarations in &lt;var&gt;file&lt;/var&gt;. This generates Go &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, and &lt;code&gt;func&lt;/code&gt; declarations which may be a useful way to start writing a Go interface to code written in some other language.</source>
          <target state="translated">任意の言語の入力ファイルの場合、対応するGo宣言を &lt;var&gt;file&lt;/var&gt; に生成します。これにより、Go &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;type&lt;/code&gt; 、 &lt;code&gt;var&lt;/code&gt; 、および &lt;code&gt;func&lt;/code&gt; 宣言が生成されます。これらの宣言は、他の言語で記述されたコードへのGoインターフェースの記述を開始するのに役立つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="c8ce6c094048677a9f8423fec4581d4ef1bd1e5b" translate="yes" xml:space="preserve">
          <source>For instance</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="a8e07e43db118dd56bbb97b1f96ccc89bac7f5fd" translate="yes" xml:space="preserve">
          <source>For instance, if the stack starts at absolute address &amp;lsquo;</source>
          <target state="translated">たとえば、スタックが絶対アドレスで始まる場合 '</target>
        </trans-unit>
        <trans-unit id="6abfd7e7f05346e1123b7bf2021cc93c61b8fbd5" translate="yes" xml:space="preserve">
          <source>For instance, if you have &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt;, and you have</source>
          <target state="translated">たとえば、 &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt; があり、</target>
        </trans-unit>
        <trans-unit id="5b9b6fe2256c52fcd89c847ec80034c7cbe3d49d" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could compile a function with &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt;. GCC creates two function clones, one compiled with</source>
          <target state="translated">たとえば、x86では、 &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt; を使用して関数をコンパイルできます。GCCは2つの関数クローンを作成し、1つは</target>
        </trans-unit>
        <trans-unit id="175bbce2fc22d4ed1ec7614154a0e449231ccaf1" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could declare one function with the &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; attribute and another with &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt;. This is equivalent to compiling the first function with</source>
          <target state="translated">例えば、x86の上で、あなたが一つの関数を宣言することができ &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; 属性として、別の &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt; 。これは、最初の関数を</target>
        </trans-unit>
        <trans-unit id="60600b26a9fa03b6c3650e82a7d4514147301ef9" translate="yes" xml:space="preserve">
          <source>For instance, on the SB-1, if FP exceptions are disabled, and we are emitting 64-bit code, then we can use both FP pipes. Otherwise, we can only use one FP pipe.</source>
          <target state="translated">例えば、SB-1でFP例外が無効になっていて、64ビットのコードを出力している場合、両方のFPパイプを使うことができます。そうでない場合は、1本のFPパイプしか使えません。</target>
        </trans-unit>
        <trans-unit id="4d64dcd6f25c2f8e61dbb8fbe7c56bdb2499ab6d" translate="yes" xml:space="preserve">
          <source>For instance, the following declarations</source>
          <target state="translated">例えば、次のような宣言があります。</target>
        </trans-unit>
        <trans-unit id="fd17d596f35be2211443642e76ceab4e5f526b5c" translate="yes" xml:space="preserve">
          <source>For internal names, all characters are significant. For external names, the number of significant characters are defined by the linker; for almost all targets, all characters are significant.</source>
          <target state="translated">内部名の場合は、すべての文字が有効です。外部の名前の場合、有効な文字の数はリンカによって定義されます。</target>
        </trans-unit>
        <trans-unit id="9f99386843936f29083f4368b21c1771def8a251" translate="yes" xml:space="preserve">
          <source>For library code, if you want the library to provide all of the template instantiations it needs, just try to link all of its object files together; the link will fail, but cause the instantiations to be generated as a side effect. Be warned, however, that this may cause conflicts if multiple libraries try to provide the same instantiations. For greater control, use explicit instantiation as described in the next option.</source>
          <target state="translated">ライブラリコードの場合、ライブラリに必要なテンプレートのインスタンスをすべて提供したい場合は、そのライブラリのすべてのオブジェクトファイルをリンクしてみてください。リンクは失敗しますが、副作用としてインスタンションが生成されます。しかし、複数のライブラリが同じインスタンションを提供しようとした場合、これは競合を引き起こす可能性があることに注意してください。より大きな制御のためには、次のオプションで説明するように明示的なインスタンス化を使用してください。</target>
        </trans-unit>
        <trans-unit id="275df5c8ab338eac0891dfd5fcb7ca333c414d1c" translate="yes" xml:space="preserve">
          <source>For machines that must pop arguments after a function call, always pop the arguments as soon as each function returns. At levels</source>
          <target state="translated">関数呼び出し後に引数をポップする必要があるマシンでは、各関数が戻ってきたらすぐに引数をポップするようにします。レベル</target>
        </trans-unit>
        <trans-unit id="4ab62f1721d989066bd88fccf2cddf5cca6c289c" translate="yes" xml:space="preserve">
          <source>For more information concerning the history of Objective-C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">オンラインで入手可能なObjective-Cの履歴に関する詳細については、&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http：//gcc.gnu.org/readings.htmlを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="445882425cb6a5526123dcb90201317cd797b812" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">トランザクションメモリに対するGCCのサポートの詳細については&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;、GNUトランザクションメモリライブラリのGNUトランザクションメモリライブラリを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="530d01e06da63e3ae60755b1d0e0664f37ce4c56" translate="yes" xml:space="preserve">
          <source>For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus</source>
          <target state="translated">プロファイル指定の最適化については、同じ最適化とコード生成オプションに加えて、ソースファイルを再度コンパイルします。</target>
        </trans-unit>
        <trans-unit id="1552bee1f905030b453e9bc73123ec457682d5d2" translate="yes" xml:space="preserve">
          <source>For references to Technical Corrigenda, Rationale documents and information concerning the history of C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">Technical Corrigenda、Rationaleドキュメント、およびオンラインで入手可能なCの歴史に関する情報については、http：//gcc.gnu.org/readings.htmlを参照して&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;ください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98fa91b9c573243f46d98173cb5c6bc69a14f37e" translate="yes" xml:space="preserve">
          <source>For run-time identification, the starting addresses of these areas, which correspond to their respective function entries minus &lt;var&gt;M&lt;/var&gt;, are additionally collected in the &lt;code&gt;__patchable_function_entries&lt;/code&gt; section of the resulting binary.</source>
          <target state="translated">実行時の識別のために、それぞれの関数エントリから &lt;var&gt;M&lt;/var&gt; を引いたものに対応するこれらの領域の開始アドレスが、結果のバイナリの &lt;code&gt;__patchable_function_entries&lt;/code&gt; セクションに追加で収集されます。</target>
        </trans-unit>
        <trans-unit id="ee4662af110f3d316db91e4c9bf088b26f37f6fc" translate="yes" xml:space="preserve">
          <source>For single-precision floating-point comparisons, emit an &lt;code&gt;fsub&lt;/code&gt; instruction and test the flags. This is faster than a software comparison, but can get incorrect results in the presence of NaNs, or when two different small numbers are compared such that their difference is calculated as zero. The default is</source>
          <target state="translated">単精度浮動小数点比較の場合、 &lt;code&gt;fsub&lt;/code&gt; 命令を発行してフラグをテストします。これはソフトウェアの比較より高速ですが、NaNが存在する場合、または2つの異なる小さな数値が比較され、それらの差がゼロとして計算される場合に、誤った結果が得られる可能性があります。デフォルトは</target>
        </trans-unit>
        <trans-unit id="629fb7062147649cb1707cc8cbe18549c87c4fce" translate="yes" xml:space="preserve">
          <source>For some target machines, GCC supports additional options to the format attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;).</source>
          <target state="translated">一部のターゲットマシンでは、GCCがformat属性の追加オプションをサポートしています（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性の宣言を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="8f693ccd95fd0352057c89a84d6dca28111b1d8d" translate="yes" xml:space="preserve">
          <source>For some targets, a suffix is added to the root directory specified with</source>
          <target state="translated">ターゲットによっては、サフィックスが</target>
        </trans-unit>
        <trans-unit id="1eef11d2e0af6679534eba00e39380a79330c652" translate="yes" xml:space="preserve">
          <source>For string operations of unknown size, use run-time checks with inline code for small blocks and a library call for large blocks.</source>
          <target state="translated">サイズが不明な文字列操作に対しては、小さなブロックに対してはインラインコードによるランタイムチェックを使用し、大きなブロックに対してはライブラリコールを使用します。</target>
        </trans-unit>
        <trans-unit id="c54c726dd72dd80b773414b86e870a30d193ec02" translate="yes" xml:space="preserve">
          <source>For systems that use the GNU C Library, the default is on.</source>
          <target state="translated">GNU C ライブラリを使用するシステムでは、デフォルトはオンになっています。</target>
        </trans-unit>
        <trans-unit id="90889da6f3749d2d8e7f525edbcff60563fc34f5" translate="yes" xml:space="preserve">
          <source>For targets that do not support either COMDAT or weak symbols, most entities with vague linkage are emitted as local symbols to avoid duplicate definition errors from the linker. This does not happen for local statics in inlines, however, as having multiple copies almost certainly breaks things.</source>
          <target state="translated">COMDATや弱いシンボルをサポートしていないターゲットの場合、リンカからの重複定義エラーを避けるために、曖昧なリンケージを持つほとんどのエンティティはローカルシンボルとして出力されます。しかし、複数のコピーを持つことはほとんど確実に物事を壊すので、これはインラインのローカル・スタティックには起こりません。</target>
        </trans-unit>
        <trans-unit id="db393fbd5a98ab60023bfd22b5dbbadca9023150" translate="yes" xml:space="preserve">
          <source>For targets that normally need trampolines for nested functions, always generate them instead of using descriptors. Otherwise, for targets that do not need them, like for example HP-PA or IA-64, do nothing.</source>
          <target state="translated">通常、入れ子になった関数にトランポリンを必要とするターゲットに対しては、記述子を使用する代わりに常に生成してください。そうでなければ、HP-PAやIA-64のようにトランポリンを必要としないターゲットに対しては、何もしません。</target>
        </trans-unit>
        <trans-unit id="3a882a0a0f801f0c1cb983c784834a8c5870b59e" translate="yes" xml:space="preserve">
          <source>For targets, like GNU/Linux, where all user-mode Xtensa code must be position-independent code (PIC), this option disables PIC for compiling kernel code.</source>
          <target state="translated">GNU/Linuxのように、ユーザモードのXtensaコードがすべて位置に依存しないコード(PIC)でなければならないターゲットの場合、このオプションはカーネルコードをコンパイルするためのPICを無効にします。</target>
        </trans-unit>
        <trans-unit id="8b8c7be3bb5a9384ba78f18abd2ee5fc45978a5a" translate="yes" xml:space="preserve">
          <source>For test coverage analysis, use &lt;code&gt;gcov&lt;/code&gt; to produce human readable information from the</source>
          <target state="translated">テストカバレッジ分析では、 &lt;code&gt;gcov&lt;/code&gt; を使用して、人間が読める情報を</target>
        </trans-unit>
        <trans-unit id="cdf3f70fc86ab5862691992f6df51e7ca5f5489e" translate="yes" xml:space="preserve">
          <source>For the NeXT runtime with version 2 of the ABI, check for a nil receiver in method invocations before doing the actual method call. This is the default and can be disabled using</source>
          <target state="translated">ABI のバージョン 2 を持つ NeXT ランタイムでは、実際のメソッド呼び出しを実行する前に、メソッド呼び出しで nil レシーバをチェックします。これは既定であり、以下を使用して無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="96b6c6242e369e6ead381c1d4d982f9072cadf3b" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler adds code to disable interrupts for the duration of those functions. If any functions so named are not encountered in the source, a warning is emitted that the pragma is not used. Examples:</source>
          <target state="translated">指定された関数に対して、コンパイラはそれらの関数の間、割り込みを無効にするコードを追加します。名前が付けられた関数がソース内で見つからない場合は、プラグマが使用されていないことを示す警告が表示されます。例を参照してください。</target>
        </trans-unit>
        <trans-unit id="b4ae72d8349f09925e7db4912a4034594f70873f" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler always uses a register-indirect call model when calling the named functions. Examples:</source>
          <target state="translated">名前付き関数の場合、コンパイラは名前付き関数を呼び出すときには常にレジスタ・ダイレクト・コール・モデルを使用します。例を参照してください。</target>
        </trans-unit>
        <trans-unit id="0f569d15217aa1a086b40826e8ecc6305b091d9b" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%. You can also use &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; to explicitly assign a probability value to individual expressions.</source>
          <target state="translated">分岐予測の最適化のために、 &lt;code&gt;__builtin_expect&lt;/code&gt; 式が &lt;code&gt;true&lt;/code&gt; である確率は、GCCの &lt;code&gt;builtin-expect-probability&lt;/code&gt; パラメーター（デフォルトは90％）によって制御されます。 &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; を使用して、確率値を個々の式に明示的に割り当てることもできます。</target>
        </trans-unit>
        <trans-unit id="bf219c0d4bab1b7372e20c5005cc97b0b9e1bb77" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directories specified by</source>
          <target state="translated">include ディレクティブの引用形では</target>
        </trans-unit>
        <trans-unit id="754ebda73d52810694ef0086a8c959916039f5fd" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directory of the current file is searched first.</source>
          <target state="translated">include ディレクティブの引用形では、カレントファイルのディレクトリが最初に検索されます。</target>
        </trans-unit>
        <trans-unit id="1d70b004544bcb6341f32cbd058f337db34bac6c" translate="yes" xml:space="preserve">
          <source>For the x86-32 compiler, you must use</source>
          <target state="translated">x86-32 コンパイラの場合は</target>
        </trans-unit>
        <trans-unit id="9e1a32426c586349d0aa1e4bc4474f828e773b55" translate="yes" xml:space="preserve">
          <source>For those adding visibility support to existing code, you may find &lt;code&gt;#pragma GCC visibility&lt;/code&gt; of use. This works by you enclosing the declarations you wish to set visibility for with (for example) &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; and &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt;. Bear in mind that symbol visibility should be viewed &lt;strong&gt;as part of the API interface contract&lt;/strong&gt; and thus all new code should always specify visibility when it is not the default; i.e., declarations only for use within the local DSO should &lt;strong&gt;always&lt;/strong&gt; be marked explicitly as hidden as so to avoid PLT indirection overheads&amp;mdash;making this abundantly clear also aids readability and self-documentation of the code. Note that due to ISO C++ specification requirements, &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; must always be of default visibility.</source>
          <target state="translated">既存のコードに可視性のサポートを追加する場合は、 &lt;code&gt;#pragma GCC visibility&lt;/code&gt; を使用できます。これは、（たとえば） &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; および &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt; を使用して、可視性を設定する宣言を囲むことで機能します。シンボルの可視性は&lt;strong&gt;APIインターフェースコントラクトの一部として&lt;/strong&gt;表示する必要があるため、デフォルトではない場合、すべての新しいコードは常に可視性を指定する必要があります。つまり、ローカルDSO内でのみ使用する宣言は、PLT間接オーバーヘッドを回避するために&lt;strong&gt;常に&lt;/strong&gt;明示的に非表示としてマークする必要&lt;strong&gt;があり&lt;/strong&gt;ます。これを十分に明確にすると、コードの可読性と自己文書化にも役立ちます。 ISO C ++仕様の要件により、 &lt;code&gt;operator new&lt;/code&gt; および &lt;code&gt;operator delete&lt;/code&gt; は常にデフォルトの可視性である必要があります。</target>
        </trans-unit>
        <trans-unit id="bb6de8937de1ff830849ca65a0b4291fa1ceadf7" translate="yes" xml:space="preserve">
          <source>Force (do not force) generated code to have a single exit point in each function.</source>
          <target state="translated">生成されたコードが各関数で単一の終了点を持つように強制する(強制しない)。</target>
        </trans-unit>
        <trans-unit id="acd5ffdf657527d019579abefcb2cc6ad1c27289" translate="yes" xml:space="preserve">
          <source>Force (do not force) the use of &lt;code&gt;memcpy&lt;/code&gt; for non-trivial block moves. The default is</source>
          <target state="translated">重要でないブロック移動に &lt;code&gt;memcpy&lt;/code&gt; の使用を強制します（強制しません）。デフォルトは</target>
        </trans-unit>
        <trans-unit id="f35628fb15f3c423c03af2c93b844cb43e594383" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt; types to be 64 bits wide. See</source>
          <target state="translated">フォース &lt;code&gt;long&lt;/code&gt; タイプは、64ビット幅であることを。見る</target>
        </trans-unit>
        <trans-unit id="df341c9e8e9829ab23b420935fbc32e82bb7a353" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and pointer types to be 32 bits wide.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、およびポインタ型を32ビット幅に強制します。</target>
        </trans-unit>
        <trans-unit id="a65d4b81903833686ba857ca6166053cb9c8d543" translate="yes" xml:space="preserve">
          <source>Force GCC to assign view numbers internally, if</source>
          <target state="translated">の場合、GCC がビュー番号を内部的に割り当てるように強制します。</target>
        </trans-unit>
        <trans-unit id="5c6c2109c0abfbfad2c57ae80b233af1137f54d6" translate="yes" xml:space="preserve">
          <source>Force GCC to generate DWARF2+ line number tables internally, if DWARF2+ line number tables are to be generated.</source>
          <target state="translated">DWARF2+の行番号テーブルを生成する場合、GCCが内部的にDWARF2+の行番号テーブルを生成するように強制する。</target>
        </trans-unit>
        <trans-unit id="e05ff97a2114aff3fe8702e99f968b0b9b270faf" translate="yes" xml:space="preserve">
          <source>Force all calls to functions to be indirect. This is useful when using Intel Processor Trace where it generates more precise timing information for function calls.</source>
          <target state="translated">関数へのすべての呼び出しを強制的に間接的にします。これは、関数呼び出しのタイミング情報をより正確に生成する Intel Processor Trace を使用する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="c6aa1876252f253f5c49c98017976af7ef3a9f80" translate="yes" xml:space="preserve">
          <source>Force all functions to be aligned to a 4-byte boundary.</source>
          <target state="translated">すべての関数を強制的に 4 バイトの境界に合わせます。</target>
        </trans-unit>
        <trans-unit id="5376700e1a5ed02b4facb60bd51b070a514bbd9d" translate="yes" xml:space="preserve">
          <source>Force all load and store instructions to always bypass cache by using I/O variants of the instructions. The default is not to bypass the cache.</source>
          <target state="translated">すべてのロードおよびストア命令は、命令のI/Oバリアントを使用して常にキャッシュをバイパスするように強制します。デフォルトではキャッシュをバイパスしないようになっています。</target>
        </trans-unit>
        <trans-unit id="6ba14189273ea29b59425c68e227901a2b9a86ef" translate="yes" xml:space="preserve">
          <source>Force assembly output to always use hex constants. Normally such constants are signed decimals, but this option is available for testsuite and/or aesthetic purposes.</source>
          <target state="translated">アセンブリ出力で常に16進数の定数を使用するように強制します。通常、このような定数は符号付き小数ですが、このオプションはテストスイートや美的目的のために利用可能です。</target>
        </trans-unit>
        <trans-unit id="a09ed1d5a3164af1580e37f843c9d03a7f3d9584" translate="yes" xml:space="preserve">
          <source>Force code generation in the ARM (A32) ISA.</source>
          <target state="translated">ARM(A32)ISAでの強制コード生成。</target>
        </trans-unit>
        <trans-unit id="8cf31b1c6efcebcf276d6ea54117f6f86a1ab3b3" translate="yes" xml:space="preserve">
          <source>Force code generation in the Thumb (T16/T32) ISA, depending on the architecture level.</source>
          <target state="translated">アーキテクチャレベルに応じて、Thumb (T16/T32)ISAで強制的にコードを生成します。</target>
        </trans-unit>
        <trans-unit id="57fc3d2f95e9a264681cfb6c086d3f11381e6d22" translate="yes" xml:space="preserve">
          <source>Force indirect call and jump via register.</source>
          <target state="translated">レジスタ経由で強制的に間接呼び出しとジャンプを行う。</target>
        </trans-unit>
        <trans-unit id="c2234a2c2c6fa572bb9aaff40c528a12cc4c9fff" translate="yes" xml:space="preserve">
          <source>Force the usage of delay slots for conditional branches, which stuffs the delay slot with a &lt;code&gt;nop&lt;/code&gt; if a suitable instruction cannot be found. By default this option is disabled. It can be enabled to work around hardware bugs as found in the original SH7055.</source>
          <target state="translated">条件付きブランチの遅延スロットの使用を強制します。適切な命令が見つからない場合は、遅延スロットに &lt;code&gt;nop&lt;/code&gt; が詰め込まれます。デフォルトでは、このオプションは無効になっています。元のSH7055にあるハードウェアのバグを回避するために有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="accd79a6ab2ab26b14a5acf0e4624a9287eb4f98" translate="yes" xml:space="preserve">
          <source>Force to call a function using jli_s instruction. This option is valid only for ARCv2 architecture.</source>
          <target state="translated">jli_s 命令を使用して関数を強制的に呼び出します。このオプションはARCv2アーキテクチャでのみ有効です。</target>
        </trans-unit>
        <trans-unit id="bda8d8b269a45b97f862176d65bac6c1e4f4afe4" translate="yes" xml:space="preserve">
          <source>Forces a particular function to be called using &lt;code&gt;jli&lt;/code&gt; instruction. The &lt;code&gt;jli&lt;/code&gt; instruction makes use of a table stored into &lt;code&gt;.jlitab&lt;/code&gt; section, which holds the location of the functions which are addressed using this instruction.</source>
          <target state="translated">&lt;code&gt;jli&lt;/code&gt; 命令を使用して特定の関数を強制的に呼び出します。 &lt;code&gt;jli&lt;/code&gt; 命令に記憶されたテーブルの使用なり &lt;code&gt;.jlitab&lt;/code&gt; この命令を使用してアドレス指定される機能の位置を保持するセクションを、。</target>
        </trans-unit>
        <trans-unit id="2f084ee73c513d8f966bbd0c40980e7ab5210b2e" translate="yes" xml:space="preserve">
          <source>Formal syntax for attributes.</source>
          <target state="translated">属性の正式な構文。</target>
        </trans-unit>
        <trans-unit id="6e97cc41857aff390c1d1352f1580ff15ac71869" translate="yes" xml:space="preserve">
          <source>Format checks specific to particular targets.</source>
          <target state="translated">特定のターゲットに固有のフォーマットチェックを行います。</target>
        </trans-unit>
        <trans-unit id="c4653752f8662d9cf50820b53f4f92b88244d0b2" translate="yes" xml:space="preserve">
          <source>Formerly the &lt;code&gt;hi&lt;/code&gt; register. This constraint is no longer supported.</source>
          <target state="translated">以前は &lt;code&gt;hi&lt;/code&gt; レジスターでした。この制約はサポートされなくなりました。</target>
        </trans-unit>
        <trans-unit id="fb001b2c292ad2f619c8caf6e0ac8afd191aaa76" translate="yes" xml:space="preserve">
          <source>Framework</source>
          <target state="translated">Framework</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="a4a10834211c2c0fbcb7eeb4d7d706ce399ad1a9" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">(従来のプリプロセッサを使用した)前処理が必要なフリーフォームのFortranソースコード。</target>
        </trans-unit>
        <trans-unit id="ab1de10d533c059aa65605ce6bb4a93b10329a51" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that should not be preprocessed.</source>
          <target state="translated">前処理してはいけない自由形のFortranソースコード。</target>
        </trans-unit>
        <trans-unit id="5888490bf4ce1fb3617e200efdb6835e0c4faa44" translate="yes" xml:space="preserve">
          <source>Function attributes are introduced by the &lt;code&gt;__attribute__&lt;/code&gt; keyword in the declaration of a function, followed by an attribute specification enclosed in double parentheses. You can specify multiple attributes in a declaration by separating them by commas within the double parentheses or by immediately following one attribute specification with another. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for the exact rules on attribute syntax and placement. Compatible attribute specifications on distinct declarations of the same function are merged. An attribute specification that is not compatible with attributes already applied to a declaration of the same function is ignored with a warning.</source>
          <target state="translated">関数属性は、関数の宣言の &lt;code&gt;__attribute__&lt;/code&gt; キーワードによって導入され、その後に二重括弧で囲まれた属性指定が続きます。宣言で複数の属性を指定するには、属性を二重括弧内のコンマで区切るか、属性指定の直後に別の属性を続けます。属性の構文と配置に関する正確な規則については、「&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性の構文&lt;/a&gt;」を参照してください。同じ関数の異なる宣言の互換性のある属性仕様がマージされます。同じ関数の宣言にすでに適用されている属性と互換性のない属性指定は、警告とともに無視されます。</target>
        </trans-unit>
        <trans-unit id="f93ed46e6d86f7b87373026d5e663168479db390" translate="yes" xml:space="preserve">
          <source>Function precision. The trap handler can determine the function that caused a floating-point exception.</source>
          <target state="translated">関数の精度。トラップハンドラは、浮動小数点例外の原因となった関数を判定することができます。</target>
        </trans-unit>
        <trans-unit id="d3d655b1f77fc46f162e436abc252a9dc6d8148d" translate="yes" xml:space="preserve">
          <source>Function prototype</source>
          <target state="translated">関数プロトタイプ</target>
        </trans-unit>
        <trans-unit id="9e039f9c7013d88c23a38a281ed14037c4166f2d" translate="yes" xml:space="preserve">
          <source>Function reordering based on profile instrumentation collects first time of execution of a function and orders these functions in ascending order.</source>
          <target state="translated">プロファイルインストルメンテーションに基づく関数の並び替えでは、関数の初回実行時間を収集し、昇順に並べ替えます。</target>
        </trans-unit>
        <trans-unit id="d33f90e4120ff23ca44b34b56f5771105ef3b24d" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 16-bit boundaries.</source>
          <target state="translated">関数は16ビットの境界にアラインメントされています。</target>
        </trans-unit>
        <trans-unit id="34be57d225a7e4b91308288bf7b00a21a76d0703" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 32-bit boundaries, unless optimizing for size.</source>
          <target state="translated">サイズを最適化しない限り、関数は32ビット境界に整列されます。</target>
        </trans-unit>
        <trans-unit id="5a29ddf72dc39612a3206ea0dfa0993bffe35aee" translate="yes" xml:space="preserve">
          <source>Functions declared with the &lt;code&gt;naked&lt;/code&gt; attribute also require basic &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 属性で宣言された関数には、基本的な &lt;code&gt;asm&lt;/code&gt; も必要です（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b405d9a1c02455968daea5fb86ad7161a05b238c" translate="yes" xml:space="preserve">
          <source>Functions from different modes can be inlined in the caller&amp;rsquo;s mode.</source>
          <target state="translated">異なるモードの関数は、呼び出し元のモードにインライン化できます。</target>
        </trans-unit>
        <trans-unit id="a51173ce4592b6408dafbf5dcd763cb00409451e" translate="yes" xml:space="preserve">
          <source>Functions prologues/epilogues are expanded as calls to appropriate subroutines. Code size is smaller.</source>
          <target state="translated">関数のプロログ/エピログは、適切なサブルーチンの呼び出しとして展開されます。コードサイズが小さくなります。</target>
        </trans-unit>
        <trans-unit id="958942a81a4fb21510019af4adcbaec4037ab18c" translate="yes" xml:space="preserve">
          <source>Functions that are normally built in but do not have semantics defined by ISO C (such as &lt;code&gt;alloca&lt;/code&gt; and &lt;code&gt;ffs&lt;/code&gt;) are not built-in functions when</source>
          <target state="translated">通常は組み込まれているが、ISO Cで定義されているセマンティクスを持たない関数（ &lt;code&gt;alloca&lt;/code&gt; や &lt;code&gt;ffs&lt;/code&gt; など）は、次の場合には組み込み関数ではありません。</target>
        </trans-unit>
        <trans-unit id="a77748cc250a919f08dac1cbb97eb54cbd2d36e9" translate="yes" xml:space="preserve">
          <source>Funding Free Software</source>
          <target state="translated">自由ソフトウェアの資金調達</target>
        </trans-unit>
        <trans-unit id="ad51c11605482040955d96c2db6f7d9f4eca570e" translate="yes" xml:space="preserve">
          <source>Furthermore, if the &lt;em&gt;earlyclobber&lt;/em&gt; operand is also a read/write operand, then that operand is written only after it&amp;rsquo;s used.</source>
          <target state="translated">さらに、&lt;em&gt;earlyclobber&lt;/em&gt;オペランドが読み取り/書き込みオペランドでもある場合、そのオペランドは使用後にのみ書き込まれます。</target>
        </trans-unit>
        <trans-unit id="8c1a9865dc580dc97d71f0ac34525d7ff40826cf" translate="yes" xml:space="preserve">
          <source>Future versions of GCC may zero-extend, or use a target-defined &lt;code&gt;ptr_extend&lt;/code&gt; pattern. Do not rely on sign extension.</source>
          <target state="translated">GCCの将来のバージョンでは、ゼロ拡張するか、ターゲット定義の &lt;code&gt;ptr_extend&lt;/code&gt; パターンを使用する可能性があります。符号拡張に依存しないでください。</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="6ed55690929b9e60aff3a9282723cba6d9ce77ea" translate="yes" xml:space="preserve">
          <source>G++ allows a virtual function returning &amp;lsquo;</source>
          <target state="translated">G ++は、仮想関数が 'を返すことを許可します</target>
        </trans-unit>
        <trans-unit id="5114ba459fc06431a44841ea4654eb2a26a6c91e" translate="yes" xml:space="preserve">
          <source>G++ allows anonymous structs and unions to have members that are not public non-static data members (i.e. fields). These extensions are deprecated.</source>
          <target state="translated">G++では、匿名構造体と組合が、パブリックではない非静的データのメンバ(つまりフィールド)を持つことができます。これらの拡張機能は非推奨です。</target>
        </trans-unit>
        <trans-unit id="de3e575c048ce4bfb45f20c4e2302053983a6e85" translate="yes" xml:space="preserve">
          <source>G++ allows attributes to follow a parenthesized direct initializer, e.g. &amp;lsquo;</source>
          <target state="translated">G ++では、属性を括弧で囲まれた直接初期化子に続けることができます。</target>
        </trans-unit>
        <trans-unit id="4279ad338a301cce60cdfae7e5135ebd09b1878c" translate="yes" xml:space="preserve">
          <source>G++ allows floating-point literals to appear in integral constant expressions, e.g. &amp;lsquo;</source>
          <target state="translated">G ++では、浮動小数点リテラルを整数定数式に含めることができます。例： '</target>
        </trans-unit>
        <trans-unit id="c5b988dd39fdeb99ab7e438425f37e6884df0f08" translate="yes" xml:space="preserve">
          <source>G++ allows static data members of const floating-point type to be declared with an initializer in a class definition. The standard only allows initializers for static members of const integral types and const enumeration types so this extension has been deprecated and will be removed from a future version.</source>
          <target state="translated">G++では、const 浮動小数点型の静的データ・メンバをクラス定義でイニシャライザを使用して宣言することができます。標準では、const 積分型と const 列挙型の静的メンバに対してのみイニシャライザを許可しているため、この拡張機能は非推奨となり、将来のバージョンから削除される予定です。</target>
        </trans-unit>
        <trans-unit id="63f7f4841ad757c79aac590be15aedf6621086d6" translate="yes" xml:space="preserve">
          <source>G++ implements the &amp;ldquo;intuitive&amp;rdquo; algorithm for copy-assignment: assign all direct bases, then assign all members. In that algorithm, the virtual base subobject can be encountered more than once. In the example, copying proceeds in the following order: &amp;lsquo;</source>
          <target state="translated">G ++は、コピー割り当てのための「直感的な」アルゴリズムを実装します。すべての直接ベースを割り当ててから、すべてのメンバーを割り当てます。そのアルゴリズムでは、仮想ベースサブオブジェクトが複数回発生する可能性があります。この例では、コピーは次の順序で行われます。</target>
        </trans-unit>
        <trans-unit id="67e3c9106f6559177c33511b2d979e92d246d3b0" translate="yes" xml:space="preserve">
          <source>G++ implements the Borland model on targets where the linker supports it, including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows. Otherwise G++ implements neither automatic model.</source>
          <target state="translated">G++は、リンカがサポートしているターゲット(GNU/LinuxなどのELFターゲット、Mac OS X、Microsoft Windowsなど)でボーランドモデルを実装します。それ以外の場合は、G++は自動モデルを実装していません。</target>
        </trans-unit>
        <trans-unit id="31ff568d5d2e9d2f6743afcdc5f3a983bc913e2f" translate="yes" xml:space="preserve">
          <source>G++ implements the same behavior as GCC does when assigning to a volatile object&amp;mdash;there is no reread of the assigned-to object, the assigned rvalue is reused. Note that in C++ assignment expressions are lvalues, and if used as an lvalue, the volatile object is referred to. For instance, &lt;var&gt;vref&lt;/var&gt; refers to &lt;var&gt;vobj&lt;/var&gt;, as expected, in the following example:</source>
          <target state="translated">G ++は、揮発性オブジェクトに割り当てるときのGCCと同じ動作を実装します。割り当て先オブジェクトの再読み取りがなく、割り当てられた右辺値が再利用されます。C ++の割り当て式は左辺値であり、左辺値として使用された場合、揮発性オブジェクトが参照されることに注意してください。たとえば、次の例では、 &lt;var&gt;vref&lt;/var&gt; が予想どおり &lt;var&gt;vobj&lt;/var&gt; を参照しています。</target>
        </trans-unit>
        <trans-unit id="a1650ba68fd434ff4571a3ae6e0e946daaa36507" translate="yes" xml:space="preserve">
          <source>G3</source>
          <target state="translated">G3</target>
        </trans-unit>
        <trans-unit id="57c24c56c83113e722078337cfe2d513db43c570" translate="yes" xml:space="preserve">
          <source>G4</source>
          <target state="translated">G4</target>
        </trans-unit>
        <trans-unit id="75cc572d557c39d31a9a311423998e30b6913f73" translate="yes" xml:space="preserve">
          <source>G5</source>
          <target state="translated">G5</target>
        </trans-unit>
        <trans-unit id="47bc5f06e2bc84be8cac3eeae94be31fd0bb67f8" translate="yes" xml:space="preserve">
          <source>GBR</source>
          <target state="translated">GBR</target>
        </trans-unit>
        <trans-unit id="8577b47d2b705ad56be34a1a6a9f6472d1ac1001" translate="yes" xml:space="preserve">
          <source>GCC</source>
          <target state="translated">GCC</target>
        </trans-unit>
        <trans-unit id="2128b3c47a543c2fd225378159dcf1cee572dc1a" translate="yes" xml:space="preserve">
          <source>GCC aims towards being usable as a conforming freestanding implementation, or as the compiler for a conforming hosted implementation. By default, it acts as the compiler for a hosted implementation, defining &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and presuming that when the names of ISO C functions are used, they have the semantics defined in the standard. To make it act as a conforming freestanding implementation for a freestanding environment, use the option</source>
          <target state="translated">GCCは、適合した独立した実装として、または適合したホストされた実装のコンパイラとして使用できることを目指しています。デフォルトでは、ホストされた実装のコンパイラーとして機能し、 &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; を &lt;code&gt;1&lt;/code&gt; として定義し、ISO C関数の名前が使用される場合、それらは標準で定義されているセマンティクスを持っていると想定します。自立型環境の適合自立型実装として機能させるには、オプションを使用します</target>
        </trans-unit>
        <trans-unit id="a09efcf4281abbe557aa1d8c0037c8b8db485c71" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on C labels. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCCでは、Cラベルに属性を設定できます。&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性&lt;/a&gt;を使用するための正確な構文の詳細については、「属性の構文」を参照してください。その他の属性は、関数（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）、変数（&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数属性を&lt;/a&gt;参照）、列挙子（列挙子&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;属性を&lt;/a&gt;参照）、ステートメント（&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;ステートメント属性を&lt;/a&gt;参照）、および型（&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;タイプ属性を&lt;/a&gt;参照）で使用できます。</target>
        </trans-unit>
        <trans-unit id="188d2c46ce847222650ff9a197ae21b6d36834fd" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on enumerators. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCCでは、列挙子に属性を設定できます。&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性&lt;/a&gt;を使用するための正確な構文の詳細については、「属性の構文」を参照してください。その他の属性は、関数（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）、変数（&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数属性を&lt;/a&gt;参照）、ラベル（&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;ラベル属性を&lt;/a&gt;参照）、ステートメント（&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;ステートメント属性を&lt;/a&gt;参照）、およびタイプ（&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;タイプ属性を&lt;/a&gt;参照）で使用できます。</target>
        </trans-unit>
        <trans-unit id="1318f5f0c876968e4d22801744660b2a68a5dbc1" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on null statements. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCCでは、nullステートメントに属性を設定できます。&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;属性&lt;/a&gt;を使用するための正確な構文の詳細については、「属性の構文」を参照してください。その他の属性は、関数（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）、変数（&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数属性を&lt;/a&gt;参照）、ラベル（&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;ラベル属性を&lt;/a&gt;参照）、列挙子（列挙子&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;属性を&lt;/a&gt;参照）、および型（&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;型属性を&lt;/a&gt;参照）で使用できます。</target>
        </trans-unit>
        <trans-unit id="8f7518a10a612c3aa4683ccb174e0aca674b8c50" translate="yes" xml:space="preserve">
          <source>GCC allows static initialization of flexible array members. This is equivalent to defining a new structure containing the original structure followed by an array of sufficient size to contain the data. E.g. in the following, &lt;code&gt;f1&lt;/code&gt; is constructed as if it were declared like &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">GCCでは、柔軟な配列メンバーの静的な初期化が可能です。これは、元の構造を含む新しい構造を定義し、その後にデータを格納するのに十分なサイズの配列を定義することと同じです。たとえば、以下では、 &lt;code&gt;f1&lt;/code&gt; は &lt;code&gt;f2&lt;/code&gt; のように宣言されたかのように構築されます。</target>
        </trans-unit>
        <trans-unit id="2f25be809d122cad042e0db0bcc9a75b7e95df2b" translate="yes" xml:space="preserve">
          <source>GCC allows the user to selectively enable or disable certain types of diagnostics, and change the kind of the diagnostic. For example, a project&amp;rsquo;s policy might require that all sources compile with</source>
          <target state="translated">GCCを使用すると、ユーザーは特定の種類の診断を選択的に有効または無効にしたり、診断の種類を変更したりできます。たとえば、プロジェクトのポリシーでは、すべてのソースをコンパイルして</target>
        </trans-unit>
        <trans-unit id="095246dfc125cf940fca19907500328219191dc3" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type, but only under the following circumstances:</source>
          <target state="translated">GCCでは、 &lt;code&gt;typedef&lt;/code&gt; 名をベクトル型の型指定子として使用できますが、これは次の状況でのみ可能です。</target>
        </trans-unit>
        <trans-unit id="118ab2384628648bceb8c24d3c1faa22f9cfc67a" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type.</source>
          <target state="translated">GCCでは、ベクター型の型指定子として &lt;code&gt;typedef&lt;/code&gt; 名を使用できます。</target>
        </trans-unit>
        <trans-unit id="4dbc0782ac4d82d0f286d4feca2e87d560c81769" translate="yes" xml:space="preserve">
          <source>GCC allows you to declare &lt;em&gt;local labels&lt;/em&gt; in any nested block scope. A local label is just like an ordinary label, but you can only reference it (with a &lt;code&gt;goto&lt;/code&gt; statement, or by taking its address) within the block in which it is declared.</source>
          <target state="translated">GCCでは、ネストされたブロックスコープで&lt;em&gt;ローカルラベル&lt;/em&gt;を宣言できます。ローカルラベルは通常のラベルと同じですが、それを宣言できるブロック内でのみ（ &lt;code&gt;goto&lt;/code&gt; ステートメントを使用するか、アドレスを取得することによって）参照できます。</target>
        </trans-unit>
        <trans-unit id="11edda20db587e9081a40a5791b651f14e5edef4" translate="yes" xml:space="preserve">
          <source>GCC allows you to use</source>
          <target state="translated">GCCでは</target>
        </trans-unit>
        <trans-unit id="cb8172c4270b6a56a430a2344a1d357df8a89c7e" translate="yes" xml:space="preserve">
          <source>GCC already has an extensive list of suffixes built into it. This directive adds an entry to the end of the list of suffixes, but since the list is searched from the end backwards, it is effectively possible to override earlier entries using this technique.</source>
          <target state="translated">GCC にはすでに広範なサフィックスのリストが組み込まれています。このディレクティブはサフィックスのリストの最後にエントリを追加しますが、 リストは最後から順に検索されるので、この手法を使って以前のエントリを上書きすることが 事実上可能です。</target>
        </trans-unit>
        <trans-unit id="4946c9e7401c541aac6237c0b11a4f8762636048" translate="yes" xml:space="preserve">
          <source>GCC also defines the macro &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; when tuning for ColdFire microarchitecture &lt;var&gt;uarch&lt;/var&gt;, where &lt;var&gt;uarch&lt;/var&gt; is one of the arguments given above.</source>
          <target state="translated">GCCはまた、ColdFireマイクロアーキテクチャー &lt;var&gt;uarch&lt;/var&gt; のチューニング時にマクロ &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; 定義します。ここで、 &lt;var&gt;uarch&lt;/var&gt; は上記の引数の1つです。</target>
        </trans-unit>
        <trans-unit id="bd57161c41c158f961b92f3f1147120413b6477d" translate="yes" xml:space="preserve">
          <source>GCC also knows implicitly that arguments starting in</source>
          <target state="translated">GCCはまた、暗黙のうちに</target>
        </trans-unit>
        <trans-unit id="5590aa7708108855eef5df246b0491a821f68f35" translate="yes" xml:space="preserve">
          <source>GCC also offers a simple mechanism for printing messages during compilation.</source>
          <target state="translated">GCCには、コンパイル中にメッセージを印刷するためのシンプルな仕組みもあります。</target>
        </trans-unit>
        <trans-unit id="ff5eb1c7d3d1103b9c01d9df5e0e050903b1adc0" translate="yes" xml:space="preserve">
          <source>GCC also provides a target specific macro &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;, which is the largest alignment ever used for any data type on the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">GCCは、ターゲット固有のマクロ &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; も提供します。これは、コンパイル対象のターゲットマシン上の任意のデータ型でこれまでに使用された最大のアライメントです。たとえば、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="1ce6a581ce58e7b0e52deb0ba48b6684312e9d7c" translate="yes" xml:space="preserve">
          <source>GCC also provides intrinsics to directly access the network registers. The intrinsics are:</source>
          <target state="translated">GCCは、ネットワークレジスタに直接アクセスするための内部構造も提供しています。イントリニクスは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="028d66aa5e30f9984efa701c3d35086edefd3f65" translate="yes" xml:space="preserve">
          <source>GCC also supports attributes on variable declarations (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCCは、変数宣言（&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数属性を&lt;/a&gt;参照）、ラベル（&lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;ラベル属性を&lt;/a&gt;参照）、列挙子（列挙子&lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;属性を&lt;/a&gt;参照）、ステートメント（&lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;ステートメント属性を&lt;/a&gt;参照）、およびタイプ（&lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;タイプ属性を&lt;/a&gt;参照）の属性もサポートしています。</target>
        </trans-unit>
        <trans-unit id="51353b73f0da65e20b68eea37e8d612e8b885954" translate="yes" xml:space="preserve">
          <source>GCC also warns about function definitions that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Again, these are only possible candidates. GCC guesses that &lt;code&gt;format&lt;/code&gt; attributes might be appropriate for any function that calls a function like &lt;code&gt;vprintf&lt;/code&gt; or &lt;code&gt;vscanf&lt;/code&gt;, but this might not always be the case, and some functions for which &lt;code&gt;format&lt;/code&gt; attributes are appropriate may not be detected.</source>
          <target state="translated">GCCは、 &lt;code&gt;format&lt;/code&gt; 属性の候補となる可能性がある関数定義についても警告します。繰り返しますが、これらは可能な候補にすぎません。 GCCは、 &lt;code&gt;format&lt;/code&gt; 属性が &lt;code&gt;vprintf&lt;/code&gt; や &lt;code&gt;vscanf&lt;/code&gt; などの関数を呼び出すすべての関数に適していると推測していますが、常にそうであるとは限らず、 &lt;code&gt;format&lt;/code&gt; 属性が適切である一部の関数が検出されない場合があります。</target>
        </trans-unit>
        <trans-unit id="e6346f95ac263c787786ddc66b5d9c0bcd8bac71" translate="yes" xml:space="preserve">
          <source>GCC always follows the C99 and C11 requirement that the result of division is truncated towards zero.</source>
          <target state="translated">GCCは、除算の結果がゼロに向かって切り捨てられるというC99とC11の要件に常に従います。</target>
        </trans-unit>
        <trans-unit id="71e58c529399ec16a2da4be1a53c86f1d271b88e" translate="yes" xml:space="preserve">
          <source>GCC always tries to compile your program if possible; it never gratuitously rejects a program whose meaning is clear merely because (for instance) it fails to conform to a standard. In some cases, however, the C and C++ standards specify that certain extensions are forbidden, and a diagnostic &lt;em&gt;must&lt;/em&gt; be issued by a conforming compiler. The</source>
          <target state="translated">GCCは、可能であれば常にプログラムをコンパイルしようとします。（たとえば）標準に準拠していないという理由だけで意味が明確なプログラムを不当に拒否することはありません。ただし、場合によっては、CおよびC ++標準では、特定の拡張を禁止し、適合コンパイラーによって診断を発行する&lt;em&gt;必要&lt;/em&gt;があると規定しています。の</target>
        </trans-unit>
        <trans-unit id="3d850d85ff9e9c0132b4336d9517c8233fd73c22" translate="yes" xml:space="preserve">
          <source>GCC by default uses the GNU Objective-C runtime library, which is part of GCC and is not the same as the Apple/NeXT Objective-C runtime library used on Apple systems. There are a number of differences documented in this manual. The options</source>
          <target state="translated">GCC は、デフォルトでは GNU Objective-C ランタイムライブラリを使用しますが、これは GCC の一部であり、Apple システムで使用されている Apple/NeXT Objective-C ランタイムライブラリとは同じではありません。このマニュアルには、いくつかの違いが記載されています。オプション</target>
        </trans-unit>
        <trans-unit id="1c0b38c968b6ef5ec06e42505963f829a108bef3" translate="yes" xml:space="preserve">
          <source>GCC by itself attempts to be a conforming freestanding implementation. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of what this means. Beyond the library facilities required of such an implementation, the rest of the C library is supplied by the vendor of the operating system. If that C library doesn&amp;rsquo;t conform to the C standards, then your programs might get warnings (especially when using</source>
          <target state="translated">GCC自体は、適合した独立した実装になることを試みます。これの意味の詳細については、&lt;a href=&quot;standards#Standards&quot;&gt;GCC&lt;/a&gt;でサポートされている言語標準を参照してください。このような実装に必要なライブラリ機能の他に、Cライブラリの残りはオペレーティングシステムのベンダーによって提供されます。そのCライブラリがC標準に準拠していない場合、プログラムは警告を受け取る可能性があります（特に、</target>
        </trans-unit>
        <trans-unit id="a367622db7093a4cc9943cb9b928ad16a228659d" translate="yes" xml:space="preserve">
          <source>GCC can allocate complex automatic variables in a noncontiguous fashion; it&amp;rsquo;s even possible for the real part to be in a register while the imaginary part is on the stack (or vice versa). Only the DWARF debug info format can represent this, so use of DWARF is recommended. If you are using the stabs debug info format, GCC describes a noncontiguous complex variable as if it were two separate variables of noncomplex type. If the variable&amp;rsquo;s actual name is &lt;code&gt;foo&lt;/code&gt;, the two fictitious variables are named &lt;code&gt;foo$real&lt;/code&gt; and &lt;code&gt;foo$imag&lt;/code&gt;. You can examine and set these two fictitious variables with your debugger.</source>
          <target state="translated">GCCは、不連続な方法で複雑な自動変数を割り当てることができます。虚数部がスタック上にあるときに実数部がレジスタに存在することも可能です（またはその逆）。これを表すことができるのはDWARFデバッグ情報形式だけなので、DWARFの使用をお勧めします。 stabsデバッグ情報形式を使用している場合、GCCは、非連続タイプの2つの別個の変数であるかのように、不連続の複素変数を記述します。変数の実際の名前が &lt;code&gt;foo&lt;/code&gt; の場合、2つの架空の変数の名前は &lt;code&gt;foo$real&lt;/code&gt; および &lt;code&gt;foo$imag&lt;/code&gt; です。これら2つの架空の変数をデバッガーで調べて設定できます。</target>
        </trans-unit>
        <trans-unit id="f1f3d3d856350fe50d86862ccf0921b96281e6bd" translate="yes" xml:space="preserve">
          <source>GCC can compile the binary representation (BRIG) of the HSAIL text format as described in HSA Programmer&amp;rsquo;s Reference Manual version 1.0.1. This capability is typically utilized to implement the HSA runtime API&amp;rsquo;s HSAIL finalization extension for a gcc supported processor. HSA standards are freely available at &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt;.</source>
          <target state="translated">GCCは、HSA Programmer's Reference Manualバージョン1.0.1で説明されているように、HSAILテキスト形式のバイナリ表現（BRIG）をコンパイルできます。この機能は通常、gccがサポートされているプロセッサーにHSAランタイムAPIのHSAILファイナライズ拡張機能を実装するために使用されます。HSA標準は、&lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http：&lt;/a&gt; //www.hsafoundation.com/standards/から無料で入手できます。</target>
        </trans-unit>
        <trans-unit id="87356dae6f4ed6235c36eedc0fe148afee6229d9" translate="yes" xml:space="preserve">
          <source>GCC can generate code for both VxWorks kernels and real time processes (RTPs). This option switches from the former to the latter. It also defines the preprocessor macro &lt;code&gt;__RTP__&lt;/code&gt;.</source>
          <target state="translated">GCCは、VxWorksカーネルとリアルタイムプロセス（RTP）の両方のコードを生成できます。このオプションは、前者から後者に切り替えます。また、プリプロセッサマクロ &lt;code&gt;__RTP__&lt;/code&gt; も定義します。</target>
        </trans-unit>
        <trans-unit id="fb9f5282eec43cb95e4c422b1995ae6896ab686c" translate="yes" xml:space="preserve">
          <source>GCC can only handle one commutative pair in an asm; if you use more, the compiler may fail. Note that you need not use the modifier if the two alternatives are strictly identical; this would only waste time in the reload pass.</source>
          <target state="translated">GCC は asm の中で 1 つの可換的なペアしか扱えません。2つの選択肢が厳密に同一である場合は修飾子を使用する必要はないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="78d74922e82c5075040c6a08c44444ac34a5ad2a" translate="yes" xml:space="preserve">
          <source>GCC comes with shell scripts to fix certain known problems in system header files. They install corrected copies of various header files in a special directory where only GCC will normally look for them. The scripts adapt to various systems by searching all the system header files for the problem cases that we know about.</source>
          <target state="translated">GCC には、システムヘッダファイルの既知の問題を修正するためのシェルスクリプトが付属しています。それらは、様々なヘッダファイルの修正されたコピーを、通常はGCCだけが探すことができる特別なディレクトリにインストールします。スクリプトは、我々が知っている問題のケースのためにすべてのシステムヘッダファイルを検索することによって、様々なシステムに適応します。</target>
        </trans-unit>
        <trans-unit id="cd976cd951c888839dc15c99651c6a379e4c0cac" translate="yes" xml:space="preserve">
          <source>GCC compiled code sometimes emits warnings from the HP-UX assembler of the form:</source>
          <target state="translated">GCC でコンパイルされたコードが HP-UX アセンブラから警告を発することがあります。</target>
        </trans-unit>
        <trans-unit id="81e4ed9eaf205df3f6c599be30d212f56ac91924" translate="yes" xml:space="preserve">
          <source>GCC complains about program fragments such as &amp;lsquo;</source>
          <target state="translated">GCCは、「</target>
        </trans-unit>
        <trans-unit id="67982454dd3e3b7d64f34362d5f739d9716bb143" translate="yes" xml:space="preserve">
          <source>GCC complains about unterminated character constants inside of preprocessing conditionals that fail. Some programs have English comments enclosed in conditionals that are guaranteed to fail; if these comments contain apostrophes, GCC will probably report an error. For example, this code would produce an error:</source>
          <target state="translated">GCC は、失敗する前処理の条件式の中にある終端のない文字定数に不満を感じています。プログラムの中には、条件式の中に英語のコメントが含まれているものがありますが、これらのコメントにアポストロフィが含まれている場合、GCC はおそらくエラーを報告します。例えば、以下のコードはエラーになります。</target>
        </trans-unit>
        <trans-unit id="e4bb7adbf45dc4a3fb687d7313280a86480960d6" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">GCCは、&lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http:&lt;/a&gt; //openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.htmlにあるOpenPOWER 64ビットELF V2 ABI仕様に準拠しています。このドキュメントの付録Aは、準拠するコンパイラが提供する必要があるベクターAPIインターフェースの一覧です。プログラマーは、そこに記述されているインターフェースを優先的に使用する必要があります。ただし、歴史的にGCCは、ベクトル命令にアクセスするための追加のインターフェースを提供してきました。これらについて以下に簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="65f9b929facca207bcc2021009f1c0587b957cbf" translate="yes" xml:space="preserve">
          <source>GCC currently emits calls to &lt;code&gt;vmldExp2&lt;/code&gt;, &lt;code&gt;vmldLn2&lt;/code&gt;, &lt;code&gt;vmldLog102&lt;/code&gt;, &lt;code&gt;vmldPow2&lt;/code&gt;, &lt;code&gt;vmldTanh2&lt;/code&gt;, &lt;code&gt;vmldTan2&lt;/code&gt;, &lt;code&gt;vmldAtan2&lt;/code&gt;, &lt;code&gt;vmldAtanh2&lt;/code&gt;, &lt;code&gt;vmldCbrt2&lt;/code&gt;, &lt;code&gt;vmldSinh2&lt;/code&gt;, &lt;code&gt;vmldSin2&lt;/code&gt;, &lt;code&gt;vmldAsinh2&lt;/code&gt;, &lt;code&gt;vmldAsin2&lt;/code&gt;, &lt;code&gt;vmldCosh2&lt;/code&gt;, &lt;code&gt;vmldCos2&lt;/code&gt;, &lt;code&gt;vmldAcosh2&lt;/code&gt;, &lt;code&gt;vmldAcos2&lt;/code&gt;, &lt;code&gt;vmlsExp4&lt;/code&gt;, &lt;code&gt;vmlsLn4&lt;/code&gt;, &lt;code&gt;vmlsLog104&lt;/code&gt;, &lt;code&gt;vmlsPow4&lt;/code&gt;, &lt;code&gt;vmlsTanh4&lt;/code&gt;, &lt;code&gt;vmlsTan4&lt;/code&gt;, &lt;code&gt;vmlsAtan4&lt;/code&gt;, &lt;code&gt;vmlsAtanh4&lt;/code&gt;, &lt;code&gt;vmlsCbrt4&lt;/code&gt;, &lt;code&gt;vmlsSinh4&lt;/code&gt;, &lt;code&gt;vmlsSin4&lt;/code&gt;, &lt;code&gt;vmlsAsinh4&lt;/code&gt;, &lt;code&gt;vmlsAsin4&lt;/code&gt;, &lt;code&gt;vmlsCosh4&lt;/code&gt;, &lt;code&gt;vmlsCos4&lt;/code&gt;, &lt;code&gt;vmlsAcosh4&lt;/code&gt; and &lt;code&gt;vmlsAcos4&lt;/code&gt; for corresponding function type when</source>
          <target state="translated">GCCは、現在の呼び出し発する &lt;code&gt;vmldExp2&lt;/code&gt; 、 &lt;code&gt;vmldLn2&lt;/code&gt; 、 &lt;code&gt;vmldLog102&lt;/code&gt; 、 &lt;code&gt;vmldPow2&lt;/code&gt; 、 &lt;code&gt;vmldTanh2&lt;/code&gt; 、 &lt;code&gt;vmldTan2&lt;/code&gt; 、 &lt;code&gt;vmldAtan2&lt;/code&gt; 、 &lt;code&gt;vmldAtanh2&lt;/code&gt; 、 &lt;code&gt;vmldCbrt2&lt;/code&gt; 、 &lt;code&gt;vmldSinh2&lt;/code&gt; 、 &lt;code&gt;vmldSin2&lt;/code&gt; 、 &lt;code&gt;vmldAsinh2&lt;/code&gt; 、 &lt;code&gt;vmldAsin2&lt;/code&gt; 、 &lt;code&gt;vmldCosh2&lt;/code&gt; 、 &lt;code&gt;vmldCos2&lt;/code&gt; 、 &lt;code&gt;vmldAcosh2&lt;/code&gt; 、 &lt;code&gt;vmldAcos2&lt;/code&gt; 、 &lt;code&gt;vmlsExp4&lt;/code&gt; 、 &lt;code&gt;vmlsLn4&lt;/code&gt; 、 &lt;code&gt;vmlsLog104&lt;/code&gt; 、 &lt;code&gt;vmlsPow4&lt;/code&gt; 、 &lt;code&gt;vmlsTanh4&lt;/code&gt; を、 &lt;code&gt;vmlsTan4&lt;/code&gt; 、 &lt;code&gt;vmlsAtan4&lt;/code&gt; 、 &lt;code&gt;vmlsAtanh4&lt;/code&gt; 、 &lt;code&gt;vmlsCbrt4&lt;/code&gt; 、 &lt;code&gt;vmlsSinh4&lt;/code&gt; 、 &lt;code&gt;vmlsSin4&lt;/code&gt; 、 &lt;code&gt;vmlsAsinh4&lt;/code&gt; 、 &lt;code&gt;vmlsAsin4&lt;/code&gt; 、 &lt;code&gt;vmlsCosh4&lt;/code&gt; 、 &lt;code&gt;vmlsCos4&lt;/code&gt; 、 &lt;code&gt;vmlsAcosh4&lt;/code&gt; および &lt;code&gt;vmlsAcos4&lt;/code&gt; およびvmlsAcos4の場合</target>
        </trans-unit>
        <trans-unit id="16f9d8d14967dad5157f0d4d4177e77917294c63" translate="yes" xml:space="preserve">
          <source>GCC defines a macro &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; whenever it is generating code for a ColdFire target. The &lt;var&gt;arch&lt;/var&gt; in this macro is one of the</source>
          <target state="translated">GCCは、ColdFireターゲットのコードを生成するときはいつでも、マクロ &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 定義します。このマクロの &lt;var&gt;arch&lt;/var&gt; は、</target>
        </trans-unit>
        <trans-unit id="9690667ebb3c4d196426b91a67e183bca646b7c4" translate="yes" xml:space="preserve">
          <source>GCC defines a preprocessor macro for the specified &lt;var&gt;cpu&lt;/var&gt;. For the &amp;lsquo;</source>
          <target state="translated">GCCは、指定された &lt;var&gt;cpu&lt;/var&gt; のプリプロセッサマクロを定義します。のために '</target>
        </trans-unit>
        <trans-unit id="1ee4979d83e119fc65d0b3ce42180431e0b52daf" translate="yes" xml:space="preserve">
          <source>GCC defines several built-in macros so that the user code can test for the presence or absence of features. Almost any of the following built-in macros are deduced from device capabilities and thus triggered by the</source>
          <target state="translated">GCC は、ユーザーコードが機能の有無をテストできるように、いくつかの組み込みマクロを定義しています。以下の組み込みマクロのほとんどは、デバイスの機能から推論され、したがって</target>
        </trans-unit>
        <trans-unit id="07c2bb68cb370eca1e6a61c97987834533dcec03" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; when ColdFire target &lt;var&gt;cpu&lt;/var&gt; is selected. It also defines &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt;, where the value of &lt;var&gt;family&lt;/var&gt; is given by the table above.</source>
          <target state="translated">ColdFireターゲット &lt;var&gt;cpu&lt;/var&gt; が選択されている場合、GCCはマクロ &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; を定義します。また、 &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt; &lt;var&gt;family&lt;/var&gt; も定義しています。この場合、 &lt;var&gt;family&lt;/var&gt; の値は上記の表で与えられます。</target>
        </trans-unit>
        <trans-unit id="57340a71d3d941522f73fea99d6d51e3e8ce6ff1" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcfhwdiv__&lt;/code&gt; when this option is enabled.</source>
          <target state="translated">このオプションが有効な場合、GCCはマクロ &lt;code&gt;__mcfhwdiv__&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="6a9b1f894460a8c96f48083896afccfe85c9be79" translate="yes" xml:space="preserve">
          <source>GCC defines the macros &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; when tuning for 680x0 architecture &lt;var&gt;arch&lt;/var&gt;. It also defines &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; unless either</source>
          <target state="translated">GCCは、680x0アーキテクチャの &lt;var&gt;arch&lt;/var&gt; チューニングするときに、マクロ &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; および &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 定義します。どちらかでない限り、 &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; &lt;var&gt;arch&lt;/var&gt; も定義します</target>
        </trans-unit>
        <trans-unit id="2885698109b0288d9891eaf5f6f566e33bc93a28" translate="yes" xml:space="preserve">
          <source>GCC defines the preprocessor macro &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; for targets that have been updated to support this builtin.</source>
          <target state="translated">GCCは、この組み込みをサポートするように更新されたターゲットに対して、プリプロセッサマクロ &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="9502202879d2e8497b3ab7402351c2cfb4aba65d" translate="yes" xml:space="preserve">
          <source>GCC defines two macros based on the value of this option. The first is &lt;code&gt;_MIPS_ARCH&lt;/code&gt;, which gives the name of target architecture, as a string. The second has the form &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt;, where &lt;var&gt;foo&lt;/var&gt; is the capitalized value of &lt;code&gt;_MIPS_ARCH&lt;/code&gt;. For example,</source>
          <target state="translated">GCCは、このオプションの値に基づいて2つのマクロを定義します。1つ目は &lt;code&gt;_MIPS_ARCH&lt;/code&gt; で、ターゲットアーキテクチャの名前を文字列として提供します。2番目の形式は &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt; で、 &lt;var&gt;foo&lt;/var&gt; は &lt;code&gt;_MIPS_ARCH&lt;/code&gt; の大文字の値です。例えば、</target>
        </trans-unit>
        <trans-unit id="a26b5e085873721291414d2146a69ef3ff2df942" translate="yes" xml:space="preserve">
          <source>GCC depresses SSEx instructions when</source>
          <target state="translated">GCCがSSEx命令を抑制する場合</target>
        </trans-unit>
        <trans-unit id="f00d9db0f7babc17a8b2e93a16eaa154dca9484f" translate="yes" xml:space="preserve">
          <source>GCC does not inline any functions when not optimizing unless you specify the &amp;lsquo;</source>
          <target state="translated">GCCは、 'を指定しない限り、最適化しない場合は関数をインライン化しません。</target>
        </trans-unit>
        <trans-unit id="d979e47341cf32b9e9788a98df7db938c53659aa" translate="yes" xml:space="preserve">
          <source>GCC does not parse basic &lt;code&gt;asm&lt;/code&gt;&amp;rsquo;s &lt;var&gt;AssemblerInstructions&lt;/var&gt;, which means there is no way to communicate to the compiler what is happening inside them. GCC has no visibility of symbols in the &lt;code&gt;asm&lt;/code&gt; and may discard them as unreferenced. It also does not know about side effects of the assembler code, such as modifications to memory or registers. Unlike some compilers, GCC assumes that no changes to general purpose registers occur. This assumption may change in a future release.</source>
          <target state="translated">GCCは基本的な &lt;code&gt;asm&lt;/code&gt; の &lt;var&gt;AssemblerInstructions&lt;/var&gt; を解析しません。つまり、それらの内部で何が起こっているかをコンパイラーに伝える方法はありません。 GCCは &lt;code&gt;asm&lt;/code&gt; 内のシンボルを可視化せず、参照されていないものとして破棄する場合があります。また、メモリやレジスタの変更など、アセンブラコードの副作用についても認識しません。一部のコンパイラーとは異なり、GCCは汎用レジスターへの変更は発生しないと想定しています。この仮定は、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="cd46297b79a48028b406a3a22f8df3c38f23ed53" translate="yes" xml:space="preserve">
          <source>GCC does not provide the C library functionality associated with</source>
          <target state="translated">GCCでは、次のようなCライブラリ機能は提供されていません。</target>
        </trans-unit>
        <trans-unit id="96d71d57d6177ab6f3fc682f6b185f4541d680d8" translate="yes" xml:space="preserve">
          <source>GCC does not provide the library facilities required only of hosted implementations, nor yet all the facilities required by C99 of freestanding implementations on all platforms. To use the facilities of a hosted environment, you need to find them elsewhere (for example, in the GNU C library). See &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;Standard Libraries&lt;/a&gt;.</source>
          <target state="translated">GCCは、ホストされた実装のみに必要なライブラリ機能を提供していません。また、すべてのプラットフォームでのC99の自立型実装に必要なすべての機能も提供していません。ホスト環境の機能を使用するには、それらを他の場所（たとえば、GNU Cライブラリー）で見つける必要があります。&lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;標準ライブラリを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="86c923d0a51125464840f7ea1874cf6ab2974fb7" translate="yes" xml:space="preserve">
          <source>GCC does not substitute macro arguments when they appear inside of string constants. For example, the following macro in GCC</source>
          <target state="translated">GCCは、マクロの引数が文字列定数の中に現れた場合、マクロの引数を代用しません。例えば、GCC の次のマクロは</target>
        </trans-unit>
        <trans-unit id="42a91da8639ee03ec161a4bd756ad60809129b66" translate="yes" xml:space="preserve">
          <source>GCC does not support any extended integer types.</source>
          <target state="translated">GCCは拡張整数型をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="3ce5b628a549292da4090df5538cf2cd3541c673" translate="yes" xml:space="preserve">
          <source>GCC does not support using this feature with a non-static local variable since such variables do not have assembler names. If you are trying to put the variable in a particular register, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">GCCは、非静的ローカル変数でのこの機能の使用をサポートしていません。そのような変数にはアセンブラ名がないためです。変数を特定のレジスターに配置する場合は、&lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;明示的なレジスター変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="057dd4b479d4087929d93c02eca9edfef895599b" translate="yes" xml:space="preserve">
          <source>GCC does not use such values.</source>
          <target state="translated">GCCではそのような値は使用していません。</target>
        </trans-unit>
        <trans-unit id="6b22e4a77b39e5fcd62364faba592ec172555481" translate="yes" xml:space="preserve">
          <source>GCC emits warnings based on this attribute by default; use</source>
          <target state="translated">GCCはデフォルトでこの属性に基づいて警告を発します。</target>
        </trans-unit>
        <trans-unit id="6213b35197bfb3bb104e08212f01a4cf35332f2f" translate="yes" xml:space="preserve">
          <source>GCC enables this option by default. If you want to force the compiler to check if a variable is referenced, regardless of whether or not optimization is turned on, use the</source>
          <target state="translated">GCC では、デフォルトでこのオプションが有効になっています。最適化がオンになっているかどうかに関わらず、変数が参照されているかどうかをコンパイラに強制的にチェックさせたい場合は</target>
        </trans-unit>
        <trans-unit id="d7b2a859b296fb3f8914b78d7834ccf3e648a510" translate="yes" xml:space="preserve">
          <source>GCC has currently no support for non-fragile instance variables.</source>
          <target state="translated">GCCは現在のところ、非脆弱性インスタンス変数をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="9b64961814c7627599dfb66d9541dfbc1c55e8a3" translate="yes" xml:space="preserve">
          <source>GCC has long supported variadic macros, and used a different syntax that allowed you to give a name to the variable arguments just like any other argument. Here is an example:</source>
          <target state="translated">GCCは長い間バリアディックマクロをサポートしており、他の引数と同じように変数引数に名前を付けることができる別の構文を使用していました。ここに例を示します。</target>
        </trans-unit>
        <trans-unit id="e677a4ecf07d49ec983c792d6fd35d17489c7528" translate="yes" xml:space="preserve">
          <source>GCC has the following spec strings built into it. Spec files can override these strings or create their own. Note that individual targets can also add their own spec strings to this list.</source>
          <target state="translated">GCCには、以下の仕様文字列が組み込まれています。Spec ファイルは、これらの文字列をオーバーライドしたり、独自の文字列を作成したりすることができます。個々のターゲットは、独自の仕様文字列をこのリストに追加することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ed8411601030aef9d10cc9d6209db6260f4d910d" translate="yes" xml:space="preserve">
          <source>GCC implements a limited buffer overflow protection mechanism that can prevent some buffer overflow attacks by determining the sizes of objects into which data is about to be written and preventing the writes when the size isn&amp;rsquo;t sufficient. The built-in functions described below yield the best results when used together and when optimization is enabled. For example, to detect object sizes across function boundaries or to follow pointer assignments through non-trivial control flow they rely on various optimization passes enabled with</source>
          <target state="translated">GCCは、データが書き込もうとするオブジェクトのサイズを決定し、サイズが十分でない場合に書き込みを防ぐことにより、一部のバッファーオーバーフロー攻撃を防ぐことができる制限付きバッファーオーバーフロー保護メカニズムを実装しています。以下で説明する組み込み関数は、一緒に使用した場合、および最適化が有効になっている場合に最良の結果をもたらします。たとえば、関数の境界を越えてオブジェクトのサイズを検出したり、重要な制御フローを通じてポインタの割り当てを追跡したりするには、次のようにして有効化されたさまざまな最適化パスに依存します。</target>
        </trans-unit>
        <trans-unit id="c63f8d617f5fcd74378c430997fb1de4655a5a57" translate="yes" xml:space="preserve">
          <source>GCC implements extensions for C as described in the ARM C Language Extensions (ACLE) specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCCはCの拡張機能を実装してい&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;ます&lt;/a&gt;。これは、http： //infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdfにあるARM C言語拡張機能（ACLE）仕様で説明されています。</target>
        </trans-unit>
        <trans-unit id="293bbd3b2e69a9d930833e11f1b427e7997876a6" translate="yes" xml:space="preserve">
          <source>GCC implements for both C and C++ a syntactic extension to implement the &lt;code&gt;offsetof&lt;/code&gt; macro.</source>
          <target state="translated">GCCは、CとC ++の両方に対して、 &lt;code&gt;offsetof&lt;/code&gt; マクロを実装する構文拡張を実装します。</target>
        </trans-unit>
        <trans-unit id="322077390825044afaea930b7263992ddcea81e8" translate="yes" xml:space="preserve">
          <source>GCC implements taking the address of a nested function using a technique called &lt;em&gt;trampolines&lt;/em&gt;. This technique was described in Lexical Closures for C++ (Thomas M. Breuel, USENIX C++ Conference Proceedings, October 17-21, 1988).</source>
          <target state="translated">GCCは、&lt;em&gt;trampolines&lt;/em&gt;と呼ばれる手法を使用して、ネストされた関数のアドレスを取ることを実装します。この手法は、C ++の字句閉包で説明されています（Thomas M. Breuel、USENIX C ++ Conference Proceedings、1988年10月17〜21日）。</target>
        </trans-unit>
        <trans-unit id="239348ac99d6992297a72fcc17bd9b383a471db0" translate="yes" xml:space="preserve">
          <source>GCC implements the ARMv8-M Security Extensions as described in the ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCCは、&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http&lt;/a&gt;：//infocenter.arm.com/help/topic/com.arm.docにある「ARMv8-M Security Extensions：Requirements on Development Tools Engineering Specification」で説明されているように、ARMv8-M Security Extensionsを実装しています。 ecm0359818 / ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf。</target>
        </trans-unit>
        <trans-unit id="7c1d6efdb055c03457ac985aa41eeb676f9d1c1c" translate="yes" xml:space="preserve">
          <source>GCC implements three different semantics of declaring a function inline. One is available with</source>
          <target state="translated">GCCは、関数をインラインで宣言する際に、3つの異なるセマンティクスを実装しています。一つは</target>
        </trans-unit>
        <trans-unit id="16fab68e571685f848321494bfa65aa76fa12ecf" translate="yes" xml:space="preserve">
          <source>GCC includes built-in versions of many of the functions in the standard C library. These functions come in two forms: one whose names start with the &lt;code&gt;__builtin_&lt;/code&gt; prefix, and the other without. Both forms have the same type (including prototype), the same address (when their address is taken), and the same meaning as the C library functions even if you specify the</source>
          <target state="translated">GCCには、標準Cライブラリの多くの関数の組み込みバージョンが含まれています。これらの関数には2つの形式があります。1つは &lt;code&gt;__builtin_&lt;/code&gt; 接頭辞で始まる名前、もう1つは名前のない名前です。両方の形式は同じタイプ（プロトタイプを含む）、同じアドレス（アドレスが取得された場合）、およびCライブラリ関数と同じ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="6ddb06bf023a460b3469518f6828ceb9799c46e8" translate="yes" xml:space="preserve">
          <source>GCC is incompatible with traditional C.</source>
          <target state="translated">GCCは従来のCとは相性が悪い。</target>
        </trans-unit>
        <trans-unit id="d28b24326033740593178727cd1510ca18099b74" translate="yes" xml:space="preserve">
          <source>GCC is only limited by available memory.</source>
          <target state="translated">GCCは利用可能なメモリが限られています。</target>
        </trans-unit>
        <trans-unit id="e1b7ed70d92a385236df81656270c5df961819cc" translate="yes" xml:space="preserve">
          <source>GCC needs to install corrected versions of some system header files. This is because most target systems have some header files that won&amp;rsquo;t work with GCC unless they are changed. Some have bugs, some are incompatible with ISO C, and some depend on special features of other compilers.</source>
          <target state="translated">GCCは、一部のシステムヘッダーファイルの修正バージョンをインストールする必要があります。これは、ほとんどのターゲットシステムに、変更しないとGCCで動作しないヘッダーファイルがあるためです。バグのあるもの、ISO Cと互換性のないもの、他のコンパイラの特別な機能に依存しているものがあります。</target>
        </trans-unit>
        <trans-unit id="6fec00d5e695a6ba7008f039024af2f2354b9175" translate="yes" xml:space="preserve">
          <source>GCC no longer supports DWARF Version 1, which is substantially different than Version 2 and later. For historical reasons, some other DWARF-related options such as</source>
          <target state="translated">GCCは、バージョン2以降とは実質的に異なるDWARFバージョン1をサポートしなくなりました。歴史的な理由から、他のいくつかのDWARF関連のオプションでは</target>
        </trans-unit>
        <trans-unit id="9571fcf4d32ba7634429d5420351196a13337bf1" translate="yes" xml:space="preserve">
          <source>GCC normally defines &lt;code&gt;__STDC__&lt;/code&gt; to be 1, and in addition defines &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; if you specify the</source>
          <target state="translated">GCCは通常、 &lt;code&gt;__STDC__&lt;/code&gt; &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; 1と定義し、さらに__STRICT_ANSI__を定義します。</target>
        </trans-unit>
        <trans-unit id="d2a04d28db5bb4fd272285d6f2261f1af937b1aa" translate="yes" xml:space="preserve">
          <source>GCC normally generates special code to handle certain built-in functions more efficiently; for instance, calls to &lt;code&gt;alloca&lt;/code&gt; may become single instructions which adjust the stack directly, and calls to &lt;code&gt;memcpy&lt;/code&gt; may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a built-in function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with</source>
          <target state="translated">GCCは通常、特定の組み込み関数をより効率的に処理するための特別なコードを生成します。たとえば、 &lt;code&gt;alloca&lt;/code&gt; の呼び出しは、スタックを直接調整する単一の命令になり、 &lt;code&gt;memcpy&lt;/code&gt; の呼び出しは、インラインコピーループになる場合があります。多くの場合、結果のコードは小さくて高速ですが、関数呼び出しはそのように表示されないため、それらの呼び出しにブレークポイントを設定したり、別のライブラリとリンクして関数の動作を変更したりすることはできません。さらに、関数が組み込み関数として認識されると、GCCはその関数に関する情報を使用して、その関数への呼び出しに関する問題について警告したり、結果のコードにその関数への呼び出しが含まれていても、より効率的なコードを生成したりできます。たとえば、警告は</target>
        </trans-unit>
        <trans-unit id="7e6e1ac548faaad8ae2131d82037c03b74f72b7e" translate="yes" xml:space="preserve">
          <source>GCC normally makes string constants read-only. If several identical-looking string constants are used, GCC stores only one copy of the string.</source>
          <target state="translated">GCCは通常、文字列定数を読み取り専用にします。複数の同一の文字列定数が使用されている場合、GCCはその文字列のコピーを1つだけ保存します。</target>
        </trans-unit>
        <trans-unit id="11a713f18e4fa0802eb282a6537925d48c0259a3" translate="yes" xml:space="preserve">
          <source>GCC normally uses a single instruction to load values from the GOT. While this is relatively efficient, it only works if the GOT is smaller than about 64k. Anything larger causes the linker to report an error such as:</source>
          <target state="translated">GCCは通常、GOTから値をロードするために1つの命令を使用します。これは比較的効率的ですが、GOT が約 64k よりも小さい場合にのみ動作します。これ以上小さくなると、リンカは以下のようなエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="be424d75f5ffc48b72e433597659af0ae3069a92" translate="yes" xml:space="preserve">
          <source>GCC option.</source>
          <target state="translated">GCCオプション。</target>
        </trans-unit>
        <trans-unit id="0cb280cc3350dd85b51b4e6912bba246b1815ba4" translate="yes" xml:space="preserve">
          <source>GCC permits a C structure to have no members:</source>
          <target state="translated">GCCは、C構造体にメンバーがいないことを認めています。</target>
        </trans-unit>
        <trans-unit id="410ccd5268fc842081ec500688897d4eab9d507c" translate="yes" xml:space="preserve">
          <source>GCC provides a couple of special builtin functions to aid in the writing of interrupt handlers in C.</source>
          <target state="translated">GCCはC言語の割り込みハンドラの記述を支援するために、いくつかの特別な組み込み関数を提供しています。</target>
        </trans-unit>
        <trans-unit id="9a84666be4b2834544f27c65de6a453c576dd60a" translate="yes" xml:space="preserve">
          <source>GCC provides a large number of built-in functions other than the ones mentioned above. Some of these are for internal use in the processing of exceptions or variable-length argument lists and are not documented here because they may change from time to time; we do not recommend general use of these functions.</source>
          <target state="translated">GCC には、上記以外にも多くの組み込み関数があります。これらの中には例外や可変長の引数リストの処理で内部的に使用するためのものもありますが、これらは随時変更される可能性があるため、ここでは説明しません。</target>
        </trans-unit>
        <trans-unit id="dd6c408349b302ebed79b324cb6148ad8750cb77" translate="yes" xml:space="preserve">
          <source>GCC provides an interface for the PowerPC family of processors to access the AltiVec operations described in Motorola&amp;rsquo;s AltiVec Programming Interface Manual. The interface is made available by including &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCCは、MotorolaのAltiVecプログラミングインターフェイスマニュアルで説明されているAltiVec操作にアクセスするためのPowerPCファミリーのプロセッサ用のインターフェイスを提供します。インターフェイスは、 &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; をインクルードして使用することで利用可能になります</target>
        </trans-unit>
        <trans-unit id="f17fd1e9e7781f60f577293ffbb0fbe50f2aa38c" translate="yes" xml:space="preserve">
          <source>GCC provides an interface to selected machine instructions from the picoChip instruction set.</source>
          <target state="translated">GCCは、picoChip命令セットから選択されたマシン命令へのインターフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="5ddbeccb51a8011bd71cee78329676c8768e012d" translate="yes" xml:space="preserve">
          <source>GCC provides built-in versions of the ISO C99 floating-point comparison macros that avoid raising exceptions for unordered operands. They have the same names as the standard macros ( &lt;code&gt;isgreater&lt;/code&gt;, &lt;code&gt;isgreaterequal&lt;/code&gt;, &lt;code&gt;isless&lt;/code&gt;, &lt;code&gt;islessequal&lt;/code&gt;, &lt;code&gt;islessgreater&lt;/code&gt;, and &lt;code&gt;isunordered&lt;/code&gt;) , with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. We intend for a library implementor to be able to simply &lt;code&gt;#define&lt;/code&gt; each standard macro to its built-in equivalent. In the same fashion, GCC provides &lt;code&gt;fpclassify&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;, &lt;code&gt;isinf_sign&lt;/code&gt;, &lt;code&gt;isnormal&lt;/code&gt; and &lt;code&gt;signbit&lt;/code&gt; built-ins used with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. The &lt;code&gt;isinf&lt;/code&gt; and &lt;code&gt;isnan&lt;/code&gt; built-in functions appear both with and without the &lt;code&gt;__builtin_&lt;/code&gt; prefix.</source>
          <target state="translated">GCCは、ISO C99浮動小数点比較マクロの組み込みバージョンを提供し、順序付けられていないオペランドの例外の発生を回避します。彼らは、標準マクロ（と同じ名前を持つ &lt;code&gt;isgreater&lt;/code&gt; 、 &lt;code&gt;isgreaterequal&lt;/code&gt; 、 &lt;code&gt;isless&lt;/code&gt; 、 &lt;code&gt;islessequal&lt;/code&gt; 、 &lt;code&gt;islessgreater&lt;/code&gt; 、および &lt;code&gt;isunordered&lt;/code&gt; で、） &lt;code&gt;__builtin_&lt;/code&gt; は接頭辞。ライブラリの実装者が、各標準マクロを組み込みの同等のマクロに &lt;code&gt;#define&lt;/code&gt; できるようにするつもりです。同じ方法では、GCCは提供 &lt;code&gt;fpclassify&lt;/code&gt; 、 &lt;code&gt;isfinite&lt;/code&gt; の、 &lt;code&gt;isinf_sign&lt;/code&gt; 、 &lt;code&gt;isnormal&lt;/code&gt; かつ &lt;code&gt;signbit&lt;/code&gt; を &lt;code&gt;__builtin_&lt;/code&gt; を前に付けて使用するビルトイン。 &lt;code&gt;isinf&lt;/code&gt; と &lt;code&gt;isnan&lt;/code&gt; 組み込み関数は、ととなしの両方に表示され &lt;code&gt;__builtin_&lt;/code&gt; 接頭辞。</target>
        </trans-unit>
        <trans-unit id="2050dfe83adc5c7628805205b83a18bf6445e1ea" translate="yes" xml:space="preserve">
          <source>GCC provides extensions for the SPU processor as described in the Sony/Toshiba/IBM SPU Language Extensions Specification. GCC&amp;rsquo;s implementation differs in several ways.</source>
          <target state="translated">GCCは、Sony / Toshiba / IBM SPU言語拡張仕様で説明されているように、SPUプロセッサーの拡張機能を提供します。GCCの実装はいくつかの点で異なります。</target>
        </trans-unit>
        <trans-unit id="e32059373d4f323b9500c52b6c9f30c837d92c67" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access certain instructions of the TI C6X processors. These intrinsics, listed below, are available after inclusion of the &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; header file. They map directly to C6X instructions.</source>
          <target state="translated">GCCは、TI C6Xプロセッサの特定の命令にアクセスするための組み込み関数を提供します。以下にリストされているこれらの組み込み関数は、 &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; ヘッダーファイルをインクルードした後に使用できます。それらはC6X命令に直接マップされます。</target>
        </trans-unit>
        <trans-unit id="4b78e24ee2fcd774983a8458d70a096c1f01f9ae" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILE-Gx processor. The intrinsics are of the form:</source>
          <target state="translated">GCC は、TILE-Gx プロセッサのすべての命令にアクセスするための組込み関数を提供します。内部構造は次のような形をしています。</target>
        </trans-unit>
        <trans-unit id="9929eef1ea9191b05967ff4d40ec8ba33acf1914" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILEPro processor. The intrinsics are of the form:</source>
          <target state="translated">GCCは、TILEProプロセッサのすべての命令にアクセスするための組込み関数を提供します。内部構造は、次のような形をしています。</target>
        </trans-unit>
        <trans-unit id="ce1f47a40b55c4bca6e7d75e5dd0559de5a981c1" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the MSA MIPS SIMD Architecture. The interface is made available by including &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCCは、MSA MIPS SIMDアーキテクチャによって提供されるSIMD命令にアクセスするための組み込み関数を提供します。インターフェイスは &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; をインクルードして使用することで利用可能になります</target>
        </trans-unit>
        <trans-unit id="40749dfbc24dc6f5a0b131fccc39dc31c09ec61c" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the ST Microelectronics Loongson-2E and -2F processors. These intrinsics, available after inclusion of the &lt;code&gt;loongson.h&lt;/code&gt; header file, operate on the following 64-bit vector types:</source>
          <target state="translated">GCCは、ST Microelectronics Loongson-2Eおよび-2Fプロセッサーが提供するSIMD命令にアクセスするための組み込み関数を提供します。 &lt;code&gt;loongson.h&lt;/code&gt; ヘッダーファイルのインクルード後に利用可能なこれらの組み込み関数は、次の64ビットベクトルタイプで動作します。</target>
        </trans-unit>
        <trans-unit id="924dd6007d38ce7b6e1d6cc29626f87cdabebfe1" translate="yes" xml:space="preserve">
          <source>GCC provides many FR-V-specific built-in functions. In general, these functions are intended to be compatible with those described by FR-V Family, Softune C/C++ Compiler Manual (V6), Fujitsu Semiconductor. The two exceptions are &lt;code&gt;__MDUNPACKH&lt;/code&gt; and &lt;code&gt;__MBTOHE&lt;/code&gt;, the GCC forms of which pass 128-bit values by pointer rather than by value.</source>
          <target state="translated">GCCは多くのFR-V固有の組み込み関数を提供します。一般に、これらの関数は、FR-Vファミリ、Softune C / C ++コンパイラマニュアル（V6）、富士通セミコンダクターで説明されているものとの互換性を目的としています。2つの例外は &lt;code&gt;__MDUNPACKH&lt;/code&gt; と &lt;code&gt;__MBTOHE&lt;/code&gt; です。これらのGCC形式では、128ビット値を値ではなくポインタで渡します。</target>
        </trans-unit>
        <trans-unit id="9e2fa02f56a7975c68bfa6e70c41727409fe7b0c" translate="yes" xml:space="preserve">
          <source>GCC provides other MIPS-specific built-in functions:</source>
          <target state="translated">GCCは、他のMIPS固有の組み込み関数を提供します。</target>
        </trans-unit>
        <trans-unit id="c10a95a94bae56390209bcb97b207903625a1bc4" translate="yes" xml:space="preserve">
          <source>GCC provides the built-in functions &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; which are similar to, but not interchangeable with, the C library functions &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;. The built-in versions are used internally by GCC&amp;rsquo;s libraries to implement exception handling on some targets. You should use the standard C library functions declared in &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; in user code instead of the builtins.</source>
          <target state="translated">GCCは、Cライブラリ関数 &lt;code&gt;setjmp&lt;/code&gt; および &lt;code&gt;longjmp&lt;/code&gt; に類似しているが互換性がない &lt;code&gt;__builtin_longjmp&lt;/code&gt; 関数 &lt;code&gt;__builtin_setjmp&lt;/code&gt; および__builtin_longjmpを提供しています。組み込みバージョンは、一部のターゲットで例外処理を実装するためにGCCのライブラリによって内部的に使用されます。組み込み関数ではなく、ユーザーコードの &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; で宣言されている標準Cライブラリ関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9735e9559d39719652bb957e983b7d2a3d2f7126" translate="yes" xml:space="preserve">
          <source>GCC provides three magic constants that hold the name of the current function as a string. In C++11 and later modes, all three are treated as constant expressions and can be used in &lt;code&gt;constexpr&lt;/code&gt; constexts. The first of these constants is &lt;code&gt;__func__&lt;/code&gt;, which is part of the C99 standard:</source>
          <target state="translated">GCCは、現在の関数の名前を文字列として保持する3つの魔法の定数を提供します。C ++ 11以降のモードでは、3つすべてが定数式として扱われ、 &lt;code&gt;constexpr&lt;/code&gt; コンテキストで使用できます。これらの定数の最初は、C99標準の一部である &lt;code&gt;__func__&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2948277f494886df96fe31449754e2666c1dabe5" translate="yes" xml:space="preserve">
          <source>GCC provides two interfaces for accessing the Hardware Transactional Memory (HTM) instructions available on some of the PowerPC family of processors (eg, POWER8). The two interfaces come in a low level interface, consisting of built-in functions specific to PowerPC and a higher level interface consisting of inline functions that are common between PowerPC and S/390.</source>
          <target state="translated">GCC は、PowerPC ファミリのいくつかのプロセッサ(例えば POWER8)で利用可能なハードウェア・トランザクション・メモリ(HTM)命令にアクセスするための 2 つのインタフェースを提供します。この2つのインタフェースには、PowerPC固有の組み込み関数からなる低レベルのインタフェースと、PowerPCとS/390の間で共通のインライン関数からなる高レベルのインタフェースがあります。</target>
        </trans-unit>
        <trans-unit id="f29e392d59a7180cc6e4238e88b7157ffcf6417f" translate="yes" xml:space="preserve">
          <source>GCC stands for &amp;ldquo;GNU Compiler Collection&amp;rdquo;. GCC is an integrated distribution of compilers for several major programming languages. These languages currently include C, C++, Objective-C, Objective-C++, Fortran, Ada, D, Go, and BRIG (HSAIL).</source>
          <target state="translated">GCCは「GNU Compiler Collection」の略です。GCCは、いくつかの主要なプログラミング言語用のコンパイラの統合ディストリビューションです。これらの言語には現在、C、C ++、Objective-C、Objective-C ++、Fortran、Ada、D、Go、およびBRIG（HSAIL）が含まれます。</target>
        </trans-unit>
        <trans-unit id="1d5a85fa7b27fa126424357ffe5ddd8aadcd2aa6" translate="yes" xml:space="preserve">
          <source>GCC support of decimal float as specified by the draft technical report is incomplete:</source>
          <target state="translated">技術報告書草案で規定されている10進数の浮動小数点のGCCサポートは不完全である。</target>
        </trans-unit>
        <trans-unit id="28561e4b3e7debdbfb6dbdfe238413f5b85b54ce" translate="yes" xml:space="preserve">
          <source>GCC support of fixed-point types as specified by the draft technical report is incomplete:</source>
          <target state="translated">技術報告書草案で規定されている定点型のGCCサポートは不完全である。</target>
        </trans-unit>
        <trans-unit id="1fa5de60932a0f2deade437763dee9d9034d0c2f" translate="yes" xml:space="preserve">
          <source>GCC supports &amp;ldquo;traditional&amp;rdquo; Objective-C (also known as &amp;ldquo;Objective-C 1.0&amp;rdquo;) and contains support for the Objective-C exception and synchronization syntax. It has also support for a number of &amp;ldquo;Objective-C 2.0&amp;rdquo; language extensions, including properties, fast enumeration (only for Objective-C), method attributes and the @optional and @required keywords in protocols. GCC supports Objective-C++ and features available in Objective-C are also available in Objective-C++.</source>
          <target state="translated">GCCは「従来の」Objective-C（「Objective-C 1.0」とも呼ばれる）をサポートし、Objective-C例外および同期構文のサポートを含みます。また、プロパティ、高速列挙（Objective-Cのみ）、メソッド属性、プロトコルの@optionalキーワードおよび@requiredキーワードなど、多数の「Objective-C 2.0」言語拡張もサポートしています。GCCはObjective-C ++をサポートしており、Objective-Cで利用可能な機能はObjective-C ++でも利用できます。</target>
        </trans-unit>
        <trans-unit id="830690076ebfb70e332b381ddb9fe46655004637" translate="yes" xml:space="preserve">
          <source>GCC supports MIPS DSP operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCCは両方の一般的なベクトルの拡張機能を使用してMIPS DSP演算をサポートしています（参照&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;ベクトル・エクステンションを&lt;/a&gt;）および組み込み関数MIPS固有のコレクション。どちらの種類のサポートも、</target>
        </trans-unit>
        <trans-unit id="8d83e55eff0bd290fe83057edfb4aff0d4da11fc" translate="yes" xml:space="preserve">
          <source>GCC supports SIMD operations on the SPARC using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) as well as built-in functions for the SPARC Visual Instruction Set (VIS). When you use the</source>
          <target state="translated">GCCは、一般的なベクトルの拡張機能の両方を使用して（参照SPARC上のSIMD演算をサポートしている&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;ベクトル・エクステンションを&lt;/a&gt; SPARCビジュアル命令セット（VIS）のため）だけでなく、組み込み関数。あなたが使うとき</target>
        </trans-unit>
        <trans-unit id="76e5e7f27add586f752fd2c88bf216b480271ed7" translate="yes" xml:space="preserve">
          <source>GCC supports a &lt;code&gt;#pragma&lt;/code&gt; directive that changes the name used in assembly for a given declaration. While this pragma is supported on all platforms, it is intended primarily to provide compatibility with the Solaris system headers. This effect can also be achieved using the asm labels extension (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;).</source>
          <target state="translated">GCCは、指定された宣言のアセンブリで使用される名前を変更する &lt;code&gt;#pragma&lt;/code&gt; ディレクティブをサポートしています。このプラグマはすべてのプラットフォームでサポートされていますが、主にSolarisシステムヘッダーとの互換性を提供することを目的としています。この効果は、asmラベル拡張を使用して実現することもできます（&lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asmラベルを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="498314540c8d67676764e9f766eda8fd96a7daed" translate="yes" xml:space="preserve">
          <source>GCC supports a number of command-line options that control adding run-time instrumentation to the code it normally generates. For example, one purpose of instrumentation is collect profiling statistics for use in finding program hot spots, code coverage analysis, or profile-guided optimizations. Another class of program instrumentation is adding run-time checking to detect programming errors like invalid pointer dereferences or out-of-bounds array accesses, as well as deliberately hostile attacks such as stack smashing or C++ vtable hijacking. There is also a general hook which can be used to implement other forms of tracing or function-level instrumentation for debug or program analysis purposes.</source>
          <target state="translated">GCC は、通常生成するコードにランタイム計測器を追加する制御を行うコマンドラインオプションを多数サポートしています。例えば、インストルメンテーションの目的の1つは、プログラムのホットスポットの発見、コードカバレッジ分析、プロファイルガイド付き最適化に使用するためのプロファイリング統計情報を収集することです。プログラムのインストルメンテーションの別のクラスには、無効なポインタのディファレンスや範囲外の配列アクセスなどのプログラミング・エラーや、スタック・スマッシングや C++vtable ハイジャックなどの意図的な敵対的な攻撃を検出するためのランタイム・チェックを追加する機能があります。また、デバッグやプログラム解析を目的とした他の形式のトレースや関数レベルのインストルメンテーションを実装するために使用できる一般的なフックもあります。</target>
        </trans-unit>
        <trans-unit id="1030e6dea2c81b69bdc7270b03b39b5f569ad6fa" translate="yes" xml:space="preserve">
          <source>GCC supports a variant of the o32 ABI in which floating-point registers are 64 rather than 32 bits wide. You can select this combination with</source>
          <target state="translated">GCCは、浮動小数点レジスタが32ビット幅ではなく64ビット幅のo32 ABIの変形をサポートしています。この組み合わせは</target>
        </trans-unit>
        <trans-unit id="c3965449e7a5dc4d5ed8a9dc3199dec909c35dc5" translate="yes" xml:space="preserve">
          <source>GCC supports only two&amp;rsquo;s complement integer types, and all bit patterns are ordinary values.</source>
          <target state="translated">GCCは2の補数の整数型のみをサポートし、すべてのビットパターンは通常の値です。</target>
        </trans-unit>
        <trans-unit id="83dd0c21621e0a6e0dd523c863cbfaef04449bd4" translate="yes" xml:space="preserve">
          <source>GCC supports paired-single operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCCの支持体は、ペア、単一の汎用ベクトル拡張（参照両方使用した操作&lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;ベクトル・エクステンション&lt;/a&gt;）と組み込み関数MIPS固有のコレクションを。どちらの種類のサポートも、</target>
        </trans-unit>
        <trans-unit id="b55fc398fe2655fec7265522ba909be632a50b88" translate="yes" xml:space="preserve">
          <source>GCC supports several types of pragmas, primarily in order to compile code originally written for other compilers. Note that in general we do not recommend the use of pragmas; See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for further explanation.</source>
          <target state="translated">GCCは、主に他のコンパイラー用に最初に作成されたコードをコンパイルするために、いくつかのタイプのプラグマをサポートしています。通常、プラグマの使用はお勧めしません。詳細については、&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="653525fcb8a016916ca28e1dd65b18ab8839e4b5" translate="yes" xml:space="preserve">
          <source>GCC supports some of the RX instructions which cannot be expressed in the C programming language via the use of built-in functions. The following functions are supported:</source>
          <target state="translated">GCCは、C言語では表現できないいくつかのRX命令を組み込み関数を使ってサポートしています。サポートされている関数は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="4b0cba78b946248aec959caf8a965144462518ce" translate="yes" xml:space="preserve">
          <source>GCC supports the D 2.0 programming language. The D language itself is currently defined by its reference implementation and supporting language specification, described at &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt;.</source>
          <target state="translated">GCCはD 2.0プログラミング言語をサポートしています。D言語自体は現在、&lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https：//dlang.org/spec/spec.html&lt;/a&gt;で説明されているリファレンス実装とサポート言語仕様によって定義されています。</target>
        </trans-unit>
        <trans-unit id="359d53772696a2b7864fe27fe3565593d8a4b28c" translate="yes" xml:space="preserve">
          <source>GCC supports the following AVR devices and ISAs:</source>
          <target state="translated">GCCは以下のAVRデバイスとISAをサポートしています。</target>
        </trans-unit>
        <trans-unit id="2ea7c76cda0c4fbb899bd829aa15b4c8a69297f6" translate="yes" xml:space="preserve">
          <source>GCC supports the original ISO C++ standard published in 1998, and the 2011 and 2014 revisions.</source>
          <target state="translated">GCCは、1998年に発行されたオリジナルのISO C++規格と、2011年と2014年の改訂版をサポートしています。</target>
        </trans-unit>
        <trans-unit id="858a69c7492112ce45741ecc79e61821fd61a803" translate="yes" xml:space="preserve">
          <source>GCC supports these options when compiling for C-SKY V2 processors.</source>
          <target state="translated">GCCは、C-SKY V2プロセッサのコンパイル時にこれらのオプションをサポートしています。</target>
        </trans-unit>
        <trans-unit id="0dc67ad6d4b46256a65720385ae1177b91b75554" translate="yes" xml:space="preserve">
          <source>GCC supports two forms of SVE code generation: &amp;ldquo;vector-length agnostic&amp;rdquo; output that works with any size of vector register and &amp;ldquo;vector-length specific&amp;rdquo; output that allows GCC to make assumptions about the vector length when it is useful for optimization reasons. The possible values of &amp;lsquo;</source>
          <target state="translated">GCCは、SVEコード生成の2つの形式をサポートしています。任意のサイズのベクトルレジスターで機能する「ベクトル長に依存しない」出力と、最適化の理由で役立つ場合にGCCがベクトル長について仮定できる「ベクトル長固有」出力です。'の可能な値</target>
        </trans-unit>
        <trans-unit id="5b3ded850043ac176423c8bd10dd3fbbab6dc5cd" translate="yes" xml:space="preserve">
          <source>GCC treats all characters of identifiers as significant. According to K&amp;amp;R-1 (2.2), &amp;ldquo;No more than the first eight characters are significant, although more may be used.&amp;rdquo;. Also according to K&amp;amp;R-1 (2.2), &amp;ldquo;An identifier is a sequence of letters and digits; the first character must be a letter. The underscore _ counts as a letter.&amp;rdquo;, but GCC also allows dollar signs in identifiers.</source>
          <target state="translated">GCCは、識別子のすべての文字を重要なものとして扱います。K＆R-1（2.2）によると、「重要なのは最初の8文字のみですが、それ以上使用してもかまいません。」また、K＆R-1（2.2）によれば、「識別子は文字と数字のシーケンスです。最初の文字は文字でなければなりません。アンダースコア_は文字としてカウントされます。」ですが、GCCでは識別子にドル記号も使用できます。</target>
        </trans-unit>
        <trans-unit id="feaee8cb866302ba1b5ec59a1ce37d673602a1f3" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code (as if by</source>
          <target state="translated">GCCは &lt;var&gt;name&lt;/var&gt; を使用して、アセンブリコードを生成するときに、どのような命令を発行できるかを決定します</target>
        </trans-unit>
        <trans-unit id="66e1ddf3758925ad2362fd6f220c229932999055" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code. If</source>
          <target state="translated">GCCは &lt;var&gt;name&lt;/var&gt; を使用して、アセンブリコードの生成時に発行できる命令の種類を決定します。もし</target>
        </trans-unit>
        <trans-unit id="813ae2789d4b6769128e82ee496ab87522d87f2b" translate="yes" xml:space="preserve">
          <source>GCC uses a garbage collector to manage its own memory allocation. This parameter specifies the minimum percentage by which the garbage collector&amp;rsquo;s heap should be allowed to expand between collections. Tuning this may improve compilation speed; it has no effect on code generation.</source>
          <target state="translated">GCCはガベージコレクターを使用して、独自のメモリ割り当てを管理します。このパラメーターは、ガベージコレクターのヒープがコレクション間で拡張できる最小の割合を指定します。これを調整すると、コンパイル速度が向上する場合があります。コード生成には影響しません。</target>
        </trans-unit>
        <trans-unit id="ae9ac11b129e57b155bc25157be869b1b76e80ad" translate="yes" xml:space="preserve">
          <source>GCC uses corrected versions of system header files. This is necessary, but doesn&amp;rsquo;t always work smoothly.</source>
          <target state="translated">GCCは修正されたバージョンのシステムヘッダーファイルを使用します。これは必要ですが、常にスムーズに機能するとは限りません。</target>
        </trans-unit>
        <trans-unit id="819a72ed7eaf70f991d756c9fa760994a62ab526" translate="yes" xml:space="preserve">
          <source>GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (</source>
          <target state="translated">GCCは、プロファイリングフィードバックが提供されていない場合に、分岐確率を推測するためにヒューリスティックを使用します (</target>
        </trans-unit>
        <trans-unit id="1a8376e3c4e7645e0b124141064b06d15d9df6a1" translate="yes" xml:space="preserve">
          <source>GCC uses the system C library, which might not be compliant with the ISO C standard.</source>
          <target state="translated">GCCはシステムCライブラリを使用しているため、ISO C規格に準拠していない可能性があります。</target>
        </trans-unit>
        <trans-unit id="ca6cd448f1a33799ac2da1a0d9dfa000cd6841ec" translate="yes" xml:space="preserve">
          <source>GCC will not inline any functions if the</source>
          <target state="translated">の場合、GCC は関数をインライン化しません。</target>
        </trans-unit>
        <trans-unit id="8a47996357771546a1d05e5991be4fe03520b6e5" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s default behavior is to emit all inline functions with the &lt;code&gt;dllexport&lt;/code&gt; attribute. Since this can cause object file-size bloat, you can use</source>
          <target state="translated">GCCのデフォルトの動作は、 &lt;code&gt;dllexport&lt;/code&gt; 属性を持つすべてのインライン関数を発行することです。これはオブジェクトのファイルサイズの膨張を引き起こす可能性があるため、使用できます</target>
        </trans-unit>
        <trans-unit id="af8e45be98e36024842dc1bd8893718108d0574b" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s implementation of the high-level language interface available from C and C++ code differs from Motorola&amp;rsquo;s documentation in several ways.</source>
          <target state="translated">CおよびC ++コードから利用可能なGCCの高水準言語インターフェースの実装は、いくつかの点でモトローラのドキュメントと異なります。</target>
        </trans-unit>
        <trans-unit id="e78ca1e1182b55c5bde4b195b5d85015058a98d0" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers do not treat this code like the non-volatile code in the earlier examples. They do not move it out of loops or omit it on the assumption that the result from a previous call is still valid.</source>
          <target state="translated">GCCのオプティマイザは、このコードを以前の例の不揮発性コードのように扱いません。前の呼び出しからの結果がまだ有効であるという前提で、ループの外に移動したり、省略したりしません。</target>
        </trans-unit>
        <trans-unit id="dbc61f28ee0b681eff97897cb82a2c8d282dc076" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers sometimes discard &lt;code&gt;asm&lt;/code&gt; statements if they determine there is no need for the output variables. Also, the optimizers may move code out of loops if they believe that the code will always return the same result (i.e. none of its input values change between calls). Using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables these optimizations. &lt;code&gt;asm&lt;/code&gt; statements that have no output operands, including &lt;code&gt;asm goto&lt;/code&gt; statements, are implicitly volatile.</source>
          <target state="translated">GCCのオプティマイザは、出力変数が必要ないと判断した場合、 &lt;code&gt;asm&lt;/code&gt; ステートメントを破棄することがあります。また、オプティマイザは、コードが常に同じ結果を返す（つまり、呼び出し間で入力値が変化しない）と考える場合、ループからコードを移動する場合があります。 &lt;code&gt;volatile&lt;/code&gt; 修飾子を使用すると、これらの最適化が無効になります。 &lt;code&gt;asm&lt;/code&gt; &lt;code&gt;asm goto&lt;/code&gt; ステートメントを含む、出力オペランドを持たないasmステートメントは、暗黙的に揮発性です。</target>
        </trans-unit>
        <trans-unit id="1e750d3c829a6b818589899b42ede982312a7f98" translate="yes" xml:space="preserve">
          <source>GCOV_ERROR_FILE</source>
          <target state="translated">GCOV_ERROR_FILE</target>
        </trans-unit>
        <trans-unit id="e485aa772b73ea7b58dcf4966c0a2d3b9c745805" translate="yes" xml:space="preserve">
          <source>GCOV_EXIT_AT_ERROR</source>
          <target state="translated">GCOV_EXIT_AT_ERROR</target>
        </trans-unit>
        <trans-unit id="80aecc9b56754f32438dd132183cddc7e4df32f1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX contains the prefix to add to the absolute paths in the object file. Prefix can be absolute, or relative. The default is no prefix.</source>
          <target state="translated">GCOV_PREFIX には、オブジェクトファイルの絶対パスに追加する接頭辞が含まれています。プレフィックスは絶対パスでも、相対パスでも構いません。デフォルトはプレフィックスなしです。</target>
        </trans-unit>
        <trans-unit id="891aee4538b1a332bb00b85c9e7c43d1cf40d1d1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX=/target/run</source>
          <target state="translated">GCOV_PREFIX=/target/run</target>
        </trans-unit>
        <trans-unit id="f0bcf8de4466a3194e31ce81577ad85f4f449ccb" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP indicates the how many initial directory names to strip off the hardwired absolute paths. Default value is 0.</source>
          <target state="translated">GCOV_PREFIX_STRIP は、ハードワイヤード絶対パスから削除する初期ディレクトリ名の数を指定します。デフォルト値は 0 です。</target>
        </trans-unit>
        <trans-unit id="7069713a73584b12e5e1b6c6673abb78172fe103" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP=1</source>
          <target state="translated">GCOV_PREFIX_STRIP=1</target>
        </trans-unit>
        <trans-unit id="a007084938316d2847460b0f869fd2dab151324f" translate="yes" xml:space="preserve">
          <source>GFNI instructions.</source>
          <target state="translated">GFNIの指示。</target>
        </trans-unit>
        <trans-unit id="768001d59e5da45e8ce2de4652950a5db0123cf5" translate="yes" xml:space="preserve">
          <source>GNU C allows you to associate specific hardware registers with C variables. In almost all cases, allowing the compiler to assign registers produces the best code. However under certain unusual circumstances, more precise control over the variable storage is required.</source>
          <target state="translated">GNU Cでは、特定のハードウェアレジスタをC変数に関連付けることができます。ほとんどの場合、コンパイラがレジスタを割り当てることで最良のコードが得られます。しかし、特定の異常な状況下では、変数の保存をより正確に制御する必要があります。</target>
        </trans-unit>
        <trans-unit id="1282a7948680a82fce143391cee57deb8d315356" translate="yes" xml:space="preserve">
          <source>GNU C extends ISO C to allow a function prototype to override a later old-style non-prototype definition. Consider the following example:</source>
          <target state="translated">GNU CはISO Cを拡張して、関数プロトタイプが後の古いスタイルの非プロトタイプ定義を上書きできるようにしました。次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="e77e07d95404402b67fc9bef0aec0c9a34ecc38f" translate="yes" xml:space="preserve">
          <source>GNU C provides several language features not found in ISO standard C. (The</source>
          <target state="translated">GNU C は ISO 標準 C にはないいくつかの言語機能を提供します。</target>
        </trans-unit>
        <trans-unit id="d45fbb49066a76f230e9020bfe458e74293358d2" translate="yes" xml:space="preserve">
          <source>GNU C++ does not support old-style function definitions, so this extension is irrelevant.</source>
          <target state="translated">GNU C++は旧式の関数定義をサポートしていないので、この拡張は無関係です。</target>
        </trans-unit>
        <trans-unit id="2ba257a10dfda1a80f343df43a5f9faccbca64b3" translate="yes" xml:space="preserve">
          <source>GNU CPP has two further variadic macro extensions, and permits them to be used with either of the above forms of macro definition.</source>
          <target state="translated">GNU CPPには、さらに2つの可変マクロ拡張があり、マクロ定義の上記の形式のいずれかと一緒に使用することができます。</target>
        </trans-unit>
        <trans-unit id="9dbaa828d6809d3452cb2a6728f3023aae5a8b22" translate="yes" xml:space="preserve">
          <source>GNU CPP permits you to completely omit the variable arguments in this way. In the above examples, the compiler would complain, though since the expansion of the macro still has the extra comma after the format string.</source>
          <target state="translated">GNU CPP では、この方法で変数引数を完全に省略することができます。上記の例では、マクロの展開はまだフォーマット文字列の後に余分なカンマがあるので、コンパイラは文句を言うでしょう。</target>
        </trans-unit>
        <trans-unit id="0e4ec8a54cfff9c2845fa38842cb6cd1bdea197d" translate="yes" xml:space="preserve">
          <source>GNU Free Documentation License</source>
          <target state="translated">GNU自由文書ライセンス</target>
        </trans-unit>
        <trans-unit id="d9cbf0740e34d88c506fb7df6e17deeabd18660c" translate="yes" xml:space="preserve">
          <source>GNU General Public License</source>
          <target state="translated">GNU一般公衆利用許諾書</target>
        </trans-unit>
        <trans-unit id="ea5447d52819458fc788d8fe66484dcf6f8b58c5" translate="yes" xml:space="preserve">
          <source>GNU General Public License says how you can copy and share GCC.</source>
          <target state="translated">GNU General Public Licenseには、GCCをコピーして共有する方法が記載されています。</target>
        </trans-unit>
        <trans-unit id="a21d2651a31b14abba6b9f4cc89e6d16156a2f47" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides constant string objects that are generated directly by the compiler. You declare a constant string object by prefixing a C constant string with the character &amp;lsquo;</source>
          <target state="translated">GNU Objective-Cは、コンパイラーによって直接生成される定数文字列オブジェクトを提供します。定数文字列オブジェクトを宣言するには、C定数文字列の前に文字 'を付けます。</target>
        </trans-unit>
        <trans-unit id="d4b0f24c5578d309a3a80bcf9db1efef7dc80491" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides exception support built into the language, as in the following example:</source>
          <target state="translated">GNU Objective-Cは、以下の例のように、言語に組み込まれた例外のサポートを提供しています。</target>
        </trans-unit>
        <trans-unit id="183b8b6fa7f0ebe7cc24b6e6b64ea37e46538bc2" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for synchronized blocks:</source>
          <target state="translated">GNU Objective-Cは同期化されたブロックをサポートしています。</target>
        </trans-unit>
        <trans-unit id="5a76f04c435b8a53e2673208f47df13d27337155" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for the fast enumeration syntax:</source>
          <target state="translated">GNU Objective-Cは高速な列挙構文をサポートしています。</target>
        </trans-unit>
        <trans-unit id="bd8453bc7fd0b5c5a5eb0b2fb1cc7653d6106ce4" translate="yes" xml:space="preserve">
          <source>GNU Objective-C runtime features.</source>
          <target state="translated">GNU Objective-Cのランタイム機能。</target>
        </trans-unit>
        <trans-unit id="dc4139cbd1ca2e4ec1fdbaf154a309856bbea2a6" translate="yes" xml:space="preserve">
          <source>GNU Objective-C supports the &lt;code&gt;@encode&lt;/code&gt; syntax that allows you to create a type encoding from a C/Objective-C type. For example, &lt;code&gt;@encode(int)&lt;/code&gt; is compiled by the compiler into &lt;code&gt;&quot;i&quot;&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-Cは、C / Objective-C型から型エンコードを作成できる &lt;code&gt;@encode&lt;/code&gt; 構文をサポートしています。たとえば、 &lt;code&gt;@encode(int)&lt;/code&gt; はコンパイラによって &lt;code&gt;&quot;i&quot;&lt;/code&gt; にコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="72bdab580bf81d58abe49ef7feb3d22b198aca72" translate="yes" xml:space="preserve">
          <source>GNU dialect of</source>
          <target state="translated">のGNU方言</target>
        </trans-unit>
        <trans-unit id="0cce44d2e046653755b9171f853b5aa7f7510c0f" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C11. The name &amp;lsquo;</source>
          <target state="translated">ISO C11のGNU方言。名前 '</target>
        </trans-unit>
        <trans-unit id="17c597be9d56a306b84e8b735a051e0b49bf682b" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C17. This is the default for C code.</source>
          <target state="translated">ISO C17 の GNU 方言。これはCコードのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="cd7ba84a6cf37a43cdd1bd215e060138c20d80ef" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C90 (including some C99 features).</source>
          <target state="translated">ISO C90 の GNU 方言 (C99 の機能を含む)。</target>
        </trans-unit>
        <trans-unit id="5a96bf0e0eb1648d92a5415bbf82f314f50fc95d" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C99. The name &amp;lsquo;</source>
          <target state="translated">ISO C99のGNU方言。名前 '</target>
        </trans-unit>
        <trans-unit id="c7513a88e6766734c8fff0b65e9260cb06e07819" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C language family.</source>
          <target state="translated">C言語ファミリのGNU拡張。</target>
        </trans-unit>
        <trans-unit id="90b8cbfe3e7aa922a28ad77fd2468b165d25db6d" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C++ language.</source>
          <target state="translated">C++言語のGNU拡張。</target>
        </trans-unit>
        <trans-unit id="73a49c549f68005dbe48c29ca2788c5808080012" translate="yes" xml:space="preserve">
          <source>General purpose register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">64ビット命令が有効な場合、またはNO_REGSの場合は汎用レジスタ。</target>
        </trans-unit>
        <trans-unit id="005c5bd36bc2dae00112330a475935d63f7703b1" translate="yes" xml:space="preserve">
          <source>General register 1</source>
          <target state="translated">一般レジスタ1</target>
        </trans-unit>
        <trans-unit id="b09ef9c6988403ff1cf426fea1c658c5b1f6be6e" translate="yes" xml:space="preserve">
          <source>General register &lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r3&lt;/code&gt; for &lt;code&gt;addl&lt;/code&gt; instruction</source>
          <target state="translated">&lt;code&gt;addl&lt;/code&gt; 命令用の汎用レジスター &lt;code&gt;r0&lt;/code&gt; から &lt;code&gt;r3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e89cc1c76441abdf1cb24c29330f5f35d304a8e7" translate="yes" xml:space="preserve">
          <source>General register, but not &lt;code&gt;r29&lt;/code&gt;, &lt;code&gt;r30&lt;/code&gt; and &lt;code&gt;r31&lt;/code&gt;</source>
          <target state="translated">汎用レジスター、ただし &lt;code&gt;r29&lt;/code&gt; 、 &lt;code&gt;r30&lt;/code&gt; および &lt;code&gt;r31&lt;/code&gt; は不可</target>
        </trans-unit>
        <trans-unit id="10bd548f00f5df8e11316ab27529f8ec0d489ead" translate="yes" xml:space="preserve">
          <source>General-purpose 32-bit register</source>
          <target state="translated">汎用32ビットレジスタ</target>
        </trans-unit>
        <trans-unit id="d86490a439329533a7fda073910d458d177b7499" translate="yes" xml:space="preserve">
          <source>Generally there is no guarantee that a memory transaction ever succeeds and suitable fallback code always needs to be supplied.</source>
          <target state="translated">一般的に、メモリトランザクションが成功する保証はなく、常に適切なフォールバックコードを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="c220eb05478a76fade659e7f472b8e896908bfb7" translate="yes" xml:space="preserve">
          <source>Generally, functions are not inlined unless optimization is specified. For functions declared inline, this attribute inlines the function independent of any restrictions that otherwise apply to inlining. Failure to inline such a function is diagnosed as an error. Note that if such a function is called indirectly the compiler may or may not inline it depending on optimization level and a failure to inline an indirect call may or may not be diagnosed.</source>
          <target state="translated">一般的に、最適化が指定されない限り、関数はインライン化されません。インラインで宣言された関数の場合、この属性は、インライン化に適用される制限とは無関係に関数をインライン化します。このような関数がインライン化されていない場合は、エラーと診断されます。このような関数が間接的に呼び出された場合、コンパイラは最適化レベルに応じてその関数をインライン化するかどうかを決定し、間接的な呼び出しがインライン化されなかった場合は診断されない場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="84a7c319c3d7d28e18ecbf416836eecf761297c6" translate="yes" xml:space="preserve">
          <source>Generally, inlining into a function is limited. For a function marked with this attribute, every call inside this function is inlined, if possible. Functions declared with attribute &lt;code&gt;noinline&lt;/code&gt; and similar are not inlined. Whether the function itself is considered for inlining depends on its size and the current inlining parameters.</source>
          <target state="translated">一般に、関数へのインライン展開は制限されています。この属性でマークされた関数の場合、可能であれば、この関数内のすべての呼び出しがインライン化されます。属性 &lt;code&gt;noinline&lt;/code&gt; などで宣言された関数はインライン化されません。関数自体がインライン化の対象となるかどうかは、そのサイズと現在のインライン化パラメーターによって異なります。</target>
        </trans-unit>
        <trans-unit id="da79890df831b8b599903d6736d5d918432eda2d" translate="yes" xml:space="preserve">
          <source>Generally, options specified at link time override those specified at compile time, although in some cases GCC attempts to infer link-time options from the settings used to compile the input files.</source>
          <target state="translated">一般的に、リンク時に指定されたオプションはコンパイル時に指定されたものを上書きしますが、GCCは入力ファイルのコンパイルに使用された設定からリンク時のオプションを推測しようとする場合もあります。</target>
        </trans-unit>
        <trans-unit id="ba4adeb327e032d99cfca5b51d0fd4daaa9b56fc" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) ColdFire hardware divide and remainder instructions. If</source>
          <target state="translated">ColdFire ハードウェアの除算および剰余命令を生成します (生成しない)。もし</target>
        </trans-unit>
        <trans-unit id="0fe80a59bc1a906ccb8af3fc3416cadc3264624c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) GP-relative accesses. The following &lt;var&gt;option&lt;/var&gt; names are recognized:</source>
          <target state="translated">GP相対アクセスを生成します（生成しません）。次の &lt;var&gt;option&lt;/var&gt; 名が認識されます。</target>
        </trans-unit>
        <trans-unit id="09abd950717c564f7150fc3aedac403b36224304" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) MIPS16 code. If GCC is targeting a MIPS32 or MIPS64 architecture, it makes use of the MIPS16e ASE.</source>
          <target state="translated">MIPS16 コードを生成する(生成しない)。GCC が MIPS32 または MIPS64 アーキテクチャをターゲットにしている場合、MIPS16e ASE を使用します。</target>
        </trans-unit>
        <trans-unit id="188ec1e266203e4853a13748340fc36d3e35234e" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is fully position-independent, and that can therefore be linked into shared libraries. This option only affects</source>
          <target state="translated">完全に位置に依存せず、共有ライブラリにリンクできるコードを生成します(生成しない)。このオプションは</target>
        </trans-unit>
        <trans-unit id="0a056a294949b854726ab099acb14488ae9baeac" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is suitable for SVR4-style dynamic objects.</source>
          <target state="translated">SVR4スタイルのダイナミックオブジェクトに適したコードを生成する(生成しない)。</target>
        </trans-unit>
        <trans-unit id="200f92cbd3d74fb5f3e648ecaaea7b69d566f040" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that uses &lt;em&gt;base addresses&lt;/em&gt;. Using a base address automatically generates a request (handled by the assembler and the linker) for a constant to be set up in a global register. The register is used for one or more base address requests within the range 0 to 255 from the value held in the register. The generally leads to short and fast code, but the number of different data items that can be addressed is limited. This means that a program that uses lots of static data may require</source>
          <target state="translated">&lt;em&gt;ベースアドレス&lt;/em&gt;を使用するコードを生成します（生成しません）。ベースアドレスを使用すると、グローバルレジスタに設定する定数の要求（アセンブラーとリンカーによって処理される）が自動的に生成されます。レジスターは、レジスターに保持されている値から0から255の範囲内の1つ以上のベース・アドレス要求に使用されます。一般に、コードは短くて高速になりますが、アドレス指定できるさまざまなデータ項目の数は限られています。つまり、多くの静的データを使用するプログラムでは、</target>
        </trans-unit>
        <trans-unit id="fc8c5a89f214acd8179a09f487fb87bbd0d7c872" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to load up the static chain register (&lt;code&gt;r11&lt;/code&gt;) when calling through a pointer on AIX and 64-bit Linux systems where a function pointer points to a 3-word descriptor giving the function address, TOC value to be loaded in register &lt;code&gt;r2&lt;/code&gt;, and static chain value to be loaded in register &lt;code&gt;r11&lt;/code&gt;. The</source>
          <target state="translated">関数ポインターが関数アドレス、TOC値を与える3ワード記述子を指すAIXおよび64ビットLinuxシステムでポインターを介して呼び出すときに、静的チェーンレジスタ（ &lt;code&gt;r11&lt;/code&gt; ）をロードするコードを生成（生成しない）します。レジスタ &lt;code&gt;r2&lt;/code&gt; にロードされる静的チェーン値とレジスタ &lt;code&gt;r11&lt;/code&gt; にロードされる静的チェーン値。の</target>
        </trans-unit>
        <trans-unit id="813e9e6ca1642f726fee97bfddf02338960484b7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to pass structure parameters with a maximum alignment of 64 bits, for compatibility with older versions of GCC.</source>
          <target state="translated">古いバージョンのGCCとの互換性のために、最大64ビットのアラインメントで構造体パラメータを渡すためのコードを生成します(生成しない)。</target>
        </trans-unit>
        <trans-unit id="55cac71e3fa8543a26a5b7f404ac565adfa17f28" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to save the TOC value in the reserved stack location in the function prologue if the function calls through a pointer on AIX and 64-bit Linux systems. If the TOC value is not saved in the prologue, it is saved just before the call through the pointer. The</source>
          <target state="translated">AIXおよび64ビットLinuxシステム上で関数がポインタを介して呼び出す場合、関数プロローグ内の予約スタック位置にTOC値を保存するためのコードを生成します(生成しません)。TOC値がプロローグに保存されていない場合は、ポインタを介して呼び出す直前に保存されます。このような場合には</target>
        </trans-unit>
        <trans-unit id="492f533f0926b6f12aa3c20775f6e3689bd7771b" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) microMIPS code.</source>
          <target state="translated">microMIPS コードを生成する(生成しない)。</target>
        </trans-unit>
        <trans-unit id="c38ed93b70630b073ac9de0cd53b30eca713a227" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the &lt;code&gt;friz&lt;/code&gt; instruction when the</source>
          <target state="translated">ときに &lt;code&gt;friz&lt;/code&gt; 命令を生成します（生成しません）。</target>
        </trans-unit>
        <trans-unit id="87be6d200ff57766f2cf75cef2026526e7116620" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;bras&lt;/code&gt; instruction to do subroutine calls. This only works reliably if the total executable size does not exceed 64k. The default is to use the &lt;code&gt;basr&lt;/code&gt; instruction instead, which does not have this limitation.</source>
          <target state="translated">サブルーチン呼び出しを行うために &lt;code&gt;bras&lt;/code&gt; 命令を使用してコードを生成します（または生成しません）。これは、実行可能ファイルの合計サイズが64kを超えない場合にのみ確実に機能します。デフォルトでは、代わりに &lt;code&gt;basr&lt;/code&gt; 命令を使用しますが、この制限はありません。</target>
        </trans-unit>
        <trans-unit id="dac8cd11137e120330b4b9ae84e6593137818e9a" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;mvcle&lt;/code&gt; instruction to perform block moves. When</source>
          <target state="translated">&lt;code&gt;mvcle&lt;/code&gt; 命令を使用してブロック移動を実行するコードを生成します（または生成しません）。いつ</target>
        </trans-unit>
        <trans-unit id="2e0545421416cf516c0b942352accf8dc6b0a0d5" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) &amp;lsquo;</source>
          <target state="translated">生成する（しない） '</target>
        </trans-unit>
        <trans-unit id="05dd2841d03433fc0ea5db0c7e0df3c7599676c8" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) a stop bit immediately before and after volatile asm statements.</source>
          <target state="translated">揮発性asmステートメントの直前と直後にストップビットを生成します（または生成しません）。</target>
        </trans-unit>
        <trans-unit id="a0784cc5b984b19815bf9eec6e275ae1a59c3b0f" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU assembler. This is the default.</source>
          <target state="translated">GNUアセンブラー用のコードを生成します（または生成しません）。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="2516ed040d38a5388dd7fe01c44239d79052cf2e" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU linker. This is the default.</source>
          <target state="translated">GNUリンカーのコードを生成します（または生成しません）。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="3e316b54c0eaa7bda512b60e40414c689d945ab8" translate="yes" xml:space="preserve">
          <source>Generate 16-bit instructions.</source>
          <target state="translated">16ビット命令を生成します。</target>
        </trans-unit>
        <trans-unit id="a52620c65360885e469f926c554c75bd50dd9583" translate="yes" xml:space="preserve">
          <source>Generate 3-instruction load and store sequences as sometimes required by the HP-UX 10 linker. This is equivalent to the &amp;lsquo;</source>
          <target state="translated">HP-UX 10リンカーで必要になる場合がある3命令ロードおよびストアシーケンスを生成します。これは「</target>
        </trans-unit>
        <trans-unit id="b384dbdcdcc6be12f32b73f9469c3ba6b9f1dccf" translate="yes" xml:space="preserve">
          <source>Generate 32x16-bit multiply and multiply-accumulate instructions.</source>
          <target state="translated">32x16ビットの乗算・積算命令を生成します。</target>
        </trans-unit>
        <trans-unit id="0ccaaa46afb8881f4f3a477c92bc05eae68e0c4a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections in a format suitable for conversion into a GDB index. This option is only useful with a linker that can produce GDB index version 7.</source>
          <target state="translated">GDBインデックスへの変換に適した形式で &lt;code&gt;.debug_pubnames&lt;/code&gt; および &lt;code&gt;.debug_pubtypes&lt;/code&gt; セクションを生成します。このオプションは、GDBインデックスバージョン7を生成できるリンカーでのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="828612c6e2cc35cf1bee3972f49446cb2047aba1" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;mul64&lt;/code&gt; and &lt;code&gt;mulu64&lt;/code&gt; instructions. Only valid for</source>
          <target state="translated">&lt;code&gt;mul64&lt;/code&gt; および &lt;code&gt;mulu64&lt;/code&gt; 命令を生成します。のみ有効</target>
        </trans-unit>
        <trans-unit id="f37d583fd1aea916d55ab9e91fa3002c399aaf84" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;norm&lt;/code&gt; instructions. This is the default if</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 命令を生成します。これはデフォルトです</target>
        </trans-unit>
        <trans-unit id="2934019de0c741342611be8077a1571f0c44928a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;swap&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;swap&lt;/code&gt; 命令を生成します。</target>
        </trans-unit>
        <trans-unit id="586858db58f3f2f4e0ba5be27cc76fd1d37e386f" translate="yes" xml:space="preserve">
          <source>Generate &lt;var&gt;N&lt;/var&gt; NOPs right at the beginning of each function, with the function entry point before the &lt;var&gt;M&lt;/var&gt;th NOP. If &lt;var&gt;M&lt;/var&gt; is omitted, it defaults to &lt;code&gt;0&lt;/code&gt; so the function entry points to the address just at the first NOP. The NOP instructions reserve extra space which can be used to patch in any desired instrumentation at run time, provided that the code segment is writable. The amount of space is controllable indirectly via the number of NOPs; the NOP instruction used corresponds to the instruction emitted by the internal GCC back-end interface &lt;code&gt;gen_nop&lt;/code&gt;. This behavior is target-specific and may also depend on the architecture variant and/or other compilation options.</source>
          <target state="translated">各関数の最初に &lt;var&gt;N&lt;/var&gt; 個の NOP を生成し、関数のエントリポイントを &lt;var&gt;M&lt;/var&gt; 番目のNOPの前に配置します。場合は &lt;var&gt;M&lt;/var&gt; がに省略されている、それはデフォルトで &lt;code&gt;0&lt;/code&gt; ちょうど最初のNOPのアドレスへの関数エントリポイントそう。 NOP命令は、コードセグメントが書き込み可能であれば、実行時に任意のインストルメンテーションにパッチを適用するために使用できる余分なスペースを予約します。スペースの量は、NOPの数を介して間接的に制御できます。使用されるNOP命令は、内部GCCバックエンドインターフェイス &lt;code&gt;gen_nop&lt;/code&gt; によって発行される命令に対応しています。この動作はターゲット固有であり、アーキテクチャバリアントや他のコンパイルオプションに依存する場合もあります。</target>
        </trans-unit>
        <trans-unit id="b56d0340e46553074756e8938fdcc9bc10345ee9" translate="yes" xml:space="preserve">
          <source>Generate C header describing the largest structure that is passed by value, if any.</source>
          <target state="translated">値で渡される最大の構造体があれば、それを記述したCヘッダを生成します。</target>
        </trans-unit>
        <trans-unit id="497d1946c219789282a881eeb57aa9b71f210579" translate="yes" xml:space="preserve">
          <source>Generate DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections.</source>
          <target state="translated">DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; および &lt;code&gt;.debug_pubtypes&lt;/code&gt; セクションを生成します。</target>
        </trans-unit>
        <trans-unit id="2f0d6b717c142d078ddbdb831a6e380bea411850" translate="yes" xml:space="preserve">
          <source>Generate GNU/Linux compatible gUSA software atomic sequences for the atomic built-in functions. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for SH3* and SH4* single-core systems. This option is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH3* or SH4*. When the target is SH4A, this option also partially utilizes the hardware atomic instructions &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; to create more efficient code, unless &amp;lsquo;</source>
          <target state="translated">アトミック組み込み関数のGNU / Linux互換gUSAソフトウェアアトミックシーケンスを生成します。生成されたアトミックシーケンスは、システムの割り込み/例外処理コードからの追加サポートを必要とし、SH3 *およびSH4 *シングルコアシステムにのみ適しています。ターゲットが &lt;code&gt;sh*-*-linux*&lt;/code&gt; およびSH3 *またはSH4 *の場合、このオプションはデフォルトで有効になります。ターゲットがSH4Aの場合、このオプションは、ハードウェアアトミック命令 &lt;code&gt;movli.l&lt;/code&gt; および &lt;code&gt;movco.l&lt;/code&gt; を部分的に利用して、より効率的なコードを作成します。</target>
        </trans-unit>
        <trans-unit id="bf2d938e1c1ea97f318900579ce3c50a9ae898af" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for all data objects in the program. If you use this option, the entire data and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">プログラム内のすべてのデータ・オブジェクトに対して GP 相対アクセスを生成します。このオプションを使用する場合、プログラムのデータセグメントとBSSセグメント全体が64Kのメモリに収まる必要があり、適切なリンカースクリプトを使用してグローバルポインタのアドレス指定可能な範囲内に割り当てる必要があります。</target>
        </trans-unit>
        <trans-unit id="1fc88c33c3fc53124fa0f92092082efc85a7cdc0" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for small data objects that are not external, weak, or uninitialized common symbols. Also use GP-relative addressing for objects that have been explicitly placed in a small data section via a &lt;code&gt;section&lt;/code&gt; attribute.</source>
          <target state="translated">外部、弱い、または初期化されていない共通シンボルではない小さなデータオブジェクトのGP相対アクセスを生成します。また、 &lt;code&gt;section&lt;/code&gt; 属性を介して小さなデータセクションに明示的に配置されたオブジェクトには、GP相対アドレッシングを使用します。</target>
        </trans-unit>
        <trans-unit id="548a87f5ac4837154b7b55bf3a0684dbbd7b3056" translate="yes" xml:space="preserve">
          <source>Generate GP-relative addresses for function pointers as well as data pointers. If you use this option, the entire text, data, and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">関数ポ イ ン タ ー と デー タ ポ イ ン タ ーのための GP 相対アドレスを生成します。このオプションを使用する場合、プログラムのテキスト、データ、および BSS セグメント全体が 64K のメモリに収まる必要があり、適切なリンカースクリプトを使用してグローバル ポインタのアドレス可能範囲内に割り当てる必要があります。</target>
        </trans-unit>
        <trans-unit id="9f3a196b430f925ff0ff89b9ccb1a7bf625049d2" translate="yes" xml:space="preserve">
          <source>Generate MIPS16 code on alternating functions. This option is provided for regression testing of mixed MIPS16/non-MIPS16 code generation, and is not intended for ordinary use in compiling user code.</source>
          <target state="translated">交互関数でMIPS16コードを生成します。このオプションは、MIPS16/非MIPS16の混在コード生成のリグレッションテストのために提供されるものであり、ユーザーコードをコンパイルする際の通常の使用を意図したものではありません。</target>
        </trans-unit>
        <trans-unit id="b7aa3b59b611b18a6a4ec60f9d9a319cc049bd6b" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the large model: The TOC may be up to 4G in size. Other data and code is only limited by the 64-bit address space.</source>
          <target state="translated">大型モデル用のPowerPC64コードを生成します。TOCは4Gまでのサイズになる可能性があります。その他のデータやコードは64ビットのアドレス空間でのみ制限されます。</target>
        </trans-unit>
        <trans-unit id="c7a74518f21d3c00aafcfd3b084cf7c00aee1848" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the medium model: The TOC and other static data may be up to a total of 4G in size. This is the default for 64-bit Linux.</source>
          <target state="translated">中型モデル用のPowerPC64コードを生成します。TOCやその他の静的データは合計4Gまでのサイズになる可能性があります。これは64ビットLinuxのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="8cfde8c4df8b2eb989bc818febefc0e7c28874e7" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the small model: The TOC is limited to 64k.</source>
          <target state="translated">小型モデル用のPowerPC64コードを生成します。TOCは64kに制限されています。</target>
        </trans-unit>
        <trans-unit id="c7ea62356cd3157102c66b58a868e34df2a5c060" translate="yes" xml:space="preserve">
          <source>Generate VRSAVE instructions when generating AltiVec code.</source>
          <target state="translated">AltiVec コードを生成する際に VRSAVE 命令を生成します。</target>
        </trans-unit>
        <trans-unit id="0bd45272345d657871ab9cf111cdd01907672885" translate="yes" xml:space="preserve">
          <source>Generate a __return_loc section pointing to all return instrumentation code.</source>
          <target state="translated">すべてのリターン・インスツルメンテーション・コードを指す __return_loc セクションを生成します。</target>
        </trans-unit>
        <trans-unit id="2cf42b0393916fe85d4396c2a4ea44c0c0b17c4a" translate="yes" xml:space="preserve">
          <source>Generate a call to the function &lt;code&gt;abort&lt;/code&gt; at the end of a &lt;code&gt;noreturn&lt;/code&gt; function. It is executed if the function tries to return.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; 関数の最後で関数 &lt;code&gt;abort&lt;/code&gt; の呼び出しを生成します。関数が復帰しようとした場合に実行されます。</target>
        </trans-unit>
        <trans-unit id="0bfebab0f7716c6c7d48b3db2e26f828205f2eb0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the ARM Procedure Call Standard for all functions, even if this is not strictly necessary for correct execution of the code. Specifying</source>
          <target state="translated">コードを正しく実行するために厳密に必要でない場合でも、すべての関数に対してARMプロシージャコール規格に準拠したスタックフレームを生成します。指定する</target>
        </trans-unit>
        <trans-unit id="09e70235b2ae102fe1ff7ae3b745820674b997a0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">すべてのリーフ関数について、Thumb Procedure Call Standard に準拠したスタック・フレームを生成します。(リーフ関数とは、他の関数を呼び出さない関数のことです。)既定値は</target>
        </trans-unit>
        <trans-unit id="4e955728a6de82a9bddec4fed62b648dcfc40e9a" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all non-leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">リーフ関数以外のすべての関数について、Thumb Procedure Call Standard に準拠したスタック・フレームを生成します。(リーフ関数とは、他の関数を呼び出さない関数のことです。)既定値は</target>
        </trans-unit>
        <trans-unit id="4839b3bf0bbd769aa7c0e4fcd67cdaaed9746bd5" translate="yes" xml:space="preserve">
          <source>Generate an executable in the ELF format, rather than the default &amp;lsquo;</source>
          <target state="translated">デフォルトではなくELF形式で実行可能ファイルを生成する '</target>
        </trans-unit>
        <trans-unit id="6c98697c08dfd7f201b6b9c98efc4af59466b6c7" translate="yes" xml:space="preserve">
          <source>Generate an inline expansion using loop code for all block compares that are less than or equal to &lt;var&gt;num&lt;/var&gt; bytes, but greater than the limit for non-loop inline block compare expansion. If the block length is not constant, at most &lt;var&gt;num&lt;/var&gt; bytes will be compared before &lt;code&gt;memcmp&lt;/code&gt; is called to compare the remainder of the block. The default value is target-specific.</source>
          <target state="translated">&lt;var&gt;num&lt;/var&gt; バイト以下であるが、非ループのインラインブロック比較拡張の制限を超えるすべてのブロック比較のループコードを使用して、インライン拡張を生成します。ブロック長が一定でない場合、ブロックの残りを比較するために &lt;code&gt;memcmp&lt;/code&gt; が呼び出される前に、最大で &lt;var&gt;num&lt;/var&gt; バイトが比較されます。デフォルト値はターゲット固有です。</target>
        </trans-unit>
        <trans-unit id="ee53ff6577ff7bdeec45265bba557ddc96dc42d1" translate="yes" xml:space="preserve">
          <source>Generate big-endian code.</source>
          <target state="translated">ビッグエンディアンコードを生成します。</target>
        </trans-unit>
        <trans-unit id="faa1ec28121e6f94c7459039f3f456a29482ffe4" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">ビッグエンディアンコードを生成します。これは「</target>
        </trans-unit>
        <trans-unit id="497dec8a0e83106900bb3f13f33208ac13cc564e" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">ビッグエンディアンコードを生成します。これは、GCCが「</target>
        </trans-unit>
        <trans-unit id="9f5c216ca40ddba6d0b7e0356dfb54eddd239c13" translate="yes" xml:space="preserve">
          <source>Generate calls as register indirect calls, thus providing access to the full 32-bit address range.</source>
          <target state="translated">レジスタ間接呼び出しとして呼び出しを生成し、32ビットのアドレス範囲全体へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="daf711e932fbd2a210fbf658c2ed048fe589f322" translate="yes" xml:space="preserve">
          <source>Generate checks for control speculation in selective scheduling. This flag is disabled by default.</source>
          <target state="translated">選択的スケジューリングにおける制御投機のチェックを生成します。このフラグはデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="340f82c2c0a45e961b4cd414df01b6dcda27429e" translate="yes" xml:space="preserve">
          <source>Generate code containing floating-point instructions. This is the default.</source>
          <target state="translated">浮動小数点命令を含むコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="d1eb9be83c7705dec7853ee52d8e983f54f63d2c" translate="yes" xml:space="preserve">
          <source>Generate code containing library calls for floating-point.</source>
          <target state="translated">浮動小数点のライブラリ呼び出しを含むコードを生成します。</target>
        </trans-unit>
        <trans-unit id="ffda305054ff95e7394bd4003326530b52f9583d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit ABI.</source>
          <target state="translated">32ビットまたは64ビットのABI用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="b67c6b7cf041ab09d12159e623bf4650fd97244d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit environments of Darwin and SVR4 targets (including GNU/Linux). The 32-bit environment sets int, long and pointer to 32 bits and generates code that runs on any PowerPC variant. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits, and generates code for PowerPC64, as for</source>
          <target state="translated">DarwinとSVR4ターゲット(GNU/Linuxを含む)の32ビットまたは64ビット環境用のコードを生成します。32ビット環境では、int、long、ポインタを32ビットに設定し、任意のPowerPCバリアント上で動作するコードを生成します。64ビット環境では、intを32ビットに、longとポインタを64ビットに設定し、PowerPC64用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="a4491a667cb7d0b6c838f6faaee6a864eadc20bd" translate="yes" xml:space="preserve">
          <source>Generate code for CR16C or CR16C+ architecture. CR16C+ architecture is default.</source>
          <target state="translated">CR16CまたはCR16C+アーキテクチャ用のコードを生成します。CR16C+アーキテクチャがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="67648931cfe6b959b11bf696abb5438c66a26217" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットがデフォルトで単精度モードになっていると仮定して、SH4-100用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="de1af2a9972c47a564f5e7fcce23d995d6ae1b8b" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">倍精度浮動小数点演算を使用しないようにSH4-100のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="107ca25d9739e824d4175850436b6598a742f5a1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that the floating-point unit is not used.</source>
          <target state="translated">浮動小数点単位を使用しないように SH4-100 のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="f4838bc707d842b8a2b2e768456d1b164bf348d3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100.</source>
          <target state="translated">SH4-100 のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="eb7eb15dc4aa3c46b2283b182c63acf0a395433d" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットがデフォルトで単精度モードになっていると仮定して、SH4-200用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="c7c33168087299c03364283296e9feb1a533b788" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">倍精度浮動小数点演算を使用しないようにSH4-200のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="b14c102c6af7d5f6fb411b3d326830a45f2aceb0" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">浮動小数点単位を使用しないように、SH4-200用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="5283c23e1460ff21798ade4588312627145b49aa" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200.</source>
          <target state="translated">SH4-200のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="2fb0dbc9dfbf231f5e57962b75a086351c1f46b3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">倍精度浮動小数点演算を使用しないようにSH4-300のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="ff44e3f28e2fd7daaa679641ff86e04eab85fb68" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">浮動小数点単位を使用しないように、SH4-300用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="5dd69911ae792e28eb1d16efd78aa149dec9b0b1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300.</source>
          <target state="translated">SH4-300のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="3190f28d97b238beea538765e992a0880400111e" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-340 (no MMU, no FPU).</source>
          <target state="translated">SH4-340用のコードを生成します(MMU、FPU内)。</target>
        </trans-unit>
        <trans-unit id="964d89eec4f49e488b7e663bfb784df7de2d9807" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-500 (no FPU). Passes</source>
          <target state="translated">SH4-500(FPUなし)のコードを生成します。合格</target>
        </trans-unit>
        <trans-unit id="bd07f25b5dfd9dc83556617396ced4ced292840d" translate="yes" xml:space="preserve">
          <source>Generate code for Smart Mode, using only registers numbered 0-7 to allow use of 16-bit instructions. This option is ignored for CK801 where this is the required behavior, and it defaults to on for CK802. For other targets, the default is off.</source>
          <target state="translated">スマートモードのコードを生成し、0~7番のレジスタのみを使用して16ビット命令を使用できるようにします。このオプションはCK801では無視され、CK802ではデフォルトでオンになります。他のターゲットでは、デフォルトはオフです。</target>
        </trans-unit>
        <trans-unit id="d1ef13a03c7e2ed855aab73fe845bb318c6bf94c" translate="yes" xml:space="preserve">
          <source>Generate code for a 16-bit, 32-bit or 64-bit environment. The</source>
          <target state="translated">16ビット、32ビット、64ビット環境用のコードを生成します。このような環境では</target>
        </trans-unit>
        <trans-unit id="6f846bc35b4ddbb63662daaf0b8a0b9a36eafb1b" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit environment, which sets int, long, and pointer to 32 bits. This is the only supported behavior so the flag is essentially ignored.</source>
          <target state="translated">int、long、ポインタを32ビットに設定する32ビット環境用のコードを生成します。これは唯一サポートされている動作なので、このフラグは基本的に無視されます。</target>
        </trans-unit>
        <trans-unit id="c70fb6bc63f54c3dd3b6636fb15aabdae1032dda" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">32ビットまたは64ビット環境用のコードを生成します。32ビット環境では、32ビットにint、long、ポインタが設定されます。64ビット環境では、32ビットにint、64ビットにlongとポインタが設定されます。</target>
        </trans-unit>
        <trans-unit id="25466413f97413255c5d54e631be1e6a23f5330d" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits. These are HP-UX specific flags.</source>
          <target state="translated">32ビットまたは64ビット環境用のコードを生成します。32ビット環境では、32ビットにint、long、ポインタが設定されます。64 ビット環境では、int を 32 ビットに、long を 64 ビットに、ポインタを 64 ビットに設定します。これらはHP-UX固有のフラグです。</target>
        </trans-unit>
        <trans-unit id="89222a0849ae48c73c6bd1624ef4d88ea3c84874" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long, and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">32ビットまたは64ビット環境用のコードを生成します。32ビット環境では、32ビットにint、long、ポインタが設定されます。64ビット環境では、intを32ビットに、longとポインタを64ビットに設定します。</target>
        </trans-unit>
        <trans-unit id="7a6899675bc409f91ebf1c2951874d09f2171d0a" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/10. Implies -msoft-float -mno-split.</source>
          <target state="translated">PDP-11/10用のコードを生成します。msoft-float -mno-splitを意味します。</target>
        </trans-unit>
        <trans-unit id="bee1deaf455b6a6b4cdb2bb13d6ee23ad81f5012" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/40. Implies -msoft-float -mno-split.</source>
          <target state="translated">PDP-11/40用のコードを生成します。msoft-float -mno-splitを意味します。</target>
        </trans-unit>
        <trans-unit id="d9780d13a5a51c47480c939a428413699ac3ed17" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/45. This is the default.</source>
          <target state="translated">PDP-11/45 のコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="92b920e8ba8535d90a16588551ee999d568f0291" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target.</source>
          <target state="translated">ビッグエンディアンターゲットのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="d68254cfeddff60f3b9cadfb72e8acbde8b8a455" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target. This is the default for HP-UX.</source>
          <target state="translated">ビッグエンディアンターゲットのコードを生成します。これはHP-UXのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="5fbe216af63a08f8f99c457d81f72aa33271a249" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target.</source>
          <target state="translated">リトルエンディアンターゲットのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="7fec6c67ff3977f6cbf34379a4b039899b9238d9" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default for AIX5 and GNU/Linux.</source>
          <target state="translated">リトルエンディアンターゲットのコードを生成します。これはAIX5とGNU/Linuxのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="12a32136f06def3f80692a9e99c0d8f9b7d0b140" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default.</source>
          <target state="translated">リトルエンディアンターゲットのコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="86cf4bd8b15db1a7bae18b7503fdfe578d14ff3d" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in big-endian mode; the default is to compile code for a little-endian processor.</source>
          <target state="translated">ビッグエンディアンモードで動作するプロセッサ用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="b9c63b6f7dde24a56bfd3b0c8c39dff387d09612" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in little-endian mode. This is the default for all standard configurations.</source>
          <target state="translated">リトルエンディアンモードで動作するプロセッサ用のコードを生成します。これはすべての標準構成のデフォルトです。</target>
        </trans-unit>
        <trans-unit id="7c9d614db21563decf26e4450a12e8ff0db080a3" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire instruction set architecture. Permissible values of &lt;var&gt;arch&lt;/var&gt; for M680x0 architectures are: &amp;lsquo;</source>
          <target state="translated">特定のM680x0またはColdFire命令セットアーキテクチャのコードを生成します。M680x0アーキテクチャの &lt;var&gt;arch&lt;/var&gt; の許容値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4756b1c10e780d22755d4efd055be671187986d0" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire processor. The M680x0 &lt;var&gt;cpu&lt;/var&gt;s are: &amp;lsquo;</source>
          <target state="translated">特定のM680x0またはColdFireプロセッサのコードを生成します。M680x0 &lt;var&gt;cpu&lt;/var&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="cf0efda24e55f61b98734329e006dab8159c05d8" translate="yes" xml:space="preserve">
          <source>Generate code for given RISC-V ISA (e.g. &amp;lsquo;</source>
          <target state="translated">特定のRISC-V ISAのコードを生成します（例： '</target>
        </trans-unit>
        <trans-unit id="1cc9f255978b92385d0966d847bc3f1f4feff36e" translate="yes" xml:space="preserve">
          <source>Generate code for given the specified PTX ISA (e.g. &amp;lsquo;</source>
          <target state="translated">指定されたPTX ISAを指定してコードを生成します（例： '</target>
        </trans-unit>
        <trans-unit id="4b8a962abd2bc5357f263a724ad7ce6201860ac4" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires divide instruction emulation.</source>
          <target state="translated">分割命令エミュレーションを必要とするハードウェア用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="0ff05f7bfb6de148dd31e5b918468ff58be8cc2b" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires multiply instruction emulation.</source>
          <target state="translated">乗算命令エミュレーションを必要とするハードウェア用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="9d141b4aab656e3ada981384fd6736554ccf4fe3" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports divide instructions. This is the default.</source>
          <target state="translated">除算命令をサポートするハードウェア用のコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="63b8cd12a9a7b77524e7516bc8342264efc809e2" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports multiply instructions. This is the default.</source>
          <target state="translated">乗算命令をサポートするハードウェア用のコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="f67b905d0c7d601714b6d40130d650c8841556d5" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports rotate right instructions.</source>
          <target state="translated">右回転命令をサポートするハードウェア用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="d8901265c038359c4cabcecef69c62a4ad403284" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports set flag immediate (&lt;code&gt;l.sf*i&lt;/code&gt;) instructions.</source>
          <target state="translated">フラグの即時設定（ &lt;code&gt;l.sf*i&lt;/code&gt; ）命令をサポートするハードウェアのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="cb0dc185d9cce6eac6a0da7c5fde4468c232eb00" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports shift immediate related instructions (i.e. &lt;code&gt;l.srai&lt;/code&gt;, &lt;code&gt;l.srli&lt;/code&gt;, &lt;code&gt;l.slli&lt;/code&gt;, &lt;code&gt;1.rori&lt;/code&gt;). Note, to enable generation of the &lt;code&gt;l.rori&lt;/code&gt; instruction the</source>
          <target state="translated">シフト関連の命令（ &lt;code&gt;l.srai&lt;/code&gt; 、 &lt;code&gt;l.srli&lt;/code&gt; 、 &lt;code&gt;l.slli&lt;/code&gt; 、 &lt;code&gt;1.rori&lt;/code&gt; ）をサポートするハードウェアのコードを生成します。 &lt;code&gt;l.rori&lt;/code&gt; 命令の生成を有効にするには、</target>
        </trans-unit>
        <trans-unit id="56c0dd74c2b5f08d1195605802098a996d48ddaa" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports sign-extension instructions.</source>
          <target state="translated">符号拡張命令をサポートするハードウェア用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="c6c9d0431f616f47453feb5bcfe61cef592a68b7" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports the conditional move (&lt;code&gt;l.cmov&lt;/code&gt;) instruction.</source>
          <target state="translated">条件付き移動（ &lt;code&gt;l.cmov&lt;/code&gt; ）命令をサポートするハードウェアのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="bf79d7ac3430cd100137adc751a91365b039edd3" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the maximum throughput algorithm.</source>
          <target state="translated">最大スループット・アルゴリズムを使用して浮動小数点値をインラインで分割するためのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="3cedd11fcbf120218332b498654e7e4160f8c76d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the minimum latency algorithm.</source>
          <target state="translated">最小遅延アルゴリズムを使用して浮動小数点値をインラインで分割するコードを生成します。</target>
        </trans-unit>
        <trans-unit id="1cc7790f16d0c4d4d91471e6f5d653df0c747e44" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the maximum throughput algorithm.</source>
          <target state="translated">最大スループットアルゴリズムを使用して整数値をインラインで分割するためのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="faf94b4d20f983cdf533f47ec33942d0ce63586d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the minimum latency algorithm.</source>
          <target state="translated">最小遅延アルゴリズムを使用して整数値をインラインで分割するためのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="5418fa0a1b1b281d2485d7060d2309afdebd6ff4" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the maximum throughput algorithm.</source>
          <target state="translated">最大スループットアルゴリズムを使用してインライン平方根のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="83ef176a0741f8d1f5fe6e111f7583e6807956ad" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the minimum latency algorithm.</source>
          <target state="translated">最小遅延アルゴリズムを使用してインライン平方根のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="00979759a61ef121145bed1163bfbd0399a7b98b" translate="yes" xml:space="preserve">
          <source>Generate code for long address mode. This is only supported for 64-bit and x32 environments. It is the default address mode for 64-bit environments.</source>
          <target state="translated">ロングアドレスモード用のコードを生成します。これは64ビットおよびx32環境でのみサポートされています。64 ビット環境ではデフォルトのアドレスモードです。</target>
        </trans-unit>
        <trans-unit id="8adaf3135394010293585c029db12629ab7fdcf7" translate="yes" xml:space="preserve">
          <source>Generate code for short address mode. This is only supported for 32-bit and x32 environments. It is the default address mode for 32-bit and x32 environments.</source>
          <target state="translated">ショートアドレスモード用のコードを生成します。これは32ビットおよびx32環境でのみサポートされています。32ビットおよびx32環境ではデフォルトのアドレスモードです。</target>
        </trans-unit>
        <trans-unit id="694f6014654115d073cccf62f6b995dc2510f9c1" translate="yes" xml:space="preserve">
          <source>Generate code for the 210 processor.</source>
          <target state="translated">210プロセッサ用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="85e35fc91e0af86a193c565f8d6f2a96d089e373" translate="yes" xml:space="preserve">
          <source>Generate code for the C-SKY compiler runtime instead of libgcc. This option defaults to off.</source>
          <target state="translated">libgcc の代わりに C-SKY コンパイラのランタイム用のコードを生成します。このオプションのデフォルトはoffです。</target>
        </trans-unit>
        <trans-unit id="27e854c2e0908c3f4c936f01364c648aa32b367c" translate="yes" xml:space="preserve">
          <source>Generate code for the H8/300H.</source>
          <target state="translated">H8/300Hのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="bb83090e60c2fc757a89c80487c241185ee5d95a" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S and H8/300H in the normal mode. This switch must be used either with</source>
          <target state="translated">ノーマルモードでH8SとH8/300Hのコードを生成します。このスイッチは</target>
        </trans-unit>
        <trans-unit id="d052e6239d8f301fe0a2b7da20c249087f96d45d" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S.</source>
          <target state="translated">H8S用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="6d5ff3e2bd91c0a262161bf6efa2cdef6971233e" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S/2600. This switch must be used with</source>
          <target state="translated">H8S/2600用のコードを生成します。このスイッチは</target>
        </trans-unit>
        <trans-unit id="d28ff0fda5a5612fbf86e8ebd7c80cabd4110b85" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R. This is the default.</source>
          <target state="translated">M32R のコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="20e08fc2eddd3584a33dc2a59b26172bf1281828" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/2.</source>
          <target state="translated">M32R/2のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="1939be789de09c47e008a34d88743773021de724" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/X.</source>
          <target state="translated">M32R/X用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="df8817f533054f34d7acf449e4e33f38657d304e" translate="yes" xml:space="preserve">
          <source>Generate code for the SH1.</source>
          <target state="translated">SH1のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="050479be73754de25483a6e1712e26489d053e34" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2.</source>
          <target state="translated">SH2のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="3723c95f415c4a4c6a69d66a7f758a27732147a1" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a without FPU, or for a SH2a-FPU in such a way that the floating-point unit is not used.</source>
          <target state="translated">FPUを使用しないSH2a用、または浮動小数点単位を使用しないSH2a-FPU用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="bc412156cf20c916e946ffa4cbe84584eb6567a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in double-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットが倍精度モードになっていると仮定して、SH2a-FPUのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="34abdbdae2fa95db6713e96853be2eca7e9c05eb" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットがデフォルトで単精度モードになっていると仮定して、SH2a-FPUのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="1f2673d8ddd54030d4d4878de69f24422a5fdba0" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">倍精度浮動小数点演算を使用しないようにSH2a-FPUのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="483cb3ca44e923a4b1df433858f80751ca9f93aa" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2e.</source>
          <target state="translated">SH2eのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="1a936c359ffaab90c574043388b2920044ce94c5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3.</source>
          <target state="translated">SH3のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="52624bfb24aef64a24903a711fc58d43129edfce" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3e.</source>
          <target state="translated">SH3eのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="3974fd9acf25ff513cb6f41c5bd4a7bda9784a55" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットがデフォルトで単精度モードになっていると仮定して、SH4のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="75d92b5b6d76cda99c6a173e1dd53216d0ca8f31" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 with a floating-point unit that only supports single-precision arithmetic.</source>
          <target state="translated">単精度演算のみをサポートする浮動小数点ユニットを持つSH4のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="162b02716f568279c8d0d5122c58fd1e1d0d9f75" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 without a floating-point unit.</source>
          <target state="translated">浮動小数点ユニットを使用しないSH4のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="63daf68bdeb08d26dfc7feca667cc330215f1c9b" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4.</source>
          <target state="translated">SH4のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="e752d163eaf5a23bc2b7e20cedab4af27f30919d" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">浮動小数点ユニットがデフォルトで単精度モードになっていると仮定して、SH4aのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="9bfcba29114940deb31d10a6d0e6239fe06706a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">倍精度浮動小数点演算を使用しないようにSH4aのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="c9b792a4628ba5fbcf5191ba54ebda633615fe85" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a.</source>
          <target state="translated">SH4aのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="e7ae153f4f4ad9faa39e7795dea14788da791715" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4al-dsp, or for a SH4a in such a way that the floating-point unit is not used.</source>
          <target state="translated">SH4al-dsp用のコード、または浮動小数点単位を使用しないようにSH4a用のコードを生成します。</target>
        </trans-unit>
        <trans-unit id="b868662932b00739d50db318aa2ddd01fc4bd249" translate="yes" xml:space="preserve">
          <source>Generate code for the given ABI.</source>
          <target state="translated">与えられたABIのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="54f462554c550dbd112a2f944735d38c4f45d0bc" translate="yes" xml:space="preserve">
          <source>Generate code for the kernel code model. The kernel runs in the negative 2 GB of the address space. This model has to be used for Linux kernel code.</source>
          <target state="translated">カーネルコードモデルのコードを生成します。カーネルはアドレス空間の負の2GBで動作します。このモデルはLinuxカーネルコードに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f7119380ad6e8c2c7924710a3b532b63b7c448f" translate="yes" xml:space="preserve">
          <source>Generate code for the large code model. This makes no assumptions about addresses and sizes of sections. Programs can be statically linked only.</source>
          <target state="translated">ラージ・コード・モデルのコードを生成します。これは、アドレスやセクションのサイズについての仮定をしません。プログラムは静的にのみリンクすることができます。</target>
        </trans-unit>
        <trans-unit id="e3f449db1f29f06f736e88f3d496de39caace854" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. There is no limitation on call distance, pc-relative addresses, or absolute addresses.</source>
          <target state="translated">大規模モデル用のコードを生成します。呼出距離、PC 相対アドレス、絶対アドレスに制限はありません。</target>
        </trans-unit>
        <trans-unit id="9e0fcd5ba89af087e24036d07076369bc21de870" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. This model makes no assumptions about addresses and sizes of sections.</source>
          <target state="translated">ラージ・モデルのコードを生成します。このモデルでは、アドレスやセクションのサイズについては何も仮定していません。</target>
        </trans-unit>
        <trans-unit id="0971940cc08a4932dadb19e61d4f634d86124a27" translate="yes" xml:space="preserve">
          <source>Generate code for the medium model: the program is linked in the lower 2 GB of the address space. Small symbols are also placed there. Symbols with sizes larger than</source>
          <target state="translated">中型モデルのコードを生成:プログラムはアドレス空間の下位2GBにリンクされています。小さなシンボルもそこに配置されます。よりも大きなサイズのシンボルは</target>
        </trans-unit>
        <trans-unit id="59ca259d5568c2d002dd2ccbe8f095a11b92f1df" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-any code model. The program and its statically defined symbols must be within any single 2 GiB address range. Programs can be statically or dynamically linked.</source>
          <target state="translated">中・任意コードモデルのコードを生成します。プログラムとその静的に定義されたシンボルは、任意の2GiBアドレス範囲内になければなりません。プログラムは静的にも動的にもリンクすることができます。</target>
        </trans-unit>
        <trans-unit id="504796a714036a0c76db86fa41cc45a9fb08427c" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-low code model. The program and its statically defined symbols must lie within a single 2 GiB address range and must lie between absolute addresses -2 GiB and +2 GiB. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">ミディアムローコードモデルのコードを生成します。プログラムとその静的に定義されたシンボルは、2GiBのアドレス範囲内に存在し、絶対アドレス-2GiBと+2GiBの間に存在しなければなりません。プログラムは、静的または動的にリンクすることができます。これがデフォルトのコードモデルです。</target>
        </trans-unit>
        <trans-unit id="071c751072fdeed9625e903fca26e27c829fa3e5" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model. The program and its statically defined symbols must be within 4GB of each other. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">スモールコードモデルのコードを生成します。プログラムとその静的に定義されたシンボルは、互いに4GB以内でなければなりません。プログラムは静的または動的にリンクすることができます。これがデフォルトのコードモデルです。</target>
        </trans-unit>
        <trans-unit id="051a1860ec3526f5a9b8c1256cff7e9959d2ec61" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model: the program and its symbols must be linked in the lower 2 GB of the address space. Pointers are 64 bits. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">スモールコードモデルのコードを生成します:プログラムとそのシンボルは、アドレス空間の下位2GBにリンクされている必要があります。ポインタは64ビットです。プログラムは静的または動的にリンクすることができます。これがデフォルトのコードモデルです。</target>
        </trans-unit>
        <trans-unit id="fccb732c10311c882aff8903c1dae6926a19b9e0" translate="yes" xml:space="preserve">
          <source>Generate code for the small model. The distance for direct calls is limited to 500M in either direction. PC-relative addresses are 32 bits. Absolute addresses support the full address range.</source>
          <target state="translated">小型モデルのコードを生成します。直接通話の距離はどちらか一方の方向に500Mまでとします。PC関連のアドレスは32ビットです。絶対アドレスは全アドレス範囲をサポートしています。</target>
        </trans-unit>
        <trans-unit id="245e4a42ebe1fc23a573492e82ac616ceb7b3a60" translate="yes" xml:space="preserve">
          <source>Generate code for the specified ABI. Permissible values are: &amp;lsquo;</source>
          <target state="translated">指定されたABIのコードを生成します。許容値は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="62cd08507f5129c0313b216b3b312e1f38339400" translate="yes" xml:space="preserve">
          <source>Generate code for the specified architecture. The choices for &lt;var&gt;architecture-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">指定されたアーキテクチャのコードを生成します。 &lt;var&gt;architecture-type&lt;/var&gt; の選択肢は '</target>
        </trans-unit>
        <trans-unit id="fa0e2168d621855d66b05e248a41636b81294293" translate="yes" xml:space="preserve">
          <source>Generate code for the specified calling convention. Permissible values are &amp;lsquo;</source>
          <target state="translated">指定された呼び出し規約のコードを生成します。許容値は '</target>
        </trans-unit>
        <trans-unit id="d43b1f64836a5b0a5d775d2376c530695500c9a6" translate="yes" xml:space="preserve">
          <source>Generate code for the specified data model. Permissible values are &amp;lsquo;</source>
          <target state="translated">指定されたデータモデルのコードを生成します。許容値は '</target>
        </trans-unit>
        <trans-unit id="e12f5237878118905a68ef1df9fd8353d31db89f" translate="yes" xml:space="preserve">
          <source>Generate code for the supervisor mode, where there are no restrictions on the access to general registers. This is the default.</source>
          <target state="translated">一般レジスタへのアクセスに制限がないスーパバイザモード用のコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="e6c40e69179c553d840354dee8e09afd6afb670e" translate="yes" xml:space="preserve">
          <source>Generate code for the tiny code model. The program and its statically defined symbols must be within 1MB of each other. Programs can be statically or dynamically linked.</source>
          <target state="translated">小さなコードモデルのコードを生成します。プログラムとその静的に定義されたシンボルは,互いに1MB以内でなければならない.プログラムは静的にも動的にもリンクすることができます。</target>
        </trans-unit>
        <trans-unit id="9e11e5ef71d66be04277bc1f01b5f5278d9a40a3" translate="yes" xml:space="preserve">
          <source>Generate code for the user mode, where the access to some general registers is forbidden: on the GR5, registers r24 to r31 cannot be accessed in this mode; on the GR6, only registers r29 to r31 are affected.</source>
          <target state="translated">いくつかの一般的なレジスタへのアクセスが禁止されているユーザモード用のコードを生成します:GR5では、このモードではレジスタr24からr31にアクセスできません;GR6ではレジスタr29からr31のみが影響を受けます。</target>
        </trans-unit>
        <trans-unit id="bd8c4bf394db1eaf7b115e9a97579b1aa69d5063" translate="yes" xml:space="preserve">
          <source>Generate code for use in OpenMP offloading: enables</source>
          <target state="translated">OpenMP のオフロードで使用するためのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="16c4c1a05d2b765d07aab8ca18577dc3fd7c3686" translate="yes" xml:space="preserve">
          <source>Generate code in big-endian mode.</source>
          <target state="translated">ビッグエンディアンモードでコードを生成します。</target>
        </trans-unit>
        <trans-unit id="617c48669c81ce32d047fdd88ab6cc36cefe714c" translate="yes" xml:space="preserve">
          <source>Generate code in big/little endian mode, respectively.</source>
          <target state="translated">ビッグエンディアン、リトルエンディアンモードでそれぞれコードを生成します。</target>
        </trans-unit>
        <trans-unit id="f467368c82a003e89d9528f03fca80cb77bf1e51" translate="yes" xml:space="preserve">
          <source>Generate code in little-endian mode.</source>
          <target state="translated">リトルエンディアンモードでコードを生成します。</target>
        </trans-unit>
        <trans-unit id="d2870658bf99f10270c562aaa0ce69afd3724aea" translate="yes" xml:space="preserve">
          <source>Generate code suitable for big switch tables. Use this option only if the assembler/linker complain about out of range branches within a switch table.</source>
          <target state="translated">大きなスイッチテーブルに適したコードを生成します。このオプションは、アセンブラ/リンカがスイッチテーブル内の範囲外の分岐について文句を言う場合にのみ使用します。</target>
        </trans-unit>
        <trans-unit id="31742c20f6d08e41957b4759da6c2e20cfa33560" translate="yes" xml:space="preserve">
          <source>Generate code suitable for fast turnaround development, such as to allow GDB to dynamically load</source>
          <target state="translated">GDBが動的にロードできるようにするなど、迅速なターンアラウンド開発に適したコードを生成します。</target>
        </trans-unit>
        <trans-unit id="f9c5e3444f60e6e1d269aebfea1614af0e0ffa27" translate="yes" xml:space="preserve">
          <source>Generate code that adds (does not add) in TPF OS specific branches to trace routines in the operating system. This option is off by default, even when compiling for the TPF OS.</source>
          <target state="translated">オペレーティングシステム内のトレースルーチンにTPF OS固有のブランチを追加する(追加しない)コードを生成します。このオプションは、TPF OS 用にコンパイルする場合でも、デフォルトではオフになっています。</target>
        </trans-unit>
        <trans-unit id="cf132e8fd4ca1bac8a3c035b0896be35d4f95248" translate="yes" xml:space="preserve">
          <source>Generate code that allows (does not allow) a static executable to be relocated to a different address at run time. A simple embedded PowerPC system loader should relocate the entire contents of &lt;code&gt;.got2&lt;/code&gt; and 4-byte locations listed in the &lt;code&gt;.fixup&lt;/code&gt; section, a table of 32-bit addresses generated by this option. For this to work, all objects linked together must be compiled with</source>
          <target state="translated">静的実行可能ファイルを実行時に別のアドレスに再配置できるようにする（許可しない）コードを生成します。単純な組み込みPowerPCシステムローダーは、 &lt;code&gt;.got2&lt;/code&gt; のコンテンツ全体と、このオプションによって生成される32ビットアドレスのテーブルである &lt;code&gt;.fixup&lt;/code&gt; セクションにリストされている4バイトの場所を再配置する必要があります。これが機能するためには、リンクされているすべてのオブジェクトが</target>
        </trans-unit>
        <trans-unit id="86d1c7c8ebb812df3d75ca440f1dd938fb6de6fb" translate="yes" xml:space="preserve">
          <source>Generate code that allows &lt;code&gt;ld&lt;/code&gt; and &lt;code&gt;ld.so&lt;/code&gt; to build executables and shared libraries with non-executable &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">&lt;code&gt;ld&lt;/code&gt; および &lt;code&gt;ld.so&lt;/code&gt; が実行可能でない &lt;code&gt;.plt&lt;/code&gt; および &lt;code&gt;.got&lt;/code&gt; セクションを含む実行可能ファイルと共有ライブラリを構築できるようにするコードを生成します。これは、PowerPC 32ビットSYSV ABIオプションです。</target>
        </trans-unit>
        <trans-unit id="2493e6ad3aa4a2943864620cf6ffd109b6ddb3da" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute in place in an environment without virtual memory management by eliminating relocations against the text section.</source>
          <target state="translated">データセグメントがテキストセグメントとは異なるメモリ領域に位置するようにするコードを生成します。これにより、テキスト部分に対する再配置を排除することで、仮想メモリ管理のない環境でもその場での実行が可能になります。</target>
        </trans-unit>
        <trans-unit id="eb6f87eee15c30331198259c5e0fa884666e3b45" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute-in-place in an environment without virtual memory management. This option implies</source>
          <target state="translated">データセグメントがテキストセグメントとは異なるメモリ領域に配置されるようにするコードを生成します。これにより、仮想メモリ管理のない環境でも、その場で実行できるようになります。このオプションは</target>
        </trans-unit>
        <trans-unit id="338b24d92797baf1f472014c3eb7e81cad28ab15" translate="yes" xml:space="preserve">
          <source>Generate code that allows trapping instructions to throw exceptions. Note that this requires platform-specific runtime support that does not exist everywhere. Moreover, it only allows &lt;em&gt;trapping&lt;/em&gt; instructions to throw exceptions, i.e. memory references or floating-point instructions. It does not allow exceptions to be thrown from arbitrary signal handlers such as &lt;code&gt;SIGALRM&lt;/code&gt;.</source>
          <target state="translated">トラップ命令が例外をスローできるようにするコードを生成します。これには、どこにも存在しないプラットフォーム固有のランタイムサポートが必要であることに注意してください。さらに、&lt;em&gt;トラッピング&lt;/em&gt;命令が例外をスローすることのみを許可します（メモリ参照または浮動小数点命令など）。 &lt;code&gt;SIGALRM&lt;/code&gt; などの任意のシグナルハンドラから例外をスローすることはできません。</target>
        </trans-unit>
        <trans-unit id="fbd1ec35fb62e61a3c0c9ad20b949b97f631374a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes (does not assume) that all calls are far away so that a longer more expensive calling sequence is required.</source>
          <target state="translated">すべての呼び出しが遠くにあると仮定して(仮定しない)、より長い高価な呼び出しシーケンスが必要となるようなコードを生成します。</target>
        </trans-unit>
        <trans-unit id="8f709a2890cb93e8763f592a97bd90453baa9bc3" translate="yes" xml:space="preserve">
          <source>Generate code that assumes calls never cross space boundaries. This allows GCC to emit code that performs faster indirect calls.</source>
          <target state="translated">呼び出しが空間の境界を越えないことを前提としたコードを生成します。これにより、GCCは間接的な呼び出しを高速に実行するコードを生成することができます。</target>
        </trans-unit>
        <trans-unit id="16b9beb60bdc4afff878eec93b064cf17ba08cf6" translate="yes" xml:space="preserve">
          <source>Generate code that assumes that the data segment follows the text segment. This is the default.</source>
          <target state="translated">データセグメントがテキストセグメントに続くことを前提としたコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="336489e1da74ce723400b7df9bbae17f47d7009a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes the target has no space registers. This allows GCC to generate faster indirect calls and use unscaled index address modes.</source>
          <target state="translated">ターゲットがスペースレジスタを持たないことを前提としたコードを生成します。これにより、GCC はより高速な間接呼び出しを生成し、スケールされていないインデックスアドレスモードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="918ffaae0c58edeaaf21af8db9990d1e80c480af" translate="yes" xml:space="preserve">
          <source>Generate code that does not use (uses) the floating-point register set. Software floating-point emulation is provided if you use the</source>
          <target state="translated">浮動小数点レジスタセットを使用しない(使用しない)コードを生成します。ソフトウェア浮動小数点エミュレーションは</target>
        </trans-unit>
        <trans-unit id="c1d77eef17962d23aa2b64213060026efae223d1" translate="yes" xml:space="preserve">
          <source>Generate code that does not use &lt;code&gt;.local&lt;/code&gt; memory directly for stack storage. Instead, a per-warp stack pointer is maintained explicitly. This enables variable-length stack allocation (with variable-length arrays or &lt;code&gt;alloca&lt;/code&gt;), and when global memory is used for underlying storage, makes it possible to access automatic variables from other threads, or with atomic instructions. This code generation variant is used for OpenMP offloading, but the option is exposed on its own for the purpose of testing the compiler; to generate code suitable for linking into programs using OpenMP offloading, use option</source>
          <target state="translated">スタックストレージに直接 &lt;code&gt;.local&lt;/code&gt; メモリを使用しないコードを生成します。代わりに、ワープごとのスタックポインターが明示的に維持されます。これにより、可変長のスタック割り当てが可能になり（可変長配列または &lt;code&gt;alloca&lt;/code&gt; を使用）、基になるストレージにグローバルメモリが使用されている場合、他のスレッドから、またはアトミック命令を使用して自動変数にアクセスできます。このコード生成バリアントはOpenMPオフロードに使用されますが、オプションはコンパイラーをテストする目的で単独で公開されます。OpenMPオフロードを使用してプログラムにリンクするのに適したコードを生成するには、オプションを使用します</target>
        </trans-unit>
        <trans-unit id="44ab5ca5f8364ad55909ace91a8c6e880674fbc6" translate="yes" xml:space="preserve">
          <source>Generate code that does not use a global pointer register. The result is not position independent code, and violates the IA-64 ABI.</source>
          <target state="translated">グローバルポインタレジスタを使用しないコードを生成します。その結果は位置に依存しないコードではなく、IA-64 ABIに違反します。</target>
        </trans-unit>
        <trans-unit id="60de4e859809d0c4dc8e855c46af0110311ff144" translate="yes" xml:space="preserve">
          <source>Generate code that doesn&amp;rsquo;t assume ID-based shared libraries are being used. This is the default.</source>
          <target state="translated">IDベースの共有ライブラリが使用されていることを前提としないコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="354fbc6c3e514e9f7e68643c90303161a363d508" translate="yes" xml:space="preserve">
          <source>Generate code that is self-relocatable. This implies</source>
          <target state="translated">自己再配置可能なコードを生成します。これは</target>
        </trans-unit>
        <trans-unit id="13b5daaeeae847dab7bba6f104ed44e1ab6ee054" translate="yes" xml:space="preserve">
          <source>Generate code that keeps (does not keeps) some integer operations adjacent so that the instructions can be fused together on power8 and later processors.</source>
          <target state="translated">Power8 以降のプロセッサで命令を融合できるように、いくつかの整数演算を隣接して保持する (保持しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="ebb2d4ebaa412c3ca6bb8549fd5605ffef2b8a3c" translate="yes" xml:space="preserve">
          <source>Generate code that passes function parameters and return values that (in the called function) are seen as registers &lt;code&gt;$0&lt;/code&gt; and up, as opposed to the GNU ABI which uses global registers &lt;code&gt;$231&lt;/code&gt; and up.</source>
          <target state="translated">グローバルレジスタ &lt;code&gt;$231&lt;/code&gt; を使用するGNU ABIとは対照的に、関数のパラメーターと戻り値（呼び出された関数内）がレジスタ &lt;code&gt;$0&lt;/code&gt; と見なされるコードを生成します。</target>
        </trans-unit>
        <trans-unit id="572a137e555b3b3423721fc0e3626b6e8b160c46" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;arch&lt;/var&gt;, which can be the name of a generic MIPS ISA, or the name of a particular processor. The ISA names are: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;arch&lt;/var&gt; で実行されるコードを生成します。これは、汎用MIPS ISAの名前、または特定のプロセッサーの名前にすることができます。ISA名は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e20973741c69f13efd8aaaa56fd8109762470570" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;cpu-type&lt;/var&gt;, which is the name of a system representing a certain processor type. Possible values for &lt;var&gt;cpu-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">特定のプロセッサタイプを表すシステムの名前である &lt;var&gt;cpu-type&lt;/var&gt; で実行されるコードを生成します。 &lt;var&gt;cpu-type&lt;/var&gt; の可能な値は '</target>
        </trans-unit>
        <trans-unit id="2afe5cce361ce178d21f1f9e300c77965e025f71" translate="yes" xml:space="preserve">
          <source>Generate code that supports calling between the ARM and Thumb instruction sets. Without this option, on pre-v5 architectures, the two instruction sets cannot be reliably used inside one program. The default is</source>
          <target state="translated">ARM 命令セットと Thumb 命令セット間の呼び出しをサポートするコードを生成します。このオプションがないと、v5 以前のアーキテクチャでは、2 つの命令セットを 1 つのプログラム内で確実に使用できません。デフォルトは</target>
        </trans-unit>
        <trans-unit id="1e1b0c53abd34ffe18acaa9b5781550d29a84379" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method, but assumes that this library or executable won&amp;rsquo;t link against any other ID shared libraries. That allows the compiler to use faster code for jumps and calls.</source>
          <target state="translated">ライブラリIDメソッドを介して共有ライブラリをサポートするコードを生成しますが、このライブラリまたは実行可能ファイルは他のID共有ライブラリとリンクしないと想定しています。これにより、コンパイラはジャンプと呼び出しにより高速なコードを使用できます。</target>
        </trans-unit>
        <trans-unit id="19a4d4ef1ca305d055c2c43578e68d17e9af2a97" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute in place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">ライブラリIDメソッドで共有ライブラリをサポートするコードを生成します。これにより、仮想メモリ管理のない環境でも、その場で実行したり、共有ライブラリを利用したりすることが可能になります。このオプションは</target>
        </trans-unit>
        <trans-unit id="d499e8859196b03e31f4b5d6d30e4cb073e79ae2" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute-in-place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">ライブラリIDメソッドで共有ライブラリをサポートするコードを生成します。これにより、仮想メモリ管理のない環境での実行インプレースや共有ライブラリの利用が可能になります。このオプションは</target>
        </trans-unit>
        <trans-unit id="3080019b4a448b8d2f42e11601716bd17c75e272" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions.</source>
          <target state="translated">インデックス付きロード命令やストア命令の使用を回避しようとする(回避しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="1d7d0f8dbe32444b165a61440094a0d21d656220" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions. These instructions can incur a performance penalty on Power6 processors in certain situations, such as when stepping through large arrays that cross a 16M boundary. This option is enabled by default when targeting Power6 and disabled otherwise.</source>
          <target state="translated">インデックス付きロード命令やストア命令の使用を避けようとする(避けない)コードを生成します。これらの命令は、16M の境界を越える大規模な配列をステップスルーする場合など、特定の状況では Power6 プロセッサでパフォーマンスのペナルティを受ける可能性があります。このオプションは、Power6 をターゲットにしている場合はデフォルトで有効になっており、そうでない場合は無効になっています。</target>
        </trans-unit>
        <trans-unit id="bf98fe716d964a094592ad1d59afe4951cb9d36f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions, and also enable the use of built-in functions that allow more direct access to the AltiVec instruction set. You may also need to set</source>
          <target state="translated">AltiVec 命令を使用する(使用しない)コードを生成し、AltiVec 命令セットへのより直接的なアクセスを可能にする組み込み関数の使用も可能にします。を設定する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="2f5b28537613ef22817b9ba8bf63c4e1f2104514" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions. In 32-bit code, you cannot enable AltiVec instructions unless</source>
          <target state="translated">AltiVec 命令を使用する(使用しない)コードを生成します。32 ビットコードでは、以下の場合を除き、AltiVec 命令を有効にすることはできません。</target>
        </trans-unit>
        <trans-unit id="8c04238a31ea4511a013025b49118e3c3e42e84e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) ISEL instruction.</source>
          <target state="translated">ISEL命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="92155be900bc9933add2300c7a5d23503087ce0e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) VAX F and G floating-point arithmetic instead of IEEE single and double precision.</source>
          <target state="translated">IEEEの単精度と倍精度の代わりにVAX FとGの浮動小数点演算を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="b95c7c98a27a75ea4aed9a1312a1f6d81d84fc5d" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP move to/from general purpose register instructions implemented on the POWER6X processor and other processors that support the extended PowerPC V2.05 architecture.</source>
          <target state="translated">POWER6Xプロセッサや拡張PowerPC V2.05アーキテクチャをサポートする他のプロセッサで実装されているFPの汎用レジスタへの移動命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="a2c4f9d3a1eb191b5662b1d07619055360c468c4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP round to integer instructions implemented on the POWER5+ processor and other processors that support the PowerPC V2.03 architecture.</source>
          <target state="translated">POWER5+プロセッサやPowerPC V2.03アーキテクチャをサポートする他のプロセッサに実装されたFPラウンドから整数命令までを使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="46d6eec21f4fa802b85560d860276b9199fed94b" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the atomic quad word memory instructions. The</source>
          <target state="translated">アトミック・クワッドワードメモリ命令を使用する(使用しない)コードを生成します。のように、そのようなコードを生成するためには</target>
        </trans-unit>
        <trans-unit id="262e0fd3e027fbfbead855b3f29a870f608f4f72" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the compare bytes instruction implemented on the POWER6 processor and other processors that support the PowerPC V2.05 architecture.</source>
          <target state="translated">POWER6 プロセッサおよび PowerPC V2.05 アーキテクチャをサポートする他のプロセッサで実装されている compare bytes 命令を使用する (使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="08b86aae00b13e22b96514a69b5b064be8919eb4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the decimal floating-point instructions implemented on some POWER processors.</source>
          <target state="translated">いくつかのPOWERプロセッサで実装されている10進浮動小数点命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="3131d9ab648d637f7f2b9519e03b551e9a374743" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used.</source>
          <target state="translated">浮動小数点乗算および累積命令を使用する(使用しない)コードを生成します。ハードウェア浮動小数点を使用する場合、これらの命令はデフォルトで生成されます。</target>
        </trans-unit>
        <trans-unit id="c04a8a825b0f94e2eb07f4e8f21cb84241b2efaf" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used. The machine-dependent</source>
          <target state="translated">浮動小数点乗算および累積命令を使用する(使用しない)コードを生成します。ハードウェア浮動小数点を使用する場合、これらの命令はデフォルトで生成されます。マシンに依存する</target>
        </trans-unit>
        <trans-unit id="61eadf2cc65c85da3c9ba20e0d77a3b18047c546" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point register set.</source>
          <target state="translated">浮動小数点レジスタセットを使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="32b3b39a373f02faec1c8e47cea1029610f3648e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the generation of PAIRED simd instructions.</source>
          <target state="translated">ペアリングされた simd 命令の生成を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="a16384b2cc48decd8d149f4edeab3b4637c6c2dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the half-word multiply and multiply-accumulate instructions on the IBM 405, 440, 464 and 476 processors. These instructions are generated by default when targeting those processors.</source>
          <target state="translated">IBM 405、440、464、および 476 プロセッサ上のハーフワード乗算および乗算累積命令を使用する (使用しない)コードを生成します。これらの命令は、これらのプロセッサをターゲットにしている場合、デフォルトで生成されます。</target>
        </trans-unit>
        <trans-unit id="0ae0cd2b0200a8b41b70cb257df1cc0c71cf4ea9" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions.</source>
          <target state="translated">複数ワードのロード命令と複数ワードのストア命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="2c52b95b537c53566c2534b67e93882f9aca68b1" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions. These instructions are generated by default on POWER systems, and not generated on PowerPC systems. Do not use</source>
          <target state="translated">複数ワードのロード命令と複数ワードのストア命令を使用する(使用しない)コードを生成します。これらの命令は、POWER システムではデフォルトで生成され、PowerPC システムでは生成されません。使用しないでください。</target>
        </trans-unit>
        <trans-unit id="fd774e2be13b8cb13d5052ff903f2b6dbbaa0be4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location.</source>
          <target state="translated">ベースレジスタを計算されたメモリ位置のアドレスに更新するロード命令またはストア命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="a22e11f108e540ae0805ccbff5751fce923b96a4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location. These instructions are generated by default. If you use</source>
          <target state="translated">ベースレジスタを計算されたメモリ位置のアドレスに更新するロード命令またはストア命令を使用する(使用しない)コードを生成します。これらの命令はデフォルトで生成されます。を使用する場合は</target>
        </trans-unit>
        <trans-unit id="0770f3e5c30f3b0aaaeba94f431ff5516808b06c" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load string instructions and the store string word instructions to save multiple registers and do small block moves.</source>
          <target state="translated">ロード文字列命令とストア文字列ワード命令を使用する(使用しない)コードを生成して、複数のレジスタを保存し、小さなブロック移動を行います。</target>
        </trans-unit>
        <trans-unit id="386b3e18aecf301e2272c3303cef5b3408b3d72f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the move from condition register field instruction implemented on the POWER4 processor and other processors that support the PowerPC V2.01 architecture.</source>
          <target state="translated">POWER4プロセッサやPowerPC V2.01アーキテクチャをサポートする他のプロセッサで実装されている条件レジスタフィールド命令からの移動を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="87adae88954ee8917f3f31be376d9936d82cd4bc" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the non-atomic quad word memory instructions. The</source>
          <target state="translated">非原子型クワッドワードメモリ命令を使用する(使用しない)コードを生成します。このようなコードを生成するためには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="fc8745a466eb796ef7f9c5a441c7003ed311977e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root.</source>
          <target state="translated">浮動小数点平方根を含む汎用グループのオプションのPowerPCアーキテクチャ命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="27810752cbb1f58324d02017084ca261477ff314" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the Graphics group, including floating-point select.</source>
          <target state="translated">グラフィックスグループのオプションのPowerPCアーキテクチャ命令(浮動小数点選択を含む)を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="98f0227605ad4df08722181505cb7a14d55e9799" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount and double-precision FP reciprocal estimate instruction implemented on the POWER5 processor and other processors that support the PowerPC V2.02 architecture.</source>
          <target state="translated">POWER5プロセッサやPowerPC V2.02アーキテクチャをサポートする他のプロセッサで実装されているpopcountおよび倍精度FP逆見積命令を使用する(使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="c07537f1993a55be984ad5f397058498e67120dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount instruction implemented on the POWER7 processor and other processors that support the PowerPC V2.06 architecture.</source>
          <target state="translated">POWER7 プロセッサおよび PowerPC V2.06 アーキテクチャをサポートする他のプロセッサで実装された popcount 命令を使用する (使用しない)コードを生成します。</target>
        </trans-unit>
        <trans-unit id="4b15de7f2b7f03ed6e1790dbf982c588fb5b3528" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the string-search &amp;lsquo;</source>
          <target state="translated">string-searchを使用する（使用しない）コードを生成する</target>
        </trans-unit>
        <trans-unit id="ab7a2922566d7313797a3ac188f3c0be7688df71" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the vector and scalar instructions that were added in version 2.07 of the PowerPC ISA. Also enable the use of built-in functions that allow more direct access to the vector instructions.</source>
          <target state="translated">PowerPC ISA のバージョン 2.07 で追加されたベクトル命令とスカラ命令を使用する(使用しない)コードを生成します。また、ベクター命令へのより直接的なアクセスを可能にする組み込み関数の使用を可能にします。</target>
        </trans-unit>
        <trans-unit id="f7dd4f67d21a30765965ab7e7de435cac230ac64" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set.</source>
          <target state="translated">ベクトル/スカラ(VSX)命令を使用する(使用しない)コードを生成し、VSX命令セットへのより直接的なアクセスを可能にする組み込み関数の使用を可能にします。</target>
        </trans-unit>
        <trans-unit id="05ca89c3814bc0cbed05cab7398d230442544564" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set. In 32-bit code, you cannot enable VSX or AltiVec instructions unless</source>
          <target state="translated">ベクトル/スカラ(VSX)命令を使用する(使用しない)コードを生成し、VSX命令セットへのより直接的なアクセスを可能にする組み込み関数の使用を有効にします。32 ビットコードでは、以下の場合を除き、VSX 命令や AltiVec 命令を有効にすることはできません。</target>
        </trans-unit>
        <trans-unit id="67b86bb995294b5ded4deb3fb6384281013e8cde" translate="yes" xml:space="preserve">
          <source>Generate code that uses a BSS &lt;code&gt;.plt&lt;/code&gt; section that &lt;code&gt;ld.so&lt;/code&gt; fills in, and requires &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections that are both writable and executable. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">&lt;code&gt;ld.so&lt;/code&gt; が埋めるBSS &lt;code&gt;.plt&lt;/code&gt; セクションを使用するコードを生成し、書き込み可能で実行可能である &lt;code&gt;.plt&lt;/code&gt; および &lt;code&gt;.got&lt;/code&gt; セクションを必要とします。これは、PowerPC 32ビットSYSV ABIオプションです。</target>
        </trans-unit>
        <trans-unit id="6beeb427ddc734bea4c58516baa43a91d09099d2" translate="yes" xml:space="preserve">
          <source>Generate code that uses a single constant global pointer value. This is useful when compiling kernel code.</source>
          <target state="translated">単一の定数グローバルポインタの値を使用するコードを生成します。これはカーネルコードをコンパイルするときに便利です。</target>
        </trans-unit>
        <trans-unit id="6f2e6ea4728870634a5f76e2497b052f725aed62" translate="yes" xml:space="preserve">
          <source>Generate code that uses long call sequences. This ensures that a call is always able to reach linker generated stubs. The default is to generate long calls only when the distance from the call site to the beginning of the function or translation unit, as the case may be, exceeds a predefined limit set by the branch type being used. The limits for normal calls are 7,600,000 and 240,000 bytes, respectively for the PA 2.0 and PA 1.X architectures. Sibcalls are always limited at 240,000 bytes.</source>
          <target state="translated">長い呼び出しシーケンスを使用するコードを生成します。これにより、呼び出しがリンカで生成されたスタブに常に到達できるようになります。デフォルトでは、コール・サイトから関数または変換ユニットの先頭までの距離が、使用するブランチ・タイプによって設定された事前の制限を超えた場合にのみ、長いコールを生成するようになっています。通常の通話の制限は、PA 2.0 および PA 1.X アーキテクチャの場合、それぞれ 7,600,000 バイトおよび 240,000 バイトです。シブコールは常に 240,000 バイトに制限されています。</target>
        </trans-unit>
        <trans-unit id="0ddfa4b3d16d23a89e5776522951b15e62426fdc" translate="yes" xml:space="preserve">
          <source>Generate code that uses only the general-purpose registers. This prevents the compiler from using floating-point, vector, mask and bound registers.</source>
          <target state="translated">汎用レジスタのみを使用するコードを生成します。これにより、コンパイラが浮動小数点レジスタ、ベクターレジスタ、マスクレジスタ、バインドレジスタを使用することを防ぎます。</target>
        </trans-unit>
        <trans-unit id="baac973b3b5994adc6aef021db0133816bd28382" translate="yes" xml:space="preserve">
          <source>Generate code to access thread-local storage using the &amp;lsquo;</source>
          <target state="translated">'を使用してスレッドローカルストレージにアクセスするコードを生成します</target>
        </trans-unit>
        <trans-unit id="c88cdcf77b77d16255b95669179f017ca5ceda39" translate="yes" xml:space="preserve">
          <source>Generate code to automatically split the stack before it overflows. The resulting program has a discontiguous stack which can only overflow if the program is unable to allocate any more memory. This is most useful when running threaded programs, as it is no longer necessary to calculate a good stack size to use for each thread. This is currently only implemented for the x86 targets running GNU/Linux.</source>
          <target state="translated">オーバーフローする前にスタックを自動的に分割するコードを生成します。結果として得られるプログラムは不連続なスタックを持ち、 プログラムがこれ以上メモリを確保できなくなった場合にのみオーバーフローすることができます。これはスレッド化されたプログラムを実行しているときに最も便利です。これは現在のところ、GNU/Linux を実行している x86 ターゲットにのみ実装されています。</target>
        </trans-unit>
        <trans-unit id="915ccec10fdc8928f52708c97467282540464b8a" translate="yes" xml:space="preserve">
          <source>Generate code to avoid bugs in the multiply instructions for the MN10300 processors. This is the default.</source>
          <target state="translated">MN10300プロセッサ用の乗算命令のバグを回避するためのコードを生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="0df3e04d22344e23f6649b40a52c7d6f0c186350" translate="yes" xml:space="preserve">
          <source>Generate code to ensure that the stack does not grow beyond a certain value, either the value of a register or the address of a symbol. If a larger stack is required, a signal is raised at run time. For most targets, the signal is raised before the stack overruns the boundary, so it is possible to catch the signal without taking special precautions.</source>
          <target state="translated">スタックが特定の値(レジスタの値またはシンボルのアドレス)を超えて大きくならないようにするコードを生成します。より大きなスタックが必要な場合、実行時にシグナルが発生します。ほとんどのターゲットでは、スタックが境界を超える前にシグナルが発生するので、特別な注意を払わなくてもシグナルをキャッチすることができます。</target>
        </trans-unit>
        <trans-unit id="1b66c9f22b9ae2f51f7b68dcb90be43a732528ba" translate="yes" xml:space="preserve">
          <source>Generate code to prevent stack clash style attacks. When this option is enabled, the compiler will only allocate one page of stack space at a time and each page is accessed immediately after allocation. Thus, it prevents allocations from jumping over any stack guard page provided by the operating system.</source>
          <target state="translated">スタック衝突スタイルの攻撃を防ぐコードを生成します。このオプションを有効にすると、コンパイラは一度にスタック領域の1ページのみを割り当て、各ページは割り当て後すぐにアクセスされます。したがって、アロケーションがオペレーティングシステムによって提供されるスタックガードページを飛び越えてしまうことを防ぎます。</target>
        </trans-unit>
        <trans-unit id="dd0c489c581360afbf7f7a5091b3992e53e109af" translate="yes" xml:space="preserve">
          <source>Generate code to verify that you do not go beyond the boundary of the stack. You should specify this flag if you are running in an environment with multiple threads, but you only rarely need to specify it in a single-threaded environment since stack overflow is automatically detected on nearly all systems if there is only one stack.</source>
          <target state="translated">スタックの境界を超えていないことを検証するコードを生成します。複数のスレッドが存在する環境で実行している場合はこのフラグを指定する必要がありますが、シングルスレッド環境で指定する必要はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="f09658f66e71e4832575a43871e37604d20cbdbd" translate="yes" xml:space="preserve">
          <source>Generate code treating the given register range as fixed registers. A fixed register is one that the register allocator cannot use. This is useful when compiling kernel code. A register range is specified as two registers separated by a dash. Multiple register ranges can be specified separated by a comma.</source>
          <target state="translated">与えられたレジスタ範囲を固定レジスタとして扱うコードを生成します。固定レジスタとは、レジスタアロケータが使用できないレジスタのことです。これはカーネルコードをコンパイルするときに便利です。レジスタ範囲はダッシュで区切られた2つのレジスタとして指定されます。複数のレジスタ範囲をカンマで区切って指定することができます。</target>
        </trans-unit>
        <trans-unit id="69365c978ad182890bcb4e65e053170c8830231a" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; instructions. This option defaults to on.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; および &lt;code&gt;pop&lt;/code&gt; 命令を使用してコードを生成します。このオプションのデフォルトはオンです。</target>
        </trans-unit>
        <trans-unit id="7f296d4ed278effc8fa87bfb0e530628874d3432" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;stm&lt;/code&gt; and &lt;code&gt;ldm&lt;/code&gt; instructions. This option isn&amp;rsquo;t supported on CK801 but is enabled by default on other processors.</source>
          <target state="translated">&lt;code&gt;stm&lt;/code&gt; および &lt;code&gt;ldm&lt;/code&gt; 命令を使用してコードを生成します。このオプションはCK801ではサポートされていませんが、他のプロセッサではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="ba4d33b91d9e6ab2d69e87dce44c7244b439ed9e" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33 processor.</source>
          <target state="translated">AM33プロセッサに特有の機能を使用してコードを生成します。</target>
        </trans-unit>
        <trans-unit id="b0f3f1a0016506b7432a6808d95156263172db1a" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33/2.0 processor.</source>
          <target state="translated">AM33/2.0プロセッサに特有の機能を使用してコードを生成します。</target>
        </trans-unit>
        <trans-unit id="4d51b4beaa1d3a18f186ce7d15002cb82d47e204" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM34 processor.</source>
          <target state="translated">AM34プロセッサに特有の機能を使用してコードを生成します。</target>
        </trans-unit>
        <trans-unit id="c282f618bb7db95f0feff29b3266b2478e4e252b" translate="yes" xml:space="preserve">
          <source>Generate code using global anchor symbol addresses.</source>
          <target state="translated">グローバルアンカーシンボルアドレスを使用してコードを生成します。</target>
        </trans-unit>
        <trans-unit id="cb509e9252b480e0a1aeb49faf8b1ef18fa7edf6" translate="yes" xml:space="preserve">
          <source>Generate code using the FDPIC ABI.</source>
          <target state="translated">FDPIC ABIを使用してコードを生成します。</target>
        </trans-unit>
        <trans-unit id="404e8a65099de95616c40afb1bc863ffa2523650" translate="yes" xml:space="preserve">
          <source>Generate code using the high registers numbered 16-31. This option is not supported on CK801, CK802, or CK803, and is enabled by default for other processors.</source>
          <target state="translated">16-31番の上位レジスタを使用してコードを生成します。このオプションはCK801、CK802、CK803ではサポートされておらず、他のプロセッサではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="4cb05ce3f6ef091d20d86e01a77fc7f4a59d0bcc" translate="yes" xml:space="preserve">
          <source>Generate code which uses only the general-purpose registers. This will prevent the compiler from using floating-point and Advanced SIMD registers but will not impose any restrictions on the assembler.</source>
          <target state="translated">汎用レジスタのみを使用するコードを生成します。これにより、コンパイラが浮動小数点レジスタやAdvanced SIMDレジスタを使用しないようになりますが、アセンブラには何の制限もかかりません。</target>
        </trans-unit>
        <trans-unit id="9cce76ef82a38c3b96967249a0f61e0fb26b9334" translate="yes" xml:space="preserve">
          <source>Generate compiler predefines and select a startfile for the specified UNIX standard. The choices for &lt;var&gt;unix-std&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">コンパイラを生成して、指定されたUNIX標準の開始ファイルを事前定義および選択します。 &lt;var&gt;unix-std&lt;/var&gt; の選択肢は '</target>
        </trans-unit>
        <trans-unit id="a678e34a31471d170303da9eda1b930e2324a992" translate="yes" xml:space="preserve">
          <source>Generate conditional move instructions.</source>
          <target state="translated">条件付きの動作命令を生成します。</target>
        </trans-unit>
        <trans-unit id="d72e8c8e0f9b51ca898631ea4a5646d5c76664c2" translate="yes" xml:space="preserve">
          <source>Generate divide instructions. Default is off.</source>
          <target state="translated">分割命令を生成します。デフォルトはオフです。</target>
        </trans-unit>
        <trans-unit id="16d77d1fe0a8bda494d3925636feea2c269c0e3f" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">コンパクトな実装のためにチューニングされた倍精度FPX命令を生成します。</target>
        </trans-unit>
        <trans-unit id="c229df63f7c476d6f9fecd75b4ac0f6491159589" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">高速な実装のためにチューニングされた倍精度FPX命令を生成します。</target>
        </trans-unit>
        <trans-unit id="efd3351263c1d9caa26ca401350421bfc7b35243" translate="yes" xml:space="preserve">
          <source>Generate extended arithmetic instructions. Currently only &lt;code&gt;divaw&lt;/code&gt;, &lt;code&gt;adds&lt;/code&gt;, &lt;code&gt;subs&lt;/code&gt;, and &lt;code&gt;sat16&lt;/code&gt; are supported. This is always enabled for</source>
          <target state="translated">拡張算術命令を生成します。現在、 &lt;code&gt;divaw&lt;/code&gt; 、 &lt;code&gt;adds&lt;/code&gt; 、 &lt;code&gt;subs&lt;/code&gt; 、 &lt;code&gt;sat16&lt;/code&gt; のみがサポートされています。これは常に有効です</target>
        </trans-unit>
        <trans-unit id="6856e99222352076039e94fbdf5c31806c05feaa" translate="yes" xml:space="preserve">
          <source>Generate extended debug information for inlined functions. Location view tracking markers are inserted at inlined entry points, so that address and view numbers can be computed and output in debug information. This can be enabled independently of location views, in which case the view numbers won&amp;rsquo;t be output, but it can only be enabled along with statement frontiers, and it is only enabled by default if location views are enabled.</source>
          <target state="translated">インライン関数の拡張デバッグ情報を生成します。インラインのエントリポイントに位置ビュー追跡マーカーが挿入されるため、住所とビュー番号を計算してデバッグ情報に出力できます。これは、位置ビューとは無関係に有効にできます。その場合、ビュー番号は出力されませんが、ステートメントフロンティアと一緒にのみ有効にできます。デフォルトで有効になるのは、位置ビューが有効になっている場合のみです。</target>
        </trans-unit>
        <trans-unit id="5d0b2408362730cc5b4ed897b120cdb4b4cc4031" translate="yes" xml:space="preserve">
          <source>Generate extra code to write profile information suitable for the analysis program &lt;code&gt;prof&lt;/code&gt; (for</source>
          <target state="translated">分析プログラム &lt;code&gt;prof&lt;/code&gt; に適したプロファイル情報を書き込むための追加コードを生成します（</target>
        </trans-unit>
        <trans-unit id="c6eeb91a33862dbf10594e59a0033583feb5fde5" translate="yes" xml:space="preserve">
          <source>Generate floating-point arithmetic for selected unit &lt;var&gt;unit&lt;/var&gt;. The choices for &lt;var&gt;unit&lt;/var&gt; are:</source>
          <target state="translated">選択した単位 &lt;var&gt;unit&lt;/var&gt; の浮動小数点演算を生成します。 &lt;var&gt;unit&lt;/var&gt; の選択肢は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="79ec4a91ff56b1468e2e0960559756f702528e59" translate="yes" xml:space="preserve">
          <source>Generate floating-point comparison instructions that compare with respect to the &lt;code&gt;rE&lt;/code&gt; epsilon register.</source>
          <target state="translated">&lt;code&gt;rE&lt;/code&gt; イプシロンレジスタと比較する浮動小数点比較命令を生成します。</target>
        </trans-unit>
        <trans-unit id="5184b7fbfd727379c1835aa4d91abffedcc6f989" translate="yes" xml:space="preserve">
          <source>Generate floating-point instructions. This is the default for 68020 and above, and for ColdFire devices that have an FPU. It defines the macro &lt;code&gt;__HAVE_68881__&lt;/code&gt; on M680x0 targets and &lt;code&gt;__mcffpu__&lt;/code&gt; on ColdFire targets.</source>
          <target state="translated">浮動小数点命令を生成します。これは68020以降、およびFPUを備えたColdFireデバイスのデフォルトです。これは、マクロ定義 &lt;code&gt;__HAVE_68881__&lt;/code&gt; M680x0ターゲットとの &lt;code&gt;__mcffpu__&lt;/code&gt; のColdFireターゲット上を。</target>
        </trans-unit>
        <trans-unit id="6ff3989b144109cfd18ff049af7f71f4c3c9f86e" translate="yes" xml:space="preserve">
          <source>Generate hardware atomic sequences using the &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; instructions only. This is only available on SH4A and is suitable for multi-core systems. Since the hardware instructions support only 32 bit atomic variables access to 8 or 16 bit variables is emulated with 32 bit accesses. Code compiled with this option is also compatible with other software atomic model interrupt/exception handling systems if executed on an SH4A system. Additional support from the interrupt/exception handling code of the system is not required for this model.</source>
          <target state="translated">&lt;code&gt;movli.l&lt;/code&gt; および &lt;code&gt;movco.l&lt;/code&gt; 命令のみを使用してハードウェアアトミックシーケンスを生成します。これはSH4Aでのみ利用可能で、マルチコアシステムに適しています。ハードウェア命令は32ビットのアトミック変数のみをサポートするため、8または16ビット変数へのアクセスは、32ビットアクセスでエミュレートされます。このオプションでコンパイルされたコードは、SH4Aシステムで実行された場合、他のソフトウェアアトミックモデル割り込み/例外処理システムとも互換性があります。このモデルでは、システムの割り込み/例外処理コードによる追加のサポートは必要ありません。</target>
        </trans-unit>
        <trans-unit id="d8debf693e895754ae8dfa412a7398684e52957b" translate="yes" xml:space="preserve">
          <source>Generate instructions for the machine type &lt;var&gt;cpu-type&lt;/var&gt;. In contrast to</source>
          <target state="translated">マシンタイプ &lt;var&gt;cpu-type&lt;/var&gt; の命令を生成します。とは対照的に</target>
        </trans-unit>
        <trans-unit id="4d9806e63398f5c7206d46ddf2dd393879704321" translate="yes" xml:space="preserve">
          <source>Generate instructions supported by barrel shifter. This is the default unless</source>
          <target state="translated">バレルシフターがサポートする命令を生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="a86b264be3b7927eef8b4d4ec32bd6e0abb23e9a" translate="yes" xml:space="preserve">
          <source>Generate instrumentation calls for entry and exit to functions. Just after function entry and just before function exit, the following profiling functions are called with the address of the current function and its call site. (On some platforms, &lt;code&gt;__builtin_return_address&lt;/code&gt; does not work beyond the current function, so the call site information may not be available to the profiling functions otherwise.)</source>
          <target state="translated">関数の入り口と出口の計測呼び出しを生成します。関数の開始直後と関数の終了直前に、次のプロファイリング関数が、現在の関数のアドレスとその呼び出しサイトで呼び出されます。（一部のプラットフォームでは、 &lt;code&gt;__builtin_return_address&lt;/code&gt; は現在の関数を超えて機能しないため、それ以外の場合、プロファイリング関数で呼び出しサイト情報を利用できない場合があります。）</target>
        </trans-unit>
        <trans-unit id="a558056c364dd801f66dea4bd9ff5d7025049fb1" translate="yes" xml:space="preserve">
          <source>Generate little-endian (default) or big-endian (experimental) code, respectively.</source>
          <target state="translated">リトルエンディアン(デフォルト)とビッグエンディアン(実験的)のコードをそれぞれ生成します。</target>
        </trans-unit>
        <trans-unit id="8c624983438064d33fb3b88653aa23aaa51afa20" translate="yes" xml:space="preserve">
          <source>Generate little-endian code.</source>
          <target state="translated">リトルエンディアンコードを生成します。</target>
        </trans-unit>
        <trans-unit id="d362bc65e7c53091f19c9e25dc0b1f5baf698d4a" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">リトルエンディアンコードを生成します。これは「</target>
        </trans-unit>
        <trans-unit id="66047ec2f64b4bd1b8fdd5fa2877f3f85b442eac" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">リトルエンディアンコードを生成します。これは、GCCが「</target>
        </trans-unit>
        <trans-unit id="e76d98abdce9e7fa1b4a7b7f0a6241f584dc592c" translate="yes" xml:space="preserve">
          <source>Generate mul.x and umul.x instructions. This is the default for &amp;lsquo;</source>
          <target state="translated">mul.xおよびumul.x命令を生成します。これは「</target>
        </trans-unit>
        <trans-unit id="11b3830c8f1fe1ef2c6dc043ba7fa4b0665f2d6d" translate="yes" xml:space="preserve">
          <source>Generate non-looping inline code for all block compares (such as calls to &lt;code&gt;memcmp&lt;/code&gt; or structure compares) less than or equal to &lt;var&gt;num&lt;/var&gt; bytes. If &lt;var&gt;num&lt;/var&gt; is 0, all inline expansion (non-loop and loop) of block compare is disabled. The default value is target-specific.</source>
          <target state="translated">&lt;var&gt;num&lt;/var&gt; バイト以下のすべてのブロック比較（ &lt;code&gt;memcmp&lt;/code&gt; への呼び出しや構造体比較など）の非ループインラインコードを生成します。 &lt;var&gt;num&lt;/var&gt; が0の場合、ブロック比較のすべてのインライン展開（非ループおよびループ）は無効になります。デフォルト値はターゲット固有です。</target>
        </trans-unit>
        <trans-unit id="726e8e558f2a846b8999b9aeb3c7faa8d320b08e" translate="yes" xml:space="preserve">
          <source>Generate object code compatible with the standard GNU Objective-C runtime. This is the default for most types of systems.</source>
          <target state="translated">標準のGNU Objective-Cランタイムと互換性のあるオブジェクトコードを生成します。これは、ほとんどのタイプのシステムではデフォルトです。</target>
        </trans-unit>
        <trans-unit id="5f828fdb836a3167f3a117e320f8c23966c29566" translate="yes" xml:space="preserve">
          <source>Generate output compatible with the NeXT runtime. This is the default for NeXT-based systems, including Darwin and Mac OS X. The macro &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; is predefined if (and only if) this option is used.</source>
          <target state="translated">NeXTランタイムと互換性のある出力を生成します。これは、DarwinやMac OS Xを含むNeXTベースのシステムのデフォルトです。このオプションを使用する場合（およびその場合のみ）、マクロ &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; が事前定義されています。</target>
        </trans-unit>
        <trans-unit id="3b10b8584ef5629375b0697c006157af2562811c" translate="yes" xml:space="preserve">
          <source>Generate output containing 80387 instructions for floating point.</source>
          <target state="translated">浮動小数点用の80387命令を含む出力を生成します。</target>
        </trans-unit>
        <trans-unit id="4ac64fa385d79df6893e650d3c87094e5fab8e8d" translate="yes" xml:space="preserve">
          <source>Generate output containing floating-point instructions. This is the default.</source>
          <target state="translated">浮動小数点命令を含む出力を生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="a54c9d559afdf54011312401dae184f34851998d" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point.</source>
          <target state="translated">浮動小数点のライブラリ呼び出しを含む出力を生成します。</target>
        </trans-unit>
        <trans-unit id="b68715959fa47ba0ff79de672b756a42be41a84c" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all HPPA targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation.</source>
          <target state="translated">浮動小数点のライブラリ呼び出しを含む出力を生成します。&lt;strong&gt;警告：&lt;/strong&gt;必要なライブラリは、すべてのHPPAターゲットで使用できるわけではありません。通常、マシンの通常のCコンパイラの機能が使用されますが、これはクロスコンパイルで直接行うことはできません。クロスコンパイルに適したライブラリ関数を提供するには、独自の配置を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="123686fdd6543b04616633629545ce470b234181" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all SPARC targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation. The embedded targets &amp;lsquo;</source>
          <target state="translated">浮動小数点のライブラリ呼び出しを含む出力を生成します。&lt;strong&gt;警告：&lt;/strong&gt;必要なライブラリは、すべてのSPARCターゲットで使用できるわけではありません。通常、マシンの通常のCコンパイラの機能が使用されますが、これはクロスコンパイルで直接行うことはできません。クロスコンパイルに適したライブラリ関数を提供するには、独自の配置を行う必要があります。埋め込まれたターゲット '</target>
        </trans-unit>
        <trans-unit id="374b214aae9f131ecd8bd8fbf3ba7e20116baf86" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for quad-word (long double) floating-point instructions. The functions called are those specified in the SPARC ABI. This is the default.</source>
          <target state="translated">クワッドワード(long double)浮動小数点命令のライブラリ呼び出しを含む出力を生成します。呼び出される関数は SPARC ABI で指定されたものです。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="e778386ad4f7c29303d76d557065f8b2cddd1a1e" translate="yes" xml:space="preserve">
          <source>Generate output containing quad-word (long double) floating-point instructions.</source>
          <target state="translated">クワッドワード(long double)浮動小数点命令を含む出力を生成します。</target>
        </trans-unit>
        <trans-unit id="72b8d6815f1c63fef196e30ed85ba66e28021cd2" translate="yes" xml:space="preserve">
          <source>Generate output for a 5206e ColdFire CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">5206e ColdFire CPU の出力を生成します。このオプションは現在では廃止され、同等の</target>
        </trans-unit>
        <trans-unit id="64050f292f81abd70f3bb1391b078794170aa43c" translate="yes" xml:space="preserve">
          <source>Generate output for a 520X ColdFire CPU. This is the default when the compiler is configured for 520X-based systems. It is equivalent to</source>
          <target state="translated">520X ColdFire CPU用の出力を生成します。これは、コンパイラが520Xベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="4e6125bf5e16c60081ffba73c18391756b953da9" translate="yes" xml:space="preserve">
          <source>Generate output for a 68000. This is the default when the compiler is configured for 68000-based systems. It is equivalent to</source>
          <target state="translated">68000 用の出力を生成します。これは、68000ベースのシステム用にコンパイラが構成されている場合のデフォルトです。と同等です。</target>
        </trans-unit>
        <trans-unit id="293fc36513894f8af34456d5d4568e3a8a660df3" translate="yes" xml:space="preserve">
          <source>Generate output for a 68010. This is the default when the compiler is configured for 68010-based systems. It is equivalent to</source>
          <target state="translated">68010 用の出力を生成します。コンパイラが68010ベースのシステム用に構成されている場合のデフォルトです。と同等です。</target>
        </trans-unit>
        <trans-unit id="3de0124e7fb5a143b3bdb1e5bf42ea00b8dc1041" translate="yes" xml:space="preserve">
          <source>Generate output for a 68020. This is the default when the compiler is configured for 68020-based systems. It is equivalent to</source>
          <target state="translated">68020 用の出力を生成します。コンパイラが68020ベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="a2125889bc447fbbe5141c63e65b9cc93af2774c" translate="yes" xml:space="preserve">
          <source>Generate output for a 68030. This is the default when the compiler is configured for 68030-based systems. It is equivalent to</source>
          <target state="translated">68030 用の出力を生成します。コンパイラが68030ベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="dcd8a9aedf0282928a86db993cf8d4ff8070b038" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68040.</source>
          <target state="translated">新しい命令を使用せずに、68040用の出力を生成します。これにより、68020/68881、68030、68040のいずれかで比較的効率的に実行できるコードが生成されます。生成されたコードは、68040でエミュレートされた688881命令を使用します。</target>
        </trans-unit>
        <trans-unit id="dd4119d908a2b18c651ef46f26b46cd2bc8b0de2" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040. This is the default when the compiler is configured for 68040-based systems. It is equivalent to</source>
          <target state="translated">68040 用の出力を生成します。コンパイラが68040ベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="c0e33f0f063c998bb9f2f1ad28f52830efcc367f" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68060.</source>
          <target state="translated">新しい命令を使用せずに、68060の出力を生成します。これにより、68020/68881、68030、68040のいずれかで比較的効率的に実行できるコードが生成されます。生成されたコードは、68060でエミュレートされた688881命令を使用します。</target>
        </trans-unit>
        <trans-unit id="4e0aa817ee3651021250220786d7a8ddadf8d908" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060. This is the default when the compiler is configured for 68060-based systems. It is equivalent to</source>
          <target state="translated">68060 用の出力を生成します。コンパイラが68060ベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="ea5be8485d83583c41e5d8584b5916331ad44880" translate="yes" xml:space="preserve">
          <source>Generate output for a CPU32. This is the default when the compiler is configured for CPU32-based systems. It is equivalent to</source>
          <target state="translated">CPU32用の出力を生成します。これは、コンパイラがCPU32ベースのシステム用に設定されている場合のデフォルトです。これは</target>
        </trans-unit>
        <trans-unit id="e1d15ac03ce80d2a7972245b867ea55ebdb92c9b" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5307 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">ColdFire 5307 CPU の出力を生成します。このオプションは現在非推奨となっており、同等の</target>
        </trans-unit>
        <trans-unit id="8e01c68482064d3161a9a189e69a1cae2c323dfb" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5407 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">ColdFire 5407 CPU の出力を生成します。このオプションは現在非推奨となっており、同等の</target>
        </trans-unit>
        <trans-unit id="0aa9f4c3f64933730b3c4adacac26f4b2456673a" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire V4e family CPU (e.g. 547x/548x). This includes use of hardware floating-point instructions. The option is equivalent to</source>
          <target state="translated">ColdFire V4e ファミリー CPU (例:547x/548x)の出力を生成します。これには、ハードウェア浮動小数点命令の使用が含まれます。このオプションは次のものと同等です。</target>
        </trans-unit>
        <trans-unit id="e7347e49e1182821745b1b659d00df4d824a3e04" translate="yes" xml:space="preserve">
          <source>Generate output for a member of the ColdFire 528X family. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">ColdFire 528X ファミリのメンバーの出力を生成します。このオプションは現在非推奨となっており、同等の</target>
        </trans-unit>
        <trans-unit id="18dcb26797382565521c621a512430444b4e53d3" translate="yes" xml:space="preserve">
          <source>Generate performance extension 2 instructions.</source>
          <target state="translated">パフォーマンス拡張2の命令を生成する。</target>
        </trans-unit>
        <trans-unit id="bd6544f4b4eb02ec7c1103af517606738fd2ba09" translate="yes" xml:space="preserve">
          <source>Generate performance extension instructions.</source>
          <target state="translated">パフォーマンス拡張命令を生成します。</target>
        </trans-unit>
        <trans-unit id="d399ee7f07dc0a2fb4ab33398b031c9b688f806f" translate="yes" xml:space="preserve">
          <source>Generate position-independent EABI code.</source>
          <target state="translated">位置に依存しないEABIコードを生成します。</target>
        </trans-unit>
        <trans-unit id="1d1142004c8111e7c50b740035c14c26ae3a4d40" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (PIC) suitable for use in a shared library, if supported for the target machine. Such code accesses all constant addresses through a global offset table (GOT). The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC; it is part of the operating system). If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that</source>
          <target state="translated">ターゲットマシンでサポートされている場合、共有ライブラリでの使用に適した位置非依存コード(PIC)を生成します。このようなコードは、グローバルオフセットテーブル(GOT)を介してすべての定数アドレスにアクセスします。ダイナミック・ローダーはプログラムの起動時に GOT エントリを解決します(ダイナミック・ローダーは GCC の一部ではなく、オペレーティング・システムの一部です)。リンクされた実行ファイルの GOT サイズがマシン固有の最大サイズを超えると、リンカから以下のようなエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="48b952028eaadcc5cf5b2652a4f09475aac1135d" translate="yes" xml:space="preserve">
          <source>Generate secure code as per the &quot;ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification&quot;, which can be found on &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0に&lt;/a&gt;ある「ARMv8-M Security Extensions：Development Tools Engineering Specificationの要件」に従って安全なコードを生成します。 PDF。</target>
        </trans-unit>
        <trans-unit id="61825c7f7fe0283dfaa12a0bf7f79986a97151b2" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">コンパクトな実装のためにチューニングされた単精度FPX命令を生成します。</target>
        </trans-unit>
        <trans-unit id="57fc66010a803fb795da295b4fbe9fac5a8dbfd1" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">高速な実装のためにチューニングされた単精度FPX命令を生成します。</target>
        </trans-unit>
        <trans-unit id="03e730324ac713e9445bac5587ed90df17b4e2e3" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that temporarily disable interrupts by setting &lt;code&gt;SR.IMASK = 1111&lt;/code&gt;. This model works only when the program runs in privileged mode and is only suitable for single-core systems. Additional support from the interrupt/exception handling code of the system is not required. This model is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH1* or SH2*.</source>
          <target state="translated">&lt;code&gt;SR.IMASK = 1111&lt;/code&gt; 設定して、割り込みを一時的に無効にするソフトウェアアトミックシーケンスを生成します。このモデルは、プログラムが特権モードで実行されている場合にのみ機能し、シングルコアシステムにのみ適しています。システムの割り込み/例外処理コードからの追加サポートは必要ありません。ターゲットが &lt;code&gt;sh*-*-linux*&lt;/code&gt; およびSH1 *またはSH2 *の場合、このモデルはデフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="adcbfbeac80cfe6a3e4b55a0bdfaf3f19f30fbea" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that use a variable in the thread control block. This is a variation of the gUSA sequences which can also be used on SH1* and SH2* targets. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for single-core systems. When using this model, the &amp;lsquo;</source>
          <target state="translated">スレッド制御ブロックで変数を使用するソフトウェアアトミックシーケンスを生成します。これは、gUSAシーケンスのバリエーションであり、SH1 *およびSH2 *ターゲットでも使用できます。生成されたアトミックシーケンスは、システムの割り込み/例外処理コードによる追加のサポートを必要とし、シングルコアシステムにのみ適しています。このモデルを使用する場合、「</target>
        </trans-unit>
        <trans-unit id="7e273affad800c8c4cf1d009bbdccfc4d50d0a21" translate="yes" xml:space="preserve">
          <source>Generate stack protection code using canary at &lt;var&gt;guard&lt;/var&gt;. Supported locations are &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;guard&lt;/var&gt; カナリアを使用してスタック保護コードを生成します。サポートされている場所は '</target>
        </trans-unit>
        <trans-unit id="b8a639f56facade8c98595f71ed5d4db9ac64830" translate="yes" xml:space="preserve">
          <source>Generate string extension instructions.</source>
          <target state="translated">文字列拡張命令を生成します。</target>
        </trans-unit>
        <trans-unit id="8a1f94259681f1ae170bbb57344c845c25fbbd90" translate="yes" xml:space="preserve">
          <source>Generate the &lt;code&gt;tas.b&lt;/code&gt; opcode for &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. Notice that depending on the particular hardware and software configuration this can degrade overall performance due to the operand cache line flushes that are implied by the &lt;code&gt;tas.b&lt;/code&gt; instruction. On multi-core SH4A processors the &lt;code&gt;tas.b&lt;/code&gt; instruction must be used with caution since it can result in data corruption for certain cache configurations.</source>
          <target state="translated">生成 &lt;code&gt;tas.b&lt;/code&gt; のオペコード &lt;code&gt;__atomic_test_and_set&lt;/code&gt; を。特定のハードウェアおよびソフトウェアの構成によっては、 &lt;code&gt;tas.b&lt;/code&gt; 命令によって暗黙的に指定されるオペランドキャッシュラインのフラッシュが原因で、全体的なパフォーマンスが低下する可能性があることに注意してください。マルチコアSH4Aプロセッサでは、特定のキャッシュ構成でデータが破損する可能性があるため、 &lt;code&gt;tas.b&lt;/code&gt; 命令は注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="33b6af1538444b86d0ad7d0fedaceadc538e6781" translate="yes" xml:space="preserve">
          <source>Generate the predefine, &lt;code&gt;_SIO&lt;/code&gt;, for server IO. The default is</source>
          <target state="translated">サーバーIO の事前定義 &lt;code&gt;_SIO&lt;/code&gt; を生成します。デフォルトは</target>
        </trans-unit>
        <trans-unit id="556e10b173cc8258302ad6ae7353988cc9258bb9" translate="yes" xml:space="preserve">
          <source>Generate unwind table in DWARF format, if supported by target machine. The table is exact at each instruction boundary, so it can be used for stack unwinding from asynchronous events (such as debugger or garbage collector).</source>
          <target state="translated">ターゲットマシンがサポートしている場合は、DWARF形式のアンワインドテーブルを生成します。テーブルは各命令境界で正確なので、非同期イベント(デバッガやガベージコレクタなど)からのスタックアンワインドに使用できます。</target>
        </trans-unit>
        <trans-unit id="57527d83fd3616a340b11bb579911dbfd64f477e" translate="yes" xml:space="preserve">
          <source>Generate v3 push25/pop25 instructions.</source>
          <target state="translated">v3 push25/pop25命令を生成します。</target>
        </trans-unit>
        <trans-unit id="fb9942d737ee06d15159ff521f994cc01ae69210" translate="yes" xml:space="preserve">
          <source>Generated code is not compatible with hardware interrupts. Code size is smaller.</source>
          <target state="translated">生成されたコードはハードウェア割り込みに対応していません。コードサイズが小さくなります。</target>
        </trans-unit>
        <trans-unit id="95fc43dc3dce502b8d3a439f3daa647aaa660090" translate="yes" xml:space="preserve">
          <source>Generates</source>
          <target state="translated">Generates</target>
        </trans-unit>
        <trans-unit id="847361d2a7401aea217f81327402896d9c474e00" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;sbit&lt;/code&gt;/&lt;code&gt;cbit&lt;/code&gt; instructions for bit manipulations.</source>
          <target state="translated">ビット操作用の &lt;code&gt;sbit&lt;/code&gt; / &lt;code&gt;cbit&lt;/code&gt; 命令を生成します。</target>
        </trans-unit>
        <trans-unit id="8c23e71aebd89fa525027dc7a4570046a7a64ce0" translate="yes" xml:space="preserve">
          <source>Generates an error message. This pragma &lt;em&gt;is&lt;/em&gt; considered to indicate an error in the compilation, and it will be treated as such.</source>
          <target state="translated">エラーメッセージを生成します。このプラグマ&lt;em&gt;は&lt;/em&gt;コンパイルのエラーを示す&lt;em&gt;と&lt;/em&gt;見なされ、そのように扱われます。</target>
        </trans-unit>
        <trans-unit id="b4a08a286760cba742dec264941903cd2180c988" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;brk&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;brk&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="de0ffdd1afe0ff10e18f301f3481e988ec1af918" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;clrpsw&lt;/code&gt; machine instruction to clear the specified bit in the processor status word.</source>
          <target state="translated">&lt;code&gt;clrpsw&lt;/code&gt; マシン命令を生成して、プロセッサステータスワードの指定されたビットをクリアします。</target>
        </trans-unit>
        <trans-unit id="e384966166fe10a7e3cda9622b8d991e42dbafb8" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32b&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32b&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="097e8495f2e00512011587a86cec2af02faf3293" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32l&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32l&lt;/code&gt; 機械語命令を生成します。</target>
        </trans-unit>
        <trans-unit id="257268a989f9b93ff19c2d7c87cb2336d607cc4f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32q&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32q&lt;/code&gt; 機械語命令を生成します。</target>
        </trans-unit>
        <trans-unit id="b6ee9ffc23cac162df8a9b520916fe8eb4063947" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32w&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32w&lt;/code&gt; 機械語命令を生成します。</target>
        </trans-unit>
        <trans-unit id="9c0298bd9ac40c51cad36ed168d5ebaa6178f1de" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;etnd&lt;/code&gt; machine instruction. The current nesting depth is returned as integer value. For a nesting depth of 0 the code is not executed as part of an transaction.</source>
          <target state="translated">&lt;code&gt;etnd&lt;/code&gt; 機械命令を生成します。現在の入れ子の深さは整数値として返されます。ネストの深さが0の場合、コードはトランザクションの一部として実行されません。</target>
        </trans-unit>
        <trans-unit id="ba9daaa604a3528f1838ae3869b5e548870970eb" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;extractps&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;extractps&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="89f2857c101ed877edbedb096cf0c5b70642f1a6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;insertps&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;insertps&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="bddf0335c49f41b446b0994e140cc0b296730b66" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;int&lt;/code&gt; machine instruction to generate an interrupt with the specified value.</source>
          <target state="translated">指定された値で割り込みを生成する &lt;code&gt;int&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="cc578c8838d75de69df84505da3623cd37d917cc" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;machi&lt;/code&gt; machine instruction to add the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">2つの引数の上位16ビットを乗算した結果をアキュムレータに追加するための &lt;code&gt;machi&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="99eacdb7a1185745b3f8d3546aa5c195c4ffc120" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;maclo&lt;/code&gt; machine instruction to add the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">&lt;code&gt;maclo&lt;/code&gt; マシン命令を生成して、2つの引数の下位16ビットを乗算した結果をアキュムレータに追加します。</target>
        </trans-unit>
        <trans-unit id="7a0ca51423d0e24c5de865392e13bff92dec8a47" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">&lt;code&gt;movhps&lt;/code&gt; マシン命令をメモリからのロードとして生成します。</target>
        </trans-unit>
        <trans-unit id="a6336fc5b41c1f5923ae66b48c6856394b9f7d5d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">&lt;code&gt;movhps&lt;/code&gt; マシン命令をメモリへのストアとして生成します。</target>
        </trans-unit>
        <trans-unit id="81a1c47a7ece45e98596dc9420085617e89d6661" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a load from memory</source>
          <target state="translated">&lt;code&gt;movlps&lt;/code&gt; マシン命令をメモリからのロードとして生成します</target>
        </trans-unit>
        <trans-unit id="1e491626b2ecf306727f7b2f326dde340a6befb6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">&lt;code&gt;movlps&lt;/code&gt; マシン命令をメモリへのストアとして生成します。</target>
        </trans-unit>
        <trans-unit id="ac79e7ffaaf077d95a6d1ffa3d8fb253edbeb451" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movss&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">&lt;code&gt;movss&lt;/code&gt; 機械命令をメモリからのロードとして生成します。</target>
        </trans-unit>
        <trans-unit id="2dc4d75da1c01f01ac98af15d63b74a7af18475d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">&lt;code&gt;movups&lt;/code&gt; マシン命令をメモリからのロードとして生成します。</target>
        </trans-unit>
        <trans-unit id="363646d48f8bc2356c5c4e7f637ebc00c96d25d3" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">&lt;code&gt;movups&lt;/code&gt; 機械命令をメモリへのストアとして生成します。</target>
        </trans-unit>
        <trans-unit id="bc35453eece3fefcd1bc15a0d478b36419def393" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mulhi&lt;/code&gt; machine instruction to place the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">&lt;code&gt;mulhi&lt;/code&gt; 機械命令を生成して、2つの引数の上位16ビットを乗算した結果をアキュムレータに配置します。</target>
        </trans-unit>
        <trans-unit id="52d614340e6bcb9b13e27d9daf3f3ec4c3e7003e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mullo&lt;/code&gt; machine instruction to place the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">2つの引数の下位16ビットを乗算した結果を &lt;code&gt;mullo&lt;/code&gt; に配置するためのmulloマシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="37702a0f744e0973c9767b2a0ae0b071d0ab6011" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfachi&lt;/code&gt; machine instruction to read the top 32 bits of the accumulator.</source>
          <target state="translated">アキュムレータの上位32ビットを読み取るための &lt;code&gt;mvfachi&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="e5e940957ba8e9f4e4a5a9b38f5ec9bacccdcd1d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfacmi&lt;/code&gt; machine instruction to read the middle 32 bits of the accumulator.</source>
          <target state="translated">アキュムレータの中央の32ビットを読み取るための &lt;code&gt;mvfacmi&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="84ea7bb4390bbd29b42442b2c0df648769428770" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfc&lt;/code&gt; machine instruction which reads the control register specified in its argument and returns its value.</source>
          <target state="translated">引数で指定された制御レジスタを読み取り、その値を返す &lt;code&gt;mvfc&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="9a7f85fadc166c23e3a73720a98d17ae8d98c867" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtachi&lt;/code&gt; machine instruction to set the top 32 bits of the accumulator.</source>
          <target state="translated">アキュムレータの上位32ビットを設定するための &lt;code&gt;mvtachi&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="c2fa5a8c449853ed0e286fabb00686c6c4684432" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtaclo&lt;/code&gt; machine instruction to set the bottom 32 bits of the accumulator.</source>
          <target state="translated">&lt;code&gt;mvtaclo&lt;/code&gt; マシン命令を生成して、アキュムレータの下位32ビットを設定します。</target>
        </trans-unit>
        <trans-unit id="0c726977269ab1aef450eb4579a182f674e2891b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtc&lt;/code&gt; machine instruction which sets control register number &lt;code&gt;reg&lt;/code&gt; to &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">制御レジスタ番号 &lt;code&gt;reg&lt;/code&gt; を &lt;code&gt;val&lt;/code&gt; に設定する &lt;code&gt;mvtc&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="e73288099a5726fcb09aeebaa5734e10714eb5f2" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtipl&lt;/code&gt; machine instruction set the interrupt priority level.</source>
          <target state="translated">割り込み優先レベルを設定する &lt;code&gt;mvtipl&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="c95405f984d5d6abab06b81618d6b2d88c6bce16" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ntstg&lt;/code&gt; machine instruction. The second argument is written to the first arguments location. The store operation will not be rolled-back in case of an transaction abort.</source>
          <target state="translated">&lt;code&gt;ntstg&lt;/code&gt; 機械命令を生成します。2番目の引数は、最初の引数の場所に書き込まれます。トランザクションが中止された場合、ストア操作はロールバックされません。</target>
        </trans-unit>
        <trans-unit id="221810e17f3f5b7b6eee2c597dcc35e9560d5c1a" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pause&lt;/code&gt; machine instruction with a compiler memory barrier.</source>
          <target state="translated">コンパイラのメモリバリアを使用して &lt;code&gt;pause&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="fabcc577b37bbc75f15d4acfc478723f40e312bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pclmulqdq&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pclmulqdq&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="138581c28238370fdca095f892b8bcc2f037ebde" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pextrb&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="cc89464fd0e0ffc62121a43ea4c78a22a765f79b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pextrd&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="6995305b1713c32c1cb9c1c29aa123fa501311ad" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">64ビットモードで &lt;code&gt;pextrq&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="7afd0d12563bc8ecde0ac65ab4ecf09a6388cc0c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pinsrb&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="587eac9a0053b04618284992d46512728f7465b0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pinsrd&lt;/code&gt; 機械語命令を生成します。</target>
        </trans-unit>
        <trans-unit id="e89f9467a7fdb5f2511c4d93da028b6494b1db2e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">&lt;code&gt;pinsrq&lt;/code&gt; マシン命令を64ビットモードで生成します。</target>
        </trans-unit>
        <trans-unit id="167d17fe5058f3ef0cb33d59903eebaaf6162e68" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;popcntl&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="6cb126029514e2d5bfcb6bca148eb150b8aba8a4" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; or &lt;code&gt;popcntq&lt;/code&gt; machine instruction, depending on the size of &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unsigned long&lt;/code&gt; のサイズに応じて、 &lt;code&gt;popcntl&lt;/code&gt; または &lt;code&gt;popcntq&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="c32c9ad948f2048e1fcb6de749499d83eb38bfdd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntq&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;popcntq&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="c6a384a17f6c55681ebb99e208e7e76367ba0a5f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ppa rX,rY,1&lt;/code&gt; machine instruction. Where the integer parameter is loaded into rX and a value of zero is loaded into rY. The integer parameter specifies the number of times the transaction repeatedly aborted.</source>
          <target state="translated">&lt;code&gt;ppa rX,rY,1&lt;/code&gt; 機械語命令を生成します。整数パラメータがrXに読み込まれ、値0がrYに読み込まれます。integerパラメータは、トランザクションが繰り返し中止された回数を指定します。</target>
        </trans-unit>
        <trans-unit id="2ad4e7198804a310937a6c8bd6ea66807f131d33" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;racw&lt;/code&gt; machine instruction to round the accumulator according to the specified mode.</source>
          <target state="translated">指定されたモードに従ってアキュムレータを &lt;code&gt;racw&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="94afa89c73a482e7f60ea3534ec6652b684e5611" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;revw&lt;/code&gt; machine instruction which swaps the bytes in the argument so that bits 0&amp;ndash;7 now occupy bits 8&amp;ndash;15 and vice versa, and also bits 16&amp;ndash;23 occupy bits 24&amp;ndash;31 and vice versa.</source>
          <target state="translated">引数のバイトを交換する &lt;code&gt;revw&lt;/code&gt; マシン命令を生成します。これにより、ビット0〜7がビット8〜15を占有し、ビット16〜23がビット24〜31を占有します。</target>
        </trans-unit>
        <trans-unit id="6d19e7f0e193910eff939ea1df5fd508cf81e1dd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;rmpa&lt;/code&gt; machine instruction which initiates a repeated multiply and accumulate sequence.</source>
          <target state="translated">繰り返し乗算および累算シーケンスを開始する &lt;code&gt;rmpa&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="3a3c845817720a1abf8f57c24608a050c45caf15" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;round&lt;/code&gt; machine instruction which returns the floating-point argument rounded according to the current rounding mode set in the floating-point status word register.</source>
          <target state="translated">浮動小数点ステータスワードレジスタに設定されている現在の丸めモードに従って丸められた浮動小数点引数を返す &lt;code&gt;round&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="693bacff2407833725bfd8a8b85cfbf1bb7e034c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;sat&lt;/code&gt; machine instruction which returns the saturated value of the argument.</source>
          <target state="translated">引数の飽和値を返す &lt;code&gt;sat&lt;/code&gt; 機械命令を生成します。</target>
        </trans-unit>
        <trans-unit id="0bd4f2535ab0460fd7e26bbf4e95465d1caef5d0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;setpsw&lt;/code&gt; machine instruction to set the specified bit in the processor status word.</source>
          <target state="translated">&lt;code&gt;setpsw&lt;/code&gt; マシン命令を生成して、指定されたビットをプロセッサステータスワードに設定します。</target>
        </trans-unit>
        <trans-unit id="86af23191f84ff6e1646de29e1379a9fa322b441" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tabort&lt;/code&gt; machine instruction with the specified abort code. Abort codes from 0 through 255 are reserved and will result in an error message.</source>
          <target state="translated">指定された中止コードを使用して、 &lt;code&gt;tabort&lt;/code&gt; 機械命令を生成します。0〜255の中止コードは予約されており、エラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="41fafa8bbaf148ec213bd90ff158b6b99b4cd68d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbegin&lt;/code&gt; machine instruction starting a non-constrained hardware transaction. If the parameter is non-NULL the memory area is used to store the transaction diagnostic buffer and will be passed as first operand to &lt;code&gt;tbegin&lt;/code&gt;. This buffer can be defined using the &lt;code&gt;struct __htm_tdb&lt;/code&gt; C struct defined in &lt;code&gt;htmintrin.h&lt;/code&gt; and must reside on a double-word boundary. The second tbegin operand is set to &lt;code&gt;0xff0c&lt;/code&gt;. This enables save/restore of all GPRs and disables aborts for FPR and AR manipulations inside the transaction body. The condition code set by the tbegin instruction is returned as integer value. The tbegin instruction by definition overwrites the content of all FPRs. The compiler will generate code which saves and restores the FPRs. For soft-float code it is recommended to used the &lt;code&gt;*_nofloat&lt;/code&gt; variant. In order to prevent a TDB from being written it is required to pass a constant zero value as parameter. Passing a zero value through a variable is not sufficient. Although modifications of access registers inside the transaction will not trigger an transaction abort it is not supported to actually modify them. Access registers do not get saved when entering a transaction. They will have undefined state when reaching the abort code.</source>
          <target state="translated">制約のないハードウェアトランザクションを開始する &lt;code&gt;tbegin&lt;/code&gt; 機械命令を生成します。パラメータがNULL以外の場合、メモリ領域はトランザクション診断バッファを格納するために使用され、最初のオペランドとして &lt;code&gt;tbegin&lt;/code&gt; に渡されます。このバッファは使用して定義することができる &lt;code&gt;struct __htm_tdb&lt;/code&gt; に定義されたC構造体 &lt;code&gt;htmintrin.h&lt;/code&gt; をダブルワード境界上に存在しなければなりません。 2番目のtbeginオペランドは &lt;code&gt;0xff0c&lt;/code&gt; に設定されます。これにより、すべてのGPRの保存/復元が有効になり、トランザクション本文内のFPRおよびAR操作の中止が無効になります。 tbegin命令によって設定された条件コードは整数値として返されます。定義により、tbegin命令はすべてのFPRの内容を上書きします。コンパイラーは、FPRを保存および復元するコードを生成します。ソフト浮動小数点コードの場合、 &lt;code&gt;*_nofloat&lt;/code&gt; を使用することをお勧めしますバリアント。TDBが書き込まれないようにするには、定数のゼロ値をパラメーターとして渡す必要があります。変数にゼロ値を渡すだけでは不十分です。トランザクション内のアクセスレジスタを変更してもトランザクションのアボートはトリガーされませんが、実際にそれらを変更することはサポートされていません。トランザクションの入力時にアクセスレジスタは保存されません。中止コードに到達すると、未定義の状態になります。</target>
        </trans-unit>
        <trans-unit id="e6827eb1aea4f7107218c612803fe4d6ada64dff" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbeginc&lt;/code&gt; machine instruction starting a constrained hardware transaction. The second operand is set to &lt;code&gt;0xff08&lt;/code&gt;.</source>
          <target state="translated">制約のあるハードウェアトランザクションを開始する &lt;code&gt;tbeginc&lt;/code&gt; 機械命令を生成します。2番目のオペランドは &lt;code&gt;0xff08&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="1623696be46dd23fac7b3be91a9dabc88baaf7ab" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tend&lt;/code&gt; machine instruction finishing a transaction and making the changes visible to other threads. The condition code generated by tend is returned as integer value.</source>
          <target state="translated">トランザクションを終了し、変更を他のスレッドから見えるようにする &lt;code&gt;tend&lt;/code&gt; 機械語命令を生成します。tendによって生成された条件コードは整数値として返されます。</target>
        </trans-unit>
        <trans-unit id="98be0f38fb4c5ac278186b26e4d1c15696ff51bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;wait&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; マシン命令を生成します。</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="ea3f79632679059de141d66e9dca3bc06851d467" translate="yes" xml:space="preserve">
          <source>Generic VIA Nano CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">x86-64、MMX、SSE、SSE2、SSE3およびSSSE3命令セットをサポートするジェネリックVIA Nano CPU。(このチップにはスケジューリングは実装されていません)</target>
        </trans-unit>
        <trans-unit id="9aea01d94f58ef40baf7a92523ddcc334efa83d3" translate="yes" xml:space="preserve">
          <source>Get and set the contents of the floating-point control and status register (FPU control register 31). These functions are only available in hard-float code but can be called in both MIPS16 and non-MIPS16 contexts.</source>
          <target state="translated">浮動小数点制御レジスタおよびステータスレジスタ(FPU制御レジスタ31)の内容を取得および設定します。これらの関数はハードフロートコードでのみ利用可能ですが、MIPS16と非MIPS16の両方のコンテキストで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="93019384bd85aa8984f35ea4b05d12346052144c" translate="yes" xml:space="preserve">
          <source>Get the current value of shadow stack pointer if shadow stack support from Intel CET is enabled in the hardware or &lt;code&gt;0&lt;/code&gt; otherwise. The &lt;code&gt;ret_type&lt;/code&gt; is &lt;code&gt;unsigned long long&lt;/code&gt; for 64-bit targets and &lt;code&gt;unsigned int&lt;/code&gt; for 32-bit targets.</source>
          <target state="translated">ハードウェアでIntel CETからのシャドウスタックサポートが有効になっている場合は、シャドウスタックポインターの現在の値を取得します。それ以外の場合は &lt;code&gt;0&lt;/code&gt; を取得します。 &lt;code&gt;ret_type&lt;/code&gt; は、64ビットターゲットの場合は &lt;code&gt;unsigned long long&lt;/code&gt; 、32ビットターゲットの場合は &lt;code&gt;unsigned int&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="242390092876b4a7227130b506459512d744c5bd" translate="yes" xml:space="preserve">
          <source>Getting pointers to labels, and computed gotos.</source>
          <target state="translated">ラベルへのポインタの取得、および計算されたゲトを取得します。</target>
        </trans-unit>
        <trans-unit id="fbec048bbd1449a0bc11388da4d5291473184989" translate="yes" xml:space="preserve">
          <source>Getting the return or frame address of a function.</source>
          <target state="translated">関数のリターンアドレスまたはフレームアドレスを取得します。</target>
        </trans-unit>
        <trans-unit id="5bde8fdcb7065ba19c1a32d2b6a67073b7fb1601" translate="yes" xml:space="preserve">
          <source>Give a warning when a value of type &lt;code&gt;float&lt;/code&gt; is implicitly promoted to &lt;code&gt;double&lt;/code&gt;. CPUs with a 32-bit &amp;ldquo;single-precision&amp;rdquo; floating-point unit implement &lt;code&gt;float&lt;/code&gt; in hardware, but emulate &lt;code&gt;double&lt;/code&gt; in software. On such a machine, doing computations using &lt;code&gt;double&lt;/code&gt; values is much more expensive because of the overhead required for software emulation.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 型の値が暗黙的に &lt;code&gt;double&lt;/code&gt; に昇格されたときに警告を出します。32ビットの「単精度」浮動小数点ユニットを備えたCPUは、ハードウェアでは &lt;code&gt;float&lt;/code&gt; を実装しますが、ソフトウェアでは &lt;code&gt;double&lt;/code&gt; をエミュレートします。このようなマシンでは、ソフトウェアエミュレーションに必要なオーバーヘッドのため、 &lt;code&gt;double&lt;/code&gt; 値を使用して計算を行うと、はるかにコストがかかります。</target>
        </trans-unit>
        <trans-unit id="133654b9660498348bca9e7a9d9666b1d3206bc1" translate="yes" xml:space="preserve">
          <source>Give a warning whenever a function is used before being declared. In C99 mode (</source>
          <target state="translated">宣言される前に関数が使用された場合に警告を与える。C99 モード (</target>
        </trans-unit>
        <trans-unit id="ce9ec4f1d36927037e489058adc0d7c699b3e5d0" translate="yes" xml:space="preserve">
          <source>Give an error whenever the &lt;em&gt;base standard&lt;/em&gt; (see</source>
          <target state="translated">&lt;em&gt;基本標準&lt;/em&gt;（エラーを参照）</target>
        </trans-unit>
        <trans-unit id="10288103238e1aab071f91b995853a568ee8af72" translate="yes" xml:space="preserve">
          <source>Given a set of input registers that die in an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know which are implicitly popped by the &lt;code&gt;asm&lt;/code&gt;, and which must be explicitly popped by GCC.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; で終了する一連の入力レジスターが与えられた場合、どれが &lt;code&gt;asm&lt;/code&gt; によって暗黙的にポップされ、どれがGCCによって明示的にポップされなければならないかを知る必要があります。</target>
        </trans-unit>
        <trans-unit id="d87967442824754978f26c181e17cc9e46db44dd" translate="yes" xml:space="preserve">
          <source>Gives all externally visible functions in the file being compiled an ARM instruction set header which switches to Thumb mode before executing the rest of the function. This allows these functions to be called from non-interworking code. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">コンパイルされたファイル内のすべての外部から見える関数に、残りの関数を実行する前にサム・モードに切り替えるARM命令セット・ヘッダを与えます。これにより、これらの関数をインターワーキング以外のコードから呼び出すことができます。既定ではインターワーキングが有効になっているため、このオプションは AAPCS 構成では有効ではありません。</target>
        </trans-unit>
        <trans-unit id="28fd2d80d56f82ae132cdb0c4269c770aa941c82" translate="yes" xml:space="preserve">
          <source>Global register variables cannot have initial values, because an executable file has no means to supply initial contents for a register.</source>
          <target state="translated">グローバルレジスタ変数は初期値を持つことができません。</target>
        </trans-unit>
        <trans-unit id="e1edbfbe92e2bd9d3f1182eb37f4bcfb20acdde5" translate="yes" xml:space="preserve">
          <source>Go source code.</source>
          <target state="translated">ソースコードを</target>
        </trans-unit>
        <trans-unit id="0104e918e01eb5413cf5e7e2b781b5b40dca1b8d" translate="yes" xml:space="preserve">
          <source>Guide linker to relax instructions.</source>
          <target state="translated">指示を緩和するためのガイドリンカー。</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="c2d31434fb0f344cb4feeec0b0e57232ab31c7ad" translate="yes" xml:space="preserve">
          <source>HI and LO registers.</source>
          <target state="translated">HIおよびLOレジスタ。</target>
        </trans-unit>
        <trans-unit id="ae1313e0d197443a538cfdaa0498460e61bc9b40" translate="yes" xml:space="preserve">
          <source>HI register.</source>
          <target state="translated">HIレジスター。</target>
        </trans-unit>
        <trans-unit id="9ffcbdd38d89bcb3eaa62489fe7281d06ece8295" translate="yes" xml:space="preserve">
          <source>HIGH register class $r12 to $r14, $r20 to $r31.</source>
          <target state="translated">HIGH登録クラス $r12~$r14、$r20~$r31。</target>
        </trans-unit>
        <trans-unit id="3cb15a163b8ebe83004d3a7496bed1214d5c34ea" translate="yes" xml:space="preserve">
          <source>HK</source>
          <target state="translated">HK</target>
        </trans-unit>
        <trans-unit id="f187928fdb223e7f3b7b0396e72e2d59a5f12b29" translate="yes" xml:space="preserve">
          <source>HR</source>
          <target state="translated">HR</target>
        </trans-unit>
        <trans-unit id="85df07a121977d0d0044781e9eeed44012e5da35" translate="yes" xml:space="preserve">
          <source>Half-Precision Floating Point.</source>
          <target state="translated">半精度浮動小数点。</target>
        </trans-unit>
        <trans-unit id="98b9b2da1252ae05155633eda47b6a7d5cf72927" translate="yes" xml:space="preserve">
          <source>Halt. The processor stops execution. This built-in is useful for implementing assertions.</source>
          <target state="translated">Halt(停止)。プロセッサは実行を停止します。この組み込みはアサーションの実装に便利です。</target>
        </trans-unit>
        <trans-unit id="04a52ed9fb0a2eefbc17a28c7b4e166c12cd47d4" translate="yes" xml:space="preserve">
          <source>Hardware autoprefetcher scheduler model control flag. Number of lookahead cycles the model looks into; at &amp;rsquo; &amp;rsquo; only enable instruction sorting heuristic.</source>
          <target state="translated">ハードウェア自動プリフェッチャースケジューラモデル制御フラグ。モデルが調査する先読みサイクルの数。''では、命令ソートヒューリスティックのみを有効にします。</target>
        </trans-unit>
        <trans-unit id="073339b2e7c4ff717e46d7be967106262132c9d4" translate="yes" xml:space="preserve">
          <source>Hardware multiplies are normally performed by calling a library routine. This saves space in the generated code. When compiling at</source>
          <target state="translated">ハードウェア乗算は通常、ライブラリルーチンを呼び出すことで実行されます。これにより、生成されるコードのスペースを節約することができます。でコンパイルする場合</target>
        </trans-unit>
        <trans-unit id="f483db45c59b64e904de79b67a44935e8bf546fe" translate="yes" xml:space="preserve">
          <source>Have &lt;code&gt;operator=&lt;/code&gt; return a reference to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">持っている &lt;code&gt;operator=&lt;/code&gt; への参照を返す &lt;code&gt;*this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="42b05fc1afa3da7a89484cda5a6cb36dbe6e8a78" translate="yes" xml:space="preserve">
          <source>Hence, it is assumed as a convention that &lt;code&gt;r*&lt;/code&gt; means &lt;code&gt;const
char *&lt;/code&gt; (since it is what is most often meant), and there is no way to encode &lt;code&gt;char *const&lt;/code&gt;. &lt;code&gt;char *const&lt;/code&gt; would simply be encoded as &lt;code&gt;*&lt;/code&gt;, and the &lt;code&gt;const&lt;/code&gt; is lost.</source>
          <target state="translated">したがって、慣習として、 &lt;code&gt;r*&lt;/code&gt; は &lt;code&gt;const char *&lt;/code&gt; *を意味するものと見なされ（ほとんどの場合それが意味されるため）、 &lt;code&gt;char *const&lt;/code&gt; をエンコードする方法はありません。 &lt;code&gt;char *const&lt;/code&gt; は単に &lt;code&gt;*&lt;/code&gt; としてエンコードされ、 &lt;code&gt;const&lt;/code&gt; は失われます。</target>
        </trans-unit>
        <trans-unit id="c6ff03b9e0183ccfd153d29e4ebb71b3afc43687" translate="yes" xml:space="preserve">
          <source>Here &amp;lsquo;</source>
          <target state="translated">ここに '</target>
        </trans-unit>
        <trans-unit id="63fa474126b5fb0e84bc0e1276f71b4f5949c4a7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; may or may not be restored to its first value when the &lt;code&gt;longjmp&lt;/code&gt; occurs. If &lt;code&gt;a&lt;/code&gt; is allocated in a register, then its first value is restored; otherwise, it keeps the last value stored in it.</source>
          <target state="translated">ここで、 &lt;code&gt;longjmp&lt;/code&gt; が発生したときに、 &lt;code&gt;a&lt;/code&gt; が最初の値に復元される場合と復元されない場合があります。 &lt;code&gt;a&lt;/code&gt; がレジスタに割り当てられている場合、最初の値が復元されます。それ以外の場合は、最後に格納された値を保持します。</target>
        </trans-unit>
        <trans-unit id="6c22abcd7bcbe4b705f9506a92dff2b4514bc0a5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining global register variables, but for a local variable the declaration appears within a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">ここで、 &lt;code&gt;r12&lt;/code&gt; は使用するレジスタの名前です。これは、グローバルレジスタ変数の定義に使用される構文と同じですが、ローカル変数の場合、宣言は関数内に表示されます。 &lt;code&gt;register&lt;/code&gt; キーワードが必要とされ、かつと組み合わせることはできません &lt;code&gt;static&lt;/code&gt; 。レジスター名は、ターゲット・プラットフォームに有効なレジスター名でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e629674ac2ffa8c8e6f920770dda44cae02f866e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining local register variables, but for a global variable the declaration appears outside a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">ここで、 &lt;code&gt;r12&lt;/code&gt; は使用するレジスタの名前です。これは、ローカルレジスタ変数の定義に使用される構文と同じですが、グローバル変数の場合、宣言は関数の外部に表示されます。 &lt;code&gt;register&lt;/code&gt; キーワードが必要とされ、かつと組み合わせることはできません &lt;code&gt;static&lt;/code&gt; 。レジスター名は、ターゲット・プラットフォームに有効なレジスター名でなければなりません。</target>
        </trans-unit>
        <trans-unit id="1bd41698f09a234c8d3f5259448a5e29c338b76f" translate="yes" xml:space="preserve">
          <source>Here are constraint modifier characters.</source>
          <target state="translated">制約修飾文字は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="13c7c696c96d9253d198dc3e9c528b8ff4863b3b" translate="yes" xml:space="preserve">
          <source>Here are some examples showing uses of these options.</source>
          <target state="translated">ここでは、これらのオプションの使用例をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="a2f0dcf3cf944a4192020c4b10f40e42e5e117ae" translate="yes" xml:space="preserve">
          <source>Here are some more examples of output operands.</source>
          <target state="translated">出力オペランドの例をいくつか挙げてみます。</target>
        </trans-unit>
        <trans-unit id="25efdeb982b817cc2032012465d473ceaf58d073" translate="yes" xml:space="preserve">
          <source>Here are some types and their encodings, as they are generated by the compiler on an i386 machine:</source>
          <target state="translated">ここでは、i386 マシン上でコンパイラが生成した型とそのエンコーディングを紹介します。</target>
        </trans-unit>
        <trans-unit id="807544d18135eba132f45e4832519a518a98b736" translate="yes" xml:space="preserve">
          <source>Here are specific details on what constraint letters you can use with &lt;code&gt;asm&lt;/code&gt; operands. Constraints can say whether an operand may be in a register, and which kinds of register; whether the operand can be a memory reference, and which kinds of address; whether the operand may be an immediate constant, and which possible values it may have. Constraints can also require two operands to match. Side-effects aren&amp;rsquo;t allowed in operands of inline &lt;code&gt;asm&lt;/code&gt;, unless &amp;lsquo;</source>
          <target state="translated">以下は、 &lt;code&gt;asm&lt;/code&gt; オペランドで使用できる制約文字の詳細です。制約は、オペランドがレジスターにあるかどうか、およびどの種類のレジスターかを示すことができます。オペランドがメモリ参照になるかどうか、およびどの種類のアドレスか。オペランドがイミディエート定数であるかどうか、およびオペランドが取り得る値。制約では、2つのオペランドを一致させる必要がある場合もあります。インライン &lt;code&gt;asm&lt;/code&gt; のオペランドでは、 'でない限り、副作用は許可されません。</target>
        </trans-unit>
        <trans-unit id="8169e79c24e48ad827616f09316f377a5693db58" translate="yes" xml:space="preserve">
          <source>Here is a fictitious &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; instruction. Notice that the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; pointer registers must be specified as input/output because the &lt;code&gt;asm&lt;/code&gt; modifies them.</source>
          <target state="translated">以下は、架空の &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; 命令です。 &lt;code&gt;asm&lt;/code&gt; がそれらを変更するため、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;z&lt;/code&gt; ポインターレジスタを入力/出力として指定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b840ee95bd53e4b94e99eb87178d11fd9afdba38" translate="yes" xml:space="preserve">
          <source>Here is a fictitious sum of squares instruction, that takes two pointers to floating point values in memory and produces a floating point register output. Notice that &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; both appear twice in the &lt;code&gt;asm&lt;/code&gt; parameters, once to specify memory accessed, and once to specify a base register used by the &lt;code&gt;asm&lt;/code&gt;. You won&amp;rsquo;t normally be wasting a register by doing this as GCC can use the same register for both purposes. However, it would be foolish to use both &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%3&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; in this &lt;code&gt;asm&lt;/code&gt; and expect them to be the same. In fact, &lt;code&gt;%3&lt;/code&gt; may well not be a register. It might be a symbolic memory reference to the object pointed to by &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">これは、メモリ内の浮動小数点値への2つのポインタを取り、浮動小数点レジスタ出力を生成する架空の二乗和命令です。通知 &lt;code&gt;x&lt;/code&gt; 、及び &lt;code&gt;y&lt;/code&gt; は二度現れる両方 &lt;code&gt;asm&lt;/code&gt; アクセスメモリを指定すると、パラメータとによって使用されるレジスタベースを指定するために、一度、 &lt;code&gt;asm&lt;/code&gt; 。GCCは両方の目的で同じレジスターを使用できるため、これを行うことでレジスターを無駄にすることは通常ありません。ただし、この &lt;code&gt;asm&lt;/code&gt; で &lt;code&gt;x&lt;/code&gt; に &lt;code&gt;%1&lt;/code&gt; と &lt;code&gt;%3&lt;/code&gt; の両方を使用し、それらが同じであることを期待するのは愚かです。実際、 &lt;code&gt;%3&lt;/code&gt; レジスタではないかもしれません。これは、 &lt;code&gt;x&lt;/code&gt; が指すオブジェクトへのシンボリックメモリ参照である可能性があります。</target>
        </trans-unit>
        <trans-unit id="989c5915dce017df7249cda1058c0a0b75ec727b" translate="yes" xml:space="preserve">
          <source>Here is a fully worked-out example using a Foundation library (which provides the implementation of &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSString&lt;/code&gt; and &lt;code&gt;NSLog&lt;/code&gt;):</source>
          <target state="translated">以下は、Foundationライブラリ（ &lt;code&gt;NSArray&lt;/code&gt; 、 &lt;code&gt;NSString&lt;/code&gt; 、および &lt;code&gt;NSLog&lt;/code&gt; の実装を提供する）を使用した完全に機能する例です。</target>
        </trans-unit>
        <trans-unit id="0837d871cde10d5f686c43af16d467ea239dcffc" translate="yes" xml:space="preserve">
          <source>Here is a list of each supported architecture and their supported implementations.</source>
          <target state="translated">ここでは、サポートされている各アーキテクチャと、サポートされている実装のリストを示します。</target>
        </trans-unit>
        <trans-unit id="6bbe295750387ad466f92bad763fdcf85832b55b" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling C++ programs:</source>
          <target state="translated">以下は、C ++プログラムのコンパイル&lt;em&gt;専用&lt;/em&gt;のオプションのリストです。</target>
        </trans-unit>
        <trans-unit id="9c6de7709b9bd71702ea864b6b84c7a93a1c5dfe" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling Objective-C and Objective-C++ programs:</source>
          <target state="translated">以下は、Objective-CおよびObjective-C ++プログラムのコンパイル&lt;em&gt;専用&lt;/em&gt;のオプションのリストです。</target>
        </trans-unit>
        <trans-unit id="3d287577ba4a1613932b539025d50b64c148479a" translate="yes" xml:space="preserve">
          <source>Here is a more technical description with the gory details. Consider the code</source>
          <target state="translated">ここでは、ゴリ押しでより専門的な説明をします。コードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1f5c95b6edb6a49dd54cd8ace0a3af7f6b8efa6e" translate="yes" xml:space="preserve">
          <source>Here is a realistic example for the VAX showing the use of clobbered registers:</source>
          <target state="translated">ここでは、クローバーされたレジスタの使用を示すVAXのための現実的な例を示しています。</target>
        </trans-unit>
        <trans-unit id="fab100c4848d525a51e3c94ffe939c5c90d217c1" translate="yes" xml:space="preserve">
          <source>Here is a small example of a spec file:</source>
          <target state="translated">ここでは、スペックファイルの小さな例を紹介します。</target>
        </trans-unit>
        <trans-unit id="fd38f38bfeb097a932215690af5b2bcebdd18296" translate="yes" xml:space="preserve">
          <source>Here is a summary of all the options, grouped by type. Explanations are in the following sections.</source>
          <target state="translated">ここでは、タイプ別にグループ化されたすべてのオプションの概要を示します。説明は以下のセクションにあります。</target>
        </trans-unit>
        <trans-unit id="776e1d0b1f7cf817731495ac8a0bb9e5528c2c48" translate="yes" xml:space="preserve">
          <source>Here is a table of all defined &amp;lsquo;</source>
          <target state="translated">ここに定義されたすべての表があります</target>
        </trans-unit>
        <trans-unit id="72ec126b11c4f7e2b3f6db181072684dbe3a798e" translate="yes" xml:space="preserve">
          <source>Here is a truncated example from the ARM port of &lt;code&gt;gcc&lt;/code&gt;:</source>
          <target state="translated">以下は、 &lt;code&gt;gcc&lt;/code&gt; の ARMポートからの切り捨てられた例です。</target>
        </trans-unit>
        <trans-unit id="816eebea82d67ac72ae8e305241f89073b0b966e" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;asm goto&lt;/code&gt; for i386:</source>
          <target state="translated">以下は、i386 の &lt;code&gt;asm goto&lt;/code&gt; の例です。</target>
        </trans-unit>
        <trans-unit id="ddf77123eb0a199270833915774797e456c51dd3" translate="yes" xml:space="preserve">
          <source>Here is an example of a PowerPC vector scale implemented in assembly, complete with vector and condition code clobbers, and some initialized offset registers that are unchanged by the &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">これは、アセンブリーに実装されたPowerPCベクトルスケールの例で、ベクトルと条件コードクロバー、および &lt;code&gt;asm&lt;/code&gt; によって変更されない初期化されたオフセットレジスターを完備しています。</target>
        </trans-unit>
        <trans-unit id="874ef7a4fb34e57091c1bf1216dfbb76680c0a4d" translate="yes" xml:space="preserve">
          <source>Here is an example of basic &lt;code&gt;asm&lt;/code&gt; for i386:</source>
          <target state="translated">以下は、i386 の基本的な &lt;code&gt;asm&lt;/code&gt; の例です。</target>
        </trans-unit>
        <trans-unit id="578c29000b6f8a220ff3bd98b1f6dac59cfc8f4c" translate="yes" xml:space="preserve">
          <source>Here is an example of constructing a &lt;code&gt;struct foo&lt;/code&gt; with a compound literal:</source>
          <target state="translated">次に、複合リテラルを使用して &lt;code&gt;struct foo&lt;/code&gt; を作成する例を示します。</target>
        </trans-unit>
        <trans-unit id="b487a854c417efabdfc0cd516c584d94dc1d4a11" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use this feature. Suppose you want to implement a class whose instances hold a weak pointer reference; the following class does this:</source>
          <target state="translated">ここでは、この機能を使用する方法の例を示します。インスタンスが弱いポインタ参照を保持するクラスを実装したいとします。</target>
        </trans-unit>
        <trans-unit id="ab5b5e88b81c892525543bbf2b441bfb5667f5c0" translate="yes" xml:space="preserve">
          <source>Here is an example showing handling for &lt;code&gt;_XABORT_RETRY&lt;/code&gt; and a fallback path for other failures:</source>
          <target state="translated">以下は、 &lt;code&gt;_XABORT_RETRY&lt;/code&gt; の処理と他の失敗のフォールバックパスを示す例です。</target>
        </trans-unit>
        <trans-unit id="156d8468259daa1a9f530dd9ec7054117c896faf" translate="yes" xml:space="preserve">
          <source>Here is an example using symbolic names.</source>
          <target state="translated">シンボリックネームを使用した例を示します。</target>
        </trans-unit>
        <trans-unit id="aa58661567f951b6e91b047e11c73d9fb7a1db05" translate="yes" xml:space="preserve">
          <source>Here is an example with a typename as the argument:</source>
          <target state="translated">ここでは、型名を引数にした例を示します。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">ここでは一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="26a60c8be4c01c6ccc45bd8984830035c8dc1a26" translate="yes" xml:space="preserve">
          <source>Here the two output filenames</source>
          <target state="translated">ここでは、2つの出力ファイル名</target>
        </trans-unit>
        <trans-unit id="00b4a6c83965e727380186cb35a7faefe39e2601" translate="yes" xml:space="preserve">
          <source>Here the type described is that of pointers to &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">ここで説明する型は、 &lt;code&gt;int&lt;/code&gt; へのポインタの型です。</target>
        </trans-unit>
        <trans-unit id="df28516bc4139f3f069071685fe09b0059baa73c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;d&lt;/code&gt; may either be in a register or in memory. Since the compiler might already have the current value of the &lt;code&gt;uint32_t&lt;/code&gt; location pointed to by &lt;code&gt;e&lt;/code&gt; in a register, you can enable it to choose the best location for &lt;code&gt;d&lt;/code&gt; by specifying both constraints.</source>
          <target state="translated">ここで、 &lt;code&gt;d&lt;/code&gt; はレジスタまたはメモリのいずれかにあります。コンパイラーはすでに &lt;code&gt;e&lt;/code&gt; が指す &lt;code&gt;uint32_t&lt;/code&gt; ロケーションの現在の値をレジスターに持っている可能性があるため、両方の制約を指定して、 &lt;code&gt;d&lt;/code&gt; に最適なロケーションを選択できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="d245b0ad9046b148b54dc212babce2d8a4b44886" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t4&lt;/code&gt; takes up 4 bytes.</source>
          <target state="translated">ここで、 &lt;code&gt;t4&lt;/code&gt; は4バイトを占めます。</target>
        </trans-unit>
        <trans-unit id="46a3f0b1a7f9b9f0c9d86a3230e304304bee1bda" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t5&lt;/code&gt; takes up 2 bytes.</source>
          <target state="translated">ここで、 &lt;code&gt;t5&lt;/code&gt; は2バイトを占めます。</target>
        </trans-unit>
        <trans-unit id="f9dddf42b68435ab0aa7d4d6b86db289bd3db824" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;std::move&lt;/code&gt; call is redundant. Because G++ implements Core Issue 1579, another example is:</source>
          <target state="translated">ここでは、 &lt;code&gt;std::move&lt;/code&gt; 呼び出しは冗長です。G ++はCore Issue 1579を実装しているため、別の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="94a1520d218a1c0edb195732392c054a4dc1a61d" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;intermediate&lt;/code&gt; receives the address of &lt;code&gt;store&lt;/code&gt; as an argument. If &lt;code&gt;intermediate&lt;/code&gt; calls &lt;code&gt;store&lt;/code&gt;, the arguments given to &lt;code&gt;store&lt;/code&gt; are used to store into &lt;code&gt;array&lt;/code&gt;. But this technique works only so long as the containing function (&lt;code&gt;hack&lt;/code&gt;, in this example) does not exit.</source>
          <target state="translated">ここで、関数 &lt;code&gt;intermediate&lt;/code&gt; は、引数として &lt;code&gt;store&lt;/code&gt; のアドレスを受け取ります。場合 &lt;code&gt;intermediate&lt;/code&gt; コールが &lt;code&gt;store&lt;/code&gt; に与えられた引数 &lt;code&gt;store&lt;/code&gt; に格納するために使用されている &lt;code&gt;array&lt;/code&gt; 。しかし、この手法は、含まれている関数（この例では &lt;code&gt;hack&lt;/code&gt; ）が終了しない限り機能します。</target>
        </trans-unit>
        <trans-unit id="8e86d7a0668faeeae59dff730b5c0908c7e965fa" translate="yes" xml:space="preserve">
          <source>Here, the names &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; appear in a context that does not depend on the type of &lt;code&gt;T&lt;/code&gt;. The compiler will thus require that they are defined in the context of use in the template, not only before the point of instantiation, and will here use &lt;code&gt;::foo(double)&lt;/code&gt; and &lt;code&gt;A::N&lt;/code&gt;, respectively. In particular, it will convert the integer value to a &lt;code&gt;double&lt;/code&gt; when passing it to &lt;code&gt;::foo(double)&lt;/code&gt;.</source>
          <target state="translated">ここで、名前 &lt;code&gt;foo&lt;/code&gt; と &lt;code&gt;N&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; のタイプに依存しないコンテキストに表示されます。したがって、コンパイラーは、インスタンス化の時点の前だけでなく、テンプレートでの使用のコンテキストでそれらを定義する必要があり、ここではそれぞれ &lt;code&gt;::foo(double)&lt;/code&gt; および &lt;code&gt;A::N&lt;/code&gt; を使用します。特に、 &lt;code&gt;::foo(double)&lt;/code&gt; に渡すときに整数値を &lt;code&gt;double&lt;/code&gt; に変換します。</target>
        </trans-unit>
        <trans-unit id="8a9da0e5c138e6d84a3e4a12f0c523bc1f369e0f" translate="yes" xml:space="preserve">
          <source>Hewlett-Packard PA-RISC&amp;mdash;</source>
          <target state="translated">Hewlett-Packard PA-RISC&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="9e735341d337ae137df7758e8465bb4d998cc55a" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point constants.</source>
          <target state="translated">16進数の浮動小数点定数。</target>
        </trans-unit>
        <trans-unit id="26e165ccce457fee42636ec531aa349640cf4392" translate="yes" xml:space="preserve">
          <source>Hidden visibility indicates that the entity declared has a new form of linkage, which we call &amp;ldquo;hidden linkage&amp;rdquo;. Two declarations of an object with hidden linkage refer to the same object if they are in the same shared object.</source>
          <target state="translated">非表示の可視性は、宣言されたエンティティに新しい形式のリンケージがあることを示します。これを「非表示のリンケージ」と呼びます。非表示のリンケージを持つオブジェクトの2つの宣言は、同じ共有オブジェクト内にある場合、同じオブジェクトを参照します。</target>
        </trans-unit>
        <trans-unit id="29464505836db623029950c0312fcb03cbd85481" translate="yes" xml:space="preserve">
          <source>Historically, GCC has not deleted &amp;ldquo;empty&amp;rdquo; loops under the assumption that the most likely reason you would put one in a program is to have a delay, so deleting them will not make real programs run any faster.</source>
          <target state="translated">歴史的に、GCCは「空の」ループを削除していません。プログラムにループを入れる最も可能性の高い理由は遅延があるため、それらを削除しても実際のプログラムの実行が速くなることはないからです。</target>
        </trans-unit>
        <trans-unit id="25855108b662a0e8c1ed703787f979b815d2d1a6" translate="yes" xml:space="preserve">
          <source>Historically, compilers for many languages, including C++ and Fortran, have been implemented as &amp;ldquo;preprocessors&amp;rdquo; which emit another high level language such as C. None of the compilers included in GCC are implemented this way; they all generate machine code directly. This sort of preprocessor should not be confused with the &lt;em&gt;C preprocessor&lt;/em&gt;, which is an integral feature of the C, C++, Objective-C and Objective-C++ languages.</source>
          <target state="translated">歴史的に、C ++やFortranを含む多くの言語のコンパイラは、「プリプロセッサ」として実装されており、Cなどの別の高水準言語を出力します。GCCに含まれるコンパイラは、この方法で実装されていません。それらはすべて直接マシンコードを生成します。この種のプリプロセッサーは、C、C ++、Objective-C、およびObjective-C ++言語の統合機能である&lt;em&gt;Cプリプロセッサー&lt;/em&gt;と混同しないでください。</target>
        </trans-unit>
        <trans-unit id="1df0e52c96207e60432f242eee2da9b8ff549d2b" translate="yes" xml:space="preserve">
          <source>How GCC calculates the size of an &lt;code&gt;asm&lt;/code&gt; block.</source>
          <target state="translated">GCCが &lt;code&gt;asm&lt;/code&gt; ブロックのサイズを計算する方法。</target>
        </trans-unit>
        <trans-unit id="3f9040ed129a83c15932559ac6449ffd679075c3" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C specification.</source>
          <target state="translated">GCCがISO C仕様をどのように実装しているか。</target>
        </trans-unit>
        <trans-unit id="f79f60bc97ae69f938083d6bd71809804c4831c5" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C++ specification.</source>
          <target state="translated">GCCがISO C++仕様をどのように実装しているか。</target>
        </trans-unit>
        <trans-unit id="62fab6a3b6832fb352405ce63e5b735618b3cef7" translate="yes" xml:space="preserve">
          <source>How To Get Help with GCC</source>
          <target state="translated">GCCのヘルプを得るには</target>
        </trans-unit>
        <trans-unit id="3e63c682de797883ae23802bc327411231cc31a8" translate="yes" xml:space="preserve">
          <source>How a diagnostic is identified (C90 3.7, C99 and C11 3.10, C90, C99 and C11 5.1.1.3).</source>
          <target state="translated">診断の識別方法(C90 3.7、C99、C11 3.10、C90、C99、C11 5.1.1.3)。</target>
        </trans-unit>
        <trans-unit id="a123b2bec235da6dad3dc58f234c2574673ff822" translate="yes" xml:space="preserve">
          <source>How much optimization?</source>
          <target state="translated">どの程度の最適化か?</target>
        </trans-unit>
        <trans-unit id="31524a9fb30368b64541b8aeb51e1826b2eb3b0a" translate="yes" xml:space="preserve">
          <source>How picky should the compiler be?</source>
          <target state="translated">コンパイラはどれだけうるさいのか?</target>
        </trans-unit>
        <trans-unit id="1e2b472e6c532fe8af4932714956f74293f46083" translate="yes" xml:space="preserve">
          <source>How sequences in both forms of header names are mapped to headers or external source file names (C90 6.1.7, C99 and C11 6.4.7).</source>
          <target state="translated">ヘッダー名の両方の形式の配列がどのようにヘッダーまたは外部ソースファイル名にマッピングされるか(C90 6.1.7、C99、C11 6.4.7)。</target>
        </trans-unit>
        <trans-unit id="848f6ad2348dcee59d13596577066e141ef4d0ad" translate="yes" xml:space="preserve">
          <source>How the named source file is searched for in an included &amp;lsquo;</source>
          <target state="translated">インクルードで名前付きソースファイルを検索する方法 '</target>
        </trans-unit>
        <trans-unit id="130378b21f742b32140465d74f388cb06f5001cf" translate="yes" xml:space="preserve">
          <source>How the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value is chosen for certain floating constants (C90 6.1.3.1, C99 and C11 6.4.4.2).</source>
          <target state="translated">特定の浮動定数について、最も近い表現可能な値または最も近い表現可能な値にすぐ隣接するより大きい表現可能な値またはより小さい表現可能な値がどのように選択されるか(C90 6.1.3.1、C99およびC11 6.4.4.2)。</target>
        </trans-unit>
        <trans-unit id="606b9fa050c9f5a8165f3052560ba0c7d8b85fa0" translate="yes" xml:space="preserve">
          <source>How to contribute to testing and developing GCC.</source>
          <target state="translated">GCCのテスト開発にどう貢献するか。</target>
        </trans-unit>
        <trans-unit id="25170558e581aabef161dcb92e9a6de67ff5f448" translate="yes" xml:space="preserve">
          <source>How to help assure funding for free software.</source>
          <target state="translated">自由ソフトウェアのための資金調達を保証するためにはどうすればよいか。</target>
        </trans-unit>
        <trans-unit id="488dee81569b2dc10244c6b537b50c3cc87269e1" translate="yes" xml:space="preserve">
          <source>How to pass switches to sub-processes.</source>
          <target state="translated">スイッチをサブプロセスに渡す方法。</target>
        </trans-unit>
        <trans-unit id="8c1e8efdd3392d7ad8138bb7223322e34b90c240" translate="yes" xml:space="preserve">
          <source>How to use gcov-dump.</source>
          <target state="translated">gcov-dumpの使い方。</target>
        </trans-unit>
        <trans-unit id="f7d8be53e9f165a3a11bb6dadca7af891ced365f" translate="yes" xml:space="preserve">
          <source>How to use gcov-tool.</source>
          <target state="translated">gcov-toolの使い方。</target>
        </trans-unit>
        <trans-unit id="dde16118c9faa27675fdfe5cf0405564b55597c4" translate="yes" xml:space="preserve">
          <source>How to use gcov.</source>
          <target state="translated">gcovの使い方。</target>
        </trans-unit>
        <trans-unit id="4e461b3cc6748ec681eab8b558da86d4b08a95ab" translate="yes" xml:space="preserve">
          <source>How you can copy and share this manual.</source>
          <target state="translated">このマニュアルをコピーして共有する方法</target>
        </trans-unit>
        <trans-unit id="9e8e4dbcb1b211f7b5ab31c6c59b3a79ec59dd4f" translate="yes" xml:space="preserve">
          <source>How, why and where to report bugs.</source>
          <target state="translated">どのように、なぜ、どこにバグを報告するのか。</target>
        </trans-unit>
        <trans-unit id="0e3275b465f023e98f74ae720920ad438e50264c" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; is not a valid cast because the union has no member of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; ユニオンには &lt;code&gt;float&lt;/code&gt; 型のメンバーがないため、は有効なキャストではありません。</target>
        </trans-unit>
        <trans-unit id="9ea71fd7ca0b24f50560578a479dbd93975ddc25" translate="yes" xml:space="preserve">
          <source>However, if a library or main executable is supposed to throw or catch exceptions, you must link it using the G++ driver, or using the option</source>
          <target state="translated">しかし、ライブラリやメインの実行ファイルが例外を投げたりキャッチしたりするようになっている場合は、G++ドライバを使ってリンクするか、オプションの</target>
        </trans-unit>
        <trans-unit id="68ad5ea0590b2a354fce31707da021a7a4908783" translate="yes" xml:space="preserve">
          <source>However, if the volatile storage is not being modified, and the value of the volatile storage is not used, then the situation is less obvious. For example</source>
          <target state="translated">しかし、揮発性記憶装置の値が変更されておらず、揮発性記憶装置の値が使用されていない場合には、その状況はあまり顕著ではない。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3955f23a3aaffbcd48d8f54a3969fb80a9687bcd" translate="yes" xml:space="preserve">
          <source>However, the rationale here is that optimization of a nonempty loop cannot produce an empty one. This held for carefully written C compiled with less powerful optimizers but is not always the case for carefully written C++ or with more powerful optimizers. Thus GCC will remove operations from loops whenever it can determine those operations are not externally visible (apart from the time taken to execute them, of course). In case the loop can be proved to be finite, GCC will also remove the loop itself.</source>
          <target state="translated">しかし、ここでの理論的根拠は、空でないループを最適化しても空のループを生成することはできないということです。これは、慎重に書かれたC言語をそれほど強力でないオプティマイザを使ってコンパイルした場合にも当てはまりますが、慎重に書かれたC++やより強力なオプティマイザを使ってコンパイルした場合には、必ずしも当てはまるとは限りません。このように、GCC はループから操作を削除します。ループが有限であることが証明できる場合、GCC はループ自体も削除します。</target>
        </trans-unit>
        <trans-unit id="9091ae1dd68a17c85dd2a3885c0a623d65f81f37" translate="yes" xml:space="preserve">
          <source>However, the use of &lt;code&gt;gcc&lt;/code&gt; does not add the C++ library. &lt;code&gt;g++&lt;/code&gt; is a program that calls GCC and automatically specifies linking against the C++ library. It treats &amp;lsquo;</source>
          <target state="translated">ただし、 &lt;code&gt;gcc&lt;/code&gt; を使用してもC ++ライブラリは追加されません。 &lt;code&gt;g++&lt;/code&gt; は、GCCを呼び出し、C ++ライブラリに対するリンクを自動的に指定するプログラムです。それは扱います</target>
        </trans-unit>
        <trans-unit id="25970c1ebc6bb12a4ef702c744afb1bf31667e71" translate="yes" xml:space="preserve">
          <source>However, these built-in functions may interact badly with some sophisticated features or other extensions of the language. It is, therefore, not recommended to use them outside very simple functions acting as mere forwarders for their arguments.</source>
          <target state="translated">しかし、これらの組み込み関数は、いくつかの洗練された機能や言語の他の拡張機能とうまく相互作用しない可能性があります。したがって、引数の単なるフォワーダとして機能する非常に単純な関数以外では使用しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="5035ba1d98ecd402c64867de896608b2100e61c1" translate="yes" xml:space="preserve">
          <source>I register</source>
          <target state="translated">登録する</target>
        </trans-unit>
        <trans-unit id="0d25569c1c1c38b68b7adac7a2691f92a581fc48" translate="yes" xml:space="preserve">
          <source>IBM 970 Server CPU (ie, Apple G5).</source>
          <target state="translated">IBM 970サーバーCPU(すなわち、Apple G5)。</target>
        </trans-unit>
        <trans-unit id="7ff989fdaf3c65fbe049204ca8d2d3b298dcd55a" translate="yes" xml:space="preserve">
          <source>IBM A2 64-bit Embedded CPU</source>
          <target state="translated">IBM A2 64ビット組み込みCPU</target>
        </trans-unit>
        <trans-unit id="7ebf129d97228e5e38b88ee3a2bf7cb0f28dd1fe" translate="yes" xml:space="preserve">
          <source>IBM POWER4 Server CPU.</source>
          <target state="translated">IBM POWER4サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="60fedee6d379816b90140e69a6cb94f8d8a8d0f3" translate="yes" xml:space="preserve">
          <source>IBM POWER5 Server CPU.</source>
          <target state="translated">IBM POWER5サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="d3878c6f9c9f4047fa51bbea5fff4ce5c35e5af1" translate="yes" xml:space="preserve">
          <source>IBM POWER5+ Server CPU.</source>
          <target state="translated">IBM POWER5+サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="738e9fd792342dee79476051b27ac20d78ee9cda" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (Architected mode).</source>
          <target state="translated">IBM POWER6 Server CPU(アーキテクトモード)。</target>
        </trans-unit>
        <trans-unit id="a1d93b9cb2926fb05ec1f665abf51961f777a207" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (RAW mode).</source>
          <target state="translated">IBM POWER6 Server CPU(RAWモード)。</target>
        </trans-unit>
        <trans-unit id="dbb9a20762f1a0c1106412992e6cc65c84bffc0f" translate="yes" xml:space="preserve">
          <source>IBM POWER7 Server CPU.</source>
          <target state="translated">IBM POWER7サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="a9a9c9a90077a9f8cbd67dc15b93836e1c987d49" translate="yes" xml:space="preserve">
          <source>IBM POWER8 Server CPU.</source>
          <target state="translated">IBM POWER8サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="c65507ef531be00847ba2a33296dc99803a18664" translate="yes" xml:space="preserve">
          <source>IBM POWER9 Server CPU.</source>
          <target state="translated">IBM POWER9サーバーCPU。</target>
        </trans-unit>
        <trans-unit id="5ad8015703e3cb16c9df6da3a8d9e97de8f9cd44" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 464 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 464 32ビット組込みCPU。</target>
        </trans-unit>
        <trans-unit id="a548cb73c6f0d35ac7d906f9a02a9350c2eb6114" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 476FP 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 476FP 32ビット組み込みCPU。</target>
        </trans-unit>
        <trans-unit id="f3afdcbb4bda95413d989775a1a1f73e05c37f36" translate="yes" xml:space="preserve">
          <source>IBM PowerPC Cell Broadband Engine Architecture CPU.</source>
          <target state="translated">IBM PowerPCセルブロードバンドエンジンアーキテクチャCPU。</target>
        </trans-unit>
        <trans-unit id="981e760991adb048080be646b9e1438966c192d0" translate="yes" xml:space="preserve">
          <source>IDT WinChip 2 CPU, dealt in same way as i486 with additional MMX and 3DNow! instruction set support.</source>
          <target state="translated">IDT WinChip 2 CPUは、i486と同じようにMMXと3DNow! 命令セットをサポートしています。</target>
        </trans-unit>
        <trans-unit id="e642e2d5acc8e35a06fd449f3d95c2b4f1486f5e" translate="yes" xml:space="preserve">
          <source>IDT WinChip C6 CPU, dealt in same way as i486 with additional MMX instruction set support.</source>
          <target state="translated">IDT WinChip C6 CPUは、MMX命令セットのサポートを追加したi486と同じように扱われました。</target>
        </trans-unit>
        <trans-unit id="ec8566180afc9d36e3493dbd47d7e2d1e9ae9485" translate="yes" xml:space="preserve">
          <source>IPA-CP attempts to track all possible values and types passed to a function&amp;rsquo;s parameter in order to propagate them and perform devirtualization.</source>
          <target state="translated">IPA-CPは、関数のパラメーターに渡されるすべての可能な値と型を追跡して、それらを伝播し、仮想化を解除しようとします。</target>
        </trans-unit>
        <trans-unit id="f55eb535889fe2d3f53ef9f4b4a57453862d05ea" translate="yes" xml:space="preserve">
          <source>IPA-CP calculates its own score of cloning profitability heuristics and performs those cloning opportunities with scores that exceed</source>
          <target state="translated">IPA-CPは、独自のクローニング収益性ヒューリスティックのスコアを計算し、それを超えるスコアを持つクローニング機会を実行します。</target>
        </trans-unit>
        <trans-unit id="18432c18c0adba44c26c2a586731fb98a9d6d897" translate="yes" xml:space="preserve">
          <source>IPA-CP is also capable to propagate a number of scalar values passed in an aggregate.</source>
          <target state="translated">IPA-CPは、アグリゲートで渡されたスカラ値の数を伝搬することも可能です。</target>
        </trans-unit>
        <trans-unit id="6522b0ebe1c355ebd160511e9d28107d63eb735d" translate="yes" xml:space="preserve">
          <source>IPA-SRA replaces a pointer to an aggregate with one or more new parameters only when their cumulative size is less or equal to</source>
          <target state="translated">IPA-SRAは、その累積サイズが</target>
        </trans-unit>
        <trans-unit id="b5db770cbd54ca7a4734eeb3ccbfba61d7f93149" translate="yes" xml:space="preserve">
          <source>IRA can be used to evaluate more accurate register pressure in loops for decisions to move loop invariants (see</source>
          <target state="translated">IRAは、ループ不変量を移動させる決定を行う際に、ループ内のレジスタ圧をより正確に評価するために使用することができます(以下を参照してください)。</target>
        </trans-unit>
        <trans-unit id="3c1b099cab9d31b532499457a148771feb1ef850" translate="yes" xml:space="preserve">
          <source>IRA uses regional register allocation by default. If a function contains more loops than the number given by this parameter, only at most the given number of the most frequently-executed loops form regions for regional register allocation.</source>
          <target state="translated">IRAでは、デフォルトで地域レジスタの割り当てが使用されます。関数にこのパラメータで指定された数よりも多くのループが含まれている場合、最も頻繁に実行されるループのうち、最大でも指定された数だけが地域レジスタ割り当てのための領域を形成します。</target>
        </trans-unit>
        <trans-unit id="e1a35fb9a6e6329c3bd0cf9dd057013f4b706fa3" translate="yes" xml:space="preserve">
          <source>ISA 3.0 of the PowerPC added new atomic memory operation (amo) instructions. GCC provides support for these instructions in 64-bit environments. All of the functions are declared in the include file &lt;code&gt;amo.h&lt;/code&gt;.</source>
          <target state="translated">PowerPCのISA 3.0は、新しいアトミックメモリ操作（amo）命令を追加しました。GCCは、64ビット環境でこれらの命令をサポートします。すべての関数は、インクルードファイル &lt;code&gt;amo.h&lt;/code&gt; で宣言されています。</target>
        </trans-unit>
        <trans-unit id="7cc00c6a2a5486718b4fd3642b097add2ed40af8" translate="yes" xml:space="preserve">
          <source>ISO C does not permit such a construct.</source>
          <target state="translated">ISO Cはそのような構成を許可していません。</target>
        </trans-unit>
        <trans-unit id="fff460d30b4f47f8adc19f1a9e29c9166acd036b" translate="yes" xml:space="preserve">
          <source>ISO C requires a &amp;ldquo;diagnostic&amp;rdquo; message for certain kinds of invalid programs, but a warning is defined by GCC to count as a diagnostic. If GCC produces a warning but not an error, that is correct ISO C support. If testsuites call this &amp;ldquo;failure&amp;rdquo;, they should be run with the GCC option</source>
          <target state="translated">ISO Cは、特定の種類の無効なプログラムに対して「診断」メッセージを要求しますが、診断としてカウントされる警告がGCCによって定義されています。GCCが警告を生成するがエラーは生成しない場合、それは正しいISO Cサポートです。テストスイートがこれを「失敗」と呼ぶ場合、GCCオプションで実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="50648f88649c1f5dd7bf2cb4554ff39825b6b2bb" translate="yes" xml:space="preserve">
          <source>ISO C11, the 2011 revision of the ISO C standard. This standard is substantially completely supported, modulo bugs, floating-point issues (mainly but not entirely relating to optional C11 features from Annexes F and G) and the optional Annexes K (Bounds-checking interfaces) and L (Analyzability). The name &amp;lsquo;</source>
          <target state="translated">ISO C11、ISO C規格の2011年改訂。この標準は、実質的に完全にサポートされ、モジュロバグ、浮動小数点の問題（主に、ただし完全ではないが、附属書FおよびGのオプションのC11機能に関連しています）およびオプションの附属書K（境界チェックインターフェイス）およびL（分析可能性）です。名前 '</target>
        </trans-unit>
        <trans-unit id="a94be837facd76378c47084c4afa22ac2ddb78d6" translate="yes" xml:space="preserve">
          <source>ISO C17, the 2017 revision of the ISO C standard (published in 2018). This standard is same as C11 except for corrections of defects (all of which are also applied with</source>
          <target state="translated">ISO C17、ISO C規格の2017年改訂版(2018年発行)。この規格は、欠陥の修正以外はC11と同じです(いずれも</target>
        </trans-unit>
        <trans-unit id="835b0fe47c2b2521e64ab3b466f790da05e1cf2c" translate="yes" xml:space="preserve">
          <source>ISO C90 as modified in amendment 1.</source>
          <target state="translated">ISO C90を修正1で修正しました。</target>
        </trans-unit>
        <trans-unit id="dd3ae16769f5e30cd0e25b181c241be07701badf" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++ allow declarations and code to be freely mixed within compound statements. As an extension, GNU C also allows this in C90 mode. For example, you could do:</source>
          <target state="translated">ISO C99とISO C++では、宣言とコードを複合文の中で自由に混在させることができます。拡張として、GNU Cでは、C90モードでもこれを許可しています。例えば、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="fd9df382c7a9e275bf54293954eb3cea3a9394da" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++11 support data types for integers that are at least 64 bits wide, and as an extension GCC supports them in C90 and C++98 modes. Simply write &lt;code&gt;long long int&lt;/code&gt; for a signed integer, or &lt;code&gt;unsigned long long int&lt;/code&gt; for an unsigned integer. To make an integer constant of type &lt;code&gt;long long int&lt;/code&gt;, add the suffix &amp;lsquo;</source>
          <target state="translated">ISO C99およびISO C ++ 11は、少なくとも64ビット幅の整数のデータ型をサポートし、GCCは拡張としてC90およびC ++ 98モードでそれらをサポートします。単に書く &lt;code&gt;long long int&lt;/code&gt; 符号付き整数のため、または &lt;code&gt;unsigned long long int&lt;/code&gt; 符号なし整数のために。 &lt;code&gt;long long int&lt;/code&gt; 型の整数定数を作成するには、接尾辞 'を追加します</target>
        </trans-unit>
        <trans-unit id="8b83453de486a892e712e76d4673bb12ab84c153" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++17 support floating-point numbers written not only in the usual decimal notation, such as &lt;code&gt;1.55e1&lt;/code&gt;, but also numbers such as &lt;code&gt;0x1.fp3&lt;/code&gt; written in hexadecimal format. As a GNU extension, GCC supports this in C90 mode (except in some cases when strictly conforming) and in C++98, C++11 and C++14 modes. In that format the &amp;lsquo;</source>
          <target state="translated">ISO C99およびISO C ++ 17は、 &lt;code&gt;1.55e1&lt;/code&gt; などの通常の10進表記で記述された浮動小数点数だけでなく、16進形式で記述された &lt;code&gt;0x1.fp3&lt;/code&gt; などの数値もサポートします。GNU拡張機能として、GCCはこれをC90モード（厳密に準拠している場合を除く）およびC ++ 98、C ++ 11、C ++ 14モードでサポートします。そのフォーマットでは</target>
        </trans-unit>
        <trans-unit id="f45bb32dfebc99db4671808e81b5e06e1a3ae3f3" translate="yes" xml:space="preserve">
          <source>ISO C99 supports complex floating data types, and as an extension GCC supports them in C90 mode and in C++. GCC also supports complex integer data types which are not part of ISO C99. You can declare complex types using the keyword &lt;code&gt;_Complex&lt;/code&gt;. As an extension, the older GNU keyword &lt;code&gt;__complex__&lt;/code&gt; is also supported.</source>
          <target state="translated">ISO C99は複雑な浮動データ型をサポートし、拡張としてGCCはC90モードおよびC ++でそれらをサポートします。GCCは、ISO C99の一部ではない複雑な整数データ型もサポートしています。キーワード &lt;code&gt;_Complex&lt;/code&gt; を使用して複合型を宣言できます。拡張機能として、古いGNUキーワード &lt;code&gt;__complex__&lt;/code&gt; もサポートされています。</target>
        </trans-unit>
        <trans-unit id="84c793c819960394587c5cc12a67f14b20b38119" translate="yes" xml:space="preserve">
          <source>ISO C99. This standard is substantially completely supported, modulo bugs and floating-point issues (mainly but not entirely relating to optional C99 features from Annexes F and G). See &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for more information. The names &amp;lsquo;</source>
          <target state="translated">ISO C99。この標準は実質的に完全にサポートされており、モジュロバグと浮動小数点の問題（主に、完全ではないが、附属書FとGのオプションのC99機能に関連している）。詳細については、&lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http：//gcc.gnu.org/c99status.html&lt;/a&gt;を参照してください。名 '</target>
        </trans-unit>
        <trans-unit id="b19dfb0d72b128922f94144b3b4ef7616d4f13d5" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3 defines new permissible values for &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; that indicate that operations and constants with a semantic type that is an interchange or extended format should be evaluated to the precision and range of that type. These new values are a superset of those permitted under C99/C11, which does not specify the meaning of other positive values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt;. As such, code conforming to C11 may not have been written expecting the possibility of the new values.</source>
          <target state="translated">ISO / IEC TS 18661-3は、 &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; の新しい許容値を定義しています。これは、交換形式または拡張形式であるセマンティック型の操作と定数を、その型の精度と範囲で評価する必要があることを示します。これらの新しい値は、C99 / C11で許可されている値のスーパーセットであり、 &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; の他の正の値の意味を指定していません。そのため、C11に準拠するコードは、新しい値の可能性を想定して書かれていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="0704127df0a170eee2b3d8c1f35e3e35e1e33e3c" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3:2015 defines C support for additional floating types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, and GCC supports these type names; the set of types supported depends on the target architecture. These types are not supported when compiling C++. Constants with these types use suffixes &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;. These type names can be used together with &lt;code&gt;_Complex&lt;/code&gt; to declare complex types.</source>
          <target state="translated">ISO / IEC TS 18661-3：2015は、追加の浮動小数点型 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; および &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; Cサポートを定義し、GCCはこれらの型名をサポートします。サポートされるタイプのセットは、ターゲットアーキテクチャによって異なります。これらの型は、C ++のコンパイル時にはサポートされません。これらのタイプの定数は、サフィックス &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; または &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; および &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; または &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; ます。これらの型名を &lt;code&gt;_Complex&lt;/code&gt; と一緒に使用して、複合型を宣言できます。</target>
        </trans-unit>
        <trans-unit id="beeb64c7eeaed20d36a340ce018bf60cf4a13bf4" translate="yes" xml:space="preserve">
          <source>Ideally, a portable program should always use &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; when it depends on the signedness of an object. But many programs have been written to use plain &lt;code&gt;char&lt;/code&gt; and expect it to be signed, or expect it to be unsigned, depending on the machines they were written for. This option, and its inverse, let you make such a program work with the opposite default.</source>
          <target state="translated">理想的には、移植可能なプログラムは、オブジェクトの &lt;code&gt;unsigned char&lt;/code&gt; に依存する場合、常に &lt;code&gt;signed char&lt;/code&gt; またはunsigned charを使用する必要があります。しかし、多くのプログラムは、プレーンな &lt;code&gt;char&lt;/code&gt; を使用するように作成されており、署名対象のマシンに応じて、署名されること、または署名されないことを期待しています。このオプションとその逆により、そのようなプログラムを反対のデフォルトで動作させることができます。</target>
        </trans-unit>
        <trans-unit id="ab2f71fc75bf24fc42ea67b7b9de3bc2377f68da" translate="yes" xml:space="preserve">
          <source>Identical like the above one, but the location of the function in the &lt;code&gt;jli&lt;/code&gt; table is known and given as an attribute parameter.</source>
          <target state="translated">上記と同じですが、 &lt;code&gt;jli&lt;/code&gt; テーブル内の関数の場所がわかっており、属性パラメーターとして指定されます。</target>
        </trans-unit>
        <trans-unit id="06758e7fffb077a661e9d5cfb54c15702892df80" translate="yes" xml:space="preserve">
          <source>Identifier conflicts with labels. Traditional C lacks a separate namespace for labels.</source>
          <target state="translated">識別子とラベルが競合します。従来のC言語では、ラベルのための独立した名前空間がありません。</target>
        </trans-unit>
        <trans-unit id="5a6386123e656c29d067b76006564d3382accf62" translate="yes" xml:space="preserve">
          <source>Identify the versions of each tool used by the compiler, in a &lt;code&gt;.ident&lt;/code&gt; assembler directive in the output.</source>
          <target state="translated">コンパイラが使用する各ツールのバージョンを、出力の &lt;code&gt;.ident&lt;/code&gt; アセンブラディレクティブで識別します。</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="b94b85388613ff812132cfe4fbfdcb534fff787e" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;</source>
          <target state="translated">もし '</target>
        </trans-unit>
        <trans-unit id="8cfab80fece1ea34402901dd4726bddf817b9cff" translate="yes" xml:space="preserve">
          <source>If 3DNow! extensions are enabled, &lt;code&gt;V2SF&lt;/code&gt; is used as a mode for a vector of two 32-bit floating-point values.</source>
          <target state="translated">3DNowなら！拡張が有効になっている場合、 &lt;code&gt;V2SF&lt;/code&gt; は2つの32ビット浮動小数点値のベクトルのモードとして使用されます。</target>
        </trans-unit>
        <trans-unit id="23030af34d65c4d0b445c2e6bf477bf6b1f5c071" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%*&lt;/code&gt; appears as the last part of a spec sequence then a space is added after the end of the last substitution. If there is more text in the sequence, however, then a space is not generated. This allows the &lt;code&gt;%*&lt;/code&gt; substitution to be used as part of a larger string. For example, a spec string like this:</source>
          <target state="translated">&lt;code&gt;%*&lt;/code&gt; が仕様シーケンスの最後の部分として表示される場合、最後の置換の終了後にスペースが追加されます。ただし、シーケンス内にさらにテキストがある場合、スペースは生成されません。これにより、 &lt;code&gt;%*&lt;/code&gt; 置換をより大きな文字列の一部として使用できます。たとえば、次のようなspec文字列：</target>
        </trans-unit>
        <trans-unit id="539ea1d3aa99e1f5670827ce3f6d748af1cde993" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) is not implemented or returns &lt;code&gt;NO&lt;/code&gt;, the runtime then tries the forwarding hook.</source>
          <target state="translated">場合 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; （又は &lt;code&gt;+resolveClassMethod:&lt;/code&gt; ）が実装しないか、または戻り &lt;code&gt;NO&lt;/code&gt; 、ランタイムは次に転送フックを試みます。</target>
        </trans-unit>
        <trans-unit id="3f8dd7c3c9fed3437a52aa9c603d614b32cf2d92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; were passed, the above would trigger a warning, but this time because of the lack of bounds checking.</source>
          <target state="translated">場合 &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; 渡された、上記の理由境界チェックの不足の警告が、この時間をトリガーします。</target>
        </trans-unit>
        <trans-unit id="ca79581e5d9acfa9f2b20401cffd3a6d08f404f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;attribute-specifier-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">場合 &lt;code&gt;D1&lt;/code&gt; は、フォーム有する &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt; 、そして宣言 &lt;code&gt;T D&lt;/code&gt; タイプ「指定 &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; は、」 &lt;var&gt;ident&lt;/var&gt; 、次いで、 &lt;code&gt;T D1&lt;/code&gt; は、「タイプを指定し &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;attribute-specifier-list&lt;/var&gt; &lt;var&gt;ident&lt;/var&gt; の指定子リスト &lt;var&gt;Type&lt;/var&gt; 」。</target>
        </trans-unit>
        <trans-unit id="bce12bf3e38781beccd90d07d87af63b34ed169d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;*
&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; pointer to &lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">場合 &lt;code&gt;D1&lt;/code&gt; は、形式は &lt;code&gt;* &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt; 、と宣言 &lt;code&gt;T D&lt;/code&gt; 指定タイプを「 &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; のために」 &lt;var&gt;ident&lt;/var&gt; 、その後、 &lt;code&gt;T D1&lt;/code&gt; は「タイプを指定する &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;ident&lt;/var&gt; の &lt;var&gt;Type&lt;/var&gt; &amp;rdquo;へのtype-list &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; ポインター。</target>
        </trans-unit>
        <trans-unit id="fdf6957ed3c287429ab808fa75095697e4d021d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; has been set for a given decl, use that in the dump instead of &lt;code&gt;DECL_NAME&lt;/code&gt;. Its primary use is ease of use working backward from mangled names in the assembly file.</source>
          <target state="translated">&lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; が特定のdeclに設定されている場合は、 &lt;code&gt;DECL_NAME&lt;/code&gt; の代わりにそれをダンプで使用します。その主な用途は、アセンブリファイル内のマングルされた名前から逆方向に作業する使いやすさです。</target>
        </trans-unit>
        <trans-unit id="647ff2c6b0ee66be47ceb0fe277c3fe135fc84e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is not set, GCC attempts to figure out an appropriate prefix to use based on the pathname it is invoked with.</source>
          <target state="translated">&lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; が設定されていない場合、GCCは、呼び出されるパス名に基づいて、使用する適切なプレフィックスを見つけようとします。</target>
        </trans-unit>
        <trans-unit id="7fc3d06e6177481bf26c022c74076e71f4e1f421" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is set, it specifies a prefix to use in the names of the subprograms executed by the compiler. No slash is added when this prefix is combined with the name of a subprogram, but you can specify a prefix that ends with a slash if you wish.</source>
          <target state="translated">場合 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; が設定されている、それはコンパイラによって実行されるサブプログラムの名前に使用する接頭辞を指定します。この接頭辞がサブプログラムの名前と組み合わされている場合、スラッシュは追加されませんが、必要に応じてスラッシュで終わる接頭辞を指定できます。</target>
        </trans-unit>
        <trans-unit id="dec8a7933acf37b1c0fdc778b779b3f382d54a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LANG&lt;/code&gt; is not defined, or if it has some other value, then the compiler uses &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbtowc&lt;/code&gt; as defined by the default locale to recognize and translate multibyte characters.</source>
          <target state="translated">&lt;code&gt;LANG&lt;/code&gt; が定義されていない場合、または他の値がある場合、コンパイラーはデフォルトのロケールで定義されている &lt;code&gt;mblen&lt;/code&gt; および &lt;code&gt;mbtowc&lt;/code&gt; を使用して、マルチバイト文字を認識および変換します。</target>
        </trans-unit>
        <trans-unit id="e1943099aece965452d744a5c53ffc07f2bc9f16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;X&lt;/code&gt;; else if &lt;code&gt;T&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;Y&lt;/code&gt;; else substitutes &lt;code&gt;D&lt;/code&gt;. There can be as many clauses as you need. This may be combined with &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;*&lt;/code&gt; as needed.</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; がGCCに与えられた場合、 &lt;code&gt;X&lt;/code&gt; を置き換えます。それ以外の場合、 &lt;code&gt;T&lt;/code&gt; がGCCに与えられると、 &lt;code&gt;Y&lt;/code&gt; に置き換えられます。それ以外の場合は &lt;code&gt;D&lt;/code&gt; に置き換えます。必要な数の句を含めることができます。これはと組み合わせることができます &lt;code&gt;.&lt;/code&gt; 、 &lt;code&gt;,&lt;/code&gt; 、 &lt;code&gt;!&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、および必要に応じて &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="404ec67951a627fb06995708ad6a0e24dc041fa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TMPDIR&lt;/code&gt; is set, it specifies the directory to use for temporary files. GCC uses temporary files to hold the output of one stage of compilation which is to be used as input to the next stage: for example, the output of the preprocessor, which is the input to the compiler proper.</source>
          <target state="translated">&lt;code&gt;TMPDIR&lt;/code&gt; が設定されている場合は、一時ファイルに使用するディレクトリを指定します。GCCは、一時ファイルを使用して、次のステージへの入力として使用されるコンパイルの1つのステージの出力を保持します。たとえば、適切なコンパイラへの入力であるプリプロセッサの出力。</target>
        </trans-unit>
        <trans-unit id="1953caa75083ee28850ca171a34b26fd4eb8373f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a default constructor that is known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; その後、特色があり &lt;code&gt;true&lt;/code&gt; 場合は、他の &lt;code&gt;type&lt;/code&gt; 例外をスローしないことが知られているデフォルトのコンストラクタを持つCVクラスまたは共用タイプ（またはその配列）は、その後形質があるある &lt;code&gt;true&lt;/code&gt; 他にそれは、 &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="763c1f95adec0e6f2c3d89c3c9b77ea1bcae352d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy constructors that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; その後、形質がある &lt;code&gt;true&lt;/code&gt; 場合、他の &lt;code&gt;type&lt;/code&gt; 例外をスローしないことが知られているコピーコンストラクタとCV-修飾クラスまたは共用タイプで、その後形質はある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="348b274e4746ccb17d0ad8ccc31192a6601178b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_class (type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is considered empty if and only if: &lt;code&gt;type&lt;/code&gt; has no non-static data members, or all non-static data members, if any, are bit-fields of length 0, and &lt;code&gt;type&lt;/code&gt; has no virtual members, and &lt;code&gt;type&lt;/code&gt; has no virtual base classes, and &lt;code&gt;type&lt;/code&gt; has no base classes &lt;code&gt;base_type&lt;/code&gt; for which &lt;code&gt;__is_empty (base_type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__is_class (type)&lt;/code&gt; あり &lt;code&gt;false&lt;/code&gt; その後、形質はある &lt;code&gt;false&lt;/code&gt; 。さもなければ &lt;code&gt;type&lt;/code&gt; 場合にのみ空と考えられる： &lt;code&gt;type&lt;/code&gt; 全く非静的データメンバー、またはすべての非静的データメンバ、もしあれば、ある長さ0のビットフィールドを有していない、及び &lt;code&gt;type&lt;/code&gt; 何の仮想メンバーを持っていない、及び &lt;code&gt;type&lt;/code&gt; 何仮想がありません基本クラス、および &lt;code&gt;type&lt;/code&gt; には、 &lt;code&gt;__is_empty (base_type)&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; である基本クラス &lt;code&gt;base_type&lt;/code&gt; がありません。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3fb256b452a67db2fcf29b7d6c9eb3c3b57425ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a trivial destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__is_pod (type)&lt;/code&gt; である &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;type&lt;/code&gt; 参照型であり、次いで形質が &lt;code&gt;true&lt;/code&gt; ならば、他の &lt;code&gt;type&lt;/code&gt; 些細なデストラクタ（[class.dtor]）とCVクラスまたは共用タイプ（またはその配列）であり、次いで形質である &lt;code&gt;true&lt;/code&gt; それ以外の場合は &lt;code&gt;false&lt;/code&gt; です。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d1bf9587539b51be90adc4a1e785e99e947f0059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type with a trivial copy constructor ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__is_pod (type)&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;type&lt;/code&gt; 参照型であるその後、形質がある &lt;code&gt;true&lt;/code&gt; 場合、他の &lt;code&gt;type&lt;/code&gt; 些細なコピーコンストラクタ（[class.copy]）とCVクラスまたは共用タイプで、その後形質はある &lt;code&gt;true&lt;/code&gt; 、そうでなければです &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="2f38bb6a2ade7b8693787a1194261c7451943ac5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type (or array thereof) with a trivial default constructor ([class.ctor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合 &lt;code&gt;__is_pod (type)&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; その後、特色があり &lt;code&gt;true&lt;/code&gt; 場合は、他の &lt;code&gt;type&lt;/code&gt; CV-資格の些細なデフォルトコンストラクタを持つクラスまたは共用タイプ（またはその配列）（[class.ctor]）を形質があるある &lt;code&gt;true&lt;/code&gt; 、それは他の、は &lt;code&gt;false&lt;/code&gt; です。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d19955ce7ffa6060ce61b406573fd7fa063dda62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base_type&lt;/code&gt; is a base class of &lt;code&gt;derived_type&lt;/code&gt; ([class.derived]) then the trait is &lt;code&gt;true&lt;/code&gt;, otherwise it is &lt;code&gt;false&lt;/code&gt;. Top-level cv-qualifications of &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are ignored. For the purposes of this trait, a class type is considered is own base. Requires: if &lt;code&gt;__is_class (base_type)&lt;/code&gt; and &lt;code&gt;__is_class (derived_type)&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are not the same type (disregarding cv-qualifiers), &lt;code&gt;derived_type&lt;/code&gt; shall be a complete type. A diagnostic is produced if this requirement is not met.</source>
          <target state="translated">&lt;code&gt;base_type&lt;/code&gt; が &lt;code&gt;derived_type&lt;/code&gt; （[class.derived]）の基本クラスである場合、特性は &lt;code&gt;true&lt;/code&gt; で、それ以外の場合は &lt;code&gt;false&lt;/code&gt; です。 &lt;code&gt;base_type&lt;/code&gt; および &lt;code&gt;derived_type&lt;/code&gt; の最上位のcv修飾は無視されます。この特性の目的のために、クラス型は独自のベースと見なされます。 &lt;code&gt;__is_class (base_type)&lt;/code&gt; ：__is_class（base_type）および &lt;code&gt;__is_class (derived_type)&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; で、 &lt;code&gt;base_type&lt;/code&gt; と &lt;code&gt;derived_type&lt;/code&gt; が同じタイプでない場合（cv-qualifiersを無視して）、 &lt;code&gt;derived_type&lt;/code&gt; は完全なタイプになります。この要件が満たされない場合、診断が生成されます。</target>
        </trans-unit>
        <trans-unit id="9ad52c7e701f6b6ac16fc011e5c3a814b836cace" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;objc_msg_lookup()&lt;/code&gt; does not find a suitable method implementation, because the receiver does not implement the required method, it tries to see if the class can dynamically register the method.</source>
          <target state="translated">&lt;code&gt;objc_msg_lookup()&lt;/code&gt; が適切なメソッド実装を見つけられない場合、レシーバは必要なメソッドを実装していないため、クラスがメソッドを動的に登録できるかどうかを確認しようとします。</target>
        </trans-unit>
        <trans-unit id="de0324724a4ecec17009f5551872ea4de764d9cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;packed&lt;/code&gt; is used on a structure, or if bit-fields are used, it may be that the Microsoft ABI lays out the structure differently than the way GCC normally does. Particularly when moving packed data between functions compiled with GCC and the native Microsoft compiler (either via function call or as data in a file), it may be necessary to access either format.</source>
          <target state="translated">場合は &lt;code&gt;packed&lt;/code&gt; 構造で使用されているビットフィールドが使用されている場合、あるいは、それはマイクロソフトABIは、GCCが通常行う方法とは異なる構造をレイアウトすることかもしれません。特に、GCCでコンパイルされた関数とネイティブのMicrosoftコンパイラー間で（関数呼び出しを介して、またはファイル内のデータとして）パックされたデータを移動する場合、いずれかの形式にアクセスする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="6f7ba7dbf5e57d92bfe72102ff6203af39a12a8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; is omitted, the signedness of the vector type is the default signedness of the base type. The default varies depending on the operating system, so a portable program should always specify the signedness.</source>
          <target state="translated">&lt;code&gt;unsigned&lt;/code&gt; &lt;code&gt;signed&lt;/code&gt; または符号なしが省略された場合、ベクトル型の符号付きは、基本型のデフォルトの符号付きです。デフォルトはオペレーティングシステムによって異なるため、移植性のあるプログラムは常に署名を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="ffd246c0a3fbb949c1fa9d8cc2260944e77a3bfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;- qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with a trivial copy assignment ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; ある &lt;code&gt;const&lt;/code&gt; -修飾または参照型で、その後特性がある &lt;code&gt;false&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;__is_pod (type)&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、特性は &lt;code&gt;true&lt;/code&gt; です。それ以外の場合、 &lt;code&gt;type&lt;/code&gt; がcv修飾クラスまたは共用コピー割り当て（[class.copy]）の共用体タイプの場合、特性は &lt;code&gt;true&lt;/code&gt; で、それ以外の場合は &lt;code&gt;false&lt;/code&gt; です。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="283cf2672e55770fc0551d9647cca120a4bb630b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;-qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy assignment operators that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; ある &lt;code&gt;const&lt;/code&gt; -qualifiedまたは参照型で、その後特性がある &lt;code&gt;false&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、特性は &lt;code&gt;true&lt;/code&gt; です。それ以外の場合、 &lt;code&gt;type&lt;/code&gt; が例外をスローしないことがわかっているコピー代入演算子を持つcv修飾クラスまたは共用体タイプの場合、特性は &lt;code&gt;true&lt;/code&gt; で、それ以外の場合は &lt;code&gt;false&lt;/code&gt; です。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（場合によってはcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または不明な境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="63c11c8bb0212d553ee20398c564d16b6ec7e69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a class type with a virtual destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; 仮想デストラクタ（[class.dtor]）を持つクラス型で、その後特色がある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3c2e0cd65d0655c5ce8c12d2d2d4a097d810e389" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv POD type ([basic.types]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; CV PODタイプ（[basic.types]）で、その後形質はある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="723863e0b5a8fce8c661ff18582b201e84983629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv enumeration type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; CVの列挙型（[basic.compound]）である特色がある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b7975a53cee041123902e4671962591f8c2cbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; CV組合のタイプ（[basic.compound]）である特色がある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89ab4b13f03f8e9b77ccbec6378e569d290932f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv-qualified class type, and not a union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; CV修飾クラスタイプではなく、労働組合のタイプ（[basic.compound]）である特色がある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c08c113aac15208c2698077a3dc6d2ee08e364" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a literal type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; リテラルのタイプ（[basic.types]）形質があるある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="44c42d9c3a648a4586d6d80ed2afeb43acc1f98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a polymorphic class ([class.virtual]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; 多型クラスである（[class.virtual]）、その後特色があり &lt;code&gt;true&lt;/code&gt; 他のそれは、 &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="902c4582059f6f78c8c47e8d4db16bfd414011e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a standard-layout type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; 標準レイアウトタイプ（[basic.types]）である特色がある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c53c71f1f92604372ad3a40e885b3e290ad04715" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a trivial type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; 些細なタイプ（[basic.types]）形質があるある &lt;code&gt;true&lt;/code&gt; 、そうでなければある &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="ffe6e21bc41957ab0a00219c12663528f239f642" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an abstract class ([class.abstract]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">場合は &lt;code&gt;type&lt;/code&gt; 抽象クラスである（[class.abstract]）、その後特色があり &lt;code&gt;true&lt;/code&gt; 他のそれは、 &lt;code&gt;false&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は完全なタイプ、（おそらくcvで修飾された） &lt;code&gt;void&lt;/code&gt; 、または未知の境界の配列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="911911ebb73f24baa4568a362dcf6545a5e8bd9f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;X&lt;/var&gt; is &lt;code&gt;0xf&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th bit of &lt;var&gt;val&lt;/var&gt; is returned unaltered.</source>
          <target state="translated">場合 &lt;var&gt;X&lt;/var&gt; がある &lt;code&gt;0xf&lt;/code&gt; 場合、 &lt;var&gt;n&lt;/var&gt; 番目のビット &lt;var&gt;val&lt;/var&gt; が不変戻されます。</target>
        </trans-unit>
        <trans-unit id="529d14d76239ac927a58af9240682db818e156fc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;desired&lt;/var&gt; is written into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; then &lt;code&gt;true&lt;/code&gt; is returned and memory is affected according to the memory order specified by &lt;var&gt;success_memorder&lt;/var&gt;. There are no restrictions on what memory order can be used here.</source>
          <target state="translated">場合 &lt;var&gt;desired&lt;/var&gt; に書き込まれる &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 次に &lt;code&gt;true&lt;/code&gt; 返され、メモリは、で指定されたメモリ順序に従って影響さ &lt;var&gt;success_memorder&lt;/var&gt; 。ここで使用できるメモリ順序に制限はありません。</target>
        </trans-unit>
        <trans-unit id="90eefc597dfd05335fdc76d585991dd479f5699e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;device&lt;/var&gt; is not a device but only a core architecture like &amp;lsquo;</source>
          <target state="translated">場合は &lt;var&gt;device&lt;/var&gt; 、デバイスが、 'のような唯一のコアアーキテクチャではありません</target>
        </trans-unit>
        <trans-unit id="37aede7b841b819868fc3f607fc7588d32233439" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;exp1&lt;/var&gt; is returned, the return type is the same as &lt;var&gt;exp1&lt;/var&gt;&amp;rsquo;s type. Similarly, if &lt;var&gt;exp2&lt;/var&gt; is returned, its return type is the same as &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">場合 &lt;var&gt;exp1&lt;/var&gt; 返され、戻り値の型は同じである &lt;var&gt;exp1&lt;/var&gt; のタイプ。同様に、 &lt;var&gt;exp2&lt;/var&gt; が返される場合、その戻り型は &lt;var&gt;exp2&lt;/var&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="43726f9389a16cd86ccc87693856924d076a1cd7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file&lt;/var&gt; is</source>
          <target state="translated">場合 &lt;var&gt;file&lt;/var&gt; あります</target>
        </trans-unit>
        <trans-unit id="5b94a494d8a93062d1fb2f08cf22419880d46ae7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;m&lt;/var&gt; is not specified, it defaults to &lt;var&gt;n&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;m&lt;/var&gt; を指定しない場合、デフォルトで &lt;var&gt;n&lt;/var&gt; になります。</target>
        </trans-unit>
        <trans-unit id="96e30c03c390fa37f95beff815a87bdc5f2296a9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default which is very likely to be &amp;lsquo;</source>
          <target state="translated">場合 &lt;var&gt;n&lt;/var&gt; は指定された、またはゼロではないが、「非常にそうするマシン依存のデフォルトを使用</target>
        </trans-unit>
        <trans-unit id="4f4c9abfe6823ac3226b1f95cfb68ae207a767d4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default.</source>
          <target state="translated">場合は &lt;var&gt;n&lt;/var&gt; を指定するか、またはゼロではないが、マシン依存のデフォルトを使用します。</target>
        </trans-unit>
        <trans-unit id="edea744d98224ea825d53a93f917e0198d6b4e4e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default. The maximum allowed &lt;var&gt;n&lt;/var&gt; option value is 65536.</source>
          <target state="translated">場合は &lt;var&gt;n&lt;/var&gt; を指定するか、またはゼロではないが、マシン依存のデフォルトを使用します。許可される &lt;var&gt;n&lt;/var&gt; オプションの最大値は65536です。</target>
        </trans-unit>
        <trans-unit id="759dfcc7101124f098c766f1c7cd00bcc6b949db" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;options&lt;/var&gt; is omitted, it defaults to &amp;lsquo;</source>
          <target state="translated">場合は &lt;var&gt;options&lt;/var&gt; 省略され、デフォルトでは'と</target>
        </trans-unit>
        <trans-unit id="4a58d0d422304ea0f155ce08523224eb514fe6b5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;path&lt;/var&gt; is specified, GCC looks at the &lt;var&gt;path&lt;/var&gt; to find the profile feedback data files. See</source>
          <target state="translated">&lt;var&gt;path&lt;/var&gt; が指定されている場合、GCCは &lt;var&gt;path&lt;/var&gt; を調べて、プロファイルフィードバックデータファイルを見つけます。見る</target>
        </trans-unit>
        <trans-unit id="424b9b0e5144f1c216be7ac998c97fd4f7a0b3fa" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;type&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;type&lt;/var&gt; が 'の場合</target>
        </trans-unit>
        <trans-unit id="a48f8bd6ddf94d7b46204690dc61b7e1c17bca21" translate="yes" xml:space="preserve">
          <source>If GCC cannot find the subprogram using the specified prefix, it tries looking in the usual places for the subprogram.</source>
          <target state="translated">指定された接頭辞を使ってサブプログラムが見つからない場合、GCCはサブプログラムの通常の場所を探してみます。</target>
        </trans-unit>
        <trans-unit id="49e516aa2892d9e488e19e4de501aef3c975c28a" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_is&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">GCCが2.23より前のGLIBCを使用するように構成されている場合、組み込み関数 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; は常に0を返し、コンパイラーは警告を発行します。</target>
        </trans-unit>
        <trans-unit id="009bc2728024c27e5f3a38c77a771a92e70da809" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">GCCが2.23より前のGLIBCを使用するように構成されている場合、組み込み関数 &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; は常に0を返し、コンパイラーは警告を発行します。</target>
        </trans-unit>
        <trans-unit id="3d3dbe293db43d1939fa63d41a62ea0fb70dc054" translate="yes" xml:space="preserve">
          <source>If LTO encounters objects with C linkage declared with incompatible types in separate translation units to be linked together (undefined behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be issued. The behavior is still undefined at run time. Similar diagnostics may be raised for other languages.</source>
          <target state="translated">LTOが、互換性のない型で宣言されたCリンクを持つオブジェクトを、別々の翻訳単位でリンクさせるために遭遇した場合(ISO C99 6.2.7に従った未定義の動作)、非致命的な診断が発行される可能性があります。実行時の動作は未定義のままです。他の言語でも同様の診断が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8064195381cae5ba1afd9e1080f901756518ee59" translate="yes" xml:space="preserve">
          <source>If SSE extensions are enabled, &lt;code&gt;V4SF&lt;/code&gt; is used for a vector of four 32-bit floating-point values. Some instructions use a vector of four 32-bit integers, these use &lt;code&gt;V4SI&lt;/code&gt;. Finally, some instructions operate on an entire vector register, interpreting it as a 128-bit integer, these use mode &lt;code&gt;TI&lt;/code&gt;.</source>
          <target state="translated">SSE拡張が有効な場合、 &lt;code&gt;V4SF&lt;/code&gt; は4つの32ビット浮動小数点値のベクトルに使用されます。一部の命令は4つの32ビット整数のベクトルを使用し、これらは &lt;code&gt;V4SI&lt;/code&gt; を使用します。最後に、一部の命令はベクトルレジスタ全体を操作し、それを128ビット整数として解釈します。これらはモード &lt;code&gt;TI&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c8aa3d549316941fe06d6dfd92787397e613a82c" translate="yes" xml:space="preserve">
          <source>If X is in the range 0&amp;hellip;7, then the &lt;var&gt;n&lt;/var&gt;-th result bit is set to the &lt;var&gt;X&lt;/var&gt;-th bit of &lt;var&gt;bits&lt;/var&gt;</source>
          <target state="translated">Xが0〜7の範囲にある場合、 &lt;var&gt;n&lt;/var&gt; 番目の結果ビットはビットの &lt;var&gt;X&lt;/var&gt; 番目のビットに設定され &lt;var&gt;bits&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4795ba768ec1950f8dcd780b40f59791bb2c3400" translate="yes" xml:space="preserve">
          <source>If X is in the range 8&amp;hellip;&lt;code&gt;0xe&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th result bit is undefined.</source>
          <target state="translated">Xが8&amp;hellip; &lt;code&gt;0xe&lt;/code&gt; の範囲にある場合、 &lt;var&gt;n&lt;/var&gt; 番目の結果ビットは未定義です。</target>
        </trans-unit>
        <trans-unit id="77a0a28430753763f9053f0aed3455f25006e137" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;named address space&lt;/a&gt; other than generic or &lt;code&gt;__flash&lt;/code&gt; is used, then &lt;code&gt;RAMPZ&lt;/code&gt; is set as needed before the operation.</source>
          <target state="translated">場合&lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;という名前のアドレス空間&lt;/a&gt;ジェネリックまたは以外の &lt;code&gt;__flash&lt;/code&gt; が使用され、その後、 &lt;code&gt;RAMPZ&lt;/code&gt; を操作する前に、必要に応じて設定されています。</target>
        </trans-unit>
        <trans-unit id="e78a838d8422ed3d9e1991db7c391d81f3fd283d" translate="yes" xml:space="preserve">
          <source>If a class is declared to implement a protocol, a warning is issued for every method in the protocol that is not implemented by the class. The default behavior is to issue a warning for every method not explicitly implemented in the class, even if a method implementation is inherited from the superclass. If you use the</source>
          <target state="translated">クラスがプロトコルを実装すると宣言されている場合、そのクラスで実装されていないプロトコルの各メソッドに対して警告が発行されます。デフォルトの動作は、メソッドの実装がスーパークラスから継承されている場合でも、クラスで明示的に実装されていないすべてのメソッドに対して警告を発行することです。もし</target>
        </trans-unit>
        <trans-unit id="29f23802437b44fdcdb64561f47637459cfd3577" translate="yes" xml:space="preserve">
          <source>If a diagnostic contains fix-it hints, it has a &lt;code&gt;fixits&lt;/code&gt; array, consisting of half-open intervals, similar to the output of</source>
          <target state="translated">診断に修正のヒントが含まれている場合、診断の出力と同様に、ハーフオープン間隔で構成される &lt;code&gt;fixits&lt;/code&gt; 配列があります。</target>
        </trans-unit>
        <trans-unit id="e94ab481666483b349181850cc8e39b26f438c5d" translate="yes" xml:space="preserve">
          <source>If a function returns a temporary &lt;code&gt;initializer_list&lt;/code&gt;, or a local &lt;code&gt;initializer_list&lt;/code&gt; variable, the array&amp;rsquo;s lifetime ends at the end of the return statement, so the value returned has a dangling pointer.</source>
          <target state="translated">関数が一時的な &lt;code&gt;initializer_list&lt;/code&gt; またはローカルの &lt;code&gt;initializer_list&lt;/code&gt; 変数を返す場合、配列の有効期間はreturnステートメントの終わりで終了するため、返される値にはぶら下がりポインタが含まれます。</target>
        </trans-unit>
        <trans-unit id="51be4d38853f3a30d7f15e3610ea69ae54265c4e" translate="yes" xml:space="preserve">
          <source>If a loop iterates over an array with a variable stride, create another version of the loop that assumes the stride is always one. For example:</source>
          <target state="translated">ループが変数ストライドを持つ配列を反復処理する場合,ストライドが常に1であると仮定した別のバージョンのループを作成します.例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e603935699eb5e105e69e65a9021ca2022ac4213" translate="yes" xml:space="preserve">
          <source>If a new-expression creates an &lt;code&gt;initializer_list&lt;/code&gt;, the array only lives until the end of the enclosing full-expression, so the &lt;code&gt;initializer_list&lt;/code&gt; in the heap has a dangling pointer.</source>
          <target state="translated">new-expressionが &lt;code&gt;initializer_list&lt;/code&gt; を作成する場合、配列はそれを囲む完全式の最後までしか存在しないため、ヒープ内の &lt;code&gt;initializer_list&lt;/code&gt; にはぶら下がりポインタがあります。</target>
        </trans-unit>
        <trans-unit id="dcc181452125b891816dee9715c4c073b739c819" translate="yes" xml:space="preserve">
          <source>If a program must use a different C++ library and it&amp;rsquo;s not possible to do the final link using a C++ driver that uses that library by default, it is necessary to tell &lt;code&gt;g++&lt;/code&gt; the location and name of that library. It might also be necessary to specify different startup files and other runtime support libraries, and to suppress the use of GCC&amp;rsquo;s support libraries with one or more of the options</source>
          <target state="translated">プログラムが別のC ++ライブラリを使用する必要があり、デフォルトでそのライブラリを使用するC ++ドライバーを使用して最終的なリンクを実行できない場合は、 &lt;code&gt;g++&lt;/code&gt; にそのライブラリの場所と名前を通知する必要があります。また、異なるスタートアップファイルやその他のランタイムサポートライブラリを指定し、1つ以上のオプションでGCCのサポートライブラリの使用を抑制する必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="e84c4785b4be9bc72195941ed1f8c2b45255457e" translate="yes" xml:space="preserve">
          <source>If a standard system include directory, or a directory specified with</source>
          <target state="translated">標準システムのインクルードディレクトリ、または</target>
        </trans-unit>
        <trans-unit id="5c3be2ab717ecd782733ce9b93456fcb31fc4af7" translate="yes" xml:space="preserve">
          <source>If a variable has the &lt;code&gt;below100&lt;/code&gt; attribute (&lt;code&gt;BELOW100&lt;/code&gt; is allowed also), GCC places the variable in the first 0x100 bytes of memory and use special opcodes to access it. Such variables are placed in either the &lt;code&gt;.bss_below100&lt;/code&gt; section or the &lt;code&gt;.data_below100&lt;/code&gt; section.</source>
          <target state="translated">変数が &lt;code&gt;below100&lt;/code&gt; 属性を持つ場合（ &lt;code&gt;BELOW100&lt;/code&gt; も許可されます）、GCCは変数をメモリの最初の0x100バイトに配置し、特別なオペコードを使用してアクセスします。そのような変数は、いずれかに配置され &lt;code&gt;.bss_below100&lt;/code&gt; 部又は &lt;code&gt;.data_below100&lt;/code&gt; セクション。</target>
        </trans-unit>
        <trans-unit id="38c3454c59e77e91336081ab769819e7fd53ba65" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field follows a normal bit-field, the type of the zero-length bit-field may affect the alignment of the structure as whole. For example, &lt;code&gt;t2&lt;/code&gt; has a size of 4 bytes, since the zero-length bit-field follows a normal bit-field, and is of type short.</source>
          <target state="translated">長さ0のビットフィールドが通常のビットフィールドの後に続く場合、長さ0のビットフィールドのタイプが構造全体の配置に影響を与える可能性があります。たとえば、 &lt;code&gt;t2&lt;/code&gt; のサイズは4バイトです。これは、長さがゼロのビットフィールドが通常のビットフィールドの後にあり、shortタイプであるためです。</target>
        </trans-unit>
        <trans-unit id="3930dc0fc00c26bd7cfbb87588dd5cf1e2064acf" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted after a bit-field, &lt;code&gt;foo&lt;/code&gt;, and the alignment of the zero-length bit-field is greater than the member that follows it, &lt;code&gt;bar&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is aligned as the type of the zero-length bit-field.</source>
          <target state="translated">長さ0のビットフィールドがビットフィールド &lt;code&gt;foo&lt;/code&gt; の後に挿入され、長さ0のビットフィールドのアラインメントがそれに続くメンバー &lt;code&gt;bar&lt;/code&gt; より大きい場合、 &lt;code&gt;bar&lt;/code&gt; は、ゼロのタイプとしてアラインされます。長さビットフィールド。</target>
        </trans-unit>
        <trans-unit id="487b9fa86178ee0fe71d79bf284c4ff7466101a0" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted between two bit-fields that are normally coalesced, the bit-fields are not coalesced.</source>
          <target state="translated">通常は合体している2つのビットフィールドの間に長さ0のビットフィールドが挿入された場合、そのビットフィールドは合体しません。</target>
        </trans-unit>
        <trans-unit id="fce50e2e3a2f90483694041f1d50957c036fd376" translate="yes" xml:space="preserve">
          <source>If accessing any memory location is potentially unsafe when speculative execution is incorrect, then the code can be rewritten as</source>
          <target state="translated">投機的な実行が正しくない場合に、任意のメモリ位置へのアクセスが安全でない可能性がある場合は、コードを次のように書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="19dee42123d1606545b47bdc1aee4dced42d70ef" translate="yes" xml:space="preserve">
          <source>If all calls to a given function are integrated, and the function is declared &lt;code&gt;static&lt;/code&gt;, then the function is normally not output as assembler code in its own right.</source>
          <target state="translated">特定の関数へのすべての呼び出しが統合されており、その関数が &lt;code&gt;static&lt;/code&gt; と宣言されている場合、通常、関数自体はアセンブラーコードとして出力されません。</target>
        </trans-unit>
        <trans-unit id="6747ee18a18040e35fcb4f80dbfe422de83e0b1d" translate="yes" xml:space="preserve">
          <source>If an explicit version number is provided and</source>
          <target state="translated">明示的なバージョン番号が提供され</target>
        </trans-unit>
        <trans-unit id="2a42f93a55377bd2fb4570f085c309d8859bae77" translate="yes" xml:space="preserve">
          <source>If an instruction only takes Altivec registers, you do not want to use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">命令がAltivecレジスタのみを取得する場合、 &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; を使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="364981cd1f151ee605ed86bfcc1747b52ebe7a19" translate="yes" xml:space="preserve">
          <source>If any of</source>
          <target state="translated">のいずれかであれば</target>
        </trans-unit>
        <trans-unit id="d4335275a2f1edfde414bbe1e986ac43ea3a56a9" translate="yes" xml:space="preserve">
          <source>If any of the enabled test conditions is true, the corresponding entry in the result vector is -1. Otherwise (all of the enabled test conditions are false), the corresponding entry of the result vector is 0.</source>
          <target state="translated">有効なテスト条件のいずれかが真であれば、結果ベクトルの対応するエントリは-1です。それ以外の場合(有効なテスト条件がすべて偽)、結果ベクトルの対応するエントリは 0 です。</target>
        </trans-unit>
        <trans-unit id="b0cb0b3f3853386544ffbd0fa1ea4935f0522535" translate="yes" xml:space="preserve">
          <source>If any of these options is used, then the linker is not run, and object file names should not be used as arguments. See &lt;a href=&quot;overall-options#Overall-Options&quot;&gt;Overall Options&lt;/a&gt;.</source>
          <target state="translated">これらのオプションのいずれかが使用されている場合、リンカーは実行されず、オブジェクトファイル名を引数として使用しないでください。&lt;a href=&quot;overall-options#Overall-Options&quot;&gt;全体的なオプションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="66bff0fe442c04caa45d8e4b29fa05e61e69952b" translate="yes" xml:space="preserve">
          <source>If application code relies on copy-assignment, a user-defined copy-assignment operator removes any uncertainties. With such an operator, the application can define whether and how the virtual base subobject is assigned.</source>
          <target state="translated">アプリケーションコードがコピー割り当てに依存している場合、ユーザー定義のコピー割り当て演算子は不確実性を取り除きます。このような演算子を使用すると、アプリケーションは仮想ベースサブオブジェクトがどのように割り当てられるかを定義することができます。</target>
        </trans-unit>
        <trans-unit id="3e6fe2d65d6ae8e8dddd4d9d96db3ba491946874" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;interrupt&lt;/code&gt; are specified for the same function, &lt;code&gt;signal&lt;/code&gt; is silently ignored.</source>
          <target state="translated">同じ関数に &lt;code&gt;signal&lt;/code&gt; と &lt;code&gt;interrupt&lt;/code&gt; 両方が指定されている場合、 &lt;code&gt;signal&lt;/code&gt; は無視されます。</target>
        </trans-unit>
        <trans-unit id="9edaf55b500443b684dd1328cbcf6a8752769f40" translate="yes" xml:space="preserve">
          <source>If both arguments are zero, hotpatching is disabled.</source>
          <target state="translated">両方の引数がゼロの場合、ホットパッチは無効になります。</target>
        </trans-unit>
        <trans-unit id="32b3bc364441ca8a7ce5db371cd86527cc2b0b55" translate="yes" xml:space="preserve">
          <source>If both the template and enclosing class have explicit visibility, the visibility from the template is used.</source>
          <target state="translated">テンプレートと囲い込みクラスの両方が明示的に可視化されている場合は、テンプレートからの可視化が使用されます。</target>
        </trans-unit>
        <trans-unit id="02529d20c3d2e23aefd28ee9dcdbc7281d16eb72" translate="yes" xml:space="preserve">
          <source>If combined with</source>
          <target state="translated">と組み合わせた場合</target>
        </trans-unit>
        <trans-unit id="af3104b1407804a82ad43f4fa2a84131be37f920" translate="yes" xml:space="preserve">
          <source>If control flow reaches the point of the &lt;code&gt;__builtin_unreachable&lt;/code&gt;, the program is undefined. It is useful in situations where the compiler cannot deduce the unreachability of the code.</source>
          <target state="translated">制御フローが &lt;code&gt;__builtin_unreachable&lt;/code&gt; のポイントに達すると、プログラムは未定義になります。これは、コンパイラーがコードの到達不能性を推定できない場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="36b8c90f4b777d0cb2020f4d21e6ac15532c3ad9" translate="yes" xml:space="preserve">
          <source>If debugging information is output when using the precompiled header, using</source>
          <target state="translated">プリコンパイルされたヘッダを使用しているときにデバッグ情報が出力される場合は</target>
        </trans-unit>
        <trans-unit id="402b191a6d5b620de512d8843ce1f34d7777a814" translate="yes" xml:space="preserve">
          <source>If either of the ways of changing the assembly name of a declaration are applied to a declaration whose assembly name has already been determined (either by a previous use of one of these features, or because the compiler needed the assembly name in order to generate code), and the new name is different, a warning issues and the name does not change.</source>
          <target state="translated">宣言のアセンブリ名を変更する方法のいずれかが、アセンブリ名がすでに決定されている宣言に適用された場合(これらの機能のいずれかを以前に使用していたか、またはコードを生成するためにコンパイラがアセンブリ名を必要としていたため)、新しい名前が異なる場合、警告が表示され、名前は変更されません。</target>
        </trans-unit>
        <trans-unit id="8e6cf380114ced6b961e13544b6be03dfc3354e5" translate="yes" xml:space="preserve">
          <source>If enabled, control-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the control speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">有効にすると、現時点で他に選択肢がない場合にのみ、制御投機的な指示がスケジュールに選択されます。これにより、制御仕様の使用がより保守的になります。デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="c9aeee8753743f519ff715357d9285071a0d9d86" translate="yes" xml:space="preserve">
          <source>If enabled, data-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the data speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">有効にすると、現時点で他に選択肢がない場合にのみ、スケジュールのためにデータ投機的な命令が選択されます。これにより、データスペキュレーションの使用がより保守的になります。デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="12c5281bb30137f5a28029f336bddc2453ae8835" translate="yes" xml:space="preserve">
          <source>If enabled, speculative dependencies are considered during computation of the instructions priorities. This makes the use of the speculation a bit more conservative. The default setting is disabled.</source>
          <target state="translated">有効にすると、命令の優先度の計算中に投機的な依存関係が考慮されます。これにより、投機の使用が少し保守的になります。デフォルトの設定は無効です。</target>
        </trans-unit>
        <trans-unit id="9d63d7ff73f8a910b7cb613706af4cc8bb2d95b9" translate="yes" xml:space="preserve">
          <source>If enabled, the maximum amount of space required for outgoing arguments is computed in the function prologue. This is faster on most modern CPUs because of reduced dependencies, improved scheduling and reduced stack usage when the preferred stack boundary is not equal to 2. The drawback is a notable increase in code size. This switch implies</source>
          <target state="translated">この機能を有効にした場合、送信引数に必要なスペースの最大量が関数プロローグで計算されます。これは、依存性の低減、スケジューリングの改善、優先スタック境界が2と等しくない場合のスタック使用量の削減のため、ほとんどの最新のCPUで高速化されます。 欠点は、コードサイズの顕著な増加です。このスイッチは</target>
        </trans-unit>
        <trans-unit id="40d23331ec805b8693bd0e7ed41af8f41bbbeef4" translate="yes" xml:space="preserve">
          <source>If functions are defined in one file and are called in another file, then be sure to write this declaration in both files.</source>
          <target state="translated">関数があるファイルで定義されていて、別のファイルで呼び出される場合は、この宣言を両方のファイルに書くようにしてください。</target>
        </trans-unit>
        <trans-unit id="5a84ad9332942b0583d76324d55388fa827b1dc5" translate="yes" xml:space="preserve">
          <source>If it is a scalar type, or on most targets an aggregate type whose only member object is of a scalar type, or a union type whose member objects are of scalar types, the expression is interpreted by GCC as a read of the volatile object; in the other cases, the expression is only evaluated for its side effects.</source>
          <target state="translated">それがスカラ型である場合、あるいはほとんどのターゲットにおいて、唯一のメンバオブジェクトがスカラ型である集約型、あるいはメンバオブジェクトがスカラ型である組合わせ型である場合、式はGCCによって揮発性オブジェクトの読み取りとして解釈され、それ以外の場合、式はその副作用についてのみ評価されます。</target>
        </trans-unit>
        <trans-unit id="79c1054be8ddf1396d899393bbaa81764a2eed88" translate="yes" xml:space="preserve">
          <source>If multiple</source>
          <target state="translated">複数の場合</target>
        </trans-unit>
        <trans-unit id="e94921c7bd35daddf444608f5259a29f5f4c8cc8" translate="yes" xml:space="preserve">
          <source>If neither</source>
          <target state="translated">どちらも</target>
        </trans-unit>
        <trans-unit id="afb8c1ba0a7e5bf800f44e5494e9d700db801b00" translate="yes" xml:space="preserve">
          <source>If new system header files are installed, nothing automatically arranges to update the corrected header files. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">新しいシステムヘッダーファイルがインストールされている場合、修正されたヘッダーファイルを更新するための自動調整は行われません。にインストールされている &lt;code&gt;mkheaders&lt;/code&gt; スクリプトを使用して更新できます。</target>
        </trans-unit>
        <trans-unit id="b7def704de696eb922c5e5ba1f5217476d727ef7" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is defined in your code, the compiler will automatically replace &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; with &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt;, where that type is silently defined by the compiler in an identical way. This can be confusing and we recommend that you define &lt;code&gt;NSFastEnumerationState&lt;/code&gt; (as shown above) instead.</source>
          <target state="translated">コードで &lt;code&gt;NSFastEnumerationState&lt;/code&gt; が定義されていない場合、コンパイラーは &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; を &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt; に自動的に置き換えます。この場合、その型はコンパイラーによって同じ方法で暗黙的に定義されます。これは混乱を招く可能性があるため、 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; （上記を参照）を定義することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="089bb39031737c14c4b1a0b430296a1926daaea0" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;arg-index&lt;/var&gt; is given to the &lt;code&gt;nonnull&lt;/code&gt; attribute, all pointer arguments are marked as non-null. To illustrate, the following declaration is equivalent to the previous example:</source>
          <target state="translated">何場合は &lt;var&gt;arg-index&lt;/var&gt; に与えられていない &lt;code&gt;nonnull&lt;/code&gt; 属性、すべてのポインタ引数が非nullとしてマークされています。説明のために、次の宣言は前の例と同等です。</target>
        </trans-unit>
        <trans-unit id="73b44337d5bc4559e8e1c4b6db36d411b8aef133" translate="yes" xml:space="preserve">
          <source>If no error occurs during compilation, run the compiler a second time, adding &lt;var&gt;opts&lt;/var&gt; and</source>
          <target state="translated">コンパイル中にエラーが発生しない場合は、コンパイラを &lt;var&gt;opts&lt;/var&gt; 実行して、optsと</target>
        </trans-unit>
        <trans-unit id="0e662391588b3d6a0fd25b9abb8a35c922931e60" translate="yes" xml:space="preserve">
          <source>If no fixup is needed, this function simply passes through &lt;var&gt;addr&lt;/var&gt;.</source>
          <target state="translated">修正が必要ない場合、この関数は単に &lt;var&gt;addr&lt;/var&gt; を通過します。</target>
        </trans-unit>
        <trans-unit id="2c0304f8188faa2beb1f6913883824900b9fd415" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all calls might be beyond the offset range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, and therefore load the function address into a register before performing a (otherwise direct) call. This is the default.</source>
          <target state="translated">属性で特に指定されていない場合は、すべての呼び出しが &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; 命令のオフセット範囲を超えている可能性があるため、（そうでなければ直接）呼び出しを実行する前に関数アドレスをレジスターにロードします。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="4019c8219c3b5cd2dda4dbb0cb3bf4c2a485adff" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all direct calls are in the range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, so use these instructions for direct calls. The default is</source>
          <target state="translated">属性で特に指定されていない場合は、すべての直接呼び出しが &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; 命令の範囲内にあると想定するため、これらの命令を直接呼び出しに使用してください。デフォルトは</target>
        </trans-unit>
        <trans-unit id="12a28d9821da145a465f7298f6e4c4d208680d82" translate="yes" xml:space="preserve">
          <source>If number of memory accesses in function being instrumented is greater or equal to this number, use callbacks instead of inline checks. E.g. to disable inline code use</source>
          <target state="translated">計測している関数のメモリアクセス数がこの数以上の場合は、インラインチェックの代わりにコールバックを使用してください。例えば、インラインコードを無効にするには</target>
        </trans-unit>
        <trans-unit id="5104c1df665f6fc4dddeb5595f01af321de5cad6" translate="yes" xml:space="preserve">
          <source>If object files containing GIMPLE bytecode are stored in a library archive, say</source>
          <target state="translated">GIMPLE バイトコードを含むオブジェクトファイルがライブラリアーカイブに保存されている場合、 例えば</target>
        </trans-unit>
        <trans-unit id="1debeabea3e55864c791086673e07af5641e2395" translate="yes" xml:space="preserve">
          <source>If patchable function entries are enabled globally using the command-line option</source>
          <target state="translated">パッチ適用可能な関数エントリがコマンドラインオプション</target>
        </trans-unit>
        <trans-unit id="7ae6684dfcfa35ba16cecacd5ec92f0fb9e0c04e" translate="yes" xml:space="preserve">
          <source>If profiling is active (</source>
          <target state="translated">プロファイリングがアクティブな場合 (</target>
        </trans-unit>
        <trans-unit id="88f3c4dd1f2c3c978031ca46886480a0ad40a791" translate="yes" xml:space="preserve">
          <source>If supported by the target machine, generate instructions to prefetch memory to improve the performance of loops that access large arrays.</source>
          <target state="translated">ターゲットマシンがサポートしている場合、大規模な配列にアクセスするループのパフォーマンスを向上させるために、メモリをプリフェッチする命令を生成します。</target>
        </trans-unit>
        <trans-unit id="8bfe7e580871525d66e6234642f97096fcdef387" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to eliminate execution stalls due to required data being unavailable. This helps machines that have slow floating point or memory load instructions by allowing other instructions to be issued until the result of the load or floating-point instruction is required.</source>
          <target state="translated">ターゲットマシンでサポートされている場合は、必要なデータが利用できないことによる実行のストールをなくすために命令を並べ替えようとします。これは、ロード命令や浮動小数点命令の結果が要求されるまで他の命令を発行できるようにすることで、浮動小数点命令やメモリロード命令が遅いマシンを支援します。</target>
        </trans-unit>
        <trans-unit id="3428a2e4a1d11936eea0f07c36277bc2aa02d581" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to exploit instruction slots available after delayed branch instructions.</source>
          <target state="translated">ターゲットマシンでサポートされている場合、遅延分岐命令の後に利用可能な命令スロットを利用して命令を並べ替えようとします。</target>
        </trans-unit>
        <trans-unit id="324f5e0a0812879119b6243a7b551f6c87385665" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, emit position-independent code, suitable for dynamic linking and avoiding any limit on the size of the global offset table. This option makes a difference on AArch64, m68k, PowerPC and SPARC.</source>
          <target state="translated">タ ーゲ ッ ト マシ ンでサポー ト さ れてい る 場合は、 位置に依存 し ない コ ー ド を出力 し ます。 こ れはダ イ ナ ミ ッ ク リ ン ク に適してお り 、 グ ロ ーバルオ フ セ ッ ト テーブルのサ イ ズの制限を回避で き ます。このオプションは、AArch64,m68k,PowerPC,SPARC では違いがあります。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">の場合は</target>
        </trans-unit>
        <trans-unit id="848af5bfa5ce573c8e5c9af3ee618628d308338c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LC_ALL&lt;/code&gt; environment variable is set, it overrides the value of &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt;; otherwise, &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; default to the value of the &lt;code&gt;LANG&lt;/code&gt; environment variable. If none of these variables are set, GCC defaults to traditional C English behavior.</source>
          <target state="translated">場合は &lt;code&gt;LC_ALL&lt;/code&gt; の環境変数が設定されている、それはの値より優先されます &lt;code&gt;LC_CTYPE&lt;/code&gt; と &lt;code&gt;LC_MESSAGES&lt;/code&gt; を。それ以外の場合、 &lt;code&gt;LC_CTYPE&lt;/code&gt; および &lt;code&gt;LC_MESSAGES&lt;/code&gt; はデフォルトで &lt;code&gt;LANG&lt;/code&gt; 環境変数の値になります。これらの変数がいずれも設定されていない場合、GCCはデフォルトで従来のC英語の動作に設定されます。</target>
        </trans-unit>
        <trans-unit id="927b034e0a10d14fe57f4acd375117bf77534e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;warning&lt;/code&gt; attribute is used on a function declaration and a call to such a function is not eliminated through dead code elimination or other optimizations, an error or warning (respectively) that includes &lt;var&gt;message&lt;/var&gt; is diagnosed. This is useful for compile-time checking, especially together with &lt;code&gt;__builtin_constant_p&lt;/code&gt; and inline functions where checking the inline function arguments is not possible through &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; tricks.</source>
          <target state="translated">場合 &lt;code&gt;error&lt;/code&gt; または &lt;code&gt;warning&lt;/code&gt; 属性は、関数宣言と、そのような関数の呼び出しに使用される含むデッドコード削除または他の最適化、エラーまたは（それぞれ）警告を介して除去されていない &lt;var&gt;message&lt;/var&gt; 診断されます。これは、特に &lt;code&gt;__builtin_constant_p&lt;/code&gt; およびインライン関数とともに、 &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; トリック。</target>
        </trans-unit>
        <trans-unit id="20d0c6878745134aa8d904b0690e4fcbddc7d599" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;filename&lt;/var&gt; is provided, then the dumps from all the applicable optimizations are concatenated into the &lt;var&gt;filename&lt;/var&gt;. Otherwise the dump is output onto</source>
          <target state="translated">場合は &lt;var&gt;filename&lt;/var&gt; 提供され、その後、適用可能なすべての最適化からのダンプはに連結されている &lt;var&gt;filename&lt;/var&gt; 。それ以外の場合、ダンプは出力されます</target>
        </trans-unit>
        <trans-unit id="9215ad70f2e3e9c6cab1765215d93885159eaa97" translate="yes" xml:space="preserve">
          <source>If the C code that follows the &lt;code&gt;asm&lt;/code&gt; makes no use of any of the output operands, use &lt;code&gt;volatile&lt;/code&gt; for the &lt;code&gt;asm&lt;/code&gt; statement to prevent the optimizers from discarding the &lt;code&gt;asm&lt;/code&gt; statement as unneeded (see &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; に続くCコードが出力オペランドをまったく使用しない場合は、 &lt;code&gt;asm&lt;/code&gt; ステートメントに &lt;code&gt;volatile&lt;/code&gt; を使用して、オプティマイザが &lt;code&gt;asm&lt;/code&gt; ステートメントを不要として破棄しないようにします（&lt;a href=&quot;#Volatile&quot;&gt;Volatileを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2aa76d6986dfd258dee402c2c95ca11459599c59" translate="yes" xml:space="preserve">
          <source>If the CPU is executing speculatively then either:</source>
          <target state="translated">CPUが投機的に実行している場合は、どちらかになります。</target>
        </trans-unit>
        <trans-unit id="8fe995e077eb81e27ea124938efd43a017d00001" translate="yes" xml:space="preserve">
          <source>If the CPU is not speculatively executing the code, then &lt;var&gt;val&lt;/var&gt; is returned.</source>
          <target state="translated">CPUがコードを投機的に実行していない場合は、 &lt;var&gt;val&lt;/var&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="c68ba352d7c54da4de70d37cd280b24a3feb4442" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for 64-bit targets. New vector types (&lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt;) are available to hold the &lt;var&gt;__int128&lt;/var&gt; and &lt;var&gt;__uint128&lt;/var&gt; types to use these builtins.</source>
          <target state="translated">ベクトル/スカラー（power8-vector）命令セットへのISA 2.07の追加が利用可能な場合、64ビットターゲットに対して以下の追加関数を利用できます。これらの &lt;var&gt;__uint128&lt;/var&gt; を使用するための &lt;var&gt;__int128&lt;/var&gt; および__uint128タイプを保持するために、新しいベクトルタイプ（ &lt;var&gt;vector __int128&lt;/var&gt; および &lt;var&gt;vector __uint128&lt;/var&gt; ）を使用できます。</target>
        </trans-unit>
        <trans-unit id="7ad5ced5d695028f0b739572f683d981d7b325cd" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for both 32-bit and 64-bit targets. For 64-bit targets, you can use &lt;var&gt;vector long&lt;/var&gt; instead of &lt;var&gt;vector long long&lt;/var&gt;, &lt;var&gt;vector bool long&lt;/var&gt; instead of &lt;var&gt;vector bool long long&lt;/var&gt;, and &lt;var&gt;vector unsigned long&lt;/var&gt; instead of &lt;var&gt;vector unsigned long long&lt;/var&gt;.</source>
          <target state="translated">ベクトル/スカラー（power8-vector）命令セットへのISA 2.07の追加が利用可能な場合、32ビットと64ビットの両方のターゲットで次の追加関数を使用できます。64ビットターゲットの場合、 &lt;var&gt;vector long&lt;/var&gt; longの代わりに &lt;var&gt;vector long long&lt;/var&gt; 、 &lt;var&gt;vector bool long&lt;/var&gt; longの代わりに &lt;var&gt;vector bool long long&lt;/var&gt; を、 &lt;var&gt;vector unsigned long&lt;/var&gt; longの代わりに &lt;var&gt;vector unsigned long long&lt;/var&gt; ます。</target>
        </trans-unit>
        <trans-unit id="c22a3317bedd3145de7eb3a31ecc603e64eb80be" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions (</source>
          <target state="translated">ISA 3.0命令セットの追加(</target>
        </trans-unit>
        <trans-unit id="424b99254d8407b86c2beca1ac6e71a6fca8ab99" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions are enabled (</source>
          <target state="translated">ISA 3.0 命令セットの追加が有効な場合 (</target>
        </trans-unit>
        <trans-unit id="b3ba2117601e3a207db62aaa0d548209b490cb82" translate="yes" xml:space="preserve">
          <source>If the argument to the macro has variably modified type, it is evaluated only once when using &lt;code&gt;__auto_type&lt;/code&gt;, but twice if &lt;code&gt;typeof&lt;/code&gt; is used.</source>
          <target state="translated">マクロの引数の型が可変的に変更されている場合、 &lt;code&gt;__auto_type&lt;/code&gt; を使用すると1回だけ評価されますが、 &lt;code&gt;typeof&lt;/code&gt; を使用すると2回評価されます。</target>
        </trans-unit>
        <trans-unit id="e5db05160eb702af65a65d649789a2509aade574" translate="yes" xml:space="preserve">
          <source>If the attribute is specified and &lt;code&gt;#pragma omp declare simd&lt;/code&gt; is present on a declaration and the</source>
          <target state="translated">属性が指定され、 &lt;code&gt;#pragma omp declare simd&lt;/code&gt; が宣言と</target>
        </trans-unit>
        <trans-unit id="d120c6bfa80fbe55cec1d9862d7e2421db795ea2" translate="yes" xml:space="preserve">
          <source>If the compiler was built to use the system&amp;rsquo;s headers by default, then the default for this option is the system version on which the compiler is running, otherwise the default is to make choices that are compatible with as many systems and code bases as possible.</source>
          <target state="translated">コンパイラがデフォルトでシステムのヘッダーを使用するように構築されている場合、このオプションのデフォルトは、コンパイラが実行されているシステムのバージョンです。それ以外の場合、デフォルトでは、できるだけ多くのシステムおよびコードベースと互換性のある選択が行われます。</target>
        </trans-unit>
        <trans-unit id="d67b52944ba9df1fde368725db64f0de08228c75" translate="yes" xml:space="preserve">
          <source>If the compiler&amp;rsquo;s optimization uses a function&amp;rsquo;s body or information extracted from its body to optimize/change another function, the latter is called an impacted function of the former. If a function is patched, its impacted functions should be patched too.</source>
          <target state="translated">コンパイラーの最適化で関数の本体または本体から抽出された情報を使用して別の関数を最適化/変更する場合、後者は前者の影響を受ける関数と呼ばれます。関数にパッチを適用する場合、影響を受ける関数にもパッチを適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b237760180d1507d3e5ec309754cc736d88da667" translate="yes" xml:space="preserve">
          <source>If the cryptographic instructions are enabled (</source>
          <target state="translated">暗号化命令が有効な場合 (</target>
        </trans-unit>
        <trans-unit id="4fb7464a62433bc1b1813aee95893c7c7b12fed7" translate="yes" xml:space="preserve">
          <source>If the device comes with a specific &lt;code&gt;RAMP&lt;/code&gt; register, the ISR prologue/epilogue saves/restores that SFR and initializes it with zero in case the ISR code might (implicitly) use it.</source>
          <target state="translated">デバイスに特定の &lt;code&gt;RAMP&lt;/code&gt; レジスタが付属している場合、ISRプロローグ/エピローグはそのSFRを保存/復元し、ISRコードが（暗黙的に）使用する可能性がある場合にゼロに初期化します。</target>
        </trans-unit>
        <trans-unit id="f359291701f84a5c952e96591467d10e46106142" translate="yes" xml:space="preserve">
          <source>If the device supports RAM larger than 64 KiB and the compiler needs to change &lt;code&gt;RAMPZ&lt;/code&gt; to accomplish an operation, &lt;code&gt;RAMPZ&lt;/code&gt; is reset to zero after the operation.</source>
          <target state="translated">デバイスがサポートして変更することが64 KiBのと、コンパイラのニーズよりも大きなRAM場合 &lt;code&gt;RAMPZ&lt;/code&gt; を操作を達成するために、 &lt;code&gt;RAMPZ&lt;/code&gt; は、操作の後にゼロにリセットされます。</target>
        </trans-unit>
        <trans-unit id="4b99e2eb0f30f6704cb82d8729d610b9c040ff67" translate="yes" xml:space="preserve">
          <source>If the equal sign is omitted, the default</source>
          <target state="translated">等号を省略した場合は、デフォルトの</target>
        </trans-unit>
        <trans-unit id="d2b152efe933ab511c3240207de045545a59413b" translate="yes" xml:space="preserve">
          <source>If the forwarding hook does not exist or returns &lt;code&gt;NULL&lt;/code&gt;, the runtime currently attempts forwarding using an older, deprecated API, and if that fails, it aborts the program. In future versions of the GNU Objective-C runtime, the runtime will immediately abort.</source>
          <target state="translated">転送フックが存在しないか &lt;code&gt;NULL&lt;/code&gt; を返す場合、ランタイムは現在、非推奨の古いAPIを使用して転送を試み、それが失敗した場合、プログラムを中止します。GNU Objective-Cランタイムの将来のバージョンでは、ランタイムはすぐに中止されます。</target>
        </trans-unit>
        <trans-unit id="fb3ee17ffd6e7e71752206840400cc69026ba54d" translate="yes" xml:space="preserve">
          <source>If the function is called repeatedly with &lt;code&gt;untrusted_index&lt;/code&gt; less than the limit of 500, then a branch predictor will learn that the block of code that returns a value stored in &lt;code&gt;array&lt;/code&gt; will be executed. If the function is subsequently called with an out-of-range value it will still try to execute that block of code first until the CPU determines that the prediction was incorrect (the CPU will unwind any incorrect operations at that point). However, depending on how the result of the function is used, it might be possible to leave traces in the cache that can reveal what was stored at the out-of-bounds location. The built-in function can be used to provide some protection against leaking data in this way by changing the code to:</source>
          <target state="translated">&lt;code&gt;untrusted_index&lt;/code&gt; が500の制限未満で関数が繰り返し呼び出される場合、分岐予測子は、 &lt;code&gt;array&lt;/code&gt; 格納された値を返すコードのブロックが実行されることを学習します。その後、範囲外の値で関数が呼び出された場合でも、予測が正しくないとCPUが判断するまで、そのコードブロックを最初に実行しようとします（CPUは、その時点で不正な操作を巻き戻します）。ただし、関数の結果がどのように使用されるかに応じて、範囲外の場所に格納されたものを明らかにできるトレースをキャッシュに残すことができる場合があります。組み込み関数を使用して、コードを次のように変更することにより、この方法でデータの漏洩を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="4966bfe90659d4fba00a57263dad419daa50166b" translate="yes" xml:space="preserve">
          <source>If the function is declared &lt;code&gt;extern&lt;/code&gt;, then this definition of the function is used only for inlining. In no case is the function compiled as a standalone function, not even if you take its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it. This has almost the effect of a macro. The way to use this is to put a function definition in a header file with this attribute, and put another copy of the function, without &lt;code&gt;extern&lt;/code&gt;, in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library. Note that the two definitions of the functions need not be precisely the same, although if they do not have the same effect your program may behave oddly.</source>
          <target state="translated">関数が &lt;code&gt;extern&lt;/code&gt; と宣言されている場合、関数のこの定義はインライン化にのみ使用されます。関数をスタンドアロン関数としてコンパイルすることは決してありません。明示的にアドレスを取得する場合でも同様です。このようなアドレスは、関数を宣言しただけで関数を定義していないかのように、外部参照になります。これはほとんどマクロの効果があります。これを使用する方法は、関数定義をこの属性を持つヘッダーファイルに入れ、 &lt;code&gt;extern&lt;/code&gt; なしで関数の別のコピーを置くことです、ライブラリファイル内。ヘッダーファイル内の定義により、関数のほとんどの呼び出しがインライン化されます。関数の使用が残っている場合は、ライブラリ内の単一のコピーを参照します。関数の2つの定義は厳密に同じである必要はありませんが、同じ効果がない場合はプログラムが奇妙に動作する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b771c97ff2c33b584d16ad8091b88c7d383e2d71" translate="yes" xml:space="preserve">
          <source>If the function is inlined in several places, the block structure in each location might not be the same. For instance, a condition might now be calculable at compile time in some instances. Because the coverage of all the uses of the inline function will be shown for the same source lines, the line counts themselves might seem inconsistent.</source>
          <target state="translated">関数が複数の場所でインライン化されている場合、各場所のブロック構造は同じではないかもしれません。例えば、ある条件がコンパイル時に計算できるようになった場合などです。インライン関数のすべての使用法が同じソース行に対して表示されるため、行数自体が矛盾しているように見えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f54a0365a2045222faa9a6a632a364c211ec115e" translate="yes" xml:space="preserve">
          <source>If the function is not inlined, the compiler must emit an out of line copy of the function, in any object file that needs it. If</source>
          <target state="translated">関数がインライン化されていない場合、コンパイラは必要なオブジェクト・ファイルに関数の行外コピーを出力する必要があります。もし</target>
        </trans-unit>
        <trans-unit id="1d41e4e5598657e0dd5a304d5f9d42468e2c3eb3" translate="yes" xml:space="preserve">
          <source>If the hotpatch option is enabled, a &amp;ldquo;hot-patching&amp;rdquo; function prologue is generated for all functions in the compilation unit. The funtion label is prepended with the given number of two-byte NOP instructions (&lt;var&gt;pre-halfwords&lt;/var&gt;, maximum 1000000). After the label, 2 * &lt;var&gt;post-halfwords&lt;/var&gt; bytes are appended, using the largest NOP like instructions the architecture allows (maximum 1000000).</source>
          <target state="translated">ホットパッチオプションが有効な場合、コンパイルユニット内のすべての関数に対して「ホットパッチ」関数プロローグが生成されます。関数ラベルの前には、指定された数の2バイトのNOP命令が追加されます（ &lt;var&gt;pre-halfwords&lt;/var&gt; 、最大1000000）。ラベルの後に、アーキテクチャで許可されている最大のNOPのような命令を使用して、2 * &lt;var&gt;post-halfwords&lt;/var&gt; バイトが追加されます（最大1000000）。</target>
        </trans-unit>
        <trans-unit id="1afbfd9c64402361ab2fa39f9fdbd1e3be8c266e" translate="yes" xml:space="preserve">
          <source>If the input program contains a function declaration such as:</source>
          <target state="translated">のような関数宣言が入力プログラムに含まれている場合。</target>
        </trans-unit>
        <trans-unit id="d87ca5a862edf69ec778f2863678b3c80b02aa1b" translate="yes" xml:space="preserve">
          <source>If the linker complains that an application is using too much small data, you might want to try rebuilding the less performance-critical parts with</source>
          <target state="translated">リンカがアプリケーションが小さすぎるデータを使用していると文句を言う場合は、パフォーマンスクリティカルではない部分を</target>
        </trans-unit>
        <trans-unit id="2bf1dd3a359ed16413542f38135a6d9bd4288cff" translate="yes" xml:space="preserve">
          <source>If the number of candidates in the set is smaller than this value, always try to remove unnecessary ivs from the set when adding a new one.</source>
          <target state="translated">セット内の候補の数がこの値よりも少ない場合は、新規追加の際には必ず不要なIVをセットから削除するようにしてください。</target>
        </trans-unit>
        <trans-unit id="e7428a6a85aa26ccfc1d34f1f1cde51cd5cd4798" translate="yes" xml:space="preserve">
          <source>If the operand of &lt;code&gt;__alignof__&lt;/code&gt; is an lvalue rather than a type, its value is the required alignment for its type, taking into account any minimum alignment specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;). For example, after this declaration:</source>
          <target state="translated">オペランド場合 &lt;code&gt;__alignof__&lt;/code&gt; は左辺値ではなく、型で、その値は、その型のために必要なアライメントで、アカウントに任意の最小アラインメントを取ることは、属性で指定された &lt;code&gt;aligned&lt;/code&gt; （参照&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;共通変数の属性&lt;/a&gt;）。たとえば、この宣言の後：</target>
        </trans-unit>
        <trans-unit id="a5fda9cca36b52c744155ff2696d3cbfb80c2db1" translate="yes" xml:space="preserve">
          <source>If the operand of the &lt;code&gt;__alignof__&lt;/code&gt; expression is a function, the expression evaluates to the alignment of the function which may be specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;__alignof__&lt;/code&gt; 式のオペランドが関数の場合、式は、属性の &lt;code&gt;aligned&lt;/code&gt; によって指定できる関数の整列に評価されます（「&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;共通の関数属性&lt;/a&gt;」を参照）。</target>
        </trans-unit>
        <trans-unit id="716641ab8a53f52206a358470c323b2f23eaf7fa" translate="yes" xml:space="preserve">
          <source>If the ratio of expression insertions to deletions is larger than this value for any expression, then RTL PRE inserts or removes the expression and thus leaves partially redundant computations in the instruction stream.</source>
          <target state="translated">式の挿入と削除の比率がこの値よりも大きい場合、RTL PREは式を挿入または削除し、その結果、命令ストリームに部分的に冗長な計算を残します。</target>
        </trans-unit>
        <trans-unit id="05912318b76a1009d770bd192ecd133075c5fc90" translate="yes" xml:space="preserve">
          <source>If the register is a call-saved register, call ABI is affected: the register will not be restored in function epilogue sequences after the variable has been assigned. Therefore, functions cannot safely return to callers that assume standard ABI.</source>
          <target state="translated">レジスタがコールセーブされたレジスタである場合、コールABIが影響を受けます:変数が代入された後の関数エピローグシーケンスではレジスタは復元されません。したがって、関数は標準ABIを想定した呼び出し元に安全に戻ることができません。</target>
        </trans-unit>
        <trans-unit id="9d80c0f0c0e0e7931ed927bbb4a8416d7ae0d80f" translate="yes" xml:space="preserve">
          <source>If the same field is initialized multiple times, or overlapping fields of a union are initialized, the value from the last initialization is used. When a field of a union is itself a structure, the entire structure from the last field initialized is used. If any previous initializer has side effect, it is unspecified whether the side effect happens or not. Currently, GCC discards the side-effecting initializer expressions and issues a warning.</source>
          <target state="translated">同じフィールドが複数回初期化されている場合や、ユニオンのフィールドが重複して初期化されている場合は、最後に初期化されたフィールドの値が使用されます。ユニオンのフィールド自体が構造体の場合は、最後に初期化されたフィールドからの構造体全体が使用されます。前の初期化子に副作用があった場合、副作用が発生するかどうかは不特定です。現在、GCCは副作用のある初期化子式を破棄して警告を出しています。</target>
        </trans-unit>
        <trans-unit id="60d643b079de10a712e4f0092195d4a678550bd1" translate="yes" xml:space="preserve">
          <source>If the second argument of a shift operation is within range, check that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc.</source>
          <target state="translated">シフト演算の第2引数が範囲内であれば、シフト演算の結果が未定義でないことを確認します。未定義とみなされるものは、CとC++、ISO C90とC99などの間で若干異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a31cdc2866161da54d441996165823d561084f93" translate="yes" xml:space="preserve">
          <source>If the selected floating-point hardware includes the NEON extension (e.g.</source>
          <target state="translated">選択された浮動小数点ハードウェアにNEON拡張機能が含まれている場合(例えば</target>
        </trans-unit>
        <trans-unit id="ba7e4ec3c7ed6c8b730bc79d728df15242bb6315" translate="yes" xml:space="preserve">
          <source>If the size of a local variable in bytes is smaller or equal to this number, directly poison (or unpoison) shadow memory instead of using run-time callbacks.</source>
          <target state="translated">ローカル変数のサイズがバイト数以下の場合は、ランタイムコールバックを使用せずに、直接シャドウメモリをポイズン(またはアンポイズン)します。</target>
        </trans-unit>
        <trans-unit id="417bd3fd4051d252d11a2c9158594ed0d6e39230" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic and not bounded, it&amp;rsquo;s:</source>
          <target state="translated">スタックの使用が（部分的に）動的であり、制限がない場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="b6665e1bf11576c0ed34f60f152094f72a6d33b1" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic but bounded, it&amp;rsquo;s:</source>
          <target state="translated">スタックの使用量が（部分的に）動的であるが制限されている場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="6185bf1adb7da0baa58ee0f68d56a9ef418a48d1" translate="yes" xml:space="preserve">
          <source>If the stack usage is fully static but exceeds the specified amount, it&amp;rsquo;s:</source>
          <target state="translated">スタックの使用量が完全に静的であるが、指定された量を超える場合、それは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d70267f0ff1a52892efb70d9a08fcf6abe326706" translate="yes" xml:space="preserve">
          <source>If the target does not require instruction cache flushes, &lt;code&gt;__builtin___clear_cache&lt;/code&gt; has no effect. Otherwise either instructions are emitted in-line to clear the instruction cache or a call to the &lt;code&gt;__clear_cache&lt;/code&gt; function in libgcc is made.</source>
          <target state="translated">ターゲットが命令キャッシュのフラッシュを必要としない場合、 &lt;code&gt;__builtin___clear_cache&lt;/code&gt; は効果がありません。それ以外の場合、命令キャッシュをクリアするために命令が &lt;code&gt;__clear_cache&lt;/code&gt; で発行されるか、libgccの__clear_cache関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="095e473e81d277e85bb1ebdb8df1dacc96479003" translate="yes" xml:space="preserve">
          <source>If the target does not support data prefetch, the address expression is evaluated if it includes side effects but no other code is generated and GCC does not issue a warning.</source>
          <target state="translated">ターゲットがデータプリフェッチをサポートしていない場合、アドレス式は副作用を含む場合に評価されますが、他のコードが生成されず、GCCが警告を発行しない場合に評価されます。</target>
        </trans-unit>
        <trans-unit id="063fcca71547a7fd5efc66500b8f981bd9c39ed3" translate="yes" xml:space="preserve">
          <source>If the target supports a BSS section, GCC by default puts variables that are initialized to zero into BSS. This can save space in the resulting code.</source>
          <target state="translated">ターゲットが BSS セクションをサポートしている場合、GCC はデフォルトでゼロに初期化された変数を BSS に入れます。これにより、結果として得られるコードのスペースを節約することができます。</target>
        </trans-unit>
        <trans-unit id="3918a65b7ea046bcd3f9722a5e8050706b67b421" translate="yes" xml:space="preserve">
          <source>If the transaction aborts, all side effects are undone and an abort code encoded as a bit mask is returned. The following macros are defined:</source>
          <target state="translated">トランザクションがアボートする場合、すべての副作用は取り消され、ビットマスクとしてエンコードされたアボートコードが返される。以下のマクロが定義されています。</target>
        </trans-unit>
        <trans-unit id="52878fb9a18ac14d0e8c56cabf2833c060108631" translate="yes" xml:space="preserve">
          <source>If the value in it has side effects, the side effects happen only once, not for each initialized field by the range initializer.</source>
          <target state="translated">その中の値に副作用がある場合、副作用は一度だけ発生し、範囲のイニシャライザで初期化されたフィールドごとに発生するのではありません。</target>
        </trans-unit>
        <trans-unit id="eea091306a656215179432ee609d12ba3a9d954d" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;y&lt;/code&gt; is always 1, 2 or 3, then &lt;code&gt;x&lt;/code&gt; is always initialized, but GCC doesn&amp;rsquo;t know this. To suppress the warning, you need to provide a default case with assert(0) or similar code.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; の値が常に1、2、または3の場合、 &lt;code&gt;x&lt;/code&gt; は常に初期化されますが、GCCはこれを認識しません。警告を抑制するには、assert（0）または同様のコードでデフォルトのケースを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a0552d924c971b406818fb3dc8c14b487a51639" translate="yes" xml:space="preserve">
          <source>If the variable is referenced in inline assembly, the type of access must be provided to the compiler via constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;). Accesses from basic asms are not supported.</source>
          <target state="translated">変数がインラインアセンブリで参照される場合、アクセスのタイプは制約を介してコンパイラーに提供する必要があります（&lt;a href=&quot;constraints#Constraints&quot;&gt;制約を&lt;/a&gt;参照）。基本的なasmからのアクセスはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="710a7177647056e46d73c6a14fa58cb0a4d39cb4" translate="yes" xml:space="preserve">
          <source>If there are no output operands but there are input operands, place two consecutive colons where the output operands would go:</source>
          <target state="translated">出力オペランドがなく、入力オペランドがある場合は、出力オペランドがあるところに2つの連続したコロンを配置してください。</target>
        </trans-unit>
        <trans-unit id="ba1e7edd0bd3070d7470d6998361492b87d52104" translate="yes" xml:space="preserve">
          <source>If there is no pattern or mechanism to provide a lock-free instruction sequence, a call is made to an external routine with the same parameters to be resolved at run time.</source>
          <target state="translated">ロックフリーの命令シーケンスを提供するパターンやメカニズムがない場合は、実行時に解決されるべき同じパラメータを持つ外部ルーチンへの呼び出しが行われます。</target>
        </trans-unit>
        <trans-unit id="76caf5beb996fc90102a47daa7e154a5cb406f3a" translate="yes" xml:space="preserve">
          <source>If these options are provided the S/390 back end emits additional instructions in the function prologue that trigger a trap if the stack size is &lt;var&gt;stack-guard&lt;/var&gt; bytes above the &lt;var&gt;stack-size&lt;/var&gt; (remember that the stack on S/390 grows downward). If the &lt;var&gt;stack-guard&lt;/var&gt; option is omitted the smallest power of 2 larger than the frame size of the compiled function is chosen. These options are intended to be used to help debugging stack overflow problems. The additionally emitted code causes only little overhead and hence can also be used in production-like systems without greater performance degradation. The given values have to be exact powers of 2 and &lt;var&gt;stack-size&lt;/var&gt; has to be greater than &lt;var&gt;stack-guard&lt;/var&gt; without exceeding 64k. In order to be efficient the extra code makes the assumption that the stack starts at an address aligned to the value given by &lt;var&gt;stack-size&lt;/var&gt;. The &lt;var&gt;stack-guard&lt;/var&gt; option can only be used in conjunction with &lt;var&gt;stack-size&lt;/var&gt;.</source>
          <target state="translated">これらのオプションが提供されている場合、S / 390バックエンドは、スタックサイズが &lt;var&gt;stack-guard&lt;/var&gt; サイズを超える &lt;var&gt;stack-size&lt;/var&gt; ガードバイトである場合にトラップをトリガーする追加の命令を関数プロローグで発行します（S / 390上のスタックは下向きに成長することに注意してください）。場合 &lt;var&gt;stack-guard&lt;/var&gt; オプションが省略されたコンパイルされた関数のフレームサイズよりも大きい2の最小電力が選択されます。これらのオプションは、スタックオーバーフローの問題のデバッグに使用することを目的としています。追加で発行されたコードはオーバーヘッドをほとんど引き起こさないため、パフォーマンスを大幅に低下させることなく、本番のようなシステムでも使用できます。与えられた値は2の正確な累乗でなければならず、 &lt;var&gt;stack-size&lt;/var&gt; は &lt;var&gt;stack-guard&lt;/var&gt; より大きい必要があります64kを超えることなく。効率を上げるために、追加のコードは、スタックが &lt;var&gt;stack-size&lt;/var&gt; で指定された値に揃えられたアドレスから始まると仮定しています。 &lt;var&gt;stack-guard&lt;/var&gt; オプションはのみと組み合わせて使用することができます &lt;var&gt;stack-size&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="a905ee4ba472cb30116f3f77a848f112c04b6376" translate="yes" xml:space="preserve">
          <source>If this happens, you should recompile your code with</source>
          <target state="translated">このような場合は、コードを</target>
        </trans-unit>
        <trans-unit id="1cc1d69b5f6b24d749c4393c1e5384e6327ba002" translate="yes" xml:space="preserve">
          <source>If this option appears multiple times in the command line with different values specified, &amp;lsquo;</source>
          <target state="translated">このオプションがコマンドラインに複数回表示され、異なる値が指定されている場合、 '</target>
        </trans-unit>
        <trans-unit id="7d789a669772c260255b8f486a50720c5dbf98e3" translate="yes" xml:space="preserve">
          <source>If this option is disabled, the compiler uses the most efficient instruction. In the previous example, that might be a 32-bit load instruction, even though that accesses bytes that do not contain any portion of the bit-field, or memory-mapped registers unrelated to the one being updated.</source>
          <target state="translated">このオプションを無効にすると、コンパイラは最も効率的な命令を使用します。前の例では、ビットフィールドの一部を含まないバイトや、更新されるビットフィールドとは関係のないメモリマップされたレジスタにアクセスしますが、これは32ビットのロード命令かもしれません。</target>
        </trans-unit>
        <trans-unit id="eaaa3704bd89671f3908d72dc5973515cc911101" translate="yes" xml:space="preserve">
          <source>If this option is enabled, the compiler tries to avoid unnecessarily overaligning functions. It attempts to instruct the assembler to align by the amount specified by</source>
          <target state="translated">このオプションを有効にすると、コンパイラは関数の不必要なオーバーアラインメントを避けようとします。コンパイラはアセンブラに</target>
        </trans-unit>
        <trans-unit id="7074bcc3f488dbf4492fda0d639c0f8273ca6d14" translate="yes" xml:space="preserve">
          <source>If this option is not provided but</source>
          <target state="translated">このオプションが提供されていないが</target>
        </trans-unit>
        <trans-unit id="b89db9dde06a530a5dff7a4661614320224ef048" translate="yes" xml:space="preserve">
          <source>If this option is not used, the single-core application programming model is used.</source>
          <target state="translated">このオプションを使用しない場合は、シングルコア・アプリケーション・プログラミング・モデルが使用されます。</target>
        </trans-unit>
        <trans-unit id="58f2a7b1d53a81872af6e83acac9efe5419c83d5" translate="yes" xml:space="preserve">
          <source>If this option is set it also selects the type of hardware multiply support to use, unless this is overridden by an explicit</source>
          <target state="translated">このオプションが設定されている場合、明示的な</target>
        </trans-unit>
        <trans-unit id="13cec7c0becaf2d393aabd05cb427709a6c05830" translate="yes" xml:space="preserve">
          <source>If this option is used, the compiler will warn for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed &lt;var&gt;byte-size&lt;/var&gt; bytes. This is similar to how</source>
          <target state="translated">このオプションを使用すると、コンパイラーは、サイズが無制限であるか、配列サイズが &lt;var&gt;byte-size&lt;/var&gt; バイトを超えることができる引数で制限されている可変長配列の宣言について警告します。これは、</target>
        </trans-unit>
        <trans-unit id="c3115ee12356444486b8dfe277e34da87b4c9653" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies a UNIX timestamp to be used in replacement of the current date and time in the &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; macros, so that the embedded timestamps become reproducible.</source>
          <target state="translated">この変数が設定されている場合、その値は、 &lt;code&gt;__DATE__&lt;/code&gt; および &lt;code&gt;__TIME__&lt;/code&gt; マクロの現在の日付と時刻の代わりに使用されるUNIXタイムスタンプを指定し、埋め込まれたタイムスタンプを再現できるようにします。</target>
        </trans-unit>
        <trans-unit id="9e2fd261f951c508769059b9f0362dce31b86177" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies how to output dependencies for Make based on the non-system header files processed by the compiler. System header files are ignored in the dependency output.</source>
          <target state="translated">この変数が設定されている場合、その値はコンパイラが処理する非システムヘッダファイルに基づいて Make の依存関係を出力する方法を指定します。システムヘッダファイルは依存関係の出力では無視されます。</target>
        </trans-unit>
        <trans-unit id="a402efdff3876f11c94bdea172224e741634fd39" translate="yes" xml:space="preserve">
          <source>If used for a function, print the PLT suffix and generate PIC code. For example, emit &lt;code&gt;foo@PLT&lt;/code&gt; instead of &amp;rsquo;foo&amp;rsquo; for the function foo(). If used for a constant, drop all syntax-specific prefixes and issue the bare constant. See &lt;code&gt;p&lt;/code&gt; above.</source>
          <target state="translated">関数に使用する場合は、PLTサフィックスを印刷し、PICコードを生成します。たとえば、関数foo（）の「foo」の代わりに &lt;code&gt;foo@PLT&lt;/code&gt; ます。定数に使用する場合は、構文固有の接頭辞をすべて削除し、必要な定数を発行します。上記の &lt;code&gt;p&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="0aee4afea693faf480212e1e7dfd95c798d52751" translate="yes" xml:space="preserve">
          <source>If you are invoking the preprocessor from a shell or shell-like program you may need to use the shell&amp;rsquo;s quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.</source>
          <target state="translated">シェルまたはシェルのようなプログラムからプリプロセッサを呼び出す場合は、シェルの引用構文を使用して、シェル構文で意味を持つスペースなどの文字を保護する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="12dd6be4f44a03f04923a3d7c38a665528824bfc" translate="yes" xml:space="preserve">
          <source>If you are not using a linker with plugin support and/or do not enable the linker plugin, then the objects inside</source>
          <target state="translated">プラグインがサポートされているリンカを使用していない場合やリンカプラグインを有効にしていない場合は</target>
        </trans-unit>
        <trans-unit id="dadbd9ac438963390bc7bff3cc4c1fa602dc81f8" translate="yes" xml:space="preserve">
          <source>If you are not using some other optimization option, consider using</source>
          <target state="translated">他の最適化オプションを使用していない場合は</target>
        </trans-unit>
        <trans-unit id="c0c121f354142152248081fdee3df09a5e0cff31" translate="yes" xml:space="preserve">
          <source>If you are using Cfront-model code, you can probably get away with not using</source>
          <target state="translated">Cfront-model のコードを使用している場合は、おそらく</target>
        </trans-unit>
        <trans-unit id="670c5a80eac2c68f98a0b7952c25d85ec989c07c" translate="yes" xml:space="preserve">
          <source>If you are using a &amp;ldquo;Foundation&amp;rdquo; library such as GNUstep-Base, this library will provide you with a rich set of functionality to do most of the inspection tasks, and you probably will only need direct access to the GNU Objective-C runtime API to define new classes or methods.</source>
          <target state="translated">GNUstep-Baseなどの「Foundation」ライブラリを使用している場合、このライブラリは、ほとんどの検査タスクを実行するための豊富な機能セットを提供し、おそらくGNU Objective-CランタイムAPIへの直接アクセスのみが必要になります新しいクラスまたはメソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="f60cfeeeec61609632220d7b04102d2cfb0874a6" translate="yes" xml:space="preserve">
          <source>If you are writing a header file that must work when included in ISO C programs, write &lt;code&gt;__typeof__&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">ISO Cプログラムに含まれたときに必須の作業というヘッダファイルを作成している場合、書き込みが &lt;code&gt;__typeof__&lt;/code&gt; の代わりに &lt;code&gt;typeof&lt;/code&gt; 演算。&lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;代替キーワードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="047e86cc1cc9d18346ee9ad5f63aecd5602b5f99" translate="yes" xml:space="preserve">
          <source>If you are writing a header file to be included in ISO C90 programs, write &lt;code&gt;__inline__&lt;/code&gt; instead of &lt;code&gt;inline&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">ISO C90プログラムに含めるヘッダーファイルを記述する &lt;code&gt;__inline__&lt;/code&gt; は、 &lt;code&gt;inline&lt;/code&gt; ではなく__inline__を記述します。&lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;代替キーワードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="dbd2d15a4f5e85df131685d7eb92f6861e37e279" translate="yes" xml:space="preserve">
          <source>If you care about controlling the amount of memory that is accessed, use volatile but do not use bit-fields.</source>
          <target state="translated">アクセスされるメモリの量を制御することにこだわるのであれば、揮発性のものを使用しますが、ビットフィールドは使用しません。</target>
        </trans-unit>
        <trans-unit id="0103e1abfe788f8d50e7fc73d958416e72e0b9c1" translate="yes" xml:space="preserve">
          <source>If you compile a module &lt;var&gt;Mod&lt;/var&gt; with</source>
          <target state="translated">モジュール &lt;var&gt;Mod&lt;/var&gt; をコンパイルすると</target>
        </trans-unit>
        <trans-unit id="47d85eced409c6f6fef0defc52869795ed0b0f14" translate="yes" xml:space="preserve">
          <source>If you define a class in a header file marked with &amp;lsquo;</source>
          <target state="translated">'でマークされたヘッダーファイルでクラスを定義する場合</target>
        </trans-unit>
        <trans-unit id="8af3483bb66c1cf78841141fb90f1ef9efc295a7" translate="yes" xml:space="preserve">
          <source>If you do not specify an optimization level option</source>
          <target state="translated">最適化レベル・オプションを指定しない場合</target>
        </trans-unit>
        <trans-unit id="0524dbf059780b836548e3795cd65f22c493bbb4" translate="yes" xml:space="preserve">
          <source>If you do use differing options when generating and using the precompiled header, the actual behavior is a mixture of the behavior for the options. For instance, if you use</source>
          <target state="translated">プリコンパイルされたヘッダを生成して使用する際に異なるオプションを使用した場合、実際の動作はオプションの動作が混在しています。例えば</target>
        </trans-unit>
        <trans-unit id="6615402a003808b60f77e922f8fff7dc102cea3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know the type of the operand, you can still do this, but you must use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;__auto_type&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;).</source>
          <target state="translated">オペランドのタイプがわからない場合でも、これを行うことができますが、 &lt;code&gt;typeof&lt;/code&gt; または &lt;code&gt;__auto_type&lt;/code&gt; を使用する必要があります（&lt;a href=&quot;typeof#Typeof&quot;&gt;Typeofを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c085ab8b04d2de8c46788dc7f554d15750ff8940" translate="yes" xml:space="preserve">
          <source>If you have trouble using GCC.</source>
          <target state="translated">GCCを使っていて困ったことがあれば</target>
        </trans-unit>
        <trans-unit id="4152886dce97a4266954e0590ef45338d28d4f3b" translate="yes" xml:space="preserve">
          <source>If you invoke &lt;code&gt;gcov&lt;/code&gt; with multiple input files, the contributions from each input file are summed. Typically you would invoke it with the same list of files as the final link of your executable.</source>
          <target state="translated">複数の入力ファイルを使用して &lt;code&gt;gcov&lt;/code&gt; を呼び出す場合、各入力ファイルからの寄与が合計されます。通常は、実行可能ファイルの最終リンクと同じファイルリストを使用して呼び出します。</target>
        </trans-unit>
        <trans-unit id="f78ebb50b8c8401143c21ca977cd992331a9d441" translate="yes" xml:space="preserve">
          <source>If you invoke GCC in parallel, compiling several different source files that share a common base name in different subdirectories or the same source file compiled for multiple output destinations, it is likely that the different parallel compilers will interfere with each other, and overwrite the temporary files. For instance:</source>
          <target state="translated">GCC を並列に起動して、異なるサブディレクトリに共通のベース名を持つ複数の異なるソースファイルをコンパイルしたり、複数の出力先に向けてコンパイルされた同じソースファイルをコンパイルしたりすると、異なる並列コンパイラが互いに干渉して一時ファイルを上書きしてしまう可能性があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="339873ba9c437ffb773ea97b43d76bef2cd414b1" translate="yes" xml:space="preserve">
          <source>If you know the above will only be reading a ten byte array then you could instead use a memory input like: &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt;.</source>
          <target state="translated">上記が10バイトの配列しか読み取らないことがわかっている場合は、代わりに次のようなメモリ入力を使用できます。 &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="888965c4f3b549f1f0054a0f4c6ff67115a7146e" translate="yes" xml:space="preserve">
          <source>If you need a Standard compliant library, then you need to find one, as GCC does not provide one. The GNU C library (called &lt;code&gt;glibc&lt;/code&gt;) provides ISO C, POSIX, BSD, SystemV and X/Open compatibility for GNU/Linux and HURD-based GNU systems; no recent version of it supports other systems, though some very old versions did. Version 2.2 of the GNU C library includes nearly complete C99 support. You could also ask your operating system vendor if newer libraries are available.</source>
          <target state="translated">標準準拠のライブラリが必要な場合は、GCCがライブラリを提供していないため、ライブラリを見つける必要があります。GNU Cライブラリ（ &lt;code&gt;glibc&lt;/code&gt; と呼ばれる）は、ISO C、POSIX、BSD、SystemV、およびX / Openとの互換性をGNU / LinuxおよびHURDベースのGNUシステムに提供します。他のシステムをサポートする最近のバージョンはありませんが、非常に古いバージョンはサポートしていました。GNU Cライブラリのバージョン2.2には、ほぼ完全なC99サポートが含まれています。新しいライブラリが利用可能かどうかをオペレーティングシステムのベンダーに問い合わせることもできます。</target>
        </trans-unit>
        <trans-unit id="2295b8a8afca796af761f37955429fb2dfb303ab" translate="yes" xml:space="preserve">
          <source>If you need to precompile the same header file for different languages, targets, or compiler options, you can instead make a &lt;em&gt;directory&lt;/em&gt; named like</source>
          <target state="translated">異なる言語、ターゲット、またはコンパイラオプションに対して同じヘッダーファイルをプリコンパイルする必要がある場合は、代わりに次のような名前の&lt;em&gt;ディレクトリ&lt;/em&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="66af9e4f8d685ec9e9b50745c5edb5982da51a9b" translate="yes" xml:space="preserve">
          <source>If you need to read the volatile object after an assignment has occurred, you must use a separate expression with an intervening sequence point.</source>
          <target state="translated">代入が発生した後に揮発性オブジェクトを読み込む必要がある場合は、シーケンスポイントを介在させた別の式を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4adf572d889db0dbe74d88ef8bb1d09b3f0a1cca" translate="yes" xml:space="preserve">
          <source>If you only want some of the stages of compilation, you can use</source>
          <target state="translated">コンパイルのいくつかの段階だけが必要な場合は</target>
        </trans-unit>
        <trans-unit id="0a3a127b379e27c78040de67c2f4f38df68d44ac" translate="yes" xml:space="preserve">
          <source>If you plan to use &lt;code&gt;gcov&lt;/code&gt; to help optimize your code, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">コードの最適化に &lt;code&gt;gcov&lt;/code&gt; を使用する場合は、まず特別なGCCオプションを使用してプログラムをコンパイルする必要があります '</target>
        </trans-unit>
        <trans-unit id="89a00b1663443b615a5e906a67310faf3ab9d3e4" translate="yes" xml:space="preserve">
          <source>If you receive a linker error message that saying you have overflowed the available TOC space, you can reduce the amount of TOC space used with the</source>
          <target state="translated">使用可能なTOCスペースがオーバーフローしたというリンカのエラーメッセージが表示された場合、使用するTOCスペースの量を減らすには</target>
        </trans-unit>
        <trans-unit id="be0941cee2405a3cef991d81a7e61b7d98631fbb" translate="yes" xml:space="preserve">
          <source>If you replaced &lt;code&gt;short_a&lt;/code&gt; with &lt;code&gt;short&lt;/code&gt; in the variable declaration, the above program would abort when compiled with</source>
          <target state="translated">変数宣言で &lt;code&gt;short_a&lt;/code&gt; を &lt;code&gt;short&lt;/code&gt; に置き換えた場合、上記のプログラムは、</target>
        </trans-unit>
        <trans-unit id="35d1d8ed39d0b8c7b146243c81d4152cdc148fcf" translate="yes" xml:space="preserve">
          <source>If you specify &amp;lsquo;</source>
          <target state="translated">「を指定した場合</target>
        </trans-unit>
        <trans-unit id="4ecc2b870bc1bb7d3b980a000c9f6dcec5995fb9" translate="yes" xml:space="preserve">
          <source>If you specify both &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; in the function definition, then the definition is used only for inlining. In no case is the function compiled on its own, not even if you refer to its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it.</source>
          <target state="translated">関数定義で &lt;code&gt;inline&lt;/code&gt; と &lt;code&gt;extern&lt;/code&gt; の両方を指定した場合、その定義はインライン化のみに使用されます。アドレスを明示的に参照したとしても、関数が単独でコンパイルされることはありません。そのようなアドレスは、関数を宣言しただけで関数を定義していないかのように、外部参照になります。</target>
        </trans-unit>
        <trans-unit id="5d47cb731371550330a13465931e86c5d293dfdf" translate="yes" xml:space="preserve">
          <source>If you specify command-line switches such as</source>
          <target state="translated">のようなコマンドラインスイッチを指定した場合</target>
        </trans-unit>
        <trans-unit id="6dac1f1fb59b9ffca6f761fa60561e481b2e6270" translate="yes" xml:space="preserve">
          <source>If you specify neither</source>
          <target state="translated">どちらも指定しない場合</target>
        </trans-unit>
        <trans-unit id="c921e7f4f95a0df5eb637ba56c7aabab978aaee6" translate="yes" xml:space="preserve">
          <source>If you specify the optional &lt;var&gt;n&lt;/var&gt;, the optimization and code generation done at link time is executed in parallel using &lt;var&gt;n&lt;/var&gt; parallel jobs by utilizing an installed &lt;code&gt;make&lt;/code&gt; program. The environment variable &lt;code&gt;MAKE&lt;/code&gt; may be used to override the program used. The default value for &lt;var&gt;n&lt;/var&gt; is 1.</source>
          <target state="translated">オプションの &lt;var&gt;n&lt;/var&gt; を指定すると、リンク時に行われる最適化とコード生成は、インストールされている &lt;code&gt;make&lt;/code&gt; プログラムを使用して、 &lt;var&gt;n&lt;/var&gt; 個の並列ジョブを使用して並列に実行されます。環境変数 &lt;code&gt;MAKE&lt;/code&gt; を使用して、使用するプログラムをオーバーライドできます。 &lt;var&gt;n&lt;/var&gt; のデフォルト値は1です。</target>
        </trans-unit>
        <trans-unit id="925aa9cac99e94c7e1b3007e94e2857fd742f461" translate="yes" xml:space="preserve">
          <source>If you still run out of space in the TOC even when you specify both of these options, specify</source>
          <target state="translated">これらのオプションの両方を指定しても、TOC内のスペースが足りない場合は</target>
        </trans-unit>
        <trans-unit id="e9f3b7bcc19fa8799f793151f5d918c0eb44cc5c" translate="yes" xml:space="preserve">
          <source>If you try to call the nested function through its address after the containing function exits, all hell breaks loose. If you try to call it after a containing scope level exits, and if it refers to some of the variables that are no longer in scope, you may be lucky, but it&amp;rsquo;s not wise to take the risk. If, however, the nested function does not refer to anything that has gone out of scope, you should be safe.</source>
          <target state="translated">含まれている関数が終了した後で、ネストされた関数をそのアドレスで呼び出そうとすると、すべての地獄が壊れます。含まれているスコープレベルが終了した後にそれを呼び出そうとした場合、スコープから外れた変数の一部を参照している場合は幸運かもしれませんが、リスクを取るのは賢明ではありません。ただし、ネストされた関数がスコープから外れたものを参照しない場合は、安全である必要があります。</target>
        </trans-unit>
        <trans-unit id="f927a3385a1b1e51d949287257534f3a4443c5fc" translate="yes" xml:space="preserve">
          <source>If you update the system&amp;rsquo;s header files, such as by installing a new system version, the fixed header files of GCC are not automatically updated. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">新しいシステムバージョンをインストールするなどしてシステムのヘッダーファイルを更新しても、GCCの固定ヘッダーファイルは自動的には更新されません。にインストールされている &lt;code&gt;mkheaders&lt;/code&gt; スクリプトを使用して更新できます。</target>
        </trans-unit>
        <trans-unit id="41fb10bf832524090b9ab05176d0ed5567a508f5" translate="yes" xml:space="preserve">
          <source>If you use</source>
          <target state="translated">を使用する場合は</target>
        </trans-unit>
        <trans-unit id="6a51a2c7443f8a2b859ded2344689b9dd5a96d35" translate="yes" xml:space="preserve">
          <source>If you use &amp;lsquo;</source>
          <target state="translated">あなたが使用する場合</target>
        </trans-unit>
        <trans-unit id="1eb60252a45f0973d8c5683aecd8b85683d307d3" translate="yes" xml:space="preserve">
          <source>If you use both this option and the</source>
          <target state="translated">このオプションと</target>
        </trans-unit>
        <trans-unit id="daf14f5a30ee5ca1525b7be167b116e92944e7ce" translate="yes" xml:space="preserve">
          <source>If you use multiple</source>
          <target state="translated">複数の</target>
        </trans-unit>
        <trans-unit id="9b9352d7bdc60d6db5e3f97a4150de5fffc4de3b" translate="yes" xml:space="preserve">
          <source>If you use one big file to do the instantiations, you may want to compile it without</source>
          <target state="translated">1つの大きなファイルを使ってインスタンションを行う場合は</target>
        </trans-unit>
        <trans-unit id="d5658f3cda5684fd922808fa10e4319b5a492e30" translate="yes" xml:space="preserve">
          <source>If you use one of the &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; address spaces you must arrange your linker script to locate the &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; sections according to your needs.</source>
          <target state="translated">&lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; アドレススペースの1つを使用する場合、リンカスクリプトを &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; して、必要に応じて.progmem &lt;var&gt;N&lt;/var&gt; .dataセクションを見つける必要があります。</target>
        </trans-unit>
        <trans-unit id="d09fff5b63f8a00b0aa50a2fbc9e05727d5eaa55" translate="yes" xml:space="preserve">
          <source>If you use the</source>
          <target state="translated">を使用している場合は</target>
        </trans-unit>
        <trans-unit id="0c2eabb891cc235e2e02c3ade4b4c6be5a7c7761" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;inline&lt;/code&gt; qualifier, then for inlining purposes the size of the &lt;code&gt;asm&lt;/code&gt; statement is taken as the smallest size possible (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 修飾子を使用する場合、インライン化の目的で、 &lt;code&gt;asm&lt;/code&gt; ステートメントのサイズは可能な限り最小のサイズと見なされます（&lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;asmのサイズを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1d0a1d145962ca52d117f00e82a8a34efa685f04" translate="yes" xml:space="preserve">
          <source>If you use the ISA 3.0 instruction set (</source>
          <target state="translated">ISA 3.0 命令セット (</target>
        </trans-unit>
        <trans-unit id="3b409b718d6983a24e16eccb9909125cc43f2697" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes a separate argument, you must use</source>
          <target state="translated">別の引数を取るオプションを渡したい場合は</target>
        </trans-unit>
        <trans-unit id="01e57dac3d1293541430d1619103f3be6de91e09" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes an argument, you must use</source>
          <target state="translated">引数を取るオプションを渡したい場合は</target>
        </trans-unit>
        <trans-unit id="57c0d52053735b1deca65f8fe95302a40e91aba4" translate="yes" xml:space="preserve">
          <source>If you want to pass the array first and the length afterward, you can use a forward declaration in the parameter list&amp;mdash;another GNU extension.</source>
          <target state="translated">最初に配列を渡し、その後に長さを渡したい場合は、パラメータリストで前方宣言を使用できます&amp;mdash;別のGNU拡張機能です。</target>
        </trans-unit>
        <trans-unit id="714721fbe0a57745166a774e2ee80658db42639e" translate="yes" xml:space="preserve">
          <source>If you want to recompile source files that do not actually use your global register variable so they do not use the specified register for any other purpose, you need not actually add the global register declaration to their source code. It suffices to specify the compiler option</source>
          <target state="translated">グローバルレジスタ変数を実際に使用しないソースファイルを再コンパイルして、指定されたレジスタを他の目的で使用しないようにしたい場合は、実際にグローバルレジスタ宣言をソースコードに追加する必要はありません。コンパイラオプション</target>
        </trans-unit>
        <trans-unit id="63035fe8f0fef33a809f5df21a239bff0f434564" translate="yes" xml:space="preserve">
          <source>If you want to warn about code that uses the uninitialized value of the variable in its own initializer, use the</source>
          <target state="translated">変数の初期化されていない値を自身のイニシャライザで使用しているコードについて警告したい場合は</target>
        </trans-unit>
        <trans-unit id="1f9d39a0d621d29f6b4df2f19650e527eb6087e6" translate="yes" xml:space="preserve">
          <source>If you want your own collection object to be usable with fast enumeration, you need to have it implement the method</source>
          <target state="translated">自分のコレクションオブジェクトを高速な列挙で使えるようにしたい場合は、そのオブジェクトに</target>
        </trans-unit>
        <trans-unit id="66ce7bf0d3f3a0ea10a8e8123399a75d9055c922" translate="yes" xml:space="preserve">
          <source>If you wish to define a function-like macro on the command line, write its argument list with surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells, so you should quote the option. With &lt;code&gt;sh&lt;/code&gt; and &lt;code&gt;csh&lt;/code&gt;,</source>
          <target state="translated">コマンドラインで関数のようなマクロを定義したい場合は、引数リストを等号（ある場合）の前に括弧で囲みます。括弧はほとんどのシェルにとって意味があるため、オプションを引用する必要があります。 &lt;code&gt;sh&lt;/code&gt; と &lt;code&gt;csh&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="344eca13d4f5455ce9ed14a9174152844b040aa2" translate="yes" xml:space="preserve">
          <source>If your code needs to support multiple assembler dialects (for example, if you are writing public headers that need to support a variety of compilation options), use constructs of this form:</source>
          <target state="translated">コードが複数のアセンブラの方言をサポートする必要がある場合 (例えば、様々なコンパイルオプションをサポートする必要があるパブリックヘッダを書く場合など)、この形式のコンストラクトを使用します。</target>
        </trans-unit>
        <trans-unit id="489624b43d62801c5096e0cef6c84a4128aa3f2e" translate="yes" xml:space="preserve">
          <source>If, for some reason, you want to include letter &amp;lsquo;</source>
          <target state="translated">何らかの理由で文字 'を含めたい場合</target>
        </trans-unit>
        <trans-unit id="8ae25dcd1480cd59f0776f409a8f3b4cc8c76dee" translate="yes" xml:space="preserve">
          <source>If, instead, you use the GCC driver to create shared libraries, you may find that they are not always linked with the shared</source>
          <target state="translated">代わりにGCCドライバを使用して共有ライブラリを作成した場合、共有ライブラリが必ずしも共有されている</target>
        </trans-unit>
        <trans-unit id="7d34e1e1ae89800680b004320ebb086b09cf39f6" translate="yes" xml:space="preserve">
          <source>Ignore the &lt;code&gt;#ident&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;#ident&lt;/code&gt; ディレクティブは無視してください。</target>
        </trans-unit>
        <trans-unit id="2e82df27ea7fceb83aac6e28c3926e8f714c2de0" translate="yes" xml:space="preserve">
          <source>Immediate 15-bit unsigned integer</source>
          <target state="translated">即時15ビット符号なし整数</target>
        </trans-unit>
        <trans-unit id="25ebf6700b63624d3804d20faa7de74e2dccc87c" translate="yes" xml:space="preserve">
          <source>Immediate 16-bit signed integer</source>
          <target state="translated">即時16ビット符号付き整数</target>
        </trans-unit>
        <trans-unit id="c2ce26e27211c1d69d3a406bee1c55a3cfc3b488" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit integer in range -16..4294967295 (i.e. 32-bit unsigned integer or &amp;lsquo;</source>
          <target state="translated">-16..4294967295の範囲の即時32ビット整数（つまり、32ビット符号なし整数または '</target>
        </trans-unit>
        <trans-unit id="7ce04d3df5932775f166ab61ebe67634f6cff4f5" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit signed integer that can be attached to an instruction encoding</source>
          <target state="translated">命令のエンコーディングに付けられる32ビット符号付き整数。</target>
        </trans-unit>
        <trans-unit id="95af07c0237447c6b15292985f8e2b14ec413d35" translate="yes" xml:space="preserve">
          <source>Immediate 64-bit constant that can be split into two &amp;lsquo;</source>
          <target state="translated">2つに分割できる即時64ビット定数 '</target>
        </trans-unit>
        <trans-unit id="aea4f97beb4642aabcdf84f409c00fa5cd5c2c91" translate="yes" xml:space="preserve">
          <source>Immediate constant -1</source>
          <target state="translated">即定数 -1</target>
        </trans-unit>
        <trans-unit id="293172a51e9ef5dbf0bb7e7f454796275cc1f905" translate="yes" xml:space="preserve">
          <source>Immediate constant that can be inlined in an instruction encoding: integer -16..64, or float 0.0, +/-0.5, +/-1.0, +/-2.0, +/-4.0, 1.0/(2.0*PI)</source>
          <target state="translated">命令エンコーディングでインライン化できる即定数:整数 -16~64、または float 0.0,+/0.5,+/1.0,+/2.0,+/4.0,1.0/(2.0*PI)</target>
        </trans-unit>
        <trans-unit id="a56a5101429aaf4e851ed409b055e85e8d91d6b8" translate="yes" xml:space="preserve">
          <source>Immediate integer in the range -16 to 64</source>
          <target state="translated">16~64の範囲の即時整数</target>
        </trans-unit>
        <trans-unit id="bf320f9d296e81a49f73cab866d640531aefcfad" translate="yes" xml:space="preserve">
          <source>Implement (do not implement) -fno-plt and long calls using an inline PLT call sequence that supports lazy linking and long calls to functions in dlopen&amp;rsquo;d shared libraries. Inline PLT calls are only supported on PowerPC64 ELFv2 and 32-bit PowerPC systems with newer GNU linkers, and are enabled by default if the support is detected when configuring GCC, and, in the case of 32-bit PowerPC, if GCC is configured with</source>
          <target state="translated">遅延リンクとdlopenされた共有ライブラリ内の関数への長い呼び出しをサポートするインラインPLT呼び出しシーケンスを使用して、-fno-pltと長い呼び出しを実装します（実装しません）。インラインPLT呼び出しは、新しいGNUリンカーを備えたPowerPC64 ELFv2および32ビットPowerPCシステムでのみサポートされ、GCCの構成時にサポートが検出された場合はデフォルトで有効になり、32ビットPowerPCの場合はGCCが</target>
        </trans-unit>
        <trans-unit id="f6c8b1a3b3ce20b0f24d10325bb5a9fda3cc0723" translate="yes" xml:space="preserve">
          <source>Implies no inter-thread ordering constraints.</source>
          <target state="translated">スレッド間の順序付け制約がないことを暗示します。</target>
        </trans-unit>
        <trans-unit id="fe96af122b5bf84f1ddc818f1e5f57ac3e7dac8c" translate="yes" xml:space="preserve">
          <source>Improved AMD Athlon CPU with MMX, 3DNow!, enhanced 3DNow! and full SSE instruction set support.</source>
          <target state="translated">AMD Athlon CPUをMMX、3DNow!、強化された3DNow!、SSE命令セットのフルサポートで改善。</target>
        </trans-unit>
        <trans-unit id="6774c0ca18d629c919e07781b4bc4345f81613ce" translate="yes" xml:space="preserve">
          <source>Improved support for generic programming.</source>
          <target state="translated">ジェネリックプログラミングのサポートを強化しました。</target>
        </trans-unit>
        <trans-unit id="bb701b014b08c67fb59b6b752448015c50d54c43" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with 64-bit extensions, MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">Intel Pentium 4 CPUの改良版で、64ビット拡張、MMX、SSE、SSE2、SSE3の命令セットをサポート。</target>
        </trans-unit>
        <trans-unit id="ed782143dc7e1163d3eb2323e646f10006e40097" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">MMX、SSE、SSE2、SSE3命令セットをサポートしたIntel Pentium 4 CPUの改良版。</target>
        </trans-unit>
        <trans-unit id="8a73deb51d5b08d19d0486183c731c2e4df58a6c" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K6 CPU with MMX and 3DNow! instruction set support.</source>
          <target state="translated">AMD K6 CPUのMMXと3DNow!命令セットをサポートした改良版。</target>
        </trans-unit>
        <trans-unit id="0640019f239b6c731b94ce729c56eafeb42fbdce" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K8 cores with SSE3 instruction set support.</source>
          <target state="translated">AMD K8コアのSSE3命令セットをサポートした改良版。</target>
        </trans-unit>
        <trans-unit id="faa77d9eb98f8c3bb3a99e6c2fd6a673c7a1ef4f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; expands to &lt;code&gt;((void *)0)&lt;/code&gt;. GCC does not provide the other headers which define &lt;code&gt;NULL&lt;/code&gt; and some library implementations may use other definitions in those headers.</source>
          <target state="translated">では &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 、 &lt;code&gt;NULL&lt;/code&gt; はに展開 &lt;code&gt;((void *)0)&lt;/code&gt; 。GCCは、 &lt;code&gt;NULL&lt;/code&gt; を定義する他のヘッダーを提供していません。一部のライブラリ実装では、それらのヘッダーで他の定義を使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="94f792f5735cf258c95fd93f04f6f7c58a83d70b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;get_i()&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; is not used in a dependent context, so the compiler will look for a name declared at the enclosing namespace scope (which is the global scope here). It will not look into the base class, since that is dependent and you may declare specializations of &lt;code&gt;Base&lt;/code&gt; even after declaring &lt;code&gt;Derived&lt;/code&gt;, so the compiler cannot really know what &lt;code&gt;i&lt;/code&gt; would refer to. If there is no global variable &lt;code&gt;i&lt;/code&gt;, then you will get an error message.</source>
          <target state="translated">で &lt;code&gt;get_i()&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; コンパイラは（ここではグローバルスコープである）を囲む名前空間スコープで宣言された名前を探しますので、依存コンテキストで使用されていません。これは依存しており、 &lt;code&gt;Derived&lt;/code&gt; を宣言した後でも &lt;code&gt;Base&lt;/code&gt; の特殊化を宣言する可能性があるため、基本クラスを調べないため、コンパイラーは &lt;code&gt;i&lt;/code&gt; が何を参照するのかを実際に知ることができません。グローバル変数 &lt;code&gt;i&lt;/code&gt; がない場合は、エラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="1efd435b2fd7ff4eeb1d3caefe51e97ec2eabff1" translate="yes" xml:space="preserve">
          <source>In C code, this option controls the placement of global variables defined without an initializer, known as &lt;em&gt;tentative definitions&lt;/em&gt; in the C standard. Tentative definitions are distinct from declarations of a variable with the &lt;code&gt;extern&lt;/code&gt; keyword, which do not allocate storage.</source>
          <target state="translated">Cコードでは、このオプションは、C標準では&lt;em&gt;暫定的な定義&lt;/em&gt;と呼ばれる、初期化子なしで定義されたグローバル変数の配置を制御します。暫定的な定義は、ストレージを割り当てない &lt;code&gt;extern&lt;/code&gt; キーワードを使用した変数の宣言とは異なります。</target>
        </trans-unit>
        <trans-unit id="986d71cafa07e6d2f235ac194e79a8e70cb9cccf" translate="yes" xml:space="preserve">
          <source>In C mode, this is equivalent to</source>
          <target state="translated">Cモードでは、これは</target>
        </trans-unit>
        <trans-unit id="6e29cf5656ff22cce837fe364a063ee35412d5b9" translate="yes" xml:space="preserve">
          <source>In C this option does not warn about the universal zero initializer &amp;lsquo;</source>
          <target state="translated">Cでは、このオプションはユニバーサルゼロ初期化子について警告しません '</target>
        </trans-unit>
        <trans-unit id="2f3a5ba446573452e29640c8fc16cb4e894d48dc" translate="yes" xml:space="preserve">
          <source>In C++ code, this allows member names in structures to be similar to previous types declarations.</source>
          <target state="translated">C++コードでは、これにより、構造体のメンバ名を以前の型宣言と同様のものにすることができます。</target>
        </trans-unit>
        <trans-unit id="c8175f71005ecf03750f6f6a8eb8dfe31c736137" translate="yes" xml:space="preserve">
          <source>In C++ the value of an object is only affected by changes within its lifetime: when the constructor begins, the object has an indeterminate value, and any changes during the lifetime of the object are dead when the object is destroyed. Normally dead store elimination will take advantage of this; if your code relies on the value of the object storage persisting beyond the lifetime of the object, you can use this flag to disable this optimization. To preserve stores before the constructor starts (e.g. because your operator new clears the object storage) but still treat the object as dead after the destructor you, can use</source>
          <target state="translated">C++では、オブジェクトの値はその有効期間内の変更によってのみ影響を受けます。コンストラクタが開始されると、オブジェクトは不確定な値を持ち、オブジェクトの有効期間内の変更は、オブジェクトが破棄されるとデッドストアとなります。通常、デッドストアの除去はこれを利用します。コードがオブジェクトの寿命を超えてもオブジェクトのストレージの値が維持されることに依存している場合は、このフラグを使用してこの最適化を無効にすることができます。コンストラクタが開始される前にストアを保存しておき(たとえば演算子 new がオブジェクトストレージをクリアするなど)、 デストラクタの後にオブジェクトをデッドストアとして扱うには</target>
        </trans-unit>
        <trans-unit id="168fb41a49baf3aa442f73f3ecb6a40cd4d6ca59" translate="yes" xml:space="preserve">
          <source>In C++, &amp;lsquo;</source>
          <target state="translated">C ++では、 '</target>
        </trans-unit>
        <trans-unit id="1bcce97889f7dbf32fa6b64e8c64b08099b3f7a1" translate="yes" xml:space="preserve">
          <source>In C++, attribute visibility (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) can also be applied to class, struct, union and enum types. Unlike other type attributes, the attribute must appear between the initial keyword and the name of the type; it cannot appear after the body of the type.</source>
          <target state="translated">C ++では、属性の可視性（「&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数の属性&lt;/a&gt;」を参照）は、クラス、構造体、共用体、列挙型にも適用できます。他のタイプ属性とは異なり、属性は最初のキーワードとタイプの名前の間に出現する必要があります。タイプの本体の後に表示することはできません。</target>
        </trans-unit>
        <trans-unit id="41407820aea4af6aceb3725e14d20bcfa5717ed8" translate="yes" xml:space="preserve">
          <source>In C++, if a template argument has limited visibility, this restriction is implicitly propagated to the template instantiation. Otherwise, template instantiations and specializations default to the visibility of their template.</source>
          <target state="translated">C++では、テンプレート引数の可視性が制限されている場合、この制限は暗黙的にテンプレート・インスタンスに伝搬されます。それ以外の場合は、テンプレートのインスタンス化と特殊化は、そのテンプレートの可視性をデフォルトとします。</target>
        </trans-unit>
        <trans-unit id="453e27477f405b0f81788514a49ffd79d08ff550" translate="yes" xml:space="preserve">
          <source>In C++, if an initializer is present for a thread-local variable, it must be a &lt;var&gt;constant-expression&lt;/var&gt;, as defined in 5.19.2 of the ANSI/ISO C++ standard.</source>
          <target state="translated">C ++では、スレッドローカル変数の初期化子が存在する場合、ANSI / ISO C ++標準の5.19.2で定義されているように、それは &lt;var&gt;constant-expression&lt;/var&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9e8da9f4a402f87aeb0e1e0768c85b6e521a3ae7" translate="yes" xml:space="preserve">
          <source>In C++, pointer to member functions (PMFs) are implemented using a wide pointer of sorts to handle all the possible call mechanisms; the PMF needs to store information about how to adjust the &amp;lsquo;</source>
          <target state="translated">C ++では、メンバー関数（PMF）へのポインターは、考えられるすべての呼び出しメカニズムを処理するために、ソートのワイドポインターを使用して実装されます。PMFは、調整方法に関する情報を保存する必要があります '</target>
        </trans-unit>
        <trans-unit id="34a26947af0331ebcf8b3ff5e4127f49a113bd19" translate="yes" xml:space="preserve">
          <source>In C++, the &lt;code&gt;ifunc&lt;/code&gt; attribute takes a string that is the mangled name of the resolver function. A C++ resolver for a non-static member function of class &lt;code&gt;C&lt;/code&gt; should be declared to return a pointer to a non-member function taking pointer to &lt;code&gt;C&lt;/code&gt; as the first argument, followed by the same arguments as of the implementation function. G++ checks the signatures of the two functions and issues a</source>
          <target state="translated">C ++では、 &lt;code&gt;ifunc&lt;/code&gt; 属性はリゾルバー関数のマングル名である文字列を取ります。A C ++クラスの非静的メンバ関数のためのリゾルバ &lt;code&gt;C&lt;/code&gt; は、ポインタを取る非メンバ関数へのポインタを返すように宣言されるべきである &lt;code&gt;C&lt;/code&gt; インプリメンテーション機能のと同じ引数が続く最初の引数として、。G ++は2つの関数の署名をチェックし、</target>
        </trans-unit>
        <trans-unit id="dae3c25a08855a03a679edfb667679b322123fbc" translate="yes" xml:space="preserve">
          <source>In C++, the logic operators &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; are available for vectors. &lt;code&gt;!v&lt;/code&gt; is equivalent to &lt;code&gt;v == 0&lt;/code&gt;, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; and &lt;code&gt;a || b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 | b!=0&lt;/code&gt;. For mixed operations between a scalar &lt;code&gt;s&lt;/code&gt; and a vector &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; is equivalent to &lt;code&gt;s?v!=0:0&lt;/code&gt; (the evaluation is short-circuit) and &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; is equivalent to &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt;.</source>
          <target state="translated">C ++では、論理演算子 &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; ベクトルに使用できます。 &lt;code&gt;!v&lt;/code&gt; は &lt;code&gt;v == 0&lt;/code&gt; と同等であり、 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; は &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; および &lt;code&gt;a || b&lt;/code&gt; と同等です。bはaと同等 &lt;code&gt;a!=0 | b!=0&lt;/code&gt; 。スカラー &lt;code&gt;s&lt;/code&gt; とベクトル &lt;code&gt;v&lt;/code&gt; の間の混合演算の場合、 &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; は &lt;code&gt;s?v!=0:0&lt;/code&gt; （評価は短絡）と同等であり、 &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; は &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="260b901dabc2f639a1fcfb92f83b3a8bfc6792cb" translate="yes" xml:space="preserve">
          <source>In C++, the ternary operator &lt;code&gt;?:&lt;/code&gt; is available. &lt;code&gt;a?b:c&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are vectors of the same type and &lt;code&gt;a&lt;/code&gt; is an integer vector with the same number of elements of the same size as &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, computes all three arguments and creates a vector &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt;. Note that unlike in OpenCL, &lt;code&gt;a&lt;/code&gt; is thus interpreted as &lt;code&gt;a != 0&lt;/code&gt; and not &lt;code&gt;a &amp;lt; 0&lt;/code&gt;. As in the case of binary operations, this syntax is also accepted when one of &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; is a scalar that is then transformed into a vector. If both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are scalars and the type of &lt;code&gt;true?b:c&lt;/code&gt; has the same size as the element type of &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are converted to a vector type whose elements have this type and with the same number of elements as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">C ++では、三項演算子 &lt;code&gt;?:&lt;/code&gt; を使用できます。 &lt;code&gt;a?b:c&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; と &lt;code&gt;c&lt;/code&gt; 同じタイプのベクトルであり、同じサイズの同じ要素数を有する整数のベクトルであり &lt;code&gt;b&lt;/code&gt; と &lt;code&gt;c&lt;/code&gt; 、すべての3つの引数を計算し、ベクトル作成 &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt; 。 OpenCLとは異なり、 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;a != 0&lt;/code&gt; として解釈され、 &lt;code&gt;a &amp;lt; 0&lt;/code&gt; はないことに注意してください。バイナリ演算の場合と同様に、この構文は、 &lt;code&gt;b&lt;/code&gt; または &lt;code&gt;c&lt;/code&gt; のいずれかがスカラーで、その後ベクトルに変換される場合にも受け入れられます。もし両方 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; そして &lt;code&gt;c&lt;/code&gt; スカラーとの一種である &lt;code&gt;true?b:c&lt;/code&gt; の要素型と同じサイズを有し、次いで、 &lt;code&gt;b&lt;/code&gt; のおよび &lt;code&gt;c&lt;/code&gt; が要素がこのタイプを持っておりと同数の要素を有するベクトル型に変換されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e8e3384895cb64dc59dfb4ef3c2eae30e005995" translate="yes" xml:space="preserve">
          <source>In C++, the visibility attribute applies to types as well as functions and objects, because in C++ types have linkage. A class must not have greater visibility than its non-static data member types and bases, and class members default to the visibility of their class. Also, a declaration without explicit visibility is limited to the visibility of its type.</source>
          <target state="translated">C++では、型にはリンケージがあるため、可視性属性は関数やオブジェクトだけでなく、型にも適用されます。クラスは、その非静的データ・メンバの型やベースよりも大きな可視性を持っていてはならず、クラス・メンバはそのクラスの可視性をデフォルトとしています。また、明示的な可視性を持たない宣言は、その型の可視性に制限されます。</target>
        </trans-unit>
        <trans-unit id="9870b14c476e69190f3f39c0be8be66122cac26a" translate="yes" xml:space="preserve">
          <source>In C++, the warning is issued when an explicit specialization of a primary template declared with attribute &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;assume_aligned&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;format_arg&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, or &lt;code&gt;nonnull&lt;/code&gt; is declared without it. Attributes &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;warning&lt;/code&gt; suppress the warning. (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">C ++では、属性 &lt;code&gt;alloc_align&lt;/code&gt; 、 &lt;code&gt;alloc_size&lt;/code&gt; 、 &lt;code&gt;assume_aligned&lt;/code&gt; 、 &lt;code&gt;format&lt;/code&gt; 、 &lt;code&gt;format_arg&lt;/code&gt; 、 &lt;code&gt;malloc&lt;/code&gt; 、または &lt;code&gt;nonnull&lt;/code&gt; で宣言されたプライマリテンプレートの明示的な特殊化がそれなしで宣言されると、警告が発行されます。 &lt;code&gt;deprecated&lt;/code&gt; 、 &lt;code&gt;error&lt;/code&gt; 、および &lt;code&gt;warning&lt;/code&gt; 属性は警告を抑制します。（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="9914fa32f31272fbd1b3c9fd5655fe7c161328ef" translate="yes" xml:space="preserve">
          <source>In C++, this attribute does not depend on &lt;code&gt;extern&lt;/code&gt; in any way, but it still requires the &lt;code&gt;inline&lt;/code&gt; keyword to enable its special behavior.</source>
          <target state="translated">C ++では、この属性は &lt;code&gt;extern&lt;/code&gt; にまったく依存していませんが、特別な動作を有効にするには &lt;code&gt;inline&lt;/code&gt; キーワードが必要です。</target>
        </trans-unit>
        <trans-unit id="1330ec9305a2cf36952504f041eeaa71d08a1559" translate="yes" xml:space="preserve">
          <source>In C++, this pragma silently applies only to declarations with &amp;ldquo;C&amp;rdquo; linkage. Again, &lt;code&gt;asm&lt;/code&gt; labels do not have this restriction.</source>
          <target state="translated">C ++では、このプラグマは「C」リンケージの宣言にのみ暗黙的に適用されます。繰り返しますが、 &lt;code&gt;asm&lt;/code&gt; ラベルにはこの制限はありません。</target>
        </trans-unit>
        <trans-unit id="4f1560146bfb02b0050b7346bcee56f1168f8456" translate="yes" xml:space="preserve">
          <source>In C++, this switch only affects the &lt;code&gt;typeof&lt;/code&gt; keyword, since &lt;code&gt;asm&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt; are standard keywords. You may want to use the</source>
          <target state="translated">C ++では、 &lt;code&gt;asm&lt;/code&gt; と &lt;code&gt;inline&lt;/code&gt; が標準キーワードであるため、このスイッチは &lt;code&gt;typeof&lt;/code&gt; キーワードにのみ影響します。あなたは使用したいかもしれません</target>
        </trans-unit>
        <trans-unit id="83513182660c016337c6a43ced48177d4ad0ef0c" translate="yes" xml:space="preserve">
          <source>In C++, you can mark member functions and static member variables of a class with the visibility attribute. This is useful if you know a particular method or static member variable should only be used from one shared object; then you can mark it hidden while the rest of the class has default visibility. Care must be taken to avoid breaking the One Definition Rule; for example, it is usually not useful to mark an inline method as hidden without marking the whole class as hidden.</source>
          <target state="translated">C++では、クラスのメンバ関数や静的メンバ変数を visibility 属性でマークすることができます。これは、特定のメソッドや静的メンバ変数が 1 つの共有オブジェクトからのみ使用されるべきであることがわかっている場合に便利です。例えば、クラス全体を非表示にすることなくインライン・メソッドを非表示にすることは通常は有用ではありません。</target>
        </trans-unit>
        <trans-unit id="1263d4b3bd19eaa09ddd9de78312a5a79d915aa7" translate="yes" xml:space="preserve">
          <source>In C++14, &lt;code&gt;f&lt;/code&gt; calls &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt;, but in C++17 it calls &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">C ++ 14では &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt; 呼び出しますが、C ++ 17では &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3eaf8f9d1fd2934be9e06d429d221c630b5bf0a" translate="yes" xml:space="preserve">
          <source>In C++17, the compiler is required to omit these temporaries, but this option still affects trivial member functions.</source>
          <target state="translated">C++17 では、コンパイラはこれらのテンポラリを省略する必要がありますが、このオプションはまだ些細なメンバ関数に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="2fd9362a64ee90151b4f33ed9f7535e5f0047820" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is yet another name for &lt;code&gt;__func__&lt;/code&gt;, except that at file (or, in C++, namespace scope), it evaluates to the string &lt;code&gt;&quot;top level&quot;&lt;/code&gt;. In addition, in C++, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; contains the signature of the function as well as its bare name. For example, this program:</source>
          <target state="translated">Cでは、 &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; はのためのさらに別の名前である &lt;code&gt;__func__&lt;/code&gt; 、それは文字列に評価（C ++、名前空間スコープでは、）のファイルでことを除いて、 &lt;code&gt;&quot;top level&quot;&lt;/code&gt; 。さらに、C ++では、 &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; には関数のシグネチャとその基本名が含まれています。たとえば、このプログラム：</target>
        </trans-unit>
        <trans-unit id="89c3cbeabc9fb0c94d32392b571a5dbe1ffa12b0" translate="yes" xml:space="preserve">
          <source>In C, a compound literal designates an unnamed object with static or automatic storage duration. In C++, a compound literal designates a temporary object that only lives until the end of its full-expression. As a result, well-defined C code that takes the address of a subobject of a compound literal can be undefined in C++, so G++ rejects the conversion of a temporary array to a pointer. For instance, if the array compound literal example above appeared inside a function, any subsequent use of &lt;code&gt;foo&lt;/code&gt; in C++ would have undefined behavior because the lifetime of the array ends after the declaration of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Cでは、複合リテラルは、静的または自動の保存期間を持つ名前のないオブジェクトを指定します。 C ++では、複合リテラルは、その完全式の終わりまでのみ存続する一時オブジェクトを指定します。その結果、複合リテラルのサブオブジェクトのアドレスを取得する明確に定義されたCコードは、C ++では未定義になる可能性があるため、G ++は一時配列のポインターへの変換を拒否します。たとえば、上記の配列複合リテラルの例が関数内にある場合、C ++でのその後の &lt;code&gt;foo&lt;/code&gt; の使用は、配列の有効期間が &lt;code&gt;foo&lt;/code&gt; の宣言の後に終了するため、未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="b955553d29e649b19193fbacbc412a24a27d538d" translate="yes" xml:space="preserve">
          <source>In C, emit &lt;code&gt;static&lt;/code&gt; functions that are declared &lt;code&gt;inline&lt;/code&gt; into the object file, even if the function has been inlined into all of its callers. This switch does not affect functions using the &lt;code&gt;extern inline&lt;/code&gt; extension in GNU C90. In C++, emit any and all inline functions into the object file.</source>
          <target state="translated">Cでは、関数がすべての呼び出し元にインライン化されている場合でも、オブジェクトファイルに &lt;code&gt;inline&lt;/code&gt; 宣言されている &lt;code&gt;static&lt;/code&gt; 関数を発行します。このスイッチは、GNU C90の &lt;code&gt;extern inline&lt;/code&gt; 拡張を使用する機能には影響しません。C ++では、すべてのインライン関数をオブジェクトファイルに出力します。</target>
        </trans-unit>
        <trans-unit id="3058a9d60ea1ade68bb14049e675f5bf83c7026b" translate="yes" xml:space="preserve">
          <source>In C, if the function is neither &lt;code&gt;extern&lt;/code&gt; nor &lt;code&gt;static&lt;/code&gt;, then the function is compiled as a standalone function, as well as being inlined where possible.</source>
          <target state="translated">Cでは、関数が &lt;code&gt;extern&lt;/code&gt; でも &lt;code&gt;static&lt;/code&gt; でもない場合、関数はスタンドアロン関数としてコンパイルされ、可能な場合はインライン化されます。</target>
        </trans-unit>
        <trans-unit id="e352da7bd9ce1ec016de9e2458664a9340519a89" translate="yes" xml:space="preserve">
          <source>In C/C++, every &lt;code&gt;else&lt;/code&gt; branch belongs to the innermost possible &lt;code&gt;if&lt;/code&gt; statement, which in this example is &lt;code&gt;if (b)&lt;/code&gt;. This is often not what the programmer expected, as illustrated in the above example by indentation the programmer chose. When there is the potential for this confusion, GCC issues a warning when this flag is specified. To eliminate the warning, add explicit braces around the innermost &lt;code&gt;if&lt;/code&gt; statement so there is no way the &lt;code&gt;else&lt;/code&gt; can belong to the enclosing &lt;code&gt;if&lt;/code&gt;. The resulting code looks like this:</source>
          <target state="translated">C / C ++では、 &lt;code&gt;else&lt;/code&gt; ブランチはすべて可能な限り最も内側の &lt;code&gt;if&lt;/code&gt; ステートメントに属し、この例では &lt;code&gt;if (b)&lt;/code&gt; です。上記の例で示したように、これはプログラマーが選択したインデントによってプログラマーが期待したものとは異なります。この混乱の可能性がある場合、このフラグを指定すると、GCCは警告を発行します。警告を排除するには、最も内側の &lt;code&gt;if&lt;/code&gt; ステートメントを明示的に中括弧で囲み、 &lt;code&gt;else&lt;/code&gt; が外側の &lt;code&gt;if&lt;/code&gt; に属することができないようにします。結果のコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="69cc3b441acbdbe11472c325735b27c046d27c5c" translate="yes" xml:space="preserve">
          <source>In G++, the result value of a statement expression undergoes array and function pointer decay, and is returned by value to the enclosing expression. For instance, if &lt;code&gt;A&lt;/code&gt; is a class, then</source>
          <target state="translated">G ++では、ステートメント式の結果値は配列と関数ポインターの減衰を受け、値によって囲んでいる式に返されます。たとえば、 &lt;code&gt;A&lt;/code&gt; がクラスの場合、</target>
        </trans-unit>
        <trans-unit id="2b79b7c58963843a8ca543d9e2a4ed22f6af9388" translate="yes" xml:space="preserve">
          <source>In GNU C and C++, you can use function attributes to specify certain function properties that may help the compiler optimize calls or check code more carefully for correctness. For example, you can use attributes to specify that a function never returns (&lt;code&gt;noreturn&lt;/code&gt;), returns a value depending only on the values of its arguments (&lt;code&gt;const&lt;/code&gt;), or has &lt;code&gt;printf&lt;/code&gt;-style arguments (&lt;code&gt;format&lt;/code&gt;).</source>
          <target state="translated">GNU CおよびC ++では、関数属性を使用して、コンパイラーが呼び出しを最適化したり、コードの正確性をより注意深くチェックしたりするのに役立つ特定の関数プロパティを指定できます。たとえば、属性を使用して、関数が決して戻らない（ &lt;code&gt;noreturn&lt;/code&gt; ）、その引数の値にのみ依存して値を返す（ &lt;code&gt;const&lt;/code&gt; ）、または &lt;code&gt;printf&lt;/code&gt; スタイルの引数（ &lt;code&gt;format&lt;/code&gt; ）を指定することができます。</target>
        </trans-unit>
        <trans-unit id="099e4a52fb6ed11fab7818dcdc84803658fe6ac9" translate="yes" xml:space="preserve">
          <source>In GNU C, addition and subtraction operations are supported on pointers to &lt;code&gt;void&lt;/code&gt; and on pointers to functions. This is done by treating the size of a &lt;code&gt;void&lt;/code&gt; or of a function as 1.</source>
          <target state="translated">GNU Cでは、加算と減算の演算は、 &lt;code&gt;void&lt;/code&gt; へのポインターと関数へのポインターでサポートされています。これは、 &lt;code&gt;void&lt;/code&gt; または関数のサイズを1として扱うことによって行われます。</target>
        </trans-unit>
        <trans-unit id="cca3c66936552d4dc4ee0493549030694bbe3a79" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear after the colon following a label, other than a &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label. GNU C++ only permits attributes on labels if the attribute specifier is immediately followed by a semicolon (i.e., the label applies to an empty statement). If the semicolon is missing, C++ label attributes are ambiguous, as it is permissible for a declaration, which could begin with an attribute list, to be labelled in C++. Declarations cannot be labelled in C90 or C99, so the ambiguity does not arise there.</source>
          <target state="translated">GNU Cでは、属性指定子リストは、 &lt;code&gt;case&lt;/code&gt; または &lt;code&gt;default&lt;/code&gt; ラベル以外のラベルに続くコロンの後に表示される場合があります。GNU C ++は、属性指定子の直後にセミコロンが続く場合（つまり、ラベルが空のステートメントに適用される場合）にのみラベルの属性を許可します。セミコロンがないと、C ++ラベル属性はあいまいになります。これは、属性リストで始まる宣言をC ++でラベル付けすることが許可されているためです。C90またはC99では宣言にラベルを付けることができないため、あいまいさが発生することはありません。</target>
        </trans-unit>
        <trans-unit id="00f091378926e345c0e4332aa146832525cddb05" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of a null statement. The attribute goes before the semicolon.</source>
          <target state="translated">GNU Cでは、属性指定子リストがnull文の一部として現れることがあります。属性はセミコロンの前に現れます。</target>
        </trans-unit>
        <trans-unit id="1b43625a41fcbb3b41411d6343924dd766870911" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of an enumerator. The attribute goes after the enumeration constant, before &lt;code&gt;=&lt;/code&gt;, if present. The optional attribute in the enumerator appertains to the enumeration constant. It is not possible to place the attribute after the constant expression, if present.</source>
          <target state="translated">GNU Cでは、属性指定子リストが列挙子の一部として表示される場合があります。属性は、列挙定数の後、 &lt;code&gt;=&lt;/code&gt; の前に存在します。列挙子のオプションの属性は、列挙定数に適合します。存在する場合、定数式の後に属性を配置することはできません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
