<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="">
    <body>
      <group id="">
        <trans-unit id="5e37ec7562e7c67e3ef533934ac18db7a4d66259" translate="yes" xml:space="preserve">
          <source>A signed 16 bit immediate for &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1f2bec644b602c55ff93653291917c0bee1cb5" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant (for arithmetic instructions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e07498a95ff964b95b70f9332548c0e101c48af" translate="yes" xml:space="preserve">
          <source>A signed 32-bit constant in which the lower 16 bits are zero. Such constants can be loaded using &lt;code&gt;lui&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a13d86f9687e787e9b67a4048c3e6f6a0a655af" translate="yes" xml:space="preserve">
          <source>A single register. If &lt;var&gt;n&lt;/var&gt; is in the range 0 to 7, the corresponding D register. If it is &lt;code&gt;A&lt;/code&gt;, then the register P0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862eefd77275509cc300d2e8b64b0bd59d6e0627" translate="yes" xml:space="preserve">
          <source>A specification has the syntax [&amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b75792a16ebbcbf75343206f45b552f9ca68dac" translate="yes" xml:space="preserve">
          <source>A status register (&lt;code&gt;rmsr&lt;/code&gt;, &lt;code&gt;$fcc1&lt;/code&gt; to &lt;code&gt;$fcc7&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8617da8fc23fdb13a32d7e55b2af3a58c983bdf6" translate="yes" xml:space="preserve">
          <source>A string constant specifying constraints on the placement of the operand; See &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;, for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bed63450bff092e0c3ca584fb2ddae5e2d82e2a" translate="yes" xml:space="preserve">
          <source>A structure containing a flexible array member, or a union containing such a structure (possibly recursively), may not be a member of a structure or an element of an array. (However, these uses are permitted by GCC as extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f3f44cecb7edd4bea911bfc4063d4f75195a8c" translate="yes" xml:space="preserve">
          <source>A symbol in the text segment of the current file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a9278d05f000d4c7a06aca9fe905b8fb5008bb" translate="yes" xml:space="preserve">
          <source>A symbol reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceac75b89def52cbcbd311ef92b55a54ff3eba6e" translate="yes" xml:space="preserve">
          <source>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb721a7785396c7acd1586d0fc279449394dcfd8" translate="yes" xml:space="preserve">
          <source>A template with a non-type template parameter of reference type was mangled incorrectly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2953b18cce576e52d1d65cb76238b4c46802eda8" translate="yes" xml:space="preserve">
          <source>A threshold on the average loop count considered by the swing modulo scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4948261ad39b1701b8001a691f2c0f51ef54c3" translate="yes" xml:space="preserve">
          <source>A trampoline is a small piece of code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. Therefore, it requires the stack to be made executable in order for the program to work properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cd7e495c30fc4bf5a59f6f14ffc8c61dbbd59b" translate="yes" xml:space="preserve">
          <source>A true dependence from store to load is costly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5307fd85f09fc936e5444911a1b34c9fbd27e507" translate="yes" xml:space="preserve">
          <source>A typical use of this option is building a kernel that does not use, and hence need not save and restore, any floating-point registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7040b335818f1c7fc002704e20a47588f7532dc4" translate="yes" xml:space="preserve">
          <source>A valid &lt;code&gt;NULL&lt;/code&gt; in this context is defined as zero with any object pointer type. If your system defines the &lt;code&gt;NULL&lt;/code&gt; macro with an integer type then you need to add an explicit cast. During installation GCC replaces the system &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; header with a copy that redefines NULL appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bba8846c50f28733626cee0f5e6cd6eae5f547" translate="yes" xml:space="preserve">
          <source>A value for this option must be provided; possible values are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28bdc15a4774baf30748fb10f9a39ee9576d0acc" translate="yes" xml:space="preserve">
          <source>A value of -1 means we don&amp;rsquo;t have a threshold and therefore prefetch hints can be issued for any constant stride.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77182ee8e74fbc85f274ec34ad0d067f9159c03c" translate="yes" xml:space="preserve">
          <source>A vector constant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a5a3c85e4d61bb20e699b708ea293eab97d102" translate="yes" xml:space="preserve">
          <source>A vector constant is a list of constant expressions within curly braces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4903fd385e6b83744a3f7241ee469fe297e3d890" translate="yes" xml:space="preserve">
          <source>A vector initializer requires no cast if the vector constant is of the same type as the variable it is initializing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce3f2c4c36ebf953052d74dd8cf41bfa72eda5d" translate="yes" xml:space="preserve">
          <source>A weak reference is an alias that does not by itself require a definition to be given for the target symbol. If the target symbol is only referenced through weak references, then it becomes a &lt;code&gt;weak&lt;/code&gt; undefined symbol. If it is directly referenced, however, then such strong references prevail, and a definition is required for the symbol, not necessarily in the same translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83fa522cc15ecf666a6fc12658b5e4cd5fdc010" translate="yes" xml:space="preserve">
          <source>AArch64 family&amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4957a12f9c33bdb7711f6bad443bcf1b59bf30ce" translate="yes" xml:space="preserve">
          <source>ABI conformance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14e4cc3f9a03a17ac3f6123a6226b7b7d34c952" translate="yes" xml:space="preserve">
          <source>ADDENDUM: How to use this License for your documents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0161097b4d6be2ad809b71f0ab06f4ccc56e03" translate="yes" xml:space="preserve">
          <source>AES instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd84aa567f4fd80f10ee4bdc1fff46ff3f84291a" translate="yes" xml:space="preserve">
          <source>AIX TOC entry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c79d98f4ab13b1e68350376a159f81803c3f05" translate="yes" xml:space="preserve">
          <source>AIX on the RS/6000 provides support (NLS) for environments outside of the United States. Compilers and assemblers use NLS to support locale-specific representations of various objects including floating-point numbers (&amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="e38876cb454c616d20b014174318cd23549c31b5" translate="yes" xml:space="preserve">
          <source>AM33</source>
          <target state="translated">AM33</target>
        </trans-unit>
        <trans-unit id="b0f3c857fc3329c9a7706ca2852892a64907ff92" translate="yes" xml:space="preserve">
          <source>AMD Athlon CPU with MMX, 3dNOW!, enhanced 3DNow! and SSE prefetch instructions support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9782812fedc19dae1f691ec0b75b46ce928e9504" translate="yes" xml:space="preserve">
          <source>AMD CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7804a001f508699c3a5d535226c1c43f89e201" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Barcelona CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f426233bd9b4aec7ad7f0935ada0d98f23dc6d" translate="yes" xml:space="preserve">
          <source>AMD Family 10h CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a221df99534b6cfd9cc25151f5b88b631e6b6c74" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Istanbul CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8a317ded567872f2b86eb3a9b2b3142383086c" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Shanghai CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a481ec8025706c39f85bf8a74294ffb3a885a4c" translate="yes" xml:space="preserve">
          <source>AMD Family 14h CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d69f21954e9736613dfdcb1541757a89581cb747" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ba99ffd8cd8d92353e0abf0591f609003e91a0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c106e6d754b124070881cb0e9b5ffaec83f58ff6" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162b040bafc7dbe0fec77eb2f6b3a8372fec8cf0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b550c62094801a9eaabc1a10c1588d01074f61b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc29f9ebb58544eff2350911f186ade2077e9e7" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0473fd00ce817690842cab967b3016ac67c8acc" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f30ce336c72904fed1286b4744fb02d22539e6b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1222a05e9ab4d223a98fe2b005e9a8fe6f149c1" translate="yes" xml:space="preserve">
          <source>AMD Family 16h CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275cd046e8c73f55e5a1e1661fd4caf48dfc118a" translate="yes" xml:space="preserve">
          <source>AMD Family 17h CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8605196ce8298328039162c5b2196f5f20eefce6" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac5c90de82cdae73bde8fdf83f5571edc22b502" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a04068ae7b738101f64aab71cef3ecd2846768" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, ,CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae2f9839ab0c946ebf780350ccb8eeef28b2d89" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb46d89908f8744c91b1c4f45dca8a1acd1ccb27" translate="yes" xml:space="preserve">
          <source>AMD GCN &amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db735b251e571e72d1b413e2700f9028689a9a1f" translate="yes" xml:space="preserve">
          <source>AMD Geode embedded processor with MMX and 3DNow! instruction set support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8e48e665e983d9bc0d85fc904dca86423a0640" translate="yes" xml:space="preserve">
          <source>AMD K6 CPU with MMX instruction set support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113a97cdab92673636cc95858168822f55ed3094" translate="yes" xml:space="preserve">
          <source>ANY</source>
          <target state="translated">ANY</target>
        </trans-unit>
        <trans-unit id="c23fd1159b1de92b9f559df33e41326ca8f7ed85" translate="yes" xml:space="preserve">
          <source>ARC &amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3246acd95d4fb7aa3011b3fb00ffb954a2152c1" translate="yes" xml:space="preserve">
          <source>ARC FPX (dpfp) 64-bit registers. &lt;code&gt;D0&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ccf1f7f060d37f54120246cfa7dc75a263926f6" translate="yes" xml:space="preserve">
          <source>ARC HS SIMD support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932a7f099a143287c2dab636f78bab3d7a1ac45d" translate="yes" xml:space="preserve">
          <source>ARC600</source>
          <target state="translated">ARC600</target>
        </trans-unit>
        <trans-unit id="4e11187f8fc082bb81a4560953a7d52297f319ca" translate="yes" xml:space="preserve">
          <source>ARC601</source>
          <target state="translated">ARC601</target>
        </trans-unit>
        <trans-unit id="db9b6f8ec7c62bb078c4ccd2086414ec10283d1a" translate="yes" xml:space="preserve">
          <source>ARC700</source>
          <target state="translated">ARC700</target>
        </trans-unit>
        <trans-unit id="69f32b824b4367437b84027bd88885eef21e2693" translate="yes" xml:space="preserve">
          <source>ARC700-xmac</source>
          <target state="translated">ARC700-xmac</target>
        </trans-unit>
        <trans-unit id="f05a45c9726afd143f3f3902e0d21ab2ae48650f" translate="yes" xml:space="preserve">
          <source>ARC725D</source>
          <target state="translated">ARC725D</target>
        </trans-unit>
        <trans-unit id="c4f837ba2f5ad05063a4e03989e3391dddb8bc79" translate="yes" xml:space="preserve">
          <source>ARC750D</source>
          <target state="translated">ARC750D</target>
        </trans-unit>
        <trans-unit id="888c2ab0ae2033359c10fd5cfdf58bbe2d0a940c" translate="yes" xml:space="preserve">
          <source>ARM family&amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9b87087c41304359e59fe26411a54c3b656947" translate="yes" xml:space="preserve">
          <source>ARM targets support two incompatible representations for half-precision floating-point values. You must choose one of the representations and use it consistently in your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7649225dad7c2a0e06a3df7785837ccbdcddf7e" translate="yes" xml:space="preserve">
          <source>AVR family&amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ce34d1fb413b0acbfa365b9e4b9f6fd56b845e" translate="yes" xml:space="preserve">
          <source>AVX instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5360c6483b9a9e1df7abdcb4de1b9b5a31a7db4c" translate="yes" xml:space="preserve">
          <source>AVX2 instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d10807c0ae95d634b933c4c91561b625fdd7ee8" translate="yes" xml:space="preserve">
          <source>AVX5124FMAPS instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2877f163ba5f992658ca47acc8b1854f3fe91f8e" translate="yes" xml:space="preserve">
          <source>AVX5124VNNIW instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aaaf18e4ab544cbae42a58b9cf1cac769995f49" translate="yes" xml:space="preserve">
          <source>AVX512BITALG instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c802e92787ca04a74935e0b7ab771a52b734eb" translate="yes" xml:space="preserve">
          <source>AVX512BW instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3621c799203e17dc8a8e2affcd32cfee406953" translate="yes" xml:space="preserve">
          <source>AVX512CD instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734e989680da5e12fff96a9678b5efdb7f080ad8" translate="yes" xml:space="preserve">
          <source>AVX512DQ instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab4d6a088fb02d341f438d1a8b690b1d06bd6a6f" translate="yes" xml:space="preserve">
          <source>AVX512ER instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e79b06b712a8ed9dc7a5818dbaa8055049287e6" translate="yes" xml:space="preserve">
          <source>AVX512F instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a774d2186ac710be1f1d2b1823b920ecc713d1ba" translate="yes" xml:space="preserve">
          <source>AVX512IFMA instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01464cdaa2c7a778b9758cae6be675e4fe0b633" translate="yes" xml:space="preserve">
          <source>AVX512PF instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f8339b23ce90729e637c7a3a364d024582dd8c" translate="yes" xml:space="preserve">
          <source>AVX512VBMI instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60db97c4b4db27b3430715d1af3a5a33414556d6" translate="yes" xml:space="preserve">
          <source>AVX512VBMI2 instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be842cb121c07bbfe15b74f0e979638742b0293" translate="yes" xml:space="preserve">
          <source>AVX512VL instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644733f8c866e0e47cbcfa44a51986c10011d89b" translate="yes" xml:space="preserve">
          <source>AVX512VNNI instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a0313f00ad630fa2e77fff34864e43bc34cbe7" translate="yes" xml:space="preserve">
          <source>AVX512VPOPCNTDQ instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e869970cd001add8f88d68dc06d771dcf6a716" translate="yes" xml:space="preserve">
          <source>Abort the current transaction. When no transaction is active this is a no-op. The &lt;var&gt;status&lt;/var&gt; is an 8-bit constant; its value is encoded in the return value from &lt;code&gt;_xbegin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06529d24f685cb943a5ccbec8926618c923b5a20" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two paired-single values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df073c7d1c50e06cd4608c23a66611cf902ab538" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two scalar values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f722ac4229dd26c3b68dd80d6e1f64e995895dbe" translate="yes" xml:space="preserve">
          <source>Absolute value (&lt;code&gt;abs.ps&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4daf0f1c1f813e9102db1a5994f1b9e8323b97c9" translate="yes" xml:space="preserve">
          <source>Accept &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2da276a5f9c648bf9aca0b0668639225e93b2f" translate="yes" xml:space="preserve">
          <source>Accept imaginary, fixed-point, or machine-defined literal number suffixes as GNU extensions. When this option is turned off these suffixes are treated as C++11 user-defined literal numeric suffixes. This is on by default for all pre-C++11 dialects and all GNU dialects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a081bde4daabce186fc90fa0db98f145d7ef25aa" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Microsoft header files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce1e6741eac355bc7dded05833655b003ffbcb7" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Plan 9 code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be39a99ef887dbe2361b7a8f01c005db47949d8d" translate="yes" xml:space="preserve">
          <source>Accept universal character names in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f43c08aeb944b0a767a69ba0fb81ec15c2500b4" translate="yes" xml:space="preserve">
          <source>Accept variadic functions without named parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045e8c6e57a163b8d206267b0ad429f37b12bd4b" translate="yes" xml:space="preserve">
          <source>Accesses through pointers to types with this attribute are not subject to type-based alias analysis, but are instead assumed to be able to alias any other type of objects. In the context of section 6.5 paragraph 7 of the C99 standard, an lvalue expression dereferencing such a pointer is treated like having a character type. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0bf5b2a877ef7b91241baabde260a26b7a132e" translate="yes" xml:space="preserve">
          <source>Accesses to bit-fields even in volatile objects works by accessing larger objects, such as a byte or a word. You cannot rely on what size of object is accessed in order to read or write the bit-field; it may even vary for a given bit-field according to the precise usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853e90163908be81a9a0fb1ee291ab1b4ba5a6c2" translate="yes" xml:space="preserve">
          <source>Accesses to non-volatile objects are not ordered with respect to volatile accesses. You cannot use a volatile object as a memory barrier to order a sequence of writes to non-volatile memory. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c072e2c48755b5522f29c41ec4ff83f53ff94a3e" translate="yes" xml:space="preserve">
          <source>Accesses to the variable may be optimized as usual and the register remains available for allocation and use in any computations, provided that observable values of the variable are not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d925b3885b30b4085b6d48f83637a9fdd674d3f" translate="yes" xml:space="preserve">
          <source>Accessing data from C programs without using input/output operands (such as by using global symbols directly from the assembler template) may not work as expected. Similarly, calling functions directly from an assembler template requires a detailed understanding of the target assembler and ABI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea1f643245ad21355d1a144988c7b86dcf2187a" translate="yes" xml:space="preserve">
          <source>According to the C standard, such an expression is an rvalue whose type is the unqualified version of its original type, i.e. &lt;code&gt;int&lt;/code&gt;. Whether GCC interprets this as a read of the volatile object being pointed to or only as a request to evaluate the expression for its side effects depends on this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35037aeb8678de2c00ed45aeca3de92268d726be" translate="yes" xml:space="preserve">
          <source>Accumulate an option for &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3826f28e4e210d0b17ec990e0a882bb608802f9" translate="yes" xml:space="preserve">
          <source>Accumulate outgoing function arguments and acquire/release the needed stack space for outgoing function arguments once in function prologue/epilogue. Without this option, outgoing arguments are pushed before calling a function and popped afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc171ad6354a6828c71d9648018df6749febe991" translate="yes" xml:space="preserve">
          <source>Accumulator register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554b8869b285c571ad11f29cd87ecd2c94a39e50" translate="yes" xml:space="preserve">
          <source>Ada source code file containing a library unit body (a subprogram or package body). Such files are also called &lt;em&gt;bodies&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2989ddb4c2391d408222a27d0f7e97c4843dda" translate="yes" xml:space="preserve">
          <source>Ada source code file that contains a library unit declaration (a declaration of a package, subprogram, or generic, or a generic instantiation), or a library unit renaming declaration (a package, generic, or subprogram renaming declaration). Such files are also called &lt;em&gt;specs&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885d4a696efd6405b314fabe588d5e90299b2183" translate="yes" xml:space="preserve">
          <source>Add &amp;ldquo;thread storage duration&amp;rdquo; to the list in paragraph 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86ee756f777d093031a2ef7598a20edf7c225e4" translate="yes" xml:space="preserve">
          <source>Add 8 bytes to an offsettable memory reference. Useful when accessing the high 8 bytes of SSE values. For a memref in (%rax), it generates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4790fd26dc16d553ca9f40c8e3122f144c79668c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list in paragraph 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a776e64e6b39926909868acf47332b1f06fea4a3" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of specifiers in paragraph 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae62118c00710deaec9ef5e1ca04437d3f24b0d" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of storage class specifiers in paragraph 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9035627ef94891bbb5d203d19159bca7ef3d20" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d24fa0d264612fefce413cb080bc55058598cb7" translate="yes" xml:space="preserve">
          <source>Add after paragraph 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d6be3cf4356a47a61429765c19c67c73985946" translate="yes" xml:space="preserve">
          <source>Add after paragraph 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c93420cec677cdd1b461d1d94e40f0e5ce17fec" translate="yes" xml:space="preserve">
          <source>Add after paragraph 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5cebdb7710016b6f480e1dcf7594bfb0735ab9" translate="yes" xml:space="preserve">
          <source>Add after paragraph 6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ee990db3ecfcd2015326c23234c180361bb454" translate="yes" xml:space="preserve">
          <source>Add code so that program flow &lt;em&gt;arcs&lt;/em&gt; are instrumented. During execution the program records how many times each branch and call is executed and how many times it is taken or returns. On targets that support constructors with priority support, profiling properly handles constructors, destructors and C++ constructors (and destructors) of classes which are used as a type of a global variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f504a568cb02675dcb4fa7f761de4ec8eef873" translate="yes" xml:space="preserve">
          <source>Add description attributes to some DWARF DIEs that have no name attribute, such as artificial variables, external references and call site parameter DIEs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71433ea39bacba1c32fb50a6079568ad524eb46d" translate="yes" xml:space="preserve">
          <source>Add directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548bf62a1540dcbb0f428d7f5c59cbf2987dcf8a" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e160272edc000ac3b59f7e3c239601278b19a4" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ab0cd8ae6eaeee09a517ab6e0fab22009af14c" translate="yes" xml:space="preserve">
          <source>Add new text before paragraph 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09310e0a5ba6730b457158c35b8623195000a4a3" translate="yes" xml:space="preserve">
          <source>Add support for multithreading with the &lt;em&gt;dce thread&lt;/em&gt; library under HP-UX. This option sets flags for both the preprocessor and linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df2581a5423cd3eaf9365ee07a19f72370b3fc1" translate="yes" xml:space="preserve">
          <source>Add the directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for header files during preprocessing. If &lt;var&gt;dir&lt;/var&gt; begins with &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c333940f1537361f906bee03e2343442706250" translate="yes" xml:space="preserve">
          <source>Add the framework directory &lt;var&gt;dir&lt;/var&gt; to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8c5a8e482b4eb45d5df440bbd4aa57581a1379" translate="yes" xml:space="preserve">
          <source>Additional Floating Types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbfd7f5a311b0863e336e4d5dd611078e4f5f005" translate="yes" xml:space="preserve">
          <source>Additional block information may succeed each line, when requested by command line option. The &lt;var&gt;execution_count&lt;/var&gt; is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a265ea53c72053fec1245e548879142e841e602" translate="yes" xml:space="preserve">
          <source>Additional built-in functions are available for the 64-bit PowerPC family of processors, for efficient use of 128-bit floating point (&lt;code&gt;__float128&lt;/code&gt;) values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e400fc31f2b8160db0d8588871c49194b1a49e9" translate="yes" xml:space="preserve">
          <source>Additional floating-point exceptions, rounding modes, environments, and classifications, and their macro names (C99 and C11 7.6, C99 and C11 7.12).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b88de1196308385f5d14de9c11ffbabcd4f7f0a" translate="yes" xml:space="preserve">
          <source>Additional post-processing of the returned value may be needed, see &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6fd1bd03704b21e269c633949f84ccf5e8856f" translate="yes" xml:space="preserve">
          <source>Additional registers typically used only in prologues and epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880c2173ff65c5e972a9e4536af68b63da90141d" translate="yes" xml:space="preserve">
          <source>Additional restrictions are enforced for types with the reverse scalar storage order with regard to the scalar storage order of the target:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09bc67c6276506971828d824b07903a4f5f9de7b" translate="yes" xml:space="preserve">
          <source>Additionally inlining a function compiled with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8b67741ce8fd715c05645cbb36737b371211d3" translate="yes" xml:space="preserve">
          <source>Additionally on native AArch64 GNU/Linux systems the value &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9983bdb073bd2da3d6b02f0173dccb4761318ac" translate="yes" xml:space="preserve">
          <source>Additionally the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32c6fe01da4320e1de2565ba6da0578715fa9c4" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;CFStringRefs&lt;/code&gt; (defined by the &lt;code&gt;CoreFoundation&lt;/code&gt; headers) may also be used as format arguments. Note that the relevant headers are only likely to be available on Darwin (OSX) installations. On such installations, the XCode and system documentation provide descriptions of &lt;code&gt;CFString&lt;/code&gt;, &lt;code&gt;CFStringRefs&lt;/code&gt; and associated functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f45ee380b9da22c173cf9d9231907ee68fe13b" translate="yes" xml:space="preserve">
          <source>Additionally, some messages are logically nested within other messages, reflecting implementation details of the optimization passes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c630e5527eda313a2b833dd18abd8307a6cfdbd" translate="yes" xml:space="preserve">
          <source>Additionally, the architectural extension string may be specified on its own. This can be used to turn on and off particular architectural extensions without having to specify a particular architecture version or core. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e68df41b1d7fdc52b01b88eeb29e9ccd6bf7ed5e" translate="yes" xml:space="preserve">
          <source>Additionally, the following architectures, which lack support for the Thumb execution state, are recognized but support is deprecated: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a870075e1e81be429acf073e584f3d7c7e76cfdf" translate="yes" xml:space="preserve">
          <source>Additionally, the options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62846127f56afc07ef1c01a4fc578e26bdf7e831" translate="yes" xml:space="preserve">
          <source>Additionally, this option can specify that GCC should tune the performance of the code for a big.LITTLE system. Permissible names are: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b7ac484445343c898ee0befeb5554f44a64e88" translate="yes" xml:space="preserve">
          <source>Additionally, warn when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="facde292bf415fbdf09a1828e9e0908e4c617e00" translate="yes" xml:space="preserve">
          <source>Address base register</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7731150d1c92cf663f9e708bf71a25213854ca" translate="yes" xml:space="preserve">
          <source>Address base register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3421b8898caa7357be908d1653e3653974d758f" translate="yes" xml:space="preserve">
          <source>Address operand that is an indexed or indirect from a register (&amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b7013cab33d0bd7c179b9b5712968750a0b395" translate="yes" xml:space="preserve">
          <source>Address operand without segment register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e849277f25d3c4f30a01955b54c92b602f3ff3ef" translate="yes" xml:space="preserve">
          <source>Address register</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60bc1681a9f62ef4591ab15398d5eb38a430789" translate="yes" xml:space="preserve">
          <source>Address register (general purpose register except r0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d4fb05cb0843e13759b8b72edb33693debf000" translate="yes" xml:space="preserve">
          <source>Address register indirect addressing mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a077484bf2c4ff84f71e4199f510082fe999bf3" translate="yes" xml:space="preserve">
          <source>Address registers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5759236ebd061a0e0392b44c51e565f6ce6fcc43" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 16 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd0e10bf3a4572e30fda31a40f35542043406cf" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 24 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="325382a51fa4bc25157b99f44454696d95890fcb" translate="yes" xml:space="preserve">
          <source>Address space identifiers may be used exactly like any other C type qualifier (e.g., &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;). See the N1275 document for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0d1ee78feebd358e9ac4716831efeab01368b7" translate="yes" xml:space="preserve">
          <source>Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte allocation unit if the integral types are the same size and if the next bit-field fits into the current allocation unit without crossing the boundary imposed by the common alignment requirements of the bit-fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94636fe0e41073552acb8d30375f7c2b9b7fa2c2" translate="yes" xml:space="preserve">
          <source>After defining a global register variable, for the current compilation unit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a160b9211c156fcb59476123ceefb14233c30de0" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, identify arithmetic instructions that compute processor flags similar to a comparison operation based on that arithmetic. If possible, eliminate the explicit comparison operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd493414e0c8a63ccc996f89446d267fe9e1e5f" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, perform a copy-propagation pass to try to reduce scheduling dependencies and occasionally eliminate the copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c15aec2fc1e009f616402ab13a6a8f9c982cca" translate="yes" xml:space="preserve">
          <source>After running a program compiled with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1454e9ea83225a76df4ee5fd8a44b04ac91ebb88" translate="yes" xml:space="preserve">
          <source>After the prefix, there must be one or more additional constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;) that describe where the value resides. Common constraints include &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d629b413e62d8e858ca1323306d594503312be" translate="yes" xml:space="preserve">
          <source>Again, the call to &lt;code&gt;f()&lt;/code&gt; is not dependent on template arguments (there are no arguments that depend on the type &lt;code&gt;T&lt;/code&gt;, and it is also not otherwise specified that the call should be in a dependent context). Thus a global declaration of such a function must be available, since the one in the base class is not visible until instantiation time. The compiler will consequently produce the following error message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15a8d239570fd7618da66d01432b0ca503636ad" translate="yes" xml:space="preserve">
          <source>Aggregates with this attribute are invalid, even if they are of the same size as a corresponding scalar. For example, the declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ffe001744d57fb7d843a75b3de19edfb4a4cd40" translate="yes" xml:space="preserve">
          <source>Aliases of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7b5a2fcf03ab39f29a64817524ffd647a4fc18" translate="yes" xml:space="preserve">
          <source>Align all branch targets to a power-of-two boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784e20f54ecda5213d66bcc1bc3f5f199a64e7ea" translate="yes" xml:space="preserve">
          <source>Align all loops to a 32-byte boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e1e4cb8c2ddc659aedc1c3a6dfffeb002bdbe7" translate="yes" xml:space="preserve">
          <source>Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping. In this case, no dummy operations need be executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8345e97e639fae1caa53fafd777f32b2148811" translate="yes" xml:space="preserve">
          <source>Align doubles at 64-bit boundaries. Note that this changes the calling conventions, and thus some functions from the standard C library do not work unless you recompile it first with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a2b427b91139b8587d4cbfe16eb7a63f8affad" translate="yes" xml:space="preserve">
          <source>Align loops to a power-of-two boundary. If the loops are executed many times, this makes up for any execution of the dummy padding instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4c088e2c0ec9d07a3a585878097d5ea3d18362" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790e74268060e0e6ade88cfb9c482c2bc048f9d0" translate="yes" xml:space="preserve">
          <source>Align variable (&lt;code&gt;alnv.ps&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="19bd4f0f0123a61d6b94fd1f26c48a5b466015b1" translate="yes" xml:space="preserve">
          <source>All condition registers: SCC, VCCZ, EXECZ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebe806ad92438745f4bad14dde213851c8a70c2" translate="yes" xml:space="preserve">
          <source>All dependences are costly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cca1530229b7b9e550b891f9a9b113625c13de2" translate="yes" xml:space="preserve">
          <source>All files specified by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eaba1cfa9a00eb4bd0b12d5b7310a8e6e1fa4c5" translate="yes" xml:space="preserve">
          <source>All implicitly popped input registers must be closer to the top of the reg-stack than any input that is not implicitly popped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1c013be47e44ec0e7b3eeaa220c1f24b9203e3" translate="yes" xml:space="preserve">
          <source>All memory orders are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ff0e08a090942eb8e784cba6de91a4fd99fb49" translate="yes" xml:space="preserve">
          <source>All modules should be compiled with the same</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0bcaa344128e72d0d5e1b94c3b2fa0090b0e882" translate="yes" xml:space="preserve">
          <source>All objects that have neither thread storage duration, dynamic storage duration nor are local [&amp;hellip;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2545f5d42fce7e86616e30c2d782de4749997a" translate="yes" xml:space="preserve">
          <source>All of the routines are described in the Intel documentation to take &amp;ldquo;an optional list of variables protected by the memory barrier&amp;rdquo;. It&amp;rsquo;s not clear what is meant by that; it could mean that &lt;em&gt;only&lt;/em&gt; the listed variables are protected, or it could mean a list of additional variables to be protected. The list is ignored by GCC which treats it as empty. GCC interprets an empty list as meaning that all globally accessible variables should be protected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc38cb28fe09de761809c6899ec0dfab5c95980" translate="yes" xml:space="preserve">
          <source>All other attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1fe3c41d4a92f980feaffab352908a5ae600b4" translate="yes" xml:space="preserve">
          <source>All the above</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ca116b6b2d46153e83f38824f95e8a5d694cf5" translate="yes" xml:space="preserve">
          <source>All the basic integer types can be used as base types, both as signed and as unsigned: &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;. In addition, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; can be used to build floating-point vector types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8115dc4041976655c63e593fd53f619ce3ca975" translate="yes" xml:space="preserve">
          <source>All the data and read-only data segments must be within 512KB addressing space. The text segment must be within 16MB addressing space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a642a04a04ca54e997a623213186ae992d1e6e8c" translate="yes" xml:space="preserve">
          <source>All the text and data segments can be within 4GB addressing space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8b82ccf3682d163d774079a9dc8ccb0aa660ee" translate="yes" xml:space="preserve">
          <source>All visibilities are supported on many, but not all, ELF targets (supported when the assembler supports the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622f4dc5287fcd41d6f3a24869b2a0df614a0723" translate="yes" xml:space="preserve">
          <source>Allocate to an &lt;code&gt;enum&lt;/code&gt; type only as many bytes as it needs for the declared range of possible values. Specifically, the &lt;code&gt;enum&lt;/code&gt; type is equivalent to the smallest integer type that has enough room.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b577848b6e6ae4af92719e79079d9951a50047f" translate="yes" xml:space="preserve">
          <source>Allocate variables to the read-only data section first if possible, then next in the small data section if possible, otherwise in data. This gives slightly slower code than the default, but reduces the amount of RAM required when executing, and thus may be preferred for some embedded systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f3f43a7ca9147ffe2ba31d63c2ea8ec201486c" translate="yes" xml:space="preserve">
          <source>Allow arbitrary-sized immediates in bit operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2c75532a2e292a21a77540eaedf29f5c432d5a" translate="yes" xml:space="preserve">
          <source>Allow conditional expressions with mismatched types in the second and third arguments. The value of such an expression is void. This option is not supported for C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d58e8c4bb0f63ea94500caf667ca947fcaa1a82" translate="yes" xml:space="preserve">
          <source>Allow fast jumps to the message dispatcher. On Darwin this is accomplished via the comm page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73dadda8d4b49fb004b5103de76106d4f0b8557" translate="yes" xml:space="preserve">
          <source>Allow implicit conversions between vectors with differing numbers of elements and/or incompatible element types. This option should not be used for new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dbb659ed768befd508acb2601c588f49ddaa57" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that (a) assume that arguments and results are valid and (b) may violate IEEE or ANSI standards. When used at link time, it may include libraries or startup files that change the default FPU control word or other similar optimizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773a6288517f96a4a7283887bb99a6fba71c957c" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that assume that arguments and results are not NaNs or +-Infs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e06113b53f739fa9c85ec94358e3f373eb320f8" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that ignore the signedness of zero. IEEE arithmetic specifies the behavior of distinct +0.0 and -0.0 values, which then prohibits simplification of expressions such as x+0.0 or 0.0*x (even with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eea9d2d0ec6a801c6ef5293eae12c7fbb21b59c" translate="yes" xml:space="preserve">
          <source>Allow optimizers to introduce new data races on stores. Set to 1 to allow, otherwise to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60cf758a077c6f503981387a6b0345419874bea" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsca&lt;/code&gt; instruction for sine and cosine approximations. The option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70331cead1dc233186888055e035642315d5054e" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsrra&lt;/code&gt; instruction for reciprocal square root approximations. The option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cbe965449910b6f59559b0a1874d0d198b696a" translate="yes" xml:space="preserve">
          <source>Allow re-association of operands in series of floating-point operations. This violates the ISO C and C++ language standard by possibly changing computation result. NOTE: re-ordering may change the sign of zero as well as ignore NaNs and inhibit or create underflow or overflow (and thus cannot be used on code that relies on rounding behavior like &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt;. May also reorder floating-point comparisons and thus may not be used when ordered comparisons are required. This option requires that both</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ce20d4ec16fad4cd32f197249fdc3fb1dac290" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of more load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b47c26e732fcedac3b1858953b01853eb8422ec" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of some load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f926321cb4f3fc49097c6857a3e7d152a19de395" translate="yes" xml:space="preserve">
          <source>Allow stop bits to be placed earlier than immediately preceding the instruction that triggered the stop bit. This can improve instruction scheduling, but does not always do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7905fb7386b21750ad5a1d1722446a6fdeb43598" translate="yes" xml:space="preserve">
          <source>Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled. For C (and C++), this activates optimizations based on the type of expressions. In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same. For example, an &lt;code&gt;unsigned int&lt;/code&gt; can alias an &lt;code&gt;int&lt;/code&gt;, but not a &lt;code&gt;void*&lt;/code&gt; or a &lt;code&gt;double&lt;/code&gt;. A character type may alias any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2aa80da8f5ff65f45ae97b354110390c96c42f" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39db7389fdae7630a67f4845ba2f639259c8a4a" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate the &lt;em&gt;SETLB&lt;/em&gt; and &lt;em&gt;Lcc&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7a919d8fa035f96c5d1af049879f0dd62e1421" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize using the assumption that a value of enumerated type can only be one of the values of the enumeration (as defined in the C++ standard; basically, a value that can be represented in the minimum number of bits needed to represent all the enumerators). This assumption may not be valid if the program uses a cast to convert an arbitrary integer value to the enumerated type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fc8a715b12ca22462902ef833240995e04a5d4" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use all of the available registers. By default registers &lt;code&gt;r24..r31&lt;/code&gt; are reserved for use in interrupt handlers. With this option enabled these registers can be used in ordinary functions as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6303c2c94b5f256a55d06aa2be50e19fcb0df737" translate="yes" xml:space="preserve">
          <source>Allow the reciprocal of a value to be used instead of dividing by the value if this enables optimizations. For example &lt;code&gt;x / y&lt;/code&gt; can be replaced with &lt;code&gt;x * (1/y)&lt;/code&gt;, which is useful if &lt;code&gt;(1/y)&lt;/code&gt; is subject to common subexpression elimination. Note that this loses precision and increases the number of flops operating on the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cbc7a77a073ec8e91de85701bbe563110739962" translate="yes" xml:space="preserve">
          <source>Allow the store merging pass to introduce unaligned stores if it is legal to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c16f16485e58470d06579755ecbd0f929ac7fa" translate="yes" xml:space="preserve">
          <source>Allow to use truncation instead of rounding towards zero for fractional fixed-point types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8834a22ee0acee1821ccfc8e148c6cbb34655847" translate="yes" xml:space="preserve">
          <source>Allow using extensions of later DWARF standard version than selected with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ea6e4c4f75e6a8f8033c8b750f3d749cc09003" translate="yes" xml:space="preserve">
          <source>Allow/disallow treating the &lt;code&gt;__ea&lt;/code&gt; address space as superset of the generic address space. This enables explicit type casts between &lt;code&gt;__ea&lt;/code&gt; and generic pointer as well as implicit conversions of generic pointers to &lt;code&gt;__ea&lt;/code&gt; pointers. The default is to allow address space pointer conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a5bb83513cc4e38a6504a7eaa0f1d977ac61b9" translate="yes" xml:space="preserve">
          <source>Allowable bit-field types other than &lt;code&gt;_Bool&lt;/code&gt;, &lt;code&gt;signed int&lt;/code&gt;, and &lt;code&gt;unsigned int&lt;/code&gt; (C99 and C11 6.7.2.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9672aa21a92b454bca4334e1b73511ba859e3019" translate="yes" xml:space="preserve">
          <source>Allows calls via function pointers (including virtual functions) to execute correctly regardless of whether the target code has been compiled for interworking or not. There is a small overhead in the cost of executing a function pointer if this option is enabled. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fab16002619dc077a62263507de1c970a51b300" translate="yes" xml:space="preserve">
          <source>Also note that GCC emits the above sequence with additional Newton-Raphson step for vectorized single-float division and vectorized &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; already with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a461c1e71dd5c0a03740ad367bc2a7b24233082" translate="yes" xml:space="preserve">
          <source>Also note that an &lt;code&gt;asm goto&lt;/code&gt; statement is always implicitly considered volatile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767bf94dfe72662ddbd8e20120050c8f90e9046e" translate="yes" xml:space="preserve">
          <source>Also warn about cases where the compiler reduces the magnitude of a constant involved in a comparison. For example: &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; is simplified to &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt;. This is reported only at the highest warning level because this simplification applies to many comparisons, so this warning level gives a very large number of false positives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c15f6772b26643b0ff617a164130fae2096f2324" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified to a constant. For example: &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt;. This can only be simplified when signed integer overflow is undefined, because &lt;code&gt;abs (INT_MIN)&lt;/code&gt; overflows to &lt;code&gt;INT_MIN&lt;/code&gt;, which is less than zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e800b6cdd36533f8ba6ba58f938d89e7317e5b" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified. For example: &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; is simplified to &lt;code&gt;x &amp;gt; 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2eccf451b029841db2d4f52cb1371fa4ffd7cc2" translate="yes" xml:space="preserve">
          <source>Also warn about other simplifications not covered by the above cases. For example: &lt;code&gt;(x * 10) / 5&lt;/code&gt; is simplified to &lt;code&gt;x * 2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf71652d194ffb84805956fe1b5940083ae517e" translate="yes" xml:space="preserve">
          <source>Also warn for dangerous uses of the GNU extension to &lt;code&gt;?:&lt;/code&gt; with omitted middle operand. When the condition in the &lt;code&gt;?&lt;/code&gt;: operator is a boolean expression, the omitted value is always 1. Often programmers expect it to be a value computed inside the conditional expression instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0777d5422fc8bc8f5bababa57c28335fb0cdc795" translate="yes" xml:space="preserve">
          <source>Also warn if a comparison like &lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; appears; this is equivalent to &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt;, which is a different interpretation from that of ordinary mathematical notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e45248057e2324494ad069a7abd8071c0384ad1" translate="yes" xml:space="preserve">
          <source>Also warn when making a cast that introduces a type qualifier in an unsafe way. For example, casting &lt;code&gt;char **&lt;/code&gt; to &lt;code&gt;const char **&lt;/code&gt; is unsafe, as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdf7f49c076ed9ff3a97d65da78f8767a5691c7" translate="yes" xml:space="preserve">
          <source>Also, some built-in functions prefer or require immediate numbers as parameters, because the corresponding DSP instructions accept both immediate numbers and register operands, or accept immediate numbers only. The immediate parameters are listed as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b2a9f079522dadbd70f5a362997b267591505d" translate="yes" xml:space="preserve">
          <source>Also, the ABI changed the mangling of template argument packs, &lt;code&gt;const_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, prefix increment/decrement, and a class scope function used as a template argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bedbe72286a46ec20159c0af50884180a15a3619" translate="yes" xml:space="preserve">
          <source>Also, there are two special clobber arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1793f4a326dd636d187c7ec419e47dec37d6305e" translate="yes" xml:space="preserve">
          <source>Also, you must provide function prototypes for all functions that take variable numbers of arguments (including &lt;code&gt;printf&lt;/code&gt;); otherwise incorrect code is generated for calls to those functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85df36ab018e13c039dd34eb2302708663f4af2" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization of loops marked with the OpenMP simd directive. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f431f1054230ce8fcc7bc5eae8ec9ced8a86a188" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc71ca35ab8d8d40760c8ef39bc71ee861a4bcc" translate="yes" xml:space="preserve">
          <source>Alter the thread-local storage model to be used (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;). The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d63c6f25ef5c2c6707d16e831a6091cc8c50e17" translate="yes" xml:space="preserve">
          <source>Alter the update method for an application instrumented for profile feedback based optimization. The &lt;var&gt;method&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ba2917cba97115bf3adee00dd20256ca8bef51" translate="yes" xml:space="preserve">
          <source>Alternately, you can reference labels using the actual C label name enclosed in brackets. For example, to reference a label named &lt;code&gt;carry&lt;/code&gt;, you can use &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04a618f555219675642e22c54d794ab28d7300f" translate="yes" xml:space="preserve">
          <source>Alternatively you can discover which binary optimizations are enabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2db455af7c311c86d9a9e68fe99ec219f1fdb6" translate="yes" xml:space="preserve">
          <source>Alternatively, the function attribute &lt;code&gt;noplt&lt;/code&gt; can be used to avoid calls through the PLT for specific external functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724d746f6afeb6dcb4048f896627e2174930b360" translate="yes" xml:space="preserve">
          <source>Alternatively, you might decide to put the precompiled header file in a directory and use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f269cf4efa79d9433eb0cf9a5bd7a136f8f62d" translate="yes" xml:space="preserve">
          <source>Although IRA uses a sophisticated algorithm to compress the conflict table, the table can still require excessive amounts of memory for huge functions. If the conflict table for a function could be more than the size in MB given by this parameter, the register allocator instead uses a faster, simpler, and lower-quality algorithm that does not require building a pseudo-register conflict table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0be486c711e5de323bb610f3f803e2869a722a" translate="yes" xml:space="preserve">
          <source>Although an effort has been made to warn about all such cases, there are probably some cases that are not warned about, even though G++ is generating incompatible code. There may also be cases where warnings are emitted even though the code that is generated is compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a8f5762db94ffdfef370246b2c12c4c385d73d" translate="yes" xml:space="preserve">
          <source>Although it is possible to define such a function, this is not very useful as it is not possible to read the arguments. This is only supported for C as this construct is allowed by C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aea130ff16faac0f0a72d4c21d30b19934fa1e8" translate="yes" xml:space="preserve">
          <source>Although the behavior is similar to the Gold Linker&amp;rsquo;s ICF optimization, GCC ICF works on different levels and thus the optimizations are not same - there are equivalences that are found only by GCC and equivalences found only by Gold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2ebe14b431087c27c2301bbb04cfe4eb87ea4a" translate="yes" xml:space="preserve">
          <source>Although the primary usage of this attribute is for POD types, the attribute can also be applied to global C++ objects that are initialized by a constructor. In this case, the static initialization and destruction code for the object is emitted in each translation defining the object, but the calls to the constructor and destructor are protected by a link-once guard variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419e2ab79b9a72e513efa7d620ba40673796ae3c" translate="yes" xml:space="preserve">
          <source>Although the size of a zero-length array is zero, an array member of this kind may increase the size of the enclosing type as a result of tail padding. The offset of a zero-length array member from the beginning of the enclosing structure is the same as the offset of an array with one or more elements of the same type. The alignment of a zero-length array is the same as the alignment of its elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a0b2e6239d57c9c30535eae8caf6619e4d8826" translate="yes" xml:space="preserve">
          <source>Altivec register if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43210ad7cdf91a35ea9e54b8ca8e28c22c6e9fd2" translate="yes" xml:space="preserve">
          <source>Altivec register to use for double loads/stores or NO_REGS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e72319ddb65cddc1596b72314174c11a529e4e9" translate="yes" xml:space="preserve">
          <source>Altivec register to use for float/32-bit int loads/stores or NO_REGS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27667baa779021dc30ceb24d0b6298a36d1ae73c" translate="yes" xml:space="preserve">
          <source>Altivec vector register</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7213a39022a1a221aa305b421707bb55dfa13ff8" translate="yes" xml:space="preserve">
          <source>Always treat bit-fields as &lt;code&gt;int&lt;/code&gt;-sized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549d944304e895a2c1d4531ead649e8cbf5063ad" translate="yes" xml:space="preserve">
          <source>Always use a library call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4062f8987d50153e0838000ddb5e4f41ad4e24" translate="yes" xml:space="preserve">
          <source>Among the consequences of these changes are that static data members of the same type with the same name but defined in different shared objects are different, so changing one does not change the other; and that pointers to function members defined in different shared objects may not compare equal. When this flag is given, it is a violation of the ODR to define types with the same name differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="c5009a6f1efb8810f35df0d2766e52237ed673ad" translate="yes" xml:space="preserve">
          <source>An 8 bit value with exactly one bit set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fdb3be2e0086894a1e44f055f6c3c5fe05581e" translate="yes" xml:space="preserve">
          <source>An 8-element vector constant with identical elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e73ea7df5141021212bafc4bcfa0e59c8e090d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm goto&lt;/code&gt; statement cannot have outputs. This is due to an internal restriction of the compiler: control transfer instructions cannot have outputs. If the assembler code does modify anything, use the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber to force the optimizers to flush all register values to memory and reload them if necessary after the &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04db20c14b6b3a82ba6832f795aabb1d2758d6a2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm&lt;/code&gt; statement has zero or more output operands indicating the names of C variables modified by the assembler code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ecf57ab1f86499d0414e65689faa519df6b817" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; type is not considered to be compatible with another &lt;code&gt;enum&lt;/code&gt; type even if both are compatible with the same integer type; this is what the C standard specifies. For example, &lt;code&gt;enum {foo, bar}&lt;/code&gt; is not similar to &lt;code&gt;enum {hot, dog}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="197244fadb4ff328f7464f8fb593d34255a64886" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier list&lt;/em&gt; is a sequence of one or more attribute specifiers, not separated by any other tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db760995f077b22b4a4d97b7a5f59e2f43ffc2f" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier&lt;/em&gt; is of the form &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt;. An &lt;em&gt;attribute list&lt;/em&gt; is a possibly empty comma-separated sequence of &lt;em&gt;attributes&lt;/em&gt;, where each attribute is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caef8d867ec8d279c62d15ef41539390101b886c" translate="yes" xml:space="preserve">
          <source>An I-type 12-bit signed immediate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06327d0e0884e8359c3aeb898ee10e76eb6687a6" translate="yes" xml:space="preserve">
          <source>An absolute address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c6a7cdfe8551206974bd67b2a089dc6fe26252" translate="yes" xml:space="preserve">
          <source>An absolute symbolic address or a label reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986b6a4e37803f27663b870d347fe309ea3ea740" translate="yes" xml:space="preserve">
          <source>An address suitable for a &lt;code&gt;prefetch&lt;/code&gt; instruction, or for any other instruction with the same addressing mode as &lt;code&gt;prefetch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892155354f6089e8dd5e479a72ea4a1751091291" translate="yes" xml:space="preserve">
          <source>An address that can be used in a non-macro load or store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff106250bd6a1ea035dee107e3b2d2773c2aecc2" translate="yes" xml:space="preserve">
          <source>An address that is held in a general-purpose register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebfbf78a988fb6bc16aa1ac07630bba74056e531" translate="yes" xml:space="preserve">
          <source>An address which does not involve register indirect addressing or pre/post increment/decrement addressing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3211e293506f09ee6205a6286105b13b8dd093c" translate="yes" xml:space="preserve">
          <source>An alternate way to write the above example is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed98e3e9e5fb257c8559031222af1c4e1303971" translate="yes" xml:space="preserve">
          <source>An alternative syntax for this that has been obsolete since GCC 2.5 but GCC still accepts is to write &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba051ca8ecdb334d29fa5a48a0711170d4503f7" translate="yes" xml:space="preserve">
          <source>An alternative to increasing the size of the destination buffer is to constrain the range of formatted values. The maximum length of string arguments can be bounded by specifying the precision in the format directive. When numeric arguments of format directives can be assumed to be bounded by less than the precision of their type, choosing an appropriate length modifier to the format specifier will reduce the required buffer size. For example, if &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; in the example above can be assumed to be within the precision of the &lt;code&gt;short int&lt;/code&gt; type then using either the &lt;code&gt;%hi&lt;/code&gt; format directive or casting the argument to &lt;code&gt;short&lt;/code&gt; reduces the maximum required size of the buffer to 24 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ac40bd537abd77f944ca782b1d8e24e3e93586" translate="yes" xml:space="preserve">
          <source>An amendment to the 1990 standard was published in 1995. This amendment added digraphs and &lt;code&gt;__STDC_VERSION__&lt;/code&gt; to the language, but otherwise concerned the library. This amendment is commonly known as &lt;em&gt;AMD1&lt;/em&gt;; the amended standard is sometimes known as &lt;em&gt;C94&lt;/em&gt; or &lt;em&gt;C95&lt;/em&gt;. To select this standard in GCC, use the option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec9ea45e6f6d2866eabdf39502663d30e59ccdc" translate="yes" xml:space="preserve">
          <source>An application can interpose its own definition of functions for functions invoked by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79eafbcf2b7c5c25e774d3009d7ad66460a67d81" translate="yes" xml:space="preserve">
          <source>An area where the difference is most apparent is name mangling. The use of different name mangling is intentional, to protect you from more subtle problems. Compilers differ as to many internal details of C++ implementation, including: how class instances are laid out, how multiple inheritance is implemented, and how virtual function calls are handled. If the name encoding were made the same, your programs would link against libraries provided from other compilers&amp;mdash;but the programs would then crash when run. Incompatible libraries are then detected at link time, rather than at run time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97545d568f0ddabc50a6a6e190b9c96c3da5965" translate="yes" xml:space="preserve">
          <source>An assembler template is a literal string containing assembler instructions. The compiler replaces tokens in the template that refer to inputs, outputs, and goto labels, and then outputs the resulting string to the assembler. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input. However, it does count the statements (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8ae718bdcb577716b49e495b23a5d728121d19" translate="yes" xml:space="preserve">
          <source>An atomic operation can both constrain code motion and be mapped to hardware instructions for synchronization between threads (e.g., a fence). To which extent this happens is controlled by the memory orders, which are listed here in approximately ascending order of strength. The description of each memory order is only meant to roughly illustrate the effects and is not a specification; see the C++11 memory model for precise semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d88b31282dc4372978d47c4d528de2e00c16901" translate="yes" xml:space="preserve">
          <source>An attribute name (which may be an identifier such as &lt;code&gt;unused&lt;/code&gt;, or a reserved word such as &lt;code&gt;const&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65131f3242824d199035927efcf93043285cd45" translate="yes" xml:space="preserve">
          <source>An attribute name followed by a parenthesized list of parameters for the attribute. These parameters take one of the following forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d755f91a373e17fad5f0c5626bbbba251cf643a" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear as part of a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; specifier. It may go either immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword, or after the closing brace. The former syntax is preferred. Where attribute specifiers follow the closing brace, they are considered to relate to the structure, union or enumerated type defined, not to any enclosing declaration the type specifier appears in, and the type defined is not complete until after the attribute specifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5e73e14616e06a74db1d5feee8111efc621957" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear at the start of a nested declarator. At present, there are some limitations in this usage: the attributes correctly apply to the declarator, but for most individual attributes the semantics this implies are not implemented. When attribute specifiers follow the &lt;code&gt;*&lt;/code&gt; of a pointer declarator, they may be mixed with any type qualifiers present. The following describes the formal semantics of this syntax. It makes the most sense if you are familiar with the formal specification of declarators in the ISO C standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c786fbc073ea725818acf8d9cbe4bc390cf984" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before a declarator (other than the first) in a comma-separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers. Such attribute specifiers apply only to the identifier before whose declarator they appear. For example, in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be5978cee71999e28113db755252c2c229b75be6" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before the comma, &lt;code&gt;=&lt;/code&gt; or semicolon terminating the declaration of an identifier other than a function definition. Such attribute specifiers apply to the declared object or function. Where an assembler name for an object or function is specified (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;), the attribute must follow the &lt;code&gt;asm&lt;/code&gt; specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c400bc0897dcce315e482021ea5ac2d0b133c9" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may, in future, be permitted to appear after the declarator in a function definition (before any old-style parameter declarations or the function body).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a74a1d3ff08634b1a7446e5738ed8abb53ee53ac" translate="yes" xml:space="preserve">
          <source>An empty replacement string indicates that the given range is to be removed. An empty range (e.g. &amp;ldquo;45:3-45:3&amp;rdquo;) indicates that the string is to be inserted at the given position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae58fb99fa1b71a549f28d943d2b614039f2208" translate="yes" xml:space="preserve">
          <source>An identifier followed by a comma and a non-empty comma-separated list of expressions. For example, &lt;code&gt;format&lt;/code&gt; attributes use this form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d7bc1885869717ff785880a55a84832370a8cc" translate="yes" xml:space="preserve">
          <source>An identifier. For example, &lt;code&gt;mode&lt;/code&gt; attributes use this form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec5ac33481525fe53d426cd6db6a12a229bec4c" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt; or &lt;code&gt;const_vector&lt;/code&gt;) is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594d6eba8a97b362385ec37bc0e852d2a80c0ac2" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt;) is allowed, but only if the target floating point format is the same as that of the host machine (on which the compiler is running).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c315fd75b55a96544e61998f54c1ece5842737a" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is sign extended as a 128 bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ccfcfe71dbbefbcc7083b3111e73c588704efb6" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 32 bit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a74b5a5b038401ba585b82ac648a38ee34ae7d" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 64 bit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724f31235beec2d91358f29c81609301ddfe064d" translate="yes" xml:space="preserve">
          <source>An immediate for most arithmetic instructions. const_int is treated as a 32 bit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5952eb86810c12a13a67307b761f420789e80d" translate="yes" xml:space="preserve">
          <source>An immediate for shift and rotate instructions. const_int is treated as a 32 bit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f576fc6545e2a7ed32b49891eee7158495619f8" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is sign extended to 128 bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa46e8c9174bfc14d1e6484c608422836253b5fc" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 32 bit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ad2e9f47c35dba5c3a654586cfbfd37c2d1074" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 64 bit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6b5c59189bcd298a8c54b0d5b72012198931a3" translate="yes" xml:space="preserve">
          <source>An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84f183cbd16bd54d89a362096c570a83e737d81" translate="yes" xml:space="preserve">
          <source>An immediate integer operand whose value is not an explicit integer is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcd4c571d6303522812fd66511c9efeae10aff4" translate="yes" xml:space="preserve">
          <source>An immediate integer operand with a known numeric value is allowed. Many systems cannot support assembly-time constants for operands less than a word wide. Constraints for these operands should use &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fead0cb9bc3652a20a6803e3e14fb097bc244e18" translate="yes" xml:space="preserve">
          <source>An immediate operand for R2 andchi/andci instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac68e335d064a71570d610173f680ac5fbe05513" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea450ed2fe096f001d0fa25412cdd9e4110db1ae" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is sign extended to 128 bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c728956eab601b71ea1ef8510f9ed46b01e9678" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 32 bit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b91f62ddf90eb3045924f61638e2ed286dc7c16" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 64 bit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e53dc412a13c67bb00bedf4c0eac4f87ba77c1" translate="yes" xml:space="preserve">
          <source>An important caveat is that GCC arranges to save and restore only those registers known to the specific architecture variant being compiled for. This can make &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; more efficient than their library counterparts in some cases, but it can also cause incorrect and mysterious behavior when mixing with code that uses the full register set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86c0eceb044416401abb04a6e463d5b6094cd25" translate="yes" xml:space="preserve">
          <source>An input register that is implicitly popped by the &lt;code&gt;asm&lt;/code&gt; must be explicitly clobbered, unless it is constrained to match an output operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c249498e8a7c24a4e363a078596ccff4c5734ab" translate="yes" xml:space="preserve">
          <source>An integer constant in the range -255 &amp;hellip; 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dc7773cc8d9e6deceeb329e43d478d46251dfd7" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 0 &amp;hellip; 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b08127ba5b721033e68de80fdaced9cd1b46db8" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28d87e9d901db2966f212d84f0e7048b61d9b95" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc6027cc8de73ec51a063277dae667199da440f" translate="yes" xml:space="preserve">
          <source>An integer constant that does not meet the constraints for codes &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84f7429b210360fa5c85dafb3a76127af085fed" translate="yes" xml:space="preserve">
          <source>An integer constant that fits in 16 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea8f3048d5d170816523d297bd8775793dabcbf" translate="yes" xml:space="preserve">
          <source>An integer constant whose low order 16 bits are zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91669a0b9c65d1cc6722fd1ac4e811cb3b9462cf" translate="yes" xml:space="preserve">
          <source>An integer constant with all bits set except exactly one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21493d2e6936d92d54e34c6a9c53ba6429a374d6" translate="yes" xml:space="preserve">
          <source>An integer constant with exactly a single bit set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148e29efc3e25eee684ae13925c5fb8932f17d90" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use only with accumulator A1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4afba48092a6cec863cdd332d5c5c0ad22e2831" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use with either accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1c35a13fe5ef99c7a9d9e7d6ae5125aea6469c" translate="yes" xml:space="preserve">
          <source>An interrupt handler must be declared with a mandatory pointer argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d371e86b4fb307c14a25adf02422873dfe31a1a2" translate="yes" xml:space="preserve">
          <source>An inverted bitfield mask suitable for bext or bins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d009fe9b76c291a5aa0c7f6c1e8d1138fabbeb43" translate="yes" xml:space="preserve">
          <source>An item in the constant pool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4793f292bc93fcd62120f48245f5e44fb822389b" translate="yes" xml:space="preserve">
          <source>An object file to be fed straight into linking. Any file name with no recognized suffix is treated this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8b9f9703de2f2ca710a30d52808d7dca0bcb72" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;__thread&lt;/code&gt; has &lt;em&gt;thread storage duration&lt;/em&gt;. Its lifetime is the entire execution of the thread, and its stored value is initialized only once, prior to thread startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a7967fec1a33e4d839edd6eff5a38decb9b59d" translate="yes" xml:space="preserve">
          <source>An offset address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89feeff33c633de750f5bb644b0891d21925addb" translate="yes" xml:space="preserve">
          <source>An offset address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa367c1ec44c9cba3102e666432b6606342ed893" translate="yes" xml:space="preserve">
          <source>An operand that is a valid memory address is allowed. This is for &amp;ldquo;load address&amp;rdquo; and &amp;ldquo;push address&amp;rdquo; instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a3bc3b1208cdb1273c2b09519bfd9e1cfc45ea" translate="yes" xml:space="preserve">
          <source>An operand that matches the specified operand number is allowed. If a digit is used together with letters within the same alternative, the digit should come last.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d03643cf5743c896341a88665563cee4e7f14b" translate="yes" xml:space="preserve">
          <source>An optimization that assumes that signed overflow does not occur is perfectly safe if the values of the variables involved are such that overflow never does, in fact, occur. Therefore this warning can easily give a false positive: a warning about code that is not actually a problem. To help focus on important issues, several warning levels are defined. No warnings are issued for the use of undefined signed overflow when estimating how many iterations a loop requires, in particular when determining whether a loop will be executed at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b187d1cbe2c1e6182a8dd178f33fdc1911f0fd4c" translate="yes" xml:space="preserve">
          <source>An overview of these techniques, their benefits and how to use them is at &lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibility&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78963be09ff63d4ade4602b745f27f40ed01fe1b" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant (for logic instructions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b34b8bcf92baede87b31604702d88f2552f8622" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant for &lt;code&gt;iohl&lt;/code&gt; and &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb9a0ccfe5c932918592859dcea72edc71b9826" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ef4bae4950c14cd2a335ebce3f24b00931f1ee" translate="yes" xml:space="preserve">
          <source>An unsigned 3-bit constant for 16-byte rotates and shifts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ddaf18fc4d2ab678603464648f03bb8de98a4d" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a00eda1fa05aab415bb11f10e795bf964e4785" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant for conversion/nop/channel instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0bf2d7544790a0320ec8391816f55aa165f088" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant whose 3 least significant bits are 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8a3cd83ae17cf2c173ff325905d55cd210117b" translate="yes" xml:space="preserve">
          <source>An x86 example where the string memory argument is of unknown length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8157a3070b0a23e585bb72291a5f64fac3066253" translate="yes" xml:space="preserve">
          <source>And the function names are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce6aeb578cc150b67e8e4f1acfc181fb9996f38" translate="yes" xml:space="preserve">
          <source>Annotate assembler instructions with estimated addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295ae69532c434798f968812e2201e5c3fd052fa" translate="yes" xml:space="preserve">
          <source>Annotate assignments to user variables early in the compilation and attempt to carry the annotations over throughout the compilation all the way to the end, in an attempt to improve debug information while optimizing. Use of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fb5f4abaa1eaa677691ec6945ce018c8d3cc8a" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with a comment indicating which pattern and alternative is used. The length and cost of each instruction are also printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a92e7968152fb0b277671cc51df48b140f38ff" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with miscellaneous debugging information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="989a73be7d945cbd818654da9eb44b704400138e" translate="yes" xml:space="preserve">
          <source>Another (simpler) way to enable link-time optimization is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f160715f630ab62644e4593ac2d81e2aac8d1b" translate="yes" xml:space="preserve">
          <source>Another consequence is that &lt;code&gt;sscanf&lt;/code&gt; does not work on some very old systems when passed a string constant as its format control string or input. This is because &lt;code&gt;sscanf&lt;/code&gt; incorrectly tries to write into the string constant. Likewise &lt;code&gt;fscanf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3114d5262ea0b2a7df098211946bd465d7ca75ca" translate="yes" xml:space="preserve">
          <source>Another feature of LTO is that it is possible to apply interprocedural optimizations on files written in different languages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800bcf1831a315ef5fa60f82c87dd864fc821d9c" translate="yes" xml:space="preserve">
          <source>Another restriction is that the clobber list should not contain the stack pointer register. This is because the compiler requires the value of the stack pointer to be the same after an &lt;code&gt;asm&lt;/code&gt; statement as it was on entry to the statement. However, previous versions of GCC did not enforce this rule and allowed the stack pointer to appear in the list, with unclear semantics. This behavior is deprecated and listing the stack pointer may become an error in future versions of GCC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cec1a74ddd904f5065125e6e0eba36e86de4da" translate="yes" xml:space="preserve">
          <source>Another revised ISO C++ standard was published in 2014 as ISO/IEC 14882:2014, and is referred to as C++14; before its publication it was sometimes referred to as C++1y. C++14 contains several further changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100b9161d8847e18a3c098c1597e4c27bddc1e4a" translate="yes" xml:space="preserve">
          <source>Another syntax that has the same meaning, obsolete since GCC 2.5, is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4503c0d7b11d51381b2775fa2f1d0bc68346b0" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;__builtin_unreachable&lt;/code&gt; is following a call a function that never returns but that is not declared &lt;code&gt;__attribute__((noreturn))&lt;/code&gt;, as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c0df1874478fedada2f09d07323584aaf952db" translate="yes" xml:space="preserve">
          <source>Another use of label values is in an interpreter for threaded code. The labels within the interpreter function can be stored in the threaded code for super-fast dispatching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054bb42dabc9a19f68ad68065d19f8cf04a8d0cf" translate="yes" xml:space="preserve">
          <source>Another way to refer to the type of an expression is with &lt;code&gt;typeof&lt;/code&gt;. The syntax of using of this keyword looks like &lt;code&gt;sizeof&lt;/code&gt;, but the construct acts semantically like a type name defined with &lt;code&gt;typedef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a721e97bbca8eab5f82eabfccb957a729c8f492f" translate="yes" xml:space="preserve">
          <source>Another way to specify a prefix much like the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96409c8e4594c5ca23408453d9c7d3939d189e53" translate="yes" xml:space="preserve">
          <source>Another, similar example involves calling member functions of a base class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53491a8e8187c94a2d02f53706e5a4e898389bcf" translate="yes" xml:space="preserve">
          <source>Any 80387 floating-point (stack) register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3758814c17061e556dad37977ffba674151e160" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;symbol_ref&lt;/code&gt; or &lt;code&gt;label_ref&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f752342a0bbfde2ec460c7e0098752d0a9c8ba" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;unspec&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08321582787b969fc3f46ec2caec6f021be74d45" translate="yes" xml:space="preserve">
          <source>Any D, P, B, M, I or L register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d7faf7c72e44e81295ee83f9349235dc1598af" translate="yes" xml:space="preserve">
          <source>Any EVEX encodable SSE register (&lt;code&gt;%xmm0-%xmm31&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162a9ef967e5306147bc46c88126767e87c35020" translate="yes" xml:space="preserve">
          <source>Any MMX register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6a18dc34784ab21c4ba11b353b499414254204" translate="yes" xml:space="preserve">
          <source>Any SSE register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6050748b38d243b476a4baca6c16743585fafbd7" translate="yes" xml:space="preserve">
          <source>Any SYMBOL_REF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458f2948a2c464f5746c7ffc43449a651a2011cd" translate="yes" xml:space="preserve">
          <source>Any VSX register if the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8389ba5b054471dbefb65e013349dc9adfee3c7" translate="yes" xml:space="preserve">
          <source>Any array can be subscripted, even if not an lvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b564784ad63437bf2bebc716f7f298f61a5028" translate="yes" xml:space="preserve">
          <source>Any const_double value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9dc0d4d4d3fa3953a7b89d1659a04266824dc2" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 16 bits wide (nothing if control registers are 24 bits wide)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdd92208f9952a1f355fdf3b7526b8f7a44d2c0" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 24 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9a960c7b57410e9d4ca5df2e5f2e42c59f7d8b" translate="yes" xml:space="preserve">
          <source>Any data or pointers to the non-generic address spaces must be qualified as &lt;code&gt;const&lt;/code&gt;, i.e. as read-only data. This still applies if the data in one of these address spaces like software version number or calibration lookup table are intended to be changed after load time by, say, a boot loader. In this case the right qualification is &lt;code&gt;const&lt;/code&gt;&lt;code&gt;volatile&lt;/code&gt; so that the compiler must not optimize away known values or insert them as immediates into operands of instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a587b8fa898666a201d21b98455df1bf047bae" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialised by the C runtime startup code, or the program loader. Not initialising data in this way can reduce program startup times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1647cf01ffb6c880e2cc9ddc546cf116110a80e6" translate="yes" xml:space="preserve">
          <source>Any dependence for which the latency is greater than or equal to &lt;var&gt;number&lt;/var&gt; is costly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d255d43091079c6ba1e5343929cbd0d4605f04" translate="yes" xml:space="preserve">
          <source>Any dependence from store to load is costly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b989b6176274d8479bf98d4817d8a49a56f0e0" translate="yes" xml:space="preserve">
          <source>Any directories specified with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d356594a5d83b50830291445eb406f59dd05afc" translate="yes" xml:space="preserve">
          <source>Any expression of type &lt;code&gt;void *&lt;/code&gt; is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68030c2dfbf4d205419f4c53b98009b37766c0cb" translate="yes" xml:space="preserve">
          <source>Any extended integer types that exist in the implementation (C99 and C11 6.2.5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1de0dfba46a4460bfe571dd6ce87a521e49944" translate="yes" xml:space="preserve">
          <source>Any interruptible-without-stack-switch code must be compiled with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a99fee73d1a0400c42d60b6ea95667d276cf8e" translate="yes" xml:space="preserve">
          <source>Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers, whether or not such a list may in that context contain storage class specifiers. (Some attributes, however, are essentially in the nature of storage class specifiers, and only make sense where storage class specifiers may be used; for example, &lt;code&gt;section&lt;/code&gt;.) There is one necessary limitation to this syntax: the first old-style parameter declaration in a function definition cannot begin with an attribute specifier, because such an attribute applies to the function instead by syntax described below (which, however, is not yet implemented in this case). In some other cases, attribute specifiers are permitted by this grammar but not yet supported by the compiler. All attribute specifiers in this place relate to the declaration as a whole. In the obsolescent usage where a type of &lt;code&gt;int&lt;/code&gt; is implied by the absence of type specifiers, such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c0071eb01b7f92c396e6d09604df6a2e8de02f" translate="yes" xml:space="preserve">
          <source>Any macros defined before the precompiled header is included must either be defined in the same way as when the precompiled header was generated, or must not affect the precompiled header, which usually means that they don&amp;rsquo;t appear in the precompiled header at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b92c247ae43e16cb2206e363e27a0e1ea146660" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the far address space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16a334f229304e5f8dc7cc1bd4372e8b13392d9" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the near address space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3f2043c21601ac2916c25995530fdcaff3e36d" translate="yes" xml:space="preserve">
          <source>Any mode at function entry is valid, and retained or restored when the function returns, and when it calls other functions. This mode is useful for compiling libraries or other compilation units you might want to incorporate into different programs with different prevailing FPU modes, and the convenience of being able to use a single object file outweighs the size and speed overhead for any extra mode switching that might be needed, compared with what would be needed with a more specific choice of prevailing FPU mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22db441873bce8bb93866379f320414a736631d8" translate="yes" xml:space="preserve">
          <source>Any of the SVE predicate registers (&lt;code&gt;P0&lt;/code&gt; to &lt;code&gt;P15&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb9f4f59a4cdd5c36fdb71fd2855542ab27a73f" translate="yes" xml:space="preserve">
          <source>Any of the floating point registers (AC0 through AC5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b07ecf518f850aa2d367035bbfbe9f027595c80" translate="yes" xml:space="preserve">
          <source>Any operand whatsoever is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68eb98cf68489e1273e0a62b2ba59241c457e20" translate="yes" xml:space="preserve">
          <source>Any register</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3553311a1c2384ac5d5327beb00f7dd79264da05" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt;: &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0809f627bf7826a77322582ca3922a14c79d5ea4" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt;. In 32-bit mode, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;; in 64-bit mode, any integer register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c586b6a4345439cd7c8437d618d713fde64e21d5" translate="yes" xml:space="preserve">
          <source>Any register except accumulators or CC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5e5f5ddbf2830c0d8f5e8f65ca789f3fd09903" translate="yes" xml:space="preserve">
          <source>Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d047e8a746fffe93cd425189ec60df3684116e7" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;based&lt;/code&gt; attribute is assigned to the &lt;code&gt;.based&lt;/code&gt; section, and is accessed with relative to the &lt;code&gt;$tp&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e967d4316910c49c908407ba08671d2b2599c34" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;persistent&lt;/code&gt; attribute will not be initialised by the C runtime startup code. Instead its value will be set once, when the application is loaded, and then never initialised again, even if the processor is reset or the program restarts. Persistent data is intended to be placed into FLASH RAM, where its value will be retained across resets. The linker script being used to create the application should ensure that persistent data is correctly placed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6814c1eba0c0bb145d77465185a812135711db30" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;dir&lt;/var&gt; to the prefix specified previously with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812a14ffbe77d828291132cdec93d807373c47c5" translate="yes" xml:space="preserve">
          <source>Application register residing in I-unit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1236d15ff73551e90456786e45b32e0be147101a" translate="yes" xml:space="preserve">
          <source>Application register residing in M-unit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157c651a499c80b5c8fd2d703d99af67d3154b57" translate="yes" xml:space="preserve">
          <source>Apply partitioned execution optimizations. This is the default when any level of optimization is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1782ef9fd22ce5aa8daf22e12703623a7b69b3eb" translate="yes" xml:space="preserve">
          <source>Apply the &lt;code&gt;longcall&lt;/code&gt; attribute to all subsequent function declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282eae08ca98891b7edf1b6d8797fd6b87a9eaef" translate="yes" xml:space="preserve">
          <source>Apply unroll and jam transformations on feasible loops. In a loop nest this unrolls the outer loop by some factor and fuses the resulting multiple inner loops. This flag is enabled by default at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5180e6ec8c8c3a9e7de475a7424e90e67f44108f" translate="yes" xml:space="preserve">
          <source>Arguments of type &lt;code&gt;uh&lt;/code&gt;, &lt;code&gt;uw1&lt;/code&gt;, &lt;code&gt;sw1&lt;/code&gt;, &lt;code&gt;uw2&lt;/code&gt; and &lt;code&gt;sw2&lt;/code&gt; are evaluated at run time. They correspond to register operands in the underlying FR-V instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b636e6a8cfc32ea746d5e97119c5c9f0abb374" translate="yes" xml:space="preserve">
          <source>Arguments that are documented as &lt;code&gt;const int&lt;/code&gt; require literal integral values within the range required for that operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56dc33ad93362bc115e17a1a1f9e847be1eea766" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;void&lt;/code&gt;-pointers and function pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47ecbfd9e2fe292a564bf4865f526df3c8781c7" translate="yes" xml:space="preserve">
          <source>Arrays whose length is computed at run time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62bbe9126770d1f883012b542af60463a81fc16c" translate="yes" xml:space="preserve">
          <source>As a GNU extension, GCC allows initialization of objects with static storage duration by compound literals (which is not possible in ISO C99 because the initializer is not a constant). It is handled as if the object were initialized only with the brace-enclosed list if the types of the compound literal and the object match. The elements of the compound literal must be constant. If the object being initialized has array type of unknown size, the size is determined by the size of the compound literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b14342b73dd91f2d28adcdc3851266c0e2adc9" translate="yes" xml:space="preserve">
          <source>As a part of ACLE, GCC implements extensions for Advanced SIMD as described in the ARM C Language Extensions Specification. The complete list of Advanced SIMD intrinsics can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt;. The built-in intrinsics for the Advanced SIMD extension are available when NEON is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf025a6b55c5b2b4d36feb2983875ada48832c0" translate="yes" xml:space="preserve">
          <source>As a result, if a function compiled with Sun CC takes the address of an argument of type &lt;code&gt;double&lt;/code&gt; and passes this pointer of type &lt;code&gt;double *&lt;/code&gt; to a function compiled with GCC, dereferencing the pointer may cause a fatal signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fe12b60268d72ed32d2dad542457f63b7450a6" translate="yes" xml:space="preserve">
          <source>As a result, when a file is compiled with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de76cec1a0ee40014e9d6de2336c465c8c2b9403" translate="yes" xml:space="preserve">
          <source>As a special kludge, if the path provided by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70ccdaa2f1d44ed8f039d89a64ebf9722e0436b" translate="yes" xml:space="preserve">
          <source>As an alternative to providing a spec string, the text following a suffix directive can be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733120310e3f16a7d9b6ceb479247f71058a2dab" translate="yes" xml:space="preserve">
          <source>As an extension the integer scalar type &lt;code&gt;__int128&lt;/code&gt; is supported for targets which have an integer mode wide enough to hold 128 bits. Simply write &lt;code&gt;__int128&lt;/code&gt; for a signed 128-bit integer, or &lt;code&gt;unsigned __int128&lt;/code&gt; for an unsigned 128-bit integer. There is no support in GCC for expressing an integer constant of type &lt;code&gt;__int128&lt;/code&gt; for targets with &lt;code&gt;long long&lt;/code&gt; integer less than 128 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f87270bea18e65d71a654a8f0baf39b38c480a" translate="yes" xml:space="preserve">
          <source>As an extension to the C language, GCC does not use the latitude given in C99 and C11 only to treat certain aspects of signed &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4513679ee7e9cc2a019ac56fe5e24f303a414ac9" translate="yes" xml:space="preserve">
          <source>As an extension, GCC accepts variable-length arrays as a member of a structure or a union. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e4f48620a93a562285a400297cd393c63d1803" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C and GNU C++ support additional floating types, which are not supported by all targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697b66e118a429cde99672cf767b29bbf7517cb2" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports decimal floating types as defined in the N1312 draft of ISO/IEC WDTR24732. Support for decimal floating types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support decimal floating types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e14a45ce2c917a5c2a3b3b95aa86553c2d0d4a7" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports fixed-point types as defined in the N1169 draft of ISO/IEC DTR 18037. Support for fixed-point types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support fixed-point types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7086d776842151d1d2c42c2e5523eaf5840573e5" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, SPU, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adca7822f575134857a5ee57f78ae4fe66d4c44f" translate="yes" xml:space="preserve">
          <source>As an optimization, G++ sometimes gives array compound literals longer lifetimes: when the array either appears outside a function or has a &lt;code&gt;const&lt;/code&gt;-qualified type. If &lt;code&gt;foo&lt;/code&gt; and its initializer had elements of type &lt;code&gt;char *const&lt;/code&gt; rather than &lt;code&gt;char *&lt;/code&gt;, or if &lt;code&gt;foo&lt;/code&gt; were a global variable, the array would have static storage duration. But it is probably safest just to avoid the use of array compound literals in C++ code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4440512ea926e0e3e9623211be65c0fe001b769e" translate="yes" xml:space="preserve">
          <source>As another example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d7d2d398b725a8ff7f6339f33b58fb71e37c73" translate="yes" xml:space="preserve">
          <source>As another example, the following call to &lt;code&gt;strncpy&lt;/code&gt; results in copying to &lt;code&gt;d&lt;/code&gt; just the characters preceding the terminating NUL, without appending the NUL to the end. Assuming the result of &lt;code&gt;strncpy&lt;/code&gt; is necessarily a NUL-terminated string is a common mistake, and so the call is diagnosed. To avoid the warning when the result is not expected to be NUL-terminated, call &lt;code&gt;memcpy&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22e08722bb8e7ce646a0894d86b714e1a18ddc2" translate="yes" xml:space="preserve">
          <source>As bit-fields are not individually addressable, volatile bit-fields may be implicitly read when written to, or when adjacent bit-fields are accessed. Bit-field operations may be optimized such that adjacent bit-fields are only partially accessed, if they straddle a storage unit boundary. For these reasons it is unwise to use volatile bit-fields to access hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54cb09a605966e1ec9e0e0780e8355b83cacd9f7" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, this attribute allows specification of target-specific compilation options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47f4f2d2c816a9b7574ec5c08de30912daa2a80" translate="yes" xml:space="preserve">
          <source>As for &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71478357402c28a54c8c6fca58d451aad7e53ab5" translate="yes" xml:space="preserve">
          <source>As in standard C++ and ISO C99, the elements of an aggregate initializer for an automatic variable are not required to be constant expressions in GNU C. Here is an example of an initializer with run-time varying elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19fab7ccaf71008439ad46e66a6dd8a8249abc0" translate="yes" xml:space="preserve">
          <source>As in the preceding example, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; type. Alternatively, you can leave out the alignment factor and just ask the compiler to align a type to the maximum useful alignment for the target machine you are compiling for. For example, you could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67040c22389d40183c4661602eeb071108d65a1" translate="yes" xml:space="preserve">
          <source>As in the preceding examples, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given variable or structure field. Alternatively, you can leave out the alignment factor and just ask the compiler to align a variable or field to the default alignment for the target architecture you are compiling for. The default alignment is sufficient for all scalar types, but may not be enough for all vector types on a target that supports vector operations. The default alignment is fixed for a particular target ABI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4953117cca7e33df31955c24738168de010b1a14" translate="yes" xml:space="preserve">
          <source>As long as the stack frame backchain is not used, code generated with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55612a0f57841c9314e7eae808cb715df500b680" translate="yes" xml:space="preserve">
          <source>As mentioned above, the new exceptions do not support handling types other than Objective-C objects. Furthermore, when used from Objective-C++, the Objective-C exception model does not interoperate with C++ exceptions at this time. This means you cannot &lt;code&gt;@throw&lt;/code&gt; an exception from Objective-C and &lt;code&gt;catch&lt;/code&gt; it in C++, or vice versa (i.e., &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294a250033394e9398ee357e8a3028f8f81f0fc0" translate="yes" xml:space="preserve">
          <source>As new Intel processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the most current Intel processors at the time that version of GCC is released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071c1df1bb91e5145c672769a3ad43fada5e0f32" translate="yes" xml:space="preserve">
          <source>As new processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the processors that are most common at the time that version of GCC is released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3744f46b0905194e3e22c08ee725283caaeed6c9" translate="yes" xml:space="preserve">
          <source>As of the GCC 4.7.1 release, GCC supports the Go 1 language standard, described at &lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64c1bee27f99a750cc73752558d5aa035a91d3b" translate="yes" xml:space="preserve">
          <source>As of this writing, only the NeXT runtime on Mac OS X 10.4 and later has support for invoking the &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="190838497fcc16bfeb19ed9bf8cb7b33b5859658" translate="yes" xml:space="preserve">
          <source>As of this writing, there are no SPARC implementations that have hardware support for the quad-word floating-point instructions. They all invoke a trap handler for one of these instructions, and then the trap handler emulates the effect of the instruction. Because of the trap handler overhead, this is much slower than calling the ABI library routines. Thus the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea115f65d5a89a6a0ce102bba12e75c8b98c940e" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements the intrinsics below. FPTR is used here to mean any function pointer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e4fff7ccbcdce5ca766f79d5a621ec9dbe0d23" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements two new function attributes: &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; and &lt;code&gt;cmse_nonsecure_call&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6f3f1d276c90c5e06c8b6bf28158a5a889bccd" translate="yes" xml:space="preserve">
          <source>As permitted by ISO C11 and for compatibility with other compilers, GCC allows you to define a structure or union that contains, as fields, structures and unions without names. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd38e2252e3cfbc1562a66af3fc83a7b3476b926" translate="yes" xml:space="preserve">
          <source>As required by ISO C++, GCC considers member functions defined within the body of a class to be marked inline even if they are not explicitly declared with the &lt;code&gt;inline&lt;/code&gt; keyword. You can override this with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee86d176185420b2cd516cd28e0d2c038499f36a" translate="yes" xml:space="preserve">
          <source>As with all outermost parameter qualifiers, &lt;code&gt;__restrict__&lt;/code&gt; is ignored in function definition matching. This means you only need to specify &lt;code&gt;__restrict__&lt;/code&gt; in a function definition, rather than in a function prototype as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3fbd93824241c0022727ea0aaa70098dbf8058" translate="yes" xml:space="preserve">
          <source>As with global register variables, it is recommended that you choose a register that is normally saved and restored by function calls on your machine, so that calls to library routines will not clobber it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9e595b377650b7d530b408f01a2295e9aa3eb5" translate="yes" xml:space="preserve">
          <source>As with the C front end, G++ understands the C99 feature of restricted pointers, specified with the &lt;code&gt;__restrict__&lt;/code&gt;, or &lt;code&gt;__restrict&lt;/code&gt; type qualifier. Because you cannot compile C++ by specifying the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e7da79fc603087dc1baeac067752aa75dc3fe9" translate="yes" xml:space="preserve">
          <source>Assembler Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf5f12f4332ce70ca2c9b5133dda1d57f7cdf19" translate="yes" xml:space="preserve">
          <source>Assembler code that must be preprocessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9cab59729ce9a72e9592405aff1f8fcf01f46db" translate="yes" xml:space="preserve">
          <source>Assembler code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b8b4178e9d441788dbf96199839a839961313d" translate="yes" xml:space="preserve">
          <source>Assembler names for data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60468da111a0ab238610d89ab550d7cb3db7634" translate="yes" xml:space="preserve">
          <source>Assembler names for functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09492c8b5916e81a92681e73286dd4d053d0d64" translate="yes" xml:space="preserve">
          <source>Assembly output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20d25392b6fcd428956d9fadf904cf6f25c34c2" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a freestanding environment. This implies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b5344f90d89057b5b4c1d64f39bf480cc87ed4" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a hosted environment. This implies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6a91afbb703874ed1adcc1fc07fbc355255566" translate="yes" xml:space="preserve">
          <source>Assignments are also expressions and have an rvalue. However when assigning to a scalar volatile, the volatile object is not reread, regardless of whether the assignment expression&amp;rsquo;s rvalue is used or not. If the assignment&amp;rsquo;s rvalue is used, the value is that assigned to the volatile object. For instance, there is no read of &lt;var&gt;vobj&lt;/var&gt; in all the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c40f851ca2e4b0159b069f87df3cdf0c325569f" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that all symbols have 32-bit values, regardless of the selected ABI. This option is useful in combination with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f90ada4a3fec867ca24dbc5026596c24d16fc4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that externally-defined data is in a small data section if the size of that data is within the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfe16d43985ee39e482829ca4a8dfdcb2d636f4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6f2df5d90d0e07067a08f77629a109a7baeb7c" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI. Selecting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813b5f0f913426f167f43f6e9f2605b43322e0d6" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the static and dynamic linkers support PLTs and copy relocations. This option only affects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6218242555601cfde6dcb1f0fb4410c65b0c0afe" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that zero displacement conditional branch instructions &lt;code&gt;bt&lt;/code&gt; and &lt;code&gt;bf&lt;/code&gt; are fast. If</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d87b438e6a49fee40ee2b8e75d048b2cb33a8d4" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;int&lt;/code&gt; to be 8-bit integer. This affects the sizes of all types: a &lt;code&gt;char&lt;/code&gt; is 1 byte, an &lt;code&gt;int&lt;/code&gt; is 1 byte, a &lt;code&gt;long&lt;/code&gt; is 2 bytes, and &lt;code&gt;long long&lt;/code&gt; is 4 bytes. Please note that this option does not conform to the C standards, but it results in smaller code size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2bc85ec675432aace4d6922b50129cffa86b60" translate="yes" xml:space="preserve">
          <source>Assume &lt;var&gt;num&lt;/var&gt; to be the cost for a branch instruction. Higher numbers make the compiler try to generate more branch-free code if possible. If not specified the value is selected depending on the processor type that is being compiled for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a18b03a98d3895d8de33097ebfdc73e386381f27" translate="yes" xml:space="preserve">
          <source>Assume a large TLS segment when generating thread-local code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc9240dada623776592057c6e5b8a92da4c9b4e" translate="yes" xml:space="preserve">
          <source>Assume addresses can be loaded as 16-bit unsigned values. This does not apply to function addresses for which</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb31614e67999bd6734c6361178e2cdabb52e555" translate="yes" xml:space="preserve">
          <source>Assume all objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c507ae5c9607f036356273bef8470c3d07a51113" translate="yes" xml:space="preserve">
          <source>Assume inline assembler is using unified asm syntax. The default is currently off which implies divided syntax. This option has no impact on Thumb2. However, this may change in future releases of GCC. Divided syntax should be considered deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db05f7ded93295035bf91b215647f3c25bb15bd8" translate="yes" xml:space="preserve">
          <source>Assume loading data from flash is slower than fetching instruction. Therefore literal load is minimized for better performance. This option is only supported when compiling for ARMv7 M-profile and off by default. It conflicts with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a16bcb883f109ce15025d3902db389e542f4a1" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d339dd7aa4708a54eb51d13312b9c328ad3f5e5" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume subroutines may not be reachable with the &lt;code&gt;bl&lt;/code&gt; instruction (the compiler generates the much slower &lt;code&gt;seth/add3/jl&lt;/code&gt; instruction sequence).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85e043c6d4b72a1f02e91090d703114e74e4f8f" translate="yes" xml:space="preserve">
          <source>Assume that &lt;code&gt;RJMP&lt;/code&gt; and &lt;code&gt;RCALL&lt;/code&gt; can target the whole program memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33caf9125270759b9ef9dbfd91c8e100e633839c" translate="yes" xml:space="preserve">
          <source>Assume that ICPLBs are enabled at run time. This has an effect on certain anomaly workarounds. For Linux targets, the default is to assume ICPLBs are enabled; for standalone applications the default is off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed72c79186a186d46e787e25dd72b1da5c105ed8" translate="yes" xml:space="preserve">
          <source>Assume that all Objective-C message dispatches (&lt;code&gt;[receiver
message:arg]&lt;/code&gt;) in this translation unit ensure that the receiver is not &lt;code&gt;nil&lt;/code&gt;. This allows for more efficient entry points in the runtime to be used. This option is only available in conjunction with the NeXT runtime and ABI version 0 or 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866258482a2aa9fcb54dee6ab333e2e33fa56a9f" translate="yes" xml:space="preserve">
          <source>Assume that all data in static storage can be accessed by LDS / STS instructions. This option has only an effect on reduced Tiny devices like ATtiny40. See also the &lt;code&gt;absdata&lt;/code&gt;&lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;variable attribute&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef3d0ef83e6f997acb69f32efa34ce5f18bfd5d" translate="yes" xml:space="preserve">
          <source>Assume that doubles have 8-byte alignment. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856f36f37f5770dafc37ec4f5ce9ae4ba43b9ab0" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 32 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89754b304532c00897fca86b5c5a4a2fdb8ea856" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 64 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5971ed7912aa4bcfc190d25dcfc54913916046" translate="yes" xml:space="preserve">
          <source>Assume that floating-point stores and loads are not likely to cause a conflict when placed into the same instruction group. This option is disabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ddd95e70fe2bc8d68e335f2358d8d016cca43e" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 32 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b1eea988cecf507f4140115cf0f3a04a0b6bc0" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 64 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05b8de7cb58ad911a3c660af041154da0f70378" translate="yes" xml:space="preserve">
          <source>Assume that programs cannot safely dereference null pointers, and that no code or data element resides at address zero. This option enables simple constant folding optimizations at all optimization levels. In addition, other optimization passes in GCC use this flag to control global dataflow analyses that eliminate useless checks for null pointers; these assume that a memory access to address zero always results in a trap, so that if a pointer is checked after it has already been dereferenced, it cannot be null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076633874f4c1995b07023b5b94aab209c515c86" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so omit the simulator library (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42823e20bce5001093b19d4ebc090a1f52fb87fe" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so there is no need to include the simulator library (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d530f525409fd98b58f0bb247b2945e9f43679e" translate="yes" xml:space="preserve">
          <source>Assume that the current compilation unit represents the whole program being compiled. All public functions and variables with the exception of &lt;code&gt;main&lt;/code&gt; and those merged by attribute &lt;code&gt;externally_visible&lt;/code&gt; become static functions and in effect are optimized more aggressively by interprocedural optimizers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4cfc093a537b06194880f65fa701bc5be05c19f" translate="yes" xml:space="preserve">
          <source>Assume that the device supports the Read-Modify-Write instructions &lt;code&gt;XCH&lt;/code&gt;, &lt;code&gt;LAC&lt;/code&gt;, &lt;code&gt;LAS&lt;/code&gt; and &lt;code&gt;LAT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766547e453a1be99c1e3faccd183445d895ac153" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This allows data to be referenced by offset from start of text address instead of GOT since PC-relative addressing is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebfb14654d3ce6ee7fc14d89650e1df706d43a0e" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This permits using PC-relative addressing operations to access data known to be in the data segment. For non-VxWorks RTP targets, this option is enabled by default. When disabled on such targets, it will enable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bffa713c2a7cd96b200f3894b2b7a3ab419ebb" translate="yes" xml:space="preserve">
          <source>Assume that the flash memory has a size of &lt;var&gt;num&lt;/var&gt; times 64 KiB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0381000794bbd2c3b341dcaa9dd877537e5d82e9" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor only supports single-precision operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da28820fdda9574eb1ba106e15f86ccdafa0352f" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor supports double-precision operations. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdfa0bfee5480efa2b5e12152c0e653e6cc25473" translate="yes" xml:space="preserve">
          <source>Assume that the handler uses a shadow register set, instead of the main general-purpose registers. An optional argument &lt;code&gt;intstack&lt;/code&gt; is supported to indicate that the shadow register set contains a valid stack pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb05f1c18ebd5a07940293ac38328ed8480807dc" translate="yes" xml:space="preserve">
          <source>Assume that the program is arbitrarily large. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea8e60014028d1c1e2350ea91c13bef18cfe395" translate="yes" xml:space="preserve">
          <source>Assume the incoming stack is aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0c018c4bbeac1a835b6bc4f97980f45c5201f9" translate="yes" xml:space="preserve">
          <source>At level &lt;var&gt;2&lt;/var&gt;, the call in the example above is again diagnosed, but this time because with &lt;var&gt;a&lt;/var&gt; equal to a 32-bit &lt;code&gt;INT_MIN&lt;/code&gt; the first &lt;code&gt;%i&lt;/code&gt; directive will write some of its digits beyond the end of the destination buffer. To make the call safe regardless of the values of the two variables, the size of the destination buffer must be increased to at least 34 bytes. GCC includes the minimum size of the buffer in an informational note following the warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddf0f631ce882bb84e3fb93f118fee7f5a7f5f9" translate="yes" xml:space="preserve">
          <source>At present, GCC only provides support for operations on 32-bit vectors. The vector type associated with 8-bit integer data is usually called &lt;code&gt;v4i8&lt;/code&gt;, the vector type associated with Q7 is usually called &lt;code&gt;v4q7&lt;/code&gt;, the vector type associated with 16-bit integer data is usually called &lt;code&gt;v2i16&lt;/code&gt;, and the vector type associated with Q15 is usually called &lt;code&gt;v2q15&lt;/code&gt;. They can be defined in C as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7562b8145986b9d15bbe747f7453ec31fbcb23e3" translate="yes" xml:space="preserve">
          <source>At present, a declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached can only be &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4135487f1e326a7c07cb63519ab457040bcc6fd" translate="yes" xml:space="preserve">
          <source>At present, the first parameter in a function prototype must have some type specifier that is not an attribute specifier; this resolves an ambiguity in the interpretation of &lt;code&gt;void f(int
(__attribute__((foo)) x))&lt;/code&gt;, but is subject to change. At present, if the parentheses of a function declarator contain only attributes then those attributes are ignored, rather than yielding an error or warning or implying a single parameter of type int, but this is subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba1eab05ac64c3b09192d2f6e850b4049723108" translate="yes" xml:space="preserve">
          <source>At the user level, the extension is visible with a new storage class keyword: &lt;code&gt;__thread&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822a22d01653371bac14c53e07474f5d45325389" translate="yes" xml:space="preserve">
          <source>At this level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ea658ed4a4a90d1fc99e8e69012153c56f031c" translate="yes" xml:space="preserve">
          <source>At this level, in addition to diagnosing all the same constructs as at level 1, a diagnostic is also issued for placement new expressions that construct an object in the last member of structure whose type is an array of a single element and whose size is less than the size of the object being constructed. While the previous example would be diagnosed, the following construct makes use of the flexible member array extension to avoid the warning at level 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bef66661f5c0b03146d1698ca3afb51d9a26fb" translate="yes" xml:space="preserve">
          <source>Atomic built-in functions with memory model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce1364206864236a22c5c48cd625fe86883adb2" translate="yes" xml:space="preserve">
          <source>Atomic types are not permitted for bit-fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41c8daf0a5d584177e036c6b54eb5d698ff31ca" translate="yes" xml:space="preserve">
          <source>Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation. This optimization most benefits processors with lots of registers. Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f5acede0fbb18382444dea8c6c4247f6477d4a" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to direct calls. This is done both within a procedure and interprocedurally as part of indirect inlining (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ecd786dc35f08a1baffd99e6e7d5e25ec53b58" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to speculative direct calls. Based on the analysis of the type inheritance graph, determine for a given call the set of likely targets. If the set is small, preferably of size 1, change the call into a conditional deciding between direct and indirect calls. The speculative calls enable more optimizations, such as inlining. When they seem useless after further optimization, they are converted back into original form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="015c279bf199fbda7e73b9795378a6fd0b0af2c9" translate="yes" xml:space="preserve">
          <source>Attempt to decrease register pressure through register live range shrinkage. This is helpful for fast processors with small or moderate size register sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687510f6384de354811653c1b3a65669791e13da" translate="yes" xml:space="preserve">
          <source>Attempt to determine location views that can be omitted from location view lists. This requires the compiler to have very accurate insn length estimates, which isn&amp;rsquo;t always the case, and it may cause incorrect view lists to be generated silently when using an assembler that does not support location view lists. The GNU assembler will flag any such error as a &lt;code&gt;view number mismatch&lt;/code&gt;. This is only enabled on ports that define a reliable estimation function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac236b78fdffe9d37dcfcf412e47b1651113242" translate="yes" xml:space="preserve">
          <source>Attempt to keep the stack boundary aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c862c84dcea1c34fb363ef2530e074c7fb9ff011" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants (string constants and floating-point constants) across compilation units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e4bd95dd66a112841cf4cd0b134789556e574d" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants and identical variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f797d45d3d320c615fd705a20d8464b1c6f92f0" translate="yes" xml:space="preserve">
          <source>Attempt to minimize stack usage. The compiler attempts to use less stack space, even if that makes the program slower. This option implies setting the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6331b92854e1a7daaaa3b254ef23d3e2705563" translate="yes" xml:space="preserve">
          <source>Attempt to remove redundant extension instructions. This is especially helpful for the x86-64 architecture, which implicitly zero-extends in 64-bit registers after writing to their lower 32-bit half.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8cd75ee0ed545b02a70bb0db32f4bb7b0a164a" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps in the innermost loops to branch-less equivalents. The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops. This is enabled by default if vectorization is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82b9d3f6e114711b5045a6cdf1e499c5d11c4fa" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps into branch-less equivalents. This includes use of conditional moves, min, max, set flags and abs instructions, and some tricks doable by standard arithmetics. The use of conditional execution on chips where it is available is controlled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffd089c28cbc3f051c86ecbaa3c75b1a01df17f" translate="yes" xml:space="preserve">
          <source>Attempt to utilize both instruction sets at once. This effectively doubles the amount of available registers, and on chips with separate execution units for 387 and SSE the execution resources too. Use this option with care, as it is still experimental, because the GCC register allocator does not model separate functional units well, resulting in unstable performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768394a0c657893c518e749955ef528cb8973c45" translate="yes" xml:space="preserve">
          <source>Attribute specifiers may be mixed with type qualifiers appearing inside the &lt;code&gt;[]&lt;/code&gt; of a parameter array declarator, in the C99 construct by which such qualifiers are applied to the pointer to which the array is implicitly converted. Such attribute specifiers apply to the pointer, not to the array, but at present this is not implemented and they are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15f9fabc9141a4fd02709ab1f144944da1df77d" translate="yes" xml:space="preserve">
          <source>Attributes considered include &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;cold&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;hot&lt;/code&gt;, &lt;code&gt;leaf&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;nonnull&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;returns_nonnull&lt;/code&gt;, and &lt;code&gt;returns_twice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e72cecf4ee93be8444bf26683f3314180b4f20f" translate="yes" xml:space="preserve">
          <source>Augment variable location lists with progressive view numbers implied from the line number table. This enables debug information consumers to inspect state at certain points of the program, even if no instructions associated with the corresponding source locations are present at that point. If the assembler lacks support for view numbers in line number tables, this will cause the compiler to emit the line number table, which generally makes them somewhat less compact. The augmented line number tables and location lists are fully backward-compatible, so they can be consumed by debug information consumers that are not aware of these augmentations, but they won&amp;rsquo;t derive any benefit from them either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e028ddf293b9280450ea608fcf02b6afb803a5cf" translate="yes" xml:space="preserve">
          <source>Automatically convert relative source file names to absolute path names in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5484fc94aa2d1ceccb816e9c671bdaec50d90ef7" translate="yes" xml:space="preserve">
          <source>Average number of iterations of a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f04d96d845a90ad835e69c3cba86443a61a89a" translate="yes" xml:space="preserve">
          <source>Avoid or allow generating memory accesses that may not be aligned on a natural object boundary as described in the architecture specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="25ec48c867ed8bb8e6f96a8b43aad4372bc4578a" translate="yes" xml:space="preserve">
          <source>B register</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde782be8b675144b1c3a413d952e5058ca53d38" translate="yes" xml:space="preserve">
          <source>BL</source>
          <target state="translated">BL</target>
        </trans-unit>
        <trans-unit id="7a64a2253d2959f0bf9362ab5d3438b38d98d231" translate="yes" xml:space="preserve">
          <source>BMI instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a694b7ba8977f0d1b0d7c872c114539da755bd3b" translate="yes" xml:space="preserve">
          <source>BMI2 instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdb06081cf1ce665b573d70cc38b7b454902ff9" translate="yes" xml:space="preserve">
          <source>BRIG files (binary representation of HSAIL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089ea9746c8cbdc04b34721f820ba603e6881ff2" translate="yes" xml:space="preserve">
          <source>Base pointer register (r28&amp;ndash;r31)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f76287d800c12dfd6b51ad7e80eed03e92c213" translate="yes" xml:space="preserve">
          <source>Base::Base</source>
          <target state="translated">Base::Base</target>
        </trans-unit>
        <trans-unit id="9039faeb6333b5e373bf646f9ff036f287abc6be" translate="yes" xml:space="preserve">
          <source>Base::operator=</source>
          <target state="translated">Base::operator=</target>
        </trans-unit>
        <trans-unit id="7b3a608459615b9bc19c9d4a294c3d2c0cd4a8a0" translate="yes" xml:space="preserve">
          <source>Basic use of constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5770040433fcf2fed9fca7319c3ac627f6efe91" translate="yes" xml:space="preserve">
          <source>Be aware of this when performing timing tests, for instance the following loop can be completely removed, provided &lt;code&gt;some_expression&lt;/code&gt; can provably not change any global state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4c386efa741fabb074be3b34ff11b267e4e0d7" translate="yes" xml:space="preserve">
          <source>Be aware that headers from outside your project, in particular system headers and headers from any other library you use, may not be expecting to be compiled with visibility other than the default. You may need to explicitly say &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; before including any such headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31e54ef88fe124b0da9af9ee2524cfb6800e5f0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__builtin_longjmp&lt;/code&gt; depends on the function return mechanism to restore the stack context, it cannot be called from the same function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt; to initialize &lt;var&gt;buf&lt;/var&gt;. It can only be called from a function called (directly or indirectly) from the function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94ff60e2bbcd755c2d21600b1c5beacc8d88e0e" translate="yes" xml:space="preserve">
          <source>Because of the interactions between synchronization and exception handling, you can only use &lt;code&gt;@synchronized&lt;/code&gt; when compiling with exceptions enabled, that is with the command line option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc31609fad1f0a543a7bf312e8fc7b4e085e75b6" translate="yes" xml:space="preserve">
          <source>Because of the special nature of the flag output operands, the constraint may not include alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b7dab219d7dd89ab8e51f25903de3035d7b00a" translate="yes" xml:space="preserve">
          <source>Because of the way GCC instruments calls, a call count can be shown after a line with no individual blocks. As you can see, line 33 contains a basic block that was not executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba975e496f98093e5f2ea388a49453725d139a4b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;asm&lt;/code&gt; statement unconditionally transfers control out of the function, control never reaches the end of the function body. The &lt;code&gt;__builtin_unreachable&lt;/code&gt; is in fact unreachable and communicates this fact to the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a314cc1449bd666eda6884b69e668c28f95c1087" translate="yes" xml:space="preserve">
          <source>Before you can use this option, you must first generate profiling information. See &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;Instrumentation Options&lt;/a&gt;, for information about the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5788148d39b8d5244dcdc29f7a93a22a6334768d" translate="yes" xml:space="preserve">
          <source>Besides declarations, the file indicates, in comments, the origin of each declaration (source file and line), whether the declaration was implicit, prototyped or unprototyped (&amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51eccbcd60621399284c614907bba67ce4fca17c" translate="yes" xml:space="preserve">
          <source>Beware that on some ELF systems this attribute is unsuitable for global functions in shared libraries with lazy binding (which is the default). Lazy binding sends the first call via resolving code in the loader, which might assume EAX, EDX and ECX can be clobbered, as per the standard calling conventions. Solaris 8 is affected by this. Systems with the GNU C Library version 2.1 or higher and FreeBSD are believed to be safe since the loaders there save EAX, EDX and ECX. (Lazy binding can be disabled with the linker or the loader if desired, to avoid the problem.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5d61cd9cd2849c270a6af03ebe1306ad2048ca" translate="yes" xml:space="preserve">
          <source>Binary Compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8668d27514898ff49d03fb634b072fd0aba7e0f7" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e9b92cdcd75a69e0946923d3da4f8d0a7fd71d" translate="yes" xml:space="preserve">
          <source>Binary compatibility encompasses several related concepts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ed98dae9970ec4cee447405cb8c658f46ef706" translate="yes" xml:space="preserve">
          <source>Binary constants using the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666bffac0affe44914b807024f7928a6d6ca6941" translate="yes" xml:space="preserve">
          <source>Bind references to global symbols when building a shared object. Warn about any unresolved references (unless overridden by the link editor option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628682c1112ff8669d8fed436fe1daac74760ad6" translate="yes" xml:space="preserve">
          <source>Bit reversal. Return the result of reversing the bits in &lt;var&gt;value&lt;/var&gt;. Bit 15 is swapped with bit 0, bit 14 is swapped with bit 1, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb3706f981c5da19b9c626f35ee7ccc246608e1" translate="yes" xml:space="preserve">
          <source>Bitwise operators act on the representation of the value including both the sign and value bits, where the sign bit is considered immediately above the highest-value value bit. Signed &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b063c3045af1663a8359f63f1ffd9a1d853789c" translate="yes" xml:space="preserve">
          <source>Blackfin family&amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daa776b5dad37eac562c1bddec1cfa040024e9a" translate="yes" xml:space="preserve">
          <source>Borland C++ solved the template instantiation problem by adding the code equivalent of common blocks to their linker; the compiler emits template instances in each translation unit that uses them, and the linker collapses them together. The advantage of this model is that the linker only has to consider the object files themselves; there is no external complexity to worry about. The disadvantage is that compilation time is increased because the template code is being compiled repeatedly. Code written for this model tends to include definitions of all templates in the header file, since they must be seen to be instantiated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200e3a355b82a42f3341fd59904fc5750775b807" translate="yes" xml:space="preserve">
          <source>Borland model</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b22f59b253dcf9c37ea4fe24c6526c4dd1e47c" translate="yes" xml:space="preserve">
          <source>Both global and local variables can be associated with a register. The consequences of performing this association are very different between the two, as explained in the sections below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4416d6a83edb82efd0f4cdffd08c5cd70ca428" translate="yes" xml:space="preserve">
          <source>Bound on number of candidates for induction variables, below which all candidates are considered for each use in induction variable optimizations. If there are more candidates than this, only the most relevant ones are considered to avoid quadratic time complexity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430f77e04bd4e8702495c79a5ebb639d2a4812c8" translate="yes" xml:space="preserve">
          <source>Bound on size of expressions used in the scalar evolutions analyzer. Large expressions slow the analyzer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e549afa5762802ff68ea72f123883ebb295578" translate="yes" xml:space="preserve">
          <source>Bound on the complexity of the expressions in the scalar evolutions analyzer. Complex expressions slow the analyzer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a6a8fa6e2e8a317cd5dd66c604413295e3eb45" translate="yes" xml:space="preserve">
          <source>Bound on the cost of an expression to compute the number of iterations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb1b62c34f820227fd0537f593962386bf2cc61" translate="yes" xml:space="preserve">
          <source>Branch register</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a833b9b5c7959a93636f56f73df394e8d3c434e8" translate="yes" xml:space="preserve">
          <source>Branches are present only with &lt;var&gt;-b&lt;/var&gt; option. Fields of the &lt;var&gt;line&lt;/var&gt; element have following semantics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6495e1aabddcd6526141ce6efe62824f5a7eae3" translate="yes" xml:space="preserve">
          <source>Brief list of all options, without explanations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654ffe48f6054af226250c2aa3867b5fc4c80bcc" translate="yes" xml:space="preserve">
          <source>Bugs we will fix later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5bfe3fd9b6538bfa34acbeb7a505866d87ffce" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core A of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core A, and the macro &lt;code&gt;__BFIN_COREA&lt;/code&gt; is defined. This option can only be used in conjunction with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6320906d93f259f860a69b97e3abeb20581c59d7" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core B of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core B, and the macro &lt;code&gt;__BFIN_COREB&lt;/code&gt; is defined. When this option is used, &lt;code&gt;coreb_main&lt;/code&gt; should be used instead of &lt;code&gt;main&lt;/code&gt;. This option can only be used in conjunction with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e010c48c400b5b030ac052e6ece9a00978fee8f4" translate="yes" xml:space="preserve">
          <source>Build a standalone application for SDRAM. Proper start files and link scripts are used to put the application into SDRAM, and the macro &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; is defined. The loader should initialize SDRAM before loading the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93828509d9639cf155e61322b59daf0187eb136a" translate="yes" xml:space="preserve">
          <source>Build a standalone application for multicore Blackfin processors. This option causes proper start files and link scripts supporting multicore to be used, and defines the macro &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt;. It can only be used with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ef0f891e9c255998243907e244b5b488c698cb" translate="yes" xml:space="preserve">
          <source>Build-in macro that resolves to a decimal number that identifies the architecture and depends on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d34970179e2bcbb0ecc79b090b87f98043678d3" translate="yes" xml:space="preserve">
          <source>Building data dependencies is expensive for very large loops. This parameter limits the number of data references in loops that are considered for data dependence analysis. These large loops are no handled by the optimizations using loop data dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d296efa2545fd43e5ab712c86bbcd120531a39c" translate="yes" xml:space="preserve">
          <source>Built-in Function:  &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt; ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cea55a1a3d5467f8414836cb770a0b2fa5b655" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_add_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f1c3be3667c2fa06bb169c518b6d4d03675142" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_and_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03055a0cd281ae02bbb4f07ca3c585700a7af0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb648ab26ef838877bc3cc4ee57b8ff3c3ec10d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_add&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf737dd7d0b652a623f88bdd6fd64fcd63596e4" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_and&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b1604908ceaddf5e7b79ba9db81f0f1c23485e" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f4365ebf0124211f5cb2705e77bd2bfd90775d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_or&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf646256d882577bfba56a5678e5b9426274e60b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5041b1cf8f3a6577d287aff4388265cba990c15b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75268ab0697eb9af1dc5c6b541d4d1ba8ac4dbf6" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_load_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd00e4ef24b741036ea643da78829d2849f8f8d7" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4657eb44924236cf67282c47ad4d932f5594137" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_or_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b4ecf7d291340ab5ae6cc114b7f02d58e8a705" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52f64419e32735eabc4e3c18aa68dedfb2e4625" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1167cb7b44d7d9f620598ea0aefcbfdf9dc55a1f" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt; (&lt;var&gt;call_exp&lt;/var&gt;, &lt;var&gt;pointer_exp&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f799a7c8358da11b0de0991867b1ca62dd416b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_choose_expr&lt;/strong&gt; (&lt;var&gt;const_exp&lt;/var&gt;, &lt;var&gt;exp1&lt;/var&gt;, &lt;var&gt;exp2&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e363a3b892d8f6c1c1fdfdd845f80862a3606b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_complex&lt;/strong&gt; (&lt;var&gt;real&lt;/var&gt;, &lt;var&gt;imag&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eec0865162048e6dccab85fb3d740aa5f07fc05" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; val, &lt;var&gt;type&lt;/var&gt; failval)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5c7616bd765dd4fc8d843ce99908ad16336f51" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_tgmath&lt;/strong&gt; (&lt;var&gt;functions&lt;/var&gt;, &lt;var&gt;arguments&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3600affbf40f82a1f599528ce0f72402f629874" translate="yes" xml:space="preserve">
          <source>Built-in Function: Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt; (void * x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ca6e3021fea0b720388d29d28e89de6177efaa" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8fbba0296cd046f79b2f8fac454e9f96b680c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3f5c8f497e0e257636ccbaf6459ad1ad8e6479" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d12b2517571e9887a8920d94ebf233b53b0d3e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f59dbda6a0f6f12e013b7d8146bb95b52fddbf" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf12c95c5e2671a78a61f716ad8c91e6ab3dca2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e065d1bdd11d40eb46afaa76c7e3c275e0e7c656" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1ad27f368302d827ffdedc2f161e1a34576916" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4a5dc00bc657abe7ad80938a7d60c8e79b5015" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b60d24ae373b1240786dec7b198434f539e010" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9f5f175d78dc2baeeae0348c4b4da7826acad2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8897a35cb1a3842c5a7b59ff4525f61eb36974a" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd15fd91da1a9d9a87216c52e010f17bc3d22e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615e03fdb9ea794729a2a1d7c358b1e301921c3b" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f520d1247e2979f87ba6e5662e70795dbd438963" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b1fe88fa6197e2c0740249ab472fde949dc447" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; *desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0cae369ba572d6fc730f1208ec5ebfd8c31b5c9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ff9b335ec817f16bd5f09bc44d64b4868726b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aee6114b477fd331dab8c2aef844fb97f49851" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt; (void *ptr, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b8a4ae04512641547c12a9c73d39675cb460a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af59554b89a8bf55a3dc48af48346f20f06e852a" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be98828c48e0d16aa6b6e2421edf84970dc86a6f" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt; (&lt;var&gt;type-or-expression&lt;/var&gt;, &lt;var&gt;attribute&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e50b8a64da2b188793a4579bb5cae5cac82268" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9d3aabacf2156e5d393cd93749ff7c8037d66e" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd735437fc9239fd342fe45001594bf9731cdde" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ee4265411f06ce5b584d4448bc72ef70be2921" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69472084a70d9c551110645ab2de32722f859a56" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d167da624174d67a584837afb39ffafce3529192" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0751d990e1a6176428723a69b8b9d35eb80fd837" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="956b1e662b4c40d70010047e2d0274713e3963f3" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b14c01667b17099ca43e693ecf1b190d3e0c9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b2f488874750806435b3aaff4f191420925191" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49724eb9cf1b5f433d9a763058afdd03539a15c8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb17f1956b296109f50ac2e4c7c8a50ec613924" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca0d6297a605dc41e2b859a3577a44be6641a95" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3ccbf74e07a994d7fa1a99c72273b8a5afff58" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b02b9649ef1800e43226f7e7109d8bbef8357dc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567411aa095944ed062923c573393ad7b9494fcc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d580478c24cd4b2a59ce2c1f75d3bbd1e01675" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df720b89a79aa504ee2325733fecf62f5d154df" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127b7aa724932fc0c15543b161cf5ca336f40c65" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0e5de085f1421cd056a7b7c2d1ac4593a791e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f0099aa9a654a142bfe318e5e28643d8ddc6f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5542c5653c759c2ffcd0eb56e8e4fce2653611" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8967205f7b6c405e734e918e4030fc20dcc7a6e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3ebe01d55449070f5b00bc45933b6ab0472f70" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt; ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0721ec3a797458f28da3b2711e9fc2d2af1823e2" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt; ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1712d1ad359c0cac12cd7a3537116bd9e795fc" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffafe4d74af74fb9ca60ea9821704b751632b93c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2864a0d09a57cc7f91ca4ff8697942e0585349f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51bc6d3e017f472618e17d8b483f22c00009407c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40603712a54f648b2195d490214834e3f8465f8" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt; (double, int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37264a6694867df8b96fcd2a07266108a13c8c2e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605b7b7bd5e72cf972739ddb673591e051dadcd8" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84c6b7adfcd7dc51b670ecde42ed816377e7198" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6f3577a561b5595beef7b2c40d9183bbecdc53" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17547d96b5dcfda1585e7b927ed2efd4413b34e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt; (float, int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af70608a64ebe69db59d9a08864316c44173d0e" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt; ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48642fe0ecb713fe1c2c62aceb4756a077c1f773" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt; (void *&lt;var&gt;val&lt;/var&gt;, int &lt;var&gt;alignval&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03ad02fdd87a3d6c105f1b3776333e8f10a10d5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c45a4bbd1df9874258bef23963c99d6fdf07ecc" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343cfc12f31c0a60920faf8b433b92fcf3f860cf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d84191dd5a2bd1c0e1ed8ebf20f4a6e76b3cbe6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt; (int x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c48a9f003c2411e7dd88432db5f58cb7b19302" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt; (long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def7076c73776e0b25f88bdee6855cecbffd2e2a" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt; (long long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a0ab60ba16fc861473b90def46ecb8b60b639d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt; (unsigned int x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af52cee1c123c25328e32f99b41a08f4a5682992" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt; (unsigned long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a7c4157a06fcdbaf2b34c2852b5f5191d70ac6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47a14a24701e5c3353b9003a2bdd96c5e473a94" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt; (&lt;var&gt;exp&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef14ea6a7a4d27be1b6d59915aed4bf7b4b1a9b6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f1d6da484baf586ba4417cd2ac456d3490d574" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5e90517840f43dd21b0d12105cc6839b7ba276" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be485791899d037b9a8263a3418dab2b9ad4f3b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f22b95a5cdd587669aed9814a5480962c20cb7d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt; (unsigned int x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e1e06b0d6fb4ae3123c409271d97e77380c487c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt; (unsigned long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a1238733f66fff846c6029aaa32b6b42066621" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0937729bdd117da89bde58b2fd5056203d7a7e12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt; (int x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c820dda274694fd7c04aa653b01ff9cf75ba5bae" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt; (long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0419174c77d9db8a178954419d9e7c6e3dc80183" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt; (long long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32b1e79ff752f0a0ce225c7feb84f484de727e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt; (int, int, int, int, int, ...)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67b5cb4d37226ea2da9240fb2bf4c5fbfb5a8e1" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt; (int x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e97eb7d6696130c1b12f3a195f09c5fe85037ac" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt; (int x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1c7c86aea003afe938bab829e378b0663f340f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt; (...)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6364cb6c54b3f23f200e94c257634d572b72a2b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt; (int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75355c68c6a70985d49c27c009882adbab77b765" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt; (int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea0be9b20abc1e8c8611e711574fc9d068aecdf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt; (unsigned int x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2674768572b8928e01401026a8478558c974780" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt; (unsigned long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9664e69ce71d737f813b0b4d98ebf2574871d2" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt; (unsigned long long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ff1595ae9b712ea80b334ac2a6cdea20f82b68" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt; (unsigned int x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a51eea95b9b1a09db27133b891662e30ce0448" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt; (unsigned long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd076b3e2da0133a80ede36a8b399d240589b8d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt; (unsigned long long)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ba97f2fd93c345aa1ebd2ae07061c6b3b1e18d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc349ef1269f6645b577d9e0423a3da86a3c0c64" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6283c7dae9e9bf7ecb0b6d081f4b083bb18c46" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061b61de0614f91eda3a2e79ebd09fdb750a9e0f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ac1419f6405c9d67980323a8c6db2b17519fa4" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba08ce759241ad5b54043023fc31cb69ea10ef12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5f4e2e49e883c140bdde81a146113e7826c6e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt; (void*)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00769436b2cde422b3b7011657e79f1018006b03" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt; (void*)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b626c4c35bdf8b837ccbdac21dccf04d3259501c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt; (void*, int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0e1df41de31ed2e428c07e756094f54001f4e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt; (void*, int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a37cc4aa4480ad9e51ba1642145972ee824d1c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b156bfa334cc82648dee3d2f253e789fdf0de655" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1b9cf1258d4a3f36ac2384619d6f6feef8480b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt;, &lt;var&gt;type2&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0fd3c8fa261ef1e9881453b5ce3996db8b353f" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt; (long &lt;var&gt;exp&lt;/var&gt;, long &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f748429dddf7f60efd21f75bc9d96a2f04db2076" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971be5dbeae5d7765bfe0bd927cc0410ae39a447" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f890816fdc58a1aea60b82df935d886c00b2bf15" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4324db719b621df0af588063a194c3f4173810b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05afbb2ee64f8e1c3ac88b778a44096576c7f966" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt; (const char *str)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b868b2b6ef31f0d2806eabe890d6c604ddddf56" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt; (long double, int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d356427c6ff17cd4bc34021c1341be077bc0c8a1" translate="yes" xml:space="preserve">
          <source>Built-in Function: short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt; (short int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f029118b8798750fa6c678264c3c7762285f4d28" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7554947332f78bb70c0521290e9a6608845a4d1" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="989a30653b65ffed34f5682558a8970a9aa0e644" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt; ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d331467c48fe2922c4d1d28e785562b4d984a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt; (uint16_t x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1726e6c424d7f99d5018566837c4927b7db5948" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt; (uint32_t x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5352b73e73ceeb994fa2584683f756d8f9d112" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt; (uint64_t x)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509ae15fd2e87932ac8b26cb6b1d223cd12aa699" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930e355c3b80a5a9fc58fc1acd0a189dee429782" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe43f813f2eb2f9db208678d8efd3062ab0ae06f" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd053e0e0e0c481f2fd8761cce8fb20e0497500" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt; (void (*&lt;var&gt;function&lt;/var&gt;)(), void *&lt;var&gt;arguments&lt;/var&gt;, size_t &lt;var&gt;size&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fa5cc333ec1b465b8bc1469ac13a9805646394" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt; ()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3f4e7eb7b92dd81ca2567a194a5a901d0bfe5f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt; (const void *&lt;var&gt;exp&lt;/var&gt;, size_t &lt;var&gt;align&lt;/var&gt;, ...)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fd532a50930c3b77686313f0365b067e8b2061" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5db4b2531bc00d2c26aa89ffd98b83b1ec2ffd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae549b690a18db077d51fc88ddfe8895c32f392" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570bc19f96ffb431d4ed4e07d4a76a73d90b1bab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a17d8a48dd1cfb01e5eca9e0fefb74ccd1f3e19" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f386f8fa1a3ce61aaddb01d8f87e99be90ce722e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;*__builtin_alloca&lt;/strong&gt; (size_t size)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c063cc66ca8c65c97e5563c39a35ab67426b4796" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;*__builtin_alloca_with_align&lt;/strong&gt; (size_t size, size_t alignment)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9a2cc82b83f94f4d0c65d76c51d114da95b31b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;*__builtin_alloca_with_align_and_max&lt;/strong&gt; (size_t size, size_t alignment, size_t max_size)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9362d0fd68d2bba012773ea9bf47a7cf19548a71" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt; (bool *ptr, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af38ddba7b2c30fcdbcb19cb7f7f28b84121aca6" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81cf5ada4648091ed72e1aa65aae72b350e8c4d3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a339c94ea5a60096d289e4b1ba778af9caadce5c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt; (int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1bcb5179154226f5bada80a127d69eae1eb5cec" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a97d93631348e25f6183eb76cee2e101979f75e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d340009d0a0b7de28ca2e66c34cf11a1340bae0" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt; (int memorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de406e12d51eaad788fc9e9d5903dcbf3bcb9513" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt; (void *&lt;var&gt;begin&lt;/var&gt;, void *&lt;var&gt;end&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbdc79fbdaaac306ca33e716a38d2039cdbc731c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41dfbf690d1f1831d27b0be428eb428d5c08e800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938747d2d81b773df4eb146dc47c371852f38281" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dacbc2eeaf144c8f5f67ca6a60249f78488adc0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df39d3186b8d524cef79461c8ccbf9360ab5670" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;, unsigned int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b3b375828d6b123d4a73fe0837a99b6630234e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e99485526d0fd614866e77c7a635130751c7b1d" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc0e84fe67d81076fbea0352fb8f5781564ffca" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ed65244aa708bd181a626a0afcf9435d2147f5" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f420eb345d10d7bfd574d6a3346de63183adc893" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42e0753d14b76f3a20b1e491681f5295a8dc135" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cc7129f46ffcafd69b91e8eda56456c2ecced9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt; (unsigned int &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627e1715f16535c4e6e435528706da2168cf77df" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29e71f1f17adad688b68068d1063df98d3d4aee" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae429fc5f0112c7890dcdff589f10f47deea16dd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cd845b205509711bbf6256051511ce8b3607ab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;, int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff14e5c46a00a91c0c0603fe5f170bde38d705e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe5501c6b5d93e7b033487f6a848dd334597db03" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt; (int *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841f0b2bab051a37cafce912e8b554544bed4ffb" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8bab86f6689c778da28b14954604543548fb9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7672c01bcce0ae5cb385b443579f1f0e814383" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c2cb53755ea177e9b7bcabfb291e59bf8c8d8b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_en&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f23c91db2e471b60a85c1d974b337410d93c4ae" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt; (uint64_t *, uint64_t)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2321505821d1604108a7105b3b6858f231f0c9ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt; (const void *&lt;var&gt;addr&lt;/var&gt;, ...)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe3fc0ac7968932105d1c1d3ab50d7b85cfe594b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt; (void *&lt;var&gt;result&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a8dfdf0491f60d9f3285d8de87cb556335dd7c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baafeee4f82f6b2b3615bbf58d2dd0b69de47091" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ac58e52ec8cfeb1ed0ce17f884d6ca28de4bb2" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f5dc479a3c9ca583cab1eca4c28279f3d7220a" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt; (int, int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e28f28fffe61c4b4679e59b89330fa5d0042874" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt; (int, int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c536195bce3a86157c9c49ee77c45d3577dcc4" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt; (int, int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5621acbcbc1163f811efb159aa50ed209c490ad9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt; (int, int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="227762640b3aca70bd083850fd27548557a69595" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eefd425b2ddf508a48e8a2189b6454058653fea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662dad4c2fd795f4f1dddab9d3e0737c1c8a5708" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt; (int reg, int val)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276391cb278528b1f872b1280affb29edbd7927c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="700036ac6c5189b95316dbc5c4ae3b0309325df1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48b2b82b14ae8b91fdb2fe28e06b8ea0b1cb522" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4595d30c690a3b8c89c7807c08a9959f30d56800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt; (float)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5948033a96e4003655c71953e27a3f9741045b3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89dbf6d50890784687748f168df8d729aebf79c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b218b72a2c6b938556ce1a8c8a3cca255a13b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt; (void *&lt;var&gt;ptr&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db4725d0eae1acd204db5ae18744d85101db3ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt; (unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9baaf9b0798ed586e63831552a408b61b1a992c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d228c7f65857695f955c2630b92714965d36378f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94689ecdbd4d60ff7b0fd602ce7245bc7b6beb10" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1c671de0baf7c15aaf53f248312afd293d5b33" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt; (int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5904be3f2c9a60beac8be0103847c267a6f80e80" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836cf5a0e71cae3a60324503179866ad686508a7" translate="yes" xml:space="preserve">
          <source>Built-in functions for limited buffer overflow checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b5ba0eb7000fc998fff5b209a2516ba2e54a3f" translate="yes" xml:space="preserve">
          <source>Built-in functions specific to particular targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253258e2e82600175022e888019e1f8e9ab9c3a1" translate="yes" xml:space="preserve">
          <source>Built-in functions to perform arithmetics and arithmetic overflow checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4708bb7371d5b0f788e5028a015745453830a6ee" translate="yes" xml:space="preserve">
          <source>Built-in macros, macros defined on the command line, and macros defined in include files are not warned about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606b68375f39bb1e243e870d45cdf01eab0caad3" translate="yes" xml:space="preserve">
          <source>But if you need to debug a problem with method signatures and need to know how they are implemented (i.e., the &amp;ldquo;ABI&amp;rdquo;), read on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ba03b4395ba58ba0713d75a0907aa6ed34a2f6" translate="yes" xml:space="preserve">
          <source>But in the definition of &lt;code&gt;foo&lt;/code&gt;, the file-scope type is used because that is available to be inherited. Thus, the definition and the prototype do not match, and you get an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f71fd5d9e178736a8b25951cca5312e798d273" translate="yes" xml:space="preserve">
          <source>But in this example, the &lt;code&gt;std::move&lt;/code&gt; call prevents copy elision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf56c043a9173e054f17c75c7e06c6a5d352b771" translate="yes" xml:space="preserve">
          <source>But this definition computes either &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; or &lt;var&gt;b&lt;/var&gt; twice, with bad results if the operand has side effects. In GNU C, if you know the type of the operands (here taken as &lt;code&gt;int&lt;/code&gt;), you can avoid this problem by defining the macro as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089c24745336688f5099a4bd50557aedc8fc6fff" translate="yes" xml:space="preserve">
          <source>By contrast, PCC on most target machines returns structures and unions of any size by copying the data into an area of static storage, and then returning the address of that storage as if it were a pointer value. The caller must copy the data from that memory area to the place where the value is wanted. GCC does not use this method because it is slower and nonreentrant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8864b0dc6da1e44443610d33567bb75bb81d17" translate="yes" xml:space="preserve">
          <source>By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function&amp;rsquo;s code into the code for its callers. This makes execution faster by eliminating the function-call overhead; in addition, if any of the actual argument values are constant, their known values may permit simplifications at compile time so that not all of the inline function&amp;rsquo;s code needs to be included. The effect on code size is less predictable; object code may be larger or smaller with function inlining, depending on the particular case. You can also direct GCC to try to integrate all &amp;ldquo;simple enough&amp;rdquo; functions into their callers with the option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571c61d917cc3bc4c5e2835a5dd40c5c41bd768f" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the GR5 variant of the Visium architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff1bd96a4bdcc76b002de9ee97861c9f804a0dc" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the V7 variant of the SPARC architecture. With</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5c102e65c6f170a209b204a4dbc9b094f06846" translate="yes" xml:space="preserve">
          <source>By default GCC inlines string operations only when the destination is known to be aligned to least a 4-byte boundary. This enables more inlining and increases code size, but may improve performance of code that depends on fast &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, and &lt;code&gt;memset&lt;/code&gt; for short lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828f5d805ef0fc5866d738b0ffbff970c7d7f41f" translate="yes" xml:space="preserve">
          <source>By default assume that all calls are far away so that a longer and more expensive calling sequence is required. This is required for calls farther than 32 megabytes (33,554,432 bytes) from the current location. A short call is generated if the compiler knows the call cannot be that far away. This setting can be overridden by the &lt;code&gt;shortcall&lt;/code&gt; function attribute, or by &lt;code&gt;#pragma
longcall(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d64d02eb42b84df503cac7606206757e75fdfc" translate="yes" xml:space="preserve">
          <source>By default instance variables in Objective-C can be accessed as if they were local variables from within the methods of the class they&amp;rsquo;re declared in. This can lead to shadowing between instance variables and other variables declared either locally inside a class method or globally with the same name. Specifying the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812f601802f8d41b61d44c3f0bd220d17f966e00" translate="yes" xml:space="preserve">
          <source>By default it is treated as &lt;code&gt;signed int&lt;/code&gt; but this may be changed by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ef9328c623bad5538b4f26249da5459c5c08d3" translate="yes" xml:space="preserve">
          <source>By default or when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b76575429db7ab5c66debc083d774f7e949e1c" translate="yes" xml:space="preserve">
          <source>By default this feature is not enabled. The default can be restored via the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7bad4b8f0ace00e1f8f2cdea4bdacee4c90882" translate="yes" xml:space="preserve">
          <source>By default when the C++ frontend prints diagnostics showing mismatching template types, common parts of the types are printed as &amp;ldquo;[...]&amp;rdquo; to simplify the error message. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c0fdbe4acada00b33542c8af5765b2142c6787" translate="yes" xml:space="preserve">
          <source>By default, GCC also provides some additional extensions to the C++ language that on rare occasions conflict with the C++ standard. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;. Use of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b721c8be1fed47cd95a2b324cc0ec1f3f3fd2db" translate="yes" xml:space="preserve">
          <source>By default, GCC emits an error message if the feedback profiles do not match the source code. This error can be turned into a warning by using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68205120aabfb538f7bc7f4202c9b447a1cf9091" translate="yes" xml:space="preserve">
          <source>By default, GCC generates a branch hint instruction to avoid pipeline stalls for always-taken or probably-taken branches. A hint is not generated closer than 8 instructions away from its branch. There is little reason to disable them, except for debugging purposes, or to make an object a little bit smaller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0fae0fc27ffb4e00a4f068905f564a20595bd8" translate="yes" xml:space="preserve">
          <source>By default, GCC generates code assuming that addresses are never larger than 18 bits. With</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc14d5fdff5ebfd96cb93f60f01d2cd55db824a" translate="yes" xml:space="preserve">
          <source>By default, GCC ignores trigraphs, but in standard-conforming modes it converts them. See the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2b09a4a457e7ae05463c18b24ed251756826ce" translate="yes" xml:space="preserve">
          <source>By default, GCC inserts NOPs to increase dual issue when it expects it to increase performance. &lt;var&gt;n&lt;/var&gt; can be a value from 0 to 10. A smaller &lt;var&gt;n&lt;/var&gt; inserts fewer NOPs. 10 is the default, 0 is the same as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6ff38e6ed640debf4ee9a5067811f24a626ac7" translate="yes" xml:space="preserve">
          <source>By default, GCC limits the size of functions that can be inlined. This flag allows coarse control of this limit. &lt;var&gt;n&lt;/var&gt; is the size of functions that can be inlined in number of pseudo instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf107b2c0510e1f5a934dedd69183ab9f3da713" translate="yes" xml:space="preserve">
          <source>By default, GCC links against startup code that assumes the SPU-style main function interface (which has an unconventional parameter list). With</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2fda2cbe2c03ae974fe1e7172dd8c82c7ece3a" translate="yes" xml:space="preserve">
          <source>By default, GCC provides some extensions to the C language that, on rare occasions conflict with the C standard. See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Extensions to the C Language Family&lt;/a&gt;. Some features that are part of the C99 standard are accepted as extensions in C90 mode, and some features that are part of the C11 standard are accepted as extensions in C90 and C99 modes. Use of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7c9e5570dcde91269bdc30909a64efa434ef4f" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes text indicating the command-line option that directly controls the diagnostic (if such an option is known to the diagnostic machinery). Specifying the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4309cf8cee66811505f90edea42d61f9045107" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes the original source line and a caret &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7763701cba03a5661d0405bf0959714c47202a4e" translate="yes" xml:space="preserve">
          <source>By default, only &amp;ldquo;high-level&amp;rdquo; messages are emitted. This option enables additional, more detailed, messages, which are likely to only be of interest to GCC developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d31796fedde16b57588ddd5284b3abd8463c996" translate="yes" xml:space="preserve">
          <source>By default, the assembler file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10caadf2568f37c4e4608d0c62719e2855118ce6" translate="yes" xml:space="preserve">
          <source>By default, the dump will contain messages about successful optimizations (equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9a2b16ff551e2f7ff627c2fd6228056bed25a8" translate="yes" xml:space="preserve">
          <source>By default, the keyword &lt;code&gt;__vector&lt;/code&gt; is added. The macro &lt;code&gt;vector&lt;/code&gt; is defined in &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; and can be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b102924aa2fe89599576741a2bd8c5becb0889f6" translate="yes" xml:space="preserve">
          <source>By default, the object file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e689c10c02894b0d8e0dcec9a7f6bd5f47a0486" translate="yes" xml:space="preserve">
          <source>By default, when printing source code (via</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f618b8855eb83706e0dd5ba4b20f8784c6acdce1" translate="yes" xml:space="preserve">
          <source>Byte swap. Return the result of swapping the upper and lower bytes of &lt;var&gt;value&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="8c7f20acc9bb2d58739f2e1f94cb9494f549d093" translate="yes" xml:space="preserve">
          <source>C Language Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2345e5746cc2edc7fabec343cb3f91233c3786" translate="yes" xml:space="preserve">
          <source>C and Objective-C-only Warning Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a16bcf14a78c44b6bfc6c36207ff504cb459f2ef" translate="yes" xml:space="preserve">
          <source>C code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43bd1aa29c2f227114eb9168f3aeb20a853ce287" translate="yes" xml:space="preserve">
          <source>C contains many standard functions that return a value that most programs choose to ignore. One obvious example is &lt;code&gt;printf&lt;/code&gt;. Warning about this practice only leads the defensive programmer to clutter programs with dozens of casts to &lt;code&gt;void&lt;/code&gt;. Such casts are required so frequently that they become visual noise. Writing those casts becomes so automatic that they no longer convey useful information about the intentions of the programmer. For functions where the return value should never be ignored, use the &lt;code&gt;warn_unused_result&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc85e5ef0494952e2e594d8f572f0cb62561829" translate="yes" xml:space="preserve">
          <source>C has the concept of volatile objects. These are normally accessed by pointers and used for accessing hardware or inter-thread communication. The standard encourages compilers to refrain from optimizations concerning accesses to volatile objects, but leaves it implementation defined as to what constitutes a volatile access. The minimum requirement is that at a sequence point all previous accesses to volatile objects have stabilized and no subsequent accesses have occurred. Thus an implementation is free to reorder and combine volatile accesses that occur between sequence points, but cannot do so for accesses across a sequence point. The use of volatile does not allow you to violate the restriction on updating objects multiple times between two sequence points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49f69bf7866959fd041d254d44ecd95bab5ba98" translate="yes" xml:space="preserve">
          <source>C register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2327d3d6eb8a5f7ce91755caf9e65d7a2e7dc1de" translate="yes" xml:space="preserve">
          <source>C source code that must be preprocessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f8a2e0d02a243e776c6bb9750832b606cb81e5" translate="yes" xml:space="preserve">
          <source>C source code that should not be preprocessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11548c240585bf5af759bc0a6b301b88b353e27e" translate="yes" xml:space="preserve">
          <source>C++ Language Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f68a93b1bb79e369d8676d696444f1cbbc7bb2" translate="yes" xml:space="preserve">
          <source>C++ comments are recognized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f61cc8037210ca9970d93d649a42c41aee100de" translate="yes" xml:space="preserve">
          <source>C++ concepts provide much-improved support for generic programming. In particular, they allow the specification of constraints on template arguments. The constraints are used to extend the usual overloading and partial specialization capabilities of the language, allowing generic data structures and algorithms to be &amp;ldquo;refined&amp;rdquo; based on their properties rather than their type names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cd14ec337b46f3c719029c11a0be19021fb2b8" translate="yes" xml:space="preserve">
          <source>C++ header file to be turned into a precompiled header or Ada spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7bc99762b7f83b6b621c845d769390544ce75a0" translate="yes" xml:space="preserve">
          <source>C++ is a complex language and an evolving one, and its standard definition (the ISO C++ standard) was only recently completed. As a result, your C++ compiler may occasionally surprise you, even when its behavior is correct. This section discusses some areas that frequently give rise to questions of this sort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84a747565fa51df782491a580d39e6a3f403239" translate="yes" xml:space="preserve">
          <source>C++ requires information about types to be written out in order to implement &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda8008d202b2d7ff2b02b361c7ea913221a6d44" translate="yes" xml:space="preserve">
          <source>C++ source code that must be preprocessed. Note that in &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fa7c5a2c337828c11bc2c4ade3aae26a30fe89" translate="yes" xml:space="preserve">
          <source>C++ source code that should not be preprocessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9e861072d065eff5c8caf3bd72ac42f37e3e61" translate="yes" xml:space="preserve">
          <source>C++ source files conventionally use one of the suffixes &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d70d761fb7676ae22ebe197ff2d2dd053c553d" translate="yes" xml:space="preserve">
          <source>C++ templates were the first language feature to require more intelligence from the environment than was traditionally found on a UNIX system. Somehow the compiler and linker have to make sure that each template instance occurs exactly once in the executable if it is needed, and not at all otherwise. There are two basic approaches to this problem, which are referred to as the Borland model and the Cfront model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16bd188cbd64c4bf1a17218266102bf9d269e075" translate="yes" xml:space="preserve">
          <source>C++ virtual functions are implemented in most compilers using a lookup table, known as a vtable. The vtable contains pointers to the virtual functions provided by a class, and each object of the class contains a pointer to its vtable (or vtables, in some multiple-inheritance situations). If the class declares any non-inline, non-pure virtual functions, the first one is chosen as the &amp;ldquo;key method&amp;rdquo; for the class, and the vtable is only emitted in the translation unit where the key method is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17265012fdaf7b797d7862b29ff392331cd3a4a0" translate="yes" xml:space="preserve">
          <source>C++17 provides a standard way to suppress the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78d571177e03968d05d81e87283c743f9bd11eb" translate="yes" xml:space="preserve">
          <source>C, C++, Objective-C or Objective-C++ header file to be turned into a precompiled header (default), or C, C++ header file to be turned into an Ada spec (via the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6297518e9deb3ffb36cfb4da17e5731d4f43ddd3" translate="yes" xml:space="preserve">
          <source>C-EUCJP</source>
          <target state="translated">C-EUCJP</target>
        </trans-unit>
        <trans-unit id="fea2102020df627a3fcd18f01c6b90d1d1ebc0a5" translate="yes" xml:space="preserve">
          <source>C-JIS</source>
          <target state="translated">C-JIS</target>
        </trans-unit>
        <trans-unit id="8aed662488c94d21a572d72dd344a0c46e870bc0" translate="yes" xml:space="preserve">
          <source>C-SJIS</source>
          <target state="translated">C-SJIS</target>
        </trans-unit>
        <trans-unit id="e1c33b8c4686460cd515031a9d28c68a3cfcef87" translate="yes" xml:space="preserve">
          <source>C-SKY&amp;mdash;</source>
          <target state="translated">C-SKY&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e66b4865aad9938d99c99c6f4ab23939ca58e09e" translate="yes" xml:space="preserve">
          <source>C99 Annex F is followed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0817809900308ce7f22b686082215869550cf931" translate="yes" xml:space="preserve">
          <source>C99 restricted pointers and references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792d9ffa119c05fda74148cc441c8be905361027" translate="yes" xml:space="preserve">
          <source>CALL_INSN</source>
          <target state="translated">CALL_INSN</target>
        </trans-unit>
        <trans-unit id="a4c1d0441ce79e81e5b485ea5fcda7d1c56b743e" translate="yes" xml:space="preserve">
          <source>CB</source>
          <target state="translated">CB</target>
        </trans-unit>
        <trans-unit id="7c9c078a9c0f1169f25be27f38940093778bb37c" translate="yes" xml:space="preserve">
          <source>CET Function: ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt; (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ab10eefead0e21345d5d4e4f22d758ced4568b" translate="yes" xml:space="preserve">
          <source>CET Function: void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt; (unsigned int)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feca3790fce7c96d6df26540c7b4128215a81089" translate="yes" xml:space="preserve">
          <source>CMOV instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2711a4d5237b1b481ba6a122e49ae7f80826ead" translate="yes" xml:space="preserve">
          <source>CPU does not have a timebase (eg, 601 and 403gx).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca704ae8911deda5afe0231823961924eb739a85" translate="yes" xml:space="preserve">
          <source>CPU has a CELL broadband engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3f4709b09760afc34be4c56dc4c6225a92c342" translate="yes" xml:space="preserve">
          <source>CPU has a SIMD/Vector Unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7513f4d098c1065cad2f73416dc6c7b6d28bb7ca" translate="yes" xml:space="preserve">
          <source>CPU has a SPE double precision floating point unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249044ceb00915a3621d91cc9c9342822f5d3a2e" translate="yes" xml:space="preserve">
          <source>CPU has a SPE single precision floating point unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc457a7d1f6c70e1a12a91ad1a70b454e13c88b" translate="yes" xml:space="preserve">
          <source>CPU has a decimal floating point unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daecf052e0ef6eddacd32a707988a46a48b10a26" translate="yes" xml:space="preserve">
          <source>CPU has a floating point unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e350ba25d5b50e7eecaa8cd017e06461b70e0e96" translate="yes" xml:space="preserve">
          <source>CPU has a memory management unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25b3ec38c741ef05546cfa00487c01e86a288da" translate="yes" xml:space="preserve">
          <source>CPU has a signal processing extension unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cdbd18b45d3ceafe188679188c10b0e63fc06b" translate="yes" xml:space="preserve">
          <source>CPU has hardware transaction memory instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817e69cd99aa2fae8e8cb1ea4ccb1e7cade39e36" translate="yes" xml:space="preserve">
          <source>CPU has unified I/D cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85030d258895560b198880492e35a8dc7104678" translate="yes" xml:space="preserve">
          <source>CPU support simultaneous multi-threading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa8be29b90ade4bb4d6c9abca15ef4efb5cea12" translate="yes" xml:space="preserve">
          <source>CPU supports 128-bit IEEE binary floating point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ec10bc634bb744e9ff5bc9b6ccebe2f8a4c1fd" translate="yes" xml:space="preserve">
          <source>CPU supports 32-bit mode execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c550c34cceac587d8bfa3d110ce84630536005e1" translate="yes" xml:space="preserve">
          <source>CPU supports 64-bit mode execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969f1a1bfc594794e1d088866f33884cafe4c0a3" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.00 (eg, POWER4)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f021a7b007d311f22fec3723c62516e8f3a0319b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.02 (eg, POWER5)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee64c969eb8481f0eae6c612175233cd07361227" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.03 (eg, POWER5+)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13964fdc29b60cfc0a706e4cb0569a01c55f1208" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba1460155478447375ae1fb486a30ad51582aec" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6) extended opcodes mffgpr and mftgpr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990b205fa1433a7d0dc63ad9070ee91af0800dd1" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.06 (eg, POWER7)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9081f5b37e7737655ad795c102d5fe7087b65d" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.07 (eg, POWER8)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf25ddc902c83eba265e85451df12c824bf2a7b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 3.0 (eg, POWER9)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055a8304e60c6c298c280b0809896894a417c35e" translate="yes" xml:space="preserve">
          <source>CPU supports a little-endian mode that uses address swizzling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255ddfc220c178db8c2fdf2c3d887268be52afce" translate="yes" xml:space="preserve">
          <source>CPU supports event base branching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a546c031cbdf8f942b2e95c5d11fb1b52e9cc57" translate="yes" xml:space="preserve">
          <source>CPU supports hardware transaction memory but does not support the &lt;code&gt;tsuspend.&lt;/code&gt; instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cc31dee3a3972d6c8549b9b9d63935ff74bd07" translate="yes" xml:space="preserve">
          <source>CPU supports icache snooping capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a7a3dc0108d58ef63d3f6ab2c6e0a72b7c8029" translate="yes" xml:space="preserve">
          <source>CPU supports the &lt;code&gt;darn&lt;/code&gt; (deliver a random number) instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d7a3e63ab0326c7992c2322e10e155757df7b2" translate="yes" xml:space="preserve">
          <source>CPU supports the Embedded ISA category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c159e0e90690ac6c2f371b7dff8ce2db12767971" translate="yes" xml:space="preserve">
          <source>CPU supports the PA Semi 6T CORE ISA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2267dd90003bf8b5f66bba6f8158082ed6e95240" translate="yes" xml:space="preserve">
          <source>CPU supports the data stream control register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a297e9cc9f2eb5df0912ac8e91302da6382422" translate="yes" xml:space="preserve">
          <source>CPU supports the integer select instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a95efc8023d10b71a08bff59a8789aa22a0fb6" translate="yes" xml:space="preserve">
          <source>CPU supports the old POWER ISA (eg, 601)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309f8ee6774ef217dd65020d0047499e145915f8" translate="yes" xml:space="preserve">
          <source>CPU supports the set of compatible performance monitoring events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654d56ee4aa1191ad640c84c9cda741472551b11" translate="yes" xml:space="preserve">
          <source>CPU supports the target address register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b74cd2604db8f416c0c904f549425dc7576345f" translate="yes" xml:space="preserve">
          <source>CPU supports the vector cryptography instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2910c789b3b4293207054dd9a2e43cc18d433b78" translate="yes" xml:space="preserve">
          <source>CPU supports the vector-scalar extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c99496e20c6a12697b36d694855c474afbe5bb" translate="yes" xml:space="preserve">
          <source>CPU supports true little-endian mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec7e4eb5fc127660ed425c7dcd89cd8eddc4bc5" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 10h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSE4A, 3DNow!, enhanced 3DNow!, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84062366ba14fb3f3b6ff6b47d03c475a3828a9" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 14h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSSE3, SSE4A, CX16, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113524bb3893cb5857442da17502358001cf141b" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 15h cores with x86-64 instruction set support. (This supersets FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a0219528807f6268d19e1c7ca96f3e9c601c1e" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 16h cores with x86-64 instruction set support. This includes MOVBE, F16C, BMI, AVX, PCL_MUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762cf7076b068d306d32ea79b0d0e2277121f2b5" translate="yes" xml:space="preserve">
          <source>CR</source>
          <target state="translated">CR</target>
        </trans-unit>
        <trans-unit id="5e1fb0077df92097ce069aa21ed47aa03c3d5c5d" translate="yes" xml:space="preserve">
          <source>CR16 Architecture&amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c744e8c0ecb712753e6342db41d199b59d9bf6" translate="yes" xml:space="preserve">
          <source>CTR</source>
          <target state="translated">CTR</target>
        </trans-unit>
        <trans-unit id="58ad68590efc1385d2b4fd64a16b4b9f8cfaaa44" translate="yes" xml:space="preserve">
          <source>Call operand, const_int, for absolute calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3373e7e79f4085d8f7291896ef1d3760c15083be" translate="yes" xml:space="preserve">
          <source>Call operand, reg, for indirect calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c51d11770c5ea3546c0d152d73faf160c859f37" translate="yes" xml:space="preserve">
          <source>Call operand, symbol, for relative calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c515fe9bf062328bec62182c3bb93d352208ec" translate="yes" xml:space="preserve">
          <source>Call the named function &lt;var&gt;function&lt;/var&gt;, passing it &lt;var&gt;args&lt;/var&gt;. &lt;var&gt;args&lt;/var&gt; is first processed as a nested spec string, then split into an argument vector in the usual fashion. The function returns a string which is processed as if it had appeared literally as part of the current spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1ccc6ccff0a4b4d69b01f9c83e0859c8e4f058" translate="yes" xml:space="preserve">
          <source>Calling conventions are a subset of an ABI that specify of how arguments are passed and function results are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e13d2ff4cf44ed7d75b8cee9472ba906dfafd20" translate="yes" xml:space="preserve">
          <source>Calling this function with a nonzero argument can have unpredictable effects, including crashing the calling program. As a result, calls that are considered unsafe are diagnosed when the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc12921ff6d4899e4dc68b34cc1cd37e3157e57e" translate="yes" xml:space="preserve">
          <source>Calls a library function that performs the operation in double precision floating point. Division by zero causes a floating-point exception. This is the default for SHcompact with FPU. Specifying this for targets that do not have a double precision FPU defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e8cd2fa85f5515142e26b60a518bb56cd4bcb6" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses a lookup table for small divisors and the &lt;code&gt;div1&lt;/code&gt; instruction with case distinction for larger divisors. Division by zero calculates an unspecified result and does not trap. This is the default for SH4. Specifying this for targets that do not have dynamic shift instructions defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66ee13b0a48eb1333567adb5302965969bbf50a" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses the single-step division instruction &lt;code&gt;div1&lt;/code&gt; to perform the operation. Division by zero calculates an unspecified result and does not trap. This is the default except for SH4, SH2A and SHcompact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45cc51de5de6fd998285ffd2412d7b2646d5ad0" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;foo&lt;/code&gt; are mapped to calls to &lt;code&gt;foo{20040821}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="293878ce1781e2ea1bacb79578feb3fbe4be3315" translate="yes" xml:space="preserve">
          <source>Calls to external functions with this attribute must return to the current compilation unit only by return or by exception handling. In particular, a leaf function is not allowed to invoke callback functions passed to it from the current compilation unit, directly call functions exported by the unit, or &lt;code&gt;longjmp&lt;/code&gt; into the unit. Leaf functions might still call functions from other compilation units and thus they are not necessarily leaf in the sense that they contain no function calls at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4271715ba8546178ce2b0fafe7396f6340205ed7" translate="yes" xml:space="preserve">
          <source>Calls to functions that have no observable effects on the state of the program other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;pure&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b52d0ab938b444cac1b9e9d1c160806cd6da345" translate="yes" xml:space="preserve">
          <source>Calls to functions whose return value is not affected by changes to the observable state of the program and that have no observable effects on such state other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;const&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8eba46ecad008a4e218a210a71672db04d7e157" translate="yes" xml:space="preserve">
          <source>Cancel an assertion with the predicate &lt;var&gt;predicate&lt;/var&gt; and answer &lt;var&gt;answer&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d15eea66865b0282cb17c0e3120ed653071f95" translate="yes" xml:space="preserve">
          <source>Cancel any previous definition of &lt;var&gt;name&lt;/var&gt;, either built in or provided with a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192387cfc73b539ff900c725ddee4d021db73db5" translate="yes" xml:space="preserve">
          <source>Casting to union type from any member of the union.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08eca4544a17d0207cde77668a933d9951e246a" translate="yes" xml:space="preserve">
          <source>Cause gas to print out tomcat statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1bd09378f19d49cb410444dadaeb9f88738a8a" translate="yes" xml:space="preserve">
          <source>Cause the errors having to do with files that have the wrong architecture to be fatal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5019333f8c270c0e57b171951e0397047e39d35e" translate="yes" xml:space="preserve">
          <source>Causes GCC to remember the state of the diagnostics as of each &lt;code&gt;push&lt;/code&gt;, and restore to that point at each &lt;code&gt;pop&lt;/code&gt;. If a &lt;code&gt;pop&lt;/code&gt; has no matching &lt;code&gt;push&lt;/code&gt;, the command-line options are restored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667cccec716e1283ccef9e29985511e0bdf9e0a0" translate="yes" xml:space="preserve">
          <source>Causes all functions to default to the &lt;code&gt;.far&lt;/code&gt; section. Without this option, functions default to the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30905206e2b1ac1064f6ac3bbe5bd6c803a6b79" translate="yes" xml:space="preserve">
          <source>Causes all variables to default to the &lt;code&gt;.tiny&lt;/code&gt; section. Note that there is a 65536-byte limit to this section. Accesses to these variables use the &lt;code&gt;%gp&lt;/code&gt; base register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98be0c7de301463de1c80070885a43330018a0b2" translate="yes" xml:space="preserve">
          <source>Causes constant variables to be placed in the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655599ac8eaa0291e221b62364ffdf96a51309de" translate="yes" xml:space="preserve">
          <source>Causes the output file to be marked such that the dynamic linker will bind all undefined references when the file is loaded or launched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48452dfc4582d4eee857576d8fb13bb7694884b" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.far&lt;/code&gt; section by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cb136a09a7c1b01f2dc417dcf7c22b8038c03d" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.near&lt;/code&gt; section by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdb8f56a4df91a529ce6b66e59857019a48ac1f" translate="yes" xml:space="preserve">
          <source>Certain ABI-changing flags are required to match in all compilation units, and trying to override this at link time with a conflicting value is ignored. This includes options such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8db3b10d95cbc07c88dbe64efa680baa0d22c3b" translate="yes" xml:space="preserve">
          <source>Certain local variables aren&amp;rsquo;t recognized by debuggers when you compile with optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7c527dd55f67d739c97b4f416bd42f396b0844" translate="yes" xml:space="preserve">
          <source>Cfront model</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aba59b0fc2fb3ed3ce5d3423cf83addc1f152f7" translate="yes" xml:space="preserve">
          <source>Change ABI to use double word insns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8ed70cb1d356e0b695cceb7ab02d866b216534" translate="yes" xml:space="preserve">
          <source>Change paragraph 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb692fbb429d564d86c14c1772ab21a4cec5d73" translate="yes" xml:space="preserve">
          <source>Change paragraph 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9fbfc9cacb726e629a9636bbe98d28a8d83b9b" translate="yes" xml:space="preserve">
          <source>Change paragraph 2 to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb241f39f5fa8625fba68e7d9da30611af7534b7" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IBM extended-precision long double. This is not likely to work if your system defaults to using IEEE extended-precision long double. If you change the long double type from IEEE extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b05bb4515e125b765f13f146e5cba54744fff37" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IEEE extended-precision long double. This is not likely to work if your system defaults to using IBM extended-precision long double. If you change the long double type from IBM extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cf332293e237ad325e62a5ee2905fadea5402b" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv1 ABI. This is the default ABI for big-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed54cd4038a43f7d20137c040c4f60546641dbf" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv2 ABI. This is the default ABI for little-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a1bd4814c92b33b933c24808e3438fdd28e471" translate="yes" xml:space="preserve">
          <source>Change the preferred SIMD mode to SImode. The default is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1693787c0c1da76f7df927835bc9d253ab1baa96" translate="yes" xml:space="preserve">
          <source>Change the target of the rule emitted by dependency generation. By default CPP takes the name of the main input file, deletes any directory components and any file suffix such as &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca39a5b032e87a9c462bafacf2e62ade09bc55e" translate="yes" xml:space="preserve">
          <source>Check calls to &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;, etc., to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense. This includes standard functions, and others specified by format attributes (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), in the &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; and &lt;code&gt;strfmon&lt;/code&gt; (an X/Open extension, not in the C standard) families (or other target-specific families). Which functions are checked without format attributes having been specified depends on the standard version selected, and such checks of functions without the attribute specified are disabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a3f453fdd63ac92077276df83570873739aa07" translate="yes" xml:space="preserve">
          <source>Check for 64 bits wide constants for add/sub instructions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac4c7c683a989d8b06bb9ece7f678cee49ed294" translate="yes" xml:space="preserve">
          <source>Check that the pointer returned by &lt;code&gt;operator new&lt;/code&gt; is non-null before attempting to modify the storage allocated. This check is normally unnecessary because the C++ standard specifies that &lt;code&gt;operator new&lt;/code&gt; only returns &lt;code&gt;0&lt;/code&gt; if it is declared &lt;code&gt;throw()&lt;/code&gt;, in which case the compiler always checks the return value even without this option. In all other cases, when &lt;code&gt;operator new&lt;/code&gt; has a non-empty exception specification, memory exhaustion is signalled by throwing &lt;code&gt;std::bad_alloc&lt;/code&gt;. See also &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e890de105f29124c3560894740b09b086a655a" translate="yes" xml:space="preserve">
          <source>Check the code for syntax errors, but don&amp;rsquo;t do anything beyond that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b609f7a36a96f87c3d3229801dbbe278531362e" translate="yes" xml:space="preserve">
          <source>Checking the number and type of arguments to a function which has an old-fashioned definition and no prototype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9acb009d6a873fdb579dcb1f012d6d507dcf76" translate="yes" xml:space="preserve">
          <source>Choose a data model. The choices for &lt;var&gt;model&lt;/var&gt; are &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3369d8e5fea9b901b46c632d20401df2fdb02c" translate="yes" xml:space="preserve">
          <source>Choose between the two available implementations of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e3a1c87aff0500a839e105b5b619da6d89b8a6" translate="yes" xml:space="preserve">
          <source>Choose integer type as 32-bit wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd477ac5e4063d79ef6de9d30fdf3c13757351dd" translate="yes" xml:space="preserve">
          <source>Choose startup files and linker script suitable for the simulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c124dc3d6f2fff1283f2960f19679f618eb758" translate="yes" xml:space="preserve">
          <source>Chopped rounding mode. Floating-point numbers are rounded towards zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baeeaf6c90ab7667596e853c19ec9377ba1a6bed" translate="yes" xml:space="preserve">
          <source>Chunk size of omp schedule for loops parallelized by parloops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f6c5316b94c42ede9e8f3c0902f04af5a47ac9" translate="yes" xml:space="preserve">
          <source>Clobber descriptions may not in any way overlap with an input or output operand. For example, you may not have an operand describing a register class with one member when listing that register in the clobber list. Variables declared to live in specific registers (see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;) and used as &lt;code&gt;asm&lt;/code&gt; input or output operands must have no part mentioned in the clobber description. In particular, there is no way to specify that input operands get modified without also specifying them as output operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d5e82c3d8cf6aecb50f1c3dec1dfd81862c300" translate="yes" xml:space="preserve">
          <source>Code Generation Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de73aa04e00c631b2bba60472a9b4cb42f90647b" translate="yes" xml:space="preserve">
          <source>Code generation tweaks that disable, respectively, splitting of 32-bit loads, generation of post-increment addresses, and generation of post-modify addresses. The defaults are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0acb8ba8662201458fc8762cdc2bfb973da3d9b7" translate="yes" xml:space="preserve">
          <source>Code like this may run successfully under some other compilers, particularly obsolete cfront-based compilers that delete temporaries along with normal local variables. However, the GNU C++ behavior is standard-conforming, so if your program depends on late destruction of temporaries it is not portable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d477ef0f890f99da791a35a9c4922d4a6b4caa9b" translate="yes" xml:space="preserve">
          <source>Code that (effectively) clobbers bits of &lt;code&gt;SREG&lt;/code&gt; other than the &lt;code&gt;I&lt;/code&gt;-flag by writing to the memory location of &lt;code&gt;SREG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22aee03764143c3347036737d5c49aa3c48b93fe" translate="yes" xml:space="preserve">
          <source>Code that uses inline assembler to jump to a different function which expects (parts of) the prologue code as outlined above to be present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04d4be0af028c55d37a5eda8e2e9e52e00d9883" translate="yes" xml:space="preserve">
          <source>Collect and dump debug information into a temporary file if an internal compiler error (ICE) occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de9bf73c20469d02f33a82c6c1b964c35ca72c5" translate="yes" xml:space="preserve">
          <source>Collect the profiles for different set of inputs, and use this tool to merge them. One can specify the weight to factor in the relative importance of each input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674fdd25c0f94978ce5404bf7783af22ebecb1fb" translate="yes" xml:space="preserve">
          <source>Combine increments or decrements of addresses with memory accesses. This pass is always skipped on architectures that do not have instructions to support this. Enabled by default at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c675961000becf8ff6422c0eeb1b9242b5fdf0f" translate="yes" xml:space="preserve">
          <source>Combines the effects of both &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4393d8b520a9b50ddef09d9f77984a620fcf38de" translate="yes" xml:space="preserve">
          <source>Combining several classes is possible, although this usually restricts the output so much that there is nothing to display. One case where it does work, however, is when one of the classes is &lt;var&gt;target&lt;/var&gt;. For example, to display all the target-specific optimization options, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a257637f31b3509bd8ac95d015b26d1c5d9ce9" translate="yes" xml:space="preserve">
          <source>Command options supported by &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5bbd00924927db3116b7ce896a99d0d6c09a71" translate="yes" xml:space="preserve">
          <source>Commit the current transaction. When no transaction is active this faults. All memory side effects of the transaction become visible to other threads in an atomic manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953dbfff4f1c2d7c9623cfa81345a412c8c95e6f" translate="yes" xml:space="preserve">
          <source>Common misunderstandings with GNU C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99484341af697bedb30f82944a2b8048a7bd9d3b" translate="yes" xml:space="preserve">
          <source>Compare at most &lt;var&gt;num&lt;/var&gt; string bytes with inline code. If the difference or end of string is not found at the end of the inline compare a call to &lt;code&gt;strcmp&lt;/code&gt; or &lt;code&gt;strncmp&lt;/code&gt; will take care of the rest of the comparison. The default is 64 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e11797436f7910f8bb83ca2860c72513034685a" translate="yes" xml:space="preserve">
          <source>Comparison of four paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any4t&lt;/code&gt;/&lt;code&gt;bc1any4f&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8cb7f422f46057d6869362d0511c9090d3a1fd7" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a9160f31b23e32c54ba7fe5458de10730189d9" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any2t&lt;/code&gt;/&lt;code&gt;bc1any2f&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651d13a7683a8781ee0feea932b0d34d198ddce8" translate="yes" xml:space="preserve">
          <source>Comparison operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1adbeb956bb205e79fa3fa9ca1c2daca593fb1fa" translate="yes" xml:space="preserve">
          <source>Compatibilities with earlier definitions of C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c2b0659cd05018587a8d43545227600a32a376" translate="yes" xml:space="preserve">
          <source>Compilation can involve up to four stages: preprocessing, compilation proper, assembly and linking, always in that order. GCC is capable of preprocessing and compiling several files either into several assembler input files, or into one assembler input file; then each assembler input file produces an object file, and linking combines all the object files (those newly compiled, and those specified as input) into an executable file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f490d968ba17b1a6b9c49acd428a6392e787830" translate="yes" xml:space="preserve">
          <source>Compile ARCv2 code with a multiplier design option. You can specify the option using either a string or numeric value for &lt;var&gt;multo&lt;/var&gt;. &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a90dd66273f8436ce33369f342227123629a080" translate="yes" xml:space="preserve">
          <source>Compile code assuming that IEEE signaling NaNs may generate user-visible traps during floating-point operations. Setting this option disables optimizations that may change the number of exceptions visible with signaling NaNs. This option implies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9970fa5395affc7dc93ea1ed06f8fdd6c082c5bc" translate="yes" xml:space="preserve">
          <source>Compile code assuming that floating-point operations cannot generate user-visible traps. These traps include division by zero, overflow, underflow, inexact result and invalid operation. This option requires that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7167229840a9f09cf85e4d3c02813e6e3f7c2954" translate="yes" xml:space="preserve">
          <source>Compile code assuming that pointers to the PPU address space accessed via the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier are either 32 or 64 bits wide. The default is 32 bits. As this is an ABI-changing option, all object code in an executable must be compiled with the same setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31103695d6eecad4fc985951c0af142d11cd5c1a" translate="yes" xml:space="preserve">
          <source>Compile code compatible with Android platform. This is the default on &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="894efb97728307a39eeed2699c1c4e4bd26dd9dc" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian mode. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1832ee4b35f2abfa3f4e141edadd28f18085110" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian targets. Use of these options is now deprecated. Big-endian code is supported by configuring GCC to build &lt;code&gt;arceb-elf32&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets, for which big endian is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8c22e36ad1f39109ec2efd6cc1a81d955acd13" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8ec4f965ec58185bb6754ac805aafeb89d3ae4" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian targets. Use of these options is now deprecated. Little-endian code is supported by configuring GCC to build &lt;code&gt;arc-elf32&lt;/code&gt; and &lt;code&gt;arc-linux-uclibc&lt;/code&gt; targets, for which little endian is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cb11574bb395057387b096cea7b6d6f515f971" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in big-endian mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f489feb9b6caedf9bb6320c99f84e7364f3077b" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in little-endian mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39bc5e8e166e8b03d8be316efdd326cda59c0f57" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17be7dfb615c6d886c0d693b9048e7e155b99fb6" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f2d72dcd31900923f3da8d539cfc9292aa3f8e" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16696f4c8426aaf6854eeea45ee7e1bd467edd27" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bca932c9c4e343d44b89be260ad06bfe429ab8a" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02df7632e889a6c5616971f35e12edcc4a5d8c62" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7fdc4d4b7214e5e7819e3d3a90236053d8b22cd" translate="yes" xml:space="preserve">
          <source>Compile for ARC 700 on NPS400 chip.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4380f255d2d18d4e8f267e7678f7435eab73b8" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM CPU with no hardware extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d617eff21e80138509c5fb71d3dfb75e71687f6e" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM minimalist configuration featuring reduced register set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b4e707d87f6b65d51c529906a072e95ff89b29" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da70dd835733600356587db74a19ff09214dbd17" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a460d3a31969ec154e7b1632e56830c60250b541" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with single-precision floating-point and double assist instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b00683884602ca4044736a233bc8c892a0f636" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with the single-precision floating-point extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b1ffe9efdf7ea63c9f3422bb5547df94d22ce1" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086d9196358fe7f0fa7f3e7051ae4fc4f433b7ae" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS CPU with no hardware extensions except the atomic instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cacfee18847f11dad685598d36ea6ee3b6957c02" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847cd27652d52b58f36a4f2e5ea5cead4371673c" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS34 CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d44b3581972b8ea0a69f39fb0ebefd762b42bbe7" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU with all hardware extensions on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c711906d8e4d4a87fb48440c2cfaa0c80bee620" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8348ca27592b892d967948ee652e94376f711101" translate="yes" xml:space="preserve">
          <source>Compile for ARC600. Aliases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0fc8bbbde2253a58a83a11623bea243e8a7c8b" translate="yes" xml:space="preserve">
          <source>Compile for ARC601. Alias:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e0d990baf06011ef4d82bdf9df53fdce00286b" translate="yes" xml:space="preserve">
          <source>Compile for ARC700. Aliases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e278797da8990f0ccb7f07f045508cd4010b76aa" translate="yes" xml:space="preserve">
          <source>Compile for GCN3 Fiji devices (gfx803).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713b8f86530a1c2d9a5d702e486321c4dc351849" translate="yes" xml:space="preserve">
          <source>Compile for GCN5 Vega 10 devices (gfx900).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c48f84ed7faf104f474152b0d3bc268ee56eba" translate="yes" xml:space="preserve">
          <source>Compile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aada22a2dba27d65c33f8d484ca9df970f74fa8a" translate="yes" xml:space="preserve">
          <source>Compile the source files additionally with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e1d1625ee50b70503b880bddd8c2899625cfd1d" translate="yes" xml:space="preserve">
          <source>Compile the source files with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae2f3f4c4da22165b65f81f0ab47bfdf72e5a74" translate="yes" xml:space="preserve">
          <source>Compile your code with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a5380160ff93557be23ea688dad9be208e4dbd" translate="yes" xml:space="preserve">
          <source>Compile your template-using code with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1fb4ab4c5c8120d8c582a624d0a9ac53f55fe3" translate="yes" xml:space="preserve">
          <source>Compiler encoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24922f29f09454ba5b177fdcf5e81c9543043eef" translate="yes" xml:space="preserve">
          <source>Compiler support for type traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d58377b2111c9408f411d965f3b8abfb37ec05b" translate="yes" xml:space="preserve">
          <source>Compiling C++ programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed13de84ad4a0f0cd9e6bd0e630f5cc19d816c7d" translate="yes" xml:space="preserve">
          <source>Compiling a header once, and using it many times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9cb191f84bf0e0a5fd4e8fafa0cbeb0ce255ebb" translate="yes" xml:space="preserve">
          <source>Compiling with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8097f9a2f49c7bb34a8f3d4a23b5682dee4f13c4" translate="yes" xml:space="preserve">
          <source>Complex multiplication and division follow Fortran rules. Range reduction is done as part of complex division, but there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e323088fd5a174d70e9a002849c8a4e688bcae61" translate="yes" xml:space="preserve">
          <source>Complex types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a513e209b739423b55158eb7f0004ee614ede0ee" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined by Renesas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca1263e4404b74af40b4e0106fd5b298bab578a" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined for GCC before the Renesas conventions were available. This option is the default for all targets of the SH toolchain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8065b09eb57234d64105b727689f45402502d3a0" translate="yes" xml:space="preserve">
          <source>Compound literals for scalar types and union types are also allowed. In the following example the variable &lt;code&gt;i&lt;/code&gt; is initialized to the value &lt;code&gt;2&lt;/code&gt;, the result of incrementing the unnamed object created by the compound literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bff82561ec7274ee97d8914e7822d45d55dda6" translate="yes" xml:space="preserve">
          <source>Compound literals give structures, unions or arrays as values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9966e73a786b7c65f837b6274e264d2ae3402caf" translate="yes" xml:space="preserve">
          <source>Compress all code using the Ft32B code compression scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c77d95794a767632393b14f518d98416da9d81b" translate="yes" xml:space="preserve">
          <source>Compute the overlap score between the two specified profile directories. The overlap score is computed based on the arc profiles. It is defined as the sum of min (p1_counter[i] / p1_sum_all, p2_counter[i] / p2_sum_all), for all arc counter i, where p1_counter[i] and p2_counter[i] are two matched counters and p1_sum_all and p2_sum_all are the sum of counter values in profile 1 and profile 2, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0428c06ffccfdc67cd165569d403d34631d68a4" translate="yes" xml:space="preserve">
          <source>Condition code register</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7cba93bc22565aab9f967f87bf72c15fbda6979" translate="yes" xml:space="preserve">
          <source>Conditional move based on absolute comparison (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8ee622eb15147934b0f1ea15e7848c0fa98464" translate="yes" xml:space="preserve">
          <source>Conditional move based on floating-point comparison (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fb4ffc803fecfe4e7aef7908f668b60686f196" translate="yes" xml:space="preserve">
          <source>Configure a board specific runtime. This will be passed to the linker for newlib board library linking. The default is &lt;code&gt;or1ksim&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
