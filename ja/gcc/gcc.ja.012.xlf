<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="129a020d6e4e2d22eefb43a7999c4dc2402a1a50" translate="yes" xml:space="preserve">
          <source>The minimum probability (in percents) of reaching a source block for interblock speculative scheduling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4b50e8ed53d44237971958e2e83e18524eb941" translate="yes" xml:space="preserve">
          <source>The minimum probability an edge must have for the scheduler to save its state across it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61926ef9181910c24fa1d9136e2e7aa3bdc9bb32" translate="yes" xml:space="preserve">
          <source>The minimum ratio between stride of two loops for interchange to be profitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e01e027a6a504c434a5c40600808d2984b71737" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of memory references to enable prefetching in a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8448923459ab38ab3cc0b8bb13a936b3627b06" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of prefetches to enable prefetching in a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8220c9492a5b7435fa642b1e05152b364a262db5" translate="yes" xml:space="preserve">
          <source>The minimum size of buffers (i.e. arrays) that receive stack smashing protection when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13054edb9e1ab6c7cefbb0f40ba19b0915f9beae" translate="yes" xml:space="preserve">
          <source>The minimum size of variables taking part in stack slot sharing when not optimizing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2de50582a702ec4d7ad2fc7c8e60438b0f0aa8" translate="yes" xml:space="preserve">
          <source>The minimum value of stage count that swing modulo scheduler generates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61665509912f06aa6c9cfa2083ef8e16d79724c" translate="yes" xml:space="preserve">
          <source>The most straightforward way to link a program to use a particular C++ library is to use a C++ driver that specifies that C++ library by default. The &lt;code&gt;g++&lt;/code&gt; driver, for example, tells the linker where to find GCC&amp;rsquo;s C++ library (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6349c8ef5b50987899abffe38003acbe800a64" translate="yes" xml:space="preserve">
          <source>The multiprocessing extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d24347b639fc5c1199b8f3590bff6a146e13c82" translate="yes" xml:space="preserve">
          <source>The name of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e8e383964ec0763f310d8e73ac1d3feb12f8de" translate="yes" xml:space="preserve">
          <source>The names of specific parameters, and the meaning of the values, are tied to the internals of the compiler, and are subject to change without notice in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329fe73400bc50b68cb243f0ab550043e7c95935" translate="yes" xml:space="preserve">
          <source>The native Linux/GNU toolchain also supports the value &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c44aa6fff9d063f62cf98bb0599d7c6a3d3bb6" translate="yes" xml:space="preserve">
          <source>The nested function can access all the variables of the containing function that are visible at the point of its definition. This is called &lt;em&gt;lexical scoping&lt;/em&gt;. For example, here we show a nested function which uses an inherited variable named &lt;code&gt;offset&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50cb616ffb2082a3e3b7e7c2d21914b6c5a5b8a" translate="yes" xml:space="preserve">
          <source>The nested function&amp;rsquo;s name is local to the block where it is defined. For example, here we define a nested function named &lt;code&gt;square&lt;/code&gt;, and call it twice:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a845c4dca5c001e6d102157bfd313918d6f8a24" translate="yes" xml:space="preserve">
          <source>The nesting limit for &lt;code&gt;#include&lt;/code&gt; processing (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1446b5bc47ae4093c3d59b0d15fb2e41a888d931" translate="yes" xml:space="preserve">
          <source>The next example shows a case where the optimizers can recognize that the input (&lt;code&gt;dwSomeValue&lt;/code&gt;) never changes during the execution of the function and can therefore move the &lt;code&gt;asm&lt;/code&gt; outside the loop to produce more efficient code. Again, using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables this type of optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1737091e750836f7db5ac991c2404cb583f13f75" translate="yes" xml:space="preserve">
          <source>The next revision of the ISO C++ standard, tentatively planned for 2020. Support is highly experimental, and will almost certainly change in incompatible ways in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07fa07f1abd567516650f6c81218681c600c92af" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development, plus GNU extensions. The support for this version is experimental and incomplete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b02aa6b6d3d78493fbc1dc480d37a214f73df64" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development. The support for this version is experimental and incomplete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0fbf82a063b2707d9377f7fa702f1fc2dca6a1" translate="yes" xml:space="preserve">
          <source>The nine trigraphs and their replacements are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e272d2493136e9ddd803eb8bb6b214c461ac69" translate="yes" xml:space="preserve">
          <source>The nineteen 32-bit registers comprising general register R0 to R14, control register GBR, and system registers MACH, MACL, and PR and the vector table address offset are saved into a register bank. Register banks are stacked in first-in last-out (FILO) sequence. Restoration from the bank is executed by issuing a RESBANK instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee0e8fe4a16194f52480c8cf2068fc9bdcd0c7f" translate="yes" xml:space="preserve">
          <source>The non-atomic types are encoded as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bfaebfb4258608ad40629ce440aac9193290911" translate="yes" xml:space="preserve">
          <source>The normal vector extract, and set operations work on &lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt; types, but the index value must be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec51f6eb264a163ff7656783d752463b0cf474e2" translate="yes" xml:space="preserve">
          <source>The null pointer constant to which the macro &lt;code&gt;NULL&lt;/code&gt; expands (C90 7.1.6, C99 7.17, C11 7.19).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d03781cbc2651157f17e0c5fbab40ff5879c62" translate="yes" xml:space="preserve">
          <source>The number of bits in a byte (C90 3.4, C99 and C11 3.6).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5116832175ad50d3f8b15e3495e553905314a198" translate="yes" xml:space="preserve">
          <source>The number of cycles the swing modulo scheduler considers when checking conflicts using DFA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1520c1ee154295eb07c627660dca8d1a6b6092fb" translate="yes" xml:space="preserve">
          <source>The number of significant initial characters in an identifier (C90 6.1.2, C90, C99 and C11 5.2.4.1, C99 and C11 6.4.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070362ab17f17b33a3ae34d59055a18a1e302bf9" translate="yes" xml:space="preserve">
          <source>The number, order, and encoding of bytes in any object (when not explicitly specified in this International Standard) (C99 and C11 6.2.6.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b604e74e2e851789383571b70ad652997e4e66f6" translate="yes" xml:space="preserve">
          <source>The object is accessed with the respective segment override prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5091aabdc201178dc68e9213e404a14e73a3fa" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4db2564696e493fee1ef7423f76307823d51b1d" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type. All memory orders are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e4eecfa7c007179ae8943f279500072d8d783d" translate="yes" xml:space="preserve">
          <source>The only difference between &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3de508e233b8d2680fdf435e3d6c8313768a8db" translate="yes" xml:space="preserve">
          <source>The only supported use for this feature is to specify registers for input and output operands when calling Extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;). This may be necessary if the constraints for a particular machine don&amp;rsquo;t provide sufficient control to select the desired register. To force an operand into a register, create a local variable and specify the register name after the variable&amp;rsquo;s declaration. Then use the local variable for the &lt;code&gt;asm&lt;/code&gt; operand and specify any constraint letter that matches the register:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80fd38457618adab2fab3528f71d1285f53dd5df" translate="yes" xml:space="preserve">
          <source>The operand is the number of a register to be read. Generates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164925c793e36006eed2abf2f19f4ef48755a0ed" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;typeof&lt;/code&gt; is evaluated for its side effects if and only if it is an expression of variably modified type or the name of such a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2a4c2f3546ef01bb01773e4920ca0359e67ac5" translate="yes" xml:space="preserve">
          <source>The operand, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register and must be a compile time constant. Generates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3479099f68d087cc74ace860bc00a95f5b731c1f" translate="yes" xml:space="preserve">
          <source>The operations behave like C++ &lt;code&gt;valarrays&lt;/code&gt;. Addition is defined as the addition of the corresponding elements of the operands. For example, in the code below, each of the 4 elements in &lt;var&gt;a&lt;/var&gt; is added to the corresponding 4 elements in &lt;var&gt;b&lt;/var&gt; and the resulting vector is stored in &lt;var&gt;c&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde6238c26830fa82a53914b9244e589ab1e426d" translate="yes" xml:space="preserve">
          <source>The operator &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1ce068a17e5dbe0ea035d1beb9f2b11368df02" translate="yes" xml:space="preserve">
          <source>The option also sets the ISA to use. If the MCU name is one that is known to only support the 430 ISA then that is selected, otherwise the 430X ISA is selected. A generic MCU name of &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bace175215f4c9a9a5086a4520e874099d58bc7b" translate="yes" xml:space="preserve">
          <source>The option cannot be combined with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e6b8f7b2e1e4a87728188dd3bdb8e34222fb03" translate="yes" xml:space="preserve">
          <source>The option has three forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57372a8b45a9a651870f464f28239ea0a9400c1" translate="yes" xml:space="preserve">
          <source>The option is equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25431ae1de44b7a0042861eaf001a15d12b77c5c" translate="yes" xml:space="preserve">
          <source>The option is similar to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0b2b21730ed2a5e07ab579f0c874433e03d81f" translate="yes" xml:space="preserve">
          <source>The option&amp;rsquo;s behavior depends on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7003d8dcf16f832eac06c03046c9a171fa807708" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;volatile&lt;/code&gt; qualifier has no effect. All basic &lt;code&gt;asm&lt;/code&gt; blocks are implicitly volatile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a01a1e7aeded7ac16f376b31f6e97656f61592" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;sirevision&lt;/var&gt; specifies the silicon revision of the target Blackfin processor. Any workarounds available for the targeted silicon revision are enabled. If &lt;var&gt;sirevision&lt;/var&gt; is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72849bef73954b968c2b10753acfe7d2de97d61" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;mask&lt;/var&gt; may have the value &lt;code&gt;notinbranch&lt;/code&gt; or &lt;code&gt;inbranch&lt;/code&gt;, and instructs the compiler to generate non-masked or masked clones correspondingly. By default, all clones are generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf601c68a359b3325301de84f8214ec6cb3bee0d" translate="yes" xml:space="preserve">
          <source>The optional extension of specifying vector constants in parentheses is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e1def618310843db3ebed1e3d40c1b748262844" translate="yes" xml:space="preserve">
          <source>The optional first word limits the specification to structs that are used directly (&amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fe5708942d28978cc841b9258dd8862934e265" translate="yes" xml:space="preserve">
          <source>The optional second word limits the specification to ordinary structs (&amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a150b476753c90be937c4eb85655e5b29ceeef" translate="yes" xml:space="preserve">
          <source>The options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4a8e159eb45db26e41d6b181749d12e91d13f3" translate="yes" xml:space="preserve">
          <source>The options from each group can be freely mixed as they are non-overlapping. However, in case of any conflicts, the later options override the earlier options on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03370c70b8d685b972b4178e392c07f67da021e0" translate="yes" xml:space="preserve">
          <source>The options in this section are defined for all VxWorks targets. Options specific to the target hardware are listed with the other options for that target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4645ad9aafdb886f64431f817492a531da45bb" translate="yes" xml:space="preserve">
          <source>The options supported are specific to each target; refer to &lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;x86 Function Attributes&lt;/a&gt;, &lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC Function Attributes&lt;/a&gt;, &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;, &lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64 Function Attributes&lt;/a&gt;, &lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;Nios II Function Attributes&lt;/a&gt;, and &lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S/390 Function Attributes&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a395788ed90836d2997bb1c84003ea7ffde770" translate="yes" xml:space="preserve">
          <source>The options work exactly like the S/390 specific command line options (without the prefix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e8fa6c8ae05f8e2a34557e6036eae0a9b76ff8" translate="yes" xml:space="preserve">
          <source>The order in which &lt;code&gt;+load&lt;/code&gt; and &lt;code&gt;+initialize&lt;/code&gt; are called could be problematic if this matters. If you don&amp;rsquo;t allocate objects inside &lt;code&gt;+load&lt;/code&gt;, it is guaranteed that &lt;code&gt;+load&lt;/code&gt; is called before &lt;code&gt;+initialize&lt;/code&gt;. If you create an object inside &lt;code&gt;+load&lt;/code&gt; the &lt;code&gt;+initialize&lt;/code&gt; method of object&amp;rsquo;s class is invoked even if &lt;code&gt;+load&lt;/code&gt; was not invoked. Note if you explicitly call &lt;code&gt;+load&lt;/code&gt; on a class, &lt;code&gt;+initialize&lt;/code&gt; will be called first. To avoid possible problems try to implement only one of these methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72c8cfa2bf4559a476794fbcac9230458dd1acf" translate="yes" xml:space="preserve">
          <source>The order of allocation of bit-fields within a unit (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bf99243d90e9f90c583730aacfa820007d4c7a" translate="yes" xml:space="preserve">
          <source>The ordering and number of these preamble lines will be augmented as &lt;code&gt;gcov&lt;/code&gt; development progresses &amp;mdash; do not rely on them remaining unchanged. Use &lt;var&gt;tag&lt;/var&gt; to locate a particular preamble line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78a9eb6841c341650bf4b7b23dd41a17afa341e" translate="yes" xml:space="preserve">
          <source>The original ANSI C standard (X3.159-1989) was ratified in 1989 and published in 1990. This standard was ratified as an ISO standard (ISO/IEC 9899:1990) later in 1990. There were no technical differences between these publications, although the sections of the ANSI standard were renumbered and became clauses in the ISO standard. The ANSI standard, but not the ISO standard, also came with a Rationale document. This standard, in both its forms, is commonly known as &lt;em&gt;C89&lt;/em&gt;, or occasionally as &lt;em&gt;C90&lt;/em&gt;, from the dates of ratification. To select this standard in GCC, use one of the options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c496279e266f5ecd75f883afecb2192cd2a917" translate="yes" xml:space="preserve">
          <source>The original ISO C++ standard was published as the ISO standard (ISO/IEC 14882:1998) and amended by a Technical Corrigenda published in 2003 (ISO/IEC 14882:2003). These standards are referred to as C++98 and C++03, respectively. GCC implements the majority of C++98 (&lt;code&gt;export&lt;/code&gt; is a notable exception) and most of the changes in C++03. To select this standard in GCC, use one of the options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55c2d645aa0f80881178d7412aa07a062ca969b" translate="yes" xml:space="preserve">
          <source>The other options specify a specific processor. Code generated under those options runs best on that processor, and may not run at all on others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5fefa619d556bce9b8629c20698a9fbaa045b6" translate="yes" xml:space="preserve">
          <source>The output is sensitive to the effects of previous command-line options, so for example it is possible to find out which optimizations are enabled at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1f8d32c864542b44f4a83fd30d75feed01b2e0" translate="yes" xml:space="preserve">
          <source>The output shows that this block of code, combined by optimization, executed 100 times. In one sense this result is correct, because there was only one instruction representing all four of these lines. However, the output does not indicate how many times the result was 0 and how many times the result was 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25cd388eab46b62953cbdcb13acb11f5a206e81f" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;archetype&lt;/var&gt; determines how the format string is interpreted, and should be &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt;, &lt;code&gt;gnu_printf&lt;/code&gt;, &lt;code&gt;gnu_scanf&lt;/code&gt;, &lt;code&gt;gnu_strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt;. (You can also use &lt;code&gt;__printf__&lt;/code&gt;, &lt;code&gt;__scanf__&lt;/code&gt;, &lt;code&gt;__strftime__&lt;/code&gt; or &lt;code&gt;__strfmon__&lt;/code&gt;.) On MinGW targets, &lt;code&gt;ms_printf&lt;/code&gt;, &lt;code&gt;ms_scanf&lt;/code&gt;, and &lt;code&gt;ms_strftime&lt;/code&gt; are also present. &lt;var&gt;archetype&lt;/var&gt; values such as &lt;code&gt;printf&lt;/code&gt; refer to the formats accepted by the system&amp;rsquo;s C runtime library, while values prefixed with &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f3b990be6aa69326bd74ae4681ebc09216102d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;string-index&lt;/var&gt; specifies which argument is the format string argument (starting from one). Since non-static C++ methods have an implicit &lt;code&gt;this&lt;/code&gt; argument, the arguments of such methods should be counted from two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb73878f5340c14052a29fb8e00d23ff62b384d" translate="yes" xml:space="preserve">
          <source>The part of a compiler that is specific to a particular language is called the &amp;ldquo;front end&amp;rdquo;. In addition to the front ends that are integrated components of GCC, there are several other front ends that are maintained separately. These support languages such as Mercury, and COBOL. To use these, they must be built together with GCC proper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b45d0ebc931e1e733ecb9fb1c3f4c5240b8194" translate="yes" xml:space="preserve">
          <source>The particular options set for any particular CPU varies between compiler versions, depending on what setting seems to produce optimal code for that CPU; it doesn&amp;rsquo;t necessarily reflect the actual hardware&amp;rsquo;s capabilities. If you wish to set an individual option to a particular value, you may specify it after the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452dc4aa50f4dd1fa4974069451a474c59e40f9c" translate="yes" xml:space="preserve">
          <source>The parts that differ are highlighted with color (&amp;ldquo;double&amp;rdquo; and &amp;ldquo;float&amp;rdquo; in this case).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af1a3f7e74758af6362de95fe293ce9aa19535b" translate="yes" xml:space="preserve">
          <source>The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2679379ebc643273c71ff53ef41c24d477972525" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;arch&lt;/var&gt; are &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d47f57e4f2874c39d4b9abd17b4e23013a44ad" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;feature&lt;/var&gt; are listed in the sub-section on &lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-march&lt;/samp&gt; and &lt;samp&gt;-mcpu&lt;/samp&gt; Feature Modifiers&lt;/a&gt;. Where conflicting feature modifiers are specified, the right-most feature is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e86233015dde5cd1c78847180c34b2f1e2bf2b" translate="yes" xml:space="preserve">
          <source>The places that are searched for an included &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8b187fae5590414120f103d445af72242d5c3b" translate="yes" xml:space="preserve">
          <source>The position in the bit-field is the position, counting in bits, of the bit closest to the beginning of the structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b546e403df1ecde52f18e1df9da4aeb8d7bc41" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;var&gt;visibility_type&lt;/var&gt; correspond to the visibility settings in the ELF gABI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6264d8e91343ef3a61a9b344f8646bf4aba8cc7" translate="yes" xml:space="preserve">
          <source>The practice of reading from a different union member than the one most recently written to (called &amp;ldquo;type-punning&amp;rdquo;) is common. Even with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcfc9f88180eb2f1134228de5ee485783fb7bf2" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the AArch64 target correspond to the AArch64 target function attributes. They can be specified as below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645dbf1ac450b591d9e4ddc2872516c2fa74709d" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the S/390 target correspond to the S/390 target function attributes and some the additional options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0f7aae6dce4abe2e06c56745ef40bd52aa8844" translate="yes" xml:space="preserve">
          <source>The precise convention for returning structures in memory depends on the target configuration macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91248f1a5a5155ccc98999905b33b441a4c0b382" translate="yes" xml:space="preserve">
          <source>The precompiled header file must be produced for the same language as the current compilation. You cannot use a C precompiled header for a C++ compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7364d3dac14debc46aa1590555ff15d8a2c5504" translate="yes" xml:space="preserve">
          <source>The precompiled header file must have been produced by the same compiler binary as the current compilation is using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa601548ca48cf3a1634bdb3b2571be6608e559a" translate="yes" xml:space="preserve">
          <source>The preferred mechanism to declare variable-length types like &lt;code&gt;struct line&lt;/code&gt; above is the ISO C99 &lt;em&gt;flexible array member&lt;/em&gt;, with slightly different syntax and semantics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781223d90b25e173d9a1c191f04f39b92b12674b" translate="yes" xml:space="preserve">
          <source>The preprocessor constants &lt;code&gt;__v850&lt;/code&gt; and &lt;code&gt;__v851__&lt;/code&gt; are always defined, regardless of which processor variant is the target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516a25c40cc84aaf870728160964e02be2e34941" translate="yes" xml:space="preserve">
          <source>The preprocessor macro &lt;code&gt;__nios2_arch__&lt;/code&gt; is available to programs, with value 1 or 2, indicating the targeted ISA level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e3cb02afe1efb7ea595142066c8a4b5aee7508" translate="yes" xml:space="preserve">
          <source>The preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; and &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; may be used to check which semantics are in effect for &lt;code&gt;inline&lt;/code&gt; functions. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Common Predefined Macros&lt;/a&gt; in The C Preprocessor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e144b8574fca5ee84d650870787998db8cc0a6cc" translate="yes" xml:space="preserve">
          <source>The preprocessor symbols &lt;code&gt;__SEG_FS&lt;/code&gt; and &lt;code&gt;__SEG_GS&lt;/code&gt; are defined when these address spaces are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59cc56242765d93d1139cc69346a113ae66f0437" translate="yes" xml:space="preserve">
          <source>The preprocessor treatment of escaped newlines is more relaxed than that specified by the C90 standard, which requires the newline to immediately follow a backslash. GCC&amp;rsquo;s implementation allows whitespace in the form of spaces, horizontal and vertical tabs, and form feeds between the backslash and the subsequent newline. The preprocessor issues a warning, but treats it as a valid escaped newline and combines the two lines to form a single logical line. This works within comments and tokens, as well as between tokens. Comments are &lt;em&gt;not&lt;/em&gt; treated as whitespace for the purposes of this relaxation, since they have not yet been replaced with spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2282938cc4db5b60fc722ea3f4e0b1558cfa2dc" translate="yes" xml:space="preserve">
          <source>The program counter (PC) is 2 bytes wide. This is the case for devices with up to 128 KiB of program memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdec771ba3fce1f14ccbe2f783eeba3b5eb697cc" translate="yes" xml:space="preserve">
          <source>The programs that fix the header files do not understand this special way of using symbolic links; therefore, the directory of fixed header files is good only for the machine model used to build it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f7403716543aa22328bdac3e1ded4dc52aedb3" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;dynamic&lt;/code&gt; means that the function manipulates the stack dynamically: in addition to the static allocation described above, stack adjustments are made in the body of the function, for example to push/pop arguments around function calls. If the qualifier &lt;code&gt;bounded&lt;/code&gt; is also present, the amount of these adjustments is bounded at compile time and the second field is an upper bound of the total amount of stack used by the function. If it is not present, the amount of these adjustments is not bounded at compile time and the second field only represents the bounded part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b6ee8f6057a92bf82347dbc31b9360f115d43a" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;static&lt;/code&gt; means that the function manipulates the stack statically: a fixed number of bytes are allocated for the frame on function entry and released on function exit; no stack adjustments are otherwise made in the function. The second field is this fixed number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99c785e19e25b0fcfa2c0d8dc79cf7ec34db9e9" translate="yes" xml:space="preserve">
          <source>The rank of any extended integer type relative to another extended integer type with the same precision (C99 and C11 6.3.1.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6573d176933b5e09eb83df2d5615b45a3bb76e" translate="yes" xml:space="preserve">
          <source>The reason for using names that start with underscores for the local variables is to avoid conflicts with variable names that occur within the expressions that are substituted for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Eventually we hope to design a new form of declaration syntax that allows you to declare variables whose scopes start only after their initializers; this will be a more reliable way to prevent such conflicts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b5e6eec29945ad1cdc98a53fb0e13f400b8a4b" translate="yes" xml:space="preserve">
          <source>The register assignments for arguments and return values remain the same, but each scalar value is passed in a single 64-bit register rather than a pair of 32-bit registers. For example, scalar floating-point values are returned in &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df089519561a6aaf6b0d5462a2d12a16f51ac16a" translate="yes" xml:space="preserve">
          <source>The register class usable in short insns. This is a register class constraint, and can thus drive register allocation. This constraint won&amp;rsquo;t match unless</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5827517313f66ee35c67440ea785808e96b2d8" translate="yes" xml:space="preserve">
          <source>The register group usable in short insns. This constraint does not use a register class, so that it only passively matches suitable registers, and doesn&amp;rsquo;t drive register allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d3acac63bf69f2e9cbe4802b6dfb23c1a3dc0a" translate="yes" xml:space="preserve">
          <source>The register indicated by Rx (not implemented yet).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14ae46b310b2d10e38a2d9126edc47d0a1b7438" translate="yes" xml:space="preserve">
          <source>The registers reserved for interrupts (&lt;code&gt;R24&lt;/code&gt; to &lt;code&gt;R31&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9c9dc3621d339e8f64077eedb5da8839ab6a60" translate="yes" xml:space="preserve">
          <source>The relevant bytes of the representation of the object are treated as an object of the type used for the access. See &lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;Type-punning&lt;/a&gt;. This may be a trap representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41e3aebc6e71662ecec887032e93bdb3882f388" translate="yes" xml:space="preserve">
          <source>The remainder of this section is specific to GNU C90 inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558c61b7cf4311ca70d848b51262ab1898c102b3" translate="yes" xml:space="preserve">
          <source>The remaining environment variables apply only when preprocessing the particular language indicated. Each specifies a list of directories to be searched as if specified with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96b85add00a5f322d58fcbd72ee7befb1dea21f" translate="yes" xml:space="preserve">
          <source>The remaining functions are provided for optimization purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4420491dd7bf1c05e945f7d72f0a1731089f6301" translate="yes" xml:space="preserve">
          <source>The respective segment base must be set via some method specific to the operating system. Rather than require an expensive system call to retrieve the segment base, these address spaces are not considered to be subspaces of the generic (flat) address space. This means that explicit casts are required to convert pointers between these address spaces and the generic address space. In practice the application should cast to &lt;code&gt;uintptr_t&lt;/code&gt; and apply the segment base offset that it installed previously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4574d542eb42ca2e1f7130ac8122d2979c3b76" translate="yes" xml:space="preserve">
          <source>The rest of this discussion uses the following code for illustrative purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6771696cde55a31392f32b7d1552e2429667db0a" translate="yes" xml:space="preserve">
          <source>The restrictions on &lt;code&gt;offsetof&lt;/code&gt; may be relaxed in a future version of the C++ standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1a1a42d6420a3422e966b9e8baa0847229727c" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlmi&lt;/code&gt; is obtained by rotating each element of the first argument vector left and inserting it under mask into the second argument vector. The third argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a3f0d57a834ed4eba9054b925159bf84ea4a8e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask specified by the second and third argument vectors. The second argument vector contains the shift count for each element in the low-order byte. The third argument vector contains the mask end for each element in the low-order byte, with the mask begin in the next higher byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac79b53c282a3e1bdc553acd00140fe5cdb87cf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_vrlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask. The second argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9316b131e727e77ff29281dc2e9a7402d2bc6522" translate="yes" xml:space="preserve">
          <source>The result of attempting to indirectly access an object with automatic or thread storage duration from a thread other than the one with which it is associated (C11 6.2.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="293312cb8a66343c5e00cc15dc2d11a748b78cdb" translate="yes" xml:space="preserve">
          <source>The result of converting a pointer to an integer or vice versa (C90 6.3.4, C99 and C11 6.3.2.3).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8adce6949d651dd3877dd8fc89775a368e6c5a5" translate="yes" xml:space="preserve">
          <source>The result of, or the signal raised by, converting an integer to a signed integer type when the value cannot be represented in an object of that type (C90 6.2.1.2, C99 and C11 6.3.1.3).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6372dea778f1e54932d501af42dec0c2c6cb7a32" translate="yes" xml:space="preserve">
          <source>The resulting code should be considerably faster in the majority of cases and avoid the numerical instability problems of 387 code, but may break some existing code that expects temporaries to be 80 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602584d89b66e12499de96c6abd45f1820a6ab70" translate="yes" xml:space="preserve">
          <source>The results of some bitwise operations on signed integers (C90 6.3, C99 and C11 6.5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e0446d619f737b8b3d1bfcead4987221134fe0" translate="yes" xml:space="preserve">
          <source>The return type, including type qualifiers. For example, a method returning &lt;code&gt;int&lt;/code&gt; would have &lt;code&gt;i&lt;/code&gt; here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d722a3f7a5a03ca6f3a20b50840f8dad2ad4a0a2" translate="yes" xml:space="preserve">
          <source>The return value is the value of &lt;var&gt;exp&lt;/var&gt;, which should be an integral expression. The semantics of the built-in are that it is expected that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b2899a0dec22c6c49cc318d7875f38a40fbcdb" translate="yes" xml:space="preserve">
          <source>The return value of the method is the number of objects in the current batch; this should not exceed &lt;code&gt;len&lt;/code&gt;, which is the maximum size of a batch as requested by the caller. The batch itself is returned in the &lt;code&gt;itemsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd39f3563e6cdbea884ac0f3b2596eb7ac3835c0" translate="yes" xml:space="preserve">
          <source>The rounding behaviors characterized by non-standard values of &lt;code&gt;FLT_ROUNDS&lt;/code&gt; (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0bfeda9cecd5551824a4a4e37d54810853db32" translate="yes" xml:space="preserve">
          <source>The runtime support file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c4c0226af27718cbd914b43f7be4de41a152cd" translate="yes" xml:space="preserve">
          <source>The safe way to write such code is to give the temporary a name, which forces it to remain until the end of the scope of the name. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4b69f3a9e8d7ca80206177b8876cf920e6f11b" translate="yes" xml:space="preserve">
          <source>The same</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53e3a35319895514d679977563fa8e554b518de" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__atomic_op_fetch&lt;/code&gt; built-in functions. All memory orders are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3bb42125b4caec8cf7a192592fcd99a8477b57" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; built-in functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ffb18b7d09b9daf66ff3c77ffe4ceee695ef40" translate="yes" xml:space="preserve">
          <source>The same problem can occur if one output parameter (&lt;var&gt;a&lt;/var&gt;) allows a register constraint and another output parameter (&lt;var&gt;b&lt;/var&gt;) allows a memory constraint. The code generated by GCC to access the memory address in &lt;var&gt;b&lt;/var&gt; can contain registers which &lt;em&gt;might&lt;/em&gt; be shared by &lt;var&gt;a&lt;/var&gt;, and GCC considers those registers to be inputs to the asm. As above, GCC assumes that such input registers are consumed before any outputs are written. This assumption may result in incorrect behavior if the &lt;code&gt;asm&lt;/code&gt; statement writes to &lt;var&gt;a&lt;/var&gt; before using &lt;var&gt;b&lt;/var&gt;. Combining the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84eb297a7c7adafda6643fbbc1a64827529d36ab" translate="yes" xml:space="preserve">
          <source>The same values for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee0deba9d1e7e31914904f7de96ff06cf02541a" translate="yes" xml:space="preserve">
          <source>The second and third &lt;code&gt;FOO&lt;/code&gt; should be in comments. This warning is on by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498b43ab0ba23ca5cccab7efec7dc706e6795ec7" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; and &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; must be a constant integer that is 0 or 1. The third argument to these built-in functions must be a constant integer in the range of 0 to 15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7455b53d8f1101ab3b5613a9bfe23cea1588051" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;var&gt;failval&lt;/var&gt;, is optional and defaults to zero if omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5696540b2cb16b0a24c5184cde684653dcb48a5" translate="yes" xml:space="preserve">
          <source>The second form of this directive is useful for the case where you have multiple headers with the same name in different directories. If you use this form, you must specify the same string to &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7af4ae65c75a113a136191463890951e0da2e45" translate="yes" xml:space="preserve">
          <source>The second pair of &lt;var&gt;n2&lt;/var&gt;:&lt;var&gt;m2&lt;/var&gt; values allows you to specify a secondary alignment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab6989d4c1c4f47e25307deb785d43e56803a5f" translate="yes" xml:space="preserve">
          <source>The security extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="227e1ad96cf49ba3c90eaa74176faf5e4ae6abc9" translate="yes" xml:space="preserve">
          <source>The sense of a qualifier can be inverted by prefixing it with the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555ceee2bb9cf5f8f3e29c4052854238c7fb191f" translate="yes" xml:space="preserve">
          <source>The set of runtime conventions followed by all of the tools that deal with binary representations of a program, including compilers, assemblers, linkers, and language runtime support. Some ABIs are formal with a written specification, possibly designed by multiple interested parties. Others are simply the way things are actually done by a particular set of tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0b9082dbf784ec48751abb46feb9a84f16889b" translate="yes" xml:space="preserve">
          <source>The setting &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be945ed951ef5a61f5eae361b911de27ce4736fe" translate="yes" xml:space="preserve">
          <source>The shadow stack unwind code looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e51279e9e910972feb51c0c337d5562d0a6bae6" translate="yes" xml:space="preserve">
          <source>The sign of the remainder on integer division (C90 6.3.5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3873ede6c61e304d381b113f1c8a01eb501fad5a" translate="yes" xml:space="preserve">
          <source>The simplest kind of constraint is a string full of letters, each of which describes one kind of operand that is permitted. Here are the letters that are allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57db1d7a87e06c8af2c5a7b6a9b449af372d773" translate="yes" xml:space="preserve">
          <source>The single- and double-precision FPv5 floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf5f529e48bebb5ac22844826b001e3be0c3afe" translate="yes" xml:space="preserve">
          <source>The single- and double-precision floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac5488ac14854117c1393d98f83c5a93f21526b" translate="yes" xml:space="preserve">
          <source>The single-precision FPv5 floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebaf382d5bdec22e2b7379aab4b7c48ea9e912b" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ad435877ea887d34b1b37f15d7368e56cc4675" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e79bc7e04e01647f6facb0d53f8d2ca1a7bc417" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv4 floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d793936d7de82c8ba0aab481f238e4822e465c4a" translate="yes" xml:space="preserve">
          <source>The single-precision floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ecbdd892eade8e6d4362e90240ff9047e6b2c01" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;t1&lt;/code&gt; is 8 bytes with the zero-length bit-field. If the zero-length bit-field were removed, &lt;code&gt;t1&lt;/code&gt;&amp;rsquo;s size would be 4 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d897dab500e785baf0afcdb6330501b34e2fb781" translate="yes" xml:space="preserve">
          <source>The size of L1 data cache, in kilobytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6dd15bf08b6f82cff4329c9e979dcd9c6cbe07" translate="yes" xml:space="preserve">
          <source>The size of L2 data cache, in kilobytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e800ceb09e88f57e9df529fb883fbfe1a95ef2" translate="yes" xml:space="preserve">
          <source>The size of cache line in L1 data cache, in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f610b8af116509d824f7fee0527a19292abfbc2" translate="yes" xml:space="preserve">
          <source>The size of the result of subtracting two pointers to elements of the same array (C90 6.3.6, C99 and C11 6.5.6).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcebc70f5d364873d98786d882fbb6e891304f9b" translate="yes" xml:space="preserve">
          <source>The sizes of all structures and unions are rounded up to a multiple of the number of bits set by this option. Permissible values are 8, 32 and 64. The default value varies for different toolchains. For the COFF targeted toolchain the default value is 8. A value of 64 is only allowed if the underlying ABI supports it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ff87dc2c61fa6c28fc00209d8623b3de0f7131" translate="yes" xml:space="preserve">
          <source>The small data area consists of sections &lt;code&gt;.sdata&lt;/code&gt; and &lt;code&gt;.sbss&lt;/code&gt;. Objects may be explicitly put in the small data area with the &lt;code&gt;section&lt;/code&gt; attribute using one of these sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7aae5531671a570fbd2d9e15330b629b257be9" translate="yes" xml:space="preserve">
          <source>The smallest number of different values for which it is best to use a jump-table instead of a tree of conditional branches. If the value is 0, use the default for the machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792c114efc46a607cc045f1ab679489dd4452c8d" translate="yes" xml:space="preserve">
          <source>The solution is to change your program to use appropriate system headers (&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; on systems with ISO C headers) and not to declare &lt;code&gt;time&lt;/code&gt; if the system header files declare it, or failing that to use &lt;code&gt;time_t&lt;/code&gt; as the return type of &lt;code&gt;time&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7081cb8d8850184ab64a42d1afab009a2529d69a" translate="yes" xml:space="preserve">
          <source>The solution is to not use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3e873518a99bceb250e9bd12263d250fd2ddde" translate="yes" xml:space="preserve">
          <source>The solution to these problems is to change the program to use &lt;code&gt;char&lt;/code&gt;-array variables with initialization strings for these purposes instead of string constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b067ba968d3fec2486b7d081b6185964ff8af7" translate="yes" xml:space="preserve">
          <source>The stack is not unwound before std::terminate is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac8658551fc80e0b476a0a64406cc85ed6f059b" translate="yes" xml:space="preserve">
          <source>The stack pointer (SP) register is treated as 8-bit respectively 16-bit register by the compiler. The definition of these macros is affected by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba04d525c72586baf4467ca71d2abc7ef4aa1e82" translate="yes" xml:space="preserve">
          <source>The stack pointer register (&lt;code&gt;SP&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0015c9e48f6bee73194b21376b4a1e1666cb6b7a" translate="yes" xml:space="preserve">
          <source>The stack pointer register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d93215dea1d74a35177f108c830b25b0a828601" translate="yes" xml:space="preserve">
          <source>The standard also defines two environments for programs, a &lt;em&gt;freestanding environment&lt;/em&gt;, required of all implementations and which may not have library facilities beyond those required of freestanding implementations, where the handling of program startup and termination are implementation-defined; and a &lt;em&gt;hosted environment&lt;/em&gt;, which is not required, in which all the library facilities are provided and startup is through a function &lt;code&gt;int
main (void)&lt;/code&gt; or &lt;code&gt;int main (int, char *[])&lt;/code&gt;. An OS kernel is an example of a program running in a freestanding environment; a program using the facilities of an operating system is an example of a program running in a hosted environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6db7352466c6267511c0ba5dc350845fe3cad9" translate="yes" xml:space="preserve">
          <source>The standard is worded confusingly, therefore there is some debate over the precise meaning of the sequence point rules in subtle cases. Links to discussions of the problem, including proposed formal definitions, may be found on the GCC readings page, at &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69cda6ddbf344279c641ca143790b176ad293ac4" translate="yes" xml:space="preserve">
          <source>The standard rules for &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros are used to find a common type &lt;var&gt;u&lt;/var&gt; from the types of the arguments for parameters whose types vary between the functions; complex integer types (a GNU extension) are treated like &lt;code&gt;_Complex double&lt;/code&gt; for this purpose (or &lt;code&gt;_Complex _Float64&lt;/code&gt; if all the function return types are the same &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; type). If the function return types vary, or are all the same integer type, the function called is the one for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, and it is an error if there is no such function. If the function return types are all the same floating-point type, the type-generic macro is taken to be one of those from TS 18661 that rounds the result to a narrower type; if there is a function for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, it is called, and otherwise the first function, if any, for which &lt;var&gt;t&lt;/var&gt; has at least the range and precision of &lt;var&gt;u&lt;/var&gt; is called, and it is an error if there is no such function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806ce7f42e8deb00dbd822deaceb91e1417e5da0" translate="yes" xml:space="preserve">
          <source>The startup code from libgcc never sets &lt;code&gt;EIND&lt;/code&gt;. Notice that startup code is a blend of code from libgcc and AVR-LibC. For the impact of AVR-LibC on &lt;code&gt;EIND&lt;/code&gt;, see the &lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-LibC user manual&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98c1752aa45287d5195f68be596da96d8fbbbe6" translate="yes" xml:space="preserve">
          <source>The startup code initializes the &lt;code&gt;RAMP&lt;/code&gt; special function registers with zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0593142bdd3bdb84b9aebea225043f72be034cf" translate="yes" xml:space="preserve">
          <source>The storage for an object of thread storage duration shall be statically initialized before the first statement of the thread startup function. An object of thread storage duration shall not require dynamic initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4b780083ada416a6c378ae8867cc1c7fb0b433" translate="yes" xml:space="preserve">
          <source>The structure has size zero. In C++, empty structures are part of the language. G++ treats empty structures as if they had a single member of type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2ecce652896fa952e1019513fab67001397b36" translate="yes" xml:space="preserve">
          <source>The subtype of the file created (like &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6a165fe3653c2eaa19af3a9cacad8cee1b0aa0" translate="yes" xml:space="preserve">
          <source>The switch matching text &lt;code&gt;S&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2591c1475ef50f2d7871f5727f318ca9819d88ef" translate="yes" xml:space="preserve">
          <source>The syntax for this extension is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c37c4e36af6f9d7c15727a683845a9a4d1ae812e" translate="yes" xml:space="preserve">
          <source>The synthetic compare types&amp;ndash;gt, lt, ge, and le.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0ec84c43a433725bea4939d7d6aa41982b5bb6" translate="yes" xml:space="preserve">
          <source>The system will help save all registers into stack before entering interrupt handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b39e2e7f8f008a32869aef147d2dc6314988d7d" translate="yes" xml:space="preserve">
          <source>The system will help save caller registers into stack before entering interrupt handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebaa5c15171a87ae7a332bb49a3f32f19a3aad26" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2i16&lt;/code&gt; operation for which hardware support exists for the DSP ASE REV 2. &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; are &lt;code&gt;v2i16&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896165ef2a0dc9f91cdad7ea07b67fa41d120e44" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2sf&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are &lt;code&gt;v2sf&lt;/code&gt; values and &lt;code&gt;x&lt;/code&gt; is an integral value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b038d441c31fe7fb35f36ddaf2d9c7ea6b680b8" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v4i8&lt;/code&gt; and &lt;code&gt;v2q15&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;v4i8&lt;/code&gt; values, and &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are &lt;code&gt;v2q15&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f249ccb08815c6079cbd323b97a2c4ac2204382" translate="yes" xml:space="preserve">
          <source>The table below lists the supported extensions for each architecture. Architectures not mentioned do not support any extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73d22c03412d342b6a999932c3fa6fbeb3a35b8" translate="yes" xml:space="preserve">
          <source>The table below shows the list of supported modifiers and their effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15aee3d23ffff41850eb55f63ba2913dcc2593de" translate="yes" xml:space="preserve">
          <source>The target may also allow additional types in &lt;code&gt;format-arg&lt;/code&gt; attributes. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1eb5143cb3645d3e56fe87871163fa73c09f83" translate="yes" xml:space="preserve">
          <source>The target may also provide additional types of format checks. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b814fff953e9628f2b901dd62490d599d61582c" translate="yes" xml:space="preserve">
          <source>The the register class of registers that can be used to hold a sibcall call address. I.e., a caller-saved register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9067dbfe61d5583898a4c222466eaecdc743a7f" translate="yes" xml:space="preserve">
          <source>The third word specifies the source files for those structs for which the compiler should emit debug information. The values &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2caf56b0822fe7bc0594ac85f716ffb2f0188f" translate="yes" xml:space="preserve">
          <source>The thread that begins execution at the &lt;code&gt;main&lt;/code&gt; function is called the &lt;em&gt;main thread&lt;/em&gt;. It is implementation defined how functions beginning threads other than the main thread are designated or typed. A function so designated, as well as the &lt;code&gt;main&lt;/code&gt; function, is called a &lt;em&gt;thread startup function&lt;/em&gt;. It is implementation defined what happens if a thread startup function returns. It is implementation defined what happens to other threads when any thread calls &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44a5b130a3ceb5fe8f03b1aaa3178d1eeebc449" translate="yes" xml:space="preserve">
          <source>The three types of inlining behave similarly in two important cases: when the &lt;code&gt;inline&lt;/code&gt; keyword is used on a &lt;code&gt;static&lt;/code&gt; function, like the example above, and when a function is first declared without using the &lt;code&gt;inline&lt;/code&gt; keyword and then is defined with &lt;code&gt;inline&lt;/code&gt;, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603ab7e85053589e42da345836681d51d569791a" translate="yes" xml:space="preserve">
          <source>The threshold ratio for performing partial redundancy elimination after reload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423954d242ed49c029dc872280561e1e359efe72" translate="yes" xml:space="preserve">
          <source>The threshold ratio of critical edges execution count that permit performing redundancy elimination after reload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a881665cedd4653a3bb7d98fcef7595547272bb0" translate="yes" xml:space="preserve">
          <source>The total number of input + output + goto operands is limited to 30.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51a43aea88607f1a48139a383f2efbea483ea5b" translate="yes" xml:space="preserve">
          <source>The total size (in bytes) required to pass all the parameters. This includes the two hidden parameters (the object &lt;code&gt;self&lt;/code&gt; and the method selector &lt;code&gt;_cmd&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dea0413ee420eebb0c3352fcc9737b26d047ac" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a persistent failure. Re-execution under same circumstances will not be productive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7970397dce5e9b8e0cc50cc8d7046872a5452379" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a transient failure. The transaction should be re-executed in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885e4cc2a7b2481bfb38880d5bc544bde78ed78c" translate="yes" xml:space="preserve">
          <source>The transaction was aborted due to an indeterminate condition which might be persistent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed635303d722768beed9ca9a2d786f5922ad4e3" translate="yes" xml:space="preserve">
          <source>The two Scalar Reduction of Aggregates passes (SRA and IPA-SRA) aim to replace scalar parts of aggregates with uses of independent scalar variables. These parameters control the maximum size, in storage units, of aggregate which is considered for replacement when compiling for speed (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d922516e422c7b0576d05743cb3430b4c8056971" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;char&lt;/code&gt; is always a distinct type from each of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, even though its behavior is always just like one of those two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1531d2ff0ef2100fb6dbf78b0a6f5c969ddbe3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;int[]&lt;/code&gt; and &lt;code&gt;int[5]&lt;/code&gt; are compatible. On the other hand, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;char *&lt;/code&gt; are not compatible, even if the size of their types, on the particular architecture are the same. Also, the amount of pointer indirection is taken into account when determining similarity. Consequently, &lt;code&gt;short *&lt;/code&gt; is not similar to &lt;code&gt;short **&lt;/code&gt;. Furthermore, two types that are typedefed are considered compatible if their underlying types are compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f524b48e32ad47b9a83509e089c5a5e1558b871" translate="yes" xml:space="preserve">
          <source>The type of an object with thread storage duration shall not have a non-trivial destructor, nor shall it be an array type whose elements (directly or indirectly) have non-trivial destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90fc1cb110409689f90a0be940bc7d5911aa3a0" translate="yes" xml:space="preserve">
          <source>The type of these constants follows the same rules as for octal or hexadecimal integer constants, so suffixes like &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1c0747061b6e04e40c5232315c9ae3b95fbcea" translate="yes" xml:space="preserve">
          <source>The type specifiers are encoded just before the type. Unlike types however, the type specifiers are only encoded when they appear in method argument types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="235cfb0079f1cae5d7bcfb5a4109668420b1ba20" translate="yes" xml:space="preserve">
          <source>The types are encoded in the following way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29416c27e6f97b9abc061da191be4a6083d70bc" translate="yes" xml:space="preserve">
          <source>The types defined in this manner can be used with a subset of normal C operations. Currently, GCC allows using the following operators on these types: &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fa8117933503d7edf67d6eb175e6d2d580176b" translate="yes" xml:space="preserve">
          <source>The types of long calls used depends on the capabilities of the assembler and linker, and the type of code being generated. The impact on systems that support long absolute calls, and long pic symbol-difference or pc-relative calls should be relatively small. However, an indirect call is used on 32-bit ELF systems in pic code and it is quite long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5bc88005ecf61d67656c8a050fcb6e58f804f9" translate="yes" xml:space="preserve">
          <source>The types of the specified functions must all be different, but related to each other in the same way as a set of functions that may be selected between by a macro in &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;. This means that the functions are parameterized by a floating-point type &lt;var&gt;t&lt;/var&gt;, different for each such function. The function return types may all be the same type, or they may be &lt;var&gt;t&lt;/var&gt; for each function, or they may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function (if some of the types &lt;var&gt;t&lt;/var&gt; are complex). Likewise, for each parameter position, the type of the parameter in that position may always be the same type, or may be &lt;var&gt;t&lt;/var&gt; for each function (this case must apply for at least one parameter position), or may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="562884deec4ebf19cace230c1d8314c9d6fd11a3" translate="yes" xml:space="preserve">
          <source>The typical use of extended &lt;code&gt;asm&lt;/code&gt; statements is to manipulate input values to produce output values. However, your &lt;code&gt;asm&lt;/code&gt; statements may also produce side effects. If so, you may need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier to disable certain optimizations. See &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e652bb27a2083165bac75933fd850a0641a946" translate="yes" xml:space="preserve">
          <source>The unary plus operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b7b641512751385c6d2814d121dfa7956a428c3" translate="yes" xml:space="preserve">
          <source>The underlying type of &lt;code&gt;type&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be an enumeration type ([dcl.enum]).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9e93062c090121b29c563680d663f3d3e33b8a" translate="yes" xml:space="preserve">
          <source>The unique value of the member of the execution character set produced for each of the standard alphabetic escape sequences (C90, C99 and C11 5.2.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9148f286cc806482521d7ebb582ea948e1076d" translate="yes" xml:space="preserve">
          <source>The use of default arguments in function pointers, function typedefs and other places where they are not permitted by the standard is deprecated and will be removed from a future version of G++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0aac07569b8c035da4f2196d548847237b0a9f" translate="yes" xml:space="preserve">
          <source>The usual calling convention has functions return values of types &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; in an FPU register, even if there is no FPU. The idea is that the operating system should emulate an FPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7784f3ecb2fcf462bcebb606253d24e3e9713b" translate="yes" xml:space="preserve">
          <source>The usual way to run GCC is to run the executable called &lt;code&gt;gcc&lt;/code&gt;, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; when cross-compiling, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; to run a specific version of GCC. When you compile C++ programs, you should invoke GCC as &lt;code&gt;g++&lt;/code&gt; instead. See &lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;Compiling C++ Programs&lt;/a&gt;, for information about the differences in behavior between &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;g++&lt;/code&gt; when compiling C++ programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b063501b645eb4fe8a716599b0b7b68ac7473998" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc836f5cd3d793de6c86ebfa23594977254dab4" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b387c15b8d7905431f6ee70a72792d2b995cec6" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6608eaa83f451be81718292f24c656e5976df89" translate="yes" xml:space="preserve">
          <source>The value &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b81b1fa621fe4401621371ef2fb0416c4e7ec83" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;branch&lt;/code&gt; tells the compiler to implement checking of validity of control-flow transfer at the point of indirect branch instructions, i.e. call/jmp instructions. The value &lt;code&gt;return&lt;/code&gt; implements checking of validity at the point of returning from a function. The value &lt;code&gt;full&lt;/code&gt; is an alias for specifying both &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt;. The value &lt;code&gt;none&lt;/code&gt; turns off instrumentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec00d8fc6d0d865baf91db330b98c794be36fbd" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 0 (the default) or 4 means that constants of any size are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7289e160f23adf91cfa58505c60106049d9e55" translate="yes" xml:space="preserve">
          <source>The value is as specified in the standard and the type is determined by the ABI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da848852806dcfc33f52696b5619522d23c88e8e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;COMPILER_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. GCC tries the directories thus specified when searching for subprograms, if it cannot find the subprograms using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72005aff0d80d4d1734d968cb3fab8a6e254f4d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; can be just a file name, in which case the Make rules are written to that file, guessing the target name from the source file name. Or the value can have the form &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edab9250e0babd1761a6140212faa3d4e9be6f54" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;LIBRARY_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. When configured as a native compiler, GCC tries the directories thus specified when searching for special linker files, if it cannot find them using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;. Linking using GCC also uses these directories when searching for ordinary libraries for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d97475c2600c7120869f306bf4b7bed4d2e9bd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; must be a UNIX timestamp, defined as the number of seconds (excluding leap seconds) since 01 Jan 1970 00:00:00 represented in ASCII; identical to the output of &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e4ba46bd46984b6c4ee052416293525cc2110b" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;addr&lt;/var&gt; is the address of the memory to prefetch. There are two optional arguments, &lt;var&gt;rw&lt;/var&gt; and &lt;var&gt;locality&lt;/var&gt;. The value of &lt;var&gt;rw&lt;/var&gt; is a compile-time constant one or zero; one means that the prefetch is preparing for a write to the memory address and zero, the default, means that the prefetch is preparing for a read. The value &lt;var&gt;locality&lt;/var&gt; must be a compile-time constant integer between zero and three. A value of zero means that the data has no temporal locality, so it need not be left in the cache after the access. A value of three means that the data has a high degree of temporal locality and should be left in all levels of cache possible. Values of one and two mean, respectively, a low or moderate degree of temporal locality. The default is three.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e11268aef227bb1a15172e67ca65858facec52" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;arguments&lt;/var&gt; should be the value returned by &lt;code&gt;__builtin_apply_args&lt;/code&gt;. The argument &lt;var&gt;size&lt;/var&gt; specifies the size of the stack argument data, in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97b2ef46aa7ac364dbf54d200c4936fb0a11aa0" translate="yes" xml:space="preserve">
          <source>The value of a &lt;code&gt;char&lt;/code&gt; object into which has been stored any character other than a member of the basic execution character set (C90 6.1.2.5, C99 and C11 6.2.5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90677fad3803708fba68301854948c65ad2e0dc" translate="yes" xml:space="preserve">
          <source>The value of a string literal containing a multibyte character or escape sequence not represented in the execution character set (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0799bf13992e78d42dd3b2499d660140de9cd663" translate="yes" xml:space="preserve">
          <source>The value of a wide character constant containing more than one multibyte character or a single multibyte character that maps to multiple members of the extended execution character set, or containing a multibyte character or escape sequence not represented in the extended execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de23bcdd7f53de07c13a72f7ab5e75f0f064b9a" translate="yes" xml:space="preserve">
          <source>The value of an integer character constant containing more than one character or containing a character or escape sequence that does not map to a single-byte execution character (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bddf51b03e8582ac60e5e332485e2f5dfdaadff5" translate="yes" xml:space="preserve">
          <source>The value of the result of the &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;_Alignof&lt;/code&gt; operators (C90 6.3.3.4, C99 and C11 6.5.3.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b2873e2d72ded9fcc9fee52452da75fb562815" translate="yes" xml:space="preserve">
          <source>The value should be a known timestamp such as the last modification time of the source or package and it should be set by the build process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30741bdd1a5b46b18e6720866027b16cbef67a9" translate="yes" xml:space="preserve">
          <source>The values &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0725ef659b65323c744f64d2a18ca8ec4185c000" translate="yes" xml:space="preserve">
          <source>The values of the members of the execution character set (C90, C99 and C11 5.2.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50dd57103792a97d47d46235c3239eae04dabde" translate="yes" xml:space="preserve">
          <source>The values or expressions assigned to the macros specified in the headers &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; (C90, C99 and C11 5.2.4.2, C99 7.18.2, C99 7.18.3, C11 7.20.2, C11 7.20.3).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24e1e6a031d69e73f1ce7f443d81ca980894830" translate="yes" xml:space="preserve">
          <source>The vector type associated with paired-single values is usually called &lt;code&gt;v2sf&lt;/code&gt;. It can be defined in C as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fd6ea52bde5e4eca142e1cb75092f72771ffd7" translate="yes" xml:space="preserve">
          <source>The virtual registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d4e21a353ad4b2c91fcbc017d8cd072d1cc8a4" translate="yes" xml:space="preserve">
          <source>The visibility attribute should be applied only to declarations that would otherwise have external linkage. The attribute should be applied consistently, so that the same entity should not be declared with different settings of the attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdff986b782b656015cb9e4191209d1fd6e3439" translate="yes" xml:space="preserve">
          <source>The warning is not issued after a &lt;code&gt;#line&lt;/code&gt; directive, since this typically indicates autogenerated code, and no assumptions can be made about the layout of the file that the directive references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d163df4c56e51212f1f69dc140213a05352c42" translate="yes" xml:space="preserve">
          <source>The warning is not issued for code involving multiline preprocessor logic such as the following example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb7b8cd90065f04f3725df949fc5d9c95db8632" translate="yes" xml:space="preserve">
          <source>The warning message for each controllable warning includes the option that controls the warning. That option can then be used with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f31ebd493031aa0be9fb191d41eda3a3e18dd4" translate="yes" xml:space="preserve">
          <source>The warnings for missing or incorrect sentinels are enabled with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb1f41a4e1e0161c8bf4c849af0ffb5ebafd481" translate="yes" xml:space="preserve">
          <source>The way to solve these problems is to put &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206a81db22964ace6231b75566fe4c7da1707abe" translate="yes" xml:space="preserve">
          <source>The workarounds for the division errata rely on special functions in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ecc69e9abd77cc6ec0f76d76bb1dccaddb7e950" translate="yes" xml:space="preserve">
          <source>The x86 architecture supports additional memory ordering flags to mark critical sections for hardware lock elision. These must be specified in addition to an existing memory order to atomic intrinsics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94474d9a2fee2945e274919425bc2dedd2ef21c" translate="yes" xml:space="preserve">
          <source>The x86-32 and x86-64 family of processors use additional built-in functions for efficient use of &lt;code&gt;TF&lt;/code&gt; (&lt;code&gt;__float128&lt;/code&gt;) 128-bit floating point and &lt;code&gt;TC&lt;/code&gt; 128-bit complex floating-point values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02b4be795b4b009422772986429301880a6ca1d" translate="yes" xml:space="preserve">
          <source>Then use the &lt;code&gt;create_gcov&lt;/code&gt; tool to convert the raw profile data to a format that can be used by GCC. You must also supply the unstripped binary for your program to this tool. See &lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;https://github.com/google/autofdo&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926b284ef06d8680215f804da3458309f6cd9668" translate="yes" xml:space="preserve">
          <source>Then you can select a label with indexing, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea728bf3b20beeae36b33c3b1a8dc7982befc50" translate="yes" xml:space="preserve">
          <source>There are 6 different memory orders that can be specified. These map to the C++11 memory orders with the same names, see the C++11 standard or the &lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;GCC wiki on atomic synchronization&lt;/a&gt; for detailed definitions. Individual targets may also support additional memory orders for use on specific architectures. Refer to the target documentation for details of these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f6ba3037fb7689eee8ed8968fd8f0d8ac13840" translate="yes" xml:space="preserve">
          <source>There are also GNU extension functions &lt;code&gt;clog10&lt;/code&gt;, &lt;code&gt;clog10f&lt;/code&gt; and &lt;code&gt;clog10l&lt;/code&gt; which names are reserved by ISO C99 for future use. All these functions have versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875ce1195c45f2b46d9a99c39e44fd3ec9b5e9cf" translate="yes" xml:space="preserve">
          <source>There are also built-in functions &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, corresponding to the TS 18661-3 functions &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, for supported types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10087f06f9970243ffcf86e55d1829b3627290b7" translate="yes" xml:space="preserve">
          <source>There are also built-in versions of the ISO C99 functions &lt;code&gt;acosf&lt;/code&gt;, &lt;code&gt;acosl&lt;/code&gt;, &lt;code&gt;asinf&lt;/code&gt;, &lt;code&gt;asinl&lt;/code&gt;, &lt;code&gt;atan2f&lt;/code&gt;, &lt;code&gt;atan2l&lt;/code&gt;, &lt;code&gt;atanf&lt;/code&gt;, &lt;code&gt;atanl&lt;/code&gt;, &lt;code&gt;ceilf&lt;/code&gt;, &lt;code&gt;ceill&lt;/code&gt;, &lt;code&gt;cosf&lt;/code&gt;, &lt;code&gt;coshf&lt;/code&gt;, &lt;code&gt;coshl&lt;/code&gt;, &lt;code&gt;cosl&lt;/code&gt;, &lt;code&gt;expf&lt;/code&gt;, &lt;code&gt;expl&lt;/code&gt;, &lt;code&gt;fabsf&lt;/code&gt;, &lt;code&gt;fabsl&lt;/code&gt;, &lt;code&gt;floorf&lt;/code&gt;, &lt;code&gt;floorl&lt;/code&gt;, &lt;code&gt;fmodf&lt;/code&gt;, &lt;code&gt;fmodl&lt;/code&gt;, &lt;code&gt;frexpf&lt;/code&gt;, &lt;code&gt;frexpl&lt;/code&gt;, &lt;code&gt;ldexpf&lt;/code&gt;, &lt;code&gt;ldexpl&lt;/code&gt;, &lt;code&gt;log10f&lt;/code&gt;, &lt;code&gt;log10l&lt;/code&gt;, &lt;code&gt;logf&lt;/code&gt;, &lt;code&gt;logl&lt;/code&gt;, &lt;code&gt;modfl&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;powf&lt;/code&gt;, &lt;code&gt;powl&lt;/code&gt;, &lt;code&gt;sinf&lt;/code&gt;, &lt;code&gt;sinhf&lt;/code&gt;, &lt;code&gt;sinhl&lt;/code&gt;, &lt;code&gt;sinl&lt;/code&gt;, &lt;code&gt;sqrtf&lt;/code&gt;, &lt;code&gt;sqrtl&lt;/code&gt;, &lt;code&gt;tanf&lt;/code&gt;, &lt;code&gt;tanhf&lt;/code&gt;, &lt;code&gt;tanhl&lt;/code&gt; and &lt;code&gt;tanl&lt;/code&gt; that are recognized in any mode since ISO C90 reserves these names for the purpose to which ISO C99 puts them. All these functions have corresponding versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32bac703972f0098c171900bd4cc85df014dde5" translate="yes" xml:space="preserve">
          <source>There are also checking built-in functions for formatted output functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8ad06fe6014524cc57bfacf331d94eea076d2f" translate="yes" xml:space="preserve">
          <source>There are built-in functions added for many common string operation functions, e.g., for &lt;code&gt;memcpy&lt;/code&gt;&lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; built-in is provided. This built-in has an additional last argument, which is the number of bytes remaining in the object the &lt;var&gt;dest&lt;/var&gt; argument points to or &lt;code&gt;(size_t) -1&lt;/code&gt; if the size is not known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ecb3f393a336df7fd790409c78fca65366bb71" translate="yes" xml:space="preserve">
          <source>There are four levels of warning supported by GCC. The default is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c6335a792caea07ef43ebcfd0dbedc3bba84b4" translate="yes" xml:space="preserve">
          <source>There are four supported &lt;var&gt;visibility_type&lt;/var&gt; values: default, hidden, protected or internal visibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8ba713c06a7d9c57fd70b516918aacdd01bbce" translate="yes" xml:space="preserve">
          <source>There are many more AVR-specific built-in functions that are used to implement the ISO/IEC TR 18037 &amp;ldquo;Embedded C&amp;rdquo; fixed-point functions of section 7.18a.6. You don&amp;rsquo;t need to use these built-ins directly. Instead, use the declarations as supplied by the &lt;code&gt;stdfix.h&lt;/code&gt; header with GNU-C99:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e7d52ba0a431ff758889d5327a13ddffa9df26" translate="yes" xml:space="preserve">
          <source>There are many other possibilities, limited only by your imagination, good sense, and the constraints of your build system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ef48c0fb35d807a55378bf489805cb806add15" translate="yes" xml:space="preserve">
          <source>There are other differences between these two methods. Space allocated with &lt;code&gt;alloca&lt;/code&gt; exists until the containing &lt;em&gt;function&lt;/em&gt; returns. The space for a variable-length array is deallocated as soon as the array name&amp;rsquo;s scope ends, unless you also use &lt;code&gt;alloca&lt;/code&gt; in this scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4c204c6335b8fb2d87ba86456a428609cad26b" translate="yes" xml:space="preserve">
          <source>There are several caveats to using the new exception mechanism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35ba4e6fe38d832f24909aadf0cb677e0066a30" translate="yes" xml:space="preserve">
          <source>There are several constructs in C++ that require space in the object file but are not clearly tied to a single translation unit. We say that these constructs have &amp;ldquo;vague linkage&amp;rdquo;. Typically such constructs are emitted wherever they are needed, though sometimes we can be more clever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973e35674df499ab71700555edbe1a93e1641ce5" translate="yes" xml:space="preserve">
          <source>There are several noteworthy incompatibilities between GNU C and K&amp;amp;R (non-ISO) versions of C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f04da83ffcbe77658a4a2fadeea31bbf52a4d35" translate="yes" xml:space="preserve">
          <source>There are several situations in which an application should use the shared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7959f13cb983e884f2106a8d8e6aa988bd66a9f9" translate="yes" xml:space="preserve">
          <source>There are some arguments for making bit-fields unsigned by default on all machines. If, for example, this becomes a universal de facto standard, it would make sense for GCC to go along with it. This is something to be considered in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451c9c37af0f9094bf98f147452ec7b2c1e8a8be" translate="yes" xml:space="preserve">
          <source>There are some code generation flags preserved by GCC when generating bytecodes, as they need to be used during the final link. Currently, the following options and their settings are taken from the first object file that explicitly specifies them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d537bfaa9f6c3001fc1a88f5b799ca08bd61a582" translate="yes" xml:space="preserve">
          <source>There are some constraints on how this can be used&amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136389e963628b14cbedd792ceed996572d52240" translate="yes" xml:space="preserve">
          <source>There are some problems with the semantics of attributes in C++. For example, there are no manglings for attributes, although they may affect code generation, so problems may arise when attributed types are used in conjunction with templates or overloading. Similarly, &lt;code&gt;typeid&lt;/code&gt; does not distinguish between types with different attributes. Support for attributes in C++ may be restricted in future to attributes on declarations only, but not on nested declarators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a43a1a2abc532264a4772bfd3acfd532a1ab60" translate="yes" xml:space="preserve">
          <source>There are two ways of writing the argument to &lt;code&gt;typeof&lt;/code&gt;: with an expression or with a type. Here is an example with an expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc25dda9b9f38426b4a5c6b4195fea59e37ab096" translate="yes" xml:space="preserve">
          <source>There is a new runtime function &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; which can be used to declare a so-called &lt;em&gt;weak pointer&lt;/em&gt; reference. Such a pointer is basically hidden for the garbage collector; this can be useful in certain situations, especially when you want to keep track of the allocated objects, yet allow them to be collected. This kind of pointers can only be members of objects, you cannot declare a global pointer as a weak reference. Every type which is a pointer type can be declared a weak pointer, including &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;SEL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6782eab9d50f7c071e99f8fc866abd4eb5cd6fa7" translate="yes" xml:space="preserve">
          <source>There is a proposed representation for view numbers that is not backward compatible with the location list format introduced in DWARF 5, that can be enabled with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b7356a3e71c6ac7b87a32d1d5d861dca74d15e" translate="yes" xml:space="preserve">
          <source>There is no formal written standard for Objective-C or Objective-C++. The authoritative manual on traditional Objective-C (1.0) is &amp;ldquo;Object-Oriented Programming and the Objective-C Language&amp;rdquo;: &lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&lt;/a&gt; is the original NeXTstep document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533538e5f5aef48cf028f3ce488b08d6002276fb" translate="yes" xml:space="preserve">
          <source>There is no guarantee (in either the C or the C++ standard language definitions) that the increments will be evaluated in any particular order. Either increment might happen first. &lt;code&gt;func&lt;/code&gt; might get the arguments &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734d8f3426c5c4d551e49ff2012c542f74ef1c08" translate="yes" xml:space="preserve">
          <source>There is no guarantee any transaction ever succeeds, so there always needs to be a valid fallback path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df09188c09c71974483614543b07ff3dea71c626" translate="yes" xml:space="preserve">
          <source>There is no support for nesting dialect alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7415b415266f5ddf918da08e3399f543c97fb7d5" translate="yes" xml:space="preserve">
          <source>There is no way to split up the contents of a single header file into multiple implementation files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35fa3005d504f47c5b76912e05a2d94970ddd97" translate="yes" xml:space="preserve">
          <source>There is no way within the template to determine which alternative was chosen. However you may be able to wrap your &lt;code&gt;asm&lt;/code&gt; statements with builtins such as &lt;code&gt;__builtin_constant_p&lt;/code&gt; to achieve the desired results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8b54db3c2d81811451aec9ad4c249cf9c17c8b" translate="yes" xml:space="preserve">
          <source>There is some overlap between the purposes of attributes and pragmas (see &lt;a href=&quot;pragmas#Pragmas&quot;&gt;Pragmas Accepted by GCC&lt;/a&gt;). It has been found convenient to use &lt;code&gt;__attribute__&lt;/code&gt; to achieve a natural attachment of attributes to their corresponding declarations, whereas &lt;code&gt;#pragma&lt;/code&gt; is of use for compatibility with other compilers or constructs that do not naturally form part of the grammar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07be20761a89905e90146c4650de03345401fe54" translate="yes" xml:space="preserve">
          <source>There may be pitfalls when you use &lt;code&gt;long long&lt;/code&gt; types for function arguments without function prototypes. If a function expects type &lt;code&gt;int&lt;/code&gt; for its argument, and you pass a value of type &lt;code&gt;long long int&lt;/code&gt;, confusion results because the caller and the subroutine disagree about the number of bytes for the argument. Likewise, if the function expects &lt;code&gt;long long int&lt;/code&gt; and you pass &lt;code&gt;int&lt;/code&gt;. The best way to avoid such problems is to use prototypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9628a707838f509cf0a37ebb92916da132e1d6" translate="yes" xml:space="preserve">
          <source>Therefore, the G++ driver automatically adds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47997e2980ed03d4553af1541dc131cfa6cb91bc" translate="yes" xml:space="preserve">
          <source>Therefore, the expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea5dc6096c9bd173073ecde828a55eabd5d76e4" translate="yes" xml:space="preserve">
          <source>These</source>
          <target state="translated">These</target>
        </trans-unit>
        <trans-unit id="322fe3b4715f9524d383adeb084e8533651edeb7" translate="yes" xml:space="preserve">
          <source>These &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc6fb4722bc714d5fae1673f7398b196f782701" translate="yes" xml:space="preserve">
          <source>These additional &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dea8e42e0ac78d81c1030a34ffa5859fb43e5e8" translate="yes" xml:space="preserve">
          <source>These additional options are available for Microsoft Windows targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429200a04514f92caf3b4499a491ca222d5caed0" translate="yes" xml:space="preserve">
          <source>These additional options are available on System V Release 4 for compatibility with other compilers on those systems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee4beda520b02d216d51ad833fd44f1904ba2f8" translate="yes" xml:space="preserve">
          <source>These are 16-bit address spaces locating data in section &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; where &lt;var&gt;N&lt;/var&gt; refers to address space &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt;. The compiler sets the &lt;code&gt;RAMPZ&lt;/code&gt; segment register appropriately before reading data by means of the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc1925e612ca94ca27a8264a7444be5df20595d" translate="yes" xml:space="preserve">
          <source>These are aliases for the corresponding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779c6f17661e07ac4152f7dc676778ae7628f8f4" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS/6000 and PowerPC Options&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae931926b0b87957b809699bfe98630faaab5aad" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;S/390 and zSeries Options&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40acc5623309fbea5623f2aba009e341f97fe7cb" translate="yes" xml:space="preserve">
          <source>These are the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a9625ab38cfd983e37ec2df20ad8c1cd341393" translate="yes" xml:space="preserve">
          <source>These are the options defined for the Altera Nios II processor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddfdc15ea502fdc771fd53ee7ee413d91e5a491a" translate="yes" xml:space="preserve">
          <source>These are the supported qualifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea04fd9aefe63e6f009323195856f23e96723b58" translate="yes" xml:space="preserve">
          <source>These attributes are the same as the MSP430 function attributes of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;). These attributes can be applied to both functions and variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9f0c12140351e3fedd51dae4c1164e0be835e5" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90cae17a8377f793b8674b8db0decc44a0b2b0db" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. Use the &lt;code&gt;fast_interrupt&lt;/code&gt; attribute to indicate handlers used in low-latency interrupt mode, and &lt;code&gt;interrupt_handler&lt;/code&gt; for interrupts that do not use low-latency handlers. In both cases, GCC emits appropriate prologue code and generates a return from the handler using &lt;code&gt;rtid&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f83b1fb8a50c976a446dd169ccf0caf9284a311" translate="yes" xml:space="preserve">
          <source>These attributes override the default chosen by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af47925da5d7dad5e220bfdf28a73cd1e09ade04" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called on MIPS. The attributes override the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c245dc24a2c3a655d76f63a05d461d62dfaa1098" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called. These attributes override the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2db2e0a6cd3c160ce892077b566038f69a5d12" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the AArch64 family of processors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ee134b7e3302b89897afcdd306492cac3af896" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors when the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c021905865fa6d163412cd97d22f339e716b63" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors with floating-point unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48306035fd811f8d35a44f11213546ba486a0570" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Alpha family of processors, depending on the command-line switches used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3ba21ab5439a452d301344eaf50af645d462ac" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Altera Nios II family of processors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f6765d03c89956e564760cefe25b8258f2acc4" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the NDS32 target:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fccae182b2f224cc802c582d293665235932f6e" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the x86-32 and x86-64 family of computers, depending on the command-line switches used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fa1603a77cd22b8b03844382316cb7fce3f487" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to &lt;code&gt;__builtin_add_overflow&lt;/code&gt;, &lt;code&gt;__builtin_sub_overflow&lt;/code&gt;, or &lt;code&gt;__builtin_mul_overflow&lt;/code&gt;, except that they don&amp;rsquo;t store the result of the arithmetic operation anywhere and the last argument is not a pointer, but some expression with integral type other than enumerated or boolean type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49cc0a5435c96c360dc8a007e08ab18d83b226a2" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform multiplication, instead of addition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60566210b0678cb1c3591a4a16d4062b4b5565ab" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform subtraction, subtract the second argument from the first one, instead of addition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2854f4ac5cfaad00730f8aa21e163c5b047dff2" translate="yes" xml:space="preserve">
          <source>These built-in functions map to the respective machine instruction, i.e. &lt;code&gt;nop&lt;/code&gt;, &lt;code&gt;sei&lt;/code&gt;, &lt;code&gt;cli&lt;/code&gt;, &lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;wdr&lt;/code&gt;, &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fmul&lt;/code&gt;, &lt;code&gt;fmuls&lt;/code&gt; resp. &lt;code&gt;fmulsu&lt;/code&gt;. The three &lt;code&gt;fmul*&lt;/code&gt; built-ins are implemented as library call if no hardware multiplier is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b498367f60152015d5067b4b4501b71daee8b167" translate="yes" xml:space="preserve">
          <source>These built-in functions perform an atomic compare and swap. That is, if the current value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is &lt;var&gt;oldval&lt;/var&gt;, then write &lt;var&gt;newval&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457d48795ac8a304362adc0940095ddd5561f409" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the new value. That is, operations on integer operands have the following semantics. Operations on pointer operands are performed as if the operand&amp;rsquo;s type were &lt;code&gt;uintptr_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4af2a3302ed8abb6fe6e394796ceea4bd21df1d" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the result of the operation. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ddce6ba857523eabbfd2cdfa6462c8733df6a0" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the value that had previously been in &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9da03d00f1fd8e4ece7f58ac8080d895ff5310" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and returns the value that had previously been in memory. That is, operations on integer operands have the following semantics. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55de8240dbd3fc7547da89964b220023f7b63ac6" translate="yes" xml:space="preserve">
          <source>These built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type the third pointer argument points to and stored there. If the stored result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. As the addition is performed in infinite signed precision, these built-in functions have fully defined behavior for all argument values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272a12ae7cc5710c521265d94a65c2d1952b524a" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RISC-V targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde559b30a769153d7e8ca70dcc17ecf58e436b4" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RX targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a802ea6adfbbd5a44e165efe9f9442f0fe2c45" translate="yes" xml:space="preserve">
          <source>These considerations mean that it is probably a bad idea to use statement expressions of this form in header files that are designed to work with C++. (Note that some versions of the GNU C Library contained header files using statement expressions that lead to precisely this bug.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb762532560d78d44fe7f3daaea45c8583b0854" translate="yes" xml:space="preserve">
          <source>These constraints are represented as multiple alternatives. An alternative can be described by a series of letters for each operand. The overall constraint for an operand is made from the letters for this operand from the first alternative, a comma, the letters for this operand from the second alternative, a comma, and so on until the last alternative. All operands for a single instruction must have the same number of alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38cef76099a34e5010638d4a8b6cdd6e8c967f30" translate="yes" xml:space="preserve">
          <source>These dumps are defined but always produce empty files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee9b2ccc9b3a342087894f7b0b9e01286328c92" translate="yes" xml:space="preserve">
          <source>These environment variables control the way that GCC uses localization information which allows GCC to work with different national conventions. GCC inspects the locale categories &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; if it has been configured to do so. These locale categories can be set to any value supported by your installation. A typical value is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a489f50971ce1280d886918f48a3bb50c7a159d8" translate="yes" xml:space="preserve">
          <source>These extensions are also available as built-in functions: see &lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;x86 Built-in Functions&lt;/a&gt;, for details of the functions enabled and disabled by these switches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d27c12c180a98e05723ed39f8b22c27ed9edb1c" translate="yes" xml:space="preserve">
          <source>These extensions are available in C and Objective-C. Most of them are also available in C++. See &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;, for extensions that apply &lt;em&gt;only&lt;/em&gt; to C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543b06dcdf13923e1595eba210fefb04ac8d69e6" translate="yes" xml:space="preserve">
          <source>These function attributes are available for H8/300 targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd06787a8c3016d0f2f433589a9910af31152c9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AMD GCN back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d4d22755862f6885158e789fb6bd235507e320" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the ARC back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c618a070b2ba6452534765be65dfbcbd06c924" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AVR back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4000ac271516da07336a51da8c25e0b8f6d448c0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Blackfin back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4afa11f7ee30e42598bbee2d62763ae6434a6f20" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the C-SKY back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b39cd5a4dc8327b896c51c9d022f5933b3f9958" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the CR16 back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec1909818ce8c44d18b66d9f611b39270c8c989" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Epiphany back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8d3405ae11a67438cd3ed6cb92d4bcf36611d0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32C back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d47de44c955eeba7615b17fd0bd7f27454a04ff3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32R/D back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7b01cf6c9218a3fa99b80d586881bd94ea12ed" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MCORE back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226e80259699476cba4da72f29c0d2be0439d85d" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MIPS back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7edfb198d558bea136b268d07a4ee17096f4b111" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MSP430 back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7afb37f2786a0500cde5b0e77a1405ec0aa689e9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MeP back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823340689a226c514215ae7cf6199d5c7033ae04" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the NDS32 back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7264e105fd00f62eb30200660903a8276158683f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nios II back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d367738aef5894acaadafa553c801d1b43d3e9d3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nvidia PTX back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8128fd2ec01bae5154b0679102e4367fb3f53fc5" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the PowerPC back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923f5bd26a54897b08d5acdad9b09a52e975ce30" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RISC-V back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e5203aed5d0b18481b945b5507d949e4d7c31f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RL78 back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4c53e48bbca37bc1541d4a60d57426dc8a00e7" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RX back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ce9850ed4dcd80e265a07962ae081b178c8abb" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the SPU back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ade06aab9acf44e5ce57399ee7881faa6de0a6" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Visium back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae2ef0b2bdfca9b1c67e94cbe7badc64e01b063f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Xstormy16 back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b7833e42af4f0fe80d613be09a87490ccd7b43" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the m68k back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7ac1f444547a0c0a07d6dfab0c75fe5199553c" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the x86 back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5189be0ccd445175d7b77e932fb4808ff6d615fa" translate="yes" xml:space="preserve">
          <source>These function attributes are supported for ARM targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd6ef1a2308a92983d4f92536fdde005890291f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on IA-64 targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64b227810fa6c9b50983f03140d568f7d9fed74" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on MicroBlaze targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9585f4effc5a2f8970b020be9771782ca105dbb1" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the S/390:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18888f95dfd62b9fe90e4d6af61fe2ecdcb6ad4f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the SH family of processors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98428d8e4eba9c792163f590881b9a318e73170e" translate="yes" xml:space="preserve">
          <source>These functions are implemented in terms of the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d57779f821090bd738e90d984c08a5bc5b3499b" translate="yes" xml:space="preserve">
          <source>These functions are intended to replace the legacy &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad90f9504c295e2f97ffc9946ebca4f6b5d5ccf1" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c7a748fe1ee1ae1b17cfc9b1186d6994642291" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if either result is &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if both results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c195ff99103a21f524d4637aac5069ea8a395ea9" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c037085992dbec65501906e5e93cf40d6de82a" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; and return the result as a boolean value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e664732594a1533360445b60577eaf62e517fa5e" translate="yes" xml:space="preserve">
          <source>These functions may be used to get information about the callers of a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dfc3d7d206adff68ce67f88a57319430a6ab850" translate="yes" xml:space="preserve">
          <source>These functions use &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; to compare &lt;var&gt;a&lt;/var&gt; with &lt;var&gt;b&lt;/var&gt; and to compare &lt;var&gt;c&lt;/var&gt; with &lt;var&gt;d&lt;/var&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if any of the four results are &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if all four results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f3cb76d903b1b5ffde931b05d3fa75fc2f5327" translate="yes" xml:space="preserve">
          <source>These hardware transactional memory intrinsics for x86 allow you to use memory transactions with RTM (Restricted Transactional Memory). This support is enabled with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8547b042f5482e49423b8a94ba89797760897f" translate="yes" xml:space="preserve">
          <source>These identifiers are variables, not preprocessor macros, and may not be used to initialize &lt;code&gt;char&lt;/code&gt; arrays or be concatenated with string literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ada7b6e3845c0a5e68e19752115e91ad7e714e" translate="yes" xml:space="preserve">
          <source>These issues were corrected in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9701e15c9d94aa04294acbc1a1a03ddc6872e2" translate="yes" xml:space="preserve">
          <source>These machine-independent options control the interface conventions used in code generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1408af6170149b7254d4dd6bcdcfd495ec7436ce" translate="yes" xml:space="preserve">
          <source>These mangling issues were fixed in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b49ceeb21cede5a3a2711e37a7de019bfde35f" translate="yes" xml:space="preserve">
          <source>These memory models are formally defined in Appendix D of the SPARC-V9 architecture manual, as set in the processor&amp;rsquo;s &lt;code&gt;PSTATE.MM&lt;/code&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c28027a49e0f9f937405f5f5d9848e5c4e1880" translate="yes" xml:space="preserve">
          <source>These modifiers generate this assembler code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743e02542ccafa4975400ec872a7ad2395932b78" translate="yes" xml:space="preserve">
          <source>These options (&amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4958c6c5d677addc8f58eab0c0d2cf3562ddc1ad" translate="yes" xml:space="preserve">
          <source>These options are defined for AArch64 implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d92fc742af2bfa615c74329a584a34db9bd186" translate="yes" xml:space="preserve">
          <source>These options are defined for AVR implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e06ccfcce04ef8518c59faf9fdd99422ee95ce" translate="yes" xml:space="preserve">
          <source>These options are defined for NDS32 implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d910c773d7a92c5968f91520cb1c96e846ae694" translate="yes" xml:space="preserve">
          <source>These options are defined for Nvidia PTX:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a11512edb73659010487af7574c61b869ed8dd" translate="yes" xml:space="preserve">
          <source>These options are defined for OpenRISC:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c280d854c3b143f60be7e0eaa4e7170900086fe5" translate="yes" xml:space="preserve">
          <source>These options are defined for Score implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb4c45c0c5f292728f019e5710497a0ec8817f3" translate="yes" xml:space="preserve">
          <source>These options are defined for Xstormy16:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b09b81649730921d2e9ab3de0a2c88ec62a4975" translate="yes" xml:space="preserve">
          <source>These options are defined for all architectures running the Darwin operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb3b867f983940ea2e4ebd67efa329a40f483ce" translate="yes" xml:space="preserve">
          <source>These options are defined for the MMIX:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385fe3117f02cef23e8d723690c0cfc308b93e2c" translate="yes" xml:space="preserve">
          <source>These options are defined for the MSP430:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adcca40803ff77f8885d53e3bb9902253e5f5f3e" translate="yes" xml:space="preserve">
          <source>These options are defined for the PDP-11:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bfa23d8fe1cfc039288a92db83209397de4a2aa" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the AMD GCN port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c86a5f185d6c276d710a46803063b57baac6b5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CR16 ports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbab2a1744111610f4ef1fc49ca09af76e7d1a32" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CRIS ports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9926932fa2a7f92eb437e1b2ac02cd6adfeca6d5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FR30 port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dab4ff68a4f656f1c031b134a3ea5a7f3fcf21b" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FT32 port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c959329e4528f6f7066c03da92ac9a3ae209b8" translate="yes" xml:space="preserve">
          <source>These options are passed down to the linker. They are defined for compatibility with Diab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514cb6ef588bccc0cfd12c2a6ee53c62e3980343" translate="yes" xml:space="preserve">
          <source>These options are passed to the Darwin linker. The Darwin linker man page describes them in detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="921e998e0a7514666b6cd58d10b556dced0e17ae" translate="yes" xml:space="preserve">
          <source>These options are similar to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c15cb110a025cb053a49b0cc23a8ae49630d084e" translate="yes" xml:space="preserve">
          <source>These options are supported for Xtensa targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024672ba12f6533c6267ee5ffbe7b18b0036fae5" translate="yes" xml:space="preserve">
          <source>These options come into play when the compiler links object files into an executable output file. They are meaningless if the compiler is not doing a link step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4133c0873f5f47fa3d2f753863bb9a83e1789d05" translate="yes" xml:space="preserve">
          <source>These options control the C preprocessor, which is run on each C source file before actual compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef76ab842e5d74de09c81a688676470bc03ede7" translate="yes" xml:space="preserve">
          <source>These options control the encoding of the special not-a-number (NaN) IEEE 754 floating-point data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d05ca58952f18a481361248697cafe54bd4e24" translate="yes" xml:space="preserve">
          <source>These options control the treatment of literal pools. The default is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f8686ec125e23f83695f3f62c70b1f7e4905ad" translate="yes" xml:space="preserve">
          <source>These options control the treatment of the special not-a-number (NaN) IEEE 754 floating-point data with the &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; machine instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe30970c8506c0b34e204983d37e0e48b0b22605" translate="yes" xml:space="preserve">
          <source>These options control various sorts of optimizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8077ddc9c44325d74d2e32e67e952882010bc964" translate="yes" xml:space="preserve">
          <source>These options control whether a bit-field is signed or unsigned, when the declaration does not use either &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;. By default, such a bit-field is signed, because this is consistent: the basic integer types such as &lt;code&gt;int&lt;/code&gt; are signed types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04984b17ce3993112173c90b978bdade9a561d21" translate="yes" xml:space="preserve">
          <source>These options control which form of branches will be generated. The default is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75acf55e945580c3df0ebbfbfe506d046bc6e85c" translate="yes" xml:space="preserve">
          <source>These options enable GCC to use these extended instructions in generated code, even without</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fd9ac7bed816cccc6942a8d8998c84e682fcba" translate="yes" xml:space="preserve">
          <source>These options enable dumping after five rounds of instruction splitting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b2a58223d63058f35e9cfc3fe268fbe52e4e8c" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position independent code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d11fb15204ab5a9c7be14b9ed2aaeffe527ddd6" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position-independent code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e82c10f4ef0470986d8f101c75c3deb8c3bb8b" translate="yes" xml:space="preserve">
          <source>These options specify directories to search for header files, for libraries and for parts of the compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76a02704dc0e3839f8323b052aabfba6ae282f0" translate="yes" xml:space="preserve">
          <source>These options tell the compiler where to place functions and data that do not have one of the &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;section&lt;/code&gt; attributes. Possible values are &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;any&lt;/code&gt;. The first three behave like the corresponding attribute. The fourth possible value - &lt;code&gt;any&lt;/code&gt; - is the default. It leaves placement entirely up to the linker script and how it assigns the standard sections (&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, etc) to the memory regions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b73ff2eada76f8ac9ebd9981af9354d96c99aa" translate="yes" xml:space="preserve">
          <source>These pragmas maintain a stack of the current target and optimization options. It is intended for include files where you temporarily want to switch to using a different &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603f3636cf78ad4d753498b11957f65672ebe2cb" translate="yes" xml:space="preserve">
          <source>These problems are perhaps regrettable, but we don&amp;rsquo;t know any practical way around them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b9fcf5c8f8750409b0be6384fa9bc28cb10f52" translate="yes" xml:space="preserve">
          <source>These programs work properly with GNU C++ if &lt;code&gt;__STDC__&lt;/code&gt; is defined. They would not work otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8668b2099e0b980048c9ff0d8e19c4e25e485197" translate="yes" xml:space="preserve">
          <source>These pseudo types are not defined by GCC, they are simply a notational convenience used in this manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f405633d47d5e6bb41585f2bd9ddbfca800a1d10" translate="yes" xml:space="preserve">
          <source>These restrictions exist because the storage order attribute is lost when the address of a scalar or the address of an array with scalar component is taken, so storing indirectly through this address generally does not work. The second case is nevertheless allowed to be able to perform a block copy from or to the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617ec4855cb2c9a651bfd784a1ec34d6b14a3c49" translate="yes" xml:space="preserve">
          <source>These switches are supported in addition to the above on Solaris 2:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8a75785b95174e69ab84ca725881f92373e1de" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default for 32-bit Bionic C library. A size of 128 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;__float128&lt;/code&gt; type. This is the default for 64-bit Bionic C library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4c72bd4a51cef29e53fde4cebb62a0cdc42ecb" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe1fb390a0357110cca04fd8837b1f7aac6050f" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. The x86-32 application binary interface specifies the size to be 96 bits, so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7348ef4aa27c2888870c0a37711f33df4fe6ef4" translate="yes" xml:space="preserve">
          <source>These switches enable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow!, enhanced 3DNow!, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, or CLDEMOTE extended instruction sets. Each has a corresponding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9495d6f00684499ee4c826615f4071694dd898" translate="yes" xml:space="preserve">
          <source>These types can be used to define 128-bit variables. The built-in functions listed in the following section can be used on these variables to generate the vector operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e668693b38e6c57f5102ee95a3e05249f7244a77" translate="yes" xml:space="preserve">
          <source>These usages are only permitted when they are not ambiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f38a05c071c60c51e986980de83378738afc905" translate="yes" xml:space="preserve">
          <source>These variable attributes are available for H8/300 targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241d1accd4905e80f5a34fe3dc64f1b3deee21e2" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the Nvidia PTX back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f806a524d1696f92091d57f9cf53c9146e9a15bf" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the V850 back end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b949d9fe4918e4b913002b1484d0c6602fa25eb3" translate="yes" xml:space="preserve">
          <source>These warnings are harmless and can be safely ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e451fc6c4b4d61a1351149a72dc14d1a6505cb95" translate="yes" xml:space="preserve">
          <source>These warnings are made optional because GCC may not be able to determine when the code is correct in spite of appearing to have an error. Here is one example of how this can happen:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e18fe51f3f4e2e5c1a093907e436f1a7eab080" translate="yes" xml:space="preserve">
          <source>These warnings are only possible in optimizing compilation, because otherwise GCC does not keep track of the state of variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e773c8b72ecdbdff1f92adf539e992bd54211f66" translate="yes" xml:space="preserve">
          <source>These warnings occur for individual uninitialized or clobbered elements of structure, union or array variables as well as for variables that are uninitialized or clobbered as a whole. They do not occur for variables or elements declared &lt;code&gt;volatile&lt;/code&gt;. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depends on the precise optimization options and version of GCC used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f2498a22474b067e488cbcf73df92835b4dcbc" translate="yes" xml:space="preserve">
          <source>Things we think are right, but some others disagree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1997b0ca2cbaa31341990ddcffc48330394de3bf" translate="yes" xml:space="preserve">
          <source>Things will disappear from G++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c779d1bd661026f38150c16245e1a66cae977330" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes one input, which is internally popped, and produces two outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea744591db59b72a57a82ebc78f06c0a9beaefd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes two inputs, which are popped by the &lt;code&gt;fyl2xp1&lt;/code&gt; opcode, and replaces them with one output. The &lt;code&gt;st(1)&lt;/code&gt; clobber is necessary for the compiler to know that &lt;code&gt;fyl2xp1&lt;/code&gt; pops both inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49059cf2744a33f2c89b82b703d94b0c5663c6e8" translate="yes" xml:space="preserve">
          <source>This IA-64 HP-UX attribute, attached to a global variable or function, renames a symbol to contain a version string, thus allowing for function level versioning. HP-UX system header files may use function level versioning for some system calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241afcfcf7826d27f6d46a14ffc5e97907ebd792" translate="yes" xml:space="preserve">
          <source>This ISA is implemented by the minimal AVR core and supported for assembler only. &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt;, &lt;code&gt;attiny12&lt;/code&gt;, &lt;code&gt;attiny15&lt;/code&gt;, &lt;code&gt;attiny28&lt;/code&gt;, &lt;code&gt;at90s1200&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7707ff43d31f77dd6414b616a64487e73ac2f610" translate="yes" xml:space="preserve">
          <source>This RX attribute is similar to the &lt;code&gt;interrupt&lt;/code&gt; attribute, including its parameters, but does not make the function an interrupt-handler type function (i.e. it retains the normal C function calling ABI). See the &lt;code&gt;interrupt&lt;/code&gt; attribute for a description of its arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3ace91b836f39e130a69b032cbc00b174ef7e1" translate="yes" xml:space="preserve">
          <source>This allows classes to dynamically register methods (by adding them to the class using &lt;code&gt;class_addMethod&lt;/code&gt;) when they are first called. To do so, a class should implement &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or, depending on the case, &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) and have it recognize the selectors of methods that can be registered dynamically at runtime, register them, and return &lt;code&gt;YES&lt;/code&gt;. It should return &lt;code&gt;NO&lt;/code&gt; for methods that it does not dynamically registered at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08bbed031d0bdc80dfc8c12fb03bbad77feeb085" translate="yes" xml:space="preserve">
          <source>This also works with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70958ab1135f4d3b760976f6ea18b5ad5e6cd4ca" translate="yes" xml:space="preserve">
          <source>This assumes that &lt;code&gt;x&lt;/code&gt; is an array of pointers to functions; the type described is that of the values of the functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e587899e8439ab096a171178bf777e82d34203e" translate="yes" xml:space="preserve">
          <source>This attribute adds stack protection code to the function if flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa1a8a02f8237f39f16f9e3141f209d4e6ecc0a" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. It can be applied to variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;) as well as functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70510133f65523747a3309a22314ce44be57270" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. The &lt;code&gt;visibility&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2662beeb7225f89f9b3b830e684251c6d287e4ea" translate="yes" xml:space="preserve">
          <source>This attribute allows one to mark secure-code functions that are callable from normal mode. The location of the secure call function into the &lt;code&gt;sjli&lt;/code&gt; table needs to be passed as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72283dc6a14cbd57d6d6c7ceadcc8425ca927f4" translate="yes" xml:space="preserve">
          <source>This attribute allows the compiler to construct the requisite function declaration, while allowing the body of the function to be assembly code. The specified function will not have prologue/epilogue sequences generated by the compiler. Only basic &lt;code&gt;asm&lt;/code&gt; statements can safely be included in naked functions (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;). While using extended &lt;code&gt;asm&lt;/code&gt; or a mixture of basic &lt;code&gt;asm&lt;/code&gt; and C code may appear to work, they cannot be depended upon to work reliably and are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da8d71f1e17b2c08ea57936e512e0f37aa70a9f" translate="yes" xml:space="preserve">
          <source>This attribute applies only to the particular namespace body, not to other definitions of the same namespace; it is equivalent to using &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6b9ade066129340d2b93cc21dd28696f004a1b" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to assume the called function is close enough to use the normal calling convention, overriding the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e0a7b8749b1724d33369b4ea037bd0b071529e" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to emit instructions to disable interrupts for the duration of the given function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e219dd9b57732e157d707be34c1c904f638a7d" translate="yes" xml:space="preserve">
          <source>This attribute corresponds to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da402fe02e024fb03bb5a3ac4167c5cbafc19db" translate="yes" xml:space="preserve">
          <source>This attribute enables creation of one or more function versions that can process multiple arguments using SIMD instructions from a single invocation. Specifying this attribute allows compiler to assume that such versions are available at link time (provided in the same or another translation unit). Generated versions are target-dependent and described in the corresponding Vector ABI document. For x86_64 target this document can be found &lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660859d290d769bde079f1e74652268ebbc1b062" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, that is an entry point that can be invoked from the host via the HSA runtime library. By default functions are only callable only from other GCN functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2fad3c190739d8e505c7ea63fef5f7267f258de" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, which can be invoked from the host via the CUDA RT library. By default functions are only callable only from other PTX functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e17cc8aacf2250a0265d50a2b47adfbfe456c6" translate="yes" xml:space="preserve">
          <source>This attribute is also accepted in C, but it is unnecessary because C does not have constructors or destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503a85109e1de0e8ce0564d361fa1038358344dc" translate="yes" xml:space="preserve">
          <source>This attribute is appropriate for types which just represent a value, such as &lt;code&gt;std::string&lt;/code&gt;; it is not appropriate for types which control a resource, such as &lt;code&gt;std::lock_guard&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2d583dcd0ca68ace008c0dc9fbd8ec6f90be8f" translate="yes" xml:space="preserve">
          <source>This attribute is ignored for R8C target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e03794349850af7bdeb66f9a9d6ef490386eec" translate="yes" xml:space="preserve">
          <source>This attribute is implicitly applied to any function named &lt;code&gt;main&lt;/code&gt;, using default parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9346f70ea23c21af36c756ae2b79002b57ffa81" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalar types. In function declarations the attribute applies to the function return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d7f394253f35fa8db5ca6f449a44ff4b56ba334" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e555249b47de74e90649b8eebd9bb76b767b366" translate="yes" xml:space="preserve">
          <source>This attribute is supported only for targets that use a uniform default scalar storage order (fortunately, most of them), i.e. targets that store the scalars either all in big-endian or all in little-endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3dbf2eda48cb59aebda306917b7f78672e9f61" translate="yes" xml:space="preserve">
          <source>This attribute is used to modify the IA-64 calling convention by marking all input registers as live at all function exits. This makes it possible to restart a system call after an interrupt without having to save/restore the input registers. This also prevents kernel data from leaking into application code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29e16cc249effe80d848bb9db8d32ddaa499113" translate="yes" xml:space="preserve">
          <source>This attribute is useful for small inline wrappers that if possible should appear during debugging as a unit. Depending on the debug info format it either means marking the function as artificial or using the caller location for all instructions within the inlined body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebce69b5ee57e7d9f9e53b8f77d9b2143a8f71f" translate="yes" xml:space="preserve">
          <source>This attribute locally overrides the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b079e0e5e6910cff82e9ecf2f5a99d46287bccb2" translate="yes" xml:space="preserve">
          <source>This attribute may only be applied to structure types. It indicates that any initialization of an object of this type must use designated initializers rather than positional initializers. The intent of this attribute is to allow the programmer to indicate that a structure&amp;rsquo;s layout may change, and that therefore relying on positional initialization will result in future breakage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c62ef86997f4e170b106b5387843679fbba8d0" translate="yes" xml:space="preserve">
          <source>This attribute modifies the behavior of an interrupt handler. The interrupt handler may be in external memory which cannot be reached by a branch instruction, so generate a local memory trampoline to transfer control. The single parameter identifies the section where the trampoline is placed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="effaae1a1a3c582ea4cc6ec90afe0b02dd3b515f" translate="yes" xml:space="preserve">
          <source>This attribute only applies to interrupt functions. It is silently ignored if applied to a non-interrupt function. A wakeup interrupt function will rouse the processor from any low-power state that it might be in when the function exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b26152314a60738ffd8a5e7f3727dd841bf2cfd9" translate="yes" xml:space="preserve">
          <source>This attribute requires assembler and object file support, and may not be available on all targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b2af80c8a3a275efbd609425500eed5fe647aa" translate="yes" xml:space="preserve">
          <source>This attribute should be used with a function that is also declared with the &lt;code&gt;inline&lt;/code&gt; keyword. It directs GCC to treat the function as if it were defined in gnu90 mode even when compiling in C99 or gnu99 mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673dc92ba9f751f0e2d252934e26bb46b7e48dac" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L1 Instruction SRAM. The function is put into a specific section named &lt;code&gt;.l1.text&lt;/code&gt;. With</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87042e05584213c1ab77c9f22219578def878d66" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L2 SRAM. The function is put into a specific section named &lt;code&gt;.l2.text&lt;/code&gt;. With</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79629b6015ecde4f64aa5edeebdeed4ca22350b1" translate="yes" xml:space="preserve">
          <source>This attribute specifies a threshold for the structure field, measured in bytes. If the structure field is aligned below the threshold, a warning will be issued. For example, the declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304795dd4f7d1f35b54a689f0ca428f75b402b8c" translate="yes" xml:space="preserve">
          <source>This attribute specifies the data type for the declaration&amp;mdash;whichever type corresponds to the mode &lt;var&gt;mode&lt;/var&gt;. This in effect lets you request an integer or floating-point type according to its width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9083d141dfccd0e26e0504dbf2c594ddf0afc0" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type of the declared variable, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4812a74afb4965dd971b67251a8e1a47c47bf670" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the following declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721933cb3a33d0b7e6bbaf2079ece1bfb6d52c2e" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or C++ &lt;code&gt;class&lt;/code&gt; type definition, specifies that each of its members (other than zero-width bit-fields) is placed to minimize the memory required. This is equivalent to specifying the &lt;code&gt;packed&lt;/code&gt; attribute on each of the members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26328ece7307f514a47cc876ff83560893a099c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;union&lt;/code&gt; type definition, indicates that any function parameter having that union type causes calls to that function to be treated in a special way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea2c8428220fbb29ff9bb397fcc0cd8bc82fcc8" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that code must be emitted for the function even if it appears that the function is not referenced. This is useful, for example, when the function is referenced only in inline assembly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26a8e83a7c29f151aef9f7d69a0073e42ed7b63" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that the function is meant to be possibly unused. GCC does not produce a warning for this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cda8d2a406df80f5c3c1e70abd61657e961b09d" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a global variable or function, nullifies the effect of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b693f4e1b31df32d21cd97a87984062ca5cf0e7b" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable with static storage, means that the variable must be emitted even if it appears that the variable is not referenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09cf2bdd650a42affb72357abc94b2d76134170c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable, means that the variable is meant to be possibly unused. GCC does not produce a warning for this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a9f3d41b5e82d7b9c83b17f60c49a3dab84962" translate="yes" xml:space="preserve">
          <source>This behavior may seem silly, but it&amp;rsquo;s what the ISO standard specifies. It is easy enough for you to make your code work by moving the definition of &lt;code&gt;struct mumble&lt;/code&gt; above the prototype. It&amp;rsquo;s not worth being incompatible with ISO C just to avoid an error for the example shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8818c6d89ffa44c89646c897a4e574f7b71484ee" translate="yes" xml:space="preserve">
          <source>This built-in can be used to determine the current transaction state using the following code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92883b24f84fe55e50f3d20ded0b1b0331344202" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between a thread and signal handlers based in the same thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a20473e8d5898eb62d474e73fb635a7caf013c9" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between threads based on the specified memory order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c179d50784fac3eee427384f1e34f1d0ea28d01" translate="yes" xml:space="preserve">
          <source>This built-in function can be used to help mitigate against unsafe speculative execution. &lt;var&gt;type&lt;/var&gt; may be any integral type or any pointer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdfcca8b913445e45652ce81bc13dc531eb31f5a" translate="yes" xml:space="preserve">
          <source>This built-in function can return an lvalue if the chosen argument is an lvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b10a642d35506bdb301b36c3b2dbb7b1a29af0" translate="yes" xml:space="preserve">
          <source>This built-in function ignores top level qualifiers (e.g., &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;). For example, &lt;code&gt;int&lt;/code&gt; is equivalent to &lt;code&gt;const
int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3196f175db1b7bf9e191bc879315daa8c8ea4f" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic compare and exchange operation. This compares the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; with the contents of &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. If equal, the operation is a &lt;em&gt;read-modify-write&lt;/em&gt; operation that writes &lt;var&gt;desired&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. If they are not equal, the operation is a &lt;em&gt;read&lt;/em&gt; and the current contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; are written into &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;true&lt;/code&gt; for weak compare_exchange, which may fail spuriously, and &lt;code&gt;false&lt;/code&gt; for the strong variation, which never fails spuriously. Many targets only offer the strong variation and ignore the parameter. When in doubt, use the strong variation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f42bd96c55f1e604c896fe2e73d0e93c4e17e7" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic exchange operation. It writes &lt;var&gt;val&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a26f774d21850134f1ad4ec8601fd024a4508" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic load operation. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2685600611aa3929789e72b13593b02a524004" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic store operation. It writes &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea16c3e951ac6e4e93bda6af660c19a372791953" translate="yes" xml:space="preserve">
          <source>This built-in function implements the generic version of &lt;code&gt;__atomic_compare_exchange&lt;/code&gt;. The function is virtually identical to &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt;, except the desired value is also a pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8296c6507414677ec38273521ab8df96daa500be" translate="yes" xml:space="preserve">
          <source>This built-in function invokes &lt;var&gt;function&lt;/var&gt; with a copy of the parameters described by &lt;var&gt;arguments&lt;/var&gt; and &lt;var&gt;size&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5c4780f25bedcea7655683b3a1f0ac5e0f5ed0" translate="yes" xml:space="preserve">
          <source>This built-in function is analogous to the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1bff7892551ba3b77dbb599f93fb2a84f960cc" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather a &lt;em&gt;release barrier&lt;/em&gt;. This means that all previous memory stores are globally visible, and all previous memory loads have been satisfied, but following memory reads are not prevented from being speculated to before the barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70719484366a8b3c252ddc3ff84790bc06cc3ad" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather an &lt;em&gt;acquire barrier&lt;/em&gt;. This means that references after the operation cannot move to (or be speculated to) before the operation, but previous memory stores may not be globally visible yet, and previous memory loads may not yet be satisfied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="073757ac658ed7f6a9f1d03295b93f00125aefcc" translate="yes" xml:space="preserve">
          <source>This built-in function issues a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e033b3b4f9c857696bc2244ed32f0a7d140cd57" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic clear operation on &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. After the operation, &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; contains 0. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt; and in conjunction with &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. For other types it may only clear partially. If the type is not &lt;code&gt;bool&lt;/code&gt; prefer using &lt;code&gt;__atomic_store&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c97edabae382ebead73a4652d8d69259efed11" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic test-and-set operation on the byte at &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The byte is set to some implementation defined nonzero &amp;ldquo;set&amp;rdquo; value and the return value is &lt;code&gt;true&lt;/code&gt; if and only if the previous contents were &amp;ldquo;set&amp;rdquo;. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. For other types only part of the value may be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b288561de8012f0a5e9cadf66cc0631f6c354855" translate="yes" xml:space="preserve">
          <source>This built-in function releases the lock acquired by &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt;. Normally this means writing the constant 0 to &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fbd055aee266ab03001d14151e03de46793e79e" translate="yes" xml:space="preserve">
          <source>This built-in function represents all anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. It must be only passed as last argument to some other function with variable arguments. This is useful for writing small wrapper inlines for variable argument functions, when using preprocessor macros is undesirable. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a645e8bd97d4c4a4974b86fe42f50e43f5945898" translate="yes" xml:space="preserve">
          <source>This built-in function returns 1 if the unqualified versions of the types &lt;var&gt;type1&lt;/var&gt; and &lt;var&gt;type2&lt;/var&gt; (which are types, not expressions) are compatible, 0 otherwise. The result of this built-in function can be used in integer constant expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfe1d809ee98496092f61c8ed5ff01343455bef" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. &lt;var&gt;size&lt;/var&gt; must resolve to a compile-time constant and the result also resolves to a compile-time constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bd1267444e0c22cd6d3d40974c7c8c9aa88d05" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. If the built-in function is not known to be lock-free, a call is made to a runtime routine named &lt;code&gt;__atomic_is_lock_free&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6d5e134400518a60b0f022ce70bc3a88ebfc9d" translate="yes" xml:space="preserve">
          <source>This built-in function returns a pointer to data describing how to perform a call with the same arguments as are passed to the current function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a965c005ba35ec687e9a6eef5b255a00ddffc5d3" translate="yes" xml:space="preserve">
          <source>This built-in function returns the number of anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. For example following does link- or run-time checking of open arguments for optimized code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a152f3eb0d609efeaccc0dfd600b3f1ca33a36" translate="yes" xml:space="preserve">
          <source>This built-in function returns the value described by &lt;var&gt;result&lt;/var&gt; from the containing function. You should specify, for &lt;var&gt;result&lt;/var&gt;, a value returned by &lt;code&gt;__builtin_apply&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f8e4f9c5ee35c6668a2b80b5a01f58cf7b3cac" translate="yes" xml:space="preserve">
          <source>This built-in function, as described by Intel, is not a traditional test-and-set operation, but rather an atomic exchange operation. It writes &lt;var&gt;value&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568a9d62c8cf52e8d6dd28fe3fede9225dfafd5c" translate="yes" xml:space="preserve">
          <source>This built-in implements the C99 fpclassify functionality. The first five int arguments should be the target library&amp;rsquo;s notion of the possible FP classes and are used for return values. They must be constant values and they must appear in this order: &lt;code&gt;FP_NAN&lt;/code&gt;, &lt;code&gt;FP_INFINITE&lt;/code&gt;, &lt;code&gt;FP_NORMAL&lt;/code&gt;, &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; and &lt;code&gt;FP_ZERO&lt;/code&gt;. The ellipsis is for exactly one floating-point value to classify. GCC treats the last argument as type-generic, which means it does not do default promotion from float to double.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de56bb64bcd269982e143b48fca7664ac4ccd934" translate="yes" xml:space="preserve">
          <source>This built-in takes a byte address to the 24-bit &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;address space&lt;/a&gt;&lt;code&gt;__memx&lt;/code&gt; and returns the number of the flash segment (the 64 KiB chunk) where the address points to. Counting starts at &lt;code&gt;0&lt;/code&gt;. If the address does not point to flash memory, return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12afcfe5b0cb2421e366cb4bf6d262a7225b43e1" translate="yes" xml:space="preserve">
          <source>This calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59930047a3dbe1a0da0d3c55b5832603831020b" translate="yes" xml:space="preserve">
          <source>This can be a suitable option for application code written for the Borland model, as it usually just works. Code written for the Cfront model needs to be modified so that the template definitions are available at one or more points of instantiation; usually this is as simple as adding &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; to the end of each template header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8138fe5070f142675bd6f047c11ca6604b5e4b89" translate="yes" xml:space="preserve">
          <source>This causes GCC&amp;rsquo;s output file to have the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b096441ddb3f545a4e7491763e07ff42aa42c7a" translate="yes" xml:space="preserve">
          <source>This causes an error messages saying:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b13c019e57e81567c1e4f0f77d055f628a1482" translate="yes" xml:space="preserve">
          <source>This clears the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52348806f9132146a3d5c83435b59d49467218d2" translate="yes" xml:space="preserve">
          <source>This code copies &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; and add 1 to &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1cd197f5f5bea21b21e4898acbd5a40235dc12" translate="yes" xml:space="preserve">
          <source>This code makes no use of the optional &lt;var&gt;asmSymbolicName&lt;/var&gt;. Therefore it references the first output operand as &lt;code&gt;%0&lt;/code&gt; (were there a second, it would be &lt;code&gt;%1&lt;/code&gt;, etc). The number of the first input operand is one greater than that of the last output operand. In this i386 example, that makes &lt;code&gt;Mask&lt;/code&gt; referenced as &lt;code&gt;%1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f2247acfc64bac06fade1fb9f20f85e4652f3a" translate="yes" xml:space="preserve">
          <source>This code really is erroneous, because the scope of &lt;code&gt;struct
mumble&lt;/code&gt; in the prototype is limited to the argument list containing it. It does not refer to the &lt;code&gt;struct mumble&lt;/code&gt; defined with file scope immediately below&amp;mdash;they are two unrelated types with similar names in different scopes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337163816650f5c7db30e6d4ef7d7194c7c7dcdf" translate="yes" xml:space="preserve">
          <source>This code runs unconditionally on all 64-bit processors. For 32-bit processors the code runs on those that support multi-byte NOP instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f60ecfa36c1d209e897848d1465d421ffe66fd4" translate="yes" xml:space="preserve">
          <source>This code says that input &lt;code&gt;b&lt;/code&gt; is not popped by the &lt;code&gt;asm&lt;/code&gt;, and that the &lt;code&gt;asm&lt;/code&gt; pushes a result onto the reg-stack, i.e., the stack is one deeper after the &lt;code&gt;asm&lt;/code&gt; than it was before. But, it is possible that reload may think that it can use the same register for both the input and the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5158b0e232baa68e812ae0b3c5ff1e7b6dd2495a" translate="yes" xml:space="preserve">
          <source>This combination of &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; has almost the effect of a macro. The way to use it is to put a function definition in a header file with these keywords, and put another copy of the definition (lacking &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt;) in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81343c69409df406d64f943e849b1b69e1c3338" translate="yes" xml:space="preserve">
          <source>This construct outputs &lt;code&gt;dialect0&lt;/code&gt; when using dialect #0 to compile the code, &lt;code&gt;dialect1&lt;/code&gt; for dialect #1, etc. If there are fewer alternatives within the braces than the number of dialects the compiler supports, the construct outputs nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4418d19029db54262a2982d0fc11517ca360b079" translate="yes" xml:space="preserve">
          <source>This could also be written using a statement expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3561933d5b27303ad0b1eed1db35f7bce90fa0b" translate="yes" xml:space="preserve">
          <source>This declaration only establishes that the class &lt;code&gt;Foo&lt;/code&gt; has an &lt;code&gt;int&lt;/code&gt; named &lt;code&gt;Foo::bar&lt;/code&gt;, and a member function named &lt;code&gt;Foo::method&lt;/code&gt;. But you still need to define &lt;em&gt;both&lt;/em&gt;&lt;code&gt;method&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; elsewhere. According to the ISO standard, you must supply an initializer in one (and only one) source file, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5d48aae2a8d70a04aa98c11ed292ce987fe6e4" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of pointers to characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5984e00c4ab800b89abb234fbcf6672036013a3" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of such values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cddb3ab7751ac13216d638e5a732f674e3c8eeb" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; with the type of what &lt;code&gt;x&lt;/code&gt; points to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faab4d37a48d574a707b33549eb07bcf03d70747" translate="yes" xml:space="preserve">
          <source>This deduction was implemented as a possible extension to the originally proposed semantics for the C++11 standard, but was not part of the final standard, so it is disabled by default. This option is deprecated, and may be removed in a future version of G++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c879d3e8cb77a4fc10b608d3eb2285203202e61b" translate="yes" xml:space="preserve">
          <source>This defaults to &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f436df92076512b77fe92317bd65f3d39a6a1f34" translate="yes" xml:space="preserve">
          <source>This distinction between lookup of dependent and non-dependent names is called two-stage (or dependent) name lookup. G++ implements it since version 3.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995cd6d9a17d418485ea5c0854d97ede3bab24ec" translate="yes" xml:space="preserve">
          <source>This document is meant to describe some of the GNU Objective-C features. It is not intended to teach you Objective-C. There are several resources on the Internet that present the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd119f74d4b60b69c880f2448f8e713a89672c3" translate="yes" xml:space="preserve">
          <source>This enables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e09a1e0e5fd69eecab75ac51a34aa77d0b56b77" translate="yes" xml:space="preserve">
          <source>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros. This also enables some language-specific warnings described in &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C++ Dialect Options&lt;/a&gt; and &lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-C and Objective-C++ Dialect Options&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c0c908290715ca8a4902d77d9d099c7818ae8f" translate="yes" xml:space="preserve">
          <source>This enables some extra warning flags that are not enabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f682e7e0e71202769284a5f29ad044bc452f34" translate="yes" xml:space="preserve">
          <source>This enables use of the locked load/store conditional extension to implement atomic memory built-in functions. Not available for ARC 6xx or ARC EM cores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5419693b2d5b267f6af681a001ebef359580125" translate="yes" xml:space="preserve">
          <source>This example assigns a function to two slots in the default table (using preprocessor macros defined elsewhere) and makes it the default for the &lt;code&gt;dct&lt;/code&gt; table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93813cffc93eab710482b42f488b7bb9eff10b0" translate="yes" xml:space="preserve">
          <source>This example is perfectly equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e949e9ca160ba7c9c4c48936e0ebb9e6567bec" translate="yes" xml:space="preserve">
          <source>This example renames the spec called &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17efc27880dcdd0f4c6216f48227b6a6d20fb6a4" translate="yes" xml:space="preserve">
          <source>This example shows a simple assignment of a function to one vector in the default table (note that preprocessor macros may be used for chip-specific symbolic vector names):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26530d0d01a4039c695b96fdd00747a2bd4aaea" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;cold&lt;/code&gt; label attribute to indicate the &lt;code&gt;ErrorHandling&lt;/code&gt; branch is unlikely to be taken and that the &lt;code&gt;ErrorHandling&lt;/code&gt; label is unused:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3998b5540160156094948f334d5843b7f7f046" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;deprecated&lt;/code&gt; enumerator attribute to indicate the &lt;code&gt;oldval&lt;/code&gt; enumerator is deprecated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215cf5b89400516fe24140191ed923d2f09bd20b" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;fallthrough&lt;/code&gt; statement attribute to indicate that the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f112db8072d753fab06651e1a77010d4e9ebe45" translate="yes" xml:space="preserve">
          <source>This example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101c080fa9daf91a22a5c3746a65d406ce7eb831" translate="yes" xml:space="preserve">
          <source>This extension is not supported by GNU C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68ab67a136425be8901f00690401dbac036957d" translate="yes" xml:space="preserve">
          <source>This extension is sufficient such that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b411a471e59249b2c99728d68299ae469991d2" translate="yes" xml:space="preserve">
          <source>This extension may not be very useful, but it makes the handling of &lt;code&gt;enum&lt;/code&gt; more consistent with the way &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; are handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5605d8fdd1bc286fd5dac21c8bc67cef9a0ffdd5" translate="yes" xml:space="preserve">
          <source>This extra alignment does consume extra stack space, and generally increases code size. Code that is sensitive to stack space usage, such as embedded systems and operating system kernels, may want to reduce the preferred alignment to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e786b1c4f43cf240524b9e361ead5cdf6cfb070b" translate="yes" xml:space="preserve">
          <source>This facility is very useful if you want to initialize global variables which can be accessed by the program directly, without sending a message to the class first. The usual way to initialize global variables, in the &lt;code&gt;+initialize&lt;/code&gt; method, might not be useful because &lt;code&gt;+initialize&lt;/code&gt; is only called when the first message is sent to a class object, which in some cases could be too late.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5301c866b6ac40f65d4bd67792ec94bc126ba1c2" translate="yes" xml:space="preserve">
          <source>This feature is especially useful for ranges of ASCII character codes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7eade7c951c9b37c2e852a014cd189c7b49192" translate="yes" xml:space="preserve">
          <source>This feature is especially useful in making macro definitions &amp;ldquo;safe&amp;rdquo; (so that they evaluate each operand exactly once). For example, the &amp;ldquo;maximum&amp;rdquo; function is commonly defined as a macro in standard C as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf86da6582486ace0550eafa0f42f9a96d5c2a2b" translate="yes" xml:space="preserve">
          <source>This feature is intended for program-generated code that may contain unused labels, but which is compiled with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1076e2c167a24356587893b7b6c8a8375aa3a4" translate="yes" xml:space="preserve">
          <source>This feature is not enabled by default. Specifying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9420f79a451b4efac8e962af58f495ad7ac181c7" translate="yes" xml:space="preserve">
          <source>This feature is used in automatic updating of makefiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f11fa97afc8a9f70ed0e1fb16cbd9bede804da" translate="yes" xml:space="preserve">
          <source>This file documents the use of the GNU compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c21848b1d55804d72743a6693d101b63cd47544" translate="yes" xml:space="preserve">
          <source>This flag attempts to use visibility settings to make GCC&amp;rsquo;s C++ linkage model compatible with that of Microsoft Visual Studio.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db7dd43d8e02c47fc0a85c5c3e38b591f0a3877" translate="yes" xml:space="preserve">
          <source>This flag does not have a negative form, because it specifies a three-way choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b1af85f2a6f09c7615fb9953621e2594fc2498" translate="yes" xml:space="preserve">
          <source>This flag is disabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef23e3f8b62106f744c396a536baec3f85486f03" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb1ed0a0aaf28dac933fdc7dd7aadf9b8292636" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c025ee0fe2aca271d6bc8b1c3c04c156ee4d07a6" translate="yes" xml:space="preserve">
          <source>This flag is included in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d3b3aedc1d8ba8a1241588ebdb03f76fc4bd8e" translate="yes" xml:space="preserve">
          <source>This function attribute indicates that an argument in a call to the function is expected to be an explicit &lt;code&gt;NULL&lt;/code&gt;. The attribute is only valid on variadic functions. By default, the sentinel is expected to be the last argument of the function call. If the optional &lt;var&gt;position&lt;/var&gt; argument is specified to the attribute, the sentinel must be located at &lt;var&gt;position&lt;/var&gt; counting backwards from the end of the argument list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eace8a8897f53986baecdd557c9bed95be5eb95" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for cloning&amp;mdash;a mechanism that produces specialized copies of functions and which is (currently) performed by interprocedural constant propagation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0185a8637e8440da0db0d53dd62eb7167b8eb84c" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for inlining. If the function does not have side effects, there are optimizations other than inlining that cause function calls to be optimized away, although the function call is live. To keep such calls from being optimized away, put</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2eae0ac690e115a386b22c2c033e3d207f73749" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a functions from being merged with another semantically equivalent function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa0a9aeda6626f962564eda6d7bc9ae77a9f9e7" translate="yes" xml:space="preserve">
          <source>This function causes the program to exit abnormally. GCC implements this function by using a target-dependent mechanism (such as intentionally executing an illegal instruction) or by calling &lt;code&gt;abort&lt;/code&gt;. The mechanism used may vary from release to release so you should not rely on any particular implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e524eeb8ecfc131aac67b7d8a458ea88f19f0eed" translate="yes" xml:space="preserve">
          <source>This function does the reverse of &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95420bd588ca997857f34739b8ed2c2d2dc9b407" translate="yes" xml:space="preserve">
          <source>This function has the same semantics as &lt;code&gt;__builtin_expect&lt;/code&gt;, but the caller provides the expected probability that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. The last argument, &lt;var&gt;probability&lt;/var&gt;, is a floating-point value in the range 0.0 to 1.0, inclusive. The &lt;var&gt;probability&lt;/var&gt; argument must be constant floating-point expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad1828780de0ec7cb4d2651f782e659f7669888" translate="yes" xml:space="preserve">
          <source>This function is a &lt;code&gt;nop&lt;/code&gt; on the PowerPC platform and is included solely to maintain API compatibility with the x86 builtins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1de5cdd4f293c4a48810df067ace8dfe7d6d91" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;__builtin_return_address&lt;/code&gt;, but it returns the address of the function frame rather than the return address of the function. Calling &lt;code&gt;__builtin_frame_address&lt;/code&gt; with a value of &lt;code&gt;0&lt;/code&gt; yields the frame address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the frame address of the caller of the current function, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b7342f9f274d12e577265101ded1a69579dafe" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the &lt;code&gt;__FUNCTION__&lt;/code&gt; symbol and returns an address constant pointing to the name of the function from which the built-in was invoked, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the name of &lt;var&gt;F&lt;/var&gt;&amp;rsquo;s caller or the empty string if the call was not made at function scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e1f1b709cdf3bbdf962d668f4ccf9699d7ee2e" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__FILE__&lt;/code&gt; macro and returns an address constant pointing to the file name containing the invocation of the built-in, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the file name of the call to &lt;var&gt;F&lt;/var&gt; or the empty string if the call was not made at function scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc294999db99ded1854e8f5e1e4b8ef679553e0d" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__LINE__&lt;/code&gt; macro and returns a constant integer expression that evaluates to the line number of the invocation of the built-in. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the line number of the call to &lt;var&gt;F&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4965b81131ff05edb23e4ac2cd86ee54e42a982" translate="yes" xml:space="preserve">
          <source>This function is used to flush the processor&amp;rsquo;s instruction cache for the region of memory between &lt;var&gt;begin&lt;/var&gt; inclusive and &lt;var&gt;end&lt;/var&gt; exclusive. Some targets require that the instruction cache be flushed, after modifying memory containing code, in order to obtain deterministic behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fe2b1a97278967d04d0a166eb411721a963d62" translate="yes" xml:space="preserve">
          <source>This function is used to minimize cache-miss latency by moving data into a cache before it is accessed. You can insert calls to &lt;code&gt;__builtin_prefetch&lt;/code&gt; into code for which you know addresses of data in memory that is likely to be accessed soon. If the target supports them, data prefetch instructions are generated. If the prefetch is done early enough before the access then the data will be in the cache by the time it is accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8919a966ee8dd6af4dbf0f92a03208a705be1969" translate="yes" xml:space="preserve">
          <source>This function restores the stack context in &lt;var&gt;buf&lt;/var&gt;, saved by a previous call to &lt;code&gt;__builtin_setjmp&lt;/code&gt;. After &lt;code&gt;__builtin_longjmp&lt;/code&gt; is finished, the program resumes execution as if the matching &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns the value &lt;var&gt;val&lt;/var&gt;, which must be 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d321f2ee318af6c2dd764431e17a984bfaa18ec1" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to data describing how to return whatever value is returned by &lt;var&gt;function&lt;/var&gt;. The data is saved in a block of memory allocated on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71039af8a1d11c8d83124bcb2f420630a5a1ce8" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following CPU names can be detected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdc7462f357d955c59d1a21b41e74d15ee8d83b" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU supports &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following features can be detected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf6bbb0ff1bf6eb1b3c656f4cca7e925e10e2a5" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27852be90385733f670b1f53118c6fb5c9f99598" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU supports the HWCAP feature &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213b2aa2268e34e2f3e902cc0c4fc9d3fae623d8" translate="yes" xml:space="preserve">
          <source>This function returns its first argument, and allows the compiler to assume that the returned pointer is at least &lt;var&gt;align&lt;/var&gt; bytes aligned. This built-in can have either two or three arguments, if it has three, the third argument should have integer type, and if it is nonzero means misalignment offset. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc83a066fc8a8ed7ae8cb097e4deaf1084d4a2b" translate="yes" xml:space="preserve">
          <source>This function returns the return address of the current function, or of one of its callers. The &lt;var&gt;level&lt;/var&gt; argument is number of frames to scan up the call stack. A value of &lt;code&gt;0&lt;/code&gt; yields the return address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the return address of the caller of the current function, and so forth. When inlining the expected behavior is that the function returns the address of the function that is returned to. To work around this behavior use the &lt;code&gt;noinline&lt;/code&gt; function attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c68121ab03a5059f1b4257b6c2b3c7234cacf3" translate="yes" xml:space="preserve">
          <source>This function runs the CPU detection code to check the type of CPU and the features supported. This built-in function needs to be invoked along with the built-in functions to check CPU type and features, &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, only when used in a function that is executed before any constructors are called. The CPU detection code is automatically executed in a very high priority constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f58a4af763a22a01173db535b0e84cbf679fc29" translate="yes" xml:space="preserve">
          <source>This function saves the current stack context in &lt;var&gt;buf&lt;/var&gt;. &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns 0 when returning directly, and 1 when returning from &lt;code&gt;__builtin_longjmp&lt;/code&gt; using the same &lt;var&gt;buf&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e7849ff4cbe4d496d1ff31f3b20212a375c758" translate="yes" xml:space="preserve">
          <source>This function, if given a string literal all of which would have been consumed by &lt;code&gt;strtol&lt;/code&gt;, is evaluated early enough that it is considered a compile-time constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b248fa09ed8681d529d9f22aaa2c70eb149364a" translate="yes" xml:space="preserve">
          <source>This has symmetry with normal static arrays, in that an array of unknown size is also written with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8646e863ba587311636afd56af70cd4124b64132" translate="yes" xml:space="preserve">
          <source>This has the same effect as the proper number of individual &lt;code&gt;case&lt;/code&gt; labels, one for each integer value from &lt;var&gt;low&lt;/var&gt; to &lt;var&gt;high&lt;/var&gt;, inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83169887a69a2b08bab1ebc54a9588ce551d545e" translate="yes" xml:space="preserve">
          <source>This hook is generally reserved for &amp;ldquo;Foundation&amp;rdquo; libraries such as GNUstep Base, which use it to implement their high-level method forwarding API, typically based around the &lt;code&gt;forwardInvocation:&lt;/code&gt; method. So, unless you are implementing your own &amp;ldquo;Foundation&amp;rdquo; library, you should not set this hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968e5049fab7f4bdf3b3205d394535ad648ef39e" translate="yes" xml:space="preserve">
          <source>This i386 code demonstrates a case that does not use (or require) the &lt;code&gt;volatile&lt;/code&gt; qualifier. If it is performing assertion checking, this code uses &lt;code&gt;asm&lt;/code&gt; to perform the validation. Otherwise, &lt;code&gt;dwRes&lt;/code&gt; is unreferenced by any code. As a result, the optimizers can discard the &lt;code&gt;asm&lt;/code&gt; statement, which in turn removes the need for the entire &lt;code&gt;DoCheck&lt;/code&gt; routine. By omitting the &lt;code&gt;volatile&lt;/code&gt; qualifier when it isn&amp;rsquo;t needed you allow the optimizers to produce the most efficient code possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808f6f4a24d0e37061696da154166d6ac70ac880" translate="yes" xml:space="preserve">
          <source>This implies that the choice of angle brackets or double quotes in an &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1db8a962787e8ba6275999130017fe253b89359" translate="yes" xml:space="preserve">
          <source>This inserts an instruction sequence that takes exactly &lt;var&gt;cycles&lt;/var&gt; cycles (between 0 and about 17E9) to complete. The inserted sequence may use jumps, loops, or no-ops, and does not interfere with any other instructions. Note that &lt;var&gt;cycles&lt;/var&gt; must be a compile-time constant integer - that is, you must pass a number, not a variable that may be optimized to a constant later. The number of cycles delayed by this builtin is exact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5d39ccb505b20a7de4368cf8c74cd0bd9b0602" translate="yes" xml:space="preserve">
          <source>This instrumentation is also done for functions expanded inline in other functions. The profiling calls indicate where, conceptually, the inline function is entered and exited. This means that addressable versions of such functions must be available. If all your uses of a function are expanded inline, this may mean an additional expansion of code size. If you use &lt;code&gt;extern inline&lt;/code&gt; in your C code, an addressable version of such functions must be provided. (This is normally the case anyway, but if you get lucky and the optimizer always expands the functions inline, you might have gotten away without providing static copies.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f757d83923a2f4750aa24fef819d39fd7c764d" translate="yes" xml:space="preserve">
          <source>This interface allows either &lt;code&gt;int *&lt;/code&gt; or &lt;code&gt;union wait *&lt;/code&gt; arguments to be passed, using the &lt;code&gt;int *&lt;/code&gt; calling convention. The program can call &lt;code&gt;wait&lt;/code&gt; with arguments of either type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa6e20d0ad9607fec20c7fa93797725b39e7225" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible after &lt;code&gt;PSW.GIE&lt;/code&gt; (global interrupt enable) is set. This allows interrupt service routine to finish some short critical code before enabling interrupts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39211b611ed78b8a4cda99c2d1b9f90b52f7b8c" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc90603ecbdd7ae47dd33c675b43de2d13b14cf" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is not interruptible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ed58186125da377f3558ec8512de6f6dbbf8ae" translate="yes" xml:space="preserve">
          <source>This invokes all subprograms of &lt;code&gt;gcc&lt;/code&gt; under &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c68f63258bf418514a8d6d7b59387b054a571e" translate="yes" xml:space="preserve">
          <source>This is a 24-bit address space that linearizes flash and RAM: If the high bit of the address is set, data is read from RAM using the lower two bytes as RAM address. If the high bit of the address is clear, data is read from flash with &lt;code&gt;RAMPZ&lt;/code&gt; set according to the high byte of the address. See &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;&lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3eadc5a720e67193fff3510f3b6d516e5846adb" translate="yes" xml:space="preserve">
          <source>This is a debugging flag. When used in conjunction with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c173adebd0002ff9b3abf598cd2d9f90729d1e99" translate="yes" xml:space="preserve">
          <source>This is a literal string that is the template for the assembler code. It is a combination of fixed text and tokens that refer to the input, output, and goto parameters. See &lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplate&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0266778a01da6e94c7dbdd70401e030bc44b9214" translate="yes" xml:space="preserve">
          <source>This is a literal string that specifies the assembler code. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b220cd2425897f657363d80f6f8c621c9e9dc4d4" translate="yes" xml:space="preserve">
          <source>This is a more fine-grained version of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210265ec50f329c0444d753e710536de44906855" translate="yes" xml:space="preserve">
          <source>This is a property of the linker. C99 and C11 require that case distinctions are always significant in identifiers with external linkage and systems without this property are not supported by GCC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc75a30c66eb95f41ba11f1badfcb67f0cc09c0" translate="yes" xml:space="preserve">
          <source>This is a set of options that are used to explicitly disable/enable optimization passes. These options are intended for use for debugging GCC. Compiler users should use regular options for enabling/disabling passes instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a5bbf22b220bbd15b9398c9ef72c66a3e9df59" translate="yes" xml:space="preserve">
          <source>This is a synonym for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe3ee5c4bc9712f6bcac0ed8f03115711a2bebe4" translate="yes" xml:space="preserve">
          <source>This is an acceptable initializer even if &lt;var&gt;EXPRESSION&lt;/var&gt; is not a constant expression, including the case where &lt;code&gt;__builtin_constant_p&lt;/code&gt; returns 1 because &lt;var&gt;EXPRESSION&lt;/var&gt; can be folded to a constant but &lt;var&gt;EXPRESSION&lt;/var&gt; contains operands that are not otherwise permitted in a static initializer (for example, &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt;). GCC must be more conservative about evaluating the built-in in this case, because it has no opportunity to perform optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0aaa7cf6754c8cbdc72fa557e1be8935391e808" translate="yes" xml:space="preserve">
          <source>This is an advanced section. Type encodings are used extensively by the compiler and by the runtime, but you generally do not need to know about them to use Objective-C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f363131e14be21e154381e2dda1e3e5a071a820" translate="yes" xml:space="preserve">
          <source>This is an alternative to creating a union with a &lt;code&gt;double&lt;/code&gt; member, which forces the union to be double-word aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d312a53d8e7c9544d42f284a8fb92ee207ce56" translate="yes" xml:space="preserve">
          <source>This is an implementation of the ISO C99 function &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb58cdaec11ea8785a298afd036692620cb8a71" translate="yes" xml:space="preserve">
          <source>This is because 2147483648 cannot fit in the type &lt;code&gt;int&lt;/code&gt;, so (following the ISO C rules) its data type is &lt;code&gt;unsigned long int&lt;/code&gt;. Negating this value yields 2147483648 again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcf60838e5c265166bf0d438d003168c4b74356" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are considered relevant with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5195f538541a2304ddd489646469dec48a8ccb37" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are optimized for size. Small growth may be desirable to anticipate optimization oppurtunities exposed by inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6762670483f9855e0a3aefbae371bb5703501c2b" translate="yes" xml:space="preserve">
          <source>This is called a &lt;em&gt;matching constraint&lt;/em&gt; and what it really means is that the assembler has only a single operand that fills two roles which &lt;code&gt;asm&lt;/code&gt; distinguishes. For example, an add instruction uses two input operands and an output operand, but on most CISC machines an add instruction really has only two operands, one of them an input-output operand:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c074cd27c3a79447115b4b73b7a639c3b4fa2a8e" translate="yes" xml:space="preserve">
          <source>This is currently implemented using the stronger &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; memory order because of a deficiency in C++11&amp;rsquo;s semantics for &lt;code&gt;memory_order_consume&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3d9a8a2627972c9a778aee53c0d0ec3f855978" translate="yes" xml:space="preserve">
          <source>This is dependent on the implementation of the C library, and is not defined by GCC itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7b67a920492c1fed38bbae2d29e3b5c143fedc" translate="yes" xml:space="preserve">
          <source>This is enabled by default when outputting DWARF 2 debug information at the normal level, as long as there is assembler support,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ef91485a4d9927171b8579ed4d91ac7ed3d923" translate="yes" xml:space="preserve">
          <source>This is equivalent to writing the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebe9f9ed1ec955a9599f55edc4af825e40a4ee7" translate="yes" xml:space="preserve">
          <source>This is generally desirable, because assembler-generated line-number tables are a lot more compact than those the compiler can generate itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbcbb929b36a00d46e328a1a9742a8d812ee911" translate="yes" xml:space="preserve">
          <source>This is how GCC traditionally handled functions declared &lt;code&gt;inline&lt;/code&gt;. Since ISO C99 specifies a different semantics for &lt;code&gt;inline&lt;/code&gt;, this function attribute is provided as a transition measure and as a useful feature in its own right. This attribute is available in GCC 4.1.3 and later. It is available if either of the preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; or &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; are defined. See &lt;a href=&quot;inline#Inline&quot;&gt;An Inline Function is As Fast As a Macro&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3659f6c91bb02b5cd8a55719f9462825417fbf7f" translate="yes" xml:space="preserve">
          <source>This is in all ways equivalent to the ISO C example above, but arguably more readable and descriptive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e833378dc7330796a80aef851e1b40fc5a1e0901" translate="yes" xml:space="preserve">
          <source>This is just like &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87943af8f7660938d198a190217b23c8ea1f6e48" translate="yes" xml:space="preserve">
          <source>This is like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d0e0a31c79678362e2daef4bb85a617b64f850" translate="yes" xml:space="preserve">
          <source>This is more friendly to code living in shared libraries, as it reduces the number of dynamic relocations that are needed, and by consequence, allows the data to be read-only. This alternative with label differences is not supported for the AVR target, please use the first approach for AVR programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f8a99adebca7a079e1f334d570e3be716912f1" translate="yes" xml:space="preserve">
          <source>This is not correct on x86-64 as it would allocate tick in either &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. You have to use the following variant instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c90434e16b0f55c0b872ec23da22fc830bc9a4" translate="yes" xml:space="preserve">
          <source>This is particularly useful for assumed-shape arrays in Fortran where (for example) it allows better vectorization assuming contiguous accesses. This flag is enabled by default at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031672016e4d502c018309428e47661800aac1a9" translate="yes" xml:space="preserve">
          <source>This is similar to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5bdec22d274cc0ce57cbe3e424189dc32fd8d9a" translate="yes" xml:space="preserve">
          <source>This is the C variable or expression being passed to the &lt;code&gt;asm&lt;/code&gt; statement as input. The enclosing parentheses are a required part of the syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08fb1a095794b3c3899440175335ee88759da275" translate="yes" xml:space="preserve">
          <source>This is the default (normal) setting. The only traps that are enabled are the ones that cannot be disabled in software (e.g., division by zero trap).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4c45120ca7a63ffc2a2ee3465224f90ffe09ce" translate="yes" xml:space="preserve">
          <source>This is the default choice for non-Darwin x86-32 targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c124a9358a8d1126f10890f1eb504cdd7df946" translate="yes" xml:space="preserve">
          <source>This is the default choice for the x86-64 compiler, Darwin x86-32 targets, and the default choice for x86-32 targets with the SSE2 instruction set when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72e96be7931cf0f817380bd16aa70bcfafbbfe8" translate="yes" xml:space="preserve">
          <source>This is the default warning level of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf92c2da398ed082aa03bcf05470475390ec8ef" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic exchange. It stores the contents of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The original value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is copied into &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544eb750f0727dd454c0757327b302d011f9d8e4" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic load. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; in &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21175b474269d19f2c711f8904d430397eb7f000" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic store. It stores the value of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38581f9b32f6622e3fe0d5bb58e5ec8a4bb25cbf" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with round-to-nearest-or-even rounding mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2425d7e7a37939aa94f7a4685eaf2c7dc785155a" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with truncating (i.e. round towards zero) rounding mode. That includes conversion from floating point to integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b95ca7a0555a082526c5eeface6f56baa751e7" translate="yes" xml:space="preserve">
          <source>This is the mode used to perform integer calculations in the FPU, e.g. integer multiply, or integer multiply-and-accumulate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4098e33c6565f575396e0bc34dbbf7c96adebca6" translate="yes" xml:space="preserve">
          <source>This is the same as &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f530e06bab16bd703cfd6e987a5d2afe910c22" translate="yes" xml:space="preserve">
          <source>This is the simplest option, but also offers flexibility and fine-grained control when necessary. It is also the most portable alternative and programs using this approach will work with most modern compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ad0261cb0958c1d426eccb32a1c93544a5dc43" translate="yes" xml:space="preserve">
          <source>This is the warning level of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e89dce84a517cc123ca42eb8de81a6643ce569" translate="yes" xml:space="preserve">
          <source>This is the warning level that is enabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760cf4bac038578756206c93dae00fb9cba073c6" translate="yes" xml:space="preserve">
          <source>This is typical output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7f2d31c6f9672e3ba4ae5efbb305bb596a464e" translate="yes" xml:space="preserve">
          <source>This is useful when &lt;code&gt;gcc&lt;/code&gt; prints the error message &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61900c28d4f89d472663c0fb34d75c4a85cd7c53" translate="yes" xml:space="preserve">
          <source>This is useful when you use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f021b4a2b4ebd3ad97c6de7e5e1dd3f9efc1450f" translate="yes" xml:space="preserve">
          <source>This is why GCC does and will treat plain bit-fields in the same fashion on all types of machines (by default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="700e39a7f2669dafee2d84e8e1e01bff08feb798" translate="yes" xml:space="preserve">
          <source>This macro reflects the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1653245bf51b1f0c3c2fa674b4064d9aab7d9670" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 9.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e0ea996271f7db110a1aacecb995078842dd10" translate="yes" xml:space="preserve">
          <source>This mechanism is not intended to be a replacement for &lt;code&gt;+initialize&lt;/code&gt;. You should be aware of its limitations when you decide to use it instead of &lt;code&gt;+initialize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b86e98dae575f25e7dd277f55069259f5a76e0f" translate="yes" xml:space="preserve">
          <source>This might appear strange; if an insn allows a constant operand with a value not known at compile time, it certainly must allow any known value. So why use &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b2398d0b07a68172b830b044a2e5af1fdcea09" translate="yes" xml:space="preserve">
          <source>This number is allowed to be more than a single digit. If multiple digits are encountered consecutively, they are interpreted as a single decimal integer. There is scant chance for ambiguity, since to-date it has never been desirable that &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e75e50204b22e1eb4e9e0ef88e476b337f8735" translate="yes" xml:space="preserve">
          <source>This occurs because sometimes GCC optimizes the variable out of existence. There is no way to tell the debugger how to compute the value such a variable &amp;ldquo;would have had&amp;rdquo;, and it is not clear that would be desirable anyway. So GCC simply does not mention the eliminated variable when it writes debugging information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce0fa0b0cabdd9e15b52efa7f6d71eba5c1f802" translate="yes" xml:space="preserve">
          <source>This only makes sense when scheduling after register allocation, i.e. with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db13c5371ec3d6856069cde7f84c42a79ba4d667" translate="yes" xml:space="preserve">
          <source>This optimization is automatically turned off in the presence of exception handling or unwind tables (on targets using setjump/longjump or target specific scheme), for linkonce sections, for functions with a user-defined section attribute and on any architecture that does not support named sections. When</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a904b6f6255ac7a46cba1abdfa2fc80dcd97c1" translate="yes" xml:space="preserve">
          <source>This optimization is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd622740636a8f6bc187abc5bbcb4be9fb8826dc" translate="yes" xml:space="preserve">
          <source>This optimization is off by default at all optimization levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c9c932cfd47ab32407f6161d42f932d1499bb6" translate="yes" xml:space="preserve">
          <source>This option allows further control over excess precision on machines where floating-point operations occur in a format with more precision or range than the IEEE standard and interchange floating-point types. By default,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd275b48533fab7a99c41cb026721abbe83dfbd" translate="yes" xml:space="preserve">
          <source>This option allows use of a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) together with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="176e6d10a5020dcedfe440b551f5e25423a91471" translate="yes" xml:space="preserve">
          <source>This option also enables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44de7a78056937b7baedfa3be44429b20f8420b9" translate="yes" xml:space="preserve">
          <source>This option also warns when &lt;code&gt;alloca&lt;/code&gt; is used in a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcb0d8b589589b99a6d5de3a4fa4b5fc06db20b" translate="yes" xml:space="preserve">
          <source>This option also warns when a non-volatile automatic variable might be changed by a call to &lt;code&gt;longjmp&lt;/code&gt;. The compiler sees only the calls to &lt;code&gt;setjmp&lt;/code&gt;. It cannot know where &lt;code&gt;longjmp&lt;/code&gt; will be called; in fact, a signal handler could call it at any point in the code. As a result, you may get a warning even when there is in fact no problem because &lt;code&gt;longjmp&lt;/code&gt; cannot in fact be called at the place that would cause a problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647a82f2f84be9cba875128f0dca433a10d57f59" translate="yes" xml:space="preserve">
          <source>This option and its counterpart,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f89764d458f9e6ce2a9e5debf60911dcf32abd" translate="yes" xml:space="preserve">
          <source>This option can be overridden for individual functions with the &lt;code&gt;hotpatch&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6031ab076087301a6d0abbb423cf52dcdfaad6ad" translate="yes" xml:space="preserve">
          <source>This option can be used with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffe3df6bb53541974a1831b4cc4d1b56a60baa8e" translate="yes" xml:space="preserve">
          <source>This option can lead to reduced code size for functions that perform several calls to functions that get their arguments on the stack like calls to printf-like functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659720e1c331361819e1f19306618a073823d1ae" translate="yes" xml:space="preserve">
          <source>This option can only be used if the target architecture supports branch-likely instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3a9caac6f7198e302fb437322053279f7c71d0" translate="yes" xml:space="preserve">
          <source>This option cannot be suffixed by feature modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c576211fac72dc023de0044164971c10d96f526d" translate="yes" xml:space="preserve">
          <source>This option causes GCC to create markers in the internal representation at the beginning of statements, and to keep them roughly in place throughout compilation, using them to guide the output of &lt;code&gt;is_stmt&lt;/code&gt; markers in the line number table. This is enabled by default when compiling with optimization (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c8757dd3d3337f46ca394f8f8769868a644ecd" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be treated as fixed registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e090b60ad88e1f4ec2772be778990575505b68" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be used in the code generated by the compiler. This setting is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d04b742fdf172a830cc81fd460a113af18fcfc" translate="yes" xml:space="preserve">
          <source>This option causes run-time data structures to be built at program startup, which are used for verifying the vtable pointers. The options &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26b4242bc022197a5b469c4333379231dcfd91c" translate="yes" xml:space="preserve">
          <source>This option causes the compiler to abort compilation on the first error occurred rather than trying to keep going and printing further error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e90ed4f8d16ef658451b5bbc4a698c1ccbdaac4" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__FAST_MATH__&lt;/code&gt; to be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f74610163bdce44c421694716dba7eea2f36f3" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; to be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc144b835e4ef20a9b868419ab10431eef1dc3bb" translate="yes" xml:space="preserve">
          <source>This option controls stack space reuse for user declared local/auto variables and compiler generated temporaries. &lt;var&gt;reuse_level&lt;/var&gt; can be &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a88d1554ed1aa2b217aa4277399c9f56f7ad9c" translate="yes" xml:space="preserve">
          <source>This option controls the code generation of the link time optimizer. By default the linker output is determined by the linker plugin automatically. For debugging the compiler and in the case of incremental linking to non-lto object file is desired, it may be useful to control the type manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9b7ff3f71ba23e9705b0d93e8591071e6bba1a" translate="yes" xml:space="preserve">
          <source>This option controls the default setting of the ISO C99 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; pragma. Nevertheless, the option applies to all languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149f5a9a7f4ee5991089ef9512f0da137f76588e" translate="yes" xml:space="preserve">
          <source>This option controls the minimum width of the left margin printed by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37de330d3f523306c4e20d85e9fac76a8d0f7abf" translate="yes" xml:space="preserve">
          <source>This option controls the priority that is assigned to dispatch-slot restricted instructions during the second scheduling pass. The argument &lt;var&gt;priority&lt;/var&gt; takes the value &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ce7609ded1a0ff2fbbb9740f9f2209c0f8ef1e" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects a software-managed cache for accessing variables in the &lt;code&gt;__ea&lt;/code&gt; address space with a particular cache size. Possible options for &lt;var&gt;cache-size&lt;/var&gt; are &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9caa6f342fbdbf76f119015b6337636546395e60" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects whether atomic updates to the software-managed cache of PPU-side variables are used. If you use atomic updates, changes to a PPU variable from SPU code using the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier do not interfere with changes to other PPU variables residing in the same cache line from PPU code. If you do not use atomic updates, such interference may occur; however, writing back cache lines is more efficient. The default behavior is to use atomic updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e0eea7f94b4ed1e828e2932547c5127c9ba599" translate="yes" xml:space="preserve">
          <source>This option controls what floating-point related traps are enabled. Other Alpha compilers call this option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1154974a88b020f8daf5bb4dc20170e8131c728" translate="yes" xml:space="preserve">
          <source>This option controls whether any out-of-line instance of the &lt;code&gt;__sync&lt;/code&gt; family of functions may be used to implement the C++11 &lt;code&gt;__atomic&lt;/code&gt; family of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a02927707c45d100e334cb80281cfb05688e67" translate="yes" xml:space="preserve">
          <source>This option controls which NOP insertion scheme is used during the second scheduling pass. The argument &lt;var&gt;scheme&lt;/var&gt; takes one of the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08ef18f138d574270868ecf3d1af53b2152507f" translate="yes" xml:space="preserve">
          <source>This option controls which dependences are considered costly by the target during instruction scheduling. The argument &lt;var&gt;dependence_type&lt;/var&gt; takes one of the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabb06a775f104526b72d8801ca8d34d938d08ee" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61955646b487d462957b5ea4ab670cca58e8127" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &lt;code&gt;!&lt;/code&gt; to invert the option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ecce718b608dfca621af1742e2244436537a5c" translate="yes" xml:space="preserve">
          <source>This option currently only works for RTL dumps, and the RTL is always dumped in slim form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0efcaa928c1eb50d04d69e5ea5969a7461e4235" translate="yes" xml:space="preserve">
          <source>This option defaults to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc2236cfdc032c6f548639c70136cdca6a33540" translate="yes" xml:space="preserve">
          <source>This option disables a target-specific pass in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70b4cbddab92e21116da323b06dd29142551856" translate="yes" xml:space="preserve">
          <source>This option disables all previously enabled sanitizers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331b4b3e9a10408d9fe49b419ac451d5b43afbf6" translate="yes" xml:space="preserve">
          <source>This option does not affect the behavior of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654b3209c6de0a321e02002e434d9a9983c5a1bb" translate="yes" xml:space="preserve">
          <source>This option does not suppress the preprocessor&amp;rsquo;s debug output, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90399aa992409c6c8444d2b7bc23fef6bd0b23f1" translate="yes" xml:space="preserve">
          <source>This option does not warn about designated initializers, so the following modification does not trigger a warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637d485d36be088d5dc6290430edcc3559942fb2" translate="yes" xml:space="preserve">
          <source>This option does not work in the presence of shared libraries or nested functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6cfd2996b7bd042cf9971ccd157a3b5ed5d4172" translate="yes" xml:space="preserve">
          <source>This option enable the compiler to emit &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; instructions. These instructions are only valid for CPUs with code-density feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36e3ffcf2c8e8b04ebd85e66df66aa0c1508360" translate="yes" xml:space="preserve">
          <source>This option enables GCC to generate &lt;code&gt;CMPXCHG16B&lt;/code&gt; instructions in 64-bit code to implement compare-and-exchange operations on 16-byte aligned 128-bit objects. This is useful for atomic updates of data structures exceeding one machine word in size. The compiler uses this instruction to implement &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;. However, for &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt; operating on 128-bit integers, a library call is always used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111a14f183c415ed55eeae4c39a6e2dbf86ced81" translate="yes" xml:space="preserve">
          <source>This option enables a predefined, named set of custom instruction encodings (see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bfbfd499b3c5f5bc13445a47161400b4906077" translate="yes" xml:space="preserve">
          <source>This option enables built-in functions &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; and &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; to generate the &lt;code&gt;crc32&lt;/code&gt; machine instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd918ec8f0e039c766cf7fe1d48f22e6df60ce4" translate="yes" xml:space="preserve">
          <source>This option enables checking of alignment of pointers when they are dereferenced, or when a reference is bound to insufficiently aligned target, or when a method or constructor is invoked on insufficiently aligned object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50199f80fe90cda9539f52ff8308973833026d26" translate="yes" xml:space="preserve">
          <source>This option enables checking that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc. This option has two suboptions,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b4168b985dbcf1d69994ce5cb2c45b6d1daccb" translate="yes" xml:space="preserve">
          <source>This option enables checking that the second argument of a shift operation is not negative and is smaller than the precision of the promoted first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938ba4d02fa2f3fd34289d2d8d2d36eb752b42e2" translate="yes" xml:space="preserve">
          <source>This option enables floating-point type to integer conversion checking. We check that the result of the conversion does not overflow. Unlike other similar options,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be71ee2359ef67de5a090bb541bf4acc1394953" translate="yes" xml:space="preserve">
          <source>This option enables functions to be overloaded for ordinary and UTF-8 strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c29fc89d033f54fcdc9384885989225fe300ca" translate="yes" xml:space="preserve">
          <source>This option enables generation of &lt;code&gt;SAHF&lt;/code&gt; instructions in 64-bit code. Early Intel Pentium 4 CPUs with Intel 64 support, prior to the introduction of Pentium 4 G1 step in December 2005, lacked the &lt;code&gt;LAHF&lt;/code&gt; and &lt;code&gt;SAHF&lt;/code&gt; instructions which are supported by AMD64. These are load and store instructions, respectively, for certain status flags. In 64-bit mode, the &lt;code&gt;SAHF&lt;/code&gt; instruction is used to optimize &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;drem&lt;/code&gt;, and &lt;code&gt;remainder&lt;/code&gt; built-in functions; see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9eedf73e4d0015fa244bb4f5c3569d74469415" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of C++ member function calls, member accesses and some conversions between pointers to base and derived classes, to verify the referenced object has the correct dynamic type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd18b0f972bb3a966564c3387d23513ed8f1114" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of arguments to selected builtin functions. If an invalid value is passed to such arguments, a run-time error is issued. E.g. passing 0 as the argument to &lt;code&gt;__builtin_ctz&lt;/code&gt; or &lt;code&gt;__builtin_clz&lt;/code&gt; invokes undefined behavior and is diagnosed by this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4707da904f3b017d856d15dd2d0965e19870e1d8" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of array bounds. Various out of bounds accesses are detected. Flexible array members, flexible array member-like arrays, and initializers of variables with static storage are not instrumented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e349da95c57c4503e630d88b725ecb09ef50689" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of calls, checking whether null values are not passed to arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d56bee13b4f38d072afa312adba62366dd96324" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from an enum type. If a value outside the range of values for the enum type is loaded, a run-time error is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bae34f78ab33cc208a29bdcebb31b30f37fdfdb" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from bool. If a value other than 0/1 is loaded, a run-time error is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c1b7dde6bdde5a1a374986dc5119119957fbe3" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of memory references using the &lt;code&gt;__builtin_object_size&lt;/code&gt; function. Various out of bounds pointer accesses are detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0292138149978c95eacc8642af7ff43cfe7b2264" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of pointer arithmetics. If the pointer arithmetics overflows, a run-time error is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430110abdd161cbe658a0d2f529325e1208cd453" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of return statements in functions marked with &lt;code&gt;returns_nonnull&lt;/code&gt; function attribute, to detect returning of null values from such functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb16ef94b917da96c006db5cf05527388bed65b9" translate="yes" xml:space="preserve">
          <source>This option enables or disables warnings about conflicts between the MCU name specified by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f864b078493b6651bb86e363b143af67066fe079" translate="yes" xml:space="preserve">
          <source>This option enables pointer checking. Particularly, the application built with this option turned on will issue an error message when it tries to dereference a NULL pointer, or if a reference (possibly an rvalue reference) is bound to a NULL pointer, or if a method is invoked on an object pointed by a NULL pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9390f84ab3c6840aa43bf14f385886239ff26f9c" translate="yes" xml:space="preserve">
          <source>This option enables return statement checking. Programs built with this option turned on will issue an error message when the end of a non-void function is reached without actually returning a value. This option works in C++ only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e06b2ed5aaf18ef55b254444b859dc73b64e5e" translate="yes" xml:space="preserve">
          <source>This option enables signed integer overflow checking. We check that the result of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and both unary and binary &lt;code&gt;-&lt;/code&gt; does not overflow in the signed arithmetics. Note, integer promotion rules must be taken into account. That is, the following is not an overflow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa6ebd08f1df0b8312082dee55c79f646e3aa80" translate="yes" xml:space="preserve">
          <source>This option enables strict instrumentation of array bounds. Most out of bounds accesses are detected, including flexible array members and flexible array member-like arrays. Initializers of variables with static storage are not instrumented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35547d9fdeedd115e10a5da6add0bd1af02febf6" translate="yes" xml:space="preserve">
          <source>This option enables the extraction of object files with GIMPLE bytecode out of library archives. This improves the quality of optimization by exposing more code to the link-time optimizer. This information specifies what symbols can be accessed externally (by non-LTO object or during dynamic linking). Resulting code quality improvements on binaries (and shared libraries that use hidden visibility) are similar to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e139de52e12e355ab2f4aceaceda024599afb6f0" translate="yes" xml:space="preserve">
          <source>This option enables use of &lt;code&gt;RCPSS&lt;/code&gt; and &lt;code&gt;RSQRTSS&lt;/code&gt; instructions (and their vectorized variants &lt;code&gt;RCPPS&lt;/code&gt; and &lt;code&gt;RSQRTPS&lt;/code&gt;) with an additional Newton-Raphson step to increase precision instead of &lt;code&gt;DIVSS&lt;/code&gt; and &lt;code&gt;SQRTSS&lt;/code&gt; (and their vectorized variants) for single-precision floating-point arguments. These instructions are generated only when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060df32e86c55ba7cad1df047f45c9f196518594" translate="yes" xml:space="preserve">
          <source>This option enables use of the &lt;code&gt;movbe&lt;/code&gt; instruction to implement &lt;code&gt;__builtin_bswap32&lt;/code&gt; and &lt;code&gt;__builtin_bswap64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be41468437cbd33ddbb5938cf95baa409134252" translate="yes" xml:space="preserve">
          <source>This option enables use of the reciprocal estimate and reciprocal square root estimate instructions with additional Newton-Raphson steps to increase precision instead of doing a divide or square root and divide for floating-point arguments. You should use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b0cc8f7ad08d6547ab80b77c947a16db351cd7" translate="yes" xml:space="preserve">
          <source>This option forces GCC to use custom shadow offset in AddressSanitizer checks. It is useful for experimenting with different shadow memory layouts in Kernel AddressSanitizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3233daa383d4066b02b1657216dd534dd8974913" translate="yes" xml:space="preserve">
          <source>This option generates traps for signed overflow on addition, subtraction, multiplication operations. The options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc361006809087722b4665eda3af889c660cf7bb" translate="yes" xml:space="preserve">
          <source>This option has no effect on abicalls code. The default is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce202009f104c41c762f668a2d6d18c3bbd55f2a" translate="yes" xml:space="preserve">
          <source>This option ignored; it is provided for compatibility purposes only. Software floating-point code is emitted by default, and this default can overridden by FPX options;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d295e879be9d8d469fabe64723a6a09c1d8dadcc" translate="yes" xml:space="preserve">
          <source>This option implies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef84b2b0112928af774bc0bf4f11244d39995fa" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68020 and 68881/68882 instructions that have to be emulated by software on the 68060. Use this option if your 68060 does not have code to emulate those instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb405ef4149f232764b47255e26eb73c1775fc9" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68881/68882 instructions that have to be emulated by software on the 68040. Use this option if your 68040 does not have code to emulate those instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c66bcd77c8bed54eff907c145c1ea37c3f6555" translate="yes" xml:space="preserve">
          <source>This option instructs CPP to add a phony target for each dependency other than the main file, causing each to depend on nothing. These dummy rules work around errors &lt;code&gt;make&lt;/code&gt; gives if you remove header files without updating the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c687d2d1d2116a0ccc32795fd0f0f68e88ed641" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to dump the names of the x86 performance tuning features and default settings. The names can be used in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a021cb20751050e831beceef3d4668ce4cf298" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;cld&lt;/code&gt; instruction in the prologue of functions that use string instructions. String instructions depend on the DF flag to select between autoincrement or autodecrement mode. While the ABI specifies the DF flag to be cleared on function entry, some operating systems violate this specification by not clearing the DF flag in their exception dispatchers. The exception handler can be invoked with the DF flag set, which leads to wrong direction mode when string instructions are used. This option can be enabled by default on 32-bit x86 targets by configuring GCC with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657b508727e487887f711193a95e39499f48960e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;vzeroupper&lt;/code&gt; instruction before a transfer of control flow out of the function to minimize the AVX to SSE transition penalty as well as remove unnecessary &lt;code&gt;zeroupper&lt;/code&gt; intrinsics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c78872fcf66a452b582423621f5fae766269c85" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to turn off all tunable features. See also</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9dd501c30e561cb69d40cbc9373ad471302725" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use 128-bit AVX instructions instead of 256-bit AVX instructions in the auto-vectorizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6945bdd3deb13214c6bf659bc52045e04a70f0e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use &lt;var&gt;opt&lt;/var&gt;-bit vector width in instructions instead of default on the selected platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbda0a70a5f352dad89f90d04caa28e3bd6d0703" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that pointer arithmetic overflow on addition and subtraction wraps around using twos-complement representation. This flag disables some optimizations which assume pointer overflow is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f816312ce41ee12df0f414176d9a5763b90df530" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that signed arithmetic overflow of addition, subtraction and multiplication wraps around using twos-complement representation. This flag enables some optimizations and disables others. The options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c431c0c08a8246794b17639d38f5f9732adef200" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to check that the size of a variable length array is positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3ab8d594e88fea27629172c62534cedd7e9ccd" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to generate code for a 16-entry register file. This option defines the &lt;code&gt;__ARC_RF16__&lt;/code&gt; preprocessor macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b138f51e639bc0b32ca1dc63d0195b9a7cfb2e6c" translate="yes" xml:space="preserve">
          <source>This option is a detailed version of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0777795174f336ed7d700a302e0b548f3225ecd3" translate="yes" xml:space="preserve">
          <source>This option is also passed on to the assembler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8a587d88750f4b64f0573d837060922995e692" translate="yes" xml:space="preserve">
          <source>This option is always enabled by default on certain machines, usually those which have no call-preserved registers to use instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c9194e0e60c9d507f16257e56fa4da6140cc2a" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a DLL&amp;mdash;a dynamic link library&amp;mdash;is to be generated, enabling the selection of the required runtime startup object and entry point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34974b8a3ddccb37978e6f7f3ab9b870fb775b53" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a GUI application is to be generated by instructing the linker to set the PE header subsystem type appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c956bb65a4ef29b2924781000ede172dfe35c9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the &lt;code&gt;dllimport&lt;/code&gt; attribute should be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0dc3ae21d5985659301b368b4c95c1db9366f7" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the GNU extension to the PE file format that permits the correct alignment of COMMON variables should be used when generating code. It is enabled by default if GCC detects that the target assembler found during configuration supports the feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9161324109587b09b1694f29c23c72102885dbb9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the typical Microsoft Windows predefined macros are to be set in the pre-processor, but does not influence the choice of runtime library/startup code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0a3afbd291f88cb3c95726f31687bd36f164b7" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW and Cygwin targets. It specifies that relocated-data in read-only section is put into the &lt;code&gt;.data&lt;/code&gt; section. This is a necessary for older runtimes not supporting modification of &lt;code&gt;.rdata&lt;/code&gt; sections for pseudo-relocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdd2b492fbf0ebaa317f2c48f132b3b62ecde92" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that MinGW-specific thread support is to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faee952b0f4c06ee910b880bfbdf149d4685f355" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that the executable flag for the stack used by nested functions isn&amp;rsquo;t set. This is necessary for binaries running in kernel mode of Microsoft Windows, as there the User32 API, which is used to set executable privileges, isn&amp;rsquo;t available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e934759656573ab06e7b01542f8d07b3197cbe74" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW-w64 targets. It causes the &lt;code&gt;UNICODE&lt;/code&gt; preprocessor macro to be predefined, and chooses Unicode-capable runtime startup code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2059e693abf7ce7ec777bf5e7cc1b18ffae32137" translate="yes" xml:space="preserve">
          <source>This option is deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aabeb9acbf850798bff5dd7ad77029ce8ab9ac73" translate="yes" xml:space="preserve">
          <source>This option is deprecated. It pads structures to multiple of 4 bytes, which is incompatible with the SH ABI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d29c4b41311afb57bb108b16e155cb489ec134b" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4053a3fd19d3968881e6f8e01595ecadbdd30069" translate="yes" xml:space="preserve">
          <source>This option is enabled at level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf488b640ab82c12aa83d2d5d585a8acb0774751" translate="yes" xml:space="preserve">
          <source>This option is enabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1ed53d314baadd464fa2b14f3800bf95fa8ca0" translate="yes" xml:space="preserve">
          <source>This option is enabled by default at optimization levels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d247bcb1695bed692a8726f3533be3d2fb1fee0b" translate="yes" xml:space="preserve">
          <source>This option is enabled by default for Microsoft Windows targets. This behavior can also be controlled locally by use of variable or type attributes. For more information, see &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; and &lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86 Type Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2652d68534c6f88541191086fa1485e27def7fc6" translate="yes" xml:space="preserve">
          <source>This option is enabled by default on most targets. On Nios II ELF, it defaults to off. On AVR, CR16, and MSP430, this option is completely disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8c17f97f0a71b6e6913867ec6d9569fa353e80" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when LTO support in GCC is enabled and GCC was configured for use with a linker supporting plugins (GNU ld 2.21 or newer or gold).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d53846e4ad58929426e4a8a561e1ca04e4dae26" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when the RH850 ABI is in use (see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f3025aa92d2d4f667e2309b49f93dcbd8a2cc1" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that affect signaling NaN behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf7bb3d6ca95f65181405f388dc4f38acb33184" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that are affected by rounding mode. Future versions of GCC may provide finer control of this setting using C99&amp;rsquo;s &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma. This command-line option will be used to specify the default state for &lt;code&gt;FENV_ACCESS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c5b1ff9a4b2c16f0283cc8b3e6a1c1ee4e99a0" translate="yes" xml:space="preserve">
          <source>This option is experimental and the format of the data within the compressed JSON file is subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c067b7272c8dfb1940d673f7549a9c970673d8" translate="yes" xml:space="preserve">
          <source>This option is ignored and provided for compatibility purposes only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39bc415cf1072ef041b852cccab7caeb03cebbe9" translate="yes" xml:space="preserve">
          <source>This option is implicitly passed to the compiler for the second compilation requested by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223090f1188ac1bc38c64fe292f4f4b2503fac75" translate="yes" xml:space="preserve">
          <source>This option is implied by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9711864ac531d244797123498f9a9fe143b47ace" translate="yes" xml:space="preserve">
          <source>This option is left for compatibility reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705dd214fcbbda555d2c25430996631d43106884" translate="yes" xml:space="preserve">
          <source>This option is like the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea37451ed423d9b4f565d2cd48781668a2b5f65" translate="yes" xml:space="preserve">
          <source>This option is not turned on by any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9abb00a56e1a1d91dc73fdc3ecd2a22dd97e1ddc" translate="yes" xml:space="preserve">
          <source>This option is off by default, because the resulting preprocessed output is only really suitable as input to GCC. It is switched on by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3ef2c8071d14f453caa189ada503a69384e247" translate="yes" xml:space="preserve">
          <source>This option is only active when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6188b363cf7403f6936d8ff4d2c56a28d236e61" translate="yes" xml:space="preserve">
          <source>This option is only active when signed overflow is undefined. It warns about cases where the compiler optimizes based on the assumption that signed overflow does not occur. Note that it does not warn about all cases where the code might overflow: it only warns about cases where the compiler implements some optimization. Thus this warning depends on the optimization level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d25fc758589cd4be71db515ac5f7ca7241f83be" translate="yes" xml:space="preserve">
          <source>This option is only available for ARCv2 cores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47efc2541291ec81a8db6b59aeed231c895bc9c4" translate="yes" xml:space="preserve">
          <source>This option is only available when compiling C++ code. It turns on (or off, if using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33ea172ac2795eac5ebb478ce17a5afc41091f3" translate="yes" xml:space="preserve">
          <source>This option is only intended to be useful when developing GCC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034517546050c1e22d79385d031d17520c531cb2" translate="yes" xml:space="preserve">
          <source>This option is only useful for debugging GCC. When used from CPP or with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b6c3c24d858a91f50ac46c4cd92ae8eecb3f01" translate="yes" xml:space="preserve">
          <source>This option is passed to the assembler and linker, and allows the linker to perform certain optimizations that cannot be done until the final link.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b562e6b75c17a9e319c7220a396dd42baef9b10e" translate="yes" xml:space="preserve">
          <source>This option is supported from MIPS Release 6 onwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69521eee9b087ee047a6dc4f213a5e965016b754" translate="yes" xml:space="preserve">
          <source>This option is the default for optimized compilation if the assembler and linker support it. Use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6be6b9afb7bd451d149acef44e3204c0799fa3d" translate="yes" xml:space="preserve">
          <source>This option is used internally by the compiler to select and build multilibs for architectures &lt;code&gt;avr2&lt;/code&gt; and &lt;code&gt;avr25&lt;/code&gt;. These architectures mix devices with and without &lt;code&gt;SPH&lt;/code&gt;. For any setting other than</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929f4574a14bae8a52d6ca406bb8cbc25e260697" translate="yes" xml:space="preserve">
          <source>This option is used internally for multilib selection. It is not an optimization option, and you don&amp;rsquo;t need to set it by hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc2eb8f428f100756f402b24615715e373e0e44" translate="yes" xml:space="preserve">
          <source>This option is used to compile and link code instrumented for coverage analysis. The option is a synonym for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d0c19a39e93a3e805a541c3dbbe3e7dee413d8" translate="yes" xml:space="preserve">
          <source>This option is used to do fine grain control of x86 code generation features. &lt;var&gt;feature-list&lt;/var&gt; is a comma separated list of &lt;var&gt;feature&lt;/var&gt; names. See also</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b5652a39108319ff242af91d4906cb16765dd8" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t effective unless you either provide profile feedback (see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad34c4a13c209b4406d2d95140526d0990b695b" translate="yes" xml:space="preserve">
          <source>This option makes symbolic debugging impossible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f70581e1a11d2a9335f77e119a8e847340333cc1" translate="yes" xml:space="preserve">
          <source>This option marks the generated code as IEEE conformant. You must not use this option unless you also specify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ded195f72714a7729c2ba3f65b232ddd1df723" translate="yes" xml:space="preserve">
          <source>This option may generate better or worse code; results are highly dependent on the structure of loops within the source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf0c177eee46432379774f3339106e6fdf38879" translate="yes" xml:space="preserve">
          <source>This option only has an effect when optimizing for the VR4130. It normally makes code faster, but at the expense of making it bigger. It is enabled by default at optimization level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6cda42cf644e48c433b85f306f3dac6f8ee9b8" translate="yes" xml:space="preserve">
          <source>This option passes on a request to assembler to enable the fixes for the named silicon errata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845f7cfd869d00c4405522a461f9c235cb5eee1d" translate="yes" xml:space="preserve">
          <source>This option passes on a request to the assembler to enable warning messages when a silicon errata might need to be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17f45a4bb601880d3a1ed4ec74cc989340e16f4" translate="yes" xml:space="preserve">
          <source>This option prevents undesirable excess precision on machines such as the 68000 where the floating registers (of the 68881) keep more precision than a &lt;code&gt;double&lt;/code&gt; is supposed to have. Similarly for the x86 architecture. For most programs, the excess precision does only good, but a few programs rely on the precise definition of IEEE floating point. Use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c0b69978ecc16b1bd0d2e9088bf661716f775e" translate="yes" xml:space="preserve">
          <source>This option provides a seed that GCC uses in place of random numbers in generating certain symbol names that have to be different in every compiled file. It is also used to place unique stamps in coverage data files and the object files that produce them. You can use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9dc1b607f48375a6d4f6012661eaa5b1b5ed1be" translate="yes" xml:space="preserve">
          <source>This option results in less efficient code, but some strange hacks that alter the assembler output may be confused by the optimizations performed when this option is not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c631110b4d2abceaccb1bae4ccf22e852178fc73" translate="yes" xml:space="preserve">
          <source>This option runs the standard link-time optimizer. When invoked with source code, it generates GIMPLE (one of GCC&amp;rsquo;s internal representations) and writes it to special ELF sections in the object file. When the object files are linked together, all the function bodies are read from these ELF sections and instantiated as if they had been part of the same translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42349550220727ae2e299d4a2015499909d245e5" translate="yes" xml:space="preserve">
          <source>This option should be used if accesses to volatile bit-fields (or other structure fields, although the compiler usually honors those types anyway) should use a single access of the width of the field&amp;rsquo;s type, aligned to a natural alignment if possible. For example, targets with memory-mapped peripheral registers might require all such accesses to be 16 bits wide; with this flag you can declare all peripheral bit-fields as &lt;code&gt;unsigned short&lt;/code&gt; (assuming short is 16 bits on these targets) to force GCC to use 16-bit accesses instead of, perhaps, a more efficient 32-bit access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6ef28258c0d1484a7407799fe40321a370f499" translate="yes" xml:space="preserve">
          <source>This option should never be turned on by any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701b657607612b9b9057df52c63d10c751e2ef8a" translate="yes" xml:space="preserve">
          <source>This option should not be used in combination with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0219c53e7274021b5f6207f588b3446cadfa388" translate="yes" xml:space="preserve">
          <source>This option significantly reduces the size of debugging information, with some potential loss in type information to the debugger. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed6d18a71b1db6dc14656f8dda97ef522ec526e" translate="yes" xml:space="preserve">
          <source>This option specifies additional section names that can be accessed via GP-relative addressing. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66f5529b3cbbe7b599cd5d6be9976188f77dac0f" translate="yes" xml:space="preserve">
          <source>This option specifies names of sections that can be accessed via a 16-bit offset from &lt;code&gt;r0&lt;/code&gt;; that is, in the low 32K or high 32K of the 32-bit address space. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2c2ce6a978cb353a59c6932941834cbab3c970" translate="yes" xml:space="preserve">
          <source>This option specifies that a console application is to be generated, by instructing the linker to set the PE header subsystem type required for console applications. This option is available for Cygwin and MinGW targets and is enabled by default on those targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21795b6b968aeddf2d8b82bab0643ab8d796f517" translate="yes" xml:space="preserve">
          <source>This option specifies the &lt;var&gt;executable&lt;/var&gt; that will load the build output file being linked. See man ld(1) for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699a780e6b546e7cd31621b332df13065645e8b9" translate="yes" xml:space="preserve">
          <source>This option specifies the level of compression used for intermediate language written to LTO object files, and is only meaningful in conjunction with LTO mode (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52135fd3bb8dd77ca2f36e74d648a4fe294ca69" translate="yes" xml:space="preserve">
          <source>This option specifies the name of the target ARM processor for which GCC should tune the performance of the code. For some ARM implementations better performance can be obtained by using this option. Permissible names are: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0092bbb4f5a1fce13bf85587ba520d02478db7fa" translate="yes" xml:space="preserve">
          <source>This option specifies where to find the executables, libraries, include files, and data files of the compiler itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fcd55b8224119aadeadea926ce6d80328cc8e5" translate="yes" xml:space="preserve">
          <source>This option substantially reduces the size of debugging information, but at significant potential loss in type information to the debugger. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12955e4ea22dbc03ccc95585111e9bd2b3cf0146" translate="yes" xml:space="preserve">
          <source>This option suppresses generation of the &lt;code&gt;CALLT&lt;/code&gt; instruction for the v850e, v850e1, v850e2, v850e2v3 and v850e3v5 flavors of the v850 architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8fc982c11de8dc3374f1f50078380019a3e1f62" translate="yes" xml:space="preserve">
          <source>This option suppresses the printing of these labels (in the example above, the vertical bars and the &amp;ldquo;char *&amp;rdquo; and &amp;ldquo;long int&amp;rdquo; text).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06538fd1399a51a29e2046a8c18ed4e9d2f3a0ec" translate="yes" xml:space="preserve">
          <source>This option tells the compiler that variables declared in common blocks (e.g. Fortran) may later be overridden with longer trailing arrays. This prevents certain optimizations that depend on knowing the array bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d836f8c7fd152c1f4c1e229195acd7d1d9aa958" translate="yes" xml:space="preserve">
          <source>This option tells the loop optimizer to use language constraints to derive bounds for the number of iterations of a loop. This assumes that loop code does not invoke undefined behavior by for example causing signed integer overflows or out-of-bound array accesses. The bounds for the number of iterations of a loop are used to guide loop unrolling and peeling and loop exit test optimizations. This option is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb8a2fe595c9e8241e6ef6590e0c3c77e876a48" translate="yes" xml:space="preserve">
          <source>This option turns off this behavior because some programs explicitly rely on variables going to the data section&amp;mdash;e.g., so that the resulting executable can find the beginning of that section and/or make assumptions based on that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03fa036158e8a2d0e9cc5e169d9035da63e693f" translate="yes" xml:space="preserve">
          <source>This option warns on all uses of &lt;code&gt;alloca&lt;/code&gt; in the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620c263a82fa884ae16095490ed1aafd4abf9e58" translate="yes" xml:space="preserve">
          <source>This option warns on calls to &lt;code&gt;alloca&lt;/code&gt; with an integer argument whose value is either zero, or that is not bounded by a controlling predicate that limits its value to at most &lt;var&gt;byte-size&lt;/var&gt;. It also warns for calls to &lt;code&gt;alloca&lt;/code&gt; where the bound value is unknown. Arguments of non-integer types are considered unbounded even if they appear to be constrained to the expected range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e70b725867d5de470ac626de798dde99007b65" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support such directives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e38bb2c3d97b5a7df94e2d4b17a0b93c48b4a5" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c545350367038810cd2987773d5c2915271f3c6" translate="yes" xml:space="preserve">
          <source>This option works only with DWARF debug output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbaec7f2023839aa97132788cd132448147454c0" translate="yes" xml:space="preserve">
          <source>This option, recognized for the cris-axis-elf, arranges to link with input-output functions from a simulator library. Code, initialized data and zero-initialized data are allocated consecutively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e5914b613a32a5cb2f8fca3e63e01d9cf519e2" translate="yes" xml:space="preserve">
          <source>This parameter prevents mixed usage of multiple atomic models, even if they are compatible, and makes the compiler generate atomic sequences of the specified model only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5d669f5cfd64a65baaa023d25d50f1d31d908f7" translate="yes" xml:space="preserve">
          <source>This parameter specifies the offset in bytes of the variable in the thread control block structure that should be used by the generated atomic sequences when the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a089b6884ff458754998285328ae2911c61445c4" translate="yes" xml:space="preserve">
          <source>This pass distributes the initialization loops and generates a call to memset zero. For example, the loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c1c873e049f9ba7fb7727e6d4eeb92324da6de" translate="yes" xml:space="preserve">
          <source>This pass only applies to certain targets that cannot explicitly represent the comparison operation before register allocation is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461faf3624a4165b061a68a094b7ad69f3e94c46" translate="yes" xml:space="preserve">
          <source>This pragma allows the user to set the visibility for multiple declarations without having to give each a visibility attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e202730c1bfc48c0778f7ea2bd0c6eb45186cc47" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set global optimization options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;optimize(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;optimize&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9f09620296c49e0c152a1252d539d7a1599030" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set target-specific options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;target(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;target&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5bdf333d1a9b5e255036222cc92af1884c97c92" translate="yes" xml:space="preserve">
          <source>This pragma and the &lt;code&gt;asm&lt;/code&gt; labels extension interact in a complicated manner. Here are some corner cases you may want to be aware of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6ea502dad4ed3727dbc5aab1f84068b260e566" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called after main, or during shared module unloading, by adding a call to the &lt;code&gt;.fini&lt;/code&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef98ac7a5a65ac560b0183a0711ed56313ca3a4" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called during initialization (before &lt;code&gt;main&lt;/code&gt;) or during shared module loading, by adding a call to the &lt;code&gt;.init&lt;/code&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4305b5e7eee9369ab0724af50f66a74eaee06881" translate="yes" xml:space="preserve">
          <source>This pragma clears the current &lt;code&gt;#pragma GCC target&lt;/code&gt; and &lt;code&gt;#pragma GCC optimize&lt;/code&gt; to use the default switches as specified on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86f808ebf265d2793b4414b964c355b2c508a5f" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol1&lt;/var&gt; to be a weak alias of &lt;var&gt;symbol2&lt;/var&gt;. It is an error if &lt;var&gt;symbol2&lt;/var&gt; is not defined in the current translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e41ab6e510f688ee4c0ac9d61fab50b654b5c94" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol&lt;/var&gt; to be weak, as if the declaration had the attribute of the same name. The pragma may appear before or after the declaration of &lt;var&gt;symbol&lt;/var&gt;. It is not an error for &lt;var&gt;symbol&lt;/var&gt; to never be defined at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d680236fdbf196915aaf992aecdb77c6a8b587b" translate="yes" xml:space="preserve">
          <source>This pragma declares variables to be possibly unused. GCC does not produce warnings for the listed variables. The effect is similar to that of the &lt;code&gt;unused&lt;/code&gt; attribute, except that this pragma may appear anywhere within the variables&amp;rsquo; scopes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297d6f917f11b7d696df277d2ac80b8a527dc0e9" translate="yes" xml:space="preserve">
          <source>This pragma gives the C function &lt;var&gt;oldname&lt;/var&gt; the assembly symbol &lt;var&gt;newname&lt;/var&gt;. The preprocessor macro &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; is defined if this pragma is available (currently on all platforms).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d47f09719c8273483bc0daaf5859bab9562dec9" translate="yes" xml:space="preserve">
          <source>This pragma is accepted, but has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d3fa1a452de5b39a96a52139032ce525a57ad0" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented, but the default is to &amp;ldquo;off&amp;rdquo; unless</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0d00bf5dd61e1e80f9e58129099c35fef14b94" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented. Expressions are currently only contracted if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42570b540208a522195f34bdcb31e38a4d6b0221" translate="yes" xml:space="preserve">
          <source>This pragma saves the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the top of the stack for this macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d99cb35c6101970038eaf301a0c3beb6107bf5a" translate="yes" xml:space="preserve">
          <source>This pragma sets the alignment of fields in structures. The values of &lt;var&gt;alignment&lt;/var&gt; may be &lt;code&gt;mac68k&lt;/code&gt;, to emulate m68k alignment, or &lt;code&gt;power&lt;/code&gt;, to emulate PowerPC alignment. Uses of this pragma nest properly; to restore the previous setting, use &lt;code&gt;reset&lt;/code&gt; for the &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e23a1d175eeaabf52f59f12be4c55b597b0251f" translate="yes" xml:space="preserve">
          <source>This pragma sets the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the value on top of the stack for this macro. If the stack for &lt;var&gt;macro_name&lt;/var&gt; is empty, the value of the macro remains unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b17cd16d3c44521375b42df7bda966fe331c0e" translate="yes" xml:space="preserve">
          <source>This pragma silently applies only to declarations with external linkage. The &lt;code&gt;asm&lt;/code&gt; label feature does not have this restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263438c853ee982ccc7a3904487e0cd3d115c742" translate="yes" xml:space="preserve">
          <source>This prefix is also used for finding files such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853d289c160cc93497a02e37abb2f9f0217d9d34" translate="yes" xml:space="preserve">
          <source>This problem may for instance occur when we use this pattern recursively, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bb145abdc75a03d83add48a654c73cbe5bd131" translate="yes" xml:space="preserve">
          <source>This problem only affects kernel stores and, depending on the system, kernel loads. As an example, a speculatively-executed store may load the target memory into cache and mark the cache line as dirty, even if the store itself is later aborted. If a DMA operation writes to the same area of memory before the &amp;ldquo;dirty&amp;rdquo; line is flushed, the cached data overwrites the DMA-ed data. See the R10K processor manual for a full description, including other potential problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bba2aa8d001273821fc7a22f52c80ae052e1b79" translate="yes" xml:space="preserve">
          <source>This qualifier informs the compiler that the &lt;code&gt;asm&lt;/code&gt; statement may perform a jump to one of the labels listed in the &lt;var&gt;GotoLabels&lt;/var&gt;. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4093c1766b06cd06224229c5ab31374f32640737" translate="yes" xml:space="preserve">
          <source>This restriction of ISO C makes it hard to write code that is portable to traditional C compilers, because the programmer does not know whether the &lt;code&gt;uid_t&lt;/code&gt; type is &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;long&lt;/code&gt;. Therefore, in cases like these GNU C allows a prototype to override a later old-style definition. More precisely, in GNU C, a function prototype argument type overrides the argument type specified by a later old-style definition if the former type is the same as the latter type before promotion. Thus in GNU C the above example is equivalent to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ab6e646b44f4632464748755730b2c272ad5f1" translate="yes" xml:space="preserve">
          <source>This sample shows how to specify the assembler name for data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b05b60d6f2ee21a98f997beb1f9023f6a4e7bc" translate="yes" xml:space="preserve">
          <source>This says that any input file whose name ends in &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc7756ea229cad62f19381d0aec545c10cece4c" translate="yes" xml:space="preserve">
          <source>This says that the suffix is an alias for a known &lt;var&gt;language&lt;/var&gt;. This is similar to using the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e07f2febdffcd9c896323de91d75db17316bb7" translate="yes" xml:space="preserve">
          <source>This section describes PowerPC built-in functions that do not require the inclusion of any special header files to declare prototypes or provide macro definitions. The sections that follow describe additional PowerPC built-in functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b61f221f0794b55701031d13518070c0255286e" translate="yes" xml:space="preserve">
          <source>This section describes built-in functions that are not named after a specific FR-V instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7abf825d737ed6aeedbed114bb5b1fa96d1d588" translate="yes" xml:space="preserve">
          <source>This section describes command-line options that are primarily of interest to GCC developers, including options to support compiler testing and investigation of compiler bugs and compile-time performance problems. This includes options that produce debug dumps at various points in the compilation; that print statistics such as memory use and execution time; and that print information about GCC&amp;rsquo;s configuration, such as where it searches for libraries. You should rarely need to use any of these options for ordinary compilation and linking tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bedaec624c9942033ae97b423071f6ba2ad1456" translate="yes" xml:space="preserve">
          <source>This section describes known problems that affect users of GCC. Most of these are not GCC bugs per se&amp;mdash;if they were, we would fix them. But the result for a user may be like the result of a bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b43873b1eac185b9fa8755ff87aff197f92a2f8" translate="yes" xml:space="preserve">
          <source>This section describes several environment variables that affect how GCC operates. Some of them work by specifying directories or prefixes to use when searching for various kinds of files. Some are used to specify other aspects of the compilation environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9055e1a522ff74558948ff04f5b4f164a424da3a" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for C++ programs. You can also use most of the GNU compiler options regardless of what language your program is in. For example, you might compile a file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378b3683f59604e4695371da6c2fddfaacd92ba1" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for Objective-C and Objective-C++ programs. You can also use most of the language-independent GNU compiler options. For example, you might compile a file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382e6f59f6c971fab95547a05668a5918cd72126" translate="yes" xml:space="preserve">
          <source>This section describes the syntax with which &lt;code&gt;__attribute__&lt;/code&gt; may be used, and the constructs to which attribute specifiers bind, for the C language. Some details may vary for C++ and Objective-C. Because of infelicities in the grammar for attributes, some forms described here may not be successfully parsed in all cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8e6c5371362aa092aae0b0592e55198f1c8b9c" translate="yes" xml:space="preserve">
          <source>This section documents the encoding of method types, which is rarely needed to use Objective-C. You should skip it at a first reading; the runtime provides functions that will work on methods and can walk through the list of parameters and interpret them for you. These functions are part of the public &amp;ldquo;API&amp;rdquo; and are the preferred way to interact with method signatures from user code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bc19fae671586234add4d5e1d253df22100b8a" translate="yes" xml:space="preserve">
          <source>This section intentionally empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dcc691a02a9391b7e0c30aab063927ea00a125c" translate="yes" xml:space="preserve">
          <source>This section is specific for the GNU Objective-C runtime. If you are using a different runtime, you can skip it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2663a3da2126761e59e5b901038db322ae02e2" translate="yes" xml:space="preserve">
          <source>This section lists changes that people frequently request, but which we do not make because we think GCC is better without them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be9fd8a27bd882ee2957a5506f02578eed902d6" translate="yes" xml:space="preserve">
          <source>This section lists various difficulties encountered in using GCC together with other compilers or with the assemblers, linkers, libraries and debuggers on certain systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5c464b4c99442f66523b49fbd84dd32d4a9f33" translate="yes" xml:space="preserve">
          <source>This sections describes built-in functions related to read and write instructions to access memory. These functions generate &lt;code&gt;membar&lt;/code&gt; instructions to flush the I/O load and stores where appropriate, as described in Fujitsu&amp;rsquo;s manual described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657a9d90f9f4dd0b4af1725dd023d864364a9a6d" translate="yes" xml:space="preserve">
          <source>This selects the CPU to generate code for at compilation time by determining the processor type of the compiling machine. Using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fbcd0192529b61aa6e52c7943fcf31e0d69f81" translate="yes" xml:space="preserve">
          <source>This sets the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8206cbbb17dc4eed11021be8e812bfcaf18d27d" translate="yes" xml:space="preserve">
          <source>This setting is only useful for strides that are known and constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe46d223c613fd1d939a40a5c5d5b8742ce8085" translate="yes" xml:space="preserve">
          <source>This setting is useful for processors that have hardware prefetchers, in which case there may be conflicts between the hardware prefetchers and the software prefetchers. If the hardware prefetchers have a maximum stride they can handle, it should be used here to improve the use of software prefetchers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f9a68d34fdcbac9802d87e4691f1d481ccdb61" translate="yes" xml:space="preserve">
          <source>This size is also used for inlining decisions. If you use &lt;code&gt;asm inline&lt;/code&gt; instead of just &lt;code&gt;asm&lt;/code&gt;, then for inlining purposes the size of the asm is taken as the minimum size, ignoring how many instructions GCC thinks it is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6436ee6603a6a283bb34edc1a40e3b3faa54b98d" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the function &lt;code&gt;func&lt;/code&gt; in the assembler code should be &lt;code&gt;MYFUNC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232e23ab36d2ae531cc928cda4ab49d45def08c5" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the variable &lt;code&gt;foo&lt;/code&gt; in the assembler code should be &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e7d4d12b96a2f9b08b67a67b6c05ae9677d81f" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. This option can be used in conjunction with or instead of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5ffdf441cdde0f8b6e9e4c7fe02c1f21c8c411" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM processor. GCC uses this name to derive the name of the target ARM architecture (as if specified by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e151a0bdb560628cb5ddbb4913dc14cfb482f53" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target Nios II architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085bdfa0f8d1afe6178b912d6185b5a3f9cb191a" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64aaf23d10b975a481227888a0c489eb1e3c16c0" translate="yes" xml:space="preserve">
          <source>This specifies what floating-point hardware (or hardware emulation) is available on the target. Permissible names are: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345d1833d12c5392425b9eb5b3c8d3be49244d38" translate="yes" xml:space="preserve">
          <source>This switch causes the command line used to invoke the compiler to be recorded into the object file that is being created. This switch is only implemented on some targets and the exact format of the recording is target and binary file format dependent, but it usually takes the form of a section containing ASCII text. This switch is related to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcef4a45435978f94ac21ce5b4ddc80a97324665" translate="yes" xml:space="preserve">
          <source>This switch causes the command-line options used to invoke the compiler that may affect code generation to be appended to the DW_AT_producer attribute in DWARF debugging information. The options are concatenated with spaces separating them from each other and from the compiler version. It is enabled by default. See also</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ef7cfaa3693eda0200855e73487a3931ad86b9" translate="yes" xml:space="preserve">
          <source>This switch declares that the user does not attempt to compare pointers to inline functions or methods where the addresses of the two functions are taken in different shared objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d12a205f2d4388bb6e6b2aa9be08da33c955f0c" translate="yes" xml:space="preserve">
          <source>This switch disables the automatic removal of redundant &lt;code&gt;membar&lt;/code&gt; instructions from the generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb214efcf15f2eebcb5c8359308da41aee1bb7a5" translate="yes" xml:space="preserve">
          <source>This switch enables or disables the generation of ISEL instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121380ba5bbee8a3b6396891291392c7f45ab990" translate="yes" xml:space="preserve">
          <source>This switch is mainly for debugging the compiler and will likely be removed in a future version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b61792d6d517f0567ee609808598af69f30e65" translate="yes" xml:space="preserve">
          <source>This switch removes redundant &lt;code&gt;membar&lt;/code&gt; instructions from the compiler-generated code. It is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2700c0c5f6842561acacd13d2b72a8353682aa23" translate="yes" xml:space="preserve">
          <source>This syntax is defined in the C++ 2011 standard, but has been supported by G++ and other compilers since well before 2011.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fcb60fefcb3dd52763982ecf7c2e7bdfe84505" translate="yes" xml:space="preserve">
          <source>This tells the compiler that a function is &lt;code&gt;malloc&lt;/code&gt;-like, i.e., that the pointer &lt;var&gt;P&lt;/var&gt; returned by the function cannot alias any other pointer valid when the function returns, and moreover no pointers to valid objects occur in any storage addressed by &lt;var&gt;P&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ca8b09b0bd70a0af88532cce8b6c0a57af5ea7" translate="yes" xml:space="preserve">
          <source>This tells the compiler to create, override or delete the named spec string. All lines after this directive up to the next directive or blank line are considered to be the text for the spec string. If this results in an empty string then the spec is deleted. (Or, if the spec did not exist, then nothing happens.) Otherwise, if the spec does not currently exist a new spec is created. If the spec does exist then its contents are overridden by the text of this directive, unless the first character of that text is the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4018bf7af9477c8687cfe9f142d2504a7341b9" translate="yes" xml:space="preserve">
          <source>This turns off certain features of GCC that are incompatible with ISO C90 (when compiling C code), or of standard C++ (when compiling C++ code), such as the &lt;code&gt;asm&lt;/code&gt; and &lt;code&gt;typeof&lt;/code&gt; keywords, and predefined macros such as &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;vax&lt;/code&gt; that identify the type of system you are using. It also enables the undesirable and rarely used ISO trigraph feature. For the C compiler, it disables recognition of C++ style &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92dd1276eca8dc32a61b9ef6e7b622bea22fa0aa" translate="yes" xml:space="preserve">
          <source>This value is used to limit superblock formation once the given percentage of executed instructions is covered. This limits unnecessary code size expansion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d25d25b176faf62dac7b5023bc142fa458d69e" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; (see above), except that system header files are not ignored, so it implies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac6e7ae8cc06c38e89aed855dd5fc2e644da6f4" translate="yes" xml:space="preserve">
          <source>This variable is used to pass locale information to the compiler. One way in which this information is used is to determine the character set to be used when character literals, string literals and comments are parsed in C and C++. When the compiler is configured to allow multibyte characters, the following values for &lt;code&gt;LANG&lt;/code&gt; are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be1995e1045ff6bbec640e0a942d94152cfdec6" translate="yes" xml:space="preserve">
          <source>This warning also warns about bitwise comparisons that always evaluate to true or false, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2459c9299d10d23b0470cd3490145629414a5b" translate="yes" xml:space="preserve">
          <source>This warning can be disabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ed913f904a95674da23281b17b4ea693c54b25" translate="yes" xml:space="preserve">
          <source>This warning does not warn when the last statement of a case cannot fall through, e.g. when there is a return statement or a call to function declared with the noreturn attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fc4cf85fe382aeb62fa09febecbde3a95eefc5" translate="yes" xml:space="preserve">
          <source>This warning is also enabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fced7dacfde6a232424563218b69038bcd4ee559" translate="yes" xml:space="preserve">
          <source>This warning is enabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a47c11f1d7801640a4ce272fb734796af5acce" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default for C and C++ programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee676e87db234394e662704c0ac8d7b78ce3a041" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default in C++ and by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cc8455b15f952933dbc6b5c4dcaaac18069659" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3917b2a596783248383561094f2cc2f726e9521a" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default. Use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d860a0af5ebf8266139b884b360d37bd26034c" translate="yes" xml:space="preserve">
          <source>This warning is included in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db92bbc8f99766a5d4907234d529494e443089db" translate="yes" xml:space="preserve">
          <source>This warning level also warns about left-shifting 1 into the sign bit, unless C++14 mode (or newer) is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7fb5cdceb183a69c6c48efdc3d5a84a181e3f7" translate="yes" xml:space="preserve">
          <source>This warning level also warns about out of bounds access for arrays at the end of a struct and for arrays accessed through pointers. This warning level may give a larger number of false positives and is deactivated by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc3c9fc8962f0931c9fc06c074ee037fa301f84" translate="yes" xml:space="preserve">
          <source>This warning level also warns for unused constant static variables in headers (excluding system headers). This is the warning level of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39d91280d86f2477375c576c702edeea7de99cb" translate="yes" xml:space="preserve">
          <source>This warning warns about redundant calls to &lt;code&gt;std::move&lt;/code&gt;; that is, when a move operation would have been performed even without the &lt;code&gt;std::move&lt;/code&gt; call. This happens because the compiler is forced to treat the object as if it were an rvalue in certain situations such as returning a local variable, where copy elision isn&amp;rsquo;t applicable. Consider:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff927821e46493382415b836b1d222941ef02c3" translate="yes" xml:space="preserve">
          <source>This warning warns when a call to &lt;code&gt;std::move&lt;/code&gt; prevents copy elision. A typical scenario when copy elision can occur is when returning in a function with a class return type, when the expression being returned is the name of a non-volatile automatic object, and is not a function parameter, and has the same type as the function return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc144d25fb3262e883d5de6746ba99b3d72080d" translate="yes" xml:space="preserve">
          <source>This was fixed in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b70ca57c3342f65e65169286b191ac23c6458f6" translate="yes" xml:space="preserve">
          <source>This would cause storage layout to be incompatible with most other C compilers. And it doesn&amp;rsquo;t seem very important, given that you can get the same result in other ways. The case where it matters most is when the enumeration-valued object is inside a structure, and in that case you can specify a field width explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="470b7fe94fb9f173a78fa935734e2192a8d7646b" translate="yes" xml:space="preserve">
          <source>Thread, static, and automatic storage durations are associated with objects introduced by declarations [&amp;hellip;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f3324c9a09465697eb233a889b15dae55b7e07" translate="yes" xml:space="preserve">
          <source>Thread-local storage (TLS) is a mechanism by which variables are allocated such that there is one instance of the variable per extant thread. The runtime model GCC uses to implement this originates in the IA-64 processor-specific ABI, but has since been migrated to other processors as well. It requires significant support from the linker (&lt;code&gt;ld&lt;/code&gt;), dynamic linker (&lt;code&gt;ld.so&lt;/code&gt;), and system libraries (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f55e84b2ac7e71c677017ee5269595545ce154" translate="yes" xml:space="preserve">
          <source>Three attributes are currently defined for the Blackfin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74960e7e5c9e31cbbbc884f673c931b0f550d460" translate="yes" xml:space="preserve">
          <source>Three attributes currently are defined for PowerPC configurations: &lt;code&gt;altivec&lt;/code&gt;, &lt;code&gt;ms_struct&lt;/code&gt; and &lt;code&gt;gcc_struct&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb2dbbb4a85c3866aff412bba9f2a41a060bb7f" translate="yes" xml:space="preserve">
          <source>Thus for example to display all the undocumented target-specific switches supported by the compiler, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a580d726772cc97718ddf7d30a624c944acce67" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;array (pointer (char), 4)&lt;/code&gt; is the type of arrays of 4 pointers to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de79caa39ed0efb8d6ccb9be9f4f52d25b8a9e8" translate="yes" xml:space="preserve">
          <source>To avoid complications from future changes to the semantics and the compatibility issues between compilers, consider replacing basic &lt;code&gt;asm&lt;/code&gt; with extended &lt;code&gt;asm&lt;/code&gt;. See &lt;a href=&quot;https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended&quot;&gt;How to convert from basic asm to extended asm&lt;/a&gt; for information about how to perform this conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3300fdd0a6bd75b07beded4de93f16de3369a5" translate="yes" xml:space="preserve">
          <source>To avoid exponential effects in the Graphite loop transforms, the number of parameters in a Static Control Part (SCoP) is bounded. A value of zero can be used to lift the bound. A variable whose value is unknown at compilation time and defined outside a SCoP is a parameter of the SCoP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b629b2d987ad7e3698e47dd90332bddf769c0ae" translate="yes" xml:space="preserve">
          <source>To be fully SVR4 ABI-compliant at the cost of some performance loss, specify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80464eace90374e03d32650091e615c04e6c4a1e" translate="yes" xml:space="preserve">
          <source>To configure the hook, you set the global variable &lt;code&gt;__objc_msg_forward2&lt;/code&gt; to a function with the same argument and return types of &lt;code&gt;objc_msg_lookup()&lt;/code&gt;. When &lt;code&gt;objc_msg_lookup()&lt;/code&gt; cannot find a method implementation, it invokes the hook function you provided to get a method implementation to return. So, in practice &lt;code&gt;__objc_msg_forward2&lt;/code&gt; allows you to extend &lt;code&gt;objc_msg_lookup()&lt;/code&gt; by adding some custom code that is called to do a further lookup when no standard method implementation can be found using the normal lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0892f6a61a5ddf8739ac6a9df58e9ff15e317ea" translate="yes" xml:space="preserve">
          <source>To create a precompiled header file, simply compile it as you would any other file, if necessary using the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3088551494e7c8fccec2e166c87f205757a7fee0" translate="yes" xml:space="preserve">
          <source>To declare a function inline, use the &lt;code&gt;inline&lt;/code&gt; keyword in its declaration, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5797514daed065cb1f475967a5b0ae2a149a5bab" translate="yes" xml:space="preserve">
          <source>To determine what tree dumps are available or find the dump for a pass of interest follow the steps below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d8395854f85aca3686a491adc6bbc80456cbb1" translate="yes" xml:space="preserve">
          <source>To disable &lt;code&gt;__gcc_isr&lt;/code&gt; generation for the whole compilation unit, there is option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0828348cc00b4bf17581e2c7550f1489803bf22" translate="yes" xml:space="preserve">
          <source>To do so, the runtime checks if the class of the receiver implements the method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881e567632131aa4c0fe4b9dfaf489bcd70667c6" translate="yes" xml:space="preserve">
          <source>To enable the creation of the dump file, append the pass code to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa9530acd994c840dc3d2acd1762406cfa124f4" translate="yes" xml:space="preserve">
          <source>To enable the support for it you have to configure the compiler using an additional argument, &lt;code&gt;--enable-objc-gc&lt;/code&gt;. This will build the boehm-gc library, and build an additional runtime library which has several enhancements to support the garbage collector. The new library has a new name,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03cac0a42ba20ca789fab6e33a836d7beda4b6b" translate="yes" xml:space="preserve">
          <source>To ensure proper alignment of this values on the stack, the stack boundary must be as aligned as that required by any value stored on the stack. Further, every function must be generated such that it keeps the stack aligned. Thus calling a function compiled with a higher preferred stack boundary from a function compiled with a lower preferred stack boundary most likely misaligns the stack. It is recommended that libraries that use callbacks always use the default setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f72a9196daa0aa6fe25defa0d854e178b76e7c" translate="yes" xml:space="preserve">
          <source>To extract the real part of a complex-valued expression &lt;var&gt;exp&lt;/var&gt;, write &lt;code&gt;__real__ &lt;var&gt;exp&lt;/var&gt;&lt;/code&gt;. Likewise, use &lt;code&gt;__imag__&lt;/code&gt; to extract the imaginary part. This is a GNU extension; for values of floating type, you should use the ISO C99 functions &lt;code&gt;crealf&lt;/code&gt;, &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;creall&lt;/code&gt;, &lt;code&gt;cimagf&lt;/code&gt;, &lt;code&gt;cimag&lt;/code&gt; and &lt;code&gt;cimagl&lt;/code&gt;, declared in &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; and also provided as built-in functions by GCC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d03d577b7b5a669a7c4822e1a0edd45b2f8702a" translate="yes" xml:space="preserve">
          <source>To generate SSE/SSE2 instructions automatically from floating-point code (as opposed to 387 instructions), see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0fe141c8ecdca866163a97026bd7dfee64a0ff" translate="yes" xml:space="preserve">
          <source>To help solve this problem, CPP behaves specially for variable arguments used with the token paste operator, &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccb76de9b13c0e702133668a7f3b6ce8851c913" translate="yes" xml:space="preserve">
          <source>To help with returning the objects, the &lt;code&gt;objects&lt;/code&gt; array is a C array preallocated by the caller (on the stack) of size &lt;code&gt;len&lt;/code&gt;. In many cases you can put the objects you want to return in that &lt;code&gt;objects&lt;/code&gt; array, then do &lt;code&gt;itemsPtr = objects&lt;/code&gt;. But you don&amp;rsquo;t have to; if your collection already has the objects to return in some form of C array, it could return them from there instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d0f609e4fa3e2ba377279a7e5054298d93e189" translate="yes" xml:space="preserve">
          <source>To initialize a range of elements to the same value, write &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9469a3d15175030b71c43e9782eac80132b4e50b" translate="yes" xml:space="preserve">
          <source>To make the above program fragment valid, place whitespace in front of the minus sign. This whitespace will end the preprocessing number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cff9fedec936f586685a14aa955b37f35f7182a" translate="yes" xml:space="preserve">
          <source>To make the code valid either use &lt;code&gt;this-&amp;gt;f()&lt;/code&gt;, or &lt;code&gt;Base&amp;lt;T&amp;gt;::f()&lt;/code&gt;. Using the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c492c2aa61afe70cee904ba589c05bee91367f4" translate="yes" xml:space="preserve">
          <source>To make whole program optimization effective, it is necessary to make certain whole program assumptions. The compiler needs to know what functions and variables can be accessed by libraries and runtime outside of the link-time optimized unit. When supported by the linker, the linker plugin (see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10f010a5357171b19c82dd57547e3f7673eff6e" translate="yes" xml:space="preserve">
          <source>To obtain all the diagnostics required by any of the standard versions described above you should specify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4aa89809c1011def5d99d621c233ec275d1953d" translate="yes" xml:space="preserve">
          <source>To optimize the program based on the collected profile information, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b4fed3cfe7ddfce1a0ca3458206394c1a66615" translate="yes" xml:space="preserve">
          <source>To prevent this from happening, if any input operand uses the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b232f82880621b972c64ec90d9ff0ca83f771650" translate="yes" xml:space="preserve">
          <source>To reference a label in the assembler template, prefix it with &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da66ae5379009e523ed502eead6298d0e166f13e" translate="yes" xml:space="preserve">
          <source>To save space, do not emit out-of-line copies of inline functions controlled by &lt;code&gt;#pragma implementation&lt;/code&gt;. This causes linker errors if these functions are not inlined everywhere they are called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8d976d0714f674e209f146cbbc7e6de34ae80c" translate="yes" xml:space="preserve">
          <source>To see the meaning of the declaration using &lt;code&gt;typeof&lt;/code&gt;, and why it might be a useful way to write, rewrite it with these macros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f035db3f8f044bbb0c622fe1fb92f16b378d0b" translate="yes" xml:space="preserve">
          <source>To specify an array index, write &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb678e44477baccb18d5369a48bd2b0b5ec0599" translate="yes" xml:space="preserve">
          <source>To specify multiple attributes, separate them by commas within the double parentheses: for example, &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279b8a3b8509796e74c2ff0e52b4b2a1757b661c" translate="yes" xml:space="preserve">
          <source>To specify the assembler name for functions, write a declaration for the function before its definition and put &lt;code&gt;asm&lt;/code&gt; there, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcbee28f5f060da3b68aea636eb26d6ab9b499b" translate="yes" xml:space="preserve">
          <source>To support cross-profiling, a program compiled with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96365bc4676b236073f125730e587d433f50ff7e" translate="yes" xml:space="preserve">
          <source>To suppress this warning use the &lt;code&gt;unused&lt;/code&gt; attribute (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e4279a59e510b02bce48ca083689c7becefcae" translate="yes" xml:space="preserve">
          <source>To tell GCC to emit extra information for use by a debugger, in almost all cases you need only to add</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b5eb5cc6d2fda96d56fc807ba5364d278d6687" translate="yes" xml:space="preserve">
          <source>To use the link-time optimizer,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d57caa2b7e4b18d64025af8cb99faf45ba1cb2" translate="yes" xml:space="preserve">
          <source>To use these values, you need to be able to jump to one. This is done with the computed goto statement&lt;a href=&quot;#FOOT3&quot; id=&quot;DOCF3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;, &lt;code&gt;goto *&lt;var&gt;exp&lt;/var&gt;;&lt;/code&gt;. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a059b55deba4fe3359e7e786d89afe0aa93dd23" translate="yes" xml:space="preserve">
          <source>To verify full coverage during</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec197d950172e34ea76227a1a78e887c52db9d18" translate="yes" xml:space="preserve">
          <source>To write a constant with a complex data type, use the suffix &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38062ec8cfdea338e4b4a324dec29b0cd9799659" translate="yes" xml:space="preserve">
          <source>Together with a linker garbage collection (linker</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e14b063514cb6630e55f0aeb0ad3b37897efca" translate="yes" xml:space="preserve">
          <source>Toggle</source>
          <target state="translated">Toggle</target>
        </trans-unit>
        <trans-unit id="e6173ef9d580540f096dfe977ae2b3f003d86077" translate="yes" xml:space="preserve">
          <source>Top of 80387 floating-point stack (&lt;code&gt;%st(0)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f1f61607f8ef773d398fa71f442e01700f516d" translate="yes" xml:space="preserve">
          <source>Total Store Order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc1b3768ce894366a90239dc16d691ba72ece66" translate="yes" xml:space="preserve">
          <source>Track locations of tokens across macro expansions. This allows the compiler to emit diagnostic about the current macro expansion stack when a compilation error occurs in a macro expansion. Using this option makes the preprocessor and the compiler consume more memory. The &lt;var&gt;level&lt;/var&gt; parameter can be used to choose the level of precision of token location tracking thus decreasing the memory consumption if necessary. Value &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4293c6fc2d0c550f24f6474e968d410857105e2b" translate="yes" xml:space="preserve">
          <source>Track top N target addresses in indirect-call profile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723c149c69cf2602683e7f446ef904f72610c870" translate="yes" xml:space="preserve">
          <source>Tracks stack adjustments (pushes and pops) and stack memory references and then tries to find ways to combine them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d7d66b6e955c972dc5701e4823af12fb85cdf2" translate="yes" xml:space="preserve">
          <source>Traditional C allows the following erroneous pair of declarations to appear together in a given scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510d795979a46696182ad87a63664d2658cf856e" translate="yes" xml:space="preserve">
          <source>Traditionally, diagnostic messages have been formatted irrespective of the output device&amp;rsquo;s aspect (e.g. its width, &amp;hellip;). You can use the options described below to control the formatting algorithm for diagnostic messages, e.g. how many characters per line, how often source location information should be reported. Note that some language front ends may not honor these options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab7709810cc2dcfdfcf719c4862cab474121c8b" translate="yes" xml:space="preserve">
          <source>Transaction abort due to a debug trap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd7b3249c42fccf913301a9808dd3e7980d5264e" translate="yes" xml:space="preserve">
          <source>Transaction abort due to a memory conflict with another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049238f821868925f76adff4fc7870e16eef0c6a" translate="yes" xml:space="preserve">
          <source>Transaction abort due to the transaction using too much memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead551a83f5f5bb74300da039b768d5b00d30187" translate="yes" xml:space="preserve">
          <source>Transaction abort in an inner nested transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485e36de3e4a7d7cfcfa7ddabb0a849c973eb7dd" translate="yes" xml:space="preserve">
          <source>Transaction retry is possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0bda536dbe2634713edf7ae5619b61d4b2b7ec" translate="yes" xml:space="preserve">
          <source>Transaction was explicitly aborted with &lt;code&gt;_xabort&lt;/code&gt;. The parameter passed to &lt;code&gt;_xabort&lt;/code&gt; is available with &lt;code&gt;_XABORT_CODE(status)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f4a1ebc38e5d0f03feed213fa084a39f1c4ca1" translate="yes" xml:space="preserve">
          <source>Transparent unions are designed for library functions that have multiple interfaces for compatibility reasons. For example, suppose the &lt;code&gt;wait&lt;/code&gt; function must accept either a value of type &lt;code&gt;int *&lt;/code&gt; to comply with POSIX, or a value of type &lt;code&gt;union wait *&lt;/code&gt; to comply with the 4.1BSD interface. If &lt;code&gt;wait&lt;/code&gt;&amp;rsquo;s parameter were &lt;code&gt;void *&lt;/code&gt;, &lt;code&gt;wait&lt;/code&gt; would accept both kinds of arguments, but it would also accept any other pointer type and this would make argument type checking less useful. Instead, &lt;code&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/code&gt; might define the interface as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0f9c4ade227657a2baa1dad9f725c64aa01d3a" translate="yes" xml:space="preserve">
          <source>Trap (do not trap) on integer division by zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d00c4acc18e3548fcbf61342f9558417419f4a6" translate="yes" xml:space="preserve">
          <source>Treat a &lt;code&gt;throw()&lt;/code&gt; exception specification as if it were a &lt;code&gt;noexcept&lt;/code&gt; specification to reduce or eliminate the text size overhead relative to a function with no exception specification. If the function has local variables of types with non-trivial destructors, the exception specification actually makes the function smaller because the EH cleanups for those variables can be optimized away. The semantic effect is that an exception thrown out of a function with such an exception specification results in a call to &lt;code&gt;terminate&lt;/code&gt; rather than &lt;code&gt;unexpected&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcf63ae910bd65526e3a00af5485e708789997f" translate="yes" xml:space="preserve">
          <source>Treat all calls as being far away (near). If calls are assumed to be far away, the compiler always loads the function&amp;rsquo;s address into a register, and calls indirect through the pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e657b1f5ccca3a3f8f766ebdbdec5db7187eaa45" translate="yes" xml:space="preserve">
          <source>Treat floating-point constants as single precision instead of implicitly converting them to double-precision constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9730fd8c54eee8a380dfaa34a9eb35908c0edfe" translate="yes" xml:space="preserve">
          <source>Treat the register named &lt;var&gt;reg&lt;/var&gt; as a fixed register; generated code should never refer to it (except perhaps as a stack pointer, frame pointer or in some other fixed role).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24bec37045b31ff86b0699b95df9d95df0bb7391" translate="yes" xml:space="preserve">
          <source>Treat the register named &lt;var&gt;reg&lt;/var&gt; as an allocable register saved by functions. It may be allocated even for temporaries or variables that live across a call. Functions compiled this way save and restore the register &lt;var&gt;reg&lt;/var&gt; if they use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed7e368cac1e3940cdf973c2d7cc16201bdbf48" translate="yes" xml:space="preserve">
          <source>Treat the register named &lt;var&gt;reg&lt;/var&gt; as an allocable register that is clobbered by function calls. It may be allocated for temporaries or variables that do not live across a call. Functions compiled this way do not save and restore the register &lt;var&gt;reg&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7012f8bdb10f107e038866fe0f141acd75a5071" translate="yes" xml:space="preserve">
          <source>Treat the register used for PIC addressing as read-only, rather than loading it in the prologue for each function. The runtime system is responsible for initializing this register with an appropriate value before execution begins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6dc381ff0b0eaf3a75a3644a1928e76a876add7" translate="yes" xml:space="preserve">
          <source>Treat the stack pointer register as an 8-bit register, i.e. assume the high byte of the stack pointer is zero. In general, you don&amp;rsquo;t need to set this option by hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a09707746246ab1f81f3b198c6fce704d60805" translate="yes" xml:space="preserve">
          <source>Try to align labels to an 8-byte boundary by inserting NOPs into the previous packet. This option only has an effect when VLIW packing is enabled. It doesn&amp;rsquo;t create new packets; it merely adds NOPs to existing ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7f1893937b8021a0b45b38ecc6c5c5982860f9" translate="yes" xml:space="preserve">
          <source>Try to format error messages so that they fit on lines of about &lt;var&gt;n&lt;/var&gt; characters. If &lt;var&gt;n&lt;/var&gt; is zero, then no line-wrapping is done; each error message appears on a single line. This is the default for all front ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ead7ad6ca24e037be309703712bdaf58fe0308" translate="yes" xml:space="preserve">
          <source>Try to imitate the behavior of pre-standard C preprocessors, as opposed to ISO C preprocessors. See the GNU CPP manual for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8878a439f989aa10bd1de06d6919d9cd9fccd45" translate="yes" xml:space="preserve">
          <source>Try to make the code as small as possible. At present, this just turns on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2943824dd1677f0ee45e17f3ad727f59c256ccaf" translate="yes" xml:space="preserve">
          <source>Try to reduce the number of symbolic address calculations by using shared &amp;ldquo;anchor&amp;rdquo; symbols to address nearby objects. This transformation can help to reduce the number of GOT entries and GOT accesses on some targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71689cce79c81b27513c53eda29d40ea96948251" translate="yes" xml:space="preserve">
          <source>Try to replace &lt;code&gt;CALL&lt;/code&gt; resp. &lt;code&gt;JMP&lt;/code&gt; instruction by the shorter &lt;code&gt;RCALL&lt;/code&gt; resp. &lt;code&gt;RJMP&lt;/code&gt; instruction if applicable. Setting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5db504e6f50390be7556b15f1e06e74d98003b" translate="yes" xml:space="preserve">
          <source>Try to turn PIC calls that are normally dispatched via register &lt;code&gt;$25&lt;/code&gt; into direct calls. This is only possible if the linker can resolve the destination at link time and if the destination is within range for a direct call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d986cee6514cc454cabe1b04f373619d70b76947" translate="yes" xml:space="preserve">
          <source>Tune for ARC600 CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd581f56e3b57950cd6ef9a480d293254a2ecd23" translate="yes" xml:space="preserve">
          <source>Tune for ARC601 CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1d8bffb14bf81b97f78406c7f3b23782c05dcc" translate="yes" xml:space="preserve">
          <source>Tune for ARC700 CPU with XMAC block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb447e923ad8db257fca3ee02ccc66a1cc26b9c9" translate="yes" xml:space="preserve">
          <source>Tune for ARC700 CPU with standard multiplier block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0124418dee31dd7297585683b0a95e9f65f2e8cc" translate="yes" xml:space="preserve">
          <source>Tune for ARC725D CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99d4307ca5e0f869f7793d383503e6ec8def3af" translate="yes" xml:space="preserve">
          <source>Tune for ARC750D CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d5b9e241148e9c20bf6639665bc7f5200a0c7a" translate="yes" xml:space="preserve">
          <source>Tune the code for a particular microarchitecture within the constraints set by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11fd75fe2998bc88e3a55f06c902e5e06c31f2d" translate="yes" xml:space="preserve">
          <source>Tune the instruction scheduling for a particular CPU, Valid values are &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d6ee31240249a6f0e63fbef357f9d54da8845d" translate="yes" xml:space="preserve">
          <source>Tune to &lt;var&gt;architecture-type&lt;/var&gt; everything applicable about the generated code, except for the ABI and the set of available instructions. The choices for &lt;var&gt;architecture-type&lt;/var&gt; are the same as for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abe7006b22b302a45d8adf679048506cceec6621" translate="yes" xml:space="preserve">
          <source>Tune to &lt;var&gt;cpu-type&lt;/var&gt; everything applicable about the generated code, except for the ABI and the set of available instructions. The list of &lt;var&gt;cpu-type&lt;/var&gt; values is the same as for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce8ad1c804c3f77bbd9eaaa6bff5e1dd657796d" translate="yes" xml:space="preserve">
          <source>Tune to &lt;var&gt;cpu-type&lt;/var&gt; everything applicable about the generated code, except for the ABI and the set of available instructions. While picking a specific &lt;var&gt;cpu-type&lt;/var&gt; schedules things appropriately for that particular chip, the compiler does not generate any code that cannot run on the default machine type unless you use a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff319ca41c83d456fd2660af1ba3a0a39ead43b" translate="yes" xml:space="preserve">
          <source>Turn off all access checking. This switch is mainly useful for working around bugs in the access control code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa7ded6e9138148782165f8ff6c917050fd8448" translate="yes" xml:space="preserve">
          <source>Turn off any specification of a language, so that subsequent files are handled according to their file name suffixes (as they are if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05599d87457784f5e8fcf58f82a82201f42c5e95" translate="yes" xml:space="preserve">
          <source>Turn off generation of debug info, if leaving out this option generates it, or turn it on at level 2 otherwise. The position of this argument in the command line does not matter; it takes effect after all other options are processed, and it does so only once, no matter how many times it is given. This is mainly intended to be used with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b5015cd05574d36521c886faa5f1fe72388eb1" translate="yes" xml:space="preserve">
          <source>Turn on all optimization options, i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f38ffe59dc7af4e39268866c9d6bf540ff3e935" translate="yes" xml:space="preserve">
          <source>Turn on all options, except</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="addc4296812df31340ecc8097c6637d705b4dc51" translate="yes" xml:space="preserve">
          <source>Turning on optimization flags makes the compiler attempt to improve the performance and/or code size at the expense of compilation time and possibly the ability to debug the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0abd8c32d9b5b449c21960750d5d9b900609a45e" translate="yes" xml:space="preserve">
          <source>Tweak register allocation to help 16-bit instruction generation. This generally has the effect of decreasing the average instruction size while increasing the instruction count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2345bb4c5df388b03bf38fa376e4f8708c805d" translate="yes" xml:space="preserve">
          <source>Two 16x16 multipliers, blocking, sequential. The following instructions are additionally enabled: &lt;code&gt;mpy&lt;/code&gt;, &lt;code&gt;mpyu&lt;/code&gt;, &lt;code&gt;mpym&lt;/code&gt;, &lt;code&gt;mpymu&lt;/code&gt;, and &lt;code&gt;mpy_s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b000d97aa40706cbe471fe85b50413fb0224467" translate="yes" xml:space="preserve">
          <source>Two additional variants of the o32 ABI are supported to enable a transition from 32-bit to 64-bit registers. These are FPXX (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc5d51eed63377e23ba7ef70163b3178b799fe5" translate="yes" xml:space="preserve">
          <source>Two&amp;rsquo;s complement of a 6-bit unsigned integer constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d021ad85f9ecc2bd4449ee63312946ef7cb6cb" translate="yes" xml:space="preserve">
          <source>Two-stage name lookup sometimes leads to situations with behavior different from non-template codes. The most common is probably this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575680b4fbe2bb6b6d519cf112b732f205e5669e" translate="yes" xml:space="preserve">
          <source>Type Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8492437da1bd59c92bb55d3921577991dfd8045e" translate="yes" xml:space="preserve">
          <source>Types &lt;code&gt;_Decimal32&lt;/code&gt;, &lt;code&gt;_Decimal64&lt;/code&gt;, and &lt;code&gt;_Decimal128&lt;/code&gt; are supported by the DWARF debug information format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c5b269a787c7229d4b1731f191eb104665ea8a" translate="yes" xml:space="preserve">
          <source>Types, but not their members, are not hidden by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="2f40553950efdfee2da54d1ec023b02b81e2bf58" translate="yes" xml:space="preserve">
          <source>UHK</source>
          <target state="translated">UHK</target>
        </trans-unit>
        <trans-unit id="f1d002b3861d02936136d383f32b05c7363677ef" translate="yes" xml:space="preserve">
          <source>UHR</source>
          <target state="translated">UHR</target>
        </trans-unit>
        <trans-unit id="7770d04c7bfb791e7c95959f12d6797bee87a8d8" translate="yes" xml:space="preserve">
          <source>UK</source>
          <target state="translated">UK</target>
        </trans-unit>
        <trans-unit id="c297964acee362f7f2dba4952f8bafc43415d17b" translate="yes" xml:space="preserve">
          <source>UL</source>
          <target state="translated">UL</target>
        </trans-unit>
        <trans-unit id="f02a449aa1e45687b9dd404230f554d77889736a" translate="yes" xml:space="preserve">
          <source>ULK</source>
          <target state="translated">ULK</target>
        </trans-unit>
        <trans-unit id="23068141b1ba54cf3def8562e3144f8201f1de6d" translate="yes" xml:space="preserve">
          <source>ULL</source>
          <target state="translated">ULL</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
