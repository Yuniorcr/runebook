<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="129a020d6e4e2d22eefb43a7999c4dc2402a1a50" translate="yes" xml:space="preserve">
          <source>The minimum probability (in percents) of reaching a source block for interblock speculative scheduling.</source>
          <target state="translated">ブロック間投機的スケジューリングのためのソースブロックに到達する最小確率(パーセン ト単位)。</target>
        </trans-unit>
        <trans-unit id="dc4b50e8ed53d44237971958e2e83e18524eb941" translate="yes" xml:space="preserve">
          <source>The minimum probability an edge must have for the scheduler to save its state across it.</source>
          <target state="translated">スケジューラがそのエッジの状態を保存するために必要な最小の確率。</target>
        </trans-unit>
        <trans-unit id="61926ef9181910c24fa1d9136e2e7aa3bdc9bb32" translate="yes" xml:space="preserve">
          <source>The minimum ratio between stride of two loops for interchange to be profitable.</source>
          <target state="translated">インターチェンジのための2つのループのストライド間の最小比率は、利益を得ることができます。</target>
        </trans-unit>
        <trans-unit id="8e01e027a6a504c434a5c40600808d2984b71737" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of memory references to enable prefetching in a loop.</source>
          <target state="translated">ループ内でプリフェッチを可能にするための命令数とメモリ参照数の最小比。</target>
        </trans-unit>
        <trans-unit id="0c8448923459ab38ab3cc0b8bb13a936b3627b06" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of prefetches to enable prefetching in a loop.</source>
          <target state="translated">ループ内でのプリフェッチを可能にするための命令数とプリフェッチ数の最小比。</target>
        </trans-unit>
        <trans-unit id="8220c9492a5b7435fa642b1e05152b364a262db5" translate="yes" xml:space="preserve">
          <source>The minimum size of buffers (i.e. arrays) that receive stack smashing protection when</source>
          <target state="translated">スタックスマッシング保護を受けるバッファ (配列など)の最小サイズ。</target>
        </trans-unit>
        <trans-unit id="13054edb9e1ab6c7cefbb0f40ba19b0915f9beae" translate="yes" xml:space="preserve">
          <source>The minimum size of variables taking part in stack slot sharing when not optimizing.</source>
          <target state="translated">最適化されていないときにスタックスロットの共有に参加する変数の最小サイズ。</target>
        </trans-unit>
        <trans-unit id="2c2de50582a702ec4d7ad2fc7c8e60438b0f0aa8" translate="yes" xml:space="preserve">
          <source>The minimum value of stage count that swing modulo scheduler generates.</source>
          <target state="translated">swing modulo スケジューラが生成するステージ数の最小値。</target>
        </trans-unit>
        <trans-unit id="e61665509912f06aa6c9cfa2083ef8e16d79724c" translate="yes" xml:space="preserve">
          <source>The most straightforward way to link a program to use a particular C++ library is to use a C++ driver that specifies that C++ library by default. The &lt;code&gt;g++&lt;/code&gt; driver, for example, tells the linker where to find GCC&amp;rsquo;s C++ library (</source>
          <target state="translated">プログラムをリンクして特定のC ++ライブラリを使用する最も簡単な方法は、デフォルトでそのC ++ライブラリを指定するC ++ドライバを使用することです。 &lt;code&gt;g++&lt;/code&gt; ドライバは、例えば、GCCのC ++ライブラリを見つけるためにリンカに指示します（</target>
        </trans-unit>
        <trans-unit id="df6349c8ef5b50987899abffe38003acbe800a64" translate="yes" xml:space="preserve">
          <source>The multiprocessing extension.</source>
          <target state="translated">マルチプロセッシングの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="8d24347b639fc5c1199b8f3590bff6a146e13c82" translate="yes" xml:space="preserve">
          <source>The name of the function.</source>
          <target state="translated">関数の名前です。</target>
        </trans-unit>
        <trans-unit id="62e8e383964ec0763f310d8e73ac1d3feb12f8de" translate="yes" xml:space="preserve">
          <source>The names of specific parameters, and the meaning of the values, are tied to the internals of the compiler, and are subject to change without notice in future releases.</source>
          <target state="translated">特定のパラメータの名前と値の意味は、コンパイラの内部に関連付けられており、将来のリリースでは予告なく変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="329fe73400bc50b68cb243f0ab550043e7c95935" translate="yes" xml:space="preserve">
          <source>The native Linux/GNU toolchain also supports the value &amp;lsquo;</source>
          <target state="translated">ネイティブLinux / GNUツールチェーンも値をサポートしています '</target>
        </trans-unit>
        <trans-unit id="04c44aa6fff9d063f62cf98bb0599d7c6a3d3bb6" translate="yes" xml:space="preserve">
          <source>The nested function can access all the variables of the containing function that are visible at the point of its definition. This is called &lt;em&gt;lexical scoping&lt;/em&gt;. For example, here we show a nested function which uses an inherited variable named &lt;code&gt;offset&lt;/code&gt;:</source>
          <target state="translated">ネストされた関数は、その定義の時点で可視である包含関数のすべての変数にアクセスできます。これは&lt;em&gt;字句スコープ&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。たとえば、ここでは、 &lt;code&gt;offset&lt;/code&gt; という名前の継承された変数を使用するネストされた関数を示します。</target>
        </trans-unit>
        <trans-unit id="d50cb616ffb2082a3e3b7e7c2d21914b6c5a5b8a" translate="yes" xml:space="preserve">
          <source>The nested function&amp;rsquo;s name is local to the block where it is defined. For example, here we define a nested function named &lt;code&gt;square&lt;/code&gt;, and call it twice:</source>
          <target state="translated">入れ子関数の名前は、それが定義されているブロックに対してローカルです。たとえば、ここでは &lt;code&gt;square&lt;/code&gt; という名前のネストされた関数を定義し、それを2回呼び出します。</target>
        </trans-unit>
        <trans-unit id="2a845c4dca5c001e6d102157bfd313918d6f8a24" translate="yes" xml:space="preserve">
          <source>The nesting limit for &lt;code&gt;#include&lt;/code&gt; processing (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; 処理のネスト制限（C90 6.8.2、C99およびC11 6.10.2）。</target>
        </trans-unit>
        <trans-unit id="1446b5bc47ae4093c3d59b0d15fb2e41a888d931" translate="yes" xml:space="preserve">
          <source>The next example shows a case where the optimizers can recognize that the input (&lt;code&gt;dwSomeValue&lt;/code&gt;) never changes during the execution of the function and can therefore move the &lt;code&gt;asm&lt;/code&gt; outside the loop to produce more efficient code. Again, using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables this type of optimization.</source>
          <target state="translated">次の例は、関数の実行中に入力（ &lt;code&gt;dwSomeValue&lt;/code&gt; ）が変更されないことをオプティマイザが認識できるため、 &lt;code&gt;asm&lt;/code&gt; をループの外に移動してより効率的なコードを生成できる場合を示しています。繰り返しますが、 &lt;code&gt;volatile&lt;/code&gt; 修飾子を使用すると、このタイプの最適化が無効になります。</target>
        </trans-unit>
        <trans-unit id="1737091e750836f7db5ac991c2404cb583f13f75" translate="yes" xml:space="preserve">
          <source>The next revision of the ISO C++ standard, tentatively planned for 2020. Support is highly experimental, and will almost certainly change in incompatible ways in future releases.</source>
          <target state="translated">2020年に暫定的に予定されているISO C++規格の次の改訂版。サポートは非常に実験的なものであり、将来のリリースではほぼ確実に互換性のない方法で変更されます。</target>
        </trans-unit>
        <trans-unit id="07fa07f1abd567516650f6c81218681c600c92af" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development, plus GNU extensions. The support for this version is experimental and incomplete.</source>
          <target state="translated">ISO C標準の次のバージョンで、まだ開発中のものにGNU拡張を加えたものです。このバージョンのサポートは実験的で不完全です。</target>
        </trans-unit>
        <trans-unit id="2b02aa6b6d3d78493fbc1dc480d37a214f73df64" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development. The support for this version is experimental and incomplete.</source>
          <target state="translated">まだ開発中のISO C規格の次期バージョン。このバージョンのサポートは実験的で不完全です。</target>
        </trans-unit>
        <trans-unit id="2f0fbf82a063b2707d9377f7fa702f1fc2dca6a1" translate="yes" xml:space="preserve">
          <source>The nine trigraphs and their replacements are</source>
          <target state="translated">9つのトライグラフとそれに代わるものは</target>
        </trans-unit>
        <trans-unit id="d3e272d2493136e9ddd803eb8bb6b214c461ac69" translate="yes" xml:space="preserve">
          <source>The nineteen 32-bit registers comprising general register R0 to R14, control register GBR, and system registers MACH, MACL, and PR and the vector table address offset are saved into a register bank. Register banks are stacked in first-in last-out (FILO) sequence. Restoration from the bank is executed by issuing a RESBANK instruction.</source>
          <target state="translated">汎用レジスタR0~R14、制御レジスタGBR、システムレジスタMACH、MACL、PRからなる19個の32ビットレジスタとベクトルテーブルのアドレスオフセットをレジスタバンクに保存します。レジスタバンクはファーストインラストアウト(FILO)の順序でスタックされます。バンクからの復帰は、RESBANK 命令を発行することで実行されます。</target>
        </trans-unit>
        <trans-unit id="3ee0e8fe4a16194f52480c8cf2068fc9bdcd0c7f" translate="yes" xml:space="preserve">
          <source>The non-atomic types are encoded as follows:</source>
          <target state="translated">非原子型は以下のようにエンコードされています。</target>
        </trans-unit>
        <trans-unit id="7bfaebfb4258608ad40629ce440aac9193290911" translate="yes" xml:space="preserve">
          <source>The normal vector extract, and set operations work on &lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt; types, but the index value must be 0.</source>
          <target state="translated">通常のベクトル抽出およびセット操作は、 &lt;var&gt;vector __int128&lt;/var&gt; および &lt;var&gt;vector __uint128&lt;/var&gt; タイプで機能しますが、インデックス値は0でなければなりません。</target>
        </trans-unit>
        <trans-unit id="ec51f6eb264a163ff7656783d752463b0cf474e2" translate="yes" xml:space="preserve">
          <source>The null pointer constant to which the macro &lt;code&gt;NULL&lt;/code&gt; expands (C90 7.1.6, C99 7.17, C11 7.19).</source>
          <target state="translated">マクロ &lt;code&gt;NULL&lt;/code&gt; が展開されるNULLポインター定数（C90 7.1.6、C99 7.17、C11 7.19）。</target>
        </trans-unit>
        <trans-unit id="38d03781cbc2651157f17e0c5fbab40ff5879c62" translate="yes" xml:space="preserve">
          <source>The number of bits in a byte (C90 3.4, C99 and C11 3.6).</source>
          <target state="translated">バイトのビット数(C90 3.4、C99、C11 3.6)。</target>
        </trans-unit>
        <trans-unit id="5116832175ad50d3f8b15e3495e553905314a198" translate="yes" xml:space="preserve">
          <source>The number of cycles the swing modulo scheduler considers when checking conflicts using DFA.</source>
          <target state="translated">DFAを使用してコンフリクトをチェックする際にスイングモジュラスケジューラが考慮するサイクル数。</target>
        </trans-unit>
        <trans-unit id="1520c1ee154295eb07c627660dca8d1a6b6092fb" translate="yes" xml:space="preserve">
          <source>The number of significant initial characters in an identifier (C90 6.1.2, C90, C99 and C11 5.2.4.1, C99 and C11 6.4.2).</source>
          <target state="translated">識別子に含まれる有効な初期文字の数(C90 6.</target>
        </trans-unit>
        <trans-unit id="070362ab17f17b33a3ae34d59055a18a1e302bf9" translate="yes" xml:space="preserve">
          <source>The number, order, and encoding of bytes in any object (when not explicitly specified in this International Standard) (C99 and C11 6.2.6.1).</source>
          <target state="translated">任意のオブジェクト内のバイト数、順序及び符号化(この国際規格で明示的に規定されていない場合)(C99及びC11 6.2.6.1)。</target>
        </trans-unit>
        <trans-unit id="b604e74e2e851789383571b70ad652997e4e66f6" translate="yes" xml:space="preserve">
          <source>The object is accessed with the respective segment override prefix.</source>
          <target state="translated">オブジェクトは、それぞれのセグメントのオーバーライド接頭辞でアクセスされます。</target>
        </trans-unit>
        <trans-unit id="3a5091aabdc201178dc68e9213e404a14e73a3fa" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type.</source>
          <target state="translated">第一引数で指し示されるオブジェクトは整数型かポインタ型でなければなりません。ブール型であってはなりません。</target>
        </trans-unit>
        <trans-unit id="a4db2564696e493fee1ef7423f76307823d51b1d" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type. All memory orders are valid.</source>
          <target state="translated">第一引数で指し示されるオブジェクトは整数型かポインタ型でなければなりません。真偽値型であってはなりません。すべてのメモリオーダーが有効です。</target>
        </trans-unit>
        <trans-unit id="13e4eecfa7c007179ae8943f279500072d8d783d" translate="yes" xml:space="preserve">
          <source>The only difference between &amp;lsquo;</source>
          <target state="translated">の唯一の違い '</target>
        </trans-unit>
        <trans-unit id="e3de508e233b8d2680fdf435e3d6c8313768a8db" translate="yes" xml:space="preserve">
          <source>The only supported use for this feature is to specify registers for input and output operands when calling Extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;). This may be necessary if the constraints for a particular machine don&amp;rsquo;t provide sufficient control to select the desired register. To force an operand into a register, create a local variable and specify the register name after the variable&amp;rsquo;s declaration. Then use the local variable for the &lt;code&gt;asm&lt;/code&gt; operand and specify any constraint letter that matches the register:</source>
          <target state="translated">この機能の唯一のサポートされている用途は、Extended &lt;code&gt;asm&lt;/code&gt; を呼び出すときに、入力および出力オペランドのレジスターを指定することです（&lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asmを&lt;/a&gt;参照）。これは、特定のマシンの制約が目的のレジスタを選択するための十分な制御を提供しない場合に必要になることがあります。オペランドをレジスタに強制するには、ローカル変数を作成し、変数の宣言の後にレジスタ名を指定します。次に、ローカル変数を &lt;code&gt;asm&lt;/code&gt; オペランドに使用して、レジスターと一致する制約文字を指定します。</target>
        </trans-unit>
        <trans-unit id="80fd38457618adab2fab3528f71d1285f53dd5df" translate="yes" xml:space="preserve">
          <source>The operand is the number of a register to be read. Generates:</source>
          <target state="translated">オペランドは、読み込まれるレジスタの番号です。生成します。</target>
        </trans-unit>
        <trans-unit id="164925c793e36006eed2abf2f19f4ef48755a0ed" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;typeof&lt;/code&gt; is evaluated for its side effects if and only if it is an expression of variably modified type or the name of such a type.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; のオペランドは、可変的に変更された型の式またはそのような型の名前である場合にのみ、その副作用について評価されます。</target>
        </trans-unit>
        <trans-unit id="6d2a4c2f3546ef01bb01773e4920ca0359e67ac5" translate="yes" xml:space="preserve">
          <source>The operand, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register and must be a compile time constant. Generates:</source>
          <target state="translated">オペランド &lt;var&gt;auxv&lt;/var&gt; は、補助レジスターのアドレスであり、コンパイル時定数でなければなりません。生成：</target>
        </trans-unit>
        <trans-unit id="3479099f68d087cc74ace860bc00a95f5b731c1f" translate="yes" xml:space="preserve">
          <source>The operations behave like C++ &lt;code&gt;valarrays&lt;/code&gt;. Addition is defined as the addition of the corresponding elements of the operands. For example, in the code below, each of the 4 elements in &lt;var&gt;a&lt;/var&gt; is added to the corresponding 4 elements in &lt;var&gt;b&lt;/var&gt; and the resulting vector is stored in &lt;var&gt;c&lt;/var&gt;.</source>
          <target state="translated">操作はC ++ &lt;code&gt;valarrays&lt;/code&gt; のように動作します。加算は、オペランドの対応する要素の加算として定義されます。例えば、以下のコードで、4つの要素のそれぞれに対応する4つの要素に追加され &lt;var&gt;b&lt;/var&gt; 及び得られたベクターに格納されている &lt;var&gt;c&lt;/var&gt; 。 &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="fde6238c26830fa82a53914b9244e589ab1e426d" translate="yes" xml:space="preserve">
          <source>The operator &amp;lsquo;</source>
          <target state="translated">オペレーター '</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">オプション</target>
        </trans-unit>
        <trans-unit id="ae1ce068a17e5dbe0ea035d1beb9f2b11368df02" translate="yes" xml:space="preserve">
          <source>The option also sets the ISA to use. If the MCU name is one that is known to only support the 430 ISA then that is selected, otherwise the 430X ISA is selected. A generic MCU name of &amp;lsquo;</source>
          <target state="translated">このオプションは、使用するISAも設定します。MCU名が430 ISAのみをサポートすることがわかっている場合はそれが選択され、そうでない場合は430X ISAが選択されます。の一般的なMCU名</target>
        </trans-unit>
        <trans-unit id="bace175215f4c9a9a5086a4520e874099d58bc7b" translate="yes" xml:space="preserve">
          <source>The option cannot be combined with</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="c9e6b8f7b2e1e4a87728188dd3bdb8e34222fb03" translate="yes" xml:space="preserve">
          <source>The option has three forms:</source>
          <target state="translated">オプションには3つの形態があります。</target>
        </trans-unit>
        <trans-unit id="f57372a8b45a9a651870f464f28239ea0a9400c1" translate="yes" xml:space="preserve">
          <source>The option is equivalent to</source>
          <target state="translated">オプションは以下に相当します。</target>
        </trans-unit>
        <trans-unit id="25431ae1de44b7a0042861eaf001a15d12b77c5c" translate="yes" xml:space="preserve">
          <source>The option is similar to</source>
          <target state="translated">オプションは以下のようなものです。</target>
        </trans-unit>
        <trans-unit id="3f0b2b21730ed2a5e07ab579f0c874433e03d81f" translate="yes" xml:space="preserve">
          <source>The option&amp;rsquo;s behavior depends on the</source>
          <target state="translated">オプションの動作は、</target>
        </trans-unit>
        <trans-unit id="7003d8dcf16f832eac06c03046c9a171fa807708" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;volatile&lt;/code&gt; qualifier has no effect. All basic &lt;code&gt;asm&lt;/code&gt; blocks are implicitly volatile.</source>
          <target state="translated">オプションの &lt;code&gt;volatile&lt;/code&gt; 修飾子は効果がありません。すべての基本的な &lt;code&gt;asm&lt;/code&gt; ブロックは暗黙的に揮発性です。</target>
        </trans-unit>
        <trans-unit id="74a01a1e7aeded7ac16f376b31f6e97656f61592" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;sirevision&lt;/var&gt; specifies the silicon revision of the target Blackfin processor. Any workarounds available for the targeted silicon revision are enabled. If &lt;var&gt;sirevision&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">オプションの &lt;var&gt;sirevision&lt;/var&gt; は、ターゲットBlackfinプロセッサーのシリコンリビジョンを指定します。ターゲットのシリコンリビジョンで利用可能な回避策は有効になっています。もし &lt;var&gt;sirevision&lt;/var&gt; は 'です</target>
        </trans-unit>
        <trans-unit id="f72849bef73954b968c2b10753acfe7d2de97d61" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;mask&lt;/var&gt; may have the value &lt;code&gt;notinbranch&lt;/code&gt; or &lt;code&gt;inbranch&lt;/code&gt;, and instructs the compiler to generate non-masked or masked clones correspondingly. By default, all clones are generated.</source>
          <target state="translated">オプションの引数 &lt;var&gt;mask&lt;/var&gt; 値があり &lt;code&gt;notinbranch&lt;/code&gt; または &lt;code&gt;inbranch&lt;/code&gt; を、それに応じてマスクされていないか、マスクされたクローンを生成するようにコンパイラーに指示します。デフォルトでは、すべてのクローンが生成されます。</target>
        </trans-unit>
        <trans-unit id="bf601c68a359b3325301de84f8214ec6cb3bee0d" translate="yes" xml:space="preserve">
          <source>The optional extension of specifying vector constants in parentheses is not supported.</source>
          <target state="translated">括弧内にベクトル定数を指定するオプションの拡張はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="8e1def618310843db3ebed1e3d40c1b748262844" translate="yes" xml:space="preserve">
          <source>The optional first word limits the specification to structs that are used directly (&amp;lsquo;</source>
          <target state="translated">オプションの最初の単語は、直接使用される構造体（ '</target>
        </trans-unit>
        <trans-unit id="a9fe5708942d28978cc841b9258dd8862934e265" translate="yes" xml:space="preserve">
          <source>The optional second word limits the specification to ordinary structs (&amp;lsquo;</source>
          <target state="translated">オプションの2番目の単語は、指定を通常の構造体（ '</target>
        </trans-unit>
        <trans-unit id="01a150b476753c90be937c4eb85655e5b29ceeef" translate="yes" xml:space="preserve">
          <source>The options</source>
          <target state="translated">オプション</target>
        </trans-unit>
        <trans-unit id="ac4a8e159eb45db26e41d6b181749d12e91d13f3" translate="yes" xml:space="preserve">
          <source>The options from each group can be freely mixed as they are non-overlapping. However, in case of any conflicts, the later options override the earlier options on the command line.</source>
          <target state="translated">各グループのオプションは重複しないので、自由に混在させることができます。ただし、競合があった場合は、コマンドライン上では後のオプションが前のオプションを上書きします。</target>
        </trans-unit>
        <trans-unit id="03370c70b8d685b972b4178e392c07f67da021e0" translate="yes" xml:space="preserve">
          <source>The options in this section are defined for all VxWorks targets. Options specific to the target hardware are listed with the other options for that target.</source>
          <target state="translated">このセクションのオプションは、すべてのVxWorksターゲットに対して定義されています。ターゲットハードウェアに固有のオプションは、そのターゲットの他のオプションと一緒にリストアップされています。</target>
        </trans-unit>
        <trans-unit id="ee4645ad9aafdb886f64431f817492a531da45bb" translate="yes" xml:space="preserve">
          <source>The options supported are specific to each target; refer to &lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;x86 Function Attributes&lt;/a&gt;, &lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC Function Attributes&lt;/a&gt;, &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;, &lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64 Function Attributes&lt;/a&gt;, &lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;Nios II Function Attributes&lt;/a&gt;, and &lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S/390 Function Attributes&lt;/a&gt; for details.</source>
          <target state="translated">サポートされるオプションは、各ターゲットに固有です。詳細については、&lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;x86関数属性&lt;/a&gt;、&lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC関数属性&lt;/a&gt;、&lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM関数属性&lt;/a&gt;、&lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64関数属性&lt;/a&gt;、&lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;Nios II関数属性&lt;/a&gt;、および&lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S / 390関数属性&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="91a395788ed90836d2997bb1c84003ea7ffde770" translate="yes" xml:space="preserve">
          <source>The options work exactly like the S/390 specific command line options (without the prefix</source>
          <target state="translated">オプションは S/390 固有のコマンドラインオプションとまったく同じように動作します (接頭辞なし)</target>
        </trans-unit>
        <trans-unit id="e9e8fa6c8ae05f8e2a34557e6036eae0a9b76ff8" translate="yes" xml:space="preserve">
          <source>The order in which &lt;code&gt;+load&lt;/code&gt; and &lt;code&gt;+initialize&lt;/code&gt; are called could be problematic if this matters. If you don&amp;rsquo;t allocate objects inside &lt;code&gt;+load&lt;/code&gt;, it is guaranteed that &lt;code&gt;+load&lt;/code&gt; is called before &lt;code&gt;+initialize&lt;/code&gt;. If you create an object inside &lt;code&gt;+load&lt;/code&gt; the &lt;code&gt;+initialize&lt;/code&gt; method of object&amp;rsquo;s class is invoked even if &lt;code&gt;+load&lt;/code&gt; was not invoked. Note if you explicitly call &lt;code&gt;+load&lt;/code&gt; on a class, &lt;code&gt;+initialize&lt;/code&gt; will be called first. To avoid possible problems try to implement only one of these methods.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; と &lt;code&gt;+initialize&lt;/code&gt; が呼び出される順序は、これが重要な場合に問題になる可能性があります。 &lt;code&gt;+load&lt;/code&gt; 内でオブジェクトを割り当てない場合は、 &lt;code&gt;+initialize&lt;/code&gt; の前に+ &lt;code&gt;+load&lt;/code&gt; が呼び出されることが保証されます。あなたは、オブジェクトの内部を作成する場合は &lt;code&gt;+load&lt;/code&gt; &lt;code&gt;+initialize&lt;/code&gt; オブジェクトのクラスのメソッドがあっても起動されます &lt;code&gt;+load&lt;/code&gt; 起動されていませんでした。クラスで &lt;code&gt;+initialize&lt;/code&gt; &lt;code&gt;+load&lt;/code&gt; を明示的に呼び出すと、+ initializeが最初に呼び出されます。考えられる問題を回避するために、これらのメソッドの1つだけを実装するようにしてください。</target>
        </trans-unit>
        <trans-unit id="d72c8cfa2bf4559a476794fbcac9230458dd1acf" translate="yes" xml:space="preserve">
          <source>The order of allocation of bit-fields within a unit (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">単位内のビットフィールドの割り当て順序(C90 6.5.2.1、C99、C11 6.7.2.1)。</target>
        </trans-unit>
        <trans-unit id="13bf99243d90e9f90c583730aacfa820007d4c7a" translate="yes" xml:space="preserve">
          <source>The ordering and number of these preamble lines will be augmented as &lt;code&gt;gcov&lt;/code&gt; development progresses &amp;mdash; do not rely on them remaining unchanged. Use &lt;var&gt;tag&lt;/var&gt; to locate a particular preamble line.</source>
          <target state="translated">これらのプリアンブルラインの順序と数は、 &lt;code&gt;gcov&lt;/code&gt; の開発が進むにつれて増加します。これらが変更されていないことに依存しないでください。 &lt;var&gt;tag&lt;/var&gt; を使用して、特定のプリアンブルラインを見つけます。</target>
        </trans-unit>
        <trans-unit id="f78a9eb6841c341650bf4b7b23dd41a17afa341e" translate="yes" xml:space="preserve">
          <source>The original ANSI C standard (X3.159-1989) was ratified in 1989 and published in 1990. This standard was ratified as an ISO standard (ISO/IEC 9899:1990) later in 1990. There were no technical differences between these publications, although the sections of the ANSI standard were renumbered and became clauses in the ISO standard. The ANSI standard, but not the ISO standard, also came with a Rationale document. This standard, in both its forms, is commonly known as &lt;em&gt;C89&lt;/em&gt;, or occasionally as &lt;em&gt;C90&lt;/em&gt;, from the dates of ratification. To select this standard in GCC, use one of the options</source>
          <target state="translated">元のANSI C標準（X3.159-1989）は1989年に承認され、1990年に公開されました。この標準はISO標準（ISO / IEC 9899：1990）として1990年の後半に承認されました。これらの出版物に技術的な違いはありませんでした。ただし、ANSI標準のセクションは番号が付け直され、ISO標準の条項になりました。 ISO規格ではなくANSI規格にもRationaleドキュメントが付属しています。この規格は、その両方の形式で、批准の日付から一般に&lt;em&gt;C89&lt;/em&gt;、または場合によっては&lt;em&gt;C90&lt;/em&gt;として知られています。 GCCでこの標準を選択するには、いずれかのオプションを使用します</target>
        </trans-unit>
        <trans-unit id="21c496279e266f5ecd75f883afecb2192cd2a917" translate="yes" xml:space="preserve">
          <source>The original ISO C++ standard was published as the ISO standard (ISO/IEC 14882:1998) and amended by a Technical Corrigenda published in 2003 (ISO/IEC 14882:2003). These standards are referred to as C++98 and C++03, respectively. GCC implements the majority of C++98 (&lt;code&gt;export&lt;/code&gt; is a notable exception) and most of the changes in C++03. To select this standard in GCC, use one of the options</source>
          <target state="translated">元のISO C ++標準は、ISO標準（ISO / IEC 14882：1998）として公開され、2003年に発行されたTechnical Corrigenda（ISO / IEC 14882：2003）によって修正されました。これらの標準は、それぞれC ++ 98およびC ++ 03と呼ばれます。 GCCはC ++ 98の大部分（ &lt;code&gt;export&lt;/code&gt; は注目すべき例外です）とC ++ 03のほとんどの変更を実装しています。 GCCでこの標準を選択するには、いずれかのオプションを使用します</target>
        </trans-unit>
        <trans-unit id="d55c2d645aa0f80881178d7412aa07a062ca969b" translate="yes" xml:space="preserve">
          <source>The other options specify a specific processor. Code generated under those options runs best on that processor, and may not run at all on others.</source>
          <target state="translated">その他のオプションは、特定のプロセッサを指定します。これらのオプションで生成されたコードは、そのプロセッサ上で最もよく動作し、他のプロセッサでは全く動作しない場合があります。</target>
        </trans-unit>
        <trans-unit id="7b5fefa619d556bce9b8629c20698a9fbaa045b6" translate="yes" xml:space="preserve">
          <source>The output is sensitive to the effects of previous command-line options, so for example it is possible to find out which optimizations are enabled at</source>
          <target state="translated">出力は以前のコマンドラインオプションの影響を受けやすいので、例えば</target>
        </trans-unit>
        <trans-unit id="ee1f8d32c864542b44f4a83fd30d75feed01b2e0" translate="yes" xml:space="preserve">
          <source>The output shows that this block of code, combined by optimization, executed 100 times. In one sense this result is correct, because there was only one instruction representing all four of these lines. However, the output does not indicate how many times the result was 0 and how many times the result was 1.</source>
          <target state="translated">出力は、最適化によって結合されたこのコードブロックが 100 回実行されたことを示しています。これらの4行すべてを表す命令が1つしかなかったので、ある意味ではこの結果は正しいです。しかし、この出力は、結果が何回0で、何回1であったかを示していません。</target>
        </trans-unit>
        <trans-unit id="25cd388eab46b62953cbdcb13acb11f5a206e81f" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;archetype&lt;/var&gt; determines how the format string is interpreted, and should be &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt;, &lt;code&gt;gnu_printf&lt;/code&gt;, &lt;code&gt;gnu_scanf&lt;/code&gt;, &lt;code&gt;gnu_strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt;. (You can also use &lt;code&gt;__printf__&lt;/code&gt;, &lt;code&gt;__scanf__&lt;/code&gt;, &lt;code&gt;__strftime__&lt;/code&gt; or &lt;code&gt;__strfmon__&lt;/code&gt;.) On MinGW targets, &lt;code&gt;ms_printf&lt;/code&gt;, &lt;code&gt;ms_scanf&lt;/code&gt;, and &lt;code&gt;ms_strftime&lt;/code&gt; are also present. &lt;var&gt;archetype&lt;/var&gt; values such as &lt;code&gt;printf&lt;/code&gt; refer to the formats accepted by the system&amp;rsquo;s C runtime library, while values prefixed with &amp;lsquo;</source>
          <target state="translated">パラメータ &lt;var&gt;archetype&lt;/var&gt; は、フォーマット文字列の解釈方法を決定し、 &lt;code&gt;printf&lt;/code&gt; 、 &lt;code&gt;scanf&lt;/code&gt; 、 &lt;code&gt;strftime&lt;/code&gt; 、 &lt;code&gt;gnu_printf&lt;/code&gt; 、 &lt;code&gt;gnu_scanf&lt;/code&gt; 、 &lt;code&gt;gnu_strftime&lt;/code&gt; または &lt;code&gt;strfmon&lt;/code&gt; である必要があります。（ &lt;code&gt;__printf__&lt;/code&gt; 、 &lt;code&gt;__scanf__&lt;/code&gt; 、 &lt;code&gt;__strftime__&lt;/code&gt; または &lt;code&gt;__strfmon__&lt;/code&gt; を使用することもできます。）MinGWターゲットには、 &lt;code&gt;ms_printf&lt;/code&gt; 、 &lt;code&gt;ms_scanf&lt;/code&gt; 、および &lt;code&gt;ms_strftime&lt;/code&gt; も存在します。 &lt;code&gt;printf&lt;/code&gt; などの &lt;var&gt;archetype&lt;/var&gt; 値 システムのCランタイムライブラリが受け入れる形式を参照し、値の前に「</target>
        </trans-unit>
        <trans-unit id="a3f3b990be6aa69326bd74ae4681ebc09216102d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;string-index&lt;/var&gt; specifies which argument is the format string argument (starting from one). Since non-static C++ methods have an implicit &lt;code&gt;this&lt;/code&gt; argument, the arguments of such methods should be counted from two.</source>
          <target state="translated">パラメーター &lt;var&gt;string-index&lt;/var&gt; は、どの引数がフォーマット文字列引数であるか（1から始まる）を指定します。非静的C ++メソッドには暗黙の &lt;code&gt;this&lt;/code&gt; 引数があるため、そのようなメソッドの引数は2から数える必要があります。</target>
        </trans-unit>
        <trans-unit id="0bb73878f5340c14052a29fb8e00d23ff62b384d" translate="yes" xml:space="preserve">
          <source>The part of a compiler that is specific to a particular language is called the &amp;ldquo;front end&amp;rdquo;. In addition to the front ends that are integrated components of GCC, there are several other front ends that are maintained separately. These support languages such as Mercury, and COBOL. To use these, they must be built together with GCC proper.</source>
          <target state="translated">特定の言語に固有のコンパイラーの部分は、「フロントエンド」と呼ばれます。GCCの統合コンポーネントであるフロントエンドに加えて、個別に保守される他のいくつかのフロントエンドがあります。これらは、MercuryやCOBOLなどの言語をサポートしています。これらを使用するには、GCC本体とともにビルドする必要があります。</target>
        </trans-unit>
        <trans-unit id="27b45d0ebc931e1e733ecb9fb1c3f4c5240b8194" translate="yes" xml:space="preserve">
          <source>The particular options set for any particular CPU varies between compiler versions, depending on what setting seems to produce optimal code for that CPU; it doesn&amp;rsquo;t necessarily reflect the actual hardware&amp;rsquo;s capabilities. If you wish to set an individual option to a particular value, you may specify it after the</source>
          <target state="translated">特定のCPUに設定される特定のオプションは、そのCPUに最適なコードを生成するように見える設定に応じて、コンパイラのバージョンによって異なります。実際のハードウェアの機能を必ずしも反映しているわけではありません。個々のオプションを特定の値に設定したい場合は、</target>
        </trans-unit>
        <trans-unit id="452dc4aa50f4dd1fa4974069451a474c59e40f9c" translate="yes" xml:space="preserve">
          <source>The parts that differ are highlighted with color (&amp;ldquo;double&amp;rdquo; and &amp;ldquo;float&amp;rdquo; in this case).</source>
          <target state="translated">異なる部分は色で強調表示されます（この場合は「double」と「float」）。</target>
        </trans-unit>
        <trans-unit id="9af1a3f7e74758af6362de95fe293ce9aa19535b" translate="yes" xml:space="preserve">
          <source>The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is available.</source>
          <target state="translated">トレース形成でカバーする必要がある関数の割合(実行頻度で加重)。プロファイルフィードバックが利用可能な場合に使用します。</target>
        </trans-unit>
        <trans-unit id="2679379ebc643273c71ff53ef41c24d477972525" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;arch&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;arch&lt;/var&gt; の許容値は '</target>
        </trans-unit>
        <trans-unit id="f2d47f57e4f2874c39d4b9abd17b4e23013a44ad" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;feature&lt;/var&gt; are listed in the sub-section on &lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-march&lt;/samp&gt; and &lt;samp&gt;-mcpu&lt;/samp&gt; Feature Modifiers&lt;/a&gt;. Where conflicting feature modifiers are specified, the right-most feature is used.</source>
          <target state="translated">&lt;var&gt;feature&lt;/var&gt; の許容値は、次のサブセクションにリストされています。&lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-行進&lt;/samp&gt; そして &lt;samp&gt;-mcpu&lt;/samp&gt;機能修飾子&lt;/a&gt;。競合する機能修飾子が指定されている場合、最も右側の機能が使用されます。</target>
        </trans-unit>
        <trans-unit id="c7e86233015dde5cd1c78847180c34b2f1e2bf2b" translate="yes" xml:space="preserve">
          <source>The places that are searched for an included &amp;lsquo;</source>
          <target state="translated">インクルードを検索する場所 '</target>
        </trans-unit>
        <trans-unit id="dd8b187fae5590414120f103d445af72242d5c3b" translate="yes" xml:space="preserve">
          <source>The position in the bit-field is the position, counting in bits, of the bit closest to the beginning of the structure.</source>
          <target state="translated">ビットフィールド内の位置は、構造体の先頭に最も近いビットの位置で、ビット単位で数えます。</target>
        </trans-unit>
        <trans-unit id="c4b546e403df1ecde52f18e1df9da4aeb8d7bc41" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;var&gt;visibility_type&lt;/var&gt; correspond to the visibility settings in the ELF gABI.</source>
          <target state="translated">&lt;var&gt;visibility_type&lt;/var&gt; の可能な値は、ELF gABIの可視性設定に対応しています。</target>
        </trans-unit>
        <trans-unit id="f6264d8e91343ef3a61a9b344f8646bf4aba8cc7" translate="yes" xml:space="preserve">
          <source>The practice of reading from a different union member than the one most recently written to (called &amp;ldquo;type-punning&amp;rdquo;) is common. Even with</source>
          <target state="translated">最近書き込まれたものとは別のユニオンメンバーから読み取る方法（「タイプパニング」と呼ばれます）は一般的です。でもで</target>
        </trans-unit>
        <trans-unit id="3fcfc9f88180eb2f1134228de5ee485783fb7bf2" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the AArch64 target correspond to the AArch64 target function attributes. They can be specified as below:</source>
          <target state="translated">AArch64 タ ーゲ ッ ト で定義 さ れたプ ラ グ マは、 AArch64 タ ーゲ ッ ト 関数属性に対応 し ます。以下のように指定できます。</target>
        </trans-unit>
        <trans-unit id="645dbf1ac450b591d9e4ddc2872516c2fa74709d" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the S/390 target correspond to the S/390 target function attributes and some the additional options:</source>
          <target state="translated">S/390ターゲットで定義されたプラグマは、S/390ターゲットの機能属性といくつかの追加オプションに対応しています。</target>
        </trans-unit>
        <trans-unit id="2c0f7aae6dce4abe2e06c56745ef40bd52aa8844" translate="yes" xml:space="preserve">
          <source>The precise convention for returning structures in memory depends on the target configuration macros.</source>
          <target state="translated">メモリ内の構造体を返すための正確な規則は、ターゲットの設定マクロに依存します。</target>
        </trans-unit>
        <trans-unit id="91248f1a5a5155ccc98999905b33b441a4c0b382" translate="yes" xml:space="preserve">
          <source>The precompiled header file must be produced for the same language as the current compilation. You cannot use a C precompiled header for a C++ compilation.</source>
          <target state="translated">プリコンパイルされたヘッダーファイルは、現在のコンパイルと同じ言語用に作成する必要があります。CのプリコンパイルされたヘッダをC++のコンパイルに使用することはできません。</target>
        </trans-unit>
        <trans-unit id="a7364d3dac14debc46aa1590555ff15d8a2c5504" translate="yes" xml:space="preserve">
          <source>The precompiled header file must have been produced by the same compiler binary as the current compilation is using.</source>
          <target state="translated">プリコンパイルされたヘッダーファイルは、現在のコンパイルで使用しているものと同じコンパイラバイナリで作成されている必要があります。</target>
        </trans-unit>
        <trans-unit id="fa601548ca48cf3a1634bdb3b2571be6608e559a" translate="yes" xml:space="preserve">
          <source>The preferred mechanism to declare variable-length types like &lt;code&gt;struct line&lt;/code&gt; above is the ISO C99 &lt;em&gt;flexible array member&lt;/em&gt;, with slightly different syntax and semantics:</source>
          <target state="translated">上記の &lt;code&gt;struct line&lt;/code&gt; のような可変長型を宣言するための推奨メカニズムは、ISO C99 &lt;em&gt;フレキシブル配列メンバーで&lt;/em&gt;、構文とセマンティクスが少し異なります。</target>
        </trans-unit>
        <trans-unit id="781223d90b25e173d9a1c191f04f39b92b12674b" translate="yes" xml:space="preserve">
          <source>The preprocessor constants &lt;code&gt;__v850&lt;/code&gt; and &lt;code&gt;__v851__&lt;/code&gt; are always defined, regardless of which processor variant is the target.</source>
          <target state="translated">プリプロセッサ定数 &lt;code&gt;__v850&lt;/code&gt; および &lt;code&gt;__v851__&lt;/code&gt; は、ターゲットのプロセッサバリアントに関係なく、常に定義されています。</target>
        </trans-unit>
        <trans-unit id="516a25c40cc84aaf870728160964e02be2e34941" translate="yes" xml:space="preserve">
          <source>The preprocessor macro &lt;code&gt;__nios2_arch__&lt;/code&gt; is available to programs, with value 1 or 2, indicating the targeted ISA level.</source>
          <target state="translated">プリプロセッサマクロ &lt;code&gt;__nios2_arch__&lt;/code&gt; は、ターゲットのISAレベルを示す値1または2でプログラムで使用できます。</target>
        </trans-unit>
        <trans-unit id="e7e3cb02afe1efb7ea595142066c8a4b5aee7508" translate="yes" xml:space="preserve">
          <source>The preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; and &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; may be used to check which semantics are in effect for &lt;code&gt;inline&lt;/code&gt; functions. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Common Predefined Macros&lt;/a&gt; in The C Preprocessor.</source>
          <target state="translated">プリプロセッサマクロ &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; および &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; を使用して、 &lt;code&gt;inline&lt;/code&gt; 関数に有効なセマンティクスを確認できます。Cプリプロセッサの&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;一般的な事前定義マクロ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e144b8574fca5ee84d650870787998db8cc0a6cc" translate="yes" xml:space="preserve">
          <source>The preprocessor symbols &lt;code&gt;__SEG_FS&lt;/code&gt; and &lt;code&gt;__SEG_GS&lt;/code&gt; are defined when these address spaces are supported.</source>
          <target state="translated">これらのアドレススペースがサポートされている場合、プリプロセッサシンボル &lt;code&gt;__SEG_FS&lt;/code&gt; および &lt;code&gt;__SEG_GS&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="59cc56242765d93d1139cc69346a113ae66f0437" translate="yes" xml:space="preserve">
          <source>The preprocessor treatment of escaped newlines is more relaxed than that specified by the C90 standard, which requires the newline to immediately follow a backslash. GCC&amp;rsquo;s implementation allows whitespace in the form of spaces, horizontal and vertical tabs, and form feeds between the backslash and the subsequent newline. The preprocessor issues a warning, but treats it as a valid escaped newline and combines the two lines to form a single logical line. This works within comments and tokens, as well as between tokens. Comments are &lt;em&gt;not&lt;/em&gt; treated as whitespace for the purposes of this relaxation, since they have not yet been replaced with spaces.</source>
          <target state="translated">エスケープされた改行のプリプロセッサ処理は、改行がバックスラッシュの直後に続くことが必要なC90標準で指定されているものよりも緩和されています。 GCCの実装では、スペース、水平および垂直タブの形式の空白、およびバックスラッシュと後続の改行の間のフォームフィードが許可されます。プリプロセッサーは警告を出しますが、それを有効なエスケープされた改行として扱い、2つの行を結合して1つの論理行を形成します。これは、コメントとトークン内だけでなく、トークン間でも機能します。コメントがされて&lt;em&gt;いない&lt;/em&gt;、彼らはまだ空白に置き換えられていないので、この緩和の目的のためにホワイトスペースとして処理しました。</target>
        </trans-unit>
        <trans-unit id="a2282938cc4db5b60fc722ea3f4e0b1558cfa2dc" translate="yes" xml:space="preserve">
          <source>The program counter (PC) is 2 bytes wide. This is the case for devices with up to 128 KiB of program memory.</source>
          <target state="translated">プログラムカウンタ(PC)は2バイト幅です。これは、最大128KiBのプログラムメモリを持つデバイスの場合です。</target>
        </trans-unit>
        <trans-unit id="bdec771ba3fce1f14ccbe2f783eeba3b5eb697cc" translate="yes" xml:space="preserve">
          <source>The programs that fix the header files do not understand this special way of using symbolic links; therefore, the directory of fixed header files is good only for the machine model used to build it.</source>
          <target state="translated">ヘッダファイルを固定するプログラムは、シンボリックリンクを使用するこの特別な方法を理解していません;したがって、固定されたヘッダファイルのディレクトリは、それを構築するために使用されるマシンモデルのためだけに良いです。</target>
        </trans-unit>
        <trans-unit id="09f7403716543aa22328bdac3e1ded4dc52aedb3" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;dynamic&lt;/code&gt; means that the function manipulates the stack dynamically: in addition to the static allocation described above, stack adjustments are made in the body of the function, for example to push/pop arguments around function calls. If the qualifier &lt;code&gt;bounded&lt;/code&gt; is also present, the amount of these adjustments is bounded at compile time and the second field is an upper bound of the total amount of stack used by the function. If it is not present, the amount of these adjustments is not bounded at compile time and the second field only represents the bounded part.</source>
          <target state="translated">&lt;code&gt;dynamic&lt;/code&gt; 修飾子は、関数がスタックを動的に操作することを意味します。上記の静的割り当てに加えて、関数の本体でスタックの調整が行われます。たとえば、関数呼び出しの周りに引数をプッシュ/ポップします。 &lt;code&gt;bounded&lt;/code&gt; の修飾子も存在する場合、これらの調整の量はコンパイル時に制限され、2番目のフィールドは、関数によって使用されるスタックの合計量の上限です。存在しない場合、これらの調整の量はコンパイル時に制限されず、2番目のフィールドは制限された部分のみを表します。</target>
        </trans-unit>
        <trans-unit id="16b6ee8f6057a92bf82347dbc31b9360f115d43a" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;static&lt;/code&gt; means that the function manipulates the stack statically: a fixed number of bytes are allocated for the frame on function entry and released on function exit; no stack adjustments are otherwise made in the function. The second field is this fixed number of bytes.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 修飾子は、関数がスタックを静的に操作することを意味します。固定バイト数が関数の入り口でフレームに割り当てられ、関数の出口で解放されます。それ以外の場合、関数ではスタック調整は行われません。2番目のフィールドは、この固定バイト数です。</target>
        </trans-unit>
        <trans-unit id="d99c785e19e25b0fcfa2c0d8dc79cf7ec34db9e9" translate="yes" xml:space="preserve">
          <source>The rank of any extended integer type relative to another extended integer type with the same precision (C99 and C11 6.3.1.1).</source>
          <target state="translated">同一精度の別の拡張整数型に対する任意の拡張整数型の順位(C99及びC11 6.3.1.1)。</target>
        </trans-unit>
        <trans-unit id="cf6573d176933b5e09eb83df2d5615b45a3bb76e" translate="yes" xml:space="preserve">
          <source>The reason for using names that start with underscores for the local variables is to avoid conflicts with variable names that occur within the expressions that are substituted for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Eventually we hope to design a new form of declaration syntax that allows you to declare variables whose scopes start only after their initializers; this will be a more reliable way to prevent such conflicts.</source>
          <target state="translated">ローカル変数にアンダースコアで始まる名前を使用する理由 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; およびbの代わりに使用される式内で発生する変数名との競合を回避するためです。最終的には、初期化子の後にのみスコープが始まる変数を宣言できる新しい形式の宣言構文を設計したいと考えています。これは、このような競合を防ぐためのより信頼できる方法です。</target>
        </trans-unit>
        <trans-unit id="17b5e6eec29945ad1cdc98a53fb0e13f400b8a4b" translate="yes" xml:space="preserve">
          <source>The register assignments for arguments and return values remain the same, but each scalar value is passed in a single 64-bit register rather than a pair of 32-bit registers. For example, scalar floating-point values are returned in &amp;lsquo;</source>
          <target state="translated">引数と戻り値のレジスタ割り当ては同じままですが、各スカラー値は、32ビットレジスタのペアではなく、単一の64ビットレジスタで渡されます。たとえば、スカラー浮動小数点値は '</target>
        </trans-unit>
        <trans-unit id="df089519561a6aaf6b0d5462a2d12a16f51ac16a" translate="yes" xml:space="preserve">
          <source>The register class usable in short insns. This is a register class constraint, and can thus drive register allocation. This constraint won&amp;rsquo;t match unless</source>
          <target state="translated">short insnsで使用可能なレジスタクラス。これはレジスタクラスの制約であるため、レジスタの割り当てを制御できます。この制約は、一致しない限り一致しません。</target>
        </trans-unit>
        <trans-unit id="ce5827517313f66ee35c67440ea785808e96b2d8" translate="yes" xml:space="preserve">
          <source>The register group usable in short insns. This constraint does not use a register class, so that it only passively matches suitable registers, and doesn&amp;rsquo;t drive register allocation.</source>
          <target state="translated">short insnsで使用可能なレジスタグループ。この制約はレジスタクラスを使用しないため、適切なレジスタにパッシブに一致するだけで、レジスタの割り当ては行われません。</target>
        </trans-unit>
        <trans-unit id="72d3acac63bf69f2e9cbe4802b6dfb23c1a3dc0a" translate="yes" xml:space="preserve">
          <source>The register indicated by Rx (not implemented yet).</source>
          <target state="translated">Rxで示されたレジスタ(未実装)。</target>
        </trans-unit>
        <trans-unit id="b14ae46b310b2d10e38a2d9126edc47d0a1b7438" translate="yes" xml:space="preserve">
          <source>The registers reserved for interrupts (&lt;code&gt;R24&lt;/code&gt; to &lt;code&gt;R31&lt;/code&gt;).</source>
          <target state="translated">割り込み用に予約されているレジスター（ &lt;code&gt;R24&lt;/code&gt; から &lt;code&gt;R31&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5b9c9dc3621d339e8f64077eedb5da8839ab6a60" translate="yes" xml:space="preserve">
          <source>The relevant bytes of the representation of the object are treated as an object of the type used for the access. See &lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;Type-punning&lt;/a&gt;. This may be a trap representation.</source>
          <target state="translated">オブジェクトの表現の関連するバイトは、アクセスに使用されるタイプのオブジェクトとして扱われます。&lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;Type-punningを&lt;/a&gt;参照してください。これはトラップ表現である可能性があります。</target>
        </trans-unit>
        <trans-unit id="f41e3aebc6e71662ecec887032e93bdb3882f388" translate="yes" xml:space="preserve">
          <source>The remainder of this section is specific to GNU C90 inlining.</source>
          <target state="translated">このセクションの残りの部分はGNU C90のインライン化に特有のものです。</target>
        </trans-unit>
        <trans-unit id="558c61b7cf4311ca70d848b51262ab1898c102b3" translate="yes" xml:space="preserve">
          <source>The remaining environment variables apply only when preprocessing the particular language indicated. Each specifies a list of directories to be searched as if specified with</source>
          <target state="translated">残りの環境変数は、指定された特定の言語を前処理する場合にのみ適用されます。それぞれの環境変数は、検索されるディレクトリのリストを</target>
        </trans-unit>
        <trans-unit id="c96b85add00a5f322d58fcbd72ee7befb1dea21f" translate="yes" xml:space="preserve">
          <source>The remaining functions are provided for optimization purposes.</source>
          <target state="translated">残りの関数は最適化のために提供されています。</target>
        </trans-unit>
        <trans-unit id="4420491dd7bf1c05e945f7d72f0a1731089f6301" translate="yes" xml:space="preserve">
          <source>The respective segment base must be set via some method specific to the operating system. Rather than require an expensive system call to retrieve the segment base, these address spaces are not considered to be subspaces of the generic (flat) address space. This means that explicit casts are required to convert pointers between these address spaces and the generic address space. In practice the application should cast to &lt;code&gt;uintptr_t&lt;/code&gt; and apply the segment base offset that it installed previously.</source>
          <target state="translated">それぞれのセグメントベースは、オペレーティングシステムに固有の方法で設定する必要があります。これらのアドレススペースは、セグメントベースを取得するために高価なシステムコールを必要とするのではなく、汎用（フラット）アドレススペースのサブスペースとは見なされません。つまり、これらのアドレス空間と汎用アドレス空間の間でポインターを変換するには、明示的なキャストが必要です。実際には、アプリケーションは &lt;code&gt;uintptr_t&lt;/code&gt; にキャストし、以前にインストールしたセグメントベースオフセットを適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9b4574d542eb42ca2e1f7130ac8122d2979c3b76" translate="yes" xml:space="preserve">
          <source>The rest of this discussion uses the following code for illustrative purposes.</source>
          <target state="translated">この議論の残りの部分では、説明のために以下のコードを使用しています。</target>
        </trans-unit>
        <trans-unit id="6771696cde55a31392f32b7d1552e2429667db0a" translate="yes" xml:space="preserve">
          <source>The restrictions on &lt;code&gt;offsetof&lt;/code&gt; may be relaxed in a future version of the C++ standard.</source>
          <target state="translated">&lt;code&gt;offsetof&lt;/code&gt; の制限は、C ++標準の将来のバージョンで緩和される可能性があります。</target>
        </trans-unit>
        <trans-unit id="dd1a1a42d6420a3422e966b9e8baa0847229727c" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlmi&lt;/code&gt; is obtained by rotating each element of the first argument vector left and inserting it under mask into the second argument vector. The third argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="translated">&lt;code&gt;vec_rlmi&lt;/code&gt; の結果は、最初の引数ベクトルの各要素を左に回転させ、それをマスクの下で2番目の引数ベクトルに挿入することによって取得されます。3番目の引数ベクトルには、各要素のビット11:15で始まるマスク、ビット19:23で終わるマスク、およびビット27:31のシフトカウントが含まれています。</target>
        </trans-unit>
        <trans-unit id="b9a3f0d57a834ed4eba9054b925159bf84ea4a8e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask specified by the second and third argument vectors. The second argument vector contains the shift count for each element in the low-order byte. The third argument vector contains the mask end for each element in the low-order byte, with the mask begin in the next higher byte.</source>
          <target state="translated">&lt;code&gt;vec_rlnm&lt;/code&gt; の結果は、最初の引数ベクトルの各要素を左に回転させ、2番目と3番目の引数ベクトルで指定されたマスクとAND 演算することによって取得されます。2番目の引数ベクトルには、下位バイトの各要素のシフトカウントが含まれます。3番目の引数ベクトルには、下位バイトの各要素のマスクの終わりが含まれ、マスクは次に高いバイトから始まります。</target>
        </trans-unit>
        <trans-unit id="8ac79b53c282a3e1bdc553acd00140fe5cdb87cf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_vrlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask. The second argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="translated">&lt;code&gt;vec_vrlnm&lt;/code&gt; の結果は、最初の引数ベクトルの各要素を左に回転し、それをマスクとANDすることによって取得されます。 2番目の引数ベクトルには、各要素のビット11:15で始まるマスク、ビット19:23で終わるマスク、およびビット27:31のシフトカウントが含まれています。</target>
        </trans-unit>
        <trans-unit id="9316b131e727e77ff29281dc2e9a7402d2bc6522" translate="yes" xml:space="preserve">
          <source>The result of attempting to indirectly access an object with automatic or thread storage duration from a thread other than the one with which it is associated (C11 6.2.4).</source>
          <target state="translated">自動保存期間またはスレッド保存期間を持つオブジェクトに、そのオブジェクトが関連付けられているスレッド以外のスレッドから間接的にアクセスしようとした結果(C11 6.2.4)。</target>
        </trans-unit>
        <trans-unit id="293312cb8a66343c5e00cc15dc2d11a748b78cdb" translate="yes" xml:space="preserve">
          <source>The result of converting a pointer to an integer or vice versa (C90 6.3.4, C99 and C11 6.3.2.3).</source>
          <target state="translated">ポインタを整数に変換した結果、またはその逆の結果(C90 6.3.4、C99、C11 6.3.2.3)。</target>
        </trans-unit>
        <trans-unit id="d8adce6949d651dd3877dd8fc89775a368e6c5a5" translate="yes" xml:space="preserve">
          <source>The result of, or the signal raised by, converting an integer to a signed integer type when the value cannot be represented in an object of that type (C90 6.2.1.2, C99 and C11 6.3.1.3).</source>
          <target state="translated">その型のオブジェクトで値を表すことができない場合に,整数を符号付き整数型に変換した結果又はそれによって生じた信号(C90 6.2.1.2,C99及びC11 6.3.1.3)。</target>
        </trans-unit>
        <trans-unit id="6372dea778f1e54932d501af42dec0c2c6cb7a32" translate="yes" xml:space="preserve">
          <source>The resulting code should be considerably faster in the majority of cases and avoid the numerical instability problems of 387 code, but may break some existing code that expects temporaries to be 80 bits.</source>
          <target state="translated">結果として得られるコードは、大多数の場合ではかなり高速になり、387コードの数値的不安定性の問題を回避できるはずですが、一時的に80ビットのテンポラリを期待する既存のコードが壊れてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="602584d89b66e12499de96c6abd45f1820a6ab70" translate="yes" xml:space="preserve">
          <source>The results of some bitwise operations on signed integers (C90 6.3, C99 and C11 6.5).</source>
          <target state="translated">符号付き整数に対するいくつかのビット演算の結果(C90 6.3、C99、C11 6.5)。</target>
        </trans-unit>
        <trans-unit id="08e0446d619f737b8b3d1bfcead4987221134fe0" translate="yes" xml:space="preserve">
          <source>The return type, including type qualifiers. For example, a method returning &lt;code&gt;int&lt;/code&gt; would have &lt;code&gt;i&lt;/code&gt; here.</source>
          <target state="translated">型修飾子を含む戻りの型。たとえば、 &lt;code&gt;int&lt;/code&gt; を返すメソッドには、ここに &lt;code&gt;i&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="d722a3f7a5a03ca6f3a20b50840f8dad2ad4a0a2" translate="yes" xml:space="preserve">
          <source>The return value is the value of &lt;var&gt;exp&lt;/var&gt;, which should be an integral expression. The semantics of the built-in are that it is expected that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. For example:</source>
          <target state="translated">戻り値は &lt;var&gt;exp&lt;/var&gt; の値であり、整数式でなければなりません。組み込みのセマンティクスは、 &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt; であることが期待されていることです。例えば：</target>
        </trans-unit>
        <trans-unit id="66b2899a0dec22c6c49cc318d7875f38a40fbcdb" translate="yes" xml:space="preserve">
          <source>The return value of the method is the number of objects in the current batch; this should not exceed &lt;code&gt;len&lt;/code&gt;, which is the maximum size of a batch as requested by the caller. The batch itself is returned in the &lt;code&gt;itemsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; struct.</source>
          <target state="translated">メソッドの戻り値は、現在のバッチ内のオブジェクトの数です。これは、呼び出し側から要求されたバッチの最大サイズである &lt;code&gt;len&lt;/code&gt; を超えてはなりません。バッチ自体は、 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; 構造体の &lt;code&gt;itemsPtr&lt;/code&gt; フィールドで返されます。</target>
        </trans-unit>
        <trans-unit id="bd39f3563e6cdbea884ac0f3b2596eb7ac3835c0" translate="yes" xml:space="preserve">
          <source>The rounding behaviors characterized by non-standard values of &lt;code&gt;FLT_ROUNDS&lt;/code&gt; (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="translated">&lt;code&gt;FLT_ROUNDS&lt;/code&gt; の非標準値（C90、C99およびC11 5.2.4.2.2）を特徴とする丸め動作。</target>
        </trans-unit>
        <trans-unit id="ca0bfeda9cecd5551824a4a4e37d54810853db32" translate="yes" xml:space="preserve">
          <source>The runtime support file</source>
          <target state="translated">ランタイムサポートファイル</target>
        </trans-unit>
        <trans-unit id="b4c4c0226af27718cbd914b43f7be4de41a152cd" translate="yes" xml:space="preserve">
          <source>The safe way to write such code is to give the temporary a name, which forces it to remain until the end of the scope of the name. For example:</source>
          <target state="translated">このようなコードを書くための安全な方法は、一時的に名前を与えることで、名前のスコープが終わるまで強制的に残るようにすることです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ba4b69f3a9e8d7ca80206177b8876cf920e6f11b" translate="yes" xml:space="preserve">
          <source>The same</source>
          <target state="translated">同じ</target>
        </trans-unit>
        <trans-unit id="e53e3a35319895514d679977563fa8e554b518de" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__atomic_op_fetch&lt;/code&gt; built-in functions. All memory orders are valid.</source>
          <target state="translated">引数には、対応する &lt;code&gt;__atomic_op_fetch&lt;/code&gt; 組み込み関数と同じ制約が適用されます。すべてのメモリ順序が有効です。</target>
        </trans-unit>
        <trans-unit id="1d3bb42125b4caec8cf7a192592fcd99a8477b57" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; built-in functions.</source>
          <target state="translated">引数には、対応する &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; 組み込み関数と同じ制約が適用されます。</target>
        </trans-unit>
        <trans-unit id="e9ffb18b7d09b9daf66ff3c77ffe4ceee695ef40" translate="yes" xml:space="preserve">
          <source>The same problem can occur if one output parameter (&lt;var&gt;a&lt;/var&gt;) allows a register constraint and another output parameter (&lt;var&gt;b&lt;/var&gt;) allows a memory constraint. The code generated by GCC to access the memory address in &lt;var&gt;b&lt;/var&gt; can contain registers which &lt;em&gt;might&lt;/em&gt; be shared by &lt;var&gt;a&lt;/var&gt;, and GCC considers those registers to be inputs to the asm. As above, GCC assumes that such input registers are consumed before any outputs are written. This assumption may result in incorrect behavior if the &lt;code&gt;asm&lt;/code&gt; statement writes to &lt;var&gt;a&lt;/var&gt; before using &lt;var&gt;b&lt;/var&gt;. Combining the &amp;lsquo;</source>
          <target state="translated">1つの出力パラメーター（ &lt;var&gt;a&lt;/var&gt; ）がレジスター制約を許可し、別の出力パラメーター（ &lt;var&gt;b&lt;/var&gt; ）がメモリー制約を許可する場合にも、同じ問題が発生する可能性があります。メモリアドレスにアクセスするためのGCCによって生成されたコード &lt;var&gt;b&lt;/var&gt; 登録含有することができる&lt;em&gt;かもしれません&lt;/em&gt;で共有すること、およびGCCは、これらのレジスタは、ASMへの入力であると考えます。上記のように、GCCは、出力が書き込まれる前にそのような入力レジスタが消費されることを想定しています。 &lt;code&gt;asm&lt;/code&gt; ステートメントが &lt;var&gt;b&lt;/var&gt; を使用 &lt;var&gt;a&lt;/var&gt; 前にaに書き込む場合、この仮定は誤った動作を引き起こす可能性があります。を組み合わせる &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="84eb297a7c7adafda6643fbbc1a64827529d36ab" translate="yes" xml:space="preserve">
          <source>The same values for</source>
          <target state="translated">の値は同じです。</target>
        </trans-unit>
        <trans-unit id="5ee0deba9d1e7e31914904f7de96ff06cf02541a" translate="yes" xml:space="preserve">
          <source>The second and third &lt;code&gt;FOO&lt;/code&gt; should be in comments. This warning is on by default.</source>
          <target state="translated">2番目と3番目の &lt;code&gt;FOO&lt;/code&gt; はコメントに含める必要があります。この警告はデフォルトでオンになっています。</target>
        </trans-unit>
        <trans-unit id="498b43ab0ba23ca5cccab7efec7dc706e6795ec7" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; and &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; must be a constant integer that is 0 or 1. The third argument to these built-in functions must be a constant integer in the range of 0 to 15.</source>
          <target state="translated">&lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; および &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; の2番目の引数は、0または1の定数整数でなければなりません。これらの組み込み関数の3番目の引数は、0〜15の範囲の定数整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a7455b53d8f1101ab3b5613a9bfe23cea1588051" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;var&gt;failval&lt;/var&gt;, is optional and defaults to zero if omitted.</source>
          <target state="translated">2番目の引数 &lt;var&gt;failval&lt;/var&gt; はオプションであり、省略した場合のデフォルトはゼロです。</target>
        </trans-unit>
        <trans-unit id="e5696540b2cb16b0a24c5184cde684653dcb48a5" translate="yes" xml:space="preserve">
          <source>The second form of this directive is useful for the case where you have multiple headers with the same name in different directories. If you use this form, you must specify the same string to &amp;lsquo;</source>
          <target state="translated">このディレクティブの2番目の形式は、異なるディレクトリに同じ名前の複数のヘッダーがある場合に役立ちます。この形式を使用する場合は、同じ文字列を '</target>
        </trans-unit>
        <trans-unit id="f7af4ae65c75a113a136191463890951e0da2e45" translate="yes" xml:space="preserve">
          <source>The second pair of &lt;var&gt;n2&lt;/var&gt;:&lt;var&gt;m2&lt;/var&gt; values allows you to specify a secondary alignment:</source>
          <target state="translated">&lt;var&gt;n2&lt;/var&gt; ： &lt;var&gt;m2&lt;/var&gt; 値の2番目のペアでは、セカンダリアライメントを指定できます。</target>
        </trans-unit>
        <trans-unit id="3ab6989d4c1c4f47e25307deb785d43e56803a5f" translate="yes" xml:space="preserve">
          <source>The security extension.</source>
          <target state="translated">セキュリティの延長線上にある</target>
        </trans-unit>
        <trans-unit id="227e1ad96cf49ba3c90eaa74176faf5e4ae6abc9" translate="yes" xml:space="preserve">
          <source>The sense of a qualifier can be inverted by prefixing it with the &amp;lsquo;</source>
          <target state="translated">修飾子の意味は、 'を前に付けることで反転できます。</target>
        </trans-unit>
        <trans-unit id="555ceee2bb9cf5f8f3e29c4052854238c7fb191f" translate="yes" xml:space="preserve">
          <source>The set of runtime conventions followed by all of the tools that deal with binary representations of a program, including compilers, assemblers, linkers, and language runtime support. Some ABIs are formal with a written specification, possibly designed by multiple interested parties. Others are simply the way things are actually done by a particular set of tools.</source>
          <target state="translated">コンパイラ、アセンブラ、リンカ、言語ランタイムサポートなど、プログラムのバイナリ表現を扱うすべてのツールが従うランタイム規約のセット。ABIの中には、複数の関係者によって設計された、仕様書が書かれた形式的なものもあります。また、特定のツールセットによって実際に行われていることを単純に表しているものもあります。</target>
        </trans-unit>
        <trans-unit id="3a0b9082dbf784ec48751abb46feb9a84f16889b" translate="yes" xml:space="preserve">
          <source>The setting &amp;lsquo;</source>
          <target state="translated">設定 '</target>
        </trans-unit>
        <trans-unit id="be945ed951ef5a61f5eae361b911de27ce4736fe" translate="yes" xml:space="preserve">
          <source>The shadow stack unwind code looks like:</source>
          <target state="translated">シャドウスタックの巻き戻しコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="5e51279e9e910972feb51c0c337d5562d0a6bae6" translate="yes" xml:space="preserve">
          <source>The sign of the remainder on integer division (C90 6.3.5).</source>
          <target state="translated">整数除算における剰余の符号(C90 6.3.5)。</target>
        </trans-unit>
        <trans-unit id="3873ede6c61e304d381b113f1c8a01eb501fad5a" translate="yes" xml:space="preserve">
          <source>The simplest kind of constraint is a string full of letters, each of which describes one kind of operand that is permitted. Here are the letters that are allowed:</source>
          <target state="translated">最も単純な種類の制約は文字列で、それぞれが許されるオペランドの種類を記述しています。ここに許可されている文字列があります。</target>
        </trans-unit>
        <trans-unit id="f57db1d7a87e06c8af2c5a7b6a9b449af372d773" translate="yes" xml:space="preserve">
          <source>The single- and double-precision FPv5 floating-point instructions.</source>
          <target state="translated">単精度および倍精度のFPv5浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="8bf5f529e48bebb5ac22844826b001e3be0c3afe" translate="yes" xml:space="preserve">
          <source>The single- and double-precision floating-point instructions.</source>
          <target state="translated">単精度浮動小数点命令と倍精度浮動小数点命令です。</target>
        </trans-unit>
        <trans-unit id="8ac5488ac14854117c1393d98f83c5a93f21526b" translate="yes" xml:space="preserve">
          <source>The single-precision FPv5 floating-point instructions.</source>
          <target state="translated">単精度FPv5浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="1ebaf382d5bdec22e2b7379aab4b7c48ea9e912b" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">倍精度16個のレジスタを持つ単精度VFPv3浮動小数点命令と半精度浮動小数点変換演算。</target>
        </trans-unit>
        <trans-unit id="e7ad435877ea887d34b1b37f15d7368e56cc4675" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">単精度VFPv3浮動小数点命令。拡張子 '</target>
        </trans-unit>
        <trans-unit id="3e79bc7e04e01647f6facb0d53f8d2ca1a7bc417" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv4 floating-point instructions.</source>
          <target state="translated">単精度VFPv4浮動小数点命令。</target>
        </trans-unit>
        <trans-unit id="d793936d7de82c8ba0aab481f238e4822e465c4a" translate="yes" xml:space="preserve">
          <source>The single-precision floating-point instructions.</source>
          <target state="translated">単精度浮動小数点命令です。</target>
        </trans-unit>
        <trans-unit id="7ecbdd892eade8e6d4362e90240ff9047e6b2c01" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;t1&lt;/code&gt; is 8 bytes with the zero-length bit-field. If the zero-length bit-field were removed, &lt;code&gt;t1&lt;/code&gt;&amp;rsquo;s size would be 4 bytes.</source>
          <target state="translated">&lt;code&gt;t1&lt;/code&gt; のサイズは8バイトで、長さゼロのビットフィールドがあります。長さゼロのビットフィールドが削除された場合、 &lt;code&gt;t1&lt;/code&gt; のサイズは4バイトになります。</target>
        </trans-unit>
        <trans-unit id="d897dab500e785baf0afcdb6330501b34e2fb781" translate="yes" xml:space="preserve">
          <source>The size of L1 data cache, in kilobytes.</source>
          <target state="translated">L1 データキャッシュのサイズをキロバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="ff6dd15bf08b6f82cff4329c9e979dcd9c6cbe07" translate="yes" xml:space="preserve">
          <source>The size of L2 data cache, in kilobytes.</source>
          <target state="translated">L2 データキャッシュのサイズをキロバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="71e800ceb09e88f57e9df529fb883fbfe1a95ef2" translate="yes" xml:space="preserve">
          <source>The size of cache line in L1 data cache, in bytes.</source>
          <target state="translated">L1 データキャッシュのキャッシュラインのサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="3f610b8af116509d824f7fee0527a19292abfbc2" translate="yes" xml:space="preserve">
          <source>The size of the result of subtracting two pointers to elements of the same array (C90 6.3.6, C99 and C11 6.5.6).</source>
          <target state="translated">同じ配列の要素へのポインタを2つ減算した結果のサイズ(C90 6.3.6,C99,C11 6.5.6)。</target>
        </trans-unit>
        <trans-unit id="bcebc70f5d364873d98786d882fbb6e891304f9b" translate="yes" xml:space="preserve">
          <source>The sizes of all structures and unions are rounded up to a multiple of the number of bits set by this option. Permissible values are 8, 32 and 64. The default value varies for different toolchains. For the COFF targeted toolchain the default value is 8. A value of 64 is only allowed if the underlying ABI supports it.</source>
          <target state="translated">すべての構造体と組合のサイズは、このオプシ ョ ンで設定したビ ッ ト 数の倍数に切り上げられます。許容される値は8、32、64です。デフォルト値はツールチェインによって異なります。COFF対象のツールチェインでは、デフォルト値は8です。 64の値は、基礎となるABIがそれをサポートしている場合にのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="90ff87dc2c61fa6c28fc00209d8623b3de0f7131" translate="yes" xml:space="preserve">
          <source>The small data area consists of sections &lt;code&gt;.sdata&lt;/code&gt; and &lt;code&gt;.sbss&lt;/code&gt;. Objects may be explicitly put in the small data area with the &lt;code&gt;section&lt;/code&gt; attribute using one of these sections.</source>
          <target state="translated">小さなデータ領域は、セクション &lt;code&gt;.sdata&lt;/code&gt; と &lt;code&gt;.sbss&lt;/code&gt; で構成されています。オブジェクトは、これらのセクションのいずれかを使用して、 &lt;code&gt;section&lt;/code&gt; 属性を持つ小さなデータ領域に明示的に配置できます。</target>
        </trans-unit>
        <trans-unit id="1c7aae5531671a570fbd2d9e15330b629b257be9" translate="yes" xml:space="preserve">
          <source>The smallest number of different values for which it is best to use a jump-table instead of a tree of conditional branches. If the value is 0, use the default for the machine.</source>
          <target state="translated">条件分岐のツリーではなく、ジャンプテーブルを使用するのが最適な、異なる値の最小数。値が0の場合、マシンのデフォルト値を使用します。</target>
        </trans-unit>
        <trans-unit id="792c114efc46a607cc045f1ab679489dd4452c8d" translate="yes" xml:space="preserve">
          <source>The solution is to change your program to use appropriate system headers (&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; on systems with ISO C headers) and not to declare &lt;code&gt;time&lt;/code&gt; if the system header files declare it, or failing that to use &lt;code&gt;time_t&lt;/code&gt; as the return type of &lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">解決策は、適切なシステムヘッダー（ISO Cヘッダーのあるシステムでは &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; )を使用するようにプログラムを変更し、システムヘッダーファイルで宣言されている場合は &lt;code&gt;time&lt;/code&gt; を宣言しないようにするか、 &lt;code&gt;time_t&lt;/code&gt; を &lt;code&gt;time&lt;/code&gt; 戻り型として使用できないようにすることです。。</target>
        </trans-unit>
        <trans-unit id="7081cb8d8850184ab64a42d1afab009a2529d69a" translate="yes" xml:space="preserve">
          <source>The solution is to not use the</source>
          <target state="translated">を使用しないことで解決します。</target>
        </trans-unit>
        <trans-unit id="3f3e873518a99bceb250e9bd12263d250fd2ddde" translate="yes" xml:space="preserve">
          <source>The solution to these problems is to change the program to use &lt;code&gt;char&lt;/code&gt;-array variables with initialization strings for these purposes instead of string constants.</source>
          <target state="translated">これらの問題の解決策は、プログラムを変更して、これらの目的のために、文字列定数の代わりに初期化文字列を持つ &lt;code&gt;char&lt;/code&gt; -array変数を使用することです。</target>
        </trans-unit>
        <trans-unit id="65b067ba968d3fec2486b7d081b6185964ff8af7" translate="yes" xml:space="preserve">
          <source>The stack is not unwound before std::terminate is called.</source>
          <target state="translated">std::terminate が呼ばれる前にスタックが巻き戻されません。</target>
        </trans-unit>
        <trans-unit id="2ac8658551fc80e0b476a0a64406cc85ed6f059b" translate="yes" xml:space="preserve">
          <source>The stack pointer (SP) register is treated as 8-bit respectively 16-bit register by the compiler. The definition of these macros is affected by</source>
          <target state="translated">スタックポインタ(SP)レジスタはコンパイラによってそれぞれ8ビット、16ビットのレジスタとして扱われます。これらのマクロの定義は</target>
        </trans-unit>
        <trans-unit id="ba04d525c72586baf4467ca71d2abc7ef4aa1e82" translate="yes" xml:space="preserve">
          <source>The stack pointer register (&lt;code&gt;SP&lt;/code&gt;)</source>
          <target state="translated">スタックポインタレジスタ（ &lt;code&gt;SP&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0015c9e48f6bee73194b21376b4a1e1666cb6b7a" translate="yes" xml:space="preserve">
          <source>The stack pointer register.</source>
          <target state="translated">スタックポインタレジスタです。</target>
        </trans-unit>
        <trans-unit id="7d93215dea1d74a35177f108c830b25b0a828601" translate="yes" xml:space="preserve">
          <source>The standard also defines two environments for programs, a &lt;em&gt;freestanding environment&lt;/em&gt;, required of all implementations and which may not have library facilities beyond those required of freestanding implementations, where the handling of program startup and termination are implementation-defined; and a &lt;em&gt;hosted environment&lt;/em&gt;, which is not required, in which all the library facilities are provided and startup is through a function &lt;code&gt;int
main (void)&lt;/code&gt; or &lt;code&gt;int main (int, char *[])&lt;/code&gt;. An OS kernel is an example of a program running in a freestanding environment; a program using the facilities of an operating system is an example of a program running in a hosted environment.</source>
          <target state="translated">この標準は、プログラムの2つの環境も定義&lt;em&gt;しています&lt;/em&gt;。これは、すべての実装に必要な&lt;em&gt;独立型環境&lt;/em&gt;であり、プログラムの起動と終了の処理が実装定義である、独立型実装に必要なものを超えるライブラリ機能がない場合があります。そして&lt;em&gt;ホスト環境&lt;/em&gt;のすべてのライブラリの施設が設けられている、必要と起動が機能を介して行われていない、 &lt;code&gt;int main (void)&lt;/code&gt; または &lt;code&gt;int main (int, char *[])&lt;/code&gt; 。OSカーネルは、独立した環境で実行されるプログラムの例です。オペレーティングシステムの機能を使用するプログラムは、ホスト環境で実行されるプログラムの例です。</target>
        </trans-unit>
        <trans-unit id="aa6db7352466c6267511c0ba5dc350845fe3cad9" translate="yes" xml:space="preserve">
          <source>The standard is worded confusingly, therefore there is some debate over the precise meaning of the sequence point rules in subtle cases. Links to discussions of the problem, including proposed formal definitions, may be found on the GCC readings page, at &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;.</source>
          <target state="translated">標準は混乱を招くように表現されているため、微妙なケースではシーケンスポイントルールの正確な意味についていくつかの議論があります。提案された正式な定義を含む問題の議論へのリンクは、&lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.htmlの&lt;/a&gt; GCCリーディングページにあります。</target>
        </trans-unit>
        <trans-unit id="69cda6ddbf344279c641ca143790b176ad293ac4" translate="yes" xml:space="preserve">
          <source>The standard rules for &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros are used to find a common type &lt;var&gt;u&lt;/var&gt; from the types of the arguments for parameters whose types vary between the functions; complex integer types (a GNU extension) are treated like &lt;code&gt;_Complex double&lt;/code&gt; for this purpose (or &lt;code&gt;_Complex _Float64&lt;/code&gt; if all the function return types are the same &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; type). If the function return types vary, or are all the same integer type, the function called is the one for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, and it is an error if there is no such function. If the function return types are all the same floating-point type, the type-generic macro is taken to be one of those from TS 18661 that rounds the result to a narrower type; if there is a function for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, it is called, and otherwise the first function, if any, for which &lt;var&gt;t&lt;/var&gt; has at least the range and precision of &lt;var&gt;u&lt;/var&gt; is called, and it is an error if there is no such function.</source>
          <target state="translated">&lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; マクロの標準規則は、関数間で型が異なるパラメーターの引数の型から共通の型 &lt;var&gt;u&lt;/var&gt; を見つけるために使用されます。複雑な整数型（GNU拡張）は、この目的のために &lt;code&gt;_Complex double&lt;/code&gt; （またはすべての関数の戻り型が同じ &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; または &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; x型である場合は &lt;code&gt;_Complex _Float64&lt;/code&gt; ）のように扱われます。関数の戻り値の型が異なる場合、またはすべて同じ整数型である場合、呼び出される関数は &lt;var&gt;t&lt;/var&gt; が &lt;var&gt;u&lt;/var&gt; である関数です、そのような関数がない場合はエラーになります。関数の戻り値の型がすべて同じ浮動小数点型である場合、型汎用の​​マクロは、結果をより狭い型に丸めるTS 18661のマクロの1つと見なされます。 &lt;var&gt;t&lt;/var&gt; が &lt;var&gt;u&lt;/var&gt; である関数が存在する場合、それが呼び出されます。それ以外の場合、 &lt;var&gt;t&lt;/var&gt; が少なくとも &lt;var&gt;u&lt;/var&gt; の範囲と精度を持つ最初の関数（存在する場合）が呼び出され、そのような関数がない場合はエラーになります。 。</target>
        </trans-unit>
        <trans-unit id="806ce7f42e8deb00dbd822deaceb91e1417e5da0" translate="yes" xml:space="preserve">
          <source>The startup code from libgcc never sets &lt;code&gt;EIND&lt;/code&gt;. Notice that startup code is a blend of code from libgcc and AVR-LibC. For the impact of AVR-LibC on &lt;code&gt;EIND&lt;/code&gt;, see the &lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-LibC user manual&lt;/a&gt;.</source>
          <target state="translated">libgccの起動コードがEINDを設定することはあり &lt;code&gt;EIND&lt;/code&gt; 。スタートアップコードは、libgccとAVR-LibCのコードのブレンドであることに注意してください。上のAVR-のlibc影響を &lt;code&gt;EIND&lt;/code&gt; 、参照&lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-のlibcマニュアルを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f98c1752aa45287d5195f68be596da96d8fbbbe6" translate="yes" xml:space="preserve">
          <source>The startup code initializes the &lt;code&gt;RAMP&lt;/code&gt; special function registers with zero.</source>
          <target state="translated">スタートアップコードは、 &lt;code&gt;RAMP&lt;/code&gt; 特殊機能レジスタをゼロで初期化します。</target>
        </trans-unit>
        <trans-unit id="e0593142bdd3bdb84b9aebea225043f72be034cf" translate="yes" xml:space="preserve">
          <source>The storage for an object of thread storage duration shall be statically initialized before the first statement of the thread startup function. An object of thread storage duration shall not require dynamic initialization.</source>
          <target state="translated">スレッド記憶期間のオブジェクトの記憶装置は,スレッド起動関数の最初の文の前に静的に初期化されなければならない。スレッド記憶期間のオブジェクトは,動的な初期化を必要としないものとする。</target>
        </trans-unit>
        <trans-unit id="2f4b780083ada416a6c378ae8867cc1c7fb0b433" translate="yes" xml:space="preserve">
          <source>The structure has size zero. In C++, empty structures are part of the language. G++ treats empty structures as if they had a single member of type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">構造のサイズはゼロです。C ++では、空の構造は言語の一部です。G ++は、空の構造体を &lt;code&gt;char&lt;/code&gt; 型の単一のメンバーがあるかのように扱います。</target>
        </trans-unit>
        <trans-unit id="3c2ecce652896fa952e1019513fab67001397b36" translate="yes" xml:space="preserve">
          <source>The subtype of the file created (like &amp;lsquo;</source>
          <target state="translated">作成されたファイルのサブタイプ（「</target>
        </trans-unit>
        <trans-unit id="ca6a165fe3653c2eaa19af3a9cacad8cee1b0aa0" translate="yes" xml:space="preserve">
          <source>The switch matching text &lt;code&gt;S&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="translated">'内のテキスト &lt;code&gt;S&lt;/code&gt; に一致するスイッチ</target>
        </trans-unit>
        <trans-unit id="2591c1475ef50f2d7871f5727f318ca9819d88ef" translate="yes" xml:space="preserve">
          <source>The syntax for this extension is</source>
          <target state="translated">この拡張子の構文は</target>
        </trans-unit>
        <trans-unit id="c37c4e36af6f9d7c15727a683845a9a4d1ae812e" translate="yes" xml:space="preserve">
          <source>The synthetic compare types&amp;ndash;gt, lt, ge, and le.</source>
          <target state="translated">合成比較タイプ&amp;ndash; gt、lt、ge、le。</target>
        </trans-unit>
        <trans-unit id="de0ec84c43a433725bea4939d7d6aa41982b5bb6" translate="yes" xml:space="preserve">
          <source>The system will help save all registers into stack before entering interrupt handler.</source>
          <target state="translated">割り込みハンドラに入る前に、すべてのレジスタをスタックに保存するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="0b39e2e7f8f008a32869aef147d2dc6314988d7d" translate="yes" xml:space="preserve">
          <source>The system will help save caller registers into stack before entering interrupt handler.</source>
          <target state="translated">割り込みハンドラに入る前に、呼び出し元のレジスタをスタックに保存するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="ebaa5c15171a87ae7a332bb49a3f32f19a3aad26" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2i16&lt;/code&gt; operation for which hardware support exists for the DSP ASE REV 2. &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; are &lt;code&gt;v2i16&lt;/code&gt; values.</source>
          <target state="translated">次の表に、DSP ASE REV 2のハードウェアサポートが存在する &lt;code&gt;v2i16&lt;/code&gt; の動作を示します &lt;code&gt;e&lt;/code&gt; と &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;v2i16&lt;/code&gt; の値です。</target>
        </trans-unit>
        <trans-unit id="896165ef2a0dc9f91cdad7ea07b67fa41d120e44" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2sf&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are &lt;code&gt;v2sf&lt;/code&gt; values and &lt;code&gt;x&lt;/code&gt; is an integral value.</source>
          <target state="translated">次の表は、ハードウェアサポートが存在する &lt;code&gt;v2sf&lt;/code&gt; 操作を示しています。 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; は &lt;code&gt;v2sf&lt;/code&gt; 値で、 &lt;code&gt;x&lt;/code&gt; は整数値です。</target>
        </trans-unit>
        <trans-unit id="9b038d441c31fe7fb35f36ddaf2d9c7ea6b680b8" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v4i8&lt;/code&gt; and &lt;code&gt;v2q15&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;v4i8&lt;/code&gt; values, and &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are &lt;code&gt;v2q15&lt;/code&gt; values.</source>
          <target state="translated">次の表は、ハードウェアサポートが存在する &lt;code&gt;v4i8&lt;/code&gt; および &lt;code&gt;v2q15&lt;/code&gt; 操作を示しています。 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;v4i8&lt;/code&gt; 値で、 &lt;code&gt;c&lt;/code&gt; と &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;v2q15&lt;/code&gt; 値です。</target>
        </trans-unit>
        <trans-unit id="3f249ccb08815c6079cbd323b97a2c4ac2204382" translate="yes" xml:space="preserve">
          <source>The table below lists the supported extensions for each architecture. Architectures not mentioned do not support any extensions.</source>
          <target state="translated">以下の表は、各アーキテクチャでサポートされている拡張機能の一覧です。記載されていないアーキテクチャは拡張機能をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="e73d22c03412d342b6a999932c3fa6fbeb3a35b8" translate="yes" xml:space="preserve">
          <source>The table below shows the list of supported modifiers and their effects.</source>
          <target state="translated">下の表は、サポートされている修飾子の一覧とその効果を示しています。</target>
        </trans-unit>
        <trans-unit id="15aee3d23ffff41850eb55f63ba2913dcc2593de" translate="yes" xml:space="preserve">
          <source>The target may also allow additional types in &lt;code&gt;format-arg&lt;/code&gt; attributes. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="translated">ターゲットは、 &lt;code&gt;format-arg&lt;/code&gt; 属性で追加の型を許可する場合もあります。&lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;特定のターゲットマシンに固有のフォーマットチェックを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2e1eb5143cb3645d3e56fe87871163fa73c09f83" translate="yes" xml:space="preserve">
          <source>The target may also provide additional types of format checks. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="translated">ターゲットは、追加のタイプのフォーマットチェックを提供する場合もあります。&lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;特定のターゲットマシンに固有のフォーマットチェックを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0b814fff953e9628f2b901dd62490d599d61582c" translate="yes" xml:space="preserve">
          <source>The the register class of registers that can be used to hold a sibcall call address. I.e., a caller-saved register.</source>
          <target state="translated">シブコールの呼び出しアドレスを保持するために使用できるレジスタのレジスタクラス。すなわち、呼び出し元が保存されたレジスタです。</target>
        </trans-unit>
        <trans-unit id="e9067dbfe61d5583898a4c222466eaecdc743a7f" translate="yes" xml:space="preserve">
          <source>The third word specifies the source files for those structs for which the compiler should emit debug information. The values &amp;lsquo;</source>
          <target state="translated">3番目の単語は、コンパイラがデバッグ情報を出力する必要のある構造体のソースファイルを指定します。その価値 '</target>
        </trans-unit>
        <trans-unit id="3c2caf56b0822fe7bc0594ac85f716ffb2f0188f" translate="yes" xml:space="preserve">
          <source>The thread that begins execution at the &lt;code&gt;main&lt;/code&gt; function is called the &lt;em&gt;main thread&lt;/em&gt;. It is implementation defined how functions beginning threads other than the main thread are designated or typed. A function so designated, as well as the &lt;code&gt;main&lt;/code&gt; function, is called a &lt;em&gt;thread startup function&lt;/em&gt;. It is implementation defined what happens if a thread startup function returns. It is implementation defined what happens to other threads when any thread calls &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 関数で実行を開始するスレッドは、&lt;em&gt;メインスレッド&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。メインスレッド以外のスレッドを開始する関数がどのように指定または型付けされるかは、実装によって定義されます。このように指定された関数と &lt;code&gt;main&lt;/code&gt; 関数は、&lt;em&gt;スレッド起動関数&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。これは、スレッド起動関数が戻った場合にどうなるかを定義した実装です。これは、スレッド呼び出しが &lt;code&gt;exit&lt;/code&gt; ときに他のスレッドに何が起こるかを定義した実装です。</target>
        </trans-unit>
        <trans-unit id="b44a5b130a3ceb5fe8f03b1aaa3178d1eeebc449" translate="yes" xml:space="preserve">
          <source>The three types of inlining behave similarly in two important cases: when the &lt;code&gt;inline&lt;/code&gt; keyword is used on a &lt;code&gt;static&lt;/code&gt; function, like the example above, and when a function is first declared without using the &lt;code&gt;inline&lt;/code&gt; keyword and then is defined with &lt;code&gt;inline&lt;/code&gt;, like this:</source>
          <target state="translated">3つのタイプのインライン化は、2つの重要なケースで同様に動作します。上記の例のように、 &lt;code&gt;static&lt;/code&gt; 関数で &lt;code&gt;inline&lt;/code&gt; キーワードが使用されている場合と、次のように、関数が最初に &lt;code&gt;inline&lt;/code&gt; キーワードを使用せずに宣言され、次に &lt;code&gt;inline&lt;/code&gt; で定義されている場合：</target>
        </trans-unit>
        <trans-unit id="603ab7e85053589e42da345836681d51d569791a" translate="yes" xml:space="preserve">
          <source>The threshold ratio for performing partial redundancy elimination after reload.</source>
          <target state="translated">リロード後に部分的な冗長性の除去を行うための閾値比。</target>
        </trans-unit>
        <trans-unit id="423954d242ed49c029dc872280561e1e359efe72" translate="yes" xml:space="preserve">
          <source>The threshold ratio of critical edges execution count that permit performing redundancy elimination after reload.</source>
          <target state="translated">リロード後の冗長性除去を可能にするクリティカルエッジの実行回数の閾値比。</target>
        </trans-unit>
        <trans-unit id="a881665cedd4653a3bb7d98fcef7595547272bb0" translate="yes" xml:space="preserve">
          <source>The total number of input + output + goto operands is limited to 30.</source>
          <target state="translated">入力+出力+gotoオペランドの合計数は30個までです。</target>
        </trans-unit>
        <trans-unit id="b51a43aea88607f1a48139a383f2efbea483ea5b" translate="yes" xml:space="preserve">
          <source>The total size (in bytes) required to pass all the parameters. This includes the two hidden parameters (the object &lt;code&gt;self&lt;/code&gt; and the method selector &lt;code&gt;_cmd&lt;/code&gt;).</source>
          <target state="translated">すべてのパラメーターを渡すために必要な合計サイズ（バイト単位）。これには、2つの非表示パラメーター（オブジェクト &lt;code&gt;self&lt;/code&gt; とメソッドセレクター &lt;code&gt;_cmd&lt;/code&gt; ）が含まれます。</target>
        </trans-unit>
        <trans-unit id="d0dea0413ee420eebb0c3352fcc9737b26d047ac" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a persistent failure. Re-execution under same circumstances will not be productive.</source>
          <target state="translated">トランザクションは、永続的な失敗のために中断されました。同じ状況での再実行は生産的ではありません。</target>
        </trans-unit>
        <trans-unit id="7970397dce5e9b8e0cc50cc8d7046872a5452379" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a transient failure. The transaction should be re-executed in that case.</source>
          <target state="translated">トランザクションはトランジェント障害のために中断されました。その場合、トランザクションは再実行されるべきです。</target>
        </trans-unit>
        <trans-unit id="885e4cc2a7b2481bfb38880d5bc544bde78ed78c" translate="yes" xml:space="preserve">
          <source>The transaction was aborted due to an indeterminate condition which might be persistent.</source>
          <target state="translated">トランザクションは、持続する可能性のある不確定な状態のために中断されました。</target>
        </trans-unit>
        <trans-unit id="eed635303d722768beed9ca9a2d786f5922ad4e3" translate="yes" xml:space="preserve">
          <source>The two Scalar Reduction of Aggregates passes (SRA and IPA-SRA) aim to replace scalar parts of aggregates with uses of independent scalar variables. These parameters control the maximum size, in storage units, of aggregate which is considered for replacement when compiling for speed (</source>
          <target state="translated">2つのScalar Reduction of Aggregatesパス(SRAとIPA-SRA)は、集合体のスカラー部分を独立したスカラー変数で置き換えることを目的としています。これらのパラメータは、高速化のためにコンパイルする際に置き換えのために考慮される集合体の最大サイズを、ストレージ単位で制御します (</target>
        </trans-unit>
        <trans-unit id="d922516e422c7b0576d05743cb3430b4c8056971" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;char&lt;/code&gt; is always a distinct type from each of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, even though its behavior is always just like one of those two.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型は、振る舞いが常にこれら2つのうちの1つと同じであるにもかかわらず、常に、 &lt;code&gt;signed char&lt;/code&gt; または &lt;code&gt;unsigned char&lt;/code&gt; のそれぞれとは異なる型です。</target>
        </trans-unit>
        <trans-unit id="7f1531d2ff0ef2100fb6dbf78b0a6f5c969ddbe3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;int[]&lt;/code&gt; and &lt;code&gt;int[5]&lt;/code&gt; are compatible. On the other hand, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;char *&lt;/code&gt; are not compatible, even if the size of their types, on the particular architecture are the same. Also, the amount of pointer indirection is taken into account when determining similarity. Consequently, &lt;code&gt;short *&lt;/code&gt; is not similar to &lt;code&gt;short **&lt;/code&gt;. Furthermore, two types that are typedefed are considered compatible if their underlying types are compatible.</source>
          <target state="translated">タイプ &lt;code&gt;int[]&lt;/code&gt; と &lt;code&gt;int[5]&lt;/code&gt; は互換性があります。一方、 &lt;code&gt;int&lt;/code&gt; と &lt;code&gt;char *&lt;/code&gt; は、特定のアーキテクチャで型のサイズが同じであっても互換性がありません。また、類似性を判断するときに、ポインターの間接参照の量が考慮されます。したがって、 &lt;code&gt;short *&lt;/code&gt; は &lt;code&gt;short **&lt;/code&gt; と似ていません。さらに、typedefされている2つの型は、その基礎となる型に互換性がある場合、互換性があると見なされます。</target>
        </trans-unit>
        <trans-unit id="8f524b48e32ad47b9a83509e089c5a5e1558b871" translate="yes" xml:space="preserve">
          <source>The type of an object with thread storage duration shall not have a non-trivial destructor, nor shall it be an array type whose elements (directly or indirectly) have non-trivial destructors.</source>
          <target state="translated">スレッド格納期間を持つオブジェクトの型は,非自明デストラクタを持ってはならず,また,その要素が(直接または間接的に)非自明デストラクタを持つ配列型であってはならない。</target>
        </trans-unit>
        <trans-unit id="c90fc1cb110409689f90a0be940bc7d5911aa3a0" translate="yes" xml:space="preserve">
          <source>The type of these constants follows the same rules as for octal or hexadecimal integer constants, so suffixes like &amp;lsquo;</source>
          <target state="translated">これらの定数のタイプは、8進数または16進数の整数定数と同じ規則に従うため、 'のような接尾辞</target>
        </trans-unit>
        <trans-unit id="3e1c0747061b6e04e40c5232315c9ae3b95fbcea" translate="yes" xml:space="preserve">
          <source>The type specifiers are encoded just before the type. Unlike types however, the type specifiers are only encoded when they appear in method argument types.</source>
          <target state="translated">型指定子は型の直前にエンコードされます。しかし、型とは異なり、型指定子はメソッドの引数型に現れたときにのみエンコードされます。</target>
        </trans-unit>
        <trans-unit id="235cfb0079f1cae5d7bcfb5a4109668420b1ba20" translate="yes" xml:space="preserve">
          <source>The types are encoded in the following way:</source>
          <target state="translated">型は以下のようにエンコードされています。</target>
        </trans-unit>
        <trans-unit id="a29416c27e6f97b9abc061da191be4a6083d70bc" translate="yes" xml:space="preserve">
          <source>The types defined in this manner can be used with a subset of normal C operations. Currently, GCC allows using the following operators on these types: &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt;.</source>
          <target state="translated">この方法で定義された型は、通常のC操作のサブセットで使用できます。現在、GCCでは、これらの型で &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt; 演算子を使用できます。</target>
        </trans-unit>
        <trans-unit id="e3fa8117933503d7edf67d6eb175e6d2d580176b" translate="yes" xml:space="preserve">
          <source>The types of long calls used depends on the capabilities of the assembler and linker, and the type of code being generated. The impact on systems that support long absolute calls, and long pic symbol-difference or pc-relative calls should be relatively small. However, an indirect call is used on 32-bit ELF systems in pic code and it is quite long.</source>
          <target state="translated">使用される長い呼び出しの種類は、アセンブラとリンカの能力と生成されるコードの種類に依存します。長い絶対コールや長い pic シンボル差分や pc 相対コールをサポートしているシステムへの影響は比較的小さいはずです。しかし、32ビットELFシステムでは間接呼び出しがpicコードで使用されており、かなり長いです。</target>
        </trans-unit>
        <trans-unit id="ec5bc88005ecf61d67656c8a050fcb6e58f804f9" translate="yes" xml:space="preserve">
          <source>The types of the specified functions must all be different, but related to each other in the same way as a set of functions that may be selected between by a macro in &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;. This means that the functions are parameterized by a floating-point type &lt;var&gt;t&lt;/var&gt;, different for each such function. The function return types may all be the same type, or they may be &lt;var&gt;t&lt;/var&gt; for each function, or they may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function (if some of the types &lt;var&gt;t&lt;/var&gt; are complex). Likewise, for each parameter position, the type of the parameter in that position may always be the same type, or may be &lt;var&gt;t&lt;/var&gt; for each function (this case must apply for at least one parameter position), or may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function.</source>
          <target state="translated">指定する関数のタイプはすべて異なっている必要がありますが、 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; のマクロで選択できる関数のセットと同じように互いに関連しています。つまり、関数は、そのような関数ごとに異なる浮動小数点型 &lt;var&gt;t&lt;/var&gt; によってパラメーター化されます。関数の戻り型は、すべて同じタイプであってもよいし、またはそれらはあってもよい &lt;var&gt;t&lt;/var&gt; 機能ごとに、またはそれらが対応する実数型とすることができる &lt;var&gt;t&lt;/var&gt; の各機能（タイプのいくつかの場合のために &lt;var&gt;t&lt;/var&gt; 複雑です）。同様に、各パラメータの位置について、その位置におけるパラメータの種類は、常に同じ種類であってもよいし、とすることができる &lt;var&gt;t&lt;/var&gt; 各関数（この場合、少なくとも1つのパラメーター位置に適用する必要があります）、または各関数の &lt;var&gt;t&lt;/var&gt; に対応する実数型の場合があります。</target>
        </trans-unit>
        <trans-unit id="562884deec4ebf19cace230c1d8314c9d6fd11a3" translate="yes" xml:space="preserve">
          <source>The typical use of extended &lt;code&gt;asm&lt;/code&gt; statements is to manipulate input values to produce output values. However, your &lt;code&gt;asm&lt;/code&gt; statements may also produce side effects. If so, you may need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier to disable certain optimizations. See &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;.</source>
          <target state="translated">拡張 &lt;code&gt;asm&lt;/code&gt; ステートメントの一般的な用途は、入力値を操作して出力値を生成することです。ただし、 &lt;code&gt;asm&lt;/code&gt; ステートメントも副作用を引き起こす可能性があります。その場合は、 &lt;code&gt;volatile&lt;/code&gt; 修飾子を使用して特定の最適化を無効にする必要がある場合があります。&lt;a href=&quot;#Volatile&quot;&gt;揮発性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="45e652bb27a2083165bac75933fd850a0641a946" translate="yes" xml:space="preserve">
          <source>The unary plus operator.</source>
          <target state="translated">単項プラス演算子です。</target>
        </trans-unit>
        <trans-unit id="5b7b641512751385c6d2814d121dfa7956a428c3" translate="yes" xml:space="preserve">
          <source>The underlying type of &lt;code&gt;type&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be an enumeration type ([dcl.enum]).</source>
          <target state="translated">基礎となるタイプ &lt;code&gt;type&lt;/code&gt; 。必須： &lt;code&gt;type&lt;/code&gt; は列挙型（[dcl.enum]）である必要があります。</target>
        </trans-unit>
        <trans-unit id="4c9e93062c090121b29c563680d663f3d3e33b8a" translate="yes" xml:space="preserve">
          <source>The unique value of the member of the execution character set produced for each of the standard alphabetic escape sequences (C90, C99 and C11 5.2.2).</source>
          <target state="translated">標準アルファベットエスケープシーケンス(C90、C99及びC11 5.2.2.2)のそれぞれに対して生成された実行文字セットのメンバの一意の値。</target>
        </trans-unit>
        <trans-unit id="6e9148f286cc806482521d7ebb582ea948e1076d" translate="yes" xml:space="preserve">
          <source>The use of default arguments in function pointers, function typedefs and other places where they are not permitted by the standard is deprecated and will be removed from a future version of G++.</source>
          <target state="translated">関数ポインタや関数型定義子など、標準では許可されていない場所でのデフォルト引数の使用は非推奨であり、将来のG++のバージョンからは削除される予定です。</target>
        </trans-unit>
        <trans-unit id="cb0aac07569b8c035da4f2196d548847237b0a9f" translate="yes" xml:space="preserve">
          <source>The usual calling convention has functions return values of types &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; in an FPU register, even if there is no FPU. The idea is that the operating system should emulate an FPU.</source>
          <target state="translated">通常の呼び出し規約には、FPUがない場合でも、FPUレジスタに &lt;code&gt;float&lt;/code&gt; 型と &lt;code&gt;double&lt;/code&gt; 型の値を返す関数があります。その考え方は、オペレーティングシステムはFPUをエミュレートする必要があるということです。</target>
        </trans-unit>
        <trans-unit id="ad7784f3ecb2fcf462bcebb606253d24e3e9713b" translate="yes" xml:space="preserve">
          <source>The usual way to run GCC is to run the executable called &lt;code&gt;gcc&lt;/code&gt;, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; when cross-compiling, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; to run a specific version of GCC. When you compile C++ programs, you should invoke GCC as &lt;code&gt;g++&lt;/code&gt; instead. See &lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;Compiling C++ Programs&lt;/a&gt;, for information about the differences in behavior between &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;g++&lt;/code&gt; when compiling C++ programs.</source>
          <target state="translated">GCCを実行する通常の方法は、 &lt;code&gt;gcc&lt;/code&gt; と呼ばれる実行可能ファイル、またはクロスコンパイル時に &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; 、または特定のバージョンのGCCを実行するための &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; を実行することです。C ++プログラムをコンパイルするときは、代わりにGCCを &lt;code&gt;g++&lt;/code&gt; として呼び出す必要があります。&lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;C ++プログラムのコンパイル&lt;/a&gt;時の &lt;code&gt;gcc&lt;/code&gt; と &lt;code&gt;g++&lt;/code&gt; 動作の違いについては、C ++プログラムのコンパイルを参照してください。</target>
        </trans-unit>
        <trans-unit id="b063501b645eb4fe8a716599b0b7b68ac7473998" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt;.</source>
          <target state="translated">有効なメモリ順序の変異体である &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; 、 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 、 &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 、 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 、および &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cc836f5cd3d793de6c86ebfa23594977254dab4" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt;.</source>
          <target state="translated">有効なメモリ順序の変異体である &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; 、 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 、 &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 、および &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b387c15b8d7905431f6ee70a72792d2b995cec6" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="translated">有効なメモリ順序バリアントは、 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; 、__ATOMIC_SEQ_CST、および &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b6608eaa83f451be81718292f24c656e5976df89" translate="yes" xml:space="preserve">
          <source>The value &amp;lsquo;</source>
          <target state="translated">値 '</target>
        </trans-unit>
        <trans-unit id="9b81b1fa621fe4401621371ef2fb0416c4e7ec83" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;branch&lt;/code&gt; tells the compiler to implement checking of validity of control-flow transfer at the point of indirect branch instructions, i.e. call/jmp instructions. The value &lt;code&gt;return&lt;/code&gt; implements checking of validity at the point of returning from a function. The value &lt;code&gt;full&lt;/code&gt; is an alias for specifying both &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt;. The value &lt;code&gt;none&lt;/code&gt; turns off instrumentation.</source>
          <target state="translated">値 &lt;code&gt;branch&lt;/code&gt; は、間接ブランチ命令、つまりcall / jmp命令のポイントで制御フロー転送の有効性のチェックを実装するようコンパイラーに指示します。 &lt;code&gt;return&lt;/code&gt; 値は、関数から戻るときに有効性のチェックを実装します。値 &lt;code&gt;full&lt;/code&gt; は、 &lt;code&gt;branch&lt;/code&gt; と &lt;code&gt;return&lt;/code&gt; 両方を指定するためのエイリアスです。 &lt;code&gt;none&lt;/code&gt; の値は、インスツルメンテーションをオフにします。</target>
        </trans-unit>
        <trans-unit id="cec00d8fc6d0d865baf91db330b98c794be36fbd" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 0 (the default) or 4 means that constants of any size are allowed.</source>
          <target state="translated">値 &lt;var&gt;N&lt;/var&gt; の範囲は0〜4です。値0（デフォルト）または4は、任意のサイズの定数が許可されることを意味します。</target>
        </trans-unit>
        <trans-unit id="bb7289e160f23adf91cfa58505c60106049d9e55" translate="yes" xml:space="preserve">
          <source>The value is as specified in the standard and the type is determined by the ABI.</source>
          <target state="translated">値は規格に規定されている通りであり、型はABIによって決定される。</target>
        </trans-unit>
        <trans-unit id="da848852806dcfc33f52696b5619522d23c88e8e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;COMPILER_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. GCC tries the directories thus specified when searching for subprograms, if it cannot find the subprograms using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COMPILER_PATH&lt;/code&gt; の値は、 &lt;code&gt;PATH&lt;/code&gt; によく似た、コロンで区切られたディレクトリのリストです。GCCは、 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; を使用してサブプログラムを見つけることができない場合、サブプログラムを検索するときにこのように指定されたディレクトリを試みます。</target>
        </trans-unit>
        <trans-unit id="d72005aff0d80d4d1734d968cb3fab8a6e254f4d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; can be just a file name, in which case the Make rules are written to that file, guessing the target name from the source file name. Or the value can have the form &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; の値は単なるファイル名にすることができます。この場合、Makeルールはそのファイルに書き込まれ、ソースファイル名からターゲット名を推測します。または、値の形式は '</target>
        </trans-unit>
        <trans-unit id="edab9250e0babd1761a6140212faa3d4e9be6f54" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;LIBRARY_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. When configured as a native compiler, GCC tries the directories thus specified when searching for special linker files, if it cannot find them using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;. Linking using GCC also uses these directories when searching for ordinary libraries for the</source>
          <target state="translated">&lt;code&gt;LIBRARY_PATH&lt;/code&gt; の値は、 &lt;code&gt;PATH&lt;/code&gt; によく似た、コロンで区切られたディレクトリのリストです。ネイティブコンパイラとして構成されている場合、GCCは、 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; を使用してそれらを見つけることができない場合、特別なリンカーファイルを検索するときに指定されたディレクトリを試します。GCCを使用したリンクでは、通常のライブラリを検索するときにこれらのディレクトリも使用します。</target>
        </trans-unit>
        <trans-unit id="43d97475c2600c7120869f306bf4b7bed4d2e9bd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; must be a UNIX timestamp, defined as the number of seconds (excluding leap seconds) since 01 Jan 1970 00:00:00 represented in ASCII; identical to the output of &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; の値は、1970年1月1日00:00:00以降の秒数（うるう秒を除く）として定義されたUNIXタイムスタンプでなければなりません。'の出力と同じ</target>
        </trans-unit>
        <trans-unit id="66e4ba46bd46984b6c4ee052416293525cc2110b" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;addr&lt;/var&gt; is the address of the memory to prefetch. There are two optional arguments, &lt;var&gt;rw&lt;/var&gt; and &lt;var&gt;locality&lt;/var&gt;. The value of &lt;var&gt;rw&lt;/var&gt; is a compile-time constant one or zero; one means that the prefetch is preparing for a write to the memory address and zero, the default, means that the prefetch is preparing for a read. The value &lt;var&gt;locality&lt;/var&gt; must be a compile-time constant integer between zero and three. A value of zero means that the data has no temporal locality, so it need not be left in the cache after the access. A value of three means that the data has a high degree of temporal locality and should be left in all levels of cache possible. Values of one and two mean, respectively, a low or moderate degree of temporal locality. The default is three.</source>
          <target state="translated">&lt;var&gt;addr&lt;/var&gt; の値は、プリフェッチするメモリのアドレスです。 2つのオプションの引数、 &lt;var&gt;rw&lt;/var&gt; と &lt;var&gt;locality&lt;/var&gt; があります。 &lt;var&gt;rw&lt;/var&gt; の値は、コンパイル時の定数1または0です。 1つは、プリフェッチがメモリアドレスへの書き込みの準備をしていることを意味し、0（デフォルト）は、プリフェッチが読み取りの準備をしていることを意味します。値の &lt;var&gt;locality&lt;/var&gt; 0から3までのコンパイル時定数整数でなければなりません。ゼロの値は、データに一時的な局所性がないことを意味するため、アクセス後にデータをキャッシュに残す必要はありません。値3は、データの一時的な局所性が高く、可能な限りすべてのレベルのキャッシュに残しておく必要があることを意味します。1と2の値は、それぞれ低または中程度の時間的局所性を意味します。デフォルトは3です。</target>
        </trans-unit>
        <trans-unit id="70e11268aef227bb1a15172e67ca65858facec52" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;arguments&lt;/var&gt; should be the value returned by &lt;code&gt;__builtin_apply_args&lt;/code&gt;. The argument &lt;var&gt;size&lt;/var&gt; specifies the size of the stack argument data, in bytes.</source>
          <target state="translated">&lt;var&gt;arguments&lt;/var&gt; の値は、 &lt;code&gt;__builtin_apply_args&lt;/code&gt; によって返される値である必要があります。引数の &lt;var&gt;size&lt;/var&gt; バイト単位で、引数のスタックデータのサイズを指定します。</target>
        </trans-unit>
        <trans-unit id="e97b2ef46aa7ac364dbf54d200c4936fb0a11aa0" translate="yes" xml:space="preserve">
          <source>The value of a &lt;code&gt;char&lt;/code&gt; object into which has been stored any character other than a member of the basic execution character set (C90 6.1.2.5, C99 and C11 6.2.5).</source>
          <target state="translated">基本実行文字セット（C90 6.1.2.5、C99およびC11 6.2.5）のメンバー以外の文字が格納されている &lt;code&gt;char&lt;/code&gt; オブジェクトの値。</target>
        </trans-unit>
        <trans-unit id="c90677fad3803708fba68301854948c65ad2e0dc" translate="yes" xml:space="preserve">
          <source>The value of a string literal containing a multibyte character or escape sequence not represented in the execution character set (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="translated">実行文字集合(C90 6.1.4、C99及びC11 6.4.5)で表現されていないマルチバイト文字又はエスケープシーケンスを含む文字列リテラルの値。</target>
        </trans-unit>
        <trans-unit id="0799bf13992e78d42dd3b2499d660140de9cd663" translate="yes" xml:space="preserve">
          <source>The value of a wide character constant containing more than one multibyte character or a single multibyte character that maps to multiple members of the extended execution character set, or containing a multibyte character or escape sequence not represented in the extended execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">拡張実行文字集合の複数のメンバに対応するマルチバイト文字又は単一のマルチバイト文字を含む幅広文字定数の値、又は拡張実行文字集合に表れないマルチバイト文字又はエスケープシーケンスを含む幅広文字定数の値(C90 6.1.3.4、C99及びC11 6.4.4.4)。</target>
        </trans-unit>
        <trans-unit id="2de23bcdd7f53de07c13a72f7ab5e75f0f064b9a" translate="yes" xml:space="preserve">
          <source>The value of an integer character constant containing more than one character or containing a character or escape sequence that does not map to a single-byte execution character (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">つ以上の文字を含む整数文字定数の値、又はシングルバイト実行文字にマッピングされない文字又はエスケープシーケンスを含む文字定数の値(C90 6.1.3.4、C99及びC11 6.4.4.4)。</target>
        </trans-unit>
        <trans-unit id="bddf51b03e8582ac60e5e332485e2f5dfdaadff5" translate="yes" xml:space="preserve">
          <source>The value of the result of the &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;_Alignof&lt;/code&gt; operators (C90 6.3.3.4, C99 and C11 6.5.3.4).</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; および &lt;code&gt;_Alignof&lt;/code&gt; 演算子の結果の値（C90 6.3.3.4、C99およびC11 6.5.3.4）。</target>
        </trans-unit>
        <trans-unit id="c0b2873e2d72ded9fcc9fee52452da75fb562815" translate="yes" xml:space="preserve">
          <source>The value should be a known timestamp such as the last modification time of the source or package and it should be set by the build process.</source>
          <target state="translated">この値は、ソースやパッケージの最終修正時刻などの既知のタイムスタンプで、ビルドプロセスで設定します。</target>
        </trans-unit>
        <trans-unit id="e30741bdd1a5b46b18e6720866027b16cbef67a9" translate="yes" xml:space="preserve">
          <source>The values &amp;lsquo;</source>
          <target state="translated">その価値 '</target>
        </trans-unit>
        <trans-unit id="0725ef659b65323c744f64d2a18ca8ec4185c000" translate="yes" xml:space="preserve">
          <source>The values of the members of the execution character set (C90, C99 and C11 5.2.1).</source>
          <target state="translated">実行文字セット(C90、C99、C11 5.2.1)のメンバの値。</target>
        </trans-unit>
        <trans-unit id="c50dd57103792a97d47d46235c3239eae04dabde" translate="yes" xml:space="preserve">
          <source>The values or expressions assigned to the macros specified in the headers &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; (C90, C99 and C11 5.2.4.2, C99 7.18.2, C99 7.18.3, C11 7.20.2, C11 7.20.3).</source>
          <target state="translated">ヘッダー &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; で指定されたマクロに割り当てられた値または式（C90、C99およびC11 5.2.4.2、C99 7.18.2、C99 7.18.3、 C11 7.20.2、C11 7.20.3）。</target>
        </trans-unit>
        <trans-unit id="c24e1e6a031d69e73f1ce7f443d81ca980894830" translate="yes" xml:space="preserve">
          <source>The vector type associated with paired-single values is usually called &lt;code&gt;v2sf&lt;/code&gt;. It can be defined in C as follows:</source>
          <target state="translated">ペアの単一の値に関連付けられたベクトルタイプは、通常 &lt;code&gt;v2sf&lt;/code&gt; と呼ばれます。Cでは次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="37fd6ea52bde5e4eca142e1cb75092f72771ffd7" translate="yes" xml:space="preserve">
          <source>The virtual registers.</source>
          <target state="translated">仮想レジスタです。</target>
        </trans-unit>
        <trans-unit id="72d4e21a353ad4b2c91fcbc017d8cd072d1cc8a4" translate="yes" xml:space="preserve">
          <source>The visibility attribute should be applied only to declarations that would otherwise have external linkage. The attribute should be applied consistently, so that the same entity should not be declared with different settings of the attribute.</source>
          <target state="translated">visibility属性は、そうでなければ外部リンクを持つ宣言にのみ適用されるべきである。属性は一貫して適用されるべきであり、同じ実体が属性の異なる設定で宣言されてはならない。</target>
        </trans-unit>
        <trans-unit id="dcdff986b782b656015cb9e4191209d1fd6e3439" translate="yes" xml:space="preserve">
          <source>The warning is not issued after a &lt;code&gt;#line&lt;/code&gt; directive, since this typically indicates autogenerated code, and no assumptions can be made about the layout of the file that the directive references.</source>
          <target state="translated">&lt;code&gt;#line&lt;/code&gt; ディレクティブの後に警告が発行されることはありません。これは通常、自動生成されたコードを示しており、ディレクティブが参照するファイルのレイアウトについて想定できないためです。</target>
        </trans-unit>
        <trans-unit id="c1d163df4c56e51212f1f69dc140213a05352c42" translate="yes" xml:space="preserve">
          <source>The warning is not issued for code involving multiline preprocessor logic such as the following example.</source>
          <target state="translated">以下の例のような複数行のプリプロセッサ・ロジックを含むコードでは、警告は発生しません。</target>
        </trans-unit>
        <trans-unit id="dcb7b8cd90065f04f3725df949fc5d9c95db8632" translate="yes" xml:space="preserve">
          <source>The warning message for each controllable warning includes the option that controls the warning. That option can then be used with</source>
          <target state="translated">制御可能な各警告の警告メッセージには、警告を制御するオプションが含まれています。そのオプションは</target>
        </trans-unit>
        <trans-unit id="f1f31ebd493031aa0be9fb191d41eda3a3e18dd4" translate="yes" xml:space="preserve">
          <source>The warnings for missing or incorrect sentinels are enabled with</source>
          <target state="translated">センチネルが見つからなかったり、間違ったセンチネルがあった場合の警告は</target>
        </trans-unit>
        <trans-unit id="6fb1f41a4e1e0161c8bf4c849af0ffb5ebafd481" translate="yes" xml:space="preserve">
          <source>The way to solve these problems is to put &amp;lsquo;</source>
          <target state="translated">これらの問題を解決する方法は、</target>
        </trans-unit>
        <trans-unit id="206a81db22964ace6231b75566fe4c7da1707abe" translate="yes" xml:space="preserve">
          <source>The workarounds for the division errata rely on special functions in</source>
          <target state="translated">分割正誤表の回避策は</target>
        </trans-unit>
        <trans-unit id="3ecc69e9abd77cc6ec0f76d76bb1dccaddb7e950" translate="yes" xml:space="preserve">
          <source>The x86 architecture supports additional memory ordering flags to mark critical sections for hardware lock elision. These must be specified in addition to an existing memory order to atomic intrinsics.</source>
          <target state="translated">x86アーキテクチャは、ハードウェアロックエリシオンのための重要なセクションをマークするための追加のメモリ順序フラグをサポートしています。これらは、既存のメモリ順序に加えて、アトミックイントリニクスへのメモリ順序を指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="f94474d9a2fee2945e274919425bc2dedd2ef21c" translate="yes" xml:space="preserve">
          <source>The x86-32 and x86-64 family of processors use additional built-in functions for efficient use of &lt;code&gt;TF&lt;/code&gt; (&lt;code&gt;__float128&lt;/code&gt;) 128-bit floating point and &lt;code&gt;TC&lt;/code&gt; 128-bit complex floating-point values.</source>
          <target state="translated">x86-32およびx86-64ファミリーのプロセッサーは、 &lt;code&gt;TF&lt;/code&gt; （ &lt;code&gt;__float128&lt;/code&gt; ）128ビット浮動小数点および &lt;code&gt;TC&lt;/code&gt; 128ビット複素浮動小数点値を効率的に使用するために追加の組み込み関数を使用します。</target>
        </trans-unit>
        <trans-unit id="d02b4be795b4b009422772986429301880a6ca1d" translate="yes" xml:space="preserve">
          <source>Then use the &lt;code&gt;create_gcov&lt;/code&gt; tool to convert the raw profile data to a format that can be used by GCC. You must also supply the unstripped binary for your program to this tool. See &lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;https://github.com/google/autofdo&lt;/a&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;create_gcov&lt;/code&gt; ツールを使用して、生のプロファイルデータをGCCで使用できる形式に変換します。また、プログラムのストリップされていないバイナリをこのツールに提供する必要があります。&lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;https://github.com/google/autofdoを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="926b284ef06d8680215f804da3458309f6cd9668" translate="yes" xml:space="preserve">
          <source>Then you can select a label with indexing, like this:</source>
          <target state="translated">すると、こんな感じでインデックス付きのラベルを選択することができます。</target>
        </trans-unit>
        <trans-unit id="cea728bf3b20beeae36b33c3b1a8dc7982befc50" translate="yes" xml:space="preserve">
          <source>There are 6 different memory orders that can be specified. These map to the C++11 memory orders with the same names, see the C++11 standard or the &lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;GCC wiki on atomic synchronization&lt;/a&gt; for detailed definitions. Individual targets may also support additional memory orders for use on specific architectures. Refer to the target documentation for details of these.</source>
          <target state="translated">指定できるメモリ順序は6種類あります。これらは、同じ名前のC ++ 11メモリオーダーにマップされます。詳細な定義については、C ++ 11標準または&lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;アトミック同期に関するGCC wikiを&lt;/a&gt;参照してください。個々のターゲットは、特定のアーキテクチャーで使用するための追加のメモリー順序もサポートする場合があります。これらの詳細については、ターゲットのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="02f6ba3037fb7689eee8ed8968fd8f0d8ac13840" translate="yes" xml:space="preserve">
          <source>There are also GNU extension functions &lt;code&gt;clog10&lt;/code&gt;, &lt;code&gt;clog10f&lt;/code&gt; and &lt;code&gt;clog10l&lt;/code&gt; which names are reserved by ISO C99 for future use. All these functions have versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="translated">GNU拡張関数 &lt;code&gt;clog10&lt;/code&gt; 、 &lt;code&gt;clog10f&lt;/code&gt; 、および &lt;code&gt;clog10l&lt;/code&gt; もあり、これらの名前はISO C99によって将来の使用のために予約されています。これらのすべての関数には、 &lt;code&gt;__builtin_&lt;/code&gt; で始まるバージョンがあります。</target>
        </trans-unit>
        <trans-unit id="875ce1195c45f2b46d9a99c39e44fd3ec9b5e9cf" translate="yes" xml:space="preserve">
          <source>There are also built-in functions &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, corresponding to the TS 18661-3 functions &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, for supported types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">そこにはまた、内蔵されている機能 &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 、 &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 、 &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 及び &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 、TS 18661から3つの関数に対応 &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 、 &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 、 &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 及び &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; サポートされているタイプの、 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; と &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10087f06f9970243ffcf86e55d1829b3627290b7" translate="yes" xml:space="preserve">
          <source>There are also built-in versions of the ISO C99 functions &lt;code&gt;acosf&lt;/code&gt;, &lt;code&gt;acosl&lt;/code&gt;, &lt;code&gt;asinf&lt;/code&gt;, &lt;code&gt;asinl&lt;/code&gt;, &lt;code&gt;atan2f&lt;/code&gt;, &lt;code&gt;atan2l&lt;/code&gt;, &lt;code&gt;atanf&lt;/code&gt;, &lt;code&gt;atanl&lt;/code&gt;, &lt;code&gt;ceilf&lt;/code&gt;, &lt;code&gt;ceill&lt;/code&gt;, &lt;code&gt;cosf&lt;/code&gt;, &lt;code&gt;coshf&lt;/code&gt;, &lt;code&gt;coshl&lt;/code&gt;, &lt;code&gt;cosl&lt;/code&gt;, &lt;code&gt;expf&lt;/code&gt;, &lt;code&gt;expl&lt;/code&gt;, &lt;code&gt;fabsf&lt;/code&gt;, &lt;code&gt;fabsl&lt;/code&gt;, &lt;code&gt;floorf&lt;/code&gt;, &lt;code&gt;floorl&lt;/code&gt;, &lt;code&gt;fmodf&lt;/code&gt;, &lt;code&gt;fmodl&lt;/code&gt;, &lt;code&gt;frexpf&lt;/code&gt;, &lt;code&gt;frexpl&lt;/code&gt;, &lt;code&gt;ldexpf&lt;/code&gt;, &lt;code&gt;ldexpl&lt;/code&gt;, &lt;code&gt;log10f&lt;/code&gt;, &lt;code&gt;log10l&lt;/code&gt;, &lt;code&gt;logf&lt;/code&gt;, &lt;code&gt;logl&lt;/code&gt;, &lt;code&gt;modfl&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;powf&lt;/code&gt;, &lt;code&gt;powl&lt;/code&gt;, &lt;code&gt;sinf&lt;/code&gt;, &lt;code&gt;sinhf&lt;/code&gt;, &lt;code&gt;sinhl&lt;/code&gt;, &lt;code&gt;sinl&lt;/code&gt;, &lt;code&gt;sqrtf&lt;/code&gt;, &lt;code&gt;sqrtl&lt;/code&gt;, &lt;code&gt;tanf&lt;/code&gt;, &lt;code&gt;tanhf&lt;/code&gt;, &lt;code&gt;tanhl&lt;/code&gt; and &lt;code&gt;tanl&lt;/code&gt; that are recognized in any mode since ISO C90 reserves these names for the purpose to which ISO C99 puts them. All these functions have corresponding versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="translated">あり、内蔵されているISO C99関数のバージョン &lt;code&gt;acosf&lt;/code&gt; 、 &lt;code&gt;acosl&lt;/code&gt; 、 &lt;code&gt;asinf&lt;/code&gt; 、 &lt;code&gt;asinl&lt;/code&gt; 、 &lt;code&gt;atan2f&lt;/code&gt; 、 &lt;code&gt;atan2l&lt;/code&gt; 、 &lt;code&gt;atanf&lt;/code&gt; 、 &lt;code&gt;atanl&lt;/code&gt; 、 &lt;code&gt;ceilf&lt;/code&gt; 、 &lt;code&gt;ceill&lt;/code&gt; 、 &lt;code&gt;cosf&lt;/code&gt; 、 &lt;code&gt;coshf&lt;/code&gt; 、 &lt;code&gt;coshl&lt;/code&gt; 、 &lt;code&gt;cosl&lt;/code&gt; 、 &lt;code&gt;expf&lt;/code&gt; 、 &lt;code&gt;expl&lt;/code&gt; 、 &lt;code&gt;fabsf&lt;/code&gt; 、 &lt;code&gt;fabsl&lt;/code&gt; 、 &lt;code&gt;floorf&lt;/code&gt; 、 &lt;code&gt;floorl&lt;/code&gt; 、 &lt;code&gt;fmodf&lt;/code&gt; 、 &lt;code&gt;fmodl&lt;/code&gt; 、 &lt;code&gt;frexpf&lt;/code&gt; 、 &lt;code&gt;frexpl&lt;/code&gt; 、 &lt;code&gt;ldexpf&lt;/code&gt; 、 &lt;code&gt;ldexpl&lt;/code&gt; 、 &lt;code&gt;log10f&lt;/code&gt; 、 &lt;code&gt;log10l&lt;/code&gt; 、 &lt;code&gt;logf&lt;/code&gt; 、 &lt;code&gt;logl&lt;/code&gt; 、 &lt;code&gt;modfl&lt;/code&gt; 、 &lt;code&gt;modf&lt;/code&gt; 、 &lt;code&gt;powf&lt;/code&gt; 、 &lt;code&gt;powl&lt;/code&gt; 、 &lt;code&gt;sinf&lt;/code&gt; 、 &lt;code&gt;sinhf&lt;/code&gt; 、 &lt;code&gt;sinhl&lt;/code&gt; 、 &lt;code&gt;sinl&lt;/code&gt; 、 &lt;code&gt;sqrtf&lt;/code&gt; 、 &lt;code&gt;sqrtl&lt;/code&gt; 、 &lt;code&gt;tanf&lt;/code&gt; 、 &lt;code&gt;tanhf&lt;/code&gt; 、 &lt;code&gt;tanhl&lt;/code&gt; と &lt;code&gt;tanl&lt;/code&gt; ISO C90準備ので、任意のモードで認識されますこれらの名前は、ISO C99が使用する目的で使用されます。これらすべての関数には、対応するバージョンの接頭辞が付いています &lt;code&gt;__builtin_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e32bac703972f0098c171900bd4cc85df014dde5" translate="yes" xml:space="preserve">
          <source>There are also checking built-in functions for formatted output functions.</source>
          <target state="translated">また、フォーマットされた出力関数については、組み込み関数のチェックもあります。</target>
        </trans-unit>
        <trans-unit id="4f8ad06fe6014524cc57bfacf331d94eea076d2f" translate="yes" xml:space="preserve">
          <source>There are built-in functions added for many common string operation functions, e.g., for &lt;code&gt;memcpy&lt;/code&gt;&lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; built-in is provided. This built-in has an additional last argument, which is the number of bytes remaining in the object the &lt;var&gt;dest&lt;/var&gt; argument points to or &lt;code&gt;(size_t) -1&lt;/code&gt; if the size is not known.</source>
          <target state="translated">多くの一般的な文字列操作関数に追加された組み込み関数があります。たとえば、 &lt;code&gt;memcpy&lt;/code&gt; &lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; 組み込み関数が提供されています。この組み込みには、最後の引数が追加されています。これは、 &lt;var&gt;dest&lt;/var&gt; 引数が指すオブジェクトに残っているバイト数、またはサイズが不明の場合は &lt;code&gt;(size_t) -1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e8ecb3f393a336df7fd790409c78fca65366bb71" translate="yes" xml:space="preserve">
          <source>There are four levels of warning supported by GCC. The default is</source>
          <target state="translated">GCCでサポートされている警告のレベルは4段階です。デフォルトは</target>
        </trans-unit>
        <trans-unit id="c5c6335a792caea07ef43ebcfd0dbedc3bba84b4" translate="yes" xml:space="preserve">
          <source>There are four supported &lt;var&gt;visibility_type&lt;/var&gt; values: default, hidden, protected or internal visibility.</source>
          <target state="translated">サポートされる &lt;var&gt;visibility_type&lt;/var&gt; 値は4つあります：デフォルト、非表示、保護、または内部の可視性。</target>
        </trans-unit>
        <trans-unit id="ce8ba713c06a7d9c57fd70b516918aacdd01bbce" translate="yes" xml:space="preserve">
          <source>There are many more AVR-specific built-in functions that are used to implement the ISO/IEC TR 18037 &amp;ldquo;Embedded C&amp;rdquo; fixed-point functions of section 7.18a.6. You don&amp;rsquo;t need to use these built-ins directly. Instead, use the declarations as supplied by the &lt;code&gt;stdfix.h&lt;/code&gt; header with GNU-C99:</source>
          <target state="translated">セクション7.18a.6のISO / IEC TR 18037&amp;ldquo; Embedded C&amp;rdquo;固定小数点関数を実装するために使用されるAVR固有の組み込み関数は他にもたくさんあります。これらのビルトインを直接使用する必要はありません。代わりに、GNU-C99で &lt;code&gt;stdfix.h&lt;/code&gt; ヘッダーによって提供される宣言を使用します。</target>
        </trans-unit>
        <trans-unit id="82e7d52ba0a431ff758889d5327a13ddffa9df26" translate="yes" xml:space="preserve">
          <source>There are many other possibilities, limited only by your imagination, good sense, and the constraints of your build system.</source>
          <target state="translated">他にも、想像力や良識、ビルドシステムの制約などで制限される可能性はたくさんあります。</target>
        </trans-unit>
        <trans-unit id="15ef48c0fb35d807a55378bf489805cb806add15" translate="yes" xml:space="preserve">
          <source>There are other differences between these two methods. Space allocated with &lt;code&gt;alloca&lt;/code&gt; exists until the containing &lt;em&gt;function&lt;/em&gt; returns. The space for a variable-length array is deallocated as soon as the array name&amp;rsquo;s scope ends, unless you also use &lt;code&gt;alloca&lt;/code&gt; in this scope.</source>
          <target state="translated">これら2つの方法には他にも違いがあります。 &lt;code&gt;alloca&lt;/code&gt; で割り当てられたスペースは、それを含む&lt;em&gt;関数&lt;/em&gt;が戻るまで存在します。可変長配列のスペースは、このスコープで &lt;code&gt;alloca&lt;/code&gt; を使用しない限り、配列名のスコープが終了するとすぐに割り当て解除されます。</target>
        </trans-unit>
        <trans-unit id="ec4c204c6335b8fb2d87ba86456a428609cad26b" translate="yes" xml:space="preserve">
          <source>There are several caveats to using the new exception mechanism:</source>
          <target state="translated">新しい例外の仕組みを使うには、いくつかの注意点があります。</target>
        </trans-unit>
        <trans-unit id="c35ba4e6fe38d832f24909aadf0cb677e0066a30" translate="yes" xml:space="preserve">
          <source>There are several constructs in C++ that require space in the object file but are not clearly tied to a single translation unit. We say that these constructs have &amp;ldquo;vague linkage&amp;rdquo;. Typically such constructs are emitted wherever they are needed, though sometimes we can be more clever.</source>
          <target state="translated">C ++には、オブジェクトファイルにスペースを必要とするいくつかの構造がありますが、単一の変換単位に明確に関連付けられていません。これらの構造には「あいまいなリンケージ」があると私たちは言います。通常、このような構造は必要な場所に出力されますが、より賢い場合もあります。</target>
        </trans-unit>
        <trans-unit id="973e35674df499ab71700555edbe1a93e1641ce5" translate="yes" xml:space="preserve">
          <source>There are several noteworthy incompatibilities between GNU C and K&amp;amp;R (non-ISO) versions of C.</source>
          <target state="translated">CのGNU CバージョンとK＆R（非ISO）バージョンの間には、いくつかの注目すべき非互換性があります。</target>
        </trans-unit>
        <trans-unit id="0f04da83ffcbe77658a4a2fadeea31bbf52a4d35" translate="yes" xml:space="preserve">
          <source>There are several situations in which an application should use the shared</source>
          <target state="translated">アプリケーションが共有の</target>
        </trans-unit>
        <trans-unit id="7959f13cb983e884f2106a8d8e6aa988bd66a9f9" translate="yes" xml:space="preserve">
          <source>There are some arguments for making bit-fields unsigned by default on all machines. If, for example, this becomes a universal de facto standard, it would make sense for GCC to go along with it. This is something to be considered in the future.</source>
          <target state="translated">すべてのマシンでビットフィールドをデフォルトで符号なしにすることにはいくつかの議論があります。例えば、これが普遍的なデファクトスタンダードになれば、GCCがそれに沿って進むことは理にかなっているでしょう。これは将来的に検討すべきことです。</target>
        </trans-unit>
        <trans-unit id="451c9c37af0f9094bf98f147452ec7b2c1e8a8be" translate="yes" xml:space="preserve">
          <source>There are some code generation flags preserved by GCC when generating bytecodes, as they need to be used during the final link. Currently, the following options and their settings are taken from the first object file that explicitly specifies them:</source>
          <target state="translated">バイトコードを生成する際にGCCによって保存されるコード生成フラグがいくつかありますが、これは最終的なリンク中に使用する必要があるためです。現在のところ、以下のオプションとその設定は、それらを明示的に指定する最初のオブジェクトファイルから取得されます。</target>
        </trans-unit>
        <trans-unit id="d537bfaa9f6c3001fc1a88f5b799ca08bd61a582" translate="yes" xml:space="preserve">
          <source>There are some constraints on how this can be used&amp;mdash;</source>
          <target state="translated">これを使用する方法にはいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="136389e963628b14cbedd792ceed996572d52240" translate="yes" xml:space="preserve">
          <source>There are some problems with the semantics of attributes in C++. For example, there are no manglings for attributes, although they may affect code generation, so problems may arise when attributed types are used in conjunction with templates or overloading. Similarly, &lt;code&gt;typeid&lt;/code&gt; does not distinguish between types with different attributes. Support for attributes in C++ may be restricted in future to attributes on declarations only, but not on nested declarators.</source>
          <target state="translated">C ++の属性のセマンティクスにはいくつかの問題があります。たとえば、属性のマングリングはありませんが、コード生成に影響を与える可能性があるため、属性付きの型をテンプレートまたはオーバーロードと組み合わせて使用​​すると問題が発生する可能性があります。同様に、 &lt;code&gt;typeid&lt;/code&gt; は異なる属性を持つタイプを区別しません。C ++での属性のサポートは、将来的には宣言の属性のみに制限され、ネストされた宣言子では制限されない可能性があります。</target>
        </trans-unit>
        <trans-unit id="f0a43a1a2abc532264a4772bfd3acfd532a1ab60" translate="yes" xml:space="preserve">
          <source>There are two ways of writing the argument to &lt;code&gt;typeof&lt;/code&gt;: with an expression or with a type. Here is an example with an expression:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; に引数を書き込むには、式を使用する方法と型を使用する方法の2つがあります。次に、式の例を示します。</target>
        </trans-unit>
        <trans-unit id="bc25dda9b9f38426b4a5c6b4195fea59e37ab096" translate="yes" xml:space="preserve">
          <source>There is a new runtime function &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; which can be used to declare a so-called &lt;em&gt;weak pointer&lt;/em&gt; reference. Such a pointer is basically hidden for the garbage collector; this can be useful in certain situations, especially when you want to keep track of the allocated objects, yet allow them to be collected. This kind of pointers can only be members of objects, you cannot declare a global pointer as a weak reference. Every type which is a pointer type can be declared a weak pointer, including &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;SEL&lt;/code&gt;.</source>
          <target state="translated">いわゆる&lt;em&gt;弱いポインター&lt;/em&gt;参照を宣言するために使用できる新しいランタイム関数 &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; があります。このようなポインターは、ガベージコレクターには基本的に非表示です。これは、特定の状況で、特に割り当てられたオブジェクトを追跡しながら、それらを収集できるようにする場合に役立ちます。この種のポインターはオブジェクトのメンバーにのみなることができ、グローバルポインターを弱い参照として宣言することはできません。ポインター型であるすべての型は、 &lt;code&gt;id&lt;/code&gt; 、 &lt;code&gt;Class&lt;/code&gt; 、 &lt;code&gt;SEL&lt;/code&gt; などのウィークポインターとして宣言できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6782eab9d50f7c071e99f8fc866abd4eb5cd6fa7" translate="yes" xml:space="preserve">
          <source>There is a proposed representation for view numbers that is not backward compatible with the location list format introduced in DWARF 5, that can be enabled with</source>
          <target state="translated">ビュー番号の表現には、DWARF 5 で導入された位置リスト形式との下位互換性がないものが提案されています。</target>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">はありません。</target>
        </trans-unit>
        <trans-unit id="29b7356a3e71c6ac7b87a32d1d5d861dca74d15e" translate="yes" xml:space="preserve">
          <source>There is no formal written standard for Objective-C or Objective-C++. The authoritative manual on traditional Objective-C (1.0) is &amp;ldquo;Object-Oriented Programming and the Objective-C Language&amp;rdquo;: &lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&lt;/a&gt; is the original NeXTstep document.</source>
          <target state="translated">Objective-CまたはObjective-C ++には、正式に書かれた標準はありません。従来のObjective-C（1.0）の信頼できるマニュアルは「オブジェクト指向プログラミングとObjective-C言語」です&lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;。http&lt;/a&gt;：//www.gnustep.org/resources/documentation/ObjectivCBook.pdfは元のNeXTstepドキュメントです。</target>
        </trans-unit>
        <trans-unit id="533538e5f5aef48cf028f3ce488b08d6002276fb" translate="yes" xml:space="preserve">
          <source>There is no guarantee (in either the C or the C++ standard language definitions) that the increments will be evaluated in any particular order. Either increment might happen first. &lt;code&gt;func&lt;/code&gt; might get the arguments &amp;lsquo;</source>
          <target state="translated">増分が特定の順序で評価されるという保証はありません（CまたはC ++標準言語定義のいずれかで）。いずれかの増分が最初に発生する可能性があります。 &lt;code&gt;func&lt;/code&gt; は引数を取得する可能性があります '</target>
        </trans-unit>
        <trans-unit id="734d8f3426c5c4d551e49ff2012c542f74ef1c08" translate="yes" xml:space="preserve">
          <source>There is no guarantee any transaction ever succeeds, so there always needs to be a valid fallback path.</source>
          <target state="translated">トランザクションが成功する保証はありませんので、常に有効なフォールバックパスが必要です。</target>
        </trans-unit>
        <trans-unit id="df09188c09c71974483614543b07ff3dea71c626" translate="yes" xml:space="preserve">
          <source>There is no support for nesting dialect alternatives.</source>
          <target state="translated">入れ子になっている方言の代替品のサポートはありません。</target>
        </trans-unit>
        <trans-unit id="7415b415266f5ddf918da08e3399f543c97fb7d5" translate="yes" xml:space="preserve">
          <source>There is no way to split up the contents of a single header file into multiple implementation files.</source>
          <target state="translated">1つのヘッダファイルの内容を複数の実装ファイルに分割する方法はありません。</target>
        </trans-unit>
        <trans-unit id="b35fa3005d504f47c5b76912e05a2d94970ddd97" translate="yes" xml:space="preserve">
          <source>There is no way within the template to determine which alternative was chosen. However you may be able to wrap your &lt;code&gt;asm&lt;/code&gt; statements with builtins such as &lt;code&gt;__builtin_constant_p&lt;/code&gt; to achieve the desired results.</source>
          <target state="translated">テンプレート内で、どの代替案が選択されたかを判断する方法はありません。しかし、あなたはあなたのラップすることができるかもしれ &lt;code&gt;asm&lt;/code&gt; ような組み込みコマンドとステートメントを &lt;code&gt;__builtin_constant_p&lt;/code&gt; 所望の結果を達成するために。</target>
        </trans-unit>
        <trans-unit id="ae8b54db3c2d81811451aec9ad4c249cf9c17c8b" translate="yes" xml:space="preserve">
          <source>There is some overlap between the purposes of attributes and pragmas (see &lt;a href=&quot;pragmas#Pragmas&quot;&gt;Pragmas Accepted by GCC&lt;/a&gt;). It has been found convenient to use &lt;code&gt;__attribute__&lt;/code&gt; to achieve a natural attachment of attributes to their corresponding declarations, whereas &lt;code&gt;#pragma&lt;/code&gt; is of use for compatibility with other compilers or constructs that do not naturally form part of the grammar.</source>
          <target state="translated">属性とプラグマの目的にはいくつかの重複があります（&lt;a href=&quot;pragmas#Pragmas&quot;&gt;GCCで受け入れ&lt;/a&gt;られるプラグマを参照）。 &lt;code&gt;__attribute__&lt;/code&gt; を使用して、対応する宣言に属性を自然に付加するのが便利であることがわかっています。一方、 &lt;code&gt;#pragma&lt;/code&gt; は、自然に文法の一部を形成しない他のコンパイラまたは構造との互換性のために使用されます。</target>
        </trans-unit>
        <trans-unit id="07be20761a89905e90146c4650de03345401fe54" translate="yes" xml:space="preserve">
          <source>There may be pitfalls when you use &lt;code&gt;long long&lt;/code&gt; types for function arguments without function prototypes. If a function expects type &lt;code&gt;int&lt;/code&gt; for its argument, and you pass a value of type &lt;code&gt;long long int&lt;/code&gt;, confusion results because the caller and the subroutine disagree about the number of bytes for the argument. Likewise, if the function expects &lt;code&gt;long long int&lt;/code&gt; and you pass &lt;code&gt;int&lt;/code&gt;. The best way to avoid such problems is to use prototypes.</source>
          <target state="translated">関数プロトタイプなしで関数の引数に &lt;code&gt;long long&lt;/code&gt; 型を使用すると、落とし穴が生じる可能性があります。関数が引数に &lt;code&gt;int&lt;/code&gt; 型を期待しているときに &lt;code&gt;long long int&lt;/code&gt; 型の値を渡した場合、呼び出し元とサブルーチンが引数のバイト数について一致しないため、混乱が生じます。関数が想定している場合同様に、 &lt;code&gt;long long int&lt;/code&gt; 、あなたは合格 &lt;code&gt;int&lt;/code&gt; 型。このような問題を回避する最良の方法は、プロトタイプを使用することです。</target>
        </trans-unit>
        <trans-unit id="4d9628a707838f509cf0a37ebb92916da132e1d6" translate="yes" xml:space="preserve">
          <source>Therefore, the G++ driver automatically adds</source>
          <target state="translated">そのため、G++ドライバは自動的に</target>
        </trans-unit>
        <trans-unit id="47997e2980ed03d4553af1541dc131cfa6cb91bc" translate="yes" xml:space="preserve">
          <source>Therefore, the expression</source>
          <target state="translated">そのため、式</target>
        </trans-unit>
        <trans-unit id="6ea5dc6096c9bd173073ecde828a55eabd5d76e4" translate="yes" xml:space="preserve">
          <source>These</source>
          <target state="translated">These</target>
        </trans-unit>
        <trans-unit id="322fe3b4715f9524d383adeb084e8533651edeb7" translate="yes" xml:space="preserve">
          <source>These &amp;lsquo;</source>
          <target state="translated">これら '</target>
        </trans-unit>
        <trans-unit id="cdc6fb4722bc714d5fae1673f7398b196f782701" translate="yes" xml:space="preserve">
          <source>These additional &amp;lsquo;</source>
          <target state="translated">これらの追加 '</target>
        </trans-unit>
        <trans-unit id="2dea8e42e0ac78d81c1030a34ffa5859fb43e5e8" translate="yes" xml:space="preserve">
          <source>These additional options are available for Microsoft Windows targets:</source>
          <target state="translated">これらの追加オプションは、Microsoft Windows ターゲットで利用可能です。</target>
        </trans-unit>
        <trans-unit id="429200a04514f92caf3b4499a491ca222d5caed0" translate="yes" xml:space="preserve">
          <source>These additional options are available on System V Release 4 for compatibility with other compilers on those systems:</source>
          <target state="translated">これらの追加オプションは、System V Release 4では、これらのシステム上の他のコンパイラとの互換性のために利用可能です。</target>
        </trans-unit>
        <trans-unit id="aee4beda520b02d216d51ad833fd44f1904ba2f8" translate="yes" xml:space="preserve">
          <source>These are 16-bit address spaces locating data in section &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; where &lt;var&gt;N&lt;/var&gt; refers to address space &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt;. The compiler sets the &lt;code&gt;RAMPZ&lt;/code&gt; segment register appropriately before reading data by means of the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="translated">これらは、セクション &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; でデータを検索する16ビットのアドレススペースで、 &lt;var&gt;N&lt;/var&gt; はアドレススペース &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; 指します。コンパイラーは、 &lt;code&gt;ELPM&lt;/code&gt; 命令によってデータを読み取る前に、 &lt;code&gt;RAMPZ&lt;/code&gt; セグメントレジスタを適切に設定します。</target>
        </trans-unit>
        <trans-unit id="9bc1925e612ca94ca27a8264a7444be5df20595d" translate="yes" xml:space="preserve">
          <source>These are aliases for the corresponding</source>
          <target state="translated">これらは、対応する</target>
        </trans-unit>
        <trans-unit id="779c6f17661e07ac4152f7dc676778ae7628f8f4" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS/6000 and PowerPC Options&lt;/a&gt;.</source>
          <target state="translated">これらはSee &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS / 6000 and PowerPC Optionsに&lt;/a&gt;リストされています。</target>
        </trans-unit>
        <trans-unit id="ae931926b0b87957b809699bfe98630faaab5aad" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;S/390 and zSeries Options&lt;/a&gt;.</source>
          <target state="translated">これらは、See &lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;S / 390 and zSeries Optionsに&lt;/a&gt;リストされています。</target>
        </trans-unit>
        <trans-unit id="40acc5623309fbea5623f2aba009e341f97fe7cb" translate="yes" xml:space="preserve">
          <source>These are the &amp;lsquo;</source>
          <target state="translated">これらは '</target>
        </trans-unit>
        <trans-unit id="25a9625ab38cfd983e37ec2df20ad8c1cd341393" translate="yes" xml:space="preserve">
          <source>These are the options defined for the Altera Nios II processor.</source>
          <target state="translated">これらは、Altera Nios II プロセッサ用に定義されたオプションです。</target>
        </trans-unit>
        <trans-unit id="ddfdc15ea502fdc771fd53ee7ee413d91e5a491a" translate="yes" xml:space="preserve">
          <source>These are the supported qualifiers:</source>
          <target state="translated">これらはサポートされている修飾子です。</target>
        </trans-unit>
        <trans-unit id="ea04fd9aefe63e6f009323195856f23e96723b58" translate="yes" xml:space="preserve">
          <source>These attributes are the same as the MSP430 function attributes of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;). These attributes can be applied to both functions and variables.</source>
          <target state="translated">これらの属性は、同じ名前のMSP430関数属性と同じです（&lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430関数属性を&lt;/a&gt;参照）。これらの属性は、関数と変数の両方に適用できます。</target>
        </trans-unit>
        <trans-unit id="bc9f0c12140351e3fedd51dae4c1164e0be835e5" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">これらの属性は、指定された関数が割り込みハンドラであることを示します。この属性がある場合、コンパイラは割り込みハンドラで使用するのに適した関数のエントリシーケンスとエグジットシーケンスを生成します。</target>
        </trans-unit>
        <trans-unit id="90cae17a8377f793b8674b8db0decc44a0b2b0db" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. Use the &lt;code&gt;fast_interrupt&lt;/code&gt; attribute to indicate handlers used in low-latency interrupt mode, and &lt;code&gt;interrupt_handler&lt;/code&gt; for interrupts that do not use low-latency handlers. In both cases, GCC emits appropriate prologue code and generates a return from the handler using &lt;code&gt;rtid&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="translated">これらの属性は、指定された関数が割り込みハンドラであることを示しています。使用 &lt;code&gt;fast_interrupt&lt;/code&gt; 低レイテンシ割り込みモード、およびで使用されるハンドラを示すために、属性を &lt;code&gt;interrupt_handler&lt;/code&gt; 低レイテンシのハンドラを使用していない割り込みのを。どちらの場合も、GCCは適切なプロローグコードを &lt;code&gt;rtid&lt;/code&gt; し、rtsdの代わりに &lt;code&gt;rtsd&lt;/code&gt; を使用してハンドラーからの戻りを生成します。</target>
        </trans-unit>
        <trans-unit id="0f83b1fb8a50c976a446dd169ccf0caf9284a311" translate="yes" xml:space="preserve">
          <source>These attributes override the default chosen by the</source>
          <target state="translated">これらの属性は</target>
        </trans-unit>
        <trans-unit id="af47925da5d7dad5e220bfdf28a73cd1e09ade04" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called on MIPS. The attributes override the</source>
          <target state="translated">これらの属性は、特定の関数がMIPS上でどのように呼び出されるかを指定します。この属性は</target>
        </trans-unit>
        <trans-unit id="c245dc24a2c3a655d76f63a05d461d62dfaa1098" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called. These attributes override the</source>
          <target state="translated">これらの属性は、特定の関数がどのように呼ばれるかを指定します。これらの属性は</target>
        </trans-unit>
        <trans-unit id="1d2db2e0a6cd3c160ce892077b566038f69a5d12" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the AArch64 family of processors.</source>
          <target state="translated">これらの組み込み機能は、AArch64 ファミリのプロセッサで利用できます。</target>
        </trans-unit>
        <trans-unit id="99ee134b7e3302b89897afcdd306492cac3af896" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors when the</source>
          <target state="translated">これらの組み込み機能は、ARM ファミリのプロセッサが</target>
        </trans-unit>
        <trans-unit id="a2c021905865fa6d163412cd97d22f339e716b63" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors with floating-point unit.</source>
          <target state="translated">これらの内蔵機能は、浮動小数点ユニットを搭載したARMファミリのプロセッサで利用可能です。</target>
        </trans-unit>
        <trans-unit id="48306035fd811f8d35a44f11213546ba486a0570" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Alpha family of processors, depending on the command-line switches used.</source>
          <target state="translated">これらの内蔵機能は、使用するコマンドラインスイッチに応じて、Alpha ファミリのプロセッサで利用可能です。</target>
        </trans-unit>
        <trans-unit id="7b3ba21ab5439a452d301344eaf50af645d462ac" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Altera Nios II family of processors.</source>
          <target state="translated">これらの内蔵機能は、Altera Nios II ファミリのプロセッサで利用できます。</target>
        </trans-unit>
        <trans-unit id="89f6765d03c89956e564760cefe25b8258f2acc4" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the NDS32 target:</source>
          <target state="translated">これらの内蔵機能はNDS32ターゲットで利用可能です。</target>
        </trans-unit>
        <trans-unit id="2fccae182b2f224cc802c582d293665235932f6e" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the x86-32 and x86-64 family of computers, depending on the command-line switches used.</source>
          <target state="translated">これらの組み込み機能は、使用するコマンドラインスイッチに応じて、x86-32およびx86-64ファミリーのコンピュータで利用できます。</target>
        </trans-unit>
        <trans-unit id="74fa1603a77cd22b8b03844382316cb7fce3f487" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to &lt;code&gt;__builtin_add_overflow&lt;/code&gt;, &lt;code&gt;__builtin_sub_overflow&lt;/code&gt;, or &lt;code&gt;__builtin_mul_overflow&lt;/code&gt;, except that they don&amp;rsquo;t store the result of the arithmetic operation anywhere and the last argument is not a pointer, but some expression with integral type other than enumerated or boolean type.</source>
          <target state="translated">これらの組み込み関数は、 &lt;code&gt;__builtin_sub_overflow&lt;/code&gt; &lt;code&gt;__builtin_add_overflow&lt;/code&gt; 、__builtin_sub_overflow、または &lt;code&gt;__builtin_mul_overflow&lt;/code&gt; に似ていますが、算術演算の結果がどこにも格納されず、最後の引数がポインターではなく、列挙型またはブール型以外の整数型の式がある点が異なります。</target>
        </trans-unit>
        <trans-unit id="49cc0a5435c96c360dc8a007e08ab18d83b226a2" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform multiplication, instead of addition.</source>
          <target state="translated">これらの組み込み関数は、加算の代わりに乗算を実行することを除いては、上記の加算オーバーフローチェックの組み込み関数と似ています。</target>
        </trans-unit>
        <trans-unit id="60566210b0678cb1c3591a4a16d4062b4b5565ab" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform subtraction, subtract the second argument from the first one, instead of addition.</source>
          <target state="translated">これらの組み込み関数は、加算の代わりに第1引数から第2引数を引く減算を行う点を除いては、上記の加算オーバーフローチェックの組み込み関数と似ています。</target>
        </trans-unit>
        <trans-unit id="f2854f4ac5cfaad00730f8aa21e163c5b047dff2" translate="yes" xml:space="preserve">
          <source>These built-in functions map to the respective machine instruction, i.e. &lt;code&gt;nop&lt;/code&gt;, &lt;code&gt;sei&lt;/code&gt;, &lt;code&gt;cli&lt;/code&gt;, &lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;wdr&lt;/code&gt;, &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fmul&lt;/code&gt;, &lt;code&gt;fmuls&lt;/code&gt; resp. &lt;code&gt;fmulsu&lt;/code&gt;. The three &lt;code&gt;fmul*&lt;/code&gt; built-ins are implemented as library call if no hardware multiplier is available.</source>
          <target state="translated">これらの組み込み関数は、それぞれの機械命令、つまり &lt;code&gt;nop&lt;/code&gt; 、 &lt;code&gt;sei&lt;/code&gt; 、 &lt;code&gt;cli&lt;/code&gt; 、 &lt;code&gt;sleep&lt;/code&gt; 、 &lt;code&gt;wdr&lt;/code&gt; 、 &lt;code&gt;swap&lt;/code&gt; 、 &lt;code&gt;fmul&lt;/code&gt; 、 &lt;code&gt;fmuls&lt;/code&gt; resp にマップされます。 &lt;code&gt;fmulsu&lt;/code&gt; 。ハードウェア乗算器が利用できない場合、3つの &lt;code&gt;fmul*&lt;/code&gt; ビルトインはライブラリコールとして実装されます。</target>
        </trans-unit>
        <trans-unit id="b498367f60152015d5067b4b4501b71daee8b167" translate="yes" xml:space="preserve">
          <source>These built-in functions perform an atomic compare and swap. That is, if the current value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is &lt;var&gt;oldval&lt;/var&gt;, then write &lt;var&gt;newval&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">これらの組み込み関数は、アトミックな比較とスワップを実行します。つまり、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の現在の値が &lt;var&gt;oldval&lt;/var&gt; である場合、 &lt;var&gt;newval&lt;/var&gt; を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="457d48795ac8a304362adc0940095ddd5561f409" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the new value. That is, operations on integer operands have the following semantics. Operations on pointer operands are performed as if the operand&amp;rsquo;s type were &lt;code&gt;uintptr_t&lt;/code&gt;.</source>
          <target state="translated">これらの組み込み関数は、名前で提案された操作を実行し、新しい値を返します。つまり、整数オペランドの演算には次のセマンティクスがあります。ポインターオペランドの演算は、オペランドの型が &lt;code&gt;uintptr_t&lt;/code&gt; であるかのように実行されます。</target>
        </trans-unit>
        <trans-unit id="c4af2a3302ed8abb6fe6e394796ceea4bd21df1d" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the result of the operation. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">これらの組み込み関数は、名前で提案された操作を実行し、操作の結果を返します。ポインター引数に対する操作は、オペランドが &lt;code&gt;uintptr_t&lt;/code&gt; タイプであるかのように実行されます。つまり、ポインターが指す型のサイズによってスケーリングされません。</target>
        </trans-unit>
        <trans-unit id="79ddce6ba857523eabbfd2cdfa6462c8733df6a0" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the value that had previously been in &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">これらの組み込み関数は、名前によって提案された操作を実行し、以前に &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; にあった値を返します。ポインター引数に対する操作は、オペランドが &lt;code&gt;uintptr_t&lt;/code&gt; タイプであるかのように実行されます。つまり、ポインターが指す型のサイズによってスケーリングされません。</target>
        </trans-unit>
        <trans-unit id="9d9da03d00f1fd8e4ece7f58ac8080d895ff5310" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and returns the value that had previously been in memory. That is, operations on integer operands have the following semantics. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">これらの組み込み関数は、名前によって提案された操作を実行し、以前にメモリにあった値を返します。つまり、整数オペランドの演算には次のセマンティクスがあります。ポインター引数に対する操作は、オペランドが &lt;code&gt;uintptr_t&lt;/code&gt; タイプであるかのように実行されます。つまり、ポインターが指す型のサイズによってスケーリングされません。</target>
        </trans-unit>
        <trans-unit id="55de8240dbd3fc7547da89964b220023f7b63ac6" translate="yes" xml:space="preserve">
          <source>These built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type the third pointer argument points to and stored there. If the stored result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. As the addition is performed in infinite signed precision, these built-in functions have fully defined behavior for all argument values.</source>
          <target state="translated">これらの組み込み関数は、最初の2つのオペランドを無限精度の符号付き型にプロモートし、プロモートされたオペランドに加算を実行します。結果は、3番目のポインター引数が指す型にキャストされ、そこに格納されます。格納された結果が無限精度の結果と等しい場合、組み込み関数は &lt;code&gt;false&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;true&lt;/code&gt; を返します。加算は無限の符号付き精度で実行されるため、これらの組み込み関数はすべての引数値に対して完全に定義された動作を持っています。</target>
        </trans-unit>
        <trans-unit id="272a12ae7cc5710c521265d94a65c2d1952b524a" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RISC-V targets:</source>
          <target state="translated">これらのコマンドラインオプションはRISC-Vターゲット用に定義されています。</target>
        </trans-unit>
        <trans-unit id="cde559b30a769153d7e8ca70dcc17ecf58e436b4" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RX targets:</source>
          <target state="translated">これらのコマンドラインオプションは、RX ターゲットに対して定義されています。</target>
        </trans-unit>
        <trans-unit id="51a802ea6adfbbd5a44e165efe9f9442f0fe2c45" translate="yes" xml:space="preserve">
          <source>These considerations mean that it is probably a bad idea to use statement expressions of this form in header files that are designed to work with C++. (Note that some versions of the GNU C Library contained header files using statement expressions that lead to precisely this bug.)</source>
          <target state="translated">これらの考慮事項は、C++で動作するように設計されたヘッダファイルでこの形式の文式を使うのは、おそらく悪い考えだということを意味しています(GNU Cライブラリのいくつかのバージョンには、まさにこのバグにつながる文式を使ったヘッダファイルが含まれていたことに注意してください)。(GNU Cライブラリのいくつかのバージョンには、まさにこのバグにつながる文式を使ったヘッダファイルが含まれていたことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="8bb762532560d78d44fe7f3daaea45c8583b0854" translate="yes" xml:space="preserve">
          <source>These constraints are represented as multiple alternatives. An alternative can be described by a series of letters for each operand. The overall constraint for an operand is made from the letters for this operand from the first alternative, a comma, the letters for this operand from the second alternative, a comma, and so on until the last alternative. All operands for a single instruction must have the same number of alternatives.</source>
          <target state="translated">これらの制約は、複数の代替案として表現されます。代替は、各オペランドに対する一連の文字で記述することができる。オペランドに対する全体的な制約は、最初の代替案からのこのオペランドに対する文字、カンマ、2番目の代替案からのこのオペランドに対する文字、カンマ、そして最後の代替案までの間の文字から作られます。1つの命令に対するすべてのオペランドは、同じ数の選択肢を持たなければなりません。</target>
        </trans-unit>
        <trans-unit id="38cef76099a34e5010638d4a8b6cdd6e8c967f30" translate="yes" xml:space="preserve">
          <source>These dumps are defined but always produce empty files.</source>
          <target state="translated">これらのダンプは定義されていますが、常に空のファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="dee9b2ccc9b3a342087894f7b0b9e01286328c92" translate="yes" xml:space="preserve">
          <source>These environment variables control the way that GCC uses localization information which allows GCC to work with different national conventions. GCC inspects the locale categories &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; if it has been configured to do so. These locale categories can be set to any value supported by your installation. A typical value is &amp;lsquo;</source>
          <target state="translated">これらの環境変数は、GCCがローカリゼーション情報を使用する方法を制御します。これにより、GCCはさまざまな国内の規則で動作できます。GCCは、ロケールカテゴリ &lt;code&gt;LC_CTYPE&lt;/code&gt; および &lt;code&gt;LC_MESSAGES&lt;/code&gt; を検査するように構成されているかどうかを検査します。これらのロケールカテゴリは、インストールでサポートされている任意の値に設定できます。典型的な値は '</target>
        </trans-unit>
        <trans-unit id="a489f50971ce1280d886918f48a3bb50c7a159d8" translate="yes" xml:space="preserve">
          <source>These extensions are also available as built-in functions: see &lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;x86 Built-in Functions&lt;/a&gt;, for details of the functions enabled and disabled by these switches.</source>
          <target state="translated">これらの拡張&lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;機能は&lt;/a&gt;、組み込み関数としても利用できます。これらのスイッチによって有効または無効になる関数の詳細については、「x86組み込み関数」を参照してください。</target>
        </trans-unit>
        <trans-unit id="8d27c12c180a98e05723ed39f8b22c27ed9edb1c" translate="yes" xml:space="preserve">
          <source>These extensions are available in C and Objective-C. Most of them are also available in C++. See &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;, for extensions that apply &lt;em&gt;only&lt;/em&gt; to C++.</source>
          <target state="translated">これらの拡張機能は、CおよびObjective-Cで使用できます。それらのほとんどはC ++でも使用できます。&lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;C ++に&lt;/a&gt;&lt;em&gt;のみ&lt;/em&gt;適用される拡張機能については、C ++言語の拡張機能を参照してください。</target>
        </trans-unit>
        <trans-unit id="543b06dcdf13923e1595eba210fefb04ac8d69e6" translate="yes" xml:space="preserve">
          <source>These function attributes are available for H8/300 targets:</source>
          <target state="translated">これらの関数属性は、H8/300ターゲットで利用可能です。</target>
        </trans-unit>
        <trans-unit id="bfd06787a8c3016d0f2f433589a9910af31152c9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AMD GCN back end:</source>
          <target state="translated">これらの関数属性は、AMD GCNバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="31d4d22755862f6885158e789fb6bd235507e320" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the ARC back end:</source>
          <target state="translated">これらの関数属性はARCバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="55c618a070b2ba6452534765be65dfbcbd06c924" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AVR back end:</source>
          <target state="translated">これらの機能属性はAVRバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="4000ac271516da07336a51da8c25e0b8f6d448c0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Blackfin back end:</source>
          <target state="translated">これらの関数属性は Blackfin バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="4afa11f7ee30e42598bbee2d62763ae6434a6f20" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the C-SKY back end:</source>
          <target state="translated">これらの関数属性は、C-SKYバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="0b39cd5a4dc8327b896c51c9d022f5933b3f9958" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the CR16 back end:</source>
          <target state="translated">これらの関数属性はCR16バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="eec1909818ce8c44d18b66d9f611b39270c8c989" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Epiphany back end:</source>
          <target state="translated">これらの関数属性は Epiphany バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="ff8d3405ae11a67438cd3ed6cb92d4bcf36611d0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32C back end:</source>
          <target state="translated">これらの関数属性はM32Cバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="d47de44c955eeba7615b17fd0bd7f27454a04ff3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32R/D back end:</source>
          <target state="translated">これらの関数属性は、M32R/Dバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="ed7b01cf6c9218a3fa99b80d586881bd94ea12ed" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MCORE back end:</source>
          <target state="translated">これらの関数属性は MCORE バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="226e80259699476cba4da72f29c0d2be0439d85d" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MIPS back end:</source>
          <target state="translated">これらの関数属性はMIPSバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="7edfb198d558bea136b268d07a4ee17096f4b111" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MSP430 back end:</source>
          <target state="translated">これらの機能属性は、MSP430バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="7afb37f2786a0500cde5b0e77a1405ec0aa689e9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MeP back end:</source>
          <target state="translated">これらの関数属性は、MePバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="823340689a226c514215ae7cf6199d5c7033ae04" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the NDS32 back end:</source>
          <target state="translated">これらの関数属性はNDS32バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="7264e105fd00f62eb30200660903a8276158683f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nios II back end:</source>
          <target state="translated">これらの関数属性は、Nios II バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="d367738aef5894acaadafa553c801d1b43d3e9d3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nvidia PTX back end:</source>
          <target state="translated">これらの機能属性は、Nvidia PTXバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="8128fd2ec01bae5154b0679102e4367fb3f53fc5" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the PowerPC back end:</source>
          <target state="translated">これらの関数属性は、PowerPCバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="923f5bd26a54897b08d5acdad9b09a52e975ce30" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RISC-V back end:</source>
          <target state="translated">これらの関数属性はRISC-Vバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="47e5203aed5d0b18481b945b5507d949e4d7c31f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RL78 back end:</source>
          <target state="translated">これらの関数属性はRL78バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="8f4c53e48bbca37bc1541d4a60d57426dc8a00e7" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RX back end:</source>
          <target state="translated">これらの関数属性は、RXバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="d7ce9850ed4dcd80e265a07962ae081b178c8abb" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the SPU back end:</source>
          <target state="translated">これらの関数属性はSPUバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="c4ade06aab9acf44e5ce57399ee7881faa6de0a6" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Visium back end:</source>
          <target state="translated">これらの関数属性はVisiumバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="ae2ef0b2bdfca9b1c67e94cbe7badc64e01b063f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Xstormy16 back end:</source>
          <target state="translated">これらの関数属性は、Xstormy16 のバックエンドでサポートされている。</target>
        </trans-unit>
        <trans-unit id="e7b7833e42af4f0fe80d613be09a87490ccd7b43" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the m68k back end:</source>
          <target state="translated">これらの関数属性は、m68kバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="fe7ac1f444547a0c0a07d6dfab0c75fe5199553c" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the x86 back end:</source>
          <target state="translated">これらの関数属性は、x86バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="5189be0ccd445175d7b77e932fb4808ff6d615fa" translate="yes" xml:space="preserve">
          <source>These function attributes are supported for ARM targets:</source>
          <target state="translated">これらの関数属性はARMターゲットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="bbd6ef1a2308a92983d4f92536fdde005890291f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on IA-64 targets:</source>
          <target state="translated">これらの関数属性はIA-64ターゲットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="f64b227810fa6c9b50983f03140d568f7d9fed74" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on MicroBlaze targets:</source>
          <target state="translated">これらの関数属性はMicroBlazeターゲットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="9585f4effc5a2f8970b020be9771782ca105dbb1" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the S/390:</source>
          <target state="translated">これらの機能属性は、S/390でサポートされています。</target>
        </trans-unit>
        <trans-unit id="18888f95dfd62b9fe90e4d6af61fe2ecdcb6ad4f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the SH family of processors:</source>
          <target state="translated">これらの関数属性は、SH ファミリのプロセッサでサポートされています。</target>
        </trans-unit>
        <trans-unit id="98428d8e4eba9c792163f590881b9a318e73170e" translate="yes" xml:space="preserve">
          <source>These functions are implemented in terms of the &amp;lsquo;</source>
          <target state="translated">これらの機能は、「</target>
        </trans-unit>
        <trans-unit id="8d57779f821090bd738e90d984c08a5bc5b3499b" translate="yes" xml:space="preserve">
          <source>These functions are intended to replace the legacy &amp;lsquo;</source>
          <target state="translated">これらの関数は、レガシーを置き換えることを目的としています '</target>
        </trans-unit>
        <trans-unit id="ad90f9504c295e2f97ffc9946ebca4f6b5d5ccf1" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="translated">これらの関数 &lt;var&gt;a&lt;/var&gt; 、 &lt;var&gt;b&lt;/var&gt; を使用して &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; とbを比較します。cond .psを実行し、結果の上半分または下半分を返します。例えば：</target>
        </trans-unit>
        <trans-unit id="03c7a748fe1ee1ae1b17cfc9b1186d6994642291" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if either result is &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if both results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="translated">これらの関数 &lt;var&gt;a&lt;/var&gt; 、 &lt;var&gt;b&lt;/var&gt; を使用して &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; とbを比較します。cond .psまたは &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 。 &lt;code&gt;any&lt;/code&gt; フォームが返さ &lt;code&gt;true&lt;/code&gt; いずれかの結果がある場合に &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;all&lt;/code&gt; フォームが返さ &lt;code&gt;true&lt;/code&gt; 両方の結果である場合は &lt;code&gt;true&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="c195ff99103a21f524d4637aac5069ea8a395ea9" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="translated">これらの関数 &lt;var&gt;a&lt;/var&gt; 、 &lt;var&gt;b&lt;/var&gt; を使用してaとbを比較し &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; を実行し、結果の上半分または下半分を返します。例えば：</target>
        </trans-unit>
        <trans-unit id="46c037085992dbec65501906e5e93cf40d6de82a" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; and return the result as a boolean value. For example:</source>
          <target state="translated">これらの関数 &lt;var&gt;a&lt;/var&gt; 、 &lt;var&gt;b&lt;/var&gt; を使用してaとbを比較し &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; または &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; を実行し、結果をブール値として返します。例えば：</target>
        </trans-unit>
        <trans-unit id="e664732594a1533360445b60577eaf62e517fa5e" translate="yes" xml:space="preserve">
          <source>These functions may be used to get information about the callers of a function.</source>
          <target state="translated">これらの関数は、関数の呼び出し元に関する情報を取得するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="1dfc3d7d206adff68ce67f88a57319430a6ab850" translate="yes" xml:space="preserve">
          <source>These functions use &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; to compare &lt;var&gt;a&lt;/var&gt; with &lt;var&gt;b&lt;/var&gt; and to compare &lt;var&gt;c&lt;/var&gt; with &lt;var&gt;d&lt;/var&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if any of the four results are &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if all four results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="translated">これらの関数は &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 使用します。cond .psまたは &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 比較すると &lt;var&gt;b&lt;/var&gt; と比較するために &lt;var&gt;c&lt;/var&gt; して &lt;var&gt;d&lt;/var&gt; 。 &lt;code&gt;any&lt;/code&gt; フォームが返さ &lt;code&gt;true&lt;/code&gt; 4つの結果のいずれかがある場合に &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;all&lt;/code&gt; フォームが返され &lt;code&gt;true&lt;/code&gt; 4件のすべての結果がある場合に &lt;code&gt;true&lt;/code&gt; 。例えば： &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="93f3cb76d903b1b5ffde931b05d3fa75fc2f5327" translate="yes" xml:space="preserve">
          <source>These hardware transactional memory intrinsics for x86 allow you to use memory transactions with RTM (Restricted Transactional Memory). This support is enabled with the</source>
          <target state="translated">x86用のこれらのハードウェア・トランザクション・メモリ・イントリニクスは、RTM (Restricted Transactional Memory)を使用してメモリ・トランザクションを使用できるようにします。このサポートは</target>
        </trans-unit>
        <trans-unit id="3b8547b042f5482e49423b8a94ba89797760897f" translate="yes" xml:space="preserve">
          <source>These identifiers are variables, not preprocessor macros, and may not be used to initialize &lt;code&gt;char&lt;/code&gt; arrays or be concatenated with string literals.</source>
          <target state="translated">これらの識別子は変数であり、プリプロセッサマクロではなく、 &lt;code&gt;char&lt;/code&gt; 配列の初期化や文字列リテラルとの連結には使用できません。</target>
        </trans-unit>
        <trans-unit id="d7ada7b6e3845c0a5e68e19752115e91ad7e714e" translate="yes" xml:space="preserve">
          <source>These issues were corrected in</source>
          <target state="translated">これらの問題は</target>
        </trans-unit>
        <trans-unit id="9b9701e15c9d94aa04294acbc1a1a03ddc6872e2" translate="yes" xml:space="preserve">
          <source>These machine-independent options control the interface conventions used in code generation.</source>
          <target state="translated">これらのマシンに依存しないオプションは、コード生成に使用されるインターフェイスの規約を制御します。</target>
        </trans-unit>
        <trans-unit id="1408af6170149b7254d4dd6bcdcfd495ec7436ce" translate="yes" xml:space="preserve">
          <source>These mangling issues were fixed in</source>
          <target state="translated">これらのマングリングの問題は、以下で修正されました。</target>
        </trans-unit>
        <trans-unit id="07b49ceeb21cede5a3a2711e37a7de019bfde35f" translate="yes" xml:space="preserve">
          <source>These memory models are formally defined in Appendix D of the SPARC-V9 architecture manual, as set in the processor&amp;rsquo;s &lt;code&gt;PSTATE.MM&lt;/code&gt; field.</source>
          <target state="translated">これらのメモリモデルは、SPARC-V9アーキテクチャマニュアルの付録Dで正式に定義されており、プロセッサの &lt;code&gt;PSTATE.MM&lt;/code&gt; フィールドに設定されています。</target>
        </trans-unit>
        <trans-unit id="b1c28027a49e0f9f937405f5f5d9848e5c4e1880" translate="yes" xml:space="preserve">
          <source>These modifiers generate this assembler code:</source>
          <target state="translated">これらの修飾子は、このアセンブラコードを生成します。</target>
        </trans-unit>
        <trans-unit id="743e02542ccafa4975400ec872a7ad2395932b78" translate="yes" xml:space="preserve">
          <source>These options (&amp;lsquo;</source>
          <target state="translated">これらのオプション（ '</target>
        </trans-unit>
        <trans-unit id="4958c6c5d677addc8f58eab0c0d2cf3562ddc1ad" translate="yes" xml:space="preserve">
          <source>These options are defined for AArch64 implementations:</source>
          <target state="translated">これらのオプションは、AArch64 の実装用に定義されています。</target>
        </trans-unit>
        <trans-unit id="48d92fc742af2bfa615c74329a584a34db9bd186" translate="yes" xml:space="preserve">
          <source>These options are defined for AVR implementations:</source>
          <target state="translated">これらのオプションはAVR実装用に定義されています。</target>
        </trans-unit>
        <trans-unit id="b2e06ccfcce04ef8518c59faf9fdd99422ee95ce" translate="yes" xml:space="preserve">
          <source>These options are defined for NDS32 implementations:</source>
          <target state="translated">これらのオプションはNDS32の実装用に定義されています。</target>
        </trans-unit>
        <trans-unit id="5d910c773d7a92c5968f91520cb1c96e846ae694" translate="yes" xml:space="preserve">
          <source>These options are defined for Nvidia PTX:</source>
          <target state="translated">これらのオプションはNvidia PTX用に定義されています。</target>
        </trans-unit>
        <trans-unit id="70a11512edb73659010487af7574c61b869ed8dd" translate="yes" xml:space="preserve">
          <source>These options are defined for OpenRISC:</source>
          <target state="translated">これらのオプションはOpenRISC用に定義されています。</target>
        </trans-unit>
        <trans-unit id="c280d854c3b143f60be7e0eaa4e7170900086fe5" translate="yes" xml:space="preserve">
          <source>These options are defined for Score implementations:</source>
          <target state="translated">これらのオプションは、Score の実装で定義されています。</target>
        </trans-unit>
        <trans-unit id="3fb4c45c0c5f292728f019e5710497a0ec8817f3" translate="yes" xml:space="preserve">
          <source>These options are defined for Xstormy16:</source>
          <target state="translated">これらのオプションは、Xstormy16 で定義されています。</target>
        </trans-unit>
        <trans-unit id="8b09b81649730921d2e9ab3de0a2c88ec62a4975" translate="yes" xml:space="preserve">
          <source>These options are defined for all architectures running the Darwin operating system.</source>
          <target state="translated">これらのオプションは、Darwin オペレーティングシステムを実行するすべてのアーキテクチャで定義されています。</target>
        </trans-unit>
        <trans-unit id="7cb3b867f983940ea2e4ebd67efa329a40f483ce" translate="yes" xml:space="preserve">
          <source>These options are defined for the MMIX:</source>
          <target state="translated">これらのオプションはMMIX用に定義されています。</target>
        </trans-unit>
        <trans-unit id="385fe3117f02cef23e8d723690c0cfc308b93e2c" translate="yes" xml:space="preserve">
          <source>These options are defined for the MSP430:</source>
          <target state="translated">これらのオプションはMSP430で定義されています。</target>
        </trans-unit>
        <trans-unit id="adcca40803ff77f8885d53e3bb9902253e5f5f3e" translate="yes" xml:space="preserve">
          <source>These options are defined for the PDP-11:</source>
          <target state="translated">これらのオプションはPDP-11で定義されています。</target>
        </trans-unit>
        <trans-unit id="9bfa23d8fe1cfc039288a92db83209397de4a2aa" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the AMD GCN port.</source>
          <target state="translated">これらのオプションは、AMD GCNポート専用に定義されています。</target>
        </trans-unit>
        <trans-unit id="08c86a5f185d6c276d710a46803063b57baac6b5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CR16 ports.</source>
          <target state="translated">これらのオプションは、CR16 ポート専用に定義されています。</target>
        </trans-unit>
        <trans-unit id="bbab2a1744111610f4ef1fc49ca09af76e7d1a32" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CRIS ports.</source>
          <target state="translated">これらのオプションは、CRIS ポート専用に定義されています。</target>
        </trans-unit>
        <trans-unit id="9926932fa2a7f92eb437e1b2ac02cd6adfeca6d5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FR30 port.</source>
          <target state="translated">これらのオプションは FR30 ポート専用に定義されています。</target>
        </trans-unit>
        <trans-unit id="3dab4ff68a4f656f1c031b134a3ea5a7f3fcf21b" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FT32 port.</source>
          <target state="translated">これらのオプションは、FT32 ポート専用に定義されています。</target>
        </trans-unit>
        <trans-unit id="75c959329e4528f6f7066c03da92ac9a3ae209b8" translate="yes" xml:space="preserve">
          <source>These options are passed down to the linker. They are defined for compatibility with Diab.</source>
          <target state="translated">これらのオプションはリンカに渡されます。これらはDiabとの互換性のために定義されています。</target>
        </trans-unit>
        <trans-unit id="514cb6ef588bccc0cfd12c2a6ee53c62e3980343" translate="yes" xml:space="preserve">
          <source>These options are passed to the Darwin linker. The Darwin linker man page describes them in detail.</source>
          <target state="translated">これらのオプションは、Darwin リンカに渡されます。Darwin リンカのマニュアルページで詳細に説明されています。</target>
        </trans-unit>
        <trans-unit id="921e998e0a7514666b6cd58d10b556dced0e17ae" translate="yes" xml:space="preserve">
          <source>These options are similar to</source>
          <target state="translated">これらのオプションは次のようなものです。</target>
        </trans-unit>
        <trans-unit id="c15cb110a025cb053a49b0cc23a8ae49630d084e" translate="yes" xml:space="preserve">
          <source>These options are supported for Xtensa targets:</source>
          <target state="translated">これらのオプションはXtensaターゲットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="024672ba12f6533c6267ee5ffbe7b18b0036fae5" translate="yes" xml:space="preserve">
          <source>These options come into play when the compiler links object files into an executable output file. They are meaningless if the compiler is not doing a link step.</source>
          <target state="translated">これらのオプションは、コンパイラがオブジェクト・ファイルを実行可能な出力ファイルにリンクするときに使用されます。コンパイラがリンク・ステップを実行していない場合、これらのオプションは意味を持ちません。</target>
        </trans-unit>
        <trans-unit id="4133c0873f5f47fa3d2f753863bb9a83e1789d05" translate="yes" xml:space="preserve">
          <source>These options control the C preprocessor, which is run on each C source file before actual compilation.</source>
          <target state="translated">これらのオプションは、実際にコンパイルする前に各Cソースファイルで実行されるCプリプロセッサを制御します。</target>
        </trans-unit>
        <trans-unit id="5ef76ab842e5d74de09c81a688676470bc03ede7" translate="yes" xml:space="preserve">
          <source>These options control the encoding of the special not-a-number (NaN) IEEE 754 floating-point data.</source>
          <target state="translated">これらのオプションは、特殊なNot-a-number (NaN)IEEE 754浮動小数点データのエンコーディングを制御します。</target>
        </trans-unit>
        <trans-unit id="b6d05ca58952f18a481361248697cafe54bd4e24" translate="yes" xml:space="preserve">
          <source>These options control the treatment of literal pools. The default is</source>
          <target state="translated">これらのオプションは、リテラルプールの処理を制御します。デフォルトは</target>
        </trans-unit>
        <trans-unit id="63f8686ec125e23f83695f3f62c70b1f7e4905ad" translate="yes" xml:space="preserve">
          <source>These options control the treatment of the special not-a-number (NaN) IEEE 754 floating-point data with the &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; machine instructions.</source>
          <target state="translated">これらのオプションは、 &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; 使用した特殊な非数（NaN）IEEE 754浮動小数点データの処理を制御します。&lt;i&gt;fmt&lt;/i&gt;と &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; マシン命令。</target>
        </trans-unit>
        <trans-unit id="fe30970c8506c0b34e204983d37e0e48b0b22605" translate="yes" xml:space="preserve">
          <source>These options control various sorts of optimizations.</source>
          <target state="translated">これらのオプションは、さまざまな種類の最適化を制御します。</target>
        </trans-unit>
        <trans-unit id="8077ddc9c44325d74d2e32e67e952882010bc964" translate="yes" xml:space="preserve">
          <source>These options control whether a bit-field is signed or unsigned, when the declaration does not use either &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;. By default, such a bit-field is signed, because this is consistent: the basic integer types such as &lt;code&gt;int&lt;/code&gt; are signed types.</source>
          <target state="translated">これらのオプションは、宣言で &lt;code&gt;signed&lt;/code&gt; または &lt;code&gt;unsigned&lt;/code&gt; のいずれも使用されていない場合に、ビットフィールドが符号付きか符号なしかを制御します。これは一貫性があるため、デフォルトでは、このようなビット・フィールドは、署名されている次のような基本的な整数型 &lt;code&gt;int&lt;/code&gt; は型が署名されています。</target>
        </trans-unit>
        <trans-unit id="04984b17ce3993112173c90b978bdade9a561d21" translate="yes" xml:space="preserve">
          <source>These options control which form of branches will be generated. The default is</source>
          <target state="translated">これらのオプションは、どの形式のブランチを生成するかを制御します。デフォルトは</target>
        </trans-unit>
        <trans-unit id="75acf55e945580c3df0ebbfbfe506d046bc6e85c" translate="yes" xml:space="preserve">
          <source>These options enable GCC to use these extended instructions in generated code, even without</source>
          <target state="translated">これらのオプションを使用すると、GCC は生成されたコードでこれらの拡張命令を使用することができます。</target>
        </trans-unit>
        <trans-unit id="e7fd9ac7bed816cccc6942a8d8998c84e682fcba" translate="yes" xml:space="preserve">
          <source>These options enable dumping after five rounds of instruction splitting.</source>
          <target state="translated">これらのオプションは、5ラウンドの命令分割後にダンピングを可能にします。</target>
        </trans-unit>
        <trans-unit id="b5b2a58223d63058f35e9cfc3fe268fbe52e4e8c" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position independent code.</source>
          <target state="translated">これらのオプションは、GCCが位置に依存しないコードを生成している場合を除いては効果がありません。</target>
        </trans-unit>
        <trans-unit id="0d11fb15204ab5a9c7be14b9ed2aaeffe527ddd6" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position-independent code.</source>
          <target state="translated">これらのオプションは、GCCが位置に依存しないコードを生成している場合を除いては効果がありません。</target>
        </trans-unit>
        <trans-unit id="32e82c10f4ef0470986d8f101c75c3deb8c3bb8b" translate="yes" xml:space="preserve">
          <source>These options specify directories to search for header files, for libraries and for parts of the compiler:</source>
          <target state="translated">これらのオプションは、ヘッダファイル、ライブラリ、およびコンパイラの一部を検索するディレクトリを指定します。</target>
        </trans-unit>
        <trans-unit id="e76a02704dc0e3839f8323b052aabfba6ae282f0" translate="yes" xml:space="preserve">
          <source>These options tell the compiler where to place functions and data that do not have one of the &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;section&lt;/code&gt; attributes. Possible values are &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;any&lt;/code&gt;. The first three behave like the corresponding attribute. The fourth possible value - &lt;code&gt;any&lt;/code&gt; - is the default. It leaves placement entirely up to the linker script and how it assigns the standard sections (&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, etc) to the memory regions.</source>
          <target state="translated">これらのオプションは、 &lt;code&gt;lower&lt;/code&gt; 、 &lt;code&gt;upper&lt;/code&gt; 、または &lt;code&gt;section&lt;/code&gt; 属性の &lt;code&gt;either&lt;/code&gt; 持たない関数とデータを配置する場所をコンパイラーに指示します。可能な値は &lt;code&gt;lower&lt;/code&gt; 、 &lt;code&gt;upper&lt;/code&gt; 、 &lt;code&gt;either&lt;/code&gt; 、または &lt;code&gt;any&lt;/code&gt; 。最初の3つは、対応する属性のように動作します。第4の可能な値- &lt;code&gt;any&lt;/code&gt; -デフォルトです。配置は完全にリンカースクリプトと、標準セクション（ &lt;code&gt;.text&lt;/code&gt; 、 &lt;code&gt;.data&lt;/code&gt; など）をメモリ領域に割り当てる方法に任されています。</target>
        </trans-unit>
        <trans-unit id="e0b73ff2eada76f8ac9ebd9981af9354d96c99aa" translate="yes" xml:space="preserve">
          <source>These pragmas maintain a stack of the current target and optimization options. It is intended for include files where you temporarily want to switch to using a different &amp;lsquo;</source>
          <target state="translated">これらのプラグマは、現在のターゲットと最適化オプションのスタックを維持します。これは、一時的に別の 'を使用するように切り替えたいインクルードファイルを対象としています</target>
        </trans-unit>
        <trans-unit id="603f3636cf78ad4d753498b11957f65672ebe2cb" translate="yes" xml:space="preserve">
          <source>These problems are perhaps regrettable, but we don&amp;rsquo;t know any practical way around them.</source>
          <target state="translated">これらの問題はおそらく残念なことですが、実際的な方法はわかりません。</target>
        </trans-unit>
        <trans-unit id="65b9fcf5c8f8750409b0be6384fa9bc28cb10f52" translate="yes" xml:space="preserve">
          <source>These programs work properly with GNU C++ if &lt;code&gt;__STDC__&lt;/code&gt; is defined. They would not work otherwise.</source>
          <target state="translated">&lt;code&gt;__STDC__&lt;/code&gt; が定義されている場合、これらのプログラムはGNU C ++で正しく動作します。それ以外の場合は機能しません。</target>
        </trans-unit>
        <trans-unit id="8668b2099e0b980048c9ff0d8e19c4e25e485197" translate="yes" xml:space="preserve">
          <source>These pseudo types are not defined by GCC, they are simply a notational convenience used in this manual.</source>
          <target state="translated">これらの疑似型はGCCで定義されているものではなく、このマニュアルで使用されている表記上の便宜を図ったものです。</target>
        </trans-unit>
        <trans-unit id="f405633d47d5e6bb41585f2bd9ddbfca800a1d10" translate="yes" xml:space="preserve">
          <source>These restrictions exist because the storage order attribute is lost when the address of a scalar or the address of an array with scalar component is taken, so storing indirectly through this address generally does not work. The second case is nevertheless allowed to be able to perform a block copy from or to the array.</source>
          <target state="translated">これらの制限が存在するのは,スカラのアドレスやスカラ成分を持つ配列のアドレスを取ると,格納順序属性が失われるため,このアドレスを介して間接的に格納することは一般的には機能しないからです.第二のケースは、それにもかかわらず、配列から、または配列へのブロックコピーを実行することができるように許可されています。</target>
        </trans-unit>
        <trans-unit id="617ec4855cb2c9a651bfd784a1ec34d6b14a3c49" translate="yes" xml:space="preserve">
          <source>These switches are supported in addition to the above on Solaris 2:</source>
          <target state="translated">これらのスイッチは、上記に加えてSolaris 2でもサポートされています。</target>
        </trans-unit>
        <trans-unit id="bc8a75785b95174e69ab84ca725881f92373e1de" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default for 32-bit Bionic C library. A size of 128 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;__float128&lt;/code&gt; type. This is the default for 64-bit Bionic C library.</source>
          <target state="translated">これらのスイッチは、 &lt;code&gt;long double&lt;/code&gt; タイプのサイズを制御します。64ビットのサイズを作る &lt;code&gt;long double&lt;/code&gt; のタイプは、同等の &lt;code&gt;double&lt;/code&gt; タイプ。これは、32ビットのBionic Cライブラリのデフォルトです。128ビットのサイズは、 &lt;code&gt;long double&lt;/code&gt; 型を &lt;code&gt;__float128&lt;/code&gt; 型と同等にします。これは、64ビットのBionic Cライブラリのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="ee4c72bd4a51cef29e53fde4cebb62a0cdc42ecb" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default.</source>
          <target state="translated">これらのスイッチは、 &lt;code&gt;long double&lt;/code&gt; タイプのサイズを制御します。64ビットのサイズを作る &lt;code&gt;long double&lt;/code&gt; のタイプは、同等の &lt;code&gt;double&lt;/code&gt; タイプ。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="cfe1fb390a0357110cca04fd8837b1f7aac6050f" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. The x86-32 application binary interface specifies the size to be 96 bits, so</source>
          <target state="translated">これらのスイッチは、 &lt;code&gt;long double&lt;/code&gt; タイプのサイズを制御します。x86-32アプリケーションバイナリインターフェイスは、サイズを96ビットに指定しているため、</target>
        </trans-unit>
        <trans-unit id="c7348ef4aa27c2888870c0a37711f33df4fe6ef4" translate="yes" xml:space="preserve">
          <source>These switches enable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow!, enhanced 3DNow!, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, or CLDEMOTE extended instruction sets. Each has a corresponding</source>
          <target state="translated">これらのスイッチは、MMX、SSE、SSE2、SSE3、SSE3、SSE4、SSE4A、SSE4.2、avx、avx2、avx512f、avx512pf、avx512er、avx512cd、avx512vl、avx512bw、avx512dq、avx512ifma、avx512vbmi、sha、aes、pclmul、clflushopt.CLWB、FSGSBASE、PTWRITE、RDRND、F16C、FMA、PCONFIG、WBNOINVD、FMA4、PREFETCHW、RDPID、PREFETCHWT1、RDSEED、SGX、XOP、LWP、3DNow!,強化された3DNow! popcnt,abm,adx,bmi,bmi2,lzcnt,fxsr,xsave,xsaveopt,xsavec,xsaves,rtm,hle,tbm,mwaitx,clzero,pku,avx512vbmi2,gfni,vaes,waitpkg.VPCLMULQDQ、AVX512BITALG、MOVDIRI、MOVDIR64B、AVX512VPOPCNTDQ、AVX5124FMAPS、AVX512VNNI、AVX5124VNNIW、またはCLDEMOTE拡張命令セット。それぞれに対応する</target>
        </trans-unit>
        <trans-unit id="cf9495d6f00684499ee4c826615f4071694dd898" translate="yes" xml:space="preserve">
          <source>These types can be used to define 128-bit variables. The built-in functions listed in the following section can be used on these variables to generate the vector operations.</source>
          <target state="translated">これらの型は、128 ビットの変数を定義するために使用できます。次のセクションにリストアップされている組み込み関数は、これらの変数でベクトル演算を生成するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="e668693b38e6c57f5102ee95a3e05249f7244a77" translate="yes" xml:space="preserve">
          <source>These usages are only permitted when they are not ambiguous.</source>
          <target state="translated">これらの用法は、曖昧さがない場合にのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="5f38a05c071c60c51e986980de83378738afc905" translate="yes" xml:space="preserve">
          <source>These variable attributes are available for H8/300 targets:</source>
          <target state="translated">これらの変数属性は、H8/300ターゲットで利用可能です。</target>
        </trans-unit>
        <trans-unit id="241d1accd4905e80f5a34fe3dc64f1b3deee21e2" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the Nvidia PTX back end:</source>
          <target state="translated">これらの変数属性は、Nvidia PTXバックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="f806a524d1696f92091d57f9cf53c9146e9a15bf" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the V850 back end:</source>
          <target state="translated">これらの変数属性は V850 バックエンドでサポートされています。</target>
        </trans-unit>
        <trans-unit id="b949d9fe4918e4b913002b1484d0c6602fa25eb3" translate="yes" xml:space="preserve">
          <source>These warnings are harmless and can be safely ignored.</source>
          <target state="translated">これらの警告は無害であり、安全に無視することができます。</target>
        </trans-unit>
        <trans-unit id="e451fc6c4b4d61a1351149a72dc14d1a6505cb95" translate="yes" xml:space="preserve">
          <source>These warnings are made optional because GCC may not be able to determine when the code is correct in spite of appearing to have an error. Here is one example of how this can happen:</source>
          <target state="translated">これらの警告はオプションになっていますが、これは、GCC がエラーがあるように見えても、コードが正しいかどうかを判断できない可能性があるためです。これがどのようにして起こるかの一例を示します。</target>
        </trans-unit>
        <trans-unit id="94e18fe51f3f4e2e5c1a093907e436f1a7eab080" translate="yes" xml:space="preserve">
          <source>These warnings are only possible in optimizing compilation, because otherwise GCC does not keep track of the state of variables.</source>
          <target state="translated">これらの警告はコンパイルを最適化する際にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="e773c8b72ecdbdff1f92adf539e992bd54211f66" translate="yes" xml:space="preserve">
          <source>These warnings occur for individual uninitialized or clobbered elements of structure, union or array variables as well as for variables that are uninitialized or clobbered as a whole. They do not occur for variables or elements declared &lt;code&gt;volatile&lt;/code&gt;. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depends on the precise optimization options and version of GCC used.</source>
          <target state="translated">これらの警告は、構造化変数、共用体変数、配列変数の初期化されていない、または破壊された個々の要素、および全体として初期化されていない、または破壊された変数に対して発生します。 &lt;code&gt;volatile&lt;/code&gt; と宣言された変数または要素では発生しません。これらの警告は最適化に依存するため、警告が出される正確な変数または要素は、使用されるGCCの正確な最適化オプションとバージョンに依存します。</target>
        </trans-unit>
        <trans-unit id="54f2498a22474b067e488cbcf73df92835b4dcbc" translate="yes" xml:space="preserve">
          <source>Things we think are right, but some others disagree.</source>
          <target state="translated">自分たちが正しいと思っていることでも、他の人が反対していることもある。</target>
        </trans-unit>
        <trans-unit id="1997b0ca2cbaa31341990ddcffc48330394de3bf" translate="yes" xml:space="preserve">
          <source>Things will disappear from G++.</source>
          <target state="translated">G++からモノが消える。</target>
        </trans-unit>
        <trans-unit id="c779d1bd661026f38150c16245e1a66cae977330" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes one input, which is internally popped, and produces two outputs.</source>
          <target state="translated">この &lt;code&gt;asm&lt;/code&gt; は、内部的にポップされる1つの入力を受け取り、2つの出力を生成します。</target>
        </trans-unit>
        <trans-unit id="7ea744591db59b72a57a82ebc78f06c0a9beaefd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes two inputs, which are popped by the &lt;code&gt;fyl2xp1&lt;/code&gt; opcode, and replaces them with one output. The &lt;code&gt;st(1)&lt;/code&gt; clobber is necessary for the compiler to know that &lt;code&gt;fyl2xp1&lt;/code&gt; pops both inputs.</source>
          <target state="translated">この &lt;code&gt;asm&lt;/code&gt; は、 &lt;code&gt;fyl2xp1&lt;/code&gt; オペコードによってポップされる2つの入力を受け取り、それらを1つの出力に置き換えます。 &lt;code&gt;st(1)&lt;/code&gt; コンパイラがいることを知っているためクロバーが必要です &lt;code&gt;fyl2xp1&lt;/code&gt; は、両方の入力をポップ。</target>
        </trans-unit>
        <trans-unit id="49059cf2744a33f2c89b82b703d94b0c5663c6e8" translate="yes" xml:space="preserve">
          <source>This IA-64 HP-UX attribute, attached to a global variable or function, renames a symbol to contain a version string, thus allowing for function level versioning. HP-UX system header files may use function level versioning for some system calls.</source>
          <target state="translated">グローバル変数または関数にアタッチされたこのIA-64 HP-UX属性は、バージョン文字列を含むシンボルの名前を変更し、関数レベルのバージョニングを可能にします。HP-UX システム・ヘッダ・ファイルでは、一部のシステム・コールで関数レベルのバージョニングを使用することがあります。</target>
        </trans-unit>
        <trans-unit id="241afcfcf7826d27f6d46a14ffc5e97907ebd792" translate="yes" xml:space="preserve">
          <source>This ISA is implemented by the minimal AVR core and supported for assembler only. &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt;, &lt;code&gt;attiny12&lt;/code&gt;, &lt;code&gt;attiny15&lt;/code&gt;, &lt;code&gt;attiny28&lt;/code&gt;, &lt;code&gt;at90s1200&lt;/code&gt;.</source>
          <target state="translated">このISAは最小限のAVRコアによって実装され、アセンブラーでのみサポートされます。 &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt; 、 &lt;code&gt;attiny12&lt;/code&gt; 、 &lt;code&gt;attiny15&lt;/code&gt; 、 &lt;code&gt;attiny28&lt;/code&gt; 、 &lt;code&gt;at90s1200&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7707ff43d31f77dd6414b616a64487e73ac2f610" translate="yes" xml:space="preserve">
          <source>This RX attribute is similar to the &lt;code&gt;interrupt&lt;/code&gt; attribute, including its parameters, but does not make the function an interrupt-handler type function (i.e. it retains the normal C function calling ABI). See the &lt;code&gt;interrupt&lt;/code&gt; attribute for a description of its arguments.</source>
          <target state="translated">このRX属性は、パラメーターを含め、 &lt;code&gt;interrupt&lt;/code&gt; 属性に似ていますが、関数を割り込みハンドラータイプの関数にしません（つまり、通常のC関数を呼び出してABIを保持します）。引数の説明については、 &lt;code&gt;interrupt&lt;/code&gt; 属性を参照してください。</target>
        </trans-unit>
        <trans-unit id="5e3ace91b836f39e130a69b032cbc00b174ef7e1" translate="yes" xml:space="preserve">
          <source>This allows classes to dynamically register methods (by adding them to the class using &lt;code&gt;class_addMethod&lt;/code&gt;) when they are first called. To do so, a class should implement &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or, depending on the case, &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) and have it recognize the selectors of methods that can be registered dynamically at runtime, register them, and return &lt;code&gt;YES&lt;/code&gt;. It should return &lt;code&gt;NO&lt;/code&gt; for methods that it does not dynamically registered at runtime.</source>
          <target state="translated">これにより、クラスは最初に呼び出されたときに（ &lt;code&gt;class_addMethod&lt;/code&gt; を使用してクラスにメソッドを追加することにより）メソッドを動的に登録できます。そのためには、クラスは &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (または場合によっては &lt;code&gt;+resolveClassMethod:&lt;/code&gt; ：）を実装し、実行時に動的に登録できるメソッドのセレクターを認識して登録し、 &lt;code&gt;YES&lt;/code&gt; を返す必要があります。実行時に動的に登録されないメソッドに対しては、 &lt;code&gt;NO&lt;/code&gt; を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="08bbed031d0bdc80dfc8c12fb03bbad77feeb085" translate="yes" xml:space="preserve">
          <source>This also works with</source>
          <target state="translated">これは、次のような場合にも動作します。</target>
        </trans-unit>
        <trans-unit id="70958ab1135f4d3b760976f6ea18b5ad5e6cd4ca" translate="yes" xml:space="preserve">
          <source>This assumes that &lt;code&gt;x&lt;/code&gt; is an array of pointers to functions; the type described is that of the values of the functions.</source>
          <target state="translated">これは、 &lt;code&gt;x&lt;/code&gt; が関数へのポインターの配列であることを前提としています。記述されているタイプは、関数の値のタイプです。</target>
        </trans-unit>
        <trans-unit id="0e587899e8439ab096a171178bf777e82d34203e" translate="yes" xml:space="preserve">
          <source>This attribute adds stack protection code to the function if flags</source>
          <target state="translated">この属性は、フラグが</target>
        </trans-unit>
        <trans-unit id="ffa1a8a02f8237f39f16f9e3141f209d4e6ecc0a" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. It can be applied to variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;) as well as functions.</source>
          <target state="translated">この属性は、それが関連付けられている宣言のリンケージに影響します。関数だけでなく、変数（「&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;共通変数属性&lt;/a&gt;」を参照）や型（「&lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;共通型属性&lt;/a&gt;」を参照）にも適用できます。</target>
        </trans-unit>
        <trans-unit id="b70510133f65523747a3309a22314ce44be57270" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. The &lt;code&gt;visibility&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">この属性は、それが関連付けられている宣言のリンケージに影響します。 &lt;code&gt;visibility&lt;/code&gt; 属性はで説明された&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;共通機能の属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2662beeb7225f89f9b3b830e684251c6d287e4ea" translate="yes" xml:space="preserve">
          <source>This attribute allows one to mark secure-code functions that are callable from normal mode. The location of the secure call function into the &lt;code&gt;sjli&lt;/code&gt; table needs to be passed as argument.</source>
          <target state="translated">この属性により、通常モードから呼び出し可能なセキュアコード関数をマークできます。セキュアな呼び出し関数の &lt;code&gt;sjli&lt;/code&gt; テーブルへの場所は、引数として渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="f72283dc6a14cbd57d6d6c7ceadcc8425ca927f4" translate="yes" xml:space="preserve">
          <source>This attribute allows the compiler to construct the requisite function declaration, while allowing the body of the function to be assembly code. The specified function will not have prologue/epilogue sequences generated by the compiler. Only basic &lt;code&gt;asm&lt;/code&gt; statements can safely be included in naked functions (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;). While using extended &lt;code&gt;asm&lt;/code&gt; or a mixture of basic &lt;code&gt;asm&lt;/code&gt; and C code may appear to work, they cannot be depended upon to work reliably and are not supported.</source>
          <target state="translated">この属性を使用すると、コンパイラーは必要な関数宣言を作成でき、関数の本体はアセンブリコードにすることができます。指定された関数には、コンパイラーによって生成されたプロローグ/エピローグシーケンスがありません。ネイキッド関数に安全に含めることができるのは、基本的な &lt;code&gt;asm&lt;/code&gt; ステートメントのみです（&lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;基本的なAsmを&lt;/a&gt;参照）。拡張 &lt;code&gt;asm&lt;/code&gt; または基本的な &lt;code&gt;asm&lt;/code&gt; とCコードの混合を使用すると動作するように見えるかもしれませんが、確実に動作するように依存することはできず、サポートされていません。</target>
        </trans-unit>
        <trans-unit id="2da8d71f1e17b2c08ea57936e512e0f37aa70a9f" translate="yes" xml:space="preserve">
          <source>This attribute applies only to the particular namespace body, not to other definitions of the same namespace; it is equivalent to using &amp;lsquo;</source>
          <target state="translated">この属性は特定の名前空間本体にのみ適用され、同じ名前空間の他の定義には適用されません。これは「</target>
        </trans-unit>
        <trans-unit id="1a6b9ade066129340d2b93cc21dd28696f004a1b" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to assume the called function is close enough to use the normal calling convention, overriding the</source>
          <target state="translated">この属性を使用すると、コンパイラは呼び出された関数が通常の呼び出し規則を使用するのに十分に近いと仮定して</target>
        </trans-unit>
        <trans-unit id="02e0a7b8749b1724d33369b4ea037bd0b071529e" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to emit instructions to disable interrupts for the duration of the given function.</source>
          <target state="translated">この属性は、コンパイラが与えられた関数の間、割り込みを無効にする命令を出すようにします。</target>
        </trans-unit>
        <trans-unit id="b8e219dd9b57732e157d707be34c1c904f638a7d" translate="yes" xml:space="preserve">
          <source>This attribute corresponds to the</source>
          <target state="translated">この属性は</target>
        </trans-unit>
        <trans-unit id="0da402fe02e024fb03bb5a3ac4167c5cbafc19db" translate="yes" xml:space="preserve">
          <source>This attribute enables creation of one or more function versions that can process multiple arguments using SIMD instructions from a single invocation. Specifying this attribute allows compiler to assume that such versions are available at link time (provided in the same or another translation unit). Generated versions are target-dependent and described in the corresponding Vector ABI document. For x86_64 target this document can be found &lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">この属性により、1回の呼び出しでSIMD命令を使用して複数の引数を処理できる1つ以上の関数バージョンを作成できます。この属性を指定すると、コンパイラーはそのようなバージョンがリンク時に使用可能であると想定できます（同じまたは別の翻訳単位で提供されます）。生成されたバージョンはターゲットに依存し、対応するベクターABIドキュメントに記載されています。x86_64ターゲットの場合、このドキュメントは&lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;ここにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="660859d290d769bde079f1e74652268ebbc1b062" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, that is an entry point that can be invoked from the host via the HSA runtime library. By default functions are only callable only from other GCN functions.</source>
          <target state="translated">この属性は、対応する関数がカーネル関数としてコンパイルされるべきであること、つまり、HSAランタイムライブラリを介してホストから呼び出すことができるエントリーポイントであることを示します。デフォルトでは、関数は他のGCN関数からのみ呼び出し可能です。</target>
        </trans-unit>
        <trans-unit id="f2fad3c190739d8e505c7ea63fef5f7267f258de" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, which can be invoked from the host via the CUDA RT library. By default functions are only callable only from other PTX functions.</source>
          <target state="translated">この属性は、対応する関数がカーネル関数としてコンパイルされ、CUDA RT ライブラリを介してホストから呼び出すことができることを示します。デフォルトでは、関数は他のPTX関数からのみ呼び出し可能です。</target>
        </trans-unit>
        <trans-unit id="57e17cc8aacf2250a0265d50a2b47adfbfe456c6" translate="yes" xml:space="preserve">
          <source>This attribute is also accepted in C, but it is unnecessary because C does not have constructors or destructors.</source>
          <target state="translated">この属性はC言語でも受け入れられていますが、C言語にはコンストラクタやデストラクタがないので不要です。</target>
        </trans-unit>
        <trans-unit id="503a85109e1de0e8ce0564d361fa1038358344dc" translate="yes" xml:space="preserve">
          <source>This attribute is appropriate for types which just represent a value, such as &lt;code&gt;std::string&lt;/code&gt;; it is not appropriate for types which control a resource, such as &lt;code&gt;std::lock_guard&lt;/code&gt;.</source>
          <target state="translated">この属性は、 &lt;code&gt;std::string&lt;/code&gt; など、値を表すだけのタイプに適しています。 &lt;code&gt;std::lock_guard&lt;/code&gt; などのリソースを制御するタイプには適していません。</target>
        </trans-unit>
        <trans-unit id="ba2d583dcd0ca68ace008c0dc9fbd8ec6f90be8f" translate="yes" xml:space="preserve">
          <source>This attribute is ignored for R8C target.</source>
          <target state="translated">この属性はR8Cターゲットでは無視されます。</target>
        </trans-unit>
        <trans-unit id="34e03794349850af7bdeb66f9a9d6ef490386eec" translate="yes" xml:space="preserve">
          <source>This attribute is implicitly applied to any function named &lt;code&gt;main&lt;/code&gt;, using default parameters.</source>
          <target state="translated">この属性は、デフォルトのパラメーターを使用して、 &lt;code&gt;main&lt;/code&gt; という名前の関数に暗黙的に適用されます。</target>
        </trans-unit>
        <trans-unit id="d9346f70ea23c21af36c756ae2b79002b57ffa81" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalar types. In function declarations the attribute applies to the function return type.</source>
          <target state="translated">この属性は、積分型と浮動スカラ型にのみ適用されます。関数宣言では、この属性は関数の戻り値の型に適用されます。</target>
        </trans-unit>
        <trans-unit id="4d7f394253f35fa8db5ca6f449a44ff4b56ba334" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct.</source>
          <target state="translated">この属性は積分スカラと浮動スカラにのみ適用されますが、配列、ポインタ、および関数の戻り値はこの構造体と組み合わせて使用することができます。</target>
        </trans-unit>
        <trans-unit id="7e555249b47de74e90649b8eebd9bb76b767b366" translate="yes" xml:space="preserve">
          <source>This attribute is supported only for targets that use a uniform default scalar storage order (fortunately, most of them), i.e. targets that store the scalars either all in big-endian or all in little-endian.</source>
          <target state="translated">この属性は、統一されたデフォルトのスカラの格納順序を使用するターゲット(幸いにも、ほとんどのターゲット)、すなわち、スカラをすべてビッグエンディアンまたはリトルエンディアンのいずれかで格納するターゲットに対してのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="0c3dbf2eda48cb59aebda306917b7f78672e9f61" translate="yes" xml:space="preserve">
          <source>This attribute is used to modify the IA-64 calling convention by marking all input registers as live at all function exits. This makes it possible to restart a system call after an interrupt without having to save/restore the input registers. This also prevents kernel data from leaking into application code.</source>
          <target state="translated">この属性は、すべての関数の終了時にすべての入力レジスタをライブとしてマークすることで、IA-64の呼び出し規約を変更するために使用されます。これにより、入力レジスタを保存/復元することなく、割り込み後にシステムコールを再起動することが可能になります。これはまた、カーネルデータがアプリケーションコードに漏れることを防ぎます。</target>
        </trans-unit>
        <trans-unit id="b29e16cc249effe80d848bb9db8d32ddaa499113" translate="yes" xml:space="preserve">
          <source>This attribute is useful for small inline wrappers that if possible should appear during debugging as a unit. Depending on the debug info format it either means marking the function as artificial or using the caller location for all instructions within the inlined body.</source>
          <target state="translated">この属性は、可能であればデバッグ中にユニットとして表示されるべき小さなインラインラッパーに便利です。デバッグ情報のフォーマットに応じて、関数を人工的なものとしてマークするか、インラインボディ内のすべての命令に呼び出し元の場所を使用することを意味します。</target>
        </trans-unit>
        <trans-unit id="eebce69b5ee57e7d9f9e53b8f77d9b2143a8f71f" translate="yes" xml:space="preserve">
          <source>This attribute locally overrides the</source>
          <target state="translated">この属性はローカルで</target>
        </trans-unit>
        <trans-unit id="b079e0e5e6910cff82e9ecf2f5a99d46287bccb2" translate="yes" xml:space="preserve">
          <source>This attribute may only be applied to structure types. It indicates that any initialization of an object of this type must use designated initializers rather than positional initializers. The intent of this attribute is to allow the programmer to indicate that a structure&amp;rsquo;s layout may change, and that therefore relying on positional initialization will result in future breakage.</source>
          <target state="translated">この属性は構造タイプにのみ適用できます。これは、このタイプのオブジェクトの初期化では、位置初期化子ではなく、指定された初期化子を使用する必要があることを示しています。この属性の目的は、構造体のレイアウトが変更される可能性があることをプログラマーが示すことができるようにすることであり、したがって、位置の初期化に依存すると、将来的に破損することになります。</target>
        </trans-unit>
        <trans-unit id="c5c62ef86997f4e170b106b5387843679fbba8d0" translate="yes" xml:space="preserve">
          <source>This attribute modifies the behavior of an interrupt handler. The interrupt handler may be in external memory which cannot be reached by a branch instruction, so generate a local memory trampoline to transfer control. The single parameter identifies the section where the trampoline is placed.</source>
          <target state="translated">この属性は割り込みハンドラの動作を変更します。割り込みハンドラは分岐命令では到達できない外部メモリにある可能性があるので、制御を転送するためにローカルメモリのトランポリンを生成します。シングルパラメータはトランポリンを配置するセクションを特定します。</target>
        </trans-unit>
        <trans-unit id="effaae1a1a3c582ea4cc6ec90afe0b02dd3b515f" translate="yes" xml:space="preserve">
          <source>This attribute only applies to interrupt functions. It is silently ignored if applied to a non-interrupt function. A wakeup interrupt function will rouse the processor from any low-power state that it might be in when the function exits.</source>
          <target state="translated">この属性は割り込み関数にのみ適用されます。非割込み関数に適用された場合は静かに無視されます。ウェイクアップ割り込み関数は、その関数が終了したときにプロセッサを低消費電力状態から解放します。</target>
        </trans-unit>
        <trans-unit id="b26152314a60738ffd8a5e7f3727dd841bf2cfd9" translate="yes" xml:space="preserve">
          <source>This attribute requires assembler and object file support, and may not be available on all targets.</source>
          <target state="translated">この属性はアセンブラとオブジェクトファイルのサポートが必要で、すべてのターゲットで利用できるわけではありません。</target>
        </trans-unit>
        <trans-unit id="91b2af80c8a3a275efbd609425500eed5fe647aa" translate="yes" xml:space="preserve">
          <source>This attribute should be used with a function that is also declared with the &lt;code&gt;inline&lt;/code&gt; keyword. It directs GCC to treat the function as if it were defined in gnu90 mode even when compiling in C99 or gnu99 mode.</source>
          <target state="translated">この属性は、 &lt;code&gt;inline&lt;/code&gt; キーワードで宣言されている関数でも使用する必要があります。これは、C99またはgnu99モードでコンパイルする場合でも、関数をgnu90モードで定義されたものとして扱うようにGCCに指示します。</target>
        </trans-unit>
        <trans-unit id="673dc92ba9f751f0e2d252934e26bb46b7e48dac" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L1 Instruction SRAM. The function is put into a specific section named &lt;code&gt;.l1.text&lt;/code&gt;. With</source>
          <target state="translated">この属性は、L1命令SRAMに配置される関数を指定します。関数は &lt;code&gt;.l1.text&lt;/code&gt; という名前の特定のセクションに配置されます。と</target>
        </trans-unit>
        <trans-unit id="87042e05584213c1ab77c9f22219578def878d66" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L2 SRAM. The function is put into a specific section named &lt;code&gt;.l2.text&lt;/code&gt;. With</source>
          <target state="translated">この属性は、L2 SRAMに配置される機能を指定します。関数は &lt;code&gt;.l2.text&lt;/code&gt; という名前の特定のセクションに配置されます。と</target>
        </trans-unit>
        <trans-unit id="79629b6015ecde4f64aa5edeebdeed4ca22350b1" translate="yes" xml:space="preserve">
          <source>This attribute specifies a threshold for the structure field, measured in bytes. If the structure field is aligned below the threshold, a warning will be issued. For example, the declaration:</source>
          <target state="translated">この属性は、バイト単位で測定される構造体フィールドのしきい値を指定します。構造体フィールドが閾値以下に整列している場合、警告が発行されます。例えば、宣言</target>
        </trans-unit>
        <trans-unit id="304795dd4f7d1f35b54a689f0ca428f75b402b8c" translate="yes" xml:space="preserve">
          <source>This attribute specifies the data type for the declaration&amp;mdash;whichever type corresponds to the mode &lt;var&gt;mode&lt;/var&gt;. This in effect lets you request an integer or floating-point type according to its width.</source>
          <target state="translated">この属性は、宣言のデータ型（モード &lt;var&gt;mode&lt;/var&gt; に対応する型）を指定します。これにより、幅に応じて整数型または浮動小数点型を要求できます。</target>
        </trans-unit>
        <trans-unit id="9c9083d141dfccd0e26e0504dbf2c594ddf0afc0" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type of the declared variable, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the declaration:</source>
          <target state="translated">この属性は、宣言された変数のタイプのベクトルサイズをバイト単位で指定します。適用される&lt;em&gt;タイプ&lt;/em&gt;は、&lt;em&gt;基本タイプ&lt;/em&gt;と呼ばれます。 &lt;var&gt;bytes&lt;/var&gt; 引数は、ベース型サイズの正の2のべき乗の倍数でなければなりません。たとえば、宣言は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4812a74afb4965dd971b67251a8e1a47c47bf670" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the following declarations:</source>
          <target state="translated">この属性は、タイプのベクトルサイズをバイト単位で指定します。適用される&lt;em&gt;タイプ&lt;/em&gt;は、&lt;em&gt;基本タイプ&lt;/em&gt;と呼ばれます。 &lt;var&gt;bytes&lt;/var&gt; 引数は、ベース型サイズの正の2のべき乗の倍数でなければなりません。たとえば、次の宣言：</target>
        </trans-unit>
        <trans-unit id="721933cb3a33d0b7e6bbaf2079ece1bfb6d52c2e" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or C++ &lt;code&gt;class&lt;/code&gt; type definition, specifies that each of its members (other than zero-width bit-fields) is placed to minimize the memory required. This is equivalent to specifying the &lt;code&gt;packed&lt;/code&gt; attribute on each of the members.</source>
          <target state="translated">この属性は、 &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; 、またはC ++ &lt;code&gt;class&lt;/code&gt; 型定義に付加され、そのメンバー（ゼロ幅ビットフィールド以外）のそれぞれが、必要なメモリを最小限に抑えるために配置されることを指定します。これは、各メンバーに &lt;code&gt;packed&lt;/code&gt; 属性を指定することと同じです。</target>
        </trans-unit>
        <trans-unit id="f26328ece7307f514a47cc876ff83560893a099c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;union&lt;/code&gt; type definition, indicates that any function parameter having that union type causes calls to that function to be treated in a special way.</source>
          <target state="translated">この属性は、 &lt;code&gt;union&lt;/code&gt; 体型定義に付加され、その共用体型を持つ関数パラメーターがあると、その関数の呼び出しが特別な方法で処理されることを示します。</target>
        </trans-unit>
        <trans-unit id="dea2c8428220fbb29ff9bb397fcc0cd8bc82fcc8" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that code must be emitted for the function even if it appears that the function is not referenced. This is useful, for example, when the function is referenced only in inline assembly.</source>
          <target state="translated">関数に添付されたこの属性は、関数が参照されていないように見えても、その関数に対してコードを出さなければならないことを意味します。これは、例えば、関数がインライン・アセンブリでしか参照されない場合などに便利です。</target>
        </trans-unit>
        <trans-unit id="f26a8e83a7c29f151aef9f7d69a0073e42ed7b63" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that the function is meant to be possibly unused. GCC does not produce a warning for this function.</source>
          <target state="translated">この属性は、関数に付けられたもので、その関数が使用されない可能性があることを意味します。GCCはこの関数に対して警告を発しません。</target>
        </trans-unit>
        <trans-unit id="0cda8d2a406df80f5c3c1e70abd61657e961b09d" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a global variable or function, nullifies the effect of the</source>
          <target state="translated">グローバル変数や関数にアタッチされたこの属性は</target>
        </trans-unit>
        <trans-unit id="b693f4e1b31df32d21cd97a87984062ca5cf0e7b" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable with static storage, means that the variable must be emitted even if it appears that the variable is not referenced.</source>
          <target state="translated">静的記憶装置を持つ変数に付けられたこの属性は、変数が参照されていないように見えても、その変数を放出しなければならないことを意味します。</target>
        </trans-unit>
        <trans-unit id="09cf2bdd650a42affb72357abc94b2d76134170c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable, means that the variable is meant to be possibly unused. GCC does not produce a warning for this variable.</source>
          <target state="translated">この属性は、変数に添付され、その変数が使用されない可能性があることを意味します。GCCはこの変数に対して警告を発しません。</target>
        </trans-unit>
        <trans-unit id="f6a9f3d41b5e82d7b9c83b17f60c49a3dab84962" translate="yes" xml:space="preserve">
          <source>This behavior may seem silly, but it&amp;rsquo;s what the ISO standard specifies. It is easy enough for you to make your code work by moving the definition of &lt;code&gt;struct mumble&lt;/code&gt; above the prototype. It&amp;rsquo;s not worth being incompatible with ISO C just to avoid an error for the example shown above.</source>
          <target state="translated">この振る舞いはばかげているように見えるかもしれませんが、それはISO標準が指定するものです。 &lt;code&gt;struct mumble&lt;/code&gt; の定義をプロトタイプの上に移動することで、コードを機能させるのは簡単です。上記の例のエラーを回避するためだけにISO Cと互換性がないことは価値がありません。</target>
        </trans-unit>
        <trans-unit id="8818c6d89ffa44c89646c897a4e574f7b71484ee" translate="yes" xml:space="preserve">
          <source>This built-in can be used to determine the current transaction state using the following code example:</source>
          <target state="translated">この組み込みは、以下のコード例を使用して現在のトランザクションの状態を決定するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="92883b24f84fe55e50f3d20ded0b1b0331344202" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between a thread and signal handlers based in the same thread.</source>
          <target state="translated">この組み込み関数は、同じスレッドに基づくスレッドとシグナルハンドラ間の同期フェンスとして機能します。</target>
        </trans-unit>
        <trans-unit id="5a20473e8d5898eb62d474e73fb635a7caf013c9" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between threads based on the specified memory order.</source>
          <target state="translated">この組み込み関数は、指定されたメモリ順序に基づいてスレッド間の同期フェンスとして機能します。</target>
        </trans-unit>
        <trans-unit id="8c179d50784fac3eee427384f1e34f1d0ea28d01" translate="yes" xml:space="preserve">
          <source>This built-in function can be used to help mitigate against unsafe speculative execution. &lt;var&gt;type&lt;/var&gt; may be any integral type or any pointer type.</source>
          <target state="translated">この組み込み関数を使用して、安全でない投機的実行を軽減することができます。 &lt;var&gt;type&lt;/var&gt; は、任意の整数型または任意のポインター型です。</target>
        </trans-unit>
        <trans-unit id="cdfcca8b913445e45652ce81bc13dc531eb31f5a" translate="yes" xml:space="preserve">
          <source>This built-in function can return an lvalue if the chosen argument is an lvalue.</source>
          <target state="translated">この組み込み関数は、選択された引数がlvalueの場合、lvalueを返すことができます。</target>
        </trans-unit>
        <trans-unit id="42b10a642d35506bdb301b36c3b2dbb7b1a29af0" translate="yes" xml:space="preserve">
          <source>This built-in function ignores top level qualifiers (e.g., &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;). For example, &lt;code&gt;int&lt;/code&gt; is equivalent to &lt;code&gt;const
int&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、最上位の修飾子（たとえば、 &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;volatile&lt;/code&gt; ）を無視します。たとえば、 &lt;code&gt;int&lt;/code&gt; は &lt;code&gt;const int&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="de3196f175db1b7bf9e191bc879315daa8c8ea4f" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic compare and exchange operation. This compares the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; with the contents of &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. If equal, the operation is a &lt;em&gt;read-modify-write&lt;/em&gt; operation that writes &lt;var&gt;desired&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. If they are not equal, the operation is a &lt;em&gt;read&lt;/em&gt; and the current contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; are written into &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;true&lt;/code&gt; for weak compare_exchange, which may fail spuriously, and &lt;code&gt;false&lt;/code&gt; for the strong variation, which never fails spuriously. Many targets only offer the strong variation and ignore the parameter. When in doubt, use the strong variation.</source>
          <target state="translated">この組み込み関数は、アトミックな比較および交換操作を実装します。これにより、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の内容と &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt; の内容が比較されます。等しい場合は、操作は&lt;em&gt;リードモディファイライト&lt;/em&gt;書き込み動作の &lt;var&gt;desired&lt;/var&gt; に &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; が。それらが等しくない場合、操作は&lt;em&gt;読み取りで&lt;/em&gt;あり、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の現在の内容が &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt; に書き込まれます。 &lt;var&gt;weak&lt;/var&gt; は、 &lt;code&gt;false&lt;/code&gt; 失敗する可能性のある弱いcompare_exchangeの &lt;code&gt;true&lt;/code&gt; はtrue、falseの場合誤って失敗することのない強力なバリエーション。多くのターゲットは強い変動のみを提供し、パラメーターを無視します。疑わしい場合は、強力なバリエーションを使用してください。</target>
        </trans-unit>
        <trans-unit id="56f42bd96c55f1e604c896fe2e73d0e93c4e17e7" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic exchange operation. It writes &lt;var&gt;val&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、アトミック交換操作を実装します。 &lt;var&gt;val&lt;/var&gt; を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に書き込み、以前の &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の内容を返します。</target>
        </trans-unit>
        <trans-unit id="e39a26f774d21850134f1ad4ec8601fd024a4508" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic load operation. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、アトミックロード操作を実装します。 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の内容を返します。</target>
        </trans-unit>
        <trans-unit id="6b2685600611aa3929789e72b13593b02a524004" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic store operation. It writes &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、アトミックストア操作を実装します。 &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="ea16c3e951ac6e4e93bda6af660c19a372791953" translate="yes" xml:space="preserve">
          <source>This built-in function implements the generic version of &lt;code&gt;__atomic_compare_exchange&lt;/code&gt;. The function is virtually identical to &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt;, except the desired value is also a pointer.</source>
          <target state="translated">この組み込み関数は、 &lt;code&gt;__atomic_compare_exchange&lt;/code&gt; の汎用バージョンを実装しています。この関数は、目的の値もポインタであることを除いて、実質的に &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="8296c6507414677ec38273521ab8df96daa500be" translate="yes" xml:space="preserve">
          <source>This built-in function invokes &lt;var&gt;function&lt;/var&gt; with a copy of the parameters described by &lt;var&gt;arguments&lt;/var&gt; and &lt;var&gt;size&lt;/var&gt;.</source>
          <target state="translated">これは、組み込み関数呼び出し &lt;var&gt;function&lt;/var&gt; によって記述されたパラメータのコピーを &lt;var&gt;arguments&lt;/var&gt; と &lt;var&gt;size&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f5c4780f25bedcea7655683b3a1f0ac5e0f5ed0" translate="yes" xml:space="preserve">
          <source>This built-in function is analogous to the &amp;lsquo;</source>
          <target state="translated">この組み込み関数は、「</target>
        </trans-unit>
        <trans-unit id="6e1bff7892551ba3b77dbb599f93fb2a84f960cc" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather a &lt;em&gt;release barrier&lt;/em&gt;. This means that all previous memory stores are globally visible, and all previous memory loads have been satisfied, but following memory reads are not prevented from being speculated to before the barrier.</source>
          <target state="translated">この組み込み関数は完全なバリアではなく、&lt;em&gt;リリースバリア&lt;/em&gt;です。これは、以前のすべてのメモリストアがグローバルに表示され、以前のすべてのメモリロードが満たされていることを意味しますが、後続のメモリ読み取りは、バリアの前に推測されることを妨げられません。</target>
        </trans-unit>
        <trans-unit id="d70719484366a8b3c252ddc3ff84790bc06cc3ad" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather an &lt;em&gt;acquire barrier&lt;/em&gt;. This means that references after the operation cannot move to (or be speculated to) before the operation, but previous memory stores may not be globally visible yet, and previous memory loads may not yet be satisfied.</source>
          <target state="translated">この組み込み関数は完全なバリアではなく、&lt;em&gt;取得バリア&lt;/em&gt;です。これは、操作後の参照が操作の前に移動できない（または推測できない）ことを意味しますが、以前のメモリストアはまだグローバルに表示されておらず、以前のメモリロードがまだ満たされていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="073757ac658ed7f6a9f1d03295b93f00125aefcc" translate="yes" xml:space="preserve">
          <source>This built-in function issues a full memory barrier.</source>
          <target state="translated">この内蔵機能は、フルメモリバリアを発行します。</target>
        </trans-unit>
        <trans-unit id="7e033b3b4f9c857696bc2244ed32f0a7d140cd57" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic clear operation on &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. After the operation, &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; contains 0. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt; and in conjunction with &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. For other types it may only clear partially. If the type is not &lt;code&gt;bool&lt;/code&gt; prefer using &lt;code&gt;__atomic_store&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に対してアトミックなクリア操作を実行します。操作後、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; には0が含まれます。これは、 &lt;code&gt;bool&lt;/code&gt; 型または &lt;code&gt;char&lt;/code&gt; 型のオペランドにのみ使用し、 &lt;code&gt;__atomic_test_and_set&lt;/code&gt; と組み合わせて使用​​する必要があります。他のタイプでは、部分的にしかクリアされない場合があります。タイプが &lt;code&gt;bool&lt;/code&gt; でない場合は、 &lt;code&gt;__atomic_store&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b9c97edabae382ebead73a4652d8d69259efed11" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic test-and-set operation on the byte at &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The byte is set to some implementation defined nonzero &amp;ldquo;set&amp;rdquo; value and the return value is &lt;code&gt;true&lt;/code&gt; if and only if the previous contents were &amp;ldquo;set&amp;rdquo;. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. For other types only part of the value may be set.</source>
          <target state="translated">この組み込み関数は、 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; のバイトに対してアトミックなテストと設定の操作を実行します。バイトは、実装によって定義されたゼロ以外の「セット」値に設定され、戻り値は、前のコンテンツが「セット」された場合にのみ &lt;code&gt;true&lt;/code&gt; になります。タイプ &lt;code&gt;bool&lt;/code&gt; または &lt;code&gt;char&lt;/code&gt; のオペランドにのみ使用してください。他のタイプの場合、値の一部のみを設定できます。</target>
        </trans-unit>
        <trans-unit id="b288561de8012f0a5e9cadf66cc0631f6c354855" translate="yes" xml:space="preserve">
          <source>This built-in function releases the lock acquired by &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt;. Normally this means writing the constant 0 to &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、 &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt; によって取得されたロックを解放します。通常、これは定数0を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に書き込むことを意味します。</target>
        </trans-unit>
        <trans-unit id="6fbd055aee266ab03001d14151e03de46793e79e" translate="yes" xml:space="preserve">
          <source>This built-in function represents all anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. It must be only passed as last argument to some other function with variable arguments. This is useful for writing small wrapper inlines for variable argument functions, when using preprocessor macros is undesirable. For example:</source>
          <target state="translated">この組み込み関数は、インライン関数のすべての匿名引数を表します。 &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; または &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; externインライン関数を使用する関数など、常にインライン化され、個別の関数としてコンパイルされることのないインライン関数でのみ使用できます。可変引数を持つ他の関数の最後の引数としてのみ渡す必要があります。これは、プリプロセッサマクロの使用が望ましくない場合に、可変引数関数の小さなラッパーインラインを記述する場合に役立ちます。例えば：</target>
        </trans-unit>
        <trans-unit id="a645e8bd97d4c4a4974b86fe42f50e43f5945898" translate="yes" xml:space="preserve">
          <source>This built-in function returns 1 if the unqualified versions of the types &lt;var&gt;type1&lt;/var&gt; and &lt;var&gt;type2&lt;/var&gt; (which are types, not expressions) are compatible, 0 otherwise. The result of this built-in function can be used in integer constant expressions.</source>
          <target state="translated">この組み込み関数は、 &lt;var&gt;type1&lt;/var&gt; と &lt;var&gt;type2&lt;/var&gt; の非修飾バージョン（式ではなく型）に互換性がある場合は1を返し、それ以外の場合は0を返します。この組み込み関数の結果は、整数定数式で使用できます。</target>
        </trans-unit>
        <trans-unit id="adfe1d809ee98496092f61c8ed5ff01343455bef" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. &lt;var&gt;size&lt;/var&gt; must resolve to a compile-time constant and the result also resolves to a compile-time constant.</source>
          <target state="translated">この組み込み関数は、バイト &lt;var&gt;size&lt;/var&gt; オブジェクトが常にターゲットアーキテクチャのロックフリーアトミック命令を生成する場合に &lt;code&gt;true&lt;/code&gt; を返します。 &lt;var&gt;size&lt;/var&gt; はコンパイル時定数に解決される必要があり、結果もコンパイル時定数に解決されます。</target>
        </trans-unit>
        <trans-unit id="81bd1267444e0c22cd6d3d40974c7c8c9aa88d05" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. If the built-in function is not known to be lock-free, a call is made to a runtime routine named &lt;code&gt;__atomic_is_lock_free&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、バイト &lt;var&gt;size&lt;/var&gt; オブジェクトが常にターゲットアーキテクチャのロックフリーアトミック命令を生成する場合に &lt;code&gt;true&lt;/code&gt; を返します。組み込み関数がロックフリーであることがわからない場合は、 &lt;code&gt;__atomic_is_lock_free&lt;/code&gt; という名前の実行時ルーチンが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7c6d5e134400518a60b0f022ce70bc3a88ebfc9d" translate="yes" xml:space="preserve">
          <source>This built-in function returns a pointer to data describing how to perform a call with the same arguments as are passed to the current function.</source>
          <target state="translated">この組み込み関数は、現在の関数に渡されている引数と同じ引数で呼び出しを実行する方法を記述したデータへのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="a965c005ba35ec687e9a6eef5b255a00ddffc5d3" translate="yes" xml:space="preserve">
          <source>This built-in function returns the number of anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. For example following does link- or run-time checking of open arguments for optimized code:</source>
          <target state="translated">この組み込み関数は、インライン関数の無名引数の数を返します。 &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; または &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; externインライン関数を使用する関数など、常にインライン化され、個別の関数としてコンパイルされることのないインライン関数でのみ使用できます。たとえば、次のコードは、最適化されたコードのオープン引数のリンク時または実行時チェックを行います。</target>
        </trans-unit>
        <trans-unit id="23a152f3eb0d609efeaccc0dfd600b3f1ca33a36" translate="yes" xml:space="preserve">
          <source>This built-in function returns the value described by &lt;var&gt;result&lt;/var&gt; from the containing function. You should specify, for &lt;var&gt;result&lt;/var&gt;, a value returned by &lt;code&gt;__builtin_apply&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、包含関数からの &lt;var&gt;result&lt;/var&gt; によって記述された値を返します。 &lt;var&gt;result&lt;/var&gt; には、__ &lt;code&gt;__builtin_apply&lt;/code&gt; によって返される値を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="93f8e4f9c5ee35c6668a2b80b5a01f58cf7b3cac" translate="yes" xml:space="preserve">
          <source>This built-in function, as described by Intel, is not a traditional test-and-set operation, but rather an atomic exchange operation. It writes &lt;var&gt;value&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数は、Intelによって記述されているように、従来のテストと設定の操作ではなく、アトミックな交換操作です。これは、書き込み &lt;var&gt;value&lt;/var&gt; に &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 、との以前の内容を返す &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="568a9d62c8cf52e8d6dd28fe3fede9225dfafd5c" translate="yes" xml:space="preserve">
          <source>This built-in implements the C99 fpclassify functionality. The first five int arguments should be the target library&amp;rsquo;s notion of the possible FP classes and are used for return values. They must be constant values and they must appear in this order: &lt;code&gt;FP_NAN&lt;/code&gt;, &lt;code&gt;FP_INFINITE&lt;/code&gt;, &lt;code&gt;FP_NORMAL&lt;/code&gt;, &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; and &lt;code&gt;FP_ZERO&lt;/code&gt;. The ellipsis is for exactly one floating-point value to classify. GCC treats the last argument as type-generic, which means it does not do default promotion from float to double.</source>
          <target state="translated">この組み込み関数は、C99 fpclassify機能を実装しています。最初の5つのint引数は、可能なFPクラスのターゲットライブラリの概念である必要があり、戻り値に使用されます。それらは定数値である必要があり、 &lt;code&gt;FP_NAN&lt;/code&gt; 、 &lt;code&gt;FP_INFINITE&lt;/code&gt; 、 &lt;code&gt;FP_NORMAL&lt;/code&gt; 、 &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; 、および &lt;code&gt;FP_ZERO&lt;/code&gt; の順序で出現する必要があります。省略記号は、1つの浮動小数点値を分類するためのものです。 GCCは最後の引数を型ジェネリックとして扱います。これは、floatからdoubleへのデフォルトの昇格を行わないことを意味します。</target>
        </trans-unit>
        <trans-unit id="de56bb64bcd269982e143b48fca7664ac4ccd934" translate="yes" xml:space="preserve">
          <source>This built-in takes a byte address to the 24-bit &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;address space&lt;/a&gt;&lt;code&gt;__memx&lt;/code&gt; and returns the number of the flash segment (the 64 KiB chunk) where the address points to. Counting starts at &lt;code&gt;0&lt;/code&gt;. If the address does not point to flash memory, return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">この組み込み &lt;code&gt;__memx&lt;/code&gt; は、バイトアドレスを24ビット&lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;アドレス空間&lt;/a&gt;__memxに取り、アドレスが指すフラッシュセグメント（64 KiBチャンク）の番号を返します。カウントは &lt;code&gt;0&lt;/code&gt; から始まります。アドレスがフラッシュメモリを指していない場合は、 &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="12afcfe5b0cb2421e366cb4bf6d262a7225b43e1" translate="yes" xml:space="preserve">
          <source>This calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.</source>
          <target state="translated">この呼び出し規約はUnixで通常使われているものと互換性がないので、Unixコンパイラでコンパイルされたライブラリを呼び出す必要がある場合には使えません。</target>
        </trans-unit>
        <trans-unit id="c59930047a3dbe1a0da0d3c55b5832603831020b" translate="yes" xml:space="preserve">
          <source>This can be a suitable option for application code written for the Borland model, as it usually just works. Code written for the Cfront model needs to be modified so that the template definitions are available at one or more points of instantiation; usually this is as simple as adding &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; to the end of each template header.</source>
          <target state="translated">これは通常動作するだけなので、Borlandモデル用に作成されたアプリケーションコードに適したオプションです。Cfrontモデル用に作成されたコードは、インスタンス化の1つ以上のポイントでテンプレート定義が使用できるように変更する必要があります。通常、これは &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; を各テンプレートヘッダーの最後に追加するだけです。</target>
        </trans-unit>
        <trans-unit id="8138fe5070f142675bd6f047c11ca6604b5e4b89" translate="yes" xml:space="preserve">
          <source>This causes GCC&amp;rsquo;s output file to have the &amp;lsquo;</source>
          <target state="translated">これにより、GCCの出力ファイルに「</target>
        </trans-unit>
        <trans-unit id="0b096441ddb3f545a4e7491763e07ff42aa42c7a" translate="yes" xml:space="preserve">
          <source>This causes an error messages saying:</source>
          <target state="translated">というエラーメッセージが出てしまいます。</target>
        </trans-unit>
        <trans-unit id="37b13c019e57e81567c1e4f0f77d055f628a1482" translate="yes" xml:space="preserve">
          <source>This clears the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="translated">現在スタック上に保存されているステータス・レジスタの保存されたコピーの中の指定されたビットをクリアします。これは割り込みハンドラ内でのみ動作し、ステータスレジスタの変更はハンドラが戻ってきてから有効になります。</target>
        </trans-unit>
        <trans-unit id="52348806f9132146a3d5c83435b59d49467218d2" translate="yes" xml:space="preserve">
          <source>This code copies &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; and add 1 to &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">このコードは &lt;code&gt;src&lt;/code&gt; を &lt;code&gt;dst&lt;/code&gt; にコピーし、1を &lt;code&gt;dst&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="5a1cd197f5f5bea21b21e4898acbd5a40235dc12" translate="yes" xml:space="preserve">
          <source>This code makes no use of the optional &lt;var&gt;asmSymbolicName&lt;/var&gt;. Therefore it references the first output operand as &lt;code&gt;%0&lt;/code&gt; (were there a second, it would be &lt;code&gt;%1&lt;/code&gt;, etc). The number of the first input operand is one greater than that of the last output operand. In this i386 example, that makes &lt;code&gt;Mask&lt;/code&gt; referenced as &lt;code&gt;%1&lt;/code&gt;:</source>
          <target state="translated">このコードは、オプションの &lt;var&gt;asmSymbolicName&lt;/var&gt; を使用しません。したがって、最初の出力オペランドは &lt;code&gt;%0&lt;/code&gt; として参照されます（2番目の出力があった場合、 &lt;code&gt;%1&lt;/code&gt; などになります）。最初の入力オペランドの数は、最後の出力オペランドの数より1つ大きくなっています。このi386の例では、 &lt;code&gt;Mask&lt;/code&gt; が &lt;code&gt;%1&lt;/code&gt; として参照されます。</target>
        </trans-unit>
        <trans-unit id="f9f2247acfc64bac06fade1fb9f20f85e4652f3a" translate="yes" xml:space="preserve">
          <source>This code really is erroneous, because the scope of &lt;code&gt;struct
mumble&lt;/code&gt; in the prototype is limited to the argument list containing it. It does not refer to the &lt;code&gt;struct mumble&lt;/code&gt; defined with file scope immediately below&amp;mdash;they are two unrelated types with similar names in different scopes.</source>
          <target state="translated">プロトタイプの &lt;code&gt;struct mumble&lt;/code&gt; のスコープはそれを含む引数リストに限定されているため、このコードは実際には誤りです。すぐ下のファイルスコープで定義された &lt;code&gt;struct mumble&lt;/code&gt; は参照されません。これらは、異なるスコープで類似した名前を持つ2つの無関係なタイプです。</target>
        </trans-unit>
        <trans-unit id="337163816650f5c7db30e6d4ef7d7194c7c7dcdf" translate="yes" xml:space="preserve">
          <source>This code runs unconditionally on all 64-bit processors. For 32-bit processors the code runs on those that support multi-byte NOP instructions.</source>
          <target state="translated">このコードは、すべての 64 ビットプロセッサ上で無条件に動作します。32ビットプロセッサでは、このコードはマルチバイトNOP命令をサポートしているプロセッサで実行されます。</target>
        </trans-unit>
        <trans-unit id="5f60ecfa36c1d209e897848d1465d421ffe66fd4" translate="yes" xml:space="preserve">
          <source>This code says that input &lt;code&gt;b&lt;/code&gt; is not popped by the &lt;code&gt;asm&lt;/code&gt;, and that the &lt;code&gt;asm&lt;/code&gt; pushes a result onto the reg-stack, i.e., the stack is one deeper after the &lt;code&gt;asm&lt;/code&gt; than it was before. But, it is possible that reload may think that it can use the same register for both the input and the output.</source>
          <target state="translated">このコードは、入力 &lt;code&gt;b&lt;/code&gt; が &lt;code&gt;asm&lt;/code&gt; によってポップされず、 &lt;code&gt;asm&lt;/code&gt; が結果をreg-stackにプッシュすることを示しています。つまり、スタックは &lt;code&gt;asm&lt;/code&gt; の前より1つ深いです。しかし、リロードは、入力と出力の両方に同じレジスターを使用できると考える可能性があります。</target>
        </trans-unit>
        <trans-unit id="5158b0e232baa68e812ae0b3c5ff1e7b6dd2495a" translate="yes" xml:space="preserve">
          <source>This combination of &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; has almost the effect of a macro. The way to use it is to put a function definition in a header file with these keywords, and put another copy of the definition (lacking &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt;) in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; と &lt;code&gt;extern&lt;/code&gt; のこの組み合わせは、ほとんどマクロの効果があります。それを使用する方法は、これらのキーワードを使用して関数定義をヘッダーファイルに置き、ライブラリファイルに定義の別のコピー（ &lt;code&gt;inline&lt;/code&gt; と &lt;code&gt;extern&lt;/code&gt; が欠けている）を置くことです。ヘッダーファイルの定義により、関数のほとんどの呼び出しがインライン化されます。関数の使用が残っている場合は、ライブラリ内の単一のコピーを参照します。</target>
        </trans-unit>
        <trans-unit id="b81343c69409df406d64f943e849b1b69e1c3338" translate="yes" xml:space="preserve">
          <source>This construct outputs &lt;code&gt;dialect0&lt;/code&gt; when using dialect #0 to compile the code, &lt;code&gt;dialect1&lt;/code&gt; for dialect #1, etc. If there are fewer alternatives within the braces than the number of dialects the compiler supports, the construct outputs nothing.</source>
          <target state="translated">この構築出力 &lt;code&gt;dialect0&lt;/code&gt; コード、コンパイルする方言＃0を使用して &lt;code&gt;dialect1&lt;/code&gt; 方言のコンパイラサポートの数、構造出力何よりも、中括弧内の少数の選択肢がある場合など方言＃1、のために。</target>
        </trans-unit>
        <trans-unit id="4418d19029db54262a2982d0fc11517ca360b079" translate="yes" xml:space="preserve">
          <source>This could also be written using a statement expression:</source>
          <target state="translated">これも文式を使って書くことができます。</target>
        </trans-unit>
        <trans-unit id="d3561933d5b27303ad0b1eed1db35f7bce90fa0b" translate="yes" xml:space="preserve">
          <source>This declaration only establishes that the class &lt;code&gt;Foo&lt;/code&gt; has an &lt;code&gt;int&lt;/code&gt; named &lt;code&gt;Foo::bar&lt;/code&gt;, and a member function named &lt;code&gt;Foo::method&lt;/code&gt;. But you still need to define &lt;em&gt;both&lt;/em&gt;&lt;code&gt;method&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; elsewhere. According to the ISO standard, you must supply an initializer in one (and only one) source file, such as:</source>
          <target state="translated">この宣言は、クラス &lt;code&gt;Foo&lt;/code&gt; に &lt;code&gt;Foo::bar&lt;/code&gt; という名前の &lt;code&gt;int&lt;/code&gt; と &lt;code&gt;Foo::method&lt;/code&gt; という名前のメンバー関数があることのみを確立します。ただし&lt;em&gt;、&lt;/em&gt; &lt;code&gt;method&lt;/code&gt; と &lt;code&gt;bar&lt;/code&gt; &lt;em&gt;両方を&lt;/em&gt;別の場所で定義する必要があります。ISO標準によれば、次のような1つの（そして1つだけの）ソースファイルで初期化子を指定する必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5d48aae2a8d70a04aa98c11ed292ce987fe6e4" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of pointers to characters:</source>
          <target state="translated">これは &lt;code&gt;y&lt;/code&gt; を文字へのポインタの配列として宣言します。</target>
        </trans-unit>
        <trans-unit id="d5984e00c4ab800b89abb234fbcf6672036013a3" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of such values.</source>
          <target state="translated">これは、 &lt;code&gt;y&lt;/code&gt; をそのような値の配列として宣言します。</target>
        </trans-unit>
        <trans-unit id="1cddb3ab7751ac13216d638e5a732f674e3c8eeb" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; with the type of what &lt;code&gt;x&lt;/code&gt; points to.</source>
          <target state="translated">これは、 &lt;code&gt;x&lt;/code&gt; が指すものの型で &lt;code&gt;y&lt;/code&gt; を宣言します。</target>
        </trans-unit>
        <trans-unit id="faab4d37a48d574a707b33549eb07bcf03d70747" translate="yes" xml:space="preserve">
          <source>This deduction was implemented as a possible extension to the originally proposed semantics for the C++11 standard, but was not part of the final standard, so it is disabled by default. This option is deprecated, and may be removed in a future version of G++.</source>
          <target state="translated">この推論は、当初提案されていた C++11 標準のセマンティクスを拡張する可能性があるとして実装されましたが、最終的な標準には含まれていなかったため、デフォルトでは無効になっています。このオプションは非推奨であり、G++の将来のバージョンでは削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="c879d3e8cb77a4fc10b608d3eb2285203202e61b" translate="yes" xml:space="preserve">
          <source>This defaults to &amp;lsquo;</source>
          <target state="translated">これはデフォルトで '</target>
        </trans-unit>
        <trans-unit id="f436df92076512b77fe92317bd65f3d39a6a1f34" translate="yes" xml:space="preserve">
          <source>This distinction between lookup of dependent and non-dependent names is called two-stage (or dependent) name lookup. G++ implements it since version 3.4.</source>
          <target state="translated">このように従属名と非従属名のルックアップを区別することを、2段階(または従属)名ルックアップと呼びます。G++ではバージョン3.4から実装されています。</target>
        </trans-unit>
        <trans-unit id="995cd6d9a17d418485ea5c0854d97ede3bab24ec" translate="yes" xml:space="preserve">
          <source>This document is meant to describe some of the GNU Objective-C features. It is not intended to teach you Objective-C. There are several resources on the Internet that present the language.</source>
          <target state="translated">この文書は、GNU Objective-C の機能の一部を説明することを目的としています。Objective-Cを教えることを意図したものではありません。インターネット上には、この言語を紹介するいくつかのリソースがあります。</target>
        </trans-unit>
        <trans-unit id="bdd119f74d4b60b69c880f2448f8e713a89672c3" translate="yes" xml:space="preserve">
          <source>This enables</source>
          <target state="translated">これにより</target>
        </trans-unit>
        <trans-unit id="0e09a1e0e5fd69eecab75ac51a34aa77d0b56b77" translate="yes" xml:space="preserve">
          <source>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros. This also enables some language-specific warnings described in &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C++ Dialect Options&lt;/a&gt; and &lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-C and Objective-C++ Dialect Options&lt;/a&gt;.</source>
          <target state="translated">これにより、マクロと組み合わせても、一部のユーザーが疑わしいと見なし、簡単に回避できる（または警告を回避するように変更できる）構造に関するすべての警告が有効になります。これにより、&lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C ++方言オプション&lt;/a&gt;と&lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-CおよびObjective-C ++方言オプションで&lt;/a&gt;説明されている言語固有の警告も有効になります。</target>
        </trans-unit>
        <trans-unit id="10c0c908290715ca8a4902d77d9d099c7818ae8f" translate="yes" xml:space="preserve">
          <source>This enables some extra warning flags that are not enabled by</source>
          <target state="translated">これにより</target>
        </trans-unit>
        <trans-unit id="b7f682e7e0e71202769284a5f29ad044bc452f34" translate="yes" xml:space="preserve">
          <source>This enables use of the locked load/store conditional extension to implement atomic memory built-in functions. Not available for ARC 6xx or ARC EM cores.</source>
          <target state="translated">これにより、ロックされたロード/ストア条件拡張を使用してアトミック・メモリ・ビルトイン関数を実装することができます。ARC 6xx または ARC EM コアでは使用できません。</target>
        </trans-unit>
        <trans-unit id="c5419693b2d5b267f6af681a001ebef359580125" translate="yes" xml:space="preserve">
          <source>This example assigns a function to two slots in the default table (using preprocessor macros defined elsewhere) and makes it the default for the &lt;code&gt;dct&lt;/code&gt; table:</source>
          <target state="translated">この例では、（他の場所で定義されたプリプロセッサマクロを使用して）デフォルトテーブルの2つのスロットに関数を割り当て、それを &lt;code&gt;dct&lt;/code&gt; テーブルのデフォルトにします。</target>
        </trans-unit>
        <trans-unit id="c93813cffc93eab710482b42f488b7bb9eff10b0" translate="yes" xml:space="preserve">
          <source>This example is perfectly equivalent to</source>
          <target state="translated">この例は</target>
        </trans-unit>
        <trans-unit id="d3e949e9ca160ba7c9c4c48936e0ebb9e6567bec" translate="yes" xml:space="preserve">
          <source>This example renames the spec called &amp;lsquo;</source>
          <target state="translated">この例では、「</target>
        </trans-unit>
        <trans-unit id="17efc27880dcdd0f4c6216f48227b6a6d20fb6a4" translate="yes" xml:space="preserve">
          <source>This example shows a simple assignment of a function to one vector in the default table (note that preprocessor macros may be used for chip-specific symbolic vector names):</source>
          <target state="translated">この例では、デフォルトテーブル内の1つのベクタに関数を簡単に代入しています(チップ固有のシンボリックベクタ名にはプリプロセッサマクロが使用される場合があることに注意してください)。</target>
        </trans-unit>
        <trans-unit id="f26530d0d01a4039c695b96fdd00747a2bd4aaea" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;cold&lt;/code&gt; label attribute to indicate the &lt;code&gt;ErrorHandling&lt;/code&gt; branch is unlikely to be taken and that the &lt;code&gt;ErrorHandling&lt;/code&gt; label is unused:</source>
          <target state="translated">この例では、 &lt;code&gt;cold&lt;/code&gt; ラベル属性を使用して、 &lt;code&gt;ErrorHandling&lt;/code&gt; ブランチが実行される可能性が低く、 &lt;code&gt;ErrorHandling&lt;/code&gt; ラベルが使用されていないことを示しています。</target>
        </trans-unit>
        <trans-unit id="0d3998b5540160156094948f334d5843b7f7f046" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;deprecated&lt;/code&gt; enumerator attribute to indicate the &lt;code&gt;oldval&lt;/code&gt; enumerator is deprecated:</source>
          <target state="translated">この例では、 &lt;code&gt;deprecated&lt;/code&gt; 列挙子属性を使用して、 &lt;code&gt;oldval&lt;/code&gt; 列挙子が非推奨であることを示しています。</target>
        </trans-unit>
        <trans-unit id="215cf5b89400516fe24140191ed923d2f09bd20b" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;fallthrough&lt;/code&gt; statement attribute to indicate that the</source>
          <target state="translated">この例では、 &lt;code&gt;fallthrough&lt;/code&gt; ステートメント属性を使用して、</target>
        </trans-unit>
        <trans-unit id="7f112db8072d753fab06651e1a77010d4e9ebe45" translate="yes" xml:space="preserve">
          <source>This example:</source>
          <target state="translated">この例。</target>
        </trans-unit>
        <trans-unit id="101c080fa9daf91a22a5c3746a65d406ce7eb831" translate="yes" xml:space="preserve">
          <source>This extension is not supported by GNU C++.</source>
          <target state="translated">この拡張機能はGNU C++ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="f68ab67a136425be8901f00690401dbac036957d" translate="yes" xml:space="preserve">
          <source>This extension is sufficient such that</source>
          <target state="translated">この拡張子は、次のような十分なものです。</target>
        </trans-unit>
        <trans-unit id="73b411a471e59249b2c99728d68299ae469991d2" translate="yes" xml:space="preserve">
          <source>This extension may not be very useful, but it makes the handling of &lt;code&gt;enum&lt;/code&gt; more consistent with the way &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; are handled.</source>
          <target state="translated">この拡張機能はあまり役に立ちませんが、 &lt;code&gt;enum&lt;/code&gt; の処理を、 &lt;code&gt;struct&lt;/code&gt; と &lt;code&gt;union&lt;/code&gt; 体の処理方法とより一貫したものにします。</target>
        </trans-unit>
        <trans-unit id="5605d8fdd1bc286fd5dac21c8bc67cef9a0ffdd5" translate="yes" xml:space="preserve">
          <source>This extra alignment does consume extra stack space, and generally increases code size. Code that is sensitive to stack space usage, such as embedded systems and operating system kernels, may want to reduce the preferred alignment to</source>
          <target state="translated">この余分なアラインメントは余分なスタックスペースを消費し、一般的にコードサイズを大きくします。組込みシステムやオペレーティングシステムのカーネルなど、スタックスペースの使用量に敏感なコードは、優先的なアラインメントを</target>
        </trans-unit>
        <trans-unit id="e786b1c4f43cf240524b9e361ead5cdf6cfb070b" translate="yes" xml:space="preserve">
          <source>This facility is very useful if you want to initialize global variables which can be accessed by the program directly, without sending a message to the class first. The usual way to initialize global variables, in the &lt;code&gt;+initialize&lt;/code&gt; method, might not be useful because &lt;code&gt;+initialize&lt;/code&gt; is only called when the first message is sent to a class object, which in some cases could be too late.</source>
          <target state="translated">この機能は、クラスにメッセージを送信せずに、プログラムから直接アクセスできるグローバル変数を初期化する場合に非常に役立ちます。グローバル変数を初期化する通常の方法は、中に &lt;code&gt;+initialize&lt;/code&gt; ための方法、便利ではないかもしれません &lt;code&gt;+initialize&lt;/code&gt; 最初のメッセージがいくつかのケースでは遅すぎるかもしれないクラスオブジェクトに送信されたときにのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5301c866b6ac40f65d4bd67792ec94bc126ba1c2" translate="yes" xml:space="preserve">
          <source>This feature is especially useful for ranges of ASCII character codes:</source>
          <target state="translated">この機能は、ASCII文字コードの範囲に対して特に有用です。</target>
        </trans-unit>
        <trans-unit id="4b7eade7c951c9b37c2e852a014cd189c7b49192" translate="yes" xml:space="preserve">
          <source>This feature is especially useful in making macro definitions &amp;ldquo;safe&amp;rdquo; (so that they evaluate each operand exactly once). For example, the &amp;ldquo;maximum&amp;rdquo; function is commonly defined as a macro in standard C as follows:</source>
          <target state="translated">この機能は、マクロ定義を「安全」にするために特に役立ちます（各オペランドを1回だけ評価するため）。たとえば、「最大」関数は通常、標準Cでは次のようにマクロとして定義されています。</target>
        </trans-unit>
        <trans-unit id="cf86da6582486ace0550eafa0f42f9a96d5c2a2b" translate="yes" xml:space="preserve">
          <source>This feature is intended for program-generated code that may contain unused labels, but which is compiled with</source>
          <target state="translated">この機能は、未使用のラベルを含む可能性のあるプログラム生成コードを対象としています。</target>
        </trans-unit>
        <trans-unit id="0c1076e2c167a24356587893b7b6c8a8375aa3a4" translate="yes" xml:space="preserve">
          <source>This feature is not enabled by default. Specifying</source>
          <target state="translated">この機能はデフォルトでは有効になっていません。指定する</target>
        </trans-unit>
        <trans-unit id="9420f79a451b4efac8e962af58f495ad7ac181c7" translate="yes" xml:space="preserve">
          <source>This feature is used in automatic updating of makefiles.</source>
          <target state="translated">この機能はmakefileの自動更新に使用されます。</target>
        </trans-unit>
        <trans-unit id="a8f11fa97afc8a9f70ed0e1fb16cbd9bede804da" translate="yes" xml:space="preserve">
          <source>This file documents the use of the GNU compilers.</source>
          <target state="translated">このファイルはGNUコンパイラの使用を文書化したものです。</target>
        </trans-unit>
        <trans-unit id="6c21848b1d55804d72743a6693d101b63cd47544" translate="yes" xml:space="preserve">
          <source>This flag attempts to use visibility settings to make GCC&amp;rsquo;s C++ linkage model compatible with that of Microsoft Visual Studio.</source>
          <target state="translated">このフラグは、可視性設定を使用して、GCCのC ++リンケージモデルをMicrosoft Visual Studioのモデルと互換性があるようにします。</target>
        </trans-unit>
        <trans-unit id="2db7dd43d8e02c47fc0a85c5c3e38b591f0a3877" translate="yes" xml:space="preserve">
          <source>This flag does not have a negative form, because it specifies a three-way choice.</source>
          <target state="translated">このフラグは、三者択一を指定しているので、負の形をしていません。</target>
        </trans-unit>
        <trans-unit id="c1b1af85f2a6f09c7615fb9953621e2594fc2498" translate="yes" xml:space="preserve">
          <source>This flag is disabled by default.</source>
          <target state="translated">このフラグはデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="ef23e3f8b62106f744c396a536baec3f85486f03" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default at</source>
          <target state="translated">このフラグはデフォルトでは</target>
        </trans-unit>
        <trans-unit id="7fb1ed0a0aaf28dac933fdc7dd7aadf9b8292636" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default for</source>
          <target state="translated">このフラグは、デフォルトでは</target>
        </trans-unit>
        <trans-unit id="c025ee0fe2aca271d6bc8b1c3c04c156ee4d07a6" translate="yes" xml:space="preserve">
          <source>This flag is included in</source>
          <target state="translated">このフラグは</target>
        </trans-unit>
        <trans-unit id="03d3b3aedc1d8ba8a1241588ebdb03f76fc4bd8e" translate="yes" xml:space="preserve">
          <source>This function attribute indicates that an argument in a call to the function is expected to be an explicit &lt;code&gt;NULL&lt;/code&gt;. The attribute is only valid on variadic functions. By default, the sentinel is expected to be the last argument of the function call. If the optional &lt;var&gt;position&lt;/var&gt; argument is specified to the attribute, the sentinel must be located at &lt;var&gt;position&lt;/var&gt; counting backwards from the end of the argument list.</source>
          <target state="translated">この関数属性は、関数の呼び出しの引数が明示的な &lt;code&gt;NULL&lt;/code&gt; であることが期待されることを示します。この属性は、可変個関数でのみ有効です。デフォルトでは、番兵は関数呼び出しの最後の引数であると想定されています。オプションの &lt;var&gt;position&lt;/var&gt; 引数が属性に指定されている場合、センチネルは引数リストの最後から逆方向に数えた位置に &lt;var&gt;position&lt;/var&gt; する必要があります。</target>
        </trans-unit>
        <trans-unit id="3eace8a8897f53986baecdd557c9bed95be5eb95" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for cloning&amp;mdash;a mechanism that produces specialized copies of functions and which is (currently) performed by interprocedural constant propagation.</source>
          <target state="translated">この関数属性は、関数がクローン作成の対象となることを防ぎます。これは、関数の特殊なコピーを作成し、（現在）プロシージャ間の定数伝播によって実行されるメカニズムです。</target>
        </trans-unit>
        <trans-unit id="0185a8637e8440da0db0d53dd62eb7167b8eb84c" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for inlining. If the function does not have side effects, there are optimizations other than inlining that cause function calls to be optimized away, although the function call is live. To keep such calls from being optimized away, put</source>
          <target state="translated">この関数属性は、関数がインライン化の対象とされないようにします。関数に副作用がない場合、インライン化以外にも、関数呼び出しが生きているにもかかわらず、関数呼び出しが離れて最適化される原因となる最適化があります。このような呼び出しが最適化されないようにするには</target>
        </trans-unit>
        <trans-unit id="c2eae0ac690e115a386b22c2c033e3d207f73749" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a functions from being merged with another semantically equivalent function.</source>
          <target state="translated">この関数属性は、関数が他の意味的に等価な関数とマージされることを防ぎます。</target>
        </trans-unit>
        <trans-unit id="cfa0a9aeda6626f962564eda6d7bc9ae77a9f9e7" translate="yes" xml:space="preserve">
          <source>This function causes the program to exit abnormally. GCC implements this function by using a target-dependent mechanism (such as intentionally executing an illegal instruction) or by calling &lt;code&gt;abort&lt;/code&gt;. The mechanism used may vary from release to release so you should not rely on any particular implementation.</source>
          <target state="translated">この関数は、プログラムを異常終了させます。GCCは、ターゲットに依存するメカニズム（意図的に不正な命令を実行するなど）を使用するか、 &lt;code&gt;abort&lt;/code&gt; を呼び出すことによって、この関数を実装します。使用されるメカニズムはリリースごとに異なる可能性があるため、特定の実装に依存しないでください。</target>
        </trans-unit>
        <trans-unit id="e524eeb8ecfc131aac67b7d8a458ea88f19f0eed" translate="yes" xml:space="preserve">
          <source>This function does the reverse of &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; の逆を行います。</target>
        </trans-unit>
        <trans-unit id="95420bd588ca997857f34739b8ed2c2d2dc9b407" translate="yes" xml:space="preserve">
          <source>This function has the same semantics as &lt;code&gt;__builtin_expect&lt;/code&gt;, but the caller provides the expected probability that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. The last argument, &lt;var&gt;probability&lt;/var&gt;, is a floating-point value in the range 0.0 to 1.0, inclusive. The &lt;var&gt;probability&lt;/var&gt; argument must be constant floating-point expression.</source>
          <target state="translated">この関数のセマンティクスは &lt;code&gt;__builtin_expect&lt;/code&gt; と同じですが、呼び出し元は &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt; であると予想される確率を提供します。最後の引数 &lt;var&gt;probability&lt;/var&gt; は、0.0〜1.0の範囲の浮動小数点値です。 &lt;var&gt;probability&lt;/var&gt; 引数は、浮動小数点定数式でなければなりません。</target>
        </trans-unit>
        <trans-unit id="dad1828780de0ec7cb4d2651f782e659f7669888" translate="yes" xml:space="preserve">
          <source>This function is a &lt;code&gt;nop&lt;/code&gt; on the PowerPC platform and is included solely to maintain API compatibility with the x86 builtins.</source>
          <target state="translated">この関数はPowerPCプラットフォームの &lt;code&gt;nop&lt;/code&gt; であり、x86ビルトインとのAPI互換性を維持するためにのみ含まれています。</target>
        </trans-unit>
        <trans-unit id="cc1de5cdd4f293c4a48810df067ace8dfe7d6d91" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;__builtin_return_address&lt;/code&gt;, but it returns the address of the function frame rather than the return address of the function. Calling &lt;code&gt;__builtin_frame_address&lt;/code&gt; with a value of &lt;code&gt;0&lt;/code&gt; yields the frame address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the frame address of the caller of the current function, and so forth.</source>
          <target state="translated">この関数は &lt;code&gt;__builtin_return_address&lt;/code&gt; に似ていますが、関数の戻りアドレスではなく、関数フレームのアドレスを返します。呼び出し &lt;code&gt;__builtin_frame_address&lt;/code&gt; の値に &lt;code&gt;0&lt;/code&gt; 収率現在の関数のフレームアドレスを、値 &lt;code&gt;1&lt;/code&gt; は、現在の関数の呼び出し元のフレームアドレスが得られる、等。</target>
        </trans-unit>
        <trans-unit id="a0b7342f9f274d12e577265101ded1a69579dafe" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the &lt;code&gt;__FUNCTION__&lt;/code&gt; symbol and returns an address constant pointing to the name of the function from which the built-in was invoked, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the name of &lt;var&gt;F&lt;/var&gt;&amp;rsquo;s caller or the empty string if the call was not made at function scope.</source>
          <target state="translated">この関数は &lt;code&gt;__FUNCTION__&lt;/code&gt; シンボルと同等であり、組み込みが呼び出された関数の名前を指すアドレス定数を返します。呼び出しが関数のスコープにない場合は空の文字列を返します。関数 &lt;var&gt;F&lt;/var&gt; の C ++デフォルト引数として使用すると、関数のスコープで呼び出しが行われなかった場合は、 &lt;var&gt;F&lt;/var&gt; の呼び出し元の名前または空の文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="86e1f1b709cdf3bbdf962d668f4ccf9699d7ee2e" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__FILE__&lt;/code&gt; macro and returns an address constant pointing to the file name containing the invocation of the built-in, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the file name of the call to &lt;var&gt;F&lt;/var&gt; or the empty string if the call was not made at function scope.</source>
          <target state="translated">この関数は、プリプロセッサの &lt;code&gt;__FILE__&lt;/code&gt; マクロと同等であり、組み込みの呼び出しを含むファイル名を指すアドレス定数を返します。呼び出しが関数のスコープにない場合は空の文字列を返します。関数 &lt;var&gt;F&lt;/var&gt; の C ++デフォルト引数として使用すると、 &lt;var&gt;F&lt;/var&gt; への呼び出しのファイル名、または関数のスコープで呼び出しが行われなかった場合は空の文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="bc294999db99ded1854e8f5e1e4b8ef679553e0d" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__LINE__&lt;/code&gt; macro and returns a constant integer expression that evaluates to the line number of the invocation of the built-in. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the line number of the call to &lt;var&gt;F&lt;/var&gt;.</source>
          <target state="translated">この関数は、プリプロセッサーの &lt;code&gt;__LINE__&lt;/code&gt; マクロと同等であり、組み込みの呼び出しの行番号に評価される定数整数式を返します。関数 &lt;var&gt;F&lt;/var&gt; の C ++デフォルト引数として使用すると、 &lt;var&gt;F&lt;/var&gt; の呼び出しの行番号が返されます。</target>
        </trans-unit>
        <trans-unit id="b4965b81131ff05edb23e4ac2cd86ee54e42a982" translate="yes" xml:space="preserve">
          <source>This function is used to flush the processor&amp;rsquo;s instruction cache for the region of memory between &lt;var&gt;begin&lt;/var&gt; inclusive and &lt;var&gt;end&lt;/var&gt; exclusive. Some targets require that the instruction cache be flushed, after modifying memory containing code, in order to obtain deterministic behavior.</source>
          <target state="translated">この関数は、包括的 &lt;var&gt;begin&lt;/var&gt; と排他的 &lt;var&gt;end&lt;/var&gt; 間のメモリ領域のプロセッサの命令キャッシュをフラッシュするために使用されます。一部のターゲットでは、確定的な動作を得るために、コードを含むメモリを変更した後、命令キャッシュをフラッシュする必要があります。</target>
        </trans-unit>
        <trans-unit id="a3fe2b1a97278967d04d0a166eb411721a963d62" translate="yes" xml:space="preserve">
          <source>This function is used to minimize cache-miss latency by moving data into a cache before it is accessed. You can insert calls to &lt;code&gt;__builtin_prefetch&lt;/code&gt; into code for which you know addresses of data in memory that is likely to be accessed soon. If the target supports them, data prefetch instructions are generated. If the prefetch is done early enough before the access then the data will be in the cache by the time it is accessed.</source>
          <target state="translated">この関数は、データがアクセスされる前にデータをキャッシュに移動することにより、キャッシュミスのレイテンシを最小限に抑えるために使用されます。 &lt;code&gt;__builtin_prefetch&lt;/code&gt; への呼び出しを、すぐにアクセスされる可能性が高いメモリ内のデータのアドレスがわかっているコードに挿入できます。ターゲットがそれらをサポートしている場合、データのプリフェッチ命令が生成されます。アクセスの前にプリフェッチが十分に早く行われた場合、データはアクセスされるまでにキャッシュ内にあります。</target>
        </trans-unit>
        <trans-unit id="8919a966ee8dd6af4dbf0f92a03208a705be1969" translate="yes" xml:space="preserve">
          <source>This function restores the stack context in &lt;var&gt;buf&lt;/var&gt;, saved by a previous call to &lt;code&gt;__builtin_setjmp&lt;/code&gt;. After &lt;code&gt;__builtin_longjmp&lt;/code&gt; is finished, the program resumes execution as if the matching &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns the value &lt;var&gt;val&lt;/var&gt;, which must be 1.</source>
          <target state="translated">この関数は、前の &lt;code&gt;__builtin_setjmp&lt;/code&gt; の呼び出しで保存されたスタックコンテキストを &lt;var&gt;buf&lt;/var&gt; に復元します。後 &lt;code&gt;__builtin_longjmp&lt;/code&gt; を終了し、一致するかのように、プログラムが実行を再開 &lt;code&gt;__builtin_setjmp&lt;/code&gt; が値を返し &lt;var&gt;val&lt;/var&gt; 1でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d321f2ee318af6c2dd764431e17a984bfaa18ec1" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to data describing how to return whatever value is returned by &lt;var&gt;function&lt;/var&gt;. The data is saved in a block of memory allocated on the stack.</source>
          <target state="translated">この関数は、によって返されるどのような値を返す方法を説明したデータへのポインタを返す &lt;var&gt;function&lt;/var&gt; 。データは、スタックに割り当てられたメモリのブロックに保存されます。</target>
        </trans-unit>
        <trans-unit id="b71039af8a1d11c8d83124bcb2f420630a5a1ce8" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following CPU names can be detected:</source>
          <target state="translated">この関数は、ランタイムCPUのタイプが &lt;var&gt;cpuname&lt;/var&gt; の場合は正の整数を返し、それ以外の場合は &lt;code&gt;0&lt;/code&gt; を返します。次のCPU名を検出できます。</target>
        </trans-unit>
        <trans-unit id="dfdc7462f357d955c59d1a21b41e74d15ee8d83b" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU supports &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following features can be detected:</source>
          <target state="translated">この関数は、ランタイムCPUが &lt;var&gt;feature&lt;/var&gt; をサポートしている場合は正の整数を返し、それ以外の場合は &lt;code&gt;0&lt;/code&gt; を返します。次の機能を検出できます。</target>
        </trans-unit>
        <trans-unit id="5bf6bbb0ff1bf6eb1b3c656f4cca7e925e10e2a5" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise</source>
          <target state="translated">この関数は、ランタイムCPUのタイプが &lt;var&gt;cpuname&lt;/var&gt; の場合は値 &lt;code&gt;1&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;0&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="27852be90385733f670b1f53118c6fb5c9f99598" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU supports the HWCAP feature &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">この関数は、ランタイムCPUがHWCAP機能 &lt;var&gt;feature&lt;/var&gt; をサポートしている場合は値 &lt;code&gt;1&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;0&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="213b2aa2268e34e2f3e902cc0c4fc9d3fae623d8" translate="yes" xml:space="preserve">
          <source>This function returns its first argument, and allows the compiler to assume that the returned pointer is at least &lt;var&gt;align&lt;/var&gt; bytes aligned. This built-in can have either two or three arguments, if it has three, the third argument should have integer type, and if it is nonzero means misalignment offset. For example:</source>
          <target state="translated">この関数は最初の引数を返し、コンパイラは返されたポインタが少なくとも &lt;var&gt;align&lt;/var&gt; バイトであると想定できるようにします。この組み込みには2つまたは3つの引数を指定できます。3つある場合、3番目の引数は整数型でなければなりません。ゼロ以外の場合は、オフセットのずれを意味します。例えば：</target>
        </trans-unit>
        <trans-unit id="0dc83a066fc8a8ed7ae8cb097e4deaf1084d4a2b" translate="yes" xml:space="preserve">
          <source>This function returns the return address of the current function, or of one of its callers. The &lt;var&gt;level&lt;/var&gt; argument is number of frames to scan up the call stack. A value of &lt;code&gt;0&lt;/code&gt; yields the return address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the return address of the caller of the current function, and so forth. When inlining the expected behavior is that the function returns the address of the function that is returned to. To work around this behavior use the &lt;code&gt;noinline&lt;/code&gt; function attribute.</source>
          <target state="translated">この関数は、現在の関数またはその呼び出し元の1つの戻りアドレスを返します。 &lt;var&gt;level&lt;/var&gt; 引数は、コールスタックをスキャンするフレームの数です。値 &lt;code&gt;0&lt;/code&gt; は現在の関数の戻りアドレスを生成し、値 &lt;code&gt;1&lt;/code&gt; は現在の関数の呼び出し元の戻りアドレスを生成し、以下同様に続きます。期待される動作をインライン化するときは、関数は、返される関数のアドレスを返します。この動作を回避するには、 &lt;code&gt;noinline&lt;/code&gt; 関数属性を使用します。</target>
        </trans-unit>
        <trans-unit id="a8c68121ab03a5059f1b4257b6c2b3c7234cacf3" translate="yes" xml:space="preserve">
          <source>This function runs the CPU detection code to check the type of CPU and the features supported. This built-in function needs to be invoked along with the built-in functions to check CPU type and features, &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, only when used in a function that is executed before any constructors are called. The CPU detection code is automatically executed in a very high priority constructor.</source>
          <target state="translated">この関数は、CPU検出コードを実行して、CPUのタイプとサポートされる機能をチェックします。この組み込み関数は、コンストラクターが呼び出される前に実行される関数で使用された場合にのみ、CPUのタイプと機能をチェックするための組み込み関数、 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; および &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; と共に呼び出す必要があります。CPU検出コードは、非常に優先度の高いコンストラクタで自動的に実行されます。</target>
        </trans-unit>
        <trans-unit id="0f58a4af763a22a01173db535b0e84cbf679fc29" translate="yes" xml:space="preserve">
          <source>This function saves the current stack context in &lt;var&gt;buf&lt;/var&gt;. &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns 0 when returning directly, and 1 when returning from &lt;code&gt;__builtin_longjmp&lt;/code&gt; using the same &lt;var&gt;buf&lt;/var&gt;.</source>
          <target state="translated">この関数は、現在のスタックコンテキストを &lt;var&gt;buf&lt;/var&gt; に保存します。 &lt;code&gt;__builtin_setjmp&lt;/code&gt; は、直接戻る場合は0を返し、同じ &lt;var&gt;buf&lt;/var&gt; を使用して &lt;code&gt;__builtin_longjmp&lt;/code&gt; から戻る場合は1を返します。</target>
        </trans-unit>
        <trans-unit id="69e7849ff4cbe4d496d1ff31f3b20212a375c758" translate="yes" xml:space="preserve">
          <source>This function, if given a string literal all of which would have been consumed by &lt;code&gt;strtol&lt;/code&gt;, is evaluated early enough that it is considered a compile-time constant.</source>
          <target state="translated">この関数は、文字列リテラルが与えられた場合、そのすべてが &lt;code&gt;strtol&lt;/code&gt; によって消費されるはずでしたが、コンパイル時定数と見なされるのに十分早く評価されます。</target>
        </trans-unit>
        <trans-unit id="1b248fa09ed8681d529d9f22aaa2c70eb149364a" translate="yes" xml:space="preserve">
          <source>This has symmetry with normal static arrays, in that an array of unknown size is also written with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">これは通常の静的配列と対称的であり、サイズが不明な配列も &lt;code&gt;[]&lt;/code&gt; で書き込まれます。</target>
        </trans-unit>
        <trans-unit id="8646e863ba587311636afd56af70cd4124b64132" translate="yes" xml:space="preserve">
          <source>This has the same effect as the proper number of individual &lt;code&gt;case&lt;/code&gt; labels, one for each integer value from &lt;var&gt;low&lt;/var&gt; to &lt;var&gt;high&lt;/var&gt;, inclusive.</source>
          <target state="translated">これは、 &lt;var&gt;low&lt;/var&gt; から &lt;var&gt;high&lt;/var&gt; までの整数値ごとに1つずつ、適切な数の個別の &lt;code&gt;case&lt;/code&gt; ラベルと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="83169887a69a2b08bab1ebc54a9588ce551d545e" translate="yes" xml:space="preserve">
          <source>This hook is generally reserved for &amp;ldquo;Foundation&amp;rdquo; libraries such as GNUstep Base, which use it to implement their high-level method forwarding API, typically based around the &lt;code&gt;forwardInvocation:&lt;/code&gt; method. So, unless you are implementing your own &amp;ldquo;Foundation&amp;rdquo; library, you should not set this hook.</source>
          <target state="translated">このフックは通常、GNUstep Baseなどの「Foundation」ライブラリ用に予約されており、これを使用して、通常は &lt;code&gt;forwardInvocation:&lt;/code&gt; メソッドに基づいた高レベルのメソッド転送APIを実装します。したがって、独自の「Foundation」ライブラリを実装しているのでない限り、このフックを設定しないでください。</target>
        </trans-unit>
        <trans-unit id="968e5049fab7f4bdf3b3205d394535ad648ef39e" translate="yes" xml:space="preserve">
          <source>This i386 code demonstrates a case that does not use (or require) the &lt;code&gt;volatile&lt;/code&gt; qualifier. If it is performing assertion checking, this code uses &lt;code&gt;asm&lt;/code&gt; to perform the validation. Otherwise, &lt;code&gt;dwRes&lt;/code&gt; is unreferenced by any code. As a result, the optimizers can discard the &lt;code&gt;asm&lt;/code&gt; statement, which in turn removes the need for the entire &lt;code&gt;DoCheck&lt;/code&gt; routine. By omitting the &lt;code&gt;volatile&lt;/code&gt; qualifier when it isn&amp;rsquo;t needed you allow the optimizers to produce the most efficient code possible.</source>
          <target state="translated">このi386コードは、 &lt;code&gt;volatile&lt;/code&gt; 修飾子を使用しない（または必要としない）ケースを示しています。アサーションチェックを実行している場合、このコードは &lt;code&gt;asm&lt;/code&gt; を使用して検証を実行します。それ以外の場合、 &lt;code&gt;dwRes&lt;/code&gt; はどのコードからも参照されません。その結果、オプティマイザは &lt;code&gt;asm&lt;/code&gt; ステートメントを破棄できるため、 &lt;code&gt;DoCheck&lt;/code&gt; ルーチン全体が不要になります。 &lt;code&gt;volatile&lt;/code&gt; 修飾子が不要な場合は省略して、オプティマイザが可能な限り最も効率的なコードを生成できるようにします。</target>
        </trans-unit>
        <trans-unit id="808f6f4a24d0e37061696da154166d6ac70ac880" translate="yes" xml:space="preserve">
          <source>This implies that the choice of angle brackets or double quotes in an &amp;lsquo;</source>
          <target state="translated">これは、 '内の山括弧または二重引用符の選択が</target>
        </trans-unit>
        <trans-unit id="e1db8a962787e8ba6275999130017fe253b89359" translate="yes" xml:space="preserve">
          <source>This inserts an instruction sequence that takes exactly &lt;var&gt;cycles&lt;/var&gt; cycles (between 0 and about 17E9) to complete. The inserted sequence may use jumps, loops, or no-ops, and does not interfere with any other instructions. Note that &lt;var&gt;cycles&lt;/var&gt; must be a compile-time constant integer - that is, you must pass a number, not a variable that may be optimized to a constant later. The number of cycles delayed by this builtin is exact.</source>
          <target state="translated">これを正確にとり、挿入命令シーケンス &lt;var&gt;cycles&lt;/var&gt; 完了するために、（0〜17E9について）サイクルを。挿入されたシーケンスは、ジャンプ、ループ、またはノーオペレーションを使用でき、他の命令に干渉しません。 &lt;var&gt;cycles&lt;/var&gt; はコンパイル時の定数整数でなければならないことに注意してください。つまり、後で定数に最適化される可能性のある変数ではなく、数値を渡す必要があります。この組み込みにより遅延したサイクル数は正確です。</target>
        </trans-unit>
        <trans-unit id="8e5d39ccb505b20a7de4368cf8c74cd0bd9b0602" translate="yes" xml:space="preserve">
          <source>This instrumentation is also done for functions expanded inline in other functions. The profiling calls indicate where, conceptually, the inline function is entered and exited. This means that addressable versions of such functions must be available. If all your uses of a function are expanded inline, this may mean an additional expansion of code size. If you use &lt;code&gt;extern inline&lt;/code&gt; in your C code, an addressable version of such functions must be provided. (This is normally the case anyway, but if you get lucky and the optimizer always expands the functions inline, you might have gotten away without providing static copies.)</source>
          <target state="translated">この計測は、他の関数でインライン展開された関数に対しても行われます。プロファイリング呼び出しは、概念的にはインライン関数の開始と終了の場所を示します。これは、そのような関数のアドレス可能なバージョンが利用可能でなければならないことを意味します。関数のすべての使用がインラインで展開される場合、これはコードサイズの追加の拡張を意味する場合があります。Cコードで &lt;code&gt;extern inline&lt;/code&gt; でexternを使用する場合は、そのような関数のアドレス可能なバージョンを提供する必要があります。 （これは通常いずれにしても当てはまりますが、運がよければ、オプティマイザーが常に関数をインラインで展開する場合は、静的コピーを提供せずに回避できた可能性があります。）</target>
        </trans-unit>
        <trans-unit id="c5f757d83923a2f4750aa24fef819d39fd7c764d" translate="yes" xml:space="preserve">
          <source>This interface allows either &lt;code&gt;int *&lt;/code&gt; or &lt;code&gt;union wait *&lt;/code&gt; arguments to be passed, using the &lt;code&gt;int *&lt;/code&gt; calling convention. The program can call &lt;code&gt;wait&lt;/code&gt; with arguments of either type:</source>
          <target state="translated">このインターフェイスでは、 &lt;code&gt;int *&lt;/code&gt; 呼び出し規約を使用して、 &lt;code&gt;int *&lt;/code&gt; または &lt;code&gt;union wait *&lt;/code&gt; 引数を渡すことができます。プログラムは、次のいずれかのタイプの引数を使用して &lt;code&gt;wait&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="7fa6e20d0ad9607fec20c7fa93797725b39e7225" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible after &lt;code&gt;PSW.GIE&lt;/code&gt; (global interrupt enable) is set. This allows interrupt service routine to finish some short critical code before enabling interrupts.</source>
          <target state="translated">この割り込みサービスルーチンは、 &lt;code&gt;PSW.GIE&lt;/code&gt; （グローバル割り込みイネーブル）が設定された後に割り込み可能です。これにより、割り込みサービスルーチンは、割り込みを有効にする前に、いくつかの重要なコードを終了できます。</target>
        </trans-unit>
        <trans-unit id="f39211b611ed78b8a4cda99c2d1b9f90b52f7b8c" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible.</source>
          <target state="translated">この割込みサービスルーチンは割込み可能です。</target>
        </trans-unit>
        <trans-unit id="8cc90603ecbdd7ae47dd33c675b43de2d13b14cf" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is not interruptible.</source>
          <target state="translated">この割込みサービスルーチンは割込み可能ではありません。</target>
        </trans-unit>
        <trans-unit id="98ed58186125da377f3558ec8512de6f6dbbf8ae" translate="yes" xml:space="preserve">
          <source>This invokes all subprograms of &lt;code&gt;gcc&lt;/code&gt; under &amp;lsquo;</source>
          <target state="translated">これにより、 'の下にある &lt;code&gt;gcc&lt;/code&gt; のすべてのサブプログラムが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="36c68f63258bf418514a8d6d7b59387b054a571e" translate="yes" xml:space="preserve">
          <source>This is a 24-bit address space that linearizes flash and RAM: If the high bit of the address is set, data is read from RAM using the lower two bytes as RAM address. If the high bit of the address is clear, data is read from flash with &lt;code&gt;RAMPZ&lt;/code&gt; set according to the high byte of the address. See &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;&lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、フラッシュとRAMを線形化する24ビットのアドレス空間です。アドレスの上位ビットが設定されている場合、データはRAMアドレスとして下位2バイトを使用してRAMから読み取られます。アドレスの上位ビットがクリアされている場合、データは &lt;code&gt;RAMPZ&lt;/code&gt; がアドレスの上位バイトに従って設定された状態でフラッシュから読み取られます。&lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt; &lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c3eadc5a720e67193fff3510f3b6d516e5846adb" translate="yes" xml:space="preserve">
          <source>This is a debugging flag. When used in conjunction with</source>
          <target state="translated">これはデバッグフラグです。と一緒に使用すると</target>
        </trans-unit>
        <trans-unit id="c173adebd0002ff9b3abf598cd2d9f90729d1e99" translate="yes" xml:space="preserve">
          <source>This is a literal string that is the template for the assembler code. It is a combination of fixed text and tokens that refer to the input, output, and goto parameters. See &lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplate&lt;/a&gt;.</source>
          <target state="translated">これは、アセンブラコードのテンプレートであるリテラル文字列です。これは、入力、出力、およびgotoパラメーターを参照する固定テキストとトークンの組み合わせです。&lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplateを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0266778a01da6e94c7dbdd70401e030bc44b9214" translate="yes" xml:space="preserve">
          <source>This is a literal string that specifies the assembler code. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input.</source>
          <target state="translated">これはアセンブラのコードを指定するリテラル文字列です。この文字列には、ディレクティブを含め、アセンブラが認識する全ての命令を含めることができます。GCC はアセンブラ命令自体を解析しませんので、それが何を意味するのか、それが有効なアセンブラ入力であるかどうかさえわかりません。</target>
        </trans-unit>
        <trans-unit id="b220cd2425897f657363d80f6f8c621c9e9dc4d4" translate="yes" xml:space="preserve">
          <source>This is a more fine-grained version of</source>
          <target state="translated">の方が細かくなっています。</target>
        </trans-unit>
        <trans-unit id="210265ec50f329c0444d753e710536de44906855" translate="yes" xml:space="preserve">
          <source>This is a property of the linker. C99 and C11 require that case distinctions are always significant in identifiers with external linkage and systems without this property are not supported by GCC.</source>
          <target state="translated">これはリンカのプロパティです。C99およびC11では、外部リンクを持つ識別子では常に大文字小文字の区別が重要であることが要求されており、このプロパティを持たないシステムはGCCではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="efc75a30c66eb95f41ba11f1badfcb67f0cc09c0" translate="yes" xml:space="preserve">
          <source>This is a set of options that are used to explicitly disable/enable optimization passes. These options are intended for use for debugging GCC. Compiler users should use regular options for enabling/disabling passes instead.</source>
          <target state="translated">これは、最適化パスを明示的に無効にしたり有効にしたりするために使用するオプションのセットです。これらのオプションは、GCC のデバッグに使用することを意図しています。コンパイラのユーザは、パスの有効化/無効化に通常のオプションを使用してください。</target>
        </trans-unit>
        <trans-unit id="c7a5bbf22b220bbd15b9398c9ef72c66a3e9df59" translate="yes" xml:space="preserve">
          <source>This is a synonym for</source>
          <target state="translated">の同義語です。</target>
        </trans-unit>
        <trans-unit id="fe3ee5c4bc9712f6bcac0ed8f03115711a2bebe4" translate="yes" xml:space="preserve">
          <source>This is an acceptable initializer even if &lt;var&gt;EXPRESSION&lt;/var&gt; is not a constant expression, including the case where &lt;code&gt;__builtin_constant_p&lt;/code&gt; returns 1 because &lt;var&gt;EXPRESSION&lt;/var&gt; can be folded to a constant but &lt;var&gt;EXPRESSION&lt;/var&gt; contains operands that are not otherwise permitted in a static initializer (for example, &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt;). GCC must be more conservative about evaluating the built-in in this case, because it has no opportunity to perform optimization.</source>
          <target state="translated">これはあっても許容されるイニシャライザで &lt;var&gt;EXPRESSION&lt;/var&gt; 場合を含む定数式でない &lt;code&gt;__builtin_constant_p&lt;/code&gt; ため戻っ1 &lt;var&gt;EXPRESSION&lt;/var&gt; 一定に折り畳むことができるが、 &lt;var&gt;EXPRESSION&lt;/var&gt; そうでない場合（例えば、初期化子静的に許可されていないオペランド含ま &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt; ）。GCCは、最適化を実行する機会がないため、この場合の組み込みの評価についてより保守的でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e0aaa7cf6754c8cbdc72fa557e1be8935391e808" translate="yes" xml:space="preserve">
          <source>This is an advanced section. Type encodings are used extensively by the compiler and by the runtime, but you generally do not need to know about them to use Objective-C.</source>
          <target state="translated">これは上級者向けのセクションです。型エンコーディングはコンパイラとランタイムによって広範囲に使用されますが、Objective-Cを使用するためには一般的には知る必要はありません。</target>
        </trans-unit>
        <trans-unit id="7f363131e14be21e154381e2dda1e3e5a071a820" translate="yes" xml:space="preserve">
          <source>This is an alternative to creating a union with a &lt;code&gt;double&lt;/code&gt; member, which forces the union to be double-word aligned.</source>
          <target state="translated">これは、 &lt;code&gt;double&lt;/code&gt; メンバーを使用してユニオンを作成する代わりの方法です。これにより、ユニオンはダブルワードで整列されます。</target>
        </trans-unit>
        <trans-unit id="07d312a53d8e7c9544d42f284a8fb92ee207ce56" translate="yes" xml:space="preserve">
          <source>This is an implementation of the ISO C99 function &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">これは、ISO C99関数 &lt;code&gt;nan&lt;/code&gt; の実装です。</target>
        </trans-unit>
        <trans-unit id="6bb58cdaec11ea8785a298afd036692620cb8a71" translate="yes" xml:space="preserve">
          <source>This is because 2147483648 cannot fit in the type &lt;code&gt;int&lt;/code&gt;, so (following the ISO C rules) its data type is &lt;code&gt;unsigned long int&lt;/code&gt;. Negating this value yields 2147483648 again.</source>
          <target state="translated">これは、2147483648が &lt;code&gt;int&lt;/code&gt; 型に収まらないため、（ISO C規則に従って）データ型が &lt;code&gt;unsigned long int&lt;/code&gt; であるためです。この値を否定すると、再び2147483648になります。</target>
        </trans-unit>
        <trans-unit id="cbcf60838e5c265166bf0d438d003168c4b74356" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are considered relevant with</source>
          <target state="translated">これは、関連性があると考えられる呼び出しに適用されます。</target>
        </trans-unit>
        <trans-unit id="5195f538541a2304ddd489646469dec48a8ccb37" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are optimized for size. Small growth may be desirable to anticipate optimization oppurtunities exposed by inlining.</source>
          <target state="translated">これは、サイズが最適化されたコールに適用されます。インライン化によって露出する最適化の機会を見越して、小さな成長が望ましいかもしれません。</target>
        </trans-unit>
        <trans-unit id="6762670483f9855e0a3aefbae371bb5703501c2b" translate="yes" xml:space="preserve">
          <source>This is called a &lt;em&gt;matching constraint&lt;/em&gt; and what it really means is that the assembler has only a single operand that fills two roles which &lt;code&gt;asm&lt;/code&gt; distinguishes. For example, an add instruction uses two input operands and an output operand, but on most CISC machines an add instruction really has only two operands, one of them an input-output operand:</source>
          <target state="translated">これは&lt;em&gt;マッチング制約&lt;/em&gt;と呼ばれ、それが実際に意味することは、アセンブラには &lt;code&gt;asm&lt;/code&gt; が区別する2つの役割を満たす単一のオペランドしかないということです。たとえば、add命令は2つの入力オペランドと1つの出力オペランドを使用しますが、ほとんどのCISCマシンでは実際にadd命令には2つのオペランドしかなく、そのうちの1つは入出力オペランドです。</target>
        </trans-unit>
        <trans-unit id="c074cd27c3a79447115b4b73b7a639c3b4fa2a8e" translate="yes" xml:space="preserve">
          <source>This is currently implemented using the stronger &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; memory order because of a deficiency in C++11&amp;rsquo;s semantics for &lt;code&gt;memory_order_consume&lt;/code&gt;.</source>
          <target state="translated">これは現在、C ++ 11の &lt;code&gt;memory_order_consume&lt;/code&gt; のセマンティクスに欠陥があるため、より強力な &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; メモリ順序を使用して実装されています。</target>
        </trans-unit>
        <trans-unit id="2b3d9a8a2627972c9a778aee53c0d0ec3f855978" translate="yes" xml:space="preserve">
          <source>This is dependent on the implementation of the C library, and is not defined by GCC itself.</source>
          <target state="translated">これはCライブラリの実装に依存しており、GCC自体では定義されていません。</target>
        </trans-unit>
        <trans-unit id="9b7b67a920492c1fed38bbae2d29e3b5c143fedc" translate="yes" xml:space="preserve">
          <source>This is enabled by default when outputting DWARF 2 debug information at the normal level, as long as there is assembler support,</source>
          <target state="translated">これは、アセンブラがサポートされている限り、DWARF 2 のデバッグ情報を通常のレベルで出力する際にデフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="99ef91485a4d9927171b8579ed4d91ac7ed3d923" translate="yes" xml:space="preserve">
          <source>This is equivalent to writing the following:</source>
          <target state="translated">これは、以下のように書くことに相当します。</target>
        </trans-unit>
        <trans-unit id="aebe9f9ed1ec955a9599f55edc4af825e40a4ee7" translate="yes" xml:space="preserve">
          <source>This is generally desirable, because assembler-generated line-number tables are a lot more compact than those the compiler can generate itself.</source>
          <target state="translated">アセンブラで生成された行番号テーブルは、コンパイラが自分で生成するよりもずっとコンパクトなので、一般的にはこれが望ましいです。</target>
        </trans-unit>
        <trans-unit id="bfbcbb929b36a00d46e328a1a9742a8d812ee911" translate="yes" xml:space="preserve">
          <source>This is how GCC traditionally handled functions declared &lt;code&gt;inline&lt;/code&gt;. Since ISO C99 specifies a different semantics for &lt;code&gt;inline&lt;/code&gt;, this function attribute is provided as a transition measure and as a useful feature in its own right. This attribute is available in GCC 4.1.3 and later. It is available if either of the preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; or &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; are defined. See &lt;a href=&quot;inline#Inline&quot;&gt;An Inline Function is As Fast As a Macro&lt;/a&gt;.</source>
          <target state="translated">これは、GCCが従来 &lt;code&gt;inline&lt;/code&gt; 宣言された関数を処理する方法です。ISO C99は &lt;code&gt;inline&lt;/code&gt; に異なるセマンティクスを指定しているため、この関数属性は、遷移測定として、およびそれ自体で有用な機能として提供されます。この属性は、GCC 4.1.3以降で使用できます。プリプロセッサマクロ &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; または &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; のいずれかが定義されている場合に使用できます。「&lt;a href=&quot;inline#Inline&quot;&gt;インライン関数はマクロと同じくらい高速です&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="3659f6c91bb02b5cd8a55719f9462825417fbf7f" translate="yes" xml:space="preserve">
          <source>This is in all ways equivalent to the ISO C example above, but arguably more readable and descriptive.</source>
          <target state="translated">これは、あらゆる意味で上記のISO Cの例と同等であるが、間違いなく、より読みやすく、記述的である。</target>
        </trans-unit>
        <trans-unit id="e833378dc7330796a80aef851e1b40fc5a1e0901" translate="yes" xml:space="preserve">
          <source>This is just like &amp;lsquo;</source>
          <target state="translated">これはちょうどのようです</target>
        </trans-unit>
        <trans-unit id="87943af8f7660938d198a190217b23c8ea1f6e48" translate="yes" xml:space="preserve">
          <source>This is like</source>
          <target state="translated">こんな感じです。</target>
        </trans-unit>
        <trans-unit id="37d0e0a31c79678362e2daef4bb85a617b64f850" translate="yes" xml:space="preserve">
          <source>This is more friendly to code living in shared libraries, as it reduces the number of dynamic relocations that are needed, and by consequence, allows the data to be read-only. This alternative with label differences is not supported for the AVR target, please use the first approach for AVR programs.</source>
          <target state="translated">これは必要とされる動的再配置の数を減らし、結果的にデータを読み取り専用にすることができるので、共有ライブラリに住むコードにはより親切です。ラベルの違いを持つこの代替案はAVRターゲットではサポートされていませんので、AVRプログラムには最初のアプローチを使用してください。</target>
        </trans-unit>
        <trans-unit id="52f8a99adebca7a079e1f334d570e3be716912f1" translate="yes" xml:space="preserve">
          <source>This is not correct on x86-64 as it would allocate tick in either &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. You have to use the following variant instead:</source>
          <target state="translated">x86-64では、 &lt;code&gt;ax&lt;/code&gt; または &lt;code&gt;dx&lt;/code&gt; のいずれかにティックを割り当てるため、これは正しくありません。代わりに次のバリアントを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="73c90434e16b0f55c0b872ec23da22fc830bc9a4" translate="yes" xml:space="preserve">
          <source>This is particularly useful for assumed-shape arrays in Fortran where (for example) it allows better vectorization assuming contiguous accesses. This flag is enabled by default at</source>
          <target state="translated">これはFortranの仮定形状配列で特に有用であり,(例えば)連続したアクセスを仮定したより良いベクトル化を可能にします.このフラグはデフォルトでは</target>
        </trans-unit>
        <trans-unit id="031672016e4d502c018309428e47661800aac1a9" translate="yes" xml:space="preserve">
          <source>This is similar to</source>
          <target state="translated">に似ています。</target>
        </trans-unit>
        <trans-unit id="b5bdec22d274cc0ce57cbe3e424189dc32fd8d9a" translate="yes" xml:space="preserve">
          <source>This is the C variable or expression being passed to the &lt;code&gt;asm&lt;/code&gt; statement as input. The enclosing parentheses are a required part of the syntax.</source>
          <target state="translated">これは、入力として &lt;code&gt;asm&lt;/code&gt; ステートメントに渡されるC変数または式です。括弧は構文の必須部分です。</target>
        </trans-unit>
        <trans-unit id="08fb1a095794b3c3899440175335ee88759da275" translate="yes" xml:space="preserve">
          <source>This is the default (normal) setting. The only traps that are enabled are the ones that cannot be disabled in software (e.g., division by zero trap).</source>
          <target state="translated">これはデフォルト(通常)の設定です。有効になっているのは、ソフトウェアで無効にできないトラップ(例:ゼロによる除算トラップ)のみです。</target>
        </trans-unit>
        <trans-unit id="1a4c45120ca7a63ffc2a2ee3465224f90ffe09ce" translate="yes" xml:space="preserve">
          <source>This is the default choice for non-Darwin x86-32 targets.</source>
          <target state="translated">これは、非Darwin x86-32ターゲットのデフォルトの選択です。</target>
        </trans-unit>
        <trans-unit id="59c124a9358a8d1126f10890f1eb504cdd7df946" translate="yes" xml:space="preserve">
          <source>This is the default choice for the x86-64 compiler, Darwin x86-32 targets, and the default choice for x86-32 targets with the SSE2 instruction set when</source>
          <target state="translated">これは、x86-64 コンパイラ、Darwin x86-32 ターゲットのデフォルトの選択であり、SSE2 命令セットを使用する x86-32 ターゲットのデフォルトの選択です。</target>
        </trans-unit>
        <trans-unit id="a72e96be7931cf0f817380bd16aa70bcfafbbfe8" translate="yes" xml:space="preserve">
          <source>This is the default warning level of</source>
          <target state="translated">のデフォルトの警告レベルです。</target>
        </trans-unit>
        <trans-unit id="2cf92c2da398ed082aa03bcf05470475390ec8ef" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic exchange. It stores the contents of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The original value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is copied into &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、アトミック交換の一般的なバージョンです。 &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; の内容を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に格納します。 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; の元の値は &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt; にコピーされます。</target>
        </trans-unit>
        <trans-unit id="544eb750f0727dd454c0757327b302d011f9d8e4" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic load. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; in &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、アトミックロードの一般的なバージョンです。それはの内容を返す &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 中で &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21175b474269d19f2c711f8904d430397eb7f000" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic store. It stores the value of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、アトミックストアの汎用バージョンです。 &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; の値を &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; に格納します。</target>
        </trans-unit>
        <trans-unit id="38581f9b32f6622e3fe0d5bb58e5ec8a4bb25cbf" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with round-to-nearest-or-even rounding mode.</source>
          <target state="translated">これは、浮動小数点演算を行う際に使用されるモードで、ラウンド・トゥ・ニアレストまたはイーブンの丸めモードを使用します。</target>
        </trans-unit>
        <trans-unit id="2425d7e7a37939aa94f7a4685eaf2c7dc785155a" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with truncating (i.e. round towards zero) rounding mode. That includes conversion from floating point to integer.</source>
          <target state="translated">これは、切り捨て(つまりゼロに向かって丸める)丸めモードを持つ浮動小数点演算に使用されるモードです。これには、浮動小数点から整数への変換も含まれます。</target>
        </trans-unit>
        <trans-unit id="35b95ca7a0555a082526c5eeface6f56baa751e7" translate="yes" xml:space="preserve">
          <source>This is the mode used to perform integer calculations in the FPU, e.g. integer multiply, or integer multiply-and-accumulate.</source>
          <target state="translated">これは、FPUで整数計算を実行するために使用されるモードで、例えば、整数の乗算、または整数の乗算と累積などがあります。</target>
        </trans-unit>
        <trans-unit id="4098e33c6565f575396e0bc34dbbf7c96adebca6" translate="yes" xml:space="preserve">
          <source>This is the same as &amp;lsquo;</source>
          <target state="translated">これは同じです</target>
        </trans-unit>
        <trans-unit id="63f530e06bab16bd703cfd6e987a5d2afe910c22" translate="yes" xml:space="preserve">
          <source>This is the simplest option, but also offers flexibility and fine-grained control when necessary. It is also the most portable alternative and programs using this approach will work with most modern compilers.</source>
          <target state="translated">これは最もシンプルなオプションですが、柔軟性があり、必要に応じて細かく制御することができます。また、これは最も移植性の高い代替手段であり、この方法を使用したプログラムはほとんどの最新のコンパイラで動作します。</target>
        </trans-unit>
        <trans-unit id="92ad0261cb0958c1d426eccb32a1c93544a5dc43" translate="yes" xml:space="preserve">
          <source>This is the warning level of</source>
          <target state="translated">の警告レベルです。</target>
        </trans-unit>
        <trans-unit id="77e89dce84a517cc123ca42eb8de81a6643ce569" translate="yes" xml:space="preserve">
          <source>This is the warning level that is enabled by</source>
          <target state="translated">これは</target>
        </trans-unit>
        <trans-unit id="760cf4bac038578756206c93dae00fb9cba073c6" translate="yes" xml:space="preserve">
          <source>This is typical output:</source>
          <target state="translated">これが典型的な出力です。</target>
        </trans-unit>
        <trans-unit id="da7f2d31c6f9672e3ba4ae5efbb305bb596a464e" translate="yes" xml:space="preserve">
          <source>This is useful when &lt;code&gt;gcc&lt;/code&gt; prints the error message &amp;lsquo;</source>
          <target state="translated">これは、 &lt;code&gt;gcc&lt;/code&gt; がエラーメッセージを出力する場合に便利です'</target>
        </trans-unit>
        <trans-unit id="61900c28d4f89d472663c0fb34d75c4a85cd7c53" translate="yes" xml:space="preserve">
          <source>This is useful when you use</source>
          <target state="translated">を使うときに便利です。</target>
        </trans-unit>
        <trans-unit id="f021b4a2b4ebd3ad97c6de7e5e1dd3f9efc1450f" translate="yes" xml:space="preserve">
          <source>This is why GCC does and will treat plain bit-fields in the same fashion on all types of machines (by default).</source>
          <target state="translated">これが、GCCがプレーンなビットフィールドをすべてのタイプのマシン上で同じ方法で扱う理由です(デフォルトでは)。</target>
        </trans-unit>
        <trans-unit id="700e39a7f2669dafee2d84e8e1e01bff08feb798" translate="yes" xml:space="preserve">
          <source>This macro reflects the</source>
          <target state="translated">このマクロは</target>
        </trans-unit>
        <trans-unit id="1653245bf51b1f0c3c2fa674b4064d9aab7d9670" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 9.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="translated">このマニュアルでは、GNUコンパイラの使用方法、その機能と非互換性、およびバグの報告方法について説明します。コンパイラ（GCC）バージョン9.2.0に対応しています。新しいターゲットに移植する方法や、新しい言語のフロントエンドを作成する方法に関する情報など、GNUコンパイラの内部については、別のマニュアルに記載されています。GNUコンパイラコレクション（GCC）の内部の&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;概要&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d1e0ea996271f7db110a1aacecb995078842dd10" translate="yes" xml:space="preserve">
          <source>This mechanism is not intended to be a replacement for &lt;code&gt;+initialize&lt;/code&gt;. You should be aware of its limitations when you decide to use it instead of &lt;code&gt;+initialize&lt;/code&gt;.</source>
          <target state="translated">このメカニズムは、 &lt;code&gt;+initialize&lt;/code&gt; の代わりになるものではありません。 &lt;code&gt;+initialize&lt;/code&gt; の代わりに使用する場合は、その制限に注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="0b86e98dae575f25e7dd277f55069259f5a76e0f" translate="yes" xml:space="preserve">
          <source>This might appear strange; if an insn allows a constant operand with a value not known at compile time, it certainly must allow any known value. So why use &amp;lsquo;</source>
          <target state="translated">これは奇妙に見えるかもしれません。insnがコンパイル時に不明な値を持つ定数オペランドを許可する場合、既知の値を許可する必要があります。だからなぜ使用する '</target>
        </trans-unit>
        <trans-unit id="93b2398d0b07a68172b830b044a2e5af1fdcea09" translate="yes" xml:space="preserve">
          <source>This number is allowed to be more than a single digit. If multiple digits are encountered consecutively, they are interpreted as a single decimal integer. There is scant chance for ambiguity, since to-date it has never been desirable that &amp;lsquo;</source>
          <target state="translated">この番号は、1桁以上にすることができます。複数の数字が連続して出現する場合、それらは単一の10進整数として解釈されます。今日までそれが望ましくなかったので、あいまいさの可能性はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="22e75e50204b22e1eb4e9e0ef88e476b337f8735" translate="yes" xml:space="preserve">
          <source>This occurs because sometimes GCC optimizes the variable out of existence. There is no way to tell the debugger how to compute the value such a variable &amp;ldquo;would have had&amp;rdquo;, and it is not clear that would be desirable anyway. So GCC simply does not mention the eliminated variable when it writes debugging information.</source>
          <target state="translated">これは、GCCが存在しない変数を最適化する場合があるために発生します。そのような変数が「持っていたはず」の値を計算する方法をデバッガーに指示する方法はなく、それがいずれにしても望ましいかは明確ではありません。そのため、GCCはデバッグ情報を書き込むときに、削除された変数については言及しません。</target>
        </trans-unit>
        <trans-unit id="5ce0fa0b0cabdd9e15b52efa7f6d71eba5c1f802" translate="yes" xml:space="preserve">
          <source>This only makes sense when scheduling after register allocation, i.e. with</source>
          <target state="translated">これは、レジスタの割り当て後にスケジューリングを行う場合にのみ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="db13c5371ec3d6856069cde7f84c42a79ba4d667" translate="yes" xml:space="preserve">
          <source>This optimization is automatically turned off in the presence of exception handling or unwind tables (on targets using setjump/longjump or target specific scheme), for linkonce sections, for functions with a user-defined section attribute and on any architecture that does not support named sections. When</source>
          <target state="translated">この最適化は、例外処理やアンワインドテーブル(setjump/longjump またはターゲット固有のスキームを使用するターゲット)、linkonce セクション、ユーザー定義のセクション属性を持つ関数、および名前付きセクションをサポートしないアーキテクチャでは、自動的にオフになります。以下のような場合には、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="03a904b6f6255ac7a46cba1abdfa2fc80dcd97c1" translate="yes" xml:space="preserve">
          <source>This optimization is enabled by default.</source>
          <target state="translated">この最適化はデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="cd622740636a8f6bc187abc5bbcb4be9fb8826dc" translate="yes" xml:space="preserve">
          <source>This optimization is off by default at all optimization levels.</source>
          <target state="translated">この最適化は、すべての最適化レベルでデフォルトではオフになっています。</target>
        </trans-unit>
        <trans-unit id="96c9c932cfd47ab32407f6161d42f932d1499bb6" translate="yes" xml:space="preserve">
          <source>This option allows further control over excess precision on machines where floating-point operations occur in a format with more precision or range than the IEEE standard and interchange floating-point types. By default,</source>
          <target state="translated">このオプションは、浮動小数点演算がIEEE標準よりも高い精度または範囲のフォーマットで行われ、浮動小数点型を交換するようなマシンで、過剰な精度をさらに制御することを可能にします。デフォルトでは</target>
        </trans-unit>
        <trans-unit id="0cd275b48533fab7a99c41cb026721abbe83dfbd" translate="yes" xml:space="preserve">
          <source>This option allows use of a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) together with</source>
          <target state="translated">このオプションを使用すると、プリコンパイル済みヘッダー（「&lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;プリ&lt;/a&gt;コンパイル済みヘッダー」を参照）と一緒に使用できます</target>
        </trans-unit>
        <trans-unit id="176e6d10a5020dcedfe440b551f5e25423a91471" translate="yes" xml:space="preserve">
          <source>This option also enables</source>
          <target state="translated">このオプションでは、次のことも可能になります。</target>
        </trans-unit>
        <trans-unit id="44de7a78056937b7baedfa3be44429b20f8420b9" translate="yes" xml:space="preserve">
          <source>This option also warns when &lt;code&gt;alloca&lt;/code&gt; is used in a loop.</source>
          <target state="translated">このオプションは、 &lt;code&gt;alloca&lt;/code&gt; がループで使用されているときにも警告します。</target>
        </trans-unit>
        <trans-unit id="8dcb0d8b589589b99a6d5de3a4fa4b5fc06db20b" translate="yes" xml:space="preserve">
          <source>This option also warns when a non-volatile automatic variable might be changed by a call to &lt;code&gt;longjmp&lt;/code&gt;. The compiler sees only the calls to &lt;code&gt;setjmp&lt;/code&gt;. It cannot know where &lt;code&gt;longjmp&lt;/code&gt; will be called; in fact, a signal handler could call it at any point in the code. As a result, you may get a warning even when there is in fact no problem because &lt;code&gt;longjmp&lt;/code&gt; cannot in fact be called at the place that would cause a problem.</source>
          <target state="translated">このオプションは、 &lt;code&gt;longjmp&lt;/code&gt; の呼び出しによって不揮発性自動変数が変更される可能性がある場合にも警告します。コンパイラーは、 &lt;code&gt;setjmp&lt;/code&gt; の呼び出しのみを認識します。 &lt;code&gt;longjmp&lt;/code&gt; が呼び出される場所を知ることはできません。実際、シグナルハンドラーはコードの任意の時点でそれを呼び出すことができます。その結果、問題が発生する場所で &lt;code&gt;longjmp&lt;/code&gt; を実際に呼び出すことができないため、実際には問題がない場合でも警告が表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="647a82f2f84be9cba875128f0dca433a10d57f59" translate="yes" xml:space="preserve">
          <source>This option and its counterpart,</source>
          <target state="translated">このオプションとそれに対応するもの。</target>
        </trans-unit>
        <trans-unit id="51f89764d458f9e6ce2a9e5debf60911dcf32abd" translate="yes" xml:space="preserve">
          <source>This option can be overridden for individual functions with the &lt;code&gt;hotpatch&lt;/code&gt; attribute.</source>
          <target state="translated">このオプションは、 &lt;code&gt;hotpatch&lt;/code&gt; 属性を持つ個々の関数に対してオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="6031ab076087301a6d0abbb423cf52dcdfaad6ad" translate="yes" xml:space="preserve">
          <source>This option can be used with</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="ffe3df6bb53541974a1831b4cc4d1b56a60baa8e" translate="yes" xml:space="preserve">
          <source>This option can lead to reduced code size for functions that perform several calls to functions that get their arguments on the stack like calls to printf-like functions.</source>
          <target state="translated">このオプションは、printf ライクな関数の呼び出しのように、スタック上で引数を取得する関数への複数の呼び出しを実行する関数のコードサイズを小さくすることができます。</target>
        </trans-unit>
        <trans-unit id="659720e1c331361819e1f19306618a073823d1ae" translate="yes" xml:space="preserve">
          <source>This option can only be used if the target architecture supports branch-likely instructions.</source>
          <target state="translated">このオプションは、ターゲットアーキテクチャが分岐可能な命令をサポートしている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="fc3a9caac6f7198e302fb437322053279f7c71d0" translate="yes" xml:space="preserve">
          <source>This option cannot be suffixed by feature modifiers.</source>
          <target state="translated">このオプションには、機能修飾子を接尾辞として付けることはできません。</target>
        </trans-unit>
        <trans-unit id="c576211fac72dc023de0044164971c10d96f526d" translate="yes" xml:space="preserve">
          <source>This option causes GCC to create markers in the internal representation at the beginning of statements, and to keep them roughly in place throughout compilation, using them to guide the output of &lt;code&gt;is_stmt&lt;/code&gt; markers in the line number table. This is enabled by default when compiling with optimization (</source>
          <target state="translated">このオプションを使用すると、GCCはステートメントの先頭で内部表現にマーカーを作成し、それらを使用して、行番号テーブルの &lt;code&gt;is_stmt&lt;/code&gt; マーカーの出力をガイドするために、コンパイル全体でマーカーを大まかに維持します。これは、最適化でコンパイルするときにデフォルトで有効になります（</target>
        </trans-unit>
        <trans-unit id="95c8757dd3d3337f46ca394f8f8769868a644ecd" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be treated as fixed registers.</source>
          <target state="translated">このオプションを使用すると、r2とr5は固定レジスタとして扱われます。</target>
        </trans-unit>
        <trans-unit id="b5e090b60ad88e1f4ec2772be778990575505b68" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be used in the code generated by the compiler. This setting is the default.</source>
          <target state="translated">このオプションを使用すると、コンパイラが生成するコードで r2 と r5 が使用されます。この設定がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="d3d04b742fdf172a830cc81fd460a113af18fcfc" translate="yes" xml:space="preserve">
          <source>This option causes run-time data structures to be built at program startup, which are used for verifying the vtable pointers. The options &amp;lsquo;</source>
          <target state="translated">このオプションにより、プログラムの起動時にランタイムデータ構造が構築され、vtableポインターの検証に使用されます。オプション '</target>
        </trans-unit>
        <trans-unit id="a26b4242bc022197a5b469c4333379231dcfd91c" translate="yes" xml:space="preserve">
          <source>This option causes the compiler to abort compilation on the first error occurred rather than trying to keep going and printing further error messages.</source>
          <target state="translated">このオプションを使用すると、コンパイルを続行してエラーメッセージを表示するのではなく、最初に発生したエラーでコンパイルを中止します。</target>
        </trans-unit>
        <trans-unit id="5e90ed4f8d16ef658451b5bbc4a698c1ccbdaac4" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__FAST_MATH__&lt;/code&gt; to be defined.</source>
          <target state="translated">このオプションにより、プリプロセッサマクロ &lt;code&gt;__FAST_MATH__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="59f74610163bdce44c421694716dba7eea2f36f3" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; to be defined.</source>
          <target state="translated">このオプションにより、プリプロセッサマクロ &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; が定義されます。</target>
        </trans-unit>
        <trans-unit id="dc144b835e4ef20a9b868419ab10431eef1dc3bb" translate="yes" xml:space="preserve">
          <source>This option controls stack space reuse for user declared local/auto variables and compiler generated temporaries. &lt;var&gt;reuse_level&lt;/var&gt; can be &amp;lsquo;</source>
          <target state="translated">このオプションは、ユーザーが宣言したローカル/自動変数とコンパイラーが生成した一時変数のスタック空間の再利用を制御します。 &lt;var&gt;reuse_level&lt;/var&gt; 利用レベルは</target>
        </trans-unit>
        <trans-unit id="68a88d1554ed1aa2b217aa4277399c9f56f7ad9c" translate="yes" xml:space="preserve">
          <source>This option controls the code generation of the link time optimizer. By default the linker output is determined by the linker plugin automatically. For debugging the compiler and in the case of incremental linking to non-lto object file is desired, it may be useful to control the type manually.</source>
          <target state="translated">このオプションは、リンク時間オプティマイザのコード生成を制御します。デフォルトでは、リンカーの出力はリンカー・プラグインによって自動的に決定されます。コンパイラのデバッグや、非ltoオブジェクトファイルへのインクリメンタルリンクが必要な場合には、手動でタイプを制御すると便利です。</target>
        </trans-unit>
        <trans-unit id="5d9b7ff3f71ba23e9705b0d93e8591071e6bba1a" translate="yes" xml:space="preserve">
          <source>This option controls the default setting of the ISO C99 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; pragma. Nevertheless, the option applies to all languages.</source>
          <target state="translated">このオプションは、ISO C99 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; プラグマのデフォルト設定を制御します。それでも、このオプションはすべての言語に適用されます。</target>
        </trans-unit>
        <trans-unit id="149f5a9a7f4ee5991089ef9512f0da137f76588e" translate="yes" xml:space="preserve">
          <source>This option controls the minimum width of the left margin printed by</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="37de330d3f523306c4e20d85e9fac76a8d0f7abf" translate="yes" xml:space="preserve">
          <source>This option controls the priority that is assigned to dispatch-slot restricted instructions during the second scheduling pass. The argument &lt;var&gt;priority&lt;/var&gt; takes the value &amp;lsquo;</source>
          <target state="translated">このオプションは、2番目のスケジューリングパス中にディスパッチスロット制限命令に割り当てられる優先度を制御します。引数 &lt;var&gt;priority&lt;/var&gt; は値 'を取ります</target>
        </trans-unit>
        <trans-unit id="00ce7609ded1a0ff2fbbb9740f9f2209c0f8ef1e" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects a software-managed cache for accessing variables in the &lt;code&gt;__ea&lt;/code&gt; address space with a particular cache size. Possible options for &lt;var&gt;cache-size&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">このオプションは、コンパイラーが実行可能ファイルにリンクするlibgccのバージョンを制御し、特定のキャッシュサイズで &lt;code&gt;__ea&lt;/code&gt; アドレス空間の変数にアクセスするためのソフトウェア管理キャッシュを選択します。 &lt;var&gt;cache-size&lt;/var&gt; の可能なオプションは '</target>
        </trans-unit>
        <trans-unit id="9caa6f342fbdbf76f119015b6337636546395e60" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects whether atomic updates to the software-managed cache of PPU-side variables are used. If you use atomic updates, changes to a PPU variable from SPU code using the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier do not interfere with changes to other PPU variables residing in the same cache line from PPU code. If you do not use atomic updates, such interference may occur; however, writing back cache lines is more efficient. The default behavior is to use atomic updates.</source>
          <target state="translated">このオプションは、コンパイラーが実行可能ファイルにリンクするlibgccのバージョンを制御し、PPU側の変数のソフトウェア管理キャッシュに対するアトミック更新を使用するかどうかを選択します。アトミック更新を使用する場合、 &lt;code&gt;__ea&lt;/code&gt; 名前付きアドレススペース修飾子を使用してSPUコードからPPU変数を変更しても、PPUコードから同じキャッシュラインにある他のPPU変数への変更を妨げることはありません。アトミック更新を使用しない場合、そのような干渉が発生する可能性があります。ただし、キャッシュラインを書き戻す方が効率的です。デフォルトの動作では、アトミック更新を使用します。</target>
        </trans-unit>
        <trans-unit id="23e0eea7f94b4ed1e828e2932547c5127c9ba599" translate="yes" xml:space="preserve">
          <source>This option controls what floating-point related traps are enabled. Other Alpha compilers call this option</source>
          <target state="translated">このオプションは、浮動小数点関連のトラップを有効にするかどうかを制御します。他のAlphaコンパイラはこのオプションを</target>
        </trans-unit>
        <trans-unit id="f1154974a88b020f8daf5bb4dc20170e8131c728" translate="yes" xml:space="preserve">
          <source>This option controls whether any out-of-line instance of the &lt;code&gt;__sync&lt;/code&gt; family of functions may be used to implement the C++11 &lt;code&gt;__atomic&lt;/code&gt; family of functions.</source>
          <target state="translated">このオプションは、 &lt;code&gt;__sync&lt;/code&gt; 関数ファミリーのアウトオブラインインスタンスを使用して、C ++ 11の &lt;code&gt;__atomic&lt;/code&gt; 関数ファミリーを実装できるかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="a4a02927707c45d100e334cb80281cfb05688e67" translate="yes" xml:space="preserve">
          <source>This option controls which NOP insertion scheme is used during the second scheduling pass. The argument &lt;var&gt;scheme&lt;/var&gt; takes one of the following values:</source>
          <target state="translated">このオプションは、2番目のスケジューリングパスで使用されるNOP挿入方式を制御します。引数 &lt;var&gt;scheme&lt;/var&gt; は、次のいずれかの値を取ります。</target>
        </trans-unit>
        <trans-unit id="c08ef18f138d574270868ecf3d1af53b2152507f" translate="yes" xml:space="preserve">
          <source>This option controls which dependences are considered costly by the target during instruction scheduling. The argument &lt;var&gt;dependence_type&lt;/var&gt; takes one of the following values:</source>
          <target state="translated">このオプションは、命令のスケジューリング中にターゲットがコストと見なす依存関係を制御します。引数 &lt;var&gt;dependence_type&lt;/var&gt; は、次のいずれかの値を取ります。</target>
        </trans-unit>
        <trans-unit id="eabb06a775f104526b72d8801ca8d34d938d08ee" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &amp;lsquo;</source>
          <target state="translated">このオプションは、使用できる相互推定命令を制御します。 &lt;var&gt;opt&lt;/var&gt; は、コンマで区切られたオプションのリストで、先頭に '</target>
        </trans-unit>
        <trans-unit id="c61955646b487d462957b5ea4ab670cca58e8127" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &lt;code&gt;!&lt;/code&gt; to invert the option:</source>
          <target state="translated">このオプションは、使用できる相互推定命令を制御します。 &lt;var&gt;opt&lt;/var&gt; は、コンマで区切られたオプションのリストで、前に &lt;code&gt;!&lt;/code&gt; オプションを反転するには：</target>
        </trans-unit>
        <trans-unit id="a2ecce718b608dfca621af1742e2244436537a5c" translate="yes" xml:space="preserve">
          <source>This option currently only works for RTL dumps, and the RTL is always dumped in slim form.</source>
          <target state="translated">このオプションは現在のところRTLダンプに対してのみ機能し、RTLは常にスリムな形でダンプされます。</target>
        </trans-unit>
        <trans-unit id="a0efcaa928c1eb50d04d69e5ea5969a7461e4235" translate="yes" xml:space="preserve">
          <source>This option defaults to</source>
          <target state="translated">このオプションのデフォルトは</target>
        </trans-unit>
        <trans-unit id="9fc2236cfdc032c6f548639c70136cdca6a33540" translate="yes" xml:space="preserve">
          <source>This option disables a target-specific pass in</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="c70b4cbddab92e21116da323b06dd29142551856" translate="yes" xml:space="preserve">
          <source>This option disables all previously enabled sanitizers.</source>
          <target state="translated">このオプションは、以前に有効になっていたサニタイザーをすべて無効にします。</target>
        </trans-unit>
        <trans-unit id="331b4b3e9a10408d9fe49b419ac451d5b43afbf6" translate="yes" xml:space="preserve">
          <source>This option does not affect the behavior of the</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="654b3209c6de0a321e02002e434d9a9983c5a1bb" translate="yes" xml:space="preserve">
          <source>This option does not suppress the preprocessor&amp;rsquo;s debug output, such as</source>
          <target state="translated">このオプションは、次のようなプリプロセッサのデバッグ出力を抑制しません。</target>
        </trans-unit>
        <trans-unit id="90399aa992409c6c8444d2b7bc23fef6bd0b23f1" translate="yes" xml:space="preserve">
          <source>This option does not warn about designated initializers, so the following modification does not trigger a warning:</source>
          <target state="translated">このオプションは、指定された初期化子について警告を発しないので、以下の変更は警告を発しません。</target>
        </trans-unit>
        <trans-unit id="637d485d36be088d5dc6290430edcc3559942fb2" translate="yes" xml:space="preserve">
          <source>This option does not work in the presence of shared libraries or nested functions.</source>
          <target state="translated">このオプションは、共有ライブラリや入れ子になった関数がある場合には動作しません。</target>
        </trans-unit>
        <trans-unit id="b6cfd2996b7bd042cf9971ccd157a3b5ed5d4172" translate="yes" xml:space="preserve">
          <source>This option enable the compiler to emit &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; instructions. These instructions are only valid for CPUs with code-density feature.</source>
          <target state="translated">このオプションを使用すると、コンパイラーは &lt;code&gt;enter&lt;/code&gt; および &lt;code&gt;leave&lt;/code&gt; 命令を発行できます。これらの命令は、コード密度機能を備えたCPUにのみ有効です。</target>
        </trans-unit>
        <trans-unit id="f36e3ffcf2c8e8b04ebd85e66df66aa0c1508360" translate="yes" xml:space="preserve">
          <source>This option enables GCC to generate &lt;code&gt;CMPXCHG16B&lt;/code&gt; instructions in 64-bit code to implement compare-and-exchange operations on 16-byte aligned 128-bit objects. This is useful for atomic updates of data structures exceeding one machine word in size. The compiler uses this instruction to implement &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;. However, for &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt; operating on 128-bit integers, a library call is always used.</source>
          <target state="translated">このオプションにより、GCC は、64ビットコードで &lt;code&gt;CMPXCHG16B&lt;/code&gt; 命令を生成して、16バイト境界で整列された128ビットオブジェクトに比較および交換操作を実装できます。これは、サイズが1マシンワードを超えるデータ構造のアトミック更新に役立ちます。コンパイラーは、この命令を使用して&lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;を実装します。ただし、128ビット整数で動作する&lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtinsの&lt;/a&gt;場合、ライブラリー呼び出しが常に使用されます。</target>
        </trans-unit>
        <trans-unit id="111a14f183c415ed55eeae4c39a6e2dbf86ced81" translate="yes" xml:space="preserve">
          <source>This option enables a predefined, named set of custom instruction encodings (see</source>
          <target state="translated">このオプションは、事前に定義された名前付きのカスタム命令エンコーディングのセットを有効にします (</target>
        </trans-unit>
        <trans-unit id="d1bfbfd499b3c5f5bc13445a47161400b4906077" translate="yes" xml:space="preserve">
          <source>This option enables built-in functions &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; and &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; to generate the &lt;code&gt;crc32&lt;/code&gt; machine instruction.</source>
          <target state="translated">このオプションは、機能を内蔵可能 &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt; 、 &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt; 、 &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; と &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; 生成する &lt;code&gt;crc32&lt;/code&gt; マシン命令を。</target>
        </trans-unit>
        <trans-unit id="2cd918ec8f0e039c766cf7fe1d48f22e6df60ce4" translate="yes" xml:space="preserve">
          <source>This option enables checking of alignment of pointers when they are dereferenced, or when a reference is bound to insufficiently aligned target, or when a method or constructor is invoked on insufficiently aligned object.</source>
          <target state="translated">このオプションは、ポインタが参照解除されたときや、参照が十分にアラインメントされていないターゲットにバインドされたとき、あるいはメソッドやコンストラクタが十分にアラインメントされていないオブジェクト上で呼び出されたときに、ポインタのアラインメントをチェックすることを可能にします。</target>
        </trans-unit>
        <trans-unit id="50199f80fe90cda9539f52ff8308973833026d26" translate="yes" xml:space="preserve">
          <source>This option enables checking that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc. This option has two suboptions,</source>
          <target state="translated">このオプシ ョ ンは、 シ フ ト 演算の結果が未定義でない こ と を確認で き る よ う に し ます。具体的に何を未定義とみなすかは、C と C++の間、また ISO C90 と C99 の間などで若干異なりますので注意してください。このオプシ ョ ンには 2 つのサブオプシ ョ ンがあ り ます。</target>
        </trans-unit>
        <trans-unit id="85b4168b985dbcf1d69994ce5cb2c45b6d1daccb" translate="yes" xml:space="preserve">
          <source>This option enables checking that the second argument of a shift operation is not negative and is smaller than the precision of the promoted first argument.</source>
          <target state="translated">このオプションを使用すると、シフト操作の第2引数が負ではなく、昇格した第1引数の精度よりも小さいことを確認することができます。</target>
        </trans-unit>
        <trans-unit id="938ba4d02fa2f3fd34289d2d8d2d36eb752b42e2" translate="yes" xml:space="preserve">
          <source>This option enables floating-point type to integer conversion checking. We check that the result of the conversion does not overflow. Unlike other similar options,</source>
          <target state="translated">このオプションは、浮動小数点型から整数型への変換チェックを有効にします。変換結果がオーバーフローしないかどうかをチェックします。他の類似のオプションとは異なります。</target>
        </trans-unit>
        <trans-unit id="2be71ee2359ef67de5a090bb541bf4acc1394953" translate="yes" xml:space="preserve">
          <source>This option enables functions to be overloaded for ordinary and UTF-8 strings:</source>
          <target state="translated">このオプションを使用すると、通常の文字列やUTF-8の文字列に対して関数をオーバーロードすることができます。</target>
        </trans-unit>
        <trans-unit id="f2c29fc89d033f54fcdc9384885989225fe300ca" translate="yes" xml:space="preserve">
          <source>This option enables generation of &lt;code&gt;SAHF&lt;/code&gt; instructions in 64-bit code. Early Intel Pentium 4 CPUs with Intel 64 support, prior to the introduction of Pentium 4 G1 step in December 2005, lacked the &lt;code&gt;LAHF&lt;/code&gt; and &lt;code&gt;SAHF&lt;/code&gt; instructions which are supported by AMD64. These are load and store instructions, respectively, for certain status flags. In 64-bit mode, the &lt;code&gt;SAHF&lt;/code&gt; instruction is used to optimize &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;drem&lt;/code&gt;, and &lt;code&gt;remainder&lt;/code&gt; built-in functions; see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt; for details.</source>
          <target state="translated">このオプションを使用すると、64ビットコードで &lt;code&gt;SAHF&lt;/code&gt; 命令を生成できます。 2005年12月にPentium 4 G1ステップが導入される前のIntel 64対応の初期のIntel Pentium 4 CPUには、AMD64でサポートされている &lt;code&gt;LAHF&lt;/code&gt; および &lt;code&gt;SAHF&lt;/code&gt; 命令がありませんでした。これらは、特定のステータスフラグのロードおよびストア命令です。 64ビットモードでは、 &lt;code&gt;SAHF&lt;/code&gt; 命令を使用して &lt;code&gt;fmod&lt;/code&gt; 、 &lt;code&gt;drem&lt;/code&gt; 、および &lt;code&gt;remainder&lt;/code&gt; 組み込み関数を最適化します。詳細については、&lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;他のビルトイン&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bf9eedf73e4d0015fa244bb4f5c3569d74469415" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of C++ member function calls, member accesses and some conversions between pointers to base and derived classes, to verify the referenced object has the correct dynamic type.</source>
          <target state="translated">このオプションを使用すると、C++のメンバ関数呼び出し、メンバ・アクセス、および基底クラスと派生クラスへのポインタ間の一部の変換を計測して、参照されるオブジェクトが正しい動的型を持っていることを確認できます。</target>
        </trans-unit>
        <trans-unit id="7dd18b0f972bb3a966564c3387d23513ed8f1114" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of arguments to selected builtin functions. If an invalid value is passed to such arguments, a run-time error is issued. E.g. passing 0 as the argument to &lt;code&gt;__builtin_ctz&lt;/code&gt; or &lt;code&gt;__builtin_clz&lt;/code&gt; invokes undefined behavior and is diagnosed by this option.</source>
          <target state="translated">このオプションは、選択された組み込み関数への引数の計測を有効にします。そのような引数に無効な値が渡されると、実行時エラーが発行されます。たとえば、 &lt;code&gt;__builtin_ctz&lt;/code&gt; または &lt;code&gt;__builtin_clz&lt;/code&gt; の引数として0を渡すと、未定義の動作が呼び出され、このオプションによって診断されます。</target>
        </trans-unit>
        <trans-unit id="4707da904f3b017d856d15dd2d0965e19870e1d8" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of array bounds. Various out of bounds accesses are detected. Flexible array members, flexible array member-like arrays, and initializers of variables with static storage are not instrumented.</source>
          <target state="translated">このオプションを使用すると、アレイの境界を計測できるようになります。様々なアウトオブバウンズアクセスが検出されます。柔軟な配列メンバ、柔軟な配列メンバライクな配列、静的ストレージを持つ変数の初期化子は計測されません。</target>
        </trans-unit>
        <trans-unit id="2e349da95c57c4503e630d88b725ecb09ef50689" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of calls, checking whether null values are not passed to arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="translated">このオプションは、NULL値がNULL以外で値を必要とするものとしてマークされた引数に渡されていないかどうかをチェックし、通話の計測を可能に &lt;code&gt;nonnull&lt;/code&gt; 関数属性。</target>
        </trans-unit>
        <trans-unit id="8d56bee13b4f38d072afa312adba62366dd96324" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from an enum type. If a value outside the range of values for the enum type is loaded, a run-time error is issued.</source>
          <target state="translated">このオプションは、列挙型からのロードの計測を可能にします。列挙型の値の範囲外の値がロードされた場合、ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8bae34f78ab33cc208a29bdcebb31b30f37fdfdb" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from bool. If a value other than 0/1 is loaded, a run-time error is issued.</source>
          <target state="translated">このオプションは、boolからのロードの計測を可能にします。0/1以外の値がロードされた場合、ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="46c1b7dde6bdde5a1a374986dc5119119957fbe3" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of memory references using the &lt;code&gt;__builtin_object_size&lt;/code&gt; function. Various out of bounds pointer accesses are detected.</source>
          <target state="translated">このオプションは、 &lt;code&gt;__builtin_object_size&lt;/code&gt; 関数を使用してメモリ参照の計測を有効にします。さまざまな範囲外のポインターアクセスが検出されます。</target>
        </trans-unit>
        <trans-unit id="0292138149978c95eacc8642af7ff43cfe7b2264" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of pointer arithmetics. If the pointer arithmetics overflows, a run-time error is issued.</source>
          <target state="translated">このオプションは、ポインタ演算の計測を可能にします。ポインタ演算器がオーバーフローした場合、ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="430110abdd161cbe658a0d2f529325e1208cd453" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of return statements in functions marked with &lt;code&gt;returns_nonnull&lt;/code&gt; function attribute, to detect returning of null values from such functions.</source>
          <target state="translated">このオプションは、 &lt;code&gt;returns_nonnull&lt;/code&gt; 関数属性でマークされた関数のreturnステートメントの計測を有効にして、そのような関数からのnull値の戻りを検出します。</target>
        </trans-unit>
        <trans-unit id="cb16ef94b917da96c006db5cf05527388bed65b9" translate="yes" xml:space="preserve">
          <source>This option enables or disables warnings about conflicts between the MCU name specified by the</source>
          <target state="translated">このオプションでは、このオプションで指定されたMCU名の競合に関する警告を有効または無効にします。</target>
        </trans-unit>
        <trans-unit id="f864b078493b6651bb86e363b143af67066fe079" translate="yes" xml:space="preserve">
          <source>This option enables pointer checking. Particularly, the application built with this option turned on will issue an error message when it tries to dereference a NULL pointer, or if a reference (possibly an rvalue reference) is bound to a NULL pointer, or if a method is invoked on an object pointed by a NULL pointer.</source>
          <target state="translated">このオプションはポインタチェックを有効にします。特に、このオプションを有効にしてビルドされたアプリケーションは、 NULL ポインタを参照解除しようとした場合や、 参照 (おそらく rvalue 参照)が NULL ポインタにバインドされている場合、あるいは NULL ポインタが指すオブジェクトに対してメソッドが呼び出された場合に、 エラーメッセージを発行します。</target>
        </trans-unit>
        <trans-unit id="9390f84ab3c6840aa43bf14f385886239ff26f9c" translate="yes" xml:space="preserve">
          <source>This option enables return statement checking. Programs built with this option turned on will issue an error message when the end of a non-void function is reached without actually returning a value. This option works in C++ only.</source>
          <target state="translated">このオプションは、戻り文のチェックを有効にします。このオプションを有効にして構築されたプログラムは、実際に値を返さずに非ボイド関数の終了に到達した場合にエラーメッセージを発行します。このオプションは C++のみで動作します。</target>
        </trans-unit>
        <trans-unit id="c5e06b2ed5aaf18ef55b254444b859dc73b64e5e" translate="yes" xml:space="preserve">
          <source>This option enables signed integer overflow checking. We check that the result of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and both unary and binary &lt;code&gt;-&lt;/code&gt; does not overflow in the signed arithmetics. Note, integer promotion rules must be taken into account. That is, the following is not an overflow:</source>
          <target state="translated">このオプションは、符号付き整数オーバーフローチェックを有効にします。私たちは、結果ことを確認してください &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、および単項およびバイナリの両方が &lt;code&gt;-&lt;/code&gt; 署名算術演算でオーバーフローしません。整数の昇格規則を考慮する必要があることに注意してください。つまり、以下はオーバーフローではありません。</target>
        </trans-unit>
        <trans-unit id="5aa6ebd08f1df0b8312082dee55c79f646e3aa80" translate="yes" xml:space="preserve">
          <source>This option enables strict instrumentation of array bounds. Most out of bounds accesses are detected, including flexible array members and flexible array member-like arrays. Initializers of variables with static storage are not instrumented.</source>
          <target state="translated">このオプションは、配列の境界を厳密に計測することを可能にします。柔軟性のある配列メンバや柔軟性のある配列メンバのような配列を含む、ほとんどのアウトオブバウンズアクセスを検出します。静的なストレージを持つ変数の初期化子は計測されません。</target>
        </trans-unit>
        <trans-unit id="35547d9fdeedd115e10a5da6add0bd1af02febf6" translate="yes" xml:space="preserve">
          <source>This option enables the extraction of object files with GIMPLE bytecode out of library archives. This improves the quality of optimization by exposing more code to the link-time optimizer. This information specifies what symbols can be accessed externally (by non-LTO object or during dynamic linking). Resulting code quality improvements on binaries (and shared libraries that use hidden visibility) are similar to</source>
          <target state="translated">このオプションは、ライブラリアーカイブからGIMPLEバイトコードを用いたオブジェクトファイルを抽出することを可能にします。これにより、より多くのコードをリンク時間オプティマイザに公開して最適化の質を向上させます。この情報は、どのようなシンボルが外部から(非LTOオブジェクトや動的リンク中に)アクセスできるかを指定します。バイナリ(および非表示の可視性を使用する共有ライブラリ)でのコード品質の向上の結果は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="e139de52e12e355ab2f4aceaceda024599afb6f0" translate="yes" xml:space="preserve">
          <source>This option enables use of &lt;code&gt;RCPSS&lt;/code&gt; and &lt;code&gt;RSQRTSS&lt;/code&gt; instructions (and their vectorized variants &lt;code&gt;RCPPS&lt;/code&gt; and &lt;code&gt;RSQRTPS&lt;/code&gt;) with an additional Newton-Raphson step to increase precision instead of &lt;code&gt;DIVSS&lt;/code&gt; and &lt;code&gt;SQRTSS&lt;/code&gt; (and their vectorized variants) for single-precision floating-point arguments. These instructions are generated only when</source>
          <target state="translated">このオプションは、単精度浮動小数点引数の &lt;code&gt;DIVSS&lt;/code&gt; および &lt;code&gt;SQRTSS&lt;/code&gt; （およびそれらのベクトル化バリアント）の代わりに、精度を高めるために追加のNewton-Raphsonステップを &lt;code&gt;RCPSS&lt;/code&gt; および &lt;code&gt;RSQRTSS&lt;/code&gt; 命令（およびそれらのベクトル化バリアント &lt;code&gt;RCPPS&lt;/code&gt; および &lt;code&gt;RSQRTPS&lt;/code&gt; ）の使用を有効にします。これらの指示は、次の場合にのみ生成されます</target>
        </trans-unit>
        <trans-unit id="060df32e86c55ba7cad1df047f45c9f196518594" translate="yes" xml:space="preserve">
          <source>This option enables use of the &lt;code&gt;movbe&lt;/code&gt; instruction to implement &lt;code&gt;__builtin_bswap32&lt;/code&gt; and &lt;code&gt;__builtin_bswap64&lt;/code&gt;.</source>
          <target state="translated">このオプションにより、 &lt;code&gt;movbe&lt;/code&gt; 命令を使用して &lt;code&gt;__builtin_bswap32&lt;/code&gt; および &lt;code&gt;__builtin_bswap64&lt;/code&gt; を実装できます。</target>
        </trans-unit>
        <trans-unit id="3be41468437cbd33ddbb5938cf95baa409134252" translate="yes" xml:space="preserve">
          <source>This option enables use of the reciprocal estimate and reciprocal square root estimate instructions with additional Newton-Raphson steps to increase precision instead of doing a divide or square root and divide for floating-point arguments. You should use the</source>
          <target state="translated">このオプションは、浮動小数点引数で除算や平方根と除算を行う代わりに、精度を向上させるためにニュートン-ラプソンステップを追加した逆推定と平方根の逆推定命令を使用することを可能にします。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="b8b0cc8f7ad08d6547ab80b77c947a16db351cd7" translate="yes" xml:space="preserve">
          <source>This option forces GCC to use custom shadow offset in AddressSanitizer checks. It is useful for experimenting with different shadow memory layouts in Kernel AddressSanitizer.</source>
          <target state="translated">このオプションを使用すると、AddressSanitizer のチェックで GCC がカスタム シャドウ オフセットを使用するように強制されます。これは、カーネル アドレス サニタイザーでさまざまなシャドウ メモリ レイアウトを実験するのに便利です。</target>
        </trans-unit>
        <trans-unit id="3233daa383d4066b02b1657216dd534dd8974913" translate="yes" xml:space="preserve">
          <source>This option generates traps for signed overflow on addition, subtraction, multiplication operations. The options</source>
          <target state="translated">このオプションは、足し算・引き算・乗算演算で符号付きオーバーフローのトラップを生成します。オプション</target>
        </trans-unit>
        <trans-unit id="bc361006809087722b4665eda3af889c660cf7bb" translate="yes" xml:space="preserve">
          <source>This option has no effect on abicalls code. The default is</source>
          <target state="translated">このオプションはabicallsのコードには何の影響もありません。デフォルトは</target>
        </trans-unit>
        <trans-unit id="ce202009f104c41c762f668a2d6d18c3bbd55f2a" translate="yes" xml:space="preserve">
          <source>This option ignored; it is provided for compatibility purposes only. Software floating-point code is emitted by default, and this default can overridden by FPX options;</source>
          <target state="translated">このオプションは無視されます。ソフトウェアの浮動小数点コードはデフォルトで出力され、このデフォルトはFPXオプションで上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="d295e879be9d8d469fabe64723a6a09c1d8dadcc" translate="yes" xml:space="preserve">
          <source>This option implies</source>
          <target state="translated">このオプションは、次のことを暗示しています。</target>
        </trans-unit>
        <trans-unit id="8ef84b2b0112928af774bc0bf4f11244d39995fa" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68020 and 68881/68882 instructions that have to be emulated by software on the 68060. Use this option if your 68060 does not have code to emulate those instructions.</source>
          <target state="translated">このオプションは、68060 のソフトウェアでエミュレートする必要がある 68020 および 68881/68882 命令の使用を禁止します。68060にこれらの命令をエミュレートするコードがない場合は、このオプションを使用してください。</target>
        </trans-unit>
        <trans-unit id="efb405ef4149f232764b47255e26eb73c1775fc9" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68881/68882 instructions that have to be emulated by software on the 68040. Use this option if your 68040 does not have code to emulate those instructions.</source>
          <target state="translated">このオプションは、68040 のソフトウェアでエミュレートする必要がある 68881/68882 命令の使用を禁止します。68040にこれらの命令をエミュレートするコードがない場合は、このオプションを使用してください。</target>
        </trans-unit>
        <trans-unit id="e0c66bcd77c8bed54eff907c145c1ea37c3f6555" translate="yes" xml:space="preserve">
          <source>This option instructs CPP to add a phony target for each dependency other than the main file, causing each to depend on nothing. These dummy rules work around errors &lt;code&gt;make&lt;/code&gt; gives if you remove header files without updating the</source>
          <target state="translated">このオプションは、メインファイル以外の依存関係ごとに偽のターゲットを追加するようにCPPに指示し、それぞれが何にも依存しないようにします。これらのダミールールは、ヘッダーファイルを削除せずにエラー &lt;code&gt;make&lt;/code&gt; 回避し、</target>
        </trans-unit>
        <trans-unit id="3c687d2d1d2116a0ccc32795fd0f0f68e88ed641" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to dump the names of the x86 performance tuning features and default settings. The names can be used in</source>
          <target state="translated">このオプションは、GCC に x86 パフォーマンスチューニング機能とデフォルト設定の名前をダンプするように指示します。この名前は</target>
        </trans-unit>
        <trans-unit id="38a021cb20751050e831beceef3d4668ce4cf298" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;cld&lt;/code&gt; instruction in the prologue of functions that use string instructions. String instructions depend on the DF flag to select between autoincrement or autodecrement mode. While the ABI specifies the DF flag to be cleared on function entry, some operating systems violate this specification by not clearing the DF flag in their exception dispatchers. The exception handler can be invoked with the DF flag set, which leads to wrong direction mode when string instructions are used. This option can be enabled by default on 32-bit x86 targets by configuring GCC with the</source>
          <target state="translated">このオプションは、文字列命令を使用する関数のプロローグで &lt;code&gt;cld&lt;/code&gt; 命令を発行するようにGCCに指示します。文字列命令はDFフラグに依存して、自動インクリメントモードまたは自動デクリメントモードを選択します。 ABIは関数の開始時にDFフラグをクリアするように指定しますが、一部のオペレーティングシステムは、例外ディスパッチャーのDFフラグをクリアしないことにより、この仕様に違反しています。例外ハンドラーは、DFフラグを設定して呼び出すことができます。これにより、文字列命令が使用されたときに誤った方向モードになります。このオプションは、32ビットx86ターゲットでデフォルトで有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="657b508727e487887f711193a95e39499f48960e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;vzeroupper&lt;/code&gt; instruction before a transfer of control flow out of the function to minimize the AVX to SSE transition penalty as well as remove unnecessary &lt;code&gt;zeroupper&lt;/code&gt; intrinsics.</source>
          <target state="translated">このオプションは、制御フローを関数から転送する前に &lt;code&gt;vzeroupper&lt;/code&gt; 命令を発行してAVXからSSEへの移行ペナルティを最小限に抑え、不要な &lt;code&gt;zeroupper&lt;/code&gt; 組み込み関数を削除するようにGCCに指示します。</target>
        </trans-unit>
        <trans-unit id="3c78872fcf66a452b582423621f5fae766269c85" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to turn off all tunable features. See also</source>
          <target state="translated">このオプションは、GCC にチューニング可能な機能をすべてオフにするよう指示します。以下も参照してください。</target>
        </trans-unit>
        <trans-unit id="3d9dd501c30e561cb69d40cbc9373ad471302725" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use 128-bit AVX instructions instead of 256-bit AVX instructions in the auto-vectorizer.</source>
          <target state="translated">このオプションは、オートベクタライザで256ビットのAVX命令の代わりに128ビットのAVX命令を使用するようにGCCに指示します。</target>
        </trans-unit>
        <trans-unit id="e6945bdd3deb13214c6bf659bc52045e04a70f0e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use &lt;var&gt;opt&lt;/var&gt;-bit vector width in instructions instead of default on the selected platform.</source>
          <target state="translated">このオプションは、GCC に、選択したプラットフォームでのデフォルトではなく、 &lt;var&gt;opt&lt;/var&gt; -bitベクトル幅を命令で使用するように指示します。</target>
        </trans-unit>
        <trans-unit id="dbda0a70a5f352dad89f90d04caa28e3bd6d0703" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that pointer arithmetic overflow on addition and subtraction wraps around using twos-complement representation. This flag disables some optimizations which assume pointer overflow is invalid.</source>
          <target state="translated">このオプションは、足し算と引き算の際にポインタの算術オーバーフローが二相補表現を使用して回避されると仮定するようにコンパイラに指示します。このフラグは、ポインタのオーバーフローが無効であると仮定したいくつかの最適化を無効にします。</target>
        </trans-unit>
        <trans-unit id="f816312ce41ee12df0f414176d9a5763b90df530" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that signed arithmetic overflow of addition, subtraction and multiplication wraps around using twos-complement representation. This flag enables some optimizations and disables others. The options</source>
          <target state="translated">このオプションは、加算、減算、乗算の符号付き算術のオーバーフローが二相補表現を使用して回避されると仮定するようにコンパイラに指示します。このフラグは、いくつかの最適化を有効にし、その他の最適化を無効にします。オプション</target>
        </trans-unit>
        <trans-unit id="c431c0c08a8246794b17639d38f5f9732adef200" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to check that the size of a variable length array is positive.</source>
          <target state="translated">このオプションは、可変長配列のサイズが正の値であることを確認するようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="0d3ab8d594e88fea27629172c62534cedd7e9ccd" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to generate code for a 16-entry register file. This option defines the &lt;code&gt;__ARC_RF16__&lt;/code&gt; preprocessor macro.</source>
          <target state="translated">このオプションは、16エントリのレジスタファイルのコードを生成するようコンパイラーに指示します。このオプションは、 &lt;code&gt;__ARC_RF16__&lt;/code&gt; プリプロセッサマクロを定義します。</target>
        </trans-unit>
        <trans-unit id="b138f51e639bc0b32ca1dc63d0195b9a7cfb2e6c" translate="yes" xml:space="preserve">
          <source>This option is a detailed version of</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="0777795174f336ed7d700a302e0b548f3225ecd3" translate="yes" xml:space="preserve">
          <source>This option is also passed on to the assembler.</source>
          <target state="translated">このオプションはアセンブラにも渡されます。</target>
        </trans-unit>
        <trans-unit id="0a8a587d88750f4b64f0573d837060922995e692" translate="yes" xml:space="preserve">
          <source>This option is always enabled by default on certain machines, usually those which have no call-preserved registers to use instead.</source>
          <target state="translated">このオプションは、特定のマシンではデフォルトで常に有効になっています。</target>
        </trans-unit>
        <trans-unit id="87c9194e0e60c9d507f16257e56fa4da6140cc2a" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a DLL&amp;mdash;a dynamic link library&amp;mdash;is to be generated, enabling the selection of the required runtime startup object and entry point.</source>
          <target state="translated">このオプションは、CygwinおよびMinGWターゲットで使用できます。DLL（ダイナミックリンクライブラリ）が生成されることを指定し、必要なランタイムスタートアップオブジェクトとエントリポイントを選択できるようにします。</target>
        </trans-unit>
        <trans-unit id="34974b8a3ddccb37978e6f7f3ab9b870fb775b53" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a GUI application is to be generated by instructing the linker to set the PE header subsystem type appropriately.</source>
          <target state="translated">このオプションはCygwinとMinGWターゲットで利用可能です。リンカにPEヘッダサブシステムタイプを適切に設定するよう指示してGUIアプリケーションを生成することを指定します。</target>
        </trans-unit>
        <trans-unit id="f9c956bb65a4ef29b2924781000ede172dfe35c9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the &lt;code&gt;dllimport&lt;/code&gt; attribute should be ignored.</source>
          <target state="translated">このオプションは、CygwinおよびMinGWターゲットで使用できます。 &lt;code&gt;dllimport&lt;/code&gt; 属性を無視するように指定しています。</target>
        </trans-unit>
        <trans-unit id="7e0dc3ae21d5985659301b368b4c95c1db9366f7" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the GNU extension to the PE file format that permits the correct alignment of COMMON variables should be used when generating code. It is enabled by default if GCC detects that the target assembler found during configuration supports the feature.</source>
          <target state="translated">このオプションは Cygwin と MinGW ターゲットで利用可能です。これは、コードを生成する際に、COMMON変数の正しい位置合わせを可能にするPEファイル形式のGNU拡張子を使用することを指定します。設定中に見つかったターゲットアセンブラがこの機能をサポートしていることを GCC が検出した場合、デフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="9161324109587b09b1694f29c23c72102885dbb9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the typical Microsoft Windows predefined macros are to be set in the pre-processor, but does not influence the choice of runtime library/startup code.</source>
          <target state="translated">このオプションはCygwinとMinGWターゲットで利用可能です。典型的なMicrosoft Windowsの定義済みマクロをプリプロセッサで設定することを指定しますが、ランタイムライブラリ/スタートアップコードの選択には影響しません。</target>
        </trans-unit>
        <trans-unit id="9e0a3afbd291f88cb3c95726f31687bd36f164b7" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW and Cygwin targets. It specifies that relocated-data in read-only section is put into the &lt;code&gt;.data&lt;/code&gt; section. This is a necessary for older runtimes not supporting modification of &lt;code&gt;.rdata&lt;/code&gt; sections for pseudo-relocation.</source>
          <target state="translated">このオプションは、MinGWおよびCygwinターゲットで使用できます。読み取り専用セクションのrelocated-dataが &lt;code&gt;.data&lt;/code&gt; セクションに配置されることを指定します。これは、疑似再配置のための &lt;code&gt;.rdata&lt;/code&gt; セクションの変更をサポートしていない古いランタイムに必要です。</target>
        </trans-unit>
        <trans-unit id="acdd2b492fbf0ebaa317f2c48f132b3b62ecde92" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that MinGW-specific thread support is to be used.</source>
          <target state="translated">このオプションはMinGWターゲットで使用できます。MinGW固有のスレッドサポートを使用することを指定します。</target>
        </trans-unit>
        <trans-unit id="faee952b0f4c06ee910b880bfbdf149d4685f355" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that the executable flag for the stack used by nested functions isn&amp;rsquo;t set. This is necessary for binaries running in kernel mode of Microsoft Windows, as there the User32 API, which is used to set executable privileges, isn&amp;rsquo;t available.</source>
          <target state="translated">このオプションは、MinGWターゲットで使用できます。ネストされた関数で使用されるスタックの実行可能フラグが設定されていないことを指定します。これは、Microsoft Windowsのカーネルモードで実行されているバイナリに必要です。実行可能権限の設定に使用されるUser32 APIが利用できないためです。</target>
        </trans-unit>
        <trans-unit id="e934759656573ab06e7b01542f8d07b3197cbe74" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW-w64 targets. It causes the &lt;code&gt;UNICODE&lt;/code&gt; preprocessor macro to be predefined, and chooses Unicode-capable runtime startup code.</source>
          <target state="translated">このオプションは、MinGW-w64ターゲットで使用できます。これは、原因 &lt;code&gt;UNICODE&lt;/code&gt; プリプロセッサマクロが事前定義すること、およびUnicode対応ランタイムスタートアップコードを選択します。</target>
        </trans-unit>
        <trans-unit id="2059e693abf7ce7ec777bf5e7cc1b18ffae32137" translate="yes" xml:space="preserve">
          <source>This option is deprecated.</source>
          <target state="translated">このオプションは非推奨です。</target>
        </trans-unit>
        <trans-unit id="aabeb9acbf850798bff5dd7ad77029ce8ab9ac73" translate="yes" xml:space="preserve">
          <source>This option is deprecated. It pads structures to multiple of 4 bytes, which is incompatible with the SH ABI.</source>
          <target state="translated">このオプションは非推奨です。これは構造体を4バイトの倍数にパッドするもので、SH ABIとは互換性がありません。</target>
        </trans-unit>
        <trans-unit id="9d29c4b41311afb57bb108b16e155cb489ec134b" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use</source>
          <target state="translated">このオプションは非推奨です。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="4053a3fd19d3968881e6f8e01595ecadbdd30069" translate="yes" xml:space="preserve">
          <source>This option is enabled at level</source>
          <target state="translated">このオプションはレベル</target>
        </trans-unit>
        <trans-unit id="bf488b640ab82c12aa83d2d5d585a8acb0774751" translate="yes" xml:space="preserve">
          <source>This option is enabled by</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="1a1ed53d314baadd464fa2b14f3800bf95fa8ca0" translate="yes" xml:space="preserve">
          <source>This option is enabled by default at optimization levels</source>
          <target state="translated">このオプションは、最適化レベルでデフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="d247bcb1695bed692a8726f3533be3d2fb1fee0b" translate="yes" xml:space="preserve">
          <source>This option is enabled by default for Microsoft Windows targets. This behavior can also be controlled locally by use of variable or type attributes. For more information, see &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; and &lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86 Type Attributes&lt;/a&gt;.</source>
          <target state="translated">このオプションは、Microsoft Windowsターゲットではデフォルトで有効になっています。この動作は、変数またはタイプ属性を使用してローカルに制御することもできます。詳細については、「&lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86変数属性」&lt;/a&gt;および「&lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86タイプ属性&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="2652d68534c6f88541191086fa1485e27def7fc6" translate="yes" xml:space="preserve">
          <source>This option is enabled by default on most targets. On Nios II ELF, it defaults to off. On AVR, CR16, and MSP430, this option is completely disabled.</source>
          <target state="translated">このオプションはほとんどのターゲットでデフォルトで有効になっています。Nios II ELFでは、デフォルトはオフになっています。AVR、CR16、MSP430では、このオプションは完全に無効になっています。</target>
        </trans-unit>
        <trans-unit id="3d8c17f97f0a71b6e6913867ec6d9569fa353e80" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when LTO support in GCC is enabled and GCC was configured for use with a linker supporting plugins (GNU ld 2.21 or newer or gold).</source>
          <target state="translated">このオプションは、GCC の LTO サポートが有効で、プラグインをサポートするリンカ (GNU ld 2.21 以降または gold)で GCC を使用するように設定されている場合に、デフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="7d53846e4ad58929426e4a8a561e1ca04e4dae26" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when the RH850 ABI is in use (see</source>
          <target state="translated">このオプションは、RH850 ABI を使用しているときにデフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="e8f3025aa92d2d4f667e2309b49f93dcbd8a2cc1" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that affect signaling NaN behavior.</source>
          <target state="translated">このオプションは実験的なものであり、シグナリングNaNの動作に影響を与えるすべてのGCC最適化を無効にすることを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="6bf7bb3d6ca95f65181405f388dc4f38acb33184" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that are affected by rounding mode. Future versions of GCC may provide finer control of this setting using C99&amp;rsquo;s &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma. This command-line option will be used to specify the default state for &lt;code&gt;FENV_ACCESS&lt;/code&gt;.</source>
          <target state="translated">このオプションは実験的なものであり、現在、丸めモードの影響を受けるすべてのGCC最適化を無効にすることを保証していません。GCCの将来のバージョンでは、C99の &lt;code&gt;FENV_ACCESS&lt;/code&gt; プラグマを使用して、この設定をより細かく制御できるようになる可能性があります。このコマンドラインオプションは、 &lt;code&gt;FENV_ACCESS&lt;/code&gt; のデフォルトの状態を指定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="41c5b1ff9a4b2c16f0283cc8b3e6a1c1ee4e99a0" translate="yes" xml:space="preserve">
          <source>This option is experimental and the format of the data within the compressed JSON file is subject to change.</source>
          <target state="translated">このオプションは実験的なものであり、圧縮されたJSONファイル内のデータのフォーマットは変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="77c067b7272c8dfb1940d673f7549a9c970673d8" translate="yes" xml:space="preserve">
          <source>This option is ignored and provided for compatibility purposes only.</source>
          <target state="translated">このオプションは無視され、互換性のためだけに提供されます。</target>
        </trans-unit>
        <trans-unit id="39bc415cf1072ef041b852cccab7caeb03cebbe9" translate="yes" xml:space="preserve">
          <source>This option is implicitly passed to the compiler for the second compilation requested by</source>
          <target state="translated">このオプションは、2回目のコンパイルを行う際に</target>
        </trans-unit>
        <trans-unit id="223090f1188ac1bc38c64fe292f4f4b2503fac75" translate="yes" xml:space="preserve">
          <source>This option is implied by</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="9711864ac531d244797123498f9a9fe143b47ace" translate="yes" xml:space="preserve">
          <source>This option is left for compatibility reasons.</source>
          <target state="translated">このオプションは互換性のために残されています。</target>
        </trans-unit>
        <trans-unit id="705dd214fcbbda555d2c25430996631d43106884" translate="yes" xml:space="preserve">
          <source>This option is like the</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="7ea37451ed423d9b4f565d2cd48781668a2b5f65" translate="yes" xml:space="preserve">
          <source>This option is not turned on by any</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="9abb00a56e1a1d91dc73fdc3ecd2a22dd97e1ddc" translate="yes" xml:space="preserve">
          <source>This option is off by default, because the resulting preprocessed output is only really suitable as input to GCC. It is switched on by</source>
          <target state="translated">このオプションはデフォルトではオフになっています。このオプションは</target>
        </trans-unit>
        <trans-unit id="4f3ef2c8071d14f453caa189ada503a69384e247" translate="yes" xml:space="preserve">
          <source>This option is only active when</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="a6188b363cf7403f6936d8ff4d2c56a28d236e61" translate="yes" xml:space="preserve">
          <source>This option is only active when signed overflow is undefined. It warns about cases where the compiler optimizes based on the assumption that signed overflow does not occur. Note that it does not warn about all cases where the code might overflow: it only warns about cases where the compiler implements some optimization. Thus this warning depends on the optimization level.</source>
          <target state="translated">このオプションは、符号付きオーバーフローが未定義の場合にのみ有効です。このオプションは、符号付きオーバーフローが発生しないと仮定してコンパイラが最適化する場合について警告します。このオプションは、コードがオーバーフローする可能性のあるすべてのケースについて警告するわけではなく、 コンパイラが何らかの最適化を実装している場合にのみ警告します。このように、この警告は最適化レベルに依存します。</target>
        </trans-unit>
        <trans-unit id="9d25fc758589cd4be71db515ac5f7ca7241f83be" translate="yes" xml:space="preserve">
          <source>This option is only available for ARCv2 cores.</source>
          <target state="translated">このオプションはARCv2コアでのみ使用可能です。</target>
        </trans-unit>
        <trans-unit id="47efc2541291ec81a8db6b59aeed231c895bc9c4" translate="yes" xml:space="preserve">
          <source>This option is only available when compiling C++ code. It turns on (or off, if using</source>
          <target state="translated">このオプションは、C++コードをコンパイルするときにのみ使用できます。このオプションをオンにします (</target>
        </trans-unit>
        <trans-unit id="f33ea172ac2795eac5ebb478ce17a5afc41091f3" translate="yes" xml:space="preserve">
          <source>This option is only intended to be useful when developing GCC.</source>
          <target state="translated">このオプションは、GCCを開発する際にのみ有用であることを意図しています。</target>
        </trans-unit>
        <trans-unit id="034517546050c1e22d79385d031d17520c531cb2" translate="yes" xml:space="preserve">
          <source>This option is only useful for debugging GCC. When used from CPP or with</source>
          <target state="translated">このオプションはGCCのデバッグにのみ有効です。CPPから使用する場合や</target>
        </trans-unit>
        <trans-unit id="05b6c3c24d858a91f50ac46c4cd92ae8eecb3f01" translate="yes" xml:space="preserve">
          <source>This option is passed to the assembler and linker, and allows the linker to perform certain optimizations that cannot be done until the final link.</source>
          <target state="translated">このオプションはアセンブラとリンカに渡され、最終的なリンクまではできない特定の最適化をリンカが実行できるようにします。</target>
        </trans-unit>
        <trans-unit id="b562e6b75c17a9e319c7220a396dd42baef9b10e" translate="yes" xml:space="preserve">
          <source>This option is supported from MIPS Release 6 onwards.</source>
          <target state="translated">このオプションは、MIPS Release 6 以降でサポートされています。</target>
        </trans-unit>
        <trans-unit id="69521eee9b087ee047a6dc4f213a5e965016b754" translate="yes" xml:space="preserve">
          <source>This option is the default for optimized compilation if the assembler and linker support it. Use</source>
          <target state="translated">アセンブラとリンカがサポートしている場合、このオプションは最適化されたコンパイルを行うためのデフォルトです。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="a6be6b9afb7bd451d149acef44e3204c0799fa3d" translate="yes" xml:space="preserve">
          <source>This option is used internally by the compiler to select and build multilibs for architectures &lt;code&gt;avr2&lt;/code&gt; and &lt;code&gt;avr25&lt;/code&gt;. These architectures mix devices with and without &lt;code&gt;SPH&lt;/code&gt;. For any setting other than</source>
          <target state="translated">このオプションは、コンパイラーによって内部的に使用され、アーキテクチャー &lt;code&gt;avr2&lt;/code&gt; および &lt;code&gt;avr25&lt;/code&gt; のマルチライブラリーを選択してビルドします。これらのアーキテクチャは、 &lt;code&gt;SPH&lt;/code&gt; があるデバイスとないデバイスを混在させます。以外の設定</target>
        </trans-unit>
        <trans-unit id="929f4574a14bae8a52d6ca406bb8cbc25e260697" translate="yes" xml:space="preserve">
          <source>This option is used internally for multilib selection. It is not an optimization option, and you don&amp;rsquo;t need to set it by hand.</source>
          <target state="translated">このオプションは、マルチライブラリを選択するために内部的に使用されます。これは最適化オプションではないため、手動で設定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="7cc2eb8f428f100756f402b24615715e373e0e44" translate="yes" xml:space="preserve">
          <source>This option is used to compile and link code instrumented for coverage analysis. The option is a synonym for</source>
          <target state="translated">このオプションは、カバレッジ解析のためにインスツルメンテーションされたコードをコンパイルしてリンクするために使用されます。このオプションは</target>
        </trans-unit>
        <trans-unit id="48d0c19a39e93a3e805a541c3dbbe3e7dee413d8" translate="yes" xml:space="preserve">
          <source>This option is used to do fine grain control of x86 code generation features. &lt;var&gt;feature-list&lt;/var&gt; is a comma separated list of &lt;var&gt;feature&lt;/var&gt; names. See also</source>
          <target state="translated">このオプションは、x86コード生成機能を細かく制御するために使用されます。 &lt;var&gt;feature-list&lt;/var&gt; は、 &lt;var&gt;feature&lt;/var&gt; 名のコンマ区切りリストです。こちらもご覧ください</target>
        </trans-unit>
        <trans-unit id="d9b5652a39108319ff242af91d4906cb16765dd8" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t effective unless you either provide profile feedback (see</source>
          <target state="translated">このオプションは、プロファイルフィードバックを提供しない限り有効ではありません（</target>
        </trans-unit>
        <trans-unit id="fad34c4a13c209b4406d2d95140526d0990b695b" translate="yes" xml:space="preserve">
          <source>This option makes symbolic debugging impossible.</source>
          <target state="translated">このオプションは、シンボリックデバッグを不可能にします。</target>
        </trans-unit>
        <trans-unit id="f70581e1a11d2a9335f77e119a8e847340333cc1" translate="yes" xml:space="preserve">
          <source>This option marks the generated code as IEEE conformant. You must not use this option unless you also specify</source>
          <target state="translated">このオプションは、生成されたコードを IEEE 準拠としてマークします。このオプションは</target>
        </trans-unit>
        <trans-unit id="15ded195f72714a7729c2ba3f65b232ddd1df723" translate="yes" xml:space="preserve">
          <source>This option may generate better or worse code; results are highly dependent on the structure of loops within the source code.</source>
          <target state="translated">このオプションは、より良いコードを生成したり、より悪いコードを生成したりする可能性があり、結果はソースコード内のループの構造に大きく依存します。</target>
        </trans-unit>
        <trans-unit id="aaf0c177eee46432379774f3339106e6fdf38879" translate="yes" xml:space="preserve">
          <source>This option only has an effect when optimizing for the VR4130. It normally makes code faster, but at the expense of making it bigger. It is enabled by default at optimization level</source>
          <target state="translated">このオプションは、VR4130 用に最適化する場合にのみ効果があります。通常はコードを高速化しますが、コードを大きくすることを犠牲にしています。デフォルトでは、最適化レベルで有効になっています。</target>
        </trans-unit>
        <trans-unit id="ab6cda42cf644e48c433b85f306f3dac6f8ee9b8" translate="yes" xml:space="preserve">
          <source>This option passes on a request to assembler to enable the fixes for the named silicon errata.</source>
          <target state="translated">このオプションはアセンブラへのリクエストを渡して、指定されたシリコンエラッタの修正を有効にするようにします。</target>
        </trans-unit>
        <trans-unit id="845f7cfd869d00c4405522a461f9c235cb5eee1d" translate="yes" xml:space="preserve">
          <source>This option passes on a request to the assembler to enable warning messages when a silicon errata might need to be applied.</source>
          <target state="translated">このオプションは、シリコンエラッタの適用が必要な場合に警告メッセージを有効にするようにアセンブラに要求を渡します。</target>
        </trans-unit>
        <trans-unit id="c17f45a4bb601880d3a1ed4ec74cc989340e16f4" translate="yes" xml:space="preserve">
          <source>This option prevents undesirable excess precision on machines such as the 68000 where the floating registers (of the 68881) keep more precision than a &lt;code&gt;double&lt;/code&gt; is supposed to have. Similarly for the x86 architecture. For most programs, the excess precision does only good, but a few programs rely on the precise definition of IEEE floating point. Use</source>
          <target state="translated">このオプションは、（68881の）浮動レジスターが &lt;code&gt;double&lt;/code&gt; の本来の精度よりも高い精度を維持する68000などのマシンでの望ましくない過剰な精度を防ぎます。x86アーキテクチャについても同様です。ほとんどのプログラムでは、過剰な精度は良い結果をもたらすだけですが、一部のプログラムはIEEE浮動小数点の正確な定義に依存しています。使用する</target>
        </trans-unit>
        <trans-unit id="85c0b69978ecc16b1bd0d2e9088bf661716f775e" translate="yes" xml:space="preserve">
          <source>This option provides a seed that GCC uses in place of random numbers in generating certain symbol names that have to be different in every compiled file. It is also used to place unique stamps in coverage data files and the object files that produce them. You can use the</source>
          <target state="translated">このオプションは、コンパイルされたファイルごとに異なる必要がある特定のシンボル名を生成する際に乱数の代わりにGCCが使用するシードを提供します。また、カバレッジデータファイルやそれを生成するオブジェクトファイルに一意のスタンプを配置するためにも使用されます。このオプションを使用するには</target>
        </trans-unit>
        <trans-unit id="c9dc1b607f48375a6d4f6012661eaa5b1b5ed1be" translate="yes" xml:space="preserve">
          <source>This option results in less efficient code, but some strange hacks that alter the assembler output may be confused by the optimizations performed when this option is not used.</source>
          <target state="translated">このオプションを使用するとコードの効率が悪くなりますが、アセンブラの出力を変更するような奇妙なハックは、このオプションを使用しない場合に実行される最適化によって混乱する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c631110b4d2abceaccb1bae4ccf22e852178fc73" translate="yes" xml:space="preserve">
          <source>This option runs the standard link-time optimizer. When invoked with source code, it generates GIMPLE (one of GCC&amp;rsquo;s internal representations) and writes it to special ELF sections in the object file. When the object files are linked together, all the function bodies are read from these ELF sections and instantiated as if they had been part of the same translation unit.</source>
          <target state="translated">このオプションは、標準のリンク時オプティマイザを実行します。ソースコードで呼び出されると、GIMPLE（GCCの内部表現の1つ）が生成され、オブジェクトファイルの特別なELFセクションに書き込まれます。オブジェクトファイルがリンクされると、すべての関数本体がこれらのELFセクションから読み取られ、同じ変換単位の一部であるかのようにインスタンス化されます。</target>
        </trans-unit>
        <trans-unit id="42349550220727ae2e299d4a2015499909d245e5" translate="yes" xml:space="preserve">
          <source>This option should be used if accesses to volatile bit-fields (or other structure fields, although the compiler usually honors those types anyway) should use a single access of the width of the field&amp;rsquo;s type, aligned to a natural alignment if possible. For example, targets with memory-mapped peripheral registers might require all such accesses to be 16 bits wide; with this flag you can declare all peripheral bit-fields as &lt;code&gt;unsigned short&lt;/code&gt; (assuming short is 16 bits on these targets) to force GCC to use 16-bit accesses instead of, perhaps, a more efficient 32-bit access.</source>
          <target state="translated">このオプションは、揮発性ビットフィールド（または他の構造体フィールドへのアクセス（ただし、コンパイラは通常これらの型を尊重します））がフィールドの型の幅の単一アクセスを使用し、可能な場合は自然な配置に揃えられる場合に使用します。たとえば、メモリマップされたペリフェラルレジスタを備えたターゲットでは、このようなすべてのアクセスを16ビット幅にする必要があります。このフラグを使用すると、すべてのペリフェラルビットフィールドを &lt;code&gt;unsigned short&lt;/code&gt; （これらのターゲットではshortが16ビットであると想定）として宣言して、GCCがおそらくより効率的な32ビットアクセスの代わりに16ビットアクセスを使用するように強制できます。</target>
        </trans-unit>
        <trans-unit id="7a6ef28258c0d1484a7407799fe40321a370f499" translate="yes" xml:space="preserve">
          <source>This option should never be turned on by any</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="701b657607612b9b9057df52c63d10c751e2ef8a" translate="yes" xml:space="preserve">
          <source>This option should not be used in combination with</source>
          <target state="translated">このオプションは</target>
        </trans-unit>
        <trans-unit id="c0219c53e7274021b5f6207f588b3446cadfa388" translate="yes" xml:space="preserve">
          <source>This option significantly reduces the size of debugging information, with some potential loss in type information to the debugger. See</source>
          <target state="translated">このオプションは、デバッガへの型情報の損失の可能性がありますが、デバッグ情報のサイズを大幅に削減します。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="3ed6d18a71b1db6dc14656f8dda97ef522ec526e" translate="yes" xml:space="preserve">
          <source>This option specifies additional section names that can be accessed via GP-relative addressing. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="translated">このオプションは、GP相対アドレス指定を介してアクセスできる追加のセクション名を指定します。これは、変数宣言の &lt;code&gt;section&lt;/code&gt; 属性（「&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;共通変数属性&lt;/a&gt;」を参照）およびカスタムリンカースクリプトと組み合わせて使用​​すると最も役立ちます。 &lt;var&gt;regexp&lt;/var&gt; POSIX拡張正規表現です。</target>
        </trans-unit>
        <trans-unit id="66f5529b3cbbe7b599cd5d6be9976188f77dac0f" translate="yes" xml:space="preserve">
          <source>This option specifies names of sections that can be accessed via a 16-bit offset from &lt;code&gt;r0&lt;/code&gt;; that is, in the low 32K or high 32K of the 32-bit address space. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="translated">このオプションは、 &lt;code&gt;r0&lt;/code&gt; からの16ビットオフセットを介してアクセスできるセクションの名前を指定します。つまり、32ビットアドレス空間の下位32Kまたは上位32Kです。これは、変数宣言の &lt;code&gt;section&lt;/code&gt; 属性（「&lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;共通変数属性&lt;/a&gt;」を参照）およびカスタムリンカースクリプトと組み合わせて使用​​すると最も役立ちます。 &lt;var&gt;regexp&lt;/var&gt; POSIX拡張正規表現です。</target>
        </trans-unit>
        <trans-unit id="4f2c2ce6a978cb353a59c6932941834cbab3c970" translate="yes" xml:space="preserve">
          <source>This option specifies that a console application is to be generated, by instructing the linker to set the PE header subsystem type required for console applications. This option is available for Cygwin and MinGW targets and is enabled by default on those targets.</source>
          <target state="translated">このオプションは、コンソールアプリケーションに必要なPEヘッダサブシステムタイプを設定するようリンカに指示することで、コンソールアプリケーションを生成することを指定します。このオプションは Cygwin と MinGW ターゲットで利用可能で、これらのターゲットではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="21795b6b968aeddf2d8b82bab0643ab8d796f517" translate="yes" xml:space="preserve">
          <source>This option specifies the &lt;var&gt;executable&lt;/var&gt; that will load the build output file being linked. See man ld(1) for more information.</source>
          <target state="translated">このオプションは、リンクされているビルド出力ファイルをロードする &lt;var&gt;executable&lt;/var&gt; を指定します。詳細については、man ld（1）を参照してください。</target>
        </trans-unit>
        <trans-unit id="699a780e6b546e7cd31621b332df13065645e8b9" translate="yes" xml:space="preserve">
          <source>This option specifies the level of compression used for intermediate language written to LTO object files, and is only meaningful in conjunction with LTO mode (</source>
          <target state="translated">このオプションは、LTO オブジェクトファイルに書き込まれる中間言語に使用される圧縮のレベルを指定します。</target>
        </trans-unit>
        <trans-unit id="a52135fd3bb8dd77ca2f36e74d648a4fe294ca69" translate="yes" xml:space="preserve">
          <source>This option specifies the name of the target ARM processor for which GCC should tune the performance of the code. For some ARM implementations better performance can be obtained by using this option. Permissible names are: &amp;lsquo;</source>
          <target state="translated">このオプションは、GCCがコードのパフォーマンスを調整する必要があるターゲットARMプロセッサーの名前を指定します。一部のARM実装では、このオプションを使用することでパフォーマンスが向上する場合があります。許可される名前は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="0092bbb4f5a1fce13bf85587ba520d02478db7fa" translate="yes" xml:space="preserve">
          <source>This option specifies where to find the executables, libraries, include files, and data files of the compiler itself.</source>
          <target state="translated">このオプションは、コンパイラ自体の実行ファイル、ライブラリ、インクルードファイル、データファイルの場所を指定します。</target>
        </trans-unit>
        <trans-unit id="34fcd55b8224119aadeadea926ce6d80328cc8e5" translate="yes" xml:space="preserve">
          <source>This option substantially reduces the size of debugging information, but at significant potential loss in type information to the debugger. See</source>
          <target state="translated">このオプションはデバッグ情報のサイズを大幅に縮小しますが、デバッガの型情報の損失が大きくなる可能性があります。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="12955e4ea22dbc03ccc95585111e9bd2b3cf0146" translate="yes" xml:space="preserve">
          <source>This option suppresses generation of the &lt;code&gt;CALLT&lt;/code&gt; instruction for the v850e, v850e1, v850e2, v850e2v3 and v850e3v5 flavors of the v850 architecture.</source>
          <target state="translated">このオプションは、v850アーキテクチャのv850e、v850e1、v850e2、v850e2v3、およびv850e3v5フレーバーの &lt;code&gt;CALLT&lt;/code&gt; 命令の生成を抑制します。</target>
        </trans-unit>
        <trans-unit id="f8fc982c11de8dc3374f1f50078380019a3e1f62" translate="yes" xml:space="preserve">
          <source>This option suppresses the printing of these labels (in the example above, the vertical bars and the &amp;ldquo;char *&amp;rdquo; and &amp;ldquo;long int&amp;rdquo; text).</source>
          <target state="translated">このオプションは、これらのラベルの印刷を抑制します（上記の例では、垂直バーと「char *」および「long int」テキスト）。</target>
        </trans-unit>
        <trans-unit id="06538fd1399a51a29e2046a8c18ed4e9d2f3a0ec" translate="yes" xml:space="preserve">
          <source>This option tells the compiler that variables declared in common blocks (e.g. Fortran) may later be overridden with longer trailing arrays. This prevents certain optimizations that depend on knowing the array bounds.</source>
          <target state="translated">このオプションは、共通ブロック(Fortranなど)で宣言された変数が、後に長い末尾の配列でオーバーライドされる可能性があることをコンパイラに伝えます。これにより、配列の境界を知ることに依存する最適化を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="2d836f8c7fd152c1f4c1e229195acd7d1d9aa958" translate="yes" xml:space="preserve">
          <source>This option tells the loop optimizer to use language constraints to derive bounds for the number of iterations of a loop. This assumes that loop code does not invoke undefined behavior by for example causing signed integer overflows or out-of-bound array accesses. The bounds for the number of iterations of a loop are used to guide loop unrolling and peeling and loop exit test optimizations. This option is enabled by default.</source>
          <target state="translated">このオプションは、ループオプティマイザが言語制約を使用してループの反復回数の境界を導出するように指示します。これは、ループコードが符号付き整数のオーバーフローやアウトオブバウンドの配列アクセスなどの未定義の動作を起こさないことを前提としています。ループの繰り返し回数の境界は、ループの展開や剥離、ループ終了テストの最適化の指針として使用されます。このオプションはデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="4eb8a2fe595c9e8241e6ef6590e0c3c77e876a48" translate="yes" xml:space="preserve">
          <source>This option turns off this behavior because some programs explicitly rely on variables going to the data section&amp;mdash;e.g., so that the resulting executable can find the beginning of that section and/or make assumptions based on that.</source>
          <target state="translated">一部のプログラムはデータセクションに移動する変数に明示的に依存しているため、このオプションはこの動作をオフにします。たとえば、結果の実行可能ファイルがそのセクションの先頭を見つけたり、それに基づいて仮定を作成したりできます。</target>
        </trans-unit>
        <trans-unit id="a03fa036158e8a2d0e9cc5e169d9035da63e693f" translate="yes" xml:space="preserve">
          <source>This option warns on all uses of &lt;code&gt;alloca&lt;/code&gt; in the source.</source>
          <target state="translated">このオプションは、ソースでの &lt;code&gt;alloca&lt;/code&gt; のすべての使用について警告します。</target>
        </trans-unit>
        <trans-unit id="620c263a82fa884ae16095490ed1aafd4abf9e58" translate="yes" xml:space="preserve">
          <source>This option warns on calls to &lt;code&gt;alloca&lt;/code&gt; with an integer argument whose value is either zero, or that is not bounded by a controlling predicate that limits its value to at most &lt;var&gt;byte-size&lt;/var&gt;. It also warns for calls to &lt;code&gt;alloca&lt;/code&gt; where the bound value is unknown. Arguments of non-integer types are considered unbounded even if they appear to be constrained to the expected range.</source>
          <target state="translated">このオプションは、値がゼロであるか、その値を最大 &lt;var&gt;byte-size&lt;/var&gt; 制限する制御述語によって制限されていない整数引数で &lt;code&gt;alloca&lt;/code&gt; を呼び出すときに警告します。また、バインドされた値が不明な &lt;code&gt;alloca&lt;/code&gt; の呼び出しについても警告します。非整数型の引数は、期待される範囲に制約されているように見えても、無制限と見なされます。</target>
        </trans-unit>
        <trans-unit id="61e70b725867d5de470ac626de798dde99007b65" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support such directives.</source>
          <target state="translated">このオプションは、GCC configure時にアセンブラがそのようなディレクティブをサポートしていることが判明した場合に、デフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="a7e38bb2c3d97b5a7df94e2d4b17a0b93c48b4a5" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support them.</source>
          <target state="translated">このオプションは、GCC configure時にアセンブラがこれらをサポートしていることが判明した場合に、デフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="1c545350367038810cd2987773d5c2915271f3c6" translate="yes" xml:space="preserve">
          <source>This option works only with DWARF debug output.</source>
          <target state="translated">このオプションは、DWARF デバッグ出力でのみ動作します。</target>
        </trans-unit>
        <trans-unit id="bbaec7f2023839aa97132788cd132448147454c0" translate="yes" xml:space="preserve">
          <source>This option, recognized for the cris-axis-elf, arranges to link with input-output functions from a simulator library. Code, initialized data and zero-initialized data are allocated consecutively.</source>
          <target state="translated">cris-axis-elf で認識されるオプションで、シミュレータライブラリからの入出力関数とのリンクを手配します。コード、初期化データ、ゼロ初期化データを連続して配置します。</target>
        </trans-unit>
        <trans-unit id="f3e5914b613a32a5cb2f8fca3e63e01d9cf519e2" translate="yes" xml:space="preserve">
          <source>This parameter prevents mixed usage of multiple atomic models, even if they are compatible, and makes the compiler generate atomic sequences of the specified model only.</source>
          <target state="translated">このパラメータは、互換性があっても複数のアトミックモデルが混在して使用されることを防ぎ、指定されたモデルのアトミックシーケンスのみをコンパイラに生成させます。</target>
        </trans-unit>
        <trans-unit id="a5d669f5cfd64a65baaa023d25d50f1d31d908f7" translate="yes" xml:space="preserve">
          <source>This parameter specifies the offset in bytes of the variable in the thread control block structure that should be used by the generated atomic sequences when the &amp;lsquo;</source>
          <target state="translated">このパラメーターは、スレッド制御ブロック構造内の変数のオフセットをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="a089b6884ff458754998285328ae2911c61445c4" translate="yes" xml:space="preserve">
          <source>This pass distributes the initialization loops and generates a call to memset zero. For example, the loop</source>
          <target state="translated">このパスは初期化ループを分散し、memset zeroへの呼び出しを生成します。例えば、ループ</target>
        </trans-unit>
        <trans-unit id="f9c1c873e049f9ba7fb7727e6d4eeb92324da6de" translate="yes" xml:space="preserve">
          <source>This pass only applies to certain targets that cannot explicitly represent the comparison operation before register allocation is complete.</source>
          <target state="translated">このパスは、レジスタの割り当てが完了する前に比較演算を明示的に表現できない特定のターゲットにのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="461faf3624a4165b061a68a094b7ad69f3e94c46" translate="yes" xml:space="preserve">
          <source>This pragma allows the user to set the visibility for multiple declarations without having to give each a visibility attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">このプラグマを使用すると、ユーザーは、各可視性属性を指定しなくても、複数の宣言の可視性を設定できます（&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e202730c1bfc48c0778f7ea2bd0c6eb45186cc47" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set global optimization options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;optimize(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;optimize&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="translated">このプラグマを使用すると、ソースファイルで後で定義される関数のグローバル最適化オプションを設定できます。1つ以上の文字列を指定できます。この時点以降に定義された各関数は、各 &lt;var&gt;string&lt;/var&gt; 引数に対して1つの &lt;code&gt;optimize(&lt;/code&gt; &lt;var&gt;string&lt;/var&gt; &lt;code&gt;)&lt;/code&gt; 属性で宣言されているかのように扱われます。プラグマ内の文字列を囲む括弧はオプションです。 &lt;code&gt;optimize&lt;/code&gt; 属性と属性構文の詳細については、&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1c9f09620296c49e0c152a1252d539d7a1599030" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set target-specific options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;target(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;target&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="translated">このプラグマを使用すると、ソースファイルで後で定義される関数のターゲット固有のオプションを設定できます。1つ以上の文字列を指定できます。この時点以降に定義された各関数は、各 &lt;var&gt;string&lt;/var&gt; 引数に対して1つの &lt;code&gt;target(&lt;/code&gt; &lt;var&gt;string&lt;/var&gt; &lt;code&gt;)&lt;/code&gt; 属性を使用して宣言されたかのように扱われます。プラグマ内の文字列を囲む括弧はオプションです。 &lt;code&gt;target&lt;/code&gt; 属性と属性構文の詳細については、&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;関数属性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e5bdf333d1a9b5e255036222cc92af1884c97c92" translate="yes" xml:space="preserve">
          <source>This pragma and the &lt;code&gt;asm&lt;/code&gt; labels extension interact in a complicated manner. Here are some corner cases you may want to be aware of:</source>
          <target state="translated">このプラグマと &lt;code&gt;asm&lt;/code&gt; ラベル拡張は、複雑な方法で相互作用します。以下に、注意が必要ないくつかのケースを示します。</target>
        </trans-unit>
        <trans-unit id="df6ea502dad4ed3727dbc5aab1f84068b260e566" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called after main, or during shared module unloading, by adding a call to the &lt;code&gt;.fini&lt;/code&gt; section.</source>
          <target state="translated">このプラグマは、 &lt;code&gt;.fini&lt;/code&gt; セクションへの呼び出しを追加することにより、リストされた各 &lt;var&gt;function&lt;/var&gt; がメインの後で、または共有モジュールのアンロード中に呼び出されるようにします。</target>
        </trans-unit>
        <trans-unit id="7ef98ac7a5a65ac560b0183a0711ed56313ca3a4" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called during initialization (before &lt;code&gt;main&lt;/code&gt;) or during shared module loading, by adding a call to the &lt;code&gt;.init&lt;/code&gt; section.</source>
          <target state="translated">このプラグマにより、初期化中（ &lt;code&gt;main&lt;/code&gt; の前）または共有モジュールのロード中に、 &lt;code&gt;.init&lt;/code&gt; セクションに呼び出しを追加することにより、リストされた各 &lt;var&gt;function&lt;/var&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4305b5e7eee9369ab0724af50f66a74eaee06881" translate="yes" xml:space="preserve">
          <source>This pragma clears the current &lt;code&gt;#pragma GCC target&lt;/code&gt; and &lt;code&gt;#pragma GCC optimize&lt;/code&gt; to use the default switches as specified on the command line.</source>
          <target state="translated">このプラグマは、現在の &lt;code&gt;#pragma GCC target&lt;/code&gt; と &lt;code&gt;#pragma GCC optimize&lt;/code&gt; をクリアして、コマンドラインで指定されたデフォルトのスイッチを使用します。</target>
        </trans-unit>
        <trans-unit id="c86f808ebf265d2793b4414b964c355b2c508a5f" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol1&lt;/var&gt; to be a weak alias of &lt;var&gt;symbol2&lt;/var&gt;. It is an error if &lt;var&gt;symbol2&lt;/var&gt; is not defined in the current translation unit.</source>
          <target state="translated">このプラグマは宣言する &lt;var&gt;symbol1&lt;/var&gt; 弱い別名であることを &lt;var&gt;symbol2&lt;/var&gt; 。現在の翻訳単位で &lt;var&gt;symbol2&lt;/var&gt; が定義されていない場合はエラーになります。</target>
        </trans-unit>
        <trans-unit id="2e41ab6e510f688ee4c0ac9d61fab50b654b5c94" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol&lt;/var&gt; to be weak, as if the declaration had the attribute of the same name. The pragma may appear before or after the declaration of &lt;var&gt;symbol&lt;/var&gt;. It is not an error for &lt;var&gt;symbol&lt;/var&gt; to never be defined at all.</source>
          <target state="translated">このプラグマは、宣言が同じ名前の属性を持っているかのように、 &lt;var&gt;symbol&lt;/var&gt; を弱いものとして宣言します。プラグマは、 &lt;var&gt;symbol&lt;/var&gt; の宣言の前または後に表示できます。 &lt;var&gt;symbol&lt;/var&gt; がまったく定義されないことはエラーではありません。</target>
        </trans-unit>
        <trans-unit id="6d680236fdbf196915aaf992aecdb77c6a8b587b" translate="yes" xml:space="preserve">
          <source>This pragma declares variables to be possibly unused. GCC does not produce warnings for the listed variables. The effect is similar to that of the &lt;code&gt;unused&lt;/code&gt; attribute, except that this pragma may appear anywhere within the variables&amp;rsquo; scopes.</source>
          <target state="translated">このプラグマは、変数が未使用になる可能性があることを宣言します。GCCは、リストされた変数に対して警告を生成しません。効果は、このプラグマが変数のスコープ内の任意の場所に現れる可能性があることを除いて、 &lt;code&gt;unused&lt;/code&gt; 属性の効果と同様です。</target>
        </trans-unit>
        <trans-unit id="297d6f917f11b7d696df277d2ac80b8a527dc0e9" translate="yes" xml:space="preserve">
          <source>This pragma gives the C function &lt;var&gt;oldname&lt;/var&gt; the assembly symbol &lt;var&gt;newname&lt;/var&gt;. The preprocessor macro &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; is defined if this pragma is available (currently on all platforms).</source>
          <target state="translated">このプラグマは、C関数 &lt;var&gt;oldname&lt;/var&gt; にアセンブリシンボル &lt;var&gt;newname&lt;/var&gt; を与えます。このプラグマが使用可能な場合、プリプロセッサマクロ &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; が定義されています（現在すべてのプラットフォーム上）。</target>
        </trans-unit>
        <trans-unit id="1d47f09719c8273483bc0daaf5859bab9562dec9" translate="yes" xml:space="preserve">
          <source>This pragma is accepted, but has no effect.</source>
          <target state="translated">このプラグマは受け入れられていますが、効果はありません。</target>
        </trans-unit>
        <trans-unit id="d1d3fa1a452de5b39a96a52139032ce525a57ad0" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented, but the default is to &amp;ldquo;off&amp;rdquo; unless</source>
          <target state="translated">このプラグマは実装されていませんが、以下の場合を除き、デフォルトは「オフ」です。</target>
        </trans-unit>
        <trans-unit id="df0d00bf5dd61e1e80f9e58129099c35fef14b94" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented. Expressions are currently only contracted if</source>
          <target state="translated">このプラグマは実装されていません。式は現在のところ</target>
        </trans-unit>
        <trans-unit id="42570b540208a522195f34bdcb31e38a4d6b0221" translate="yes" xml:space="preserve">
          <source>This pragma saves the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the top of the stack for this macro.</source>
          <target state="translated">このプラグマは、 &lt;var&gt;macro_name&lt;/var&gt; という名前のマクロの値を、このマクロのスタックの最上位に保存します。</target>
        </trans-unit>
        <trans-unit id="0d99cb35c6101970038eaf301a0c3beb6107bf5a" translate="yes" xml:space="preserve">
          <source>This pragma sets the alignment of fields in structures. The values of &lt;var&gt;alignment&lt;/var&gt; may be &lt;code&gt;mac68k&lt;/code&gt;, to emulate m68k alignment, or &lt;code&gt;power&lt;/code&gt;, to emulate PowerPC alignment. Uses of this pragma nest properly; to restore the previous setting, use &lt;code&gt;reset&lt;/code&gt; for the &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="translated">このプラグマは、構造体のフィールドの配置を設定します。 &lt;var&gt;alignment&lt;/var&gt; の値は、m68kアラインメントをエミュレートする場合は &lt;code&gt;mac68k&lt;/code&gt; 、PowerPCアラインメントをエミュレートする場合は &lt;code&gt;power&lt;/code&gt; です。このプラグマを使用すると、適切にネストされます。以前の設定に &lt;code&gt;reset&lt;/code&gt; は、 &lt;var&gt;alignment&lt;/var&gt; リセットを使用します。</target>
        </trans-unit>
        <trans-unit id="6e23a1d175eeaabf52f59f12be4c55b597b0251f" translate="yes" xml:space="preserve">
          <source>This pragma sets the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the value on top of the stack for this macro. If the stack for &lt;var&gt;macro_name&lt;/var&gt; is empty, the value of the macro remains unchanged.</source>
          <target state="translated">このプラグマは、 &lt;var&gt;macro_name&lt;/var&gt; という名前のマクロの値を、このマクロのスタックの一番上の値に設定します。 &lt;var&gt;macro_name&lt;/var&gt; のスタックが空の場合、マクロの値は変更されません。</target>
        </trans-unit>
        <trans-unit id="03b17cd16d3c44521375b42df7bda966fe331c0e" translate="yes" xml:space="preserve">
          <source>This pragma silently applies only to declarations with external linkage. The &lt;code&gt;asm&lt;/code&gt; label feature does not have this restriction.</source>
          <target state="translated">このプラグマは、外部リンケージのある宣言にのみ暗黙的に適用されます。 &lt;code&gt;asm&lt;/code&gt; ラベル機能は、この制限はありません。</target>
        </trans-unit>
        <trans-unit id="263438c853ee982ccc7a3904487e0cd3d115c742" translate="yes" xml:space="preserve">
          <source>This prefix is also used for finding files such as</source>
          <target state="translated">この接頭辞は、次のようなファイルを見つけるためにも使われます。</target>
        </trans-unit>
        <trans-unit id="853d289c160cc93497a02e37abb2f9f0217d9d34" translate="yes" xml:space="preserve">
          <source>This problem may for instance occur when we use this pattern recursively, like so:</source>
          <target state="translated">この問題は、例えば、このパターンを再帰的に使用する場合に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="92bb145abdc75a03d83add48a654c73cbe5bd131" translate="yes" xml:space="preserve">
          <source>This problem only affects kernel stores and, depending on the system, kernel loads. As an example, a speculatively-executed store may load the target memory into cache and mark the cache line as dirty, even if the store itself is later aborted. If a DMA operation writes to the same area of memory before the &amp;ldquo;dirty&amp;rdquo; line is flushed, the cached data overwrites the DMA-ed data. See the R10K processor manual for a full description, including other potential problems.</source>
          <target state="translated">この問題はカーネルストアにのみ影響し、システムによってはカーネルロードに影響します。例として、投機的に実行されたストアは、ストア自体が後で中止された場合でも、ターゲットメモリをキャッシュにロードし、キャッシュラインをダーティとしてマークします。「ダーティ」ラインがフラッシュされる前にDMA操作がメモリの同じ領域に書き込む場合、キャッシュされたデータはDMAされたデータを上書きします。他の潜在的な問題を含む完全な説明については、R10Kプロセッサのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="6bba2aa8d001273821fc7a22f52c80ae052e1b79" translate="yes" xml:space="preserve">
          <source>This qualifier informs the compiler that the &lt;code&gt;asm&lt;/code&gt; statement may perform a jump to one of the labels listed in the &lt;var&gt;GotoLabels&lt;/var&gt;. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="translated">この修飾子は、 &lt;code&gt;asm&lt;/code&gt; ステートメントが &lt;var&gt;GotoLabels&lt;/var&gt; にリストされているラベルの1つにジャンプする可能性があることをコンパイラーに通知します。&lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabelsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4093c1766b06cd06224229c5ab31374f32640737" translate="yes" xml:space="preserve">
          <source>This restriction of ISO C makes it hard to write code that is portable to traditional C compilers, because the programmer does not know whether the &lt;code&gt;uid_t&lt;/code&gt; type is &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;long&lt;/code&gt;. Therefore, in cases like these GNU C allows a prototype to override a later old-style definition. More precisely, in GNU C, a function prototype argument type overrides the argument type specified by a later old-style definition if the former type is the same as the latter type before promotion. Thus in GNU C the above example is equivalent to the following:</source>
          <target state="translated">ISO Cのこの制限により、プログラマーは &lt;code&gt;uid_t&lt;/code&gt; 型が &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、または &lt;code&gt;long&lt;/code&gt; のいずれであるかを知らないため、従来のCコンパイラーに移植可能なコードを書くことが難しくなります。したがって、これらのGNU Cのようなケースでは、プロトタイプが後の古いスタイルの定義をオーバーライドできるようにします。より正確には、GNU Cでは、昇格前の型が後者の型と同じである場合、関数のプロトタイプ引数の型は、後の古いスタイルの定義で指定された引数の型をオーバーライドします。したがって、GNU Cでは、上記の例は次と同等です。</target>
        </trans-unit>
        <trans-unit id="b4ab6e646b44f4632464748755730b2c272ad5f1" translate="yes" xml:space="preserve">
          <source>This sample shows how to specify the assembler name for data:</source>
          <target state="translated">このサンプルでは、データのアセンブラ名を指定する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="e5b05b60d6f2ee21a98f997beb1f9023f6a4e7bc" translate="yes" xml:space="preserve">
          <source>This says that any input file whose name ends in &amp;lsquo;</source>
          <target state="translated">これは、名前が「</target>
        </trans-unit>
        <trans-unit id="8bc7756ea229cad62f19381d0aec545c10cece4c" translate="yes" xml:space="preserve">
          <source>This says that the suffix is an alias for a known &lt;var&gt;language&lt;/var&gt;. This is similar to using the</source>
          <target state="translated">これは、サフィックスが既知の &lt;var&gt;language&lt;/var&gt; エイリアスであることを示しています。これは、</target>
        </trans-unit>
        <trans-unit id="77e07f2febdffcd9c896323de91d75db17316bb7" translate="yes" xml:space="preserve">
          <source>This section describes PowerPC built-in functions that do not require the inclusion of any special header files to declare prototypes or provide macro definitions. The sections that follow describe additional PowerPC built-in functions.</source>
          <target state="translated">このセクションでは、プロトタイプを宣言したりマクロ定義を提供したりするために特別なヘッダーファイルを含める必要のない PowerPC 組み込み関数について説明します。以下のセクションでは、その他のPowerPC組み込み関数について説明します。</target>
        </trans-unit>
        <trans-unit id="4b61f221f0794b55701031d13518070c0255286e" translate="yes" xml:space="preserve">
          <source>This section describes built-in functions that are not named after a specific FR-V instruction.</source>
          <target state="translated">ここでは、特定のFR-V命令に名前を付けない組み込み関数について説明します。</target>
        </trans-unit>
        <trans-unit id="d7abf825d737ed6aeedbed114bb5b1fa96d1d588" translate="yes" xml:space="preserve">
          <source>This section describes command-line options that are primarily of interest to GCC developers, including options to support compiler testing and investigation of compiler bugs and compile-time performance problems. This includes options that produce debug dumps at various points in the compilation; that print statistics such as memory use and execution time; and that print information about GCC&amp;rsquo;s configuration, such as where it searches for libraries. You should rarely need to use any of these options for ordinary compilation and linking tasks.</source>
          <target state="translated">このセクションでは、コンパイラーのテストやコンパイラーのバグやコンパイル時のパフォーマンスの問題の調査をサポートするオプションなど、主にGCC開発者が関心を持つコマンドラインオプションについて説明します。これには、コンパイルのさまざまな時点でデバッグダンプを生成するオプションが含まれます。メモリの使用状況や実行時間などの統計情報を出力します。ライブラリを検索する場所など、GCCの構成に関する情報を出力します。通常のコンパイルおよびリンクタスクでは、これらのオプションを使用する必要はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="2bedaec624c9942033ae97b423071f6ba2ad1456" translate="yes" xml:space="preserve">
          <source>This section describes known problems that affect users of GCC. Most of these are not GCC bugs per se&amp;mdash;if they were, we would fix them. But the result for a user may be like the result of a bug.</source>
          <target state="translated">このセクションでは、GCCのユーザーに影響を与える既知の問題について説明します。これらのほとんどは、それ自体GCCバグではありません。もしそうであれば、私たちはそれらを修正します。しかし、ユーザーの結果はバグの結果のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5b43873b1eac185b9fa8755ff87aff197f92a2f8" translate="yes" xml:space="preserve">
          <source>This section describes several environment variables that affect how GCC operates. Some of them work by specifying directories or prefixes to use when searching for various kinds of files. Some are used to specify other aspects of the compilation environment.</source>
          <target state="translated">この節では、GCC の動作に影響を与えるいくつかの環境変数について説明します。いくつかの環境変数は、様々な種類のファイルを検索する際に使用するディレクトリや接頭辞を指定することで動作します。また、コンパイル環境の他の側面を指定するために使用されるものもあります。</target>
        </trans-unit>
        <trans-unit id="9055e1a522ff74558948ff04f5b4f164a424da3a" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for C++ programs. You can also use most of the GNU compiler options regardless of what language your program is in. For example, you might compile a file</source>
          <target state="translated">この節では、C++プログラムにのみ意味のあるコマンドラインオプションについて説明します。また、プログラムの言語に関係なく、GNUコンパイラのオプションのほとんどを使うことができます。例えば、ファイル</target>
        </trans-unit>
        <trans-unit id="378b3683f59604e4695371da6c2fddfaacd92ba1" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for Objective-C and Objective-C++ programs. You can also use most of the language-independent GNU compiler options. For example, you might compile a file</source>
          <target state="translated">この節では、Objective-C と Objective-C++プログラムでのみ意味を持つコマンドラインオプションについて説明します。また、言語に依存しないGNUコンパイラオプションのほとんどを使うことができます。例えば、以下のようなファイルをコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="382e6f59f6c971fab95547a05668a5918cd72126" translate="yes" xml:space="preserve">
          <source>This section describes the syntax with which &lt;code&gt;__attribute__&lt;/code&gt; may be used, and the constructs to which attribute specifiers bind, for the C language. Some details may vary for C++ and Objective-C. Because of infelicities in the grammar for attributes, some forms described here may not be successfully parsed in all cases.</source>
          <target state="translated">このセクションでは、C言語の &lt;code&gt;__attribute__&lt;/code&gt; で使用できる構文、および属性指定子がバインドする構成について説明します。C ++とObjective-Cでは一部の詳細が異なる場合があります。属性の文法に不備があるため、ここで説明する一部の形式は、すべての場合に正常に解析されるとは限りません。</target>
        </trans-unit>
        <trans-unit id="bd8e6c5371362aa092aae0b0592e55198f1c8b9c" translate="yes" xml:space="preserve">
          <source>This section documents the encoding of method types, which is rarely needed to use Objective-C. You should skip it at a first reading; the runtime provides functions that will work on methods and can walk through the list of parameters and interpret them for you. These functions are part of the public &amp;ldquo;API&amp;rdquo; and are the preferred way to interact with method signatures from user code.</source>
          <target state="translated">このセクションでは、Objective-Cを使用するためにめったに必要とされないメソッドタイプのエンコーディングについて説明します。あなたは最初の読書でそれをスキップする必要があります。ランタイムは、メソッドで機能し、パラメーターのリストをウォークスルーして解釈できる関数を提供します。これらの関数はパブリック「API」の一部であり、ユーザーコードからのメソッドシグネチャと対話するための推奨される方法です。</target>
        </trans-unit>
        <trans-unit id="92bc19fae671586234add4d5e1d253df22100b8a" translate="yes" xml:space="preserve">
          <source>This section intentionally empty.</source>
          <target state="translated">このセクションは意図的に空になっています。</target>
        </trans-unit>
        <trans-unit id="9dcc691a02a9391b7e0c30aab063927ea00a125c" translate="yes" xml:space="preserve">
          <source>This section is specific for the GNU Objective-C runtime. If you are using a different runtime, you can skip it.</source>
          <target state="translated">このセクションはGNU Objective-Cランタイムに特化しています。他のランタイムを使用している場合は、省略しても構いません。</target>
        </trans-unit>
        <trans-unit id="4d2663a3da2126761e59e5b901038db322ae02e2" translate="yes" xml:space="preserve">
          <source>This section lists changes that people frequently request, but which we do not make because we think GCC is better without them.</source>
          <target state="translated">ここでは、よくリクエストされる変更点をリストアップしていますが、GCCはない方がいいと思っているので、作っていません。</target>
        </trans-unit>
        <trans-unit id="6be9fd8a27bd882ee2957a5506f02578eed902d6" translate="yes" xml:space="preserve">
          <source>This section lists various difficulties encountered in using GCC together with other compilers or with the assemblers, linkers, libraries and debuggers on certain systems.</source>
          <target state="translated">このセクションでは、GCCを他のコンパイラと併用したり、特定のシステム上でアセンブラ、リンカ、ライブラリ、デバッガを使用したりする際に遭遇する様々な問題を列挙しています。</target>
        </trans-unit>
        <trans-unit id="fc5c464b4c99442f66523b49fbd84dd32d4a9f33" translate="yes" xml:space="preserve">
          <source>This sections describes built-in functions related to read and write instructions to access memory. These functions generate &lt;code&gt;membar&lt;/code&gt; instructions to flush the I/O load and stores where appropriate, as described in Fujitsu&amp;rsquo;s manual described above.</source>
          <target state="translated">このセクションでは、メモリにアクセスするための読み取りおよび書き込み命令に関連する組み込み関数について説明します。これらの関数は、上記のFujitsuのマニュアルに記載されているように、I / Oロードをフラッシュするための &lt;code&gt;membar&lt;/code&gt; 命令を生成し、必要に応じて保存します。</target>
        </trans-unit>
        <trans-unit id="657a9d90f9f4dd0b4af1725dd023d864364a9a6d" translate="yes" xml:space="preserve">
          <source>This selects the CPU to generate code for at compilation time by determining the processor type of the compiling machine. Using</source>
          <target state="translated">コンパイルマシンのプロセッサの種類を決定して、コンパイル時にコードを生成するCPUを選択します。使用方法は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="52fbcd0192529b61aa6e52c7943fcf31e0d69f81" translate="yes" xml:space="preserve">
          <source>This sets the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="translated">現在スタック上に保存されているステータス・レジスタのコピーに指定されたビットを設定します。これは割り込みハンドラ内でのみ動作し、ステータスレジスタの変更はハンドラが戻ってきてから有効になります。</target>
        </trans-unit>
        <trans-unit id="c8206cbbb17dc4eed11021be8e812bfcaf18d27d" translate="yes" xml:space="preserve">
          <source>This setting is only useful for strides that are known and constant.</source>
          <target state="translated">この設定は、既知で一定のストライドにのみ有効です。</target>
        </trans-unit>
        <trans-unit id="efe46d223c613fd1d939a40a5c5d5b8742ce8085" translate="yes" xml:space="preserve">
          <source>This setting is useful for processors that have hardware prefetchers, in which case there may be conflicts between the hardware prefetchers and the software prefetchers. If the hardware prefetchers have a maximum stride they can handle, it should be used here to improve the use of software prefetchers.</source>
          <target state="translated">この設定は、ハードウェアプリフェッチャがあるプロセッサで、ハードウェアプリフェッチャとソフトウェアプリフェッチャの間に競合がある場合に有用です。ハードウェアプリフェッチャが扱える最大のストライドを持っている場合は、 ソフトウェアプリフェッチャの使用を改善するためにここで使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="23f9a68d34fdcbac9802d87e4691f1d481ccdb61" translate="yes" xml:space="preserve">
          <source>This size is also used for inlining decisions. If you use &lt;code&gt;asm inline&lt;/code&gt; instead of just &lt;code&gt;asm&lt;/code&gt;, then for inlining purposes the size of the asm is taken as the minimum size, ignoring how many instructions GCC thinks it is.</source>
          <target state="translated">このサイズは、決定のインライン化にも使用されます。あなたが使用している場合は &lt;code&gt;asm inline&lt;/code&gt; だけではなく &lt;code&gt;asm&lt;/code&gt; 、その後、インライン化の目的のためにASMの大きさは、GCCは、それがあると考えてどのように多くの命令を無視し、最小サイズとしています。</target>
        </trans-unit>
        <trans-unit id="6436ee6603a6a283bb34edc1a40e3b3faa54b98d" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the function &lt;code&gt;func&lt;/code&gt; in the assembler code should be &lt;code&gt;MYFUNC&lt;/code&gt;.</source>
          <target state="translated">これは、アセンブラコードで関数 &lt;code&gt;func&lt;/code&gt; に使用される名前が &lt;code&gt;MYFUNC&lt;/code&gt; であることを指定します。</target>
        </trans-unit>
        <trans-unit id="232e23ab36d2ae531cc928cda4ab49d45def08c5" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the variable &lt;code&gt;foo&lt;/code&gt; in the assembler code should be &amp;lsquo;</source>
          <target state="translated">これは、アセンブラー・コードの変数 &lt;code&gt;foo&lt;/code&gt; に使用される名前が '</target>
        </trans-unit>
        <trans-unit id="d2e7d4d12b96a2f9b08b67a67b6c05ae9677d81f" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. This option can be used in conjunction with or instead of the</source>
          <target state="translated">これはターゲットとなるARMアーキテクチャの名前を指定します。GCCはこの名前を使用して、アセンブリコードを生成する際にどのような命令を出すことができるかを決定します。このオプションは</target>
        </trans-unit>
        <trans-unit id="5f5ffdf441cdde0f8b6e9e4c7fe02c1f21c8c411" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM processor. GCC uses this name to derive the name of the target ARM architecture (as if specified by</source>
          <target state="translated">ターゲットARMプロセッサの名前を指定します。GCCはこの名前を使用して、ターゲットARMアーキテクチャの名前を導出します。</target>
        </trans-unit>
        <trans-unit id="8e151a0bdb560628cb5ddbb4913dc14cfb482f53" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target Nios II architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="translated">これは、ターゲットNios IIアーキテクチャの名前を指定します。GCCはこの名前を使用して、アセンブリコードの生成時に発行できる命令の種類を決定します。許可される名前は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="085bdfa0f8d1afe6178b912d6185b5a3f9cb191a" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="translated">ターゲットアーキテクチャの名前を指定します。GCCはこの名前を使用して、アセンブリコードの生成時に発行できる命令の種類を決定します。許可される名前は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="64aaf23d10b975a481227888a0c489eb1e3c16c0" translate="yes" xml:space="preserve">
          <source>This specifies what floating-point hardware (or hardware emulation) is available on the target. Permissible names are: &amp;lsquo;</source>
          <target state="translated">これは、ターゲットで使用可能な浮動小数点ハードウェア（またはハードウェアエミュレーション）を指定します。許可される名前は次のとおりです： '</target>
        </trans-unit>
        <trans-unit id="345d1833d12c5392425b9eb5b3c8d3be49244d38" translate="yes" xml:space="preserve">
          <source>This switch causes the command line used to invoke the compiler to be recorded into the object file that is being created. This switch is only implemented on some targets and the exact format of the recording is target and binary file format dependent, but it usually takes the form of a section containing ASCII text. This switch is related to the</source>
          <target state="translated">このスイッチは、コンパイラを呼び出すために使用されたコマンド・ラインを作成中のオブジェクト・ファイルに記録します。このスイッチは一部のターゲットにのみ実装されており、記録の正確な形式はターゲットとバイナリファイルの形式に依存しますが、通常はASCIIテキストを含むセクションの形をとります。このスイッチは</target>
        </trans-unit>
        <trans-unit id="fcef4a45435978f94ac21ce5b4ddc80a97324665" translate="yes" xml:space="preserve">
          <source>This switch causes the command-line options used to invoke the compiler that may affect code generation to be appended to the DW_AT_producer attribute in DWARF debugging information. The options are concatenated with spaces separating them from each other and from the compiler version. It is enabled by default. See also</source>
          <target state="translated">このスイッチにより、コード生成に影響を与える可能性のあるコンパイラの呼び出しに使用されるコマンドライン・オプションが、DWARF デバッグ情報の DW_AT_producer 属性に追加されます。オプションはスペースで連結されており、お互いのオプションとコンパイラのバージョンを区切っています。デフォルトでは有効になっています。これはデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="a3ef7cfaa3693eda0200855e73487a3931ad86b9" translate="yes" xml:space="preserve">
          <source>This switch declares that the user does not attempt to compare pointers to inline functions or methods where the addresses of the two functions are taken in different shared objects.</source>
          <target state="translated">このスイッチは、ユーザーがインライン関数やメソッドへのポインタを比較しようとしないことを宣言します。</target>
        </trans-unit>
        <trans-unit id="9d12a205f2d4388bb6e6b2aa9be08da33c955f0c" translate="yes" xml:space="preserve">
          <source>This switch disables the automatic removal of redundant &lt;code&gt;membar&lt;/code&gt; instructions from the generated code.</source>
          <target state="translated">このスイッチは、生成されたコードからの冗長な &lt;code&gt;membar&lt;/code&gt; 命令の自動削除を無効にします。</target>
        </trans-unit>
        <trans-unit id="fb214efcf15f2eebcb5c8359308da41aee1bb7a5" translate="yes" xml:space="preserve">
          <source>This switch enables or disables the generation of ISEL instructions.</source>
          <target state="translated">このスイッチは、ISEL命令の生成を有効または無効にします。</target>
        </trans-unit>
        <trans-unit id="121380ba5bbee8a3b6396891291392c7f45ab990" translate="yes" xml:space="preserve">
          <source>This switch is mainly for debugging the compiler and will likely be removed in a future version.</source>
          <target state="translated">このスイッチは主にコンパイラをデバッグするためのもので、将来のバージョンでは削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="83b61792d6d517f0567ee609808598af69f30e65" translate="yes" xml:space="preserve">
          <source>This switch removes redundant &lt;code&gt;membar&lt;/code&gt; instructions from the compiler-generated code. It is enabled by default.</source>
          <target state="translated">このスイッチは、コンパイラが生成したコードから冗長な &lt;code&gt;membar&lt;/code&gt; 命令を削除します。デフォルトでは有効になっています。</target>
        </trans-unit>
        <trans-unit id="2700c0c5f6842561acacd13d2b72a8353682aa23" translate="yes" xml:space="preserve">
          <source>This syntax is defined in the C++ 2011 standard, but has been supported by G++ and other compilers since well before 2011.</source>
          <target state="translated">この構文は C++2011 標準で定義されていますが、2011 年以前から G++や他のコンパイラでサポートされています。</target>
        </trans-unit>
        <trans-unit id="82fcb60fefcb3dd52763982ecf7c2e7bdfe84505" translate="yes" xml:space="preserve">
          <source>This tells the compiler that a function is &lt;code&gt;malloc&lt;/code&gt;-like, i.e., that the pointer &lt;var&gt;P&lt;/var&gt; returned by the function cannot alias any other pointer valid when the function returns, and moreover no pointers to valid objects occur in any storage addressed by &lt;var&gt;P&lt;/var&gt;.</source>
          <target state="translated">これは、関数が &lt;code&gt;malloc&lt;/code&gt; に似ていること、つまり、関数から返されたポインター &lt;var&gt;P&lt;/var&gt; が、関数が戻ったときに有効な他のポインターをエイリアスできず、さらに、 &lt;var&gt;P&lt;/var&gt; によってアドレス指定されたストレージで有効なオブジェクトへのポインターが発生しないことをコンパイラーに伝えます。</target>
        </trans-unit>
        <trans-unit id="57ca8b09b0bd70a0af88532cce8b6c0a57af5ea7" translate="yes" xml:space="preserve">
          <source>This tells the compiler to create, override or delete the named spec string. All lines after this directive up to the next directive or blank line are considered to be the text for the spec string. If this results in an empty string then the spec is deleted. (Or, if the spec did not exist, then nothing happens.) Otherwise, if the spec does not currently exist a new spec is created. If the spec does exist then its contents are overridden by the text of this directive, unless the first character of that text is the &amp;lsquo;</source>
          <target state="translated">これは、名前付き仕様文字列を作成、オーバーライド、または削除するようコンパイラーに指示します。このディレクティブの後の次のディレクティブまたは空白行までのすべての行は、スペック文字列のテキストと見なされます。これが空の文字列になる場合、スペックは削除されます。（または、仕様が存在しない場合は何も起こりません。）それ以外の場合、仕様が現在存在しない場合は、新しい仕様が作成されます。仕様が存在する場合、テキストの最初の文字が 'でない限り、その内容はこのディレクティブのテキストで上書きされます。</target>
        </trans-unit>
        <trans-unit id="ad4018bf7af9477c8687cfe9f142d2504a7341b9" translate="yes" xml:space="preserve">
          <source>This turns off certain features of GCC that are incompatible with ISO C90 (when compiling C code), or of standard C++ (when compiling C++ code), such as the &lt;code&gt;asm&lt;/code&gt; and &lt;code&gt;typeof&lt;/code&gt; keywords, and predefined macros such as &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;vax&lt;/code&gt; that identify the type of system you are using. It also enables the undesirable and rarely used ISO trigraph feature. For the C compiler, it disables recognition of C++ style &amp;lsquo;</source>
          <target state="translated">ようなISO C90（Cコードをコンパイル）と互換性があるGCCの特定の機能をオフ、または標準的なCのこのターン++（C ++コードをコンパイル）、 &lt;code&gt;asm&lt;/code&gt; と &lt;code&gt;typeof&lt;/code&gt; をキーワード、等の定義済みマクロ &lt;code&gt;unix&lt;/code&gt; と &lt;code&gt;vax&lt;/code&gt; 識別使用しているシステムのタイプ。また、望ましくない、めったに使用されないISOトリグラフ機能も有効にします。Cコンパイラの場合、C ++スタイルの認識を無効にします '</target>
        </trans-unit>
        <trans-unit id="92dd1276eca8dc32a61b9ef6e7b622bea22fa0aa" translate="yes" xml:space="preserve">
          <source>This value is used to limit superblock formation once the given percentage of executed instructions is covered. This limits unnecessary code size expansion.</source>
          <target state="translated">この値は、実行される命令の所定の割合がカバーされると、スーパーブロック形成を制限するために使用されます。これにより、不必要なコードサイズの拡張を制限します。</target>
        </trans-unit>
        <trans-unit id="25d25d25b176faf62dac7b5023bc142fa458d69e" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; (see above), except that system header files are not ignored, so it implies</source>
          <target state="translated">この変数は、システムヘッダーファイルが無視されないことを除いて、 &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; （上記を参照）と同じであるため、</target>
        </trans-unit>
        <trans-unit id="1ac6e7ae8cc06c38e89aed855dd5fc2e644da6f4" translate="yes" xml:space="preserve">
          <source>This variable is used to pass locale information to the compiler. One way in which this information is used is to determine the character set to be used when character literals, string literals and comments are parsed in C and C++. When the compiler is configured to allow multibyte characters, the following values for &lt;code&gt;LANG&lt;/code&gt; are recognized:</source>
          <target state="translated">この変数は、ロケール情報をコンパイラーに渡すために使用されます。この情報が使用される1つの方法は、文字リテラル、文字列リテラル、およびコメントがCおよびC ++で解析されるときに使用される文字セットを決定することです。コンパイラーがマルチバイト文字を許可するように構成されている場合、以下の &lt;code&gt;LANG&lt;/code&gt; の値が認識されます。</target>
        </trans-unit>
        <trans-unit id="4be1995e1045ff6bbec640e0a942d94152cfdec6" translate="yes" xml:space="preserve">
          <source>This warning also warns about bitwise comparisons that always evaluate to true or false, for instance:</source>
          <target state="translated">この警告は、例えば、常に真か偽かを評価するビット単位の比較についても警告しています。</target>
        </trans-unit>
        <trans-unit id="0b2459c9299d10d23b0470cd3490145629414a5b" translate="yes" xml:space="preserve">
          <source>This warning can be disabled by</source>
          <target state="translated">この警告は以下の方法で無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="89ed913f904a95674da23281b17b4ea693c54b25" translate="yes" xml:space="preserve">
          <source>This warning does not warn when the last statement of a case cannot fall through, e.g. when there is a return statement or a call to function declared with the noreturn attribute.</source>
          <target state="translated">この警告は、ケースの最後の文が通過できない場合、例えばreturn文やnoreturn属性で宣言された関数の呼び出しがある場合などには警告しません。</target>
        </trans-unit>
        <trans-unit id="89fc4cf85fe382aeb62fa09febecbde3a95eefc5" translate="yes" xml:space="preserve">
          <source>This warning is also enabled by</source>
          <target state="translated">この警告は</target>
        </trans-unit>
        <trans-unit id="fced7dacfde6a232424563218b69038bcd4ee559" translate="yes" xml:space="preserve">
          <source>This warning is enabled by</source>
          <target state="translated">この警告は</target>
        </trans-unit>
        <trans-unit id="36a47c11f1d7801640a4ce272fb734796af5acce" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">この警告は、C および C++プログラムではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="ee676e87db234394e662704c0ac8d7b78ce3a041" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default in C++ and by</source>
          <target state="translated">この警告は、C++ではデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="29cc8455b15f952933dbc6b5c4dcaaac18069659" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default.</source>
          <target state="translated">この警告はデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="3917b2a596783248383561094f2cc2f726e9521a" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default. Use</source>
          <target state="translated">この警告はデフォルトで有効になっています。この警告を有効にするには</target>
        </trans-unit>
        <trans-unit id="73d860a0af5ebf8266139b884b360d37bd26034c" translate="yes" xml:space="preserve">
          <source>This warning is included in</source>
          <target state="translated">この警告は</target>
        </trans-unit>
        <trans-unit id="db92bbc8f99766a5d4907234d529494e443089db" translate="yes" xml:space="preserve">
          <source>This warning level also warns about left-shifting 1 into the sign bit, unless C++14 mode (or newer) is active.</source>
          <target state="translated">この警告レベルは、C++14 モード (またはそれ以降)がアクティブでない限り、符号ビットに 1 を左シフトすることについても警告します。</target>
        </trans-unit>
        <trans-unit id="ab7fb5cdceb183a69c6c48efdc3d5a84a181e3f7" translate="yes" xml:space="preserve">
          <source>This warning level also warns about out of bounds access for arrays at the end of a struct and for arrays accessed through pointers. This warning level may give a larger number of false positives and is deactivated by default.</source>
          <target state="translated">この警告レベルは、構造体の末尾にある配列やポインタを介してアクセスされる配列の範囲外アクセスについても警告します。この警告レベルは、より多くの誤検出を与える可能性があり、デフォルトでは無効化されています。</target>
        </trans-unit>
        <trans-unit id="3bc3c9fc8962f0931c9fc06c074ee037fa301f84" translate="yes" xml:space="preserve">
          <source>This warning level also warns for unused constant static variables in headers (excluding system headers). This is the warning level of</source>
          <target state="translated">この警告レベルは、ヘッダ内の未使用の定数静的変数(システムヘッダを除く)についても警告します。の警告レベルです。</target>
        </trans-unit>
        <trans-unit id="e39d91280d86f2477375c576c702edeea7de99cb" translate="yes" xml:space="preserve">
          <source>This warning warns about redundant calls to &lt;code&gt;std::move&lt;/code&gt;; that is, when a move operation would have been performed even without the &lt;code&gt;std::move&lt;/code&gt; call. This happens because the compiler is forced to treat the object as if it were an rvalue in certain situations such as returning a local variable, where copy elision isn&amp;rsquo;t applicable. Consider:</source>
          <target state="translated">この警告は、 &lt;code&gt;std::move&lt;/code&gt; への冗長な呼び出しについて警告します。つまり、 &lt;code&gt;std::move&lt;/code&gt; 呼び出しがなくても移動操作が実行された場合です。これは、コピー省略が適用されないローカル変数を返すなどの特定の状況では、コンパイラーがオブジェクトを右辺値であるかのように処理することを強制されるために発生します。考慮してください：</target>
        </trans-unit>
        <trans-unit id="8ff927821e46493382415b836b1d222941ef02c3" translate="yes" xml:space="preserve">
          <source>This warning warns when a call to &lt;code&gt;std::move&lt;/code&gt; prevents copy elision. A typical scenario when copy elision can occur is when returning in a function with a class return type, when the expression being returned is the name of a non-volatile automatic object, and is not a function parameter, and has the same type as the function return type.</source>
          <target state="translated">この警告は、 &lt;code&gt;std::move&lt;/code&gt; 呼び出しがコピーの省略を防ぐときに警告します。コピーエリクションが発生する可能性がある典型的なシナリオは、クラスの戻り値の型を使用して関数に戻るとき、返される式が不揮発性の自動オブジェクトの名前であり、関数パラメーターではなく、関数の型と同じである場合です関数の戻り値の型。</target>
        </trans-unit>
        <trans-unit id="bfc144d25fb3262e883d5de6746ba99b3d72080d" translate="yes" xml:space="preserve">
          <source>This was fixed in</source>
          <target state="translated">で修正されました。</target>
        </trans-unit>
        <trans-unit id="8b70ca57c3342f65e65169286b191ac23c6458f6" translate="yes" xml:space="preserve">
          <source>This would cause storage layout to be incompatible with most other C compilers. And it doesn&amp;rsquo;t seem very important, given that you can get the same result in other ways. The case where it matters most is when the enumeration-valued object is inside a structure, and in that case you can specify a field width explicitly.</source>
          <target state="translated">これにより、ストレージレイアウトは他のほとんどのCコンパイラと互換性がなくなります。また、他の方法でも同じ結果が得られる場合は、それほど重要ではないようです。最も重要なのは、列挙値のオブジェクトが構造体の内部にある場合です。その場合、フィールド幅を明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="470b7fe94fb9f173a78fa935734e2192a8d7646b" translate="yes" xml:space="preserve">
          <source>Thread, static, and automatic storage durations are associated with objects introduced by declarations [&amp;hellip;].</source>
          <target state="translated">スレッド、静的、および自動ストレージ期間は、宣言によって導入されたオブジェクトに関連付けられています[&amp;hellip;]。</target>
        </trans-unit>
        <trans-unit id="62f3324c9a09465697eb233a889b15dae55b7e07" translate="yes" xml:space="preserve">
          <source>Thread-local storage (TLS) is a mechanism by which variables are allocated such that there is one instance of the variable per extant thread. The runtime model GCC uses to implement this originates in the IA-64 processor-specific ABI, but has since been migrated to other processors as well. It requires significant support from the linker (&lt;code&gt;ld&lt;/code&gt;), dynamic linker (&lt;code&gt;ld.so&lt;/code&gt;), and system libraries (</source>
          <target state="translated">スレッドローカルストレージ（TLS）は、既存のスレッドごとに変数のインスタンスが1つ存在するように変数が割り当てられるメカニズムです。これを実装するためにGCCが使用するランタイムモデルは、IA-64プロセッサー固有のABIに由来しますが、他のプロセッサーにも移行されています。リンカー（ &lt;code&gt;ld&lt;/code&gt; ）、動的リンカー（ &lt;code&gt;ld.so&lt;/code&gt; ）、およびシステムライブラリ（</target>
        </trans-unit>
        <trans-unit id="f7f55e84b2ac7e71c677017ee5269595545ce154" translate="yes" xml:space="preserve">
          <source>Three attributes are currently defined for the Blackfin.</source>
          <target state="translated">現在、ブラックフィンには3つの属性が定義されています。</target>
        </trans-unit>
        <trans-unit id="74960e7e5c9e31cbbbc884f673c931b0f550d460" translate="yes" xml:space="preserve">
          <source>Three attributes currently are defined for PowerPC configurations: &lt;code&gt;altivec&lt;/code&gt;, &lt;code&gt;ms_struct&lt;/code&gt; and &lt;code&gt;gcc_struct&lt;/code&gt;.</source>
          <target state="translated">現在PowerPC構成用に定義されている3つの属性： &lt;code&gt;altivec&lt;/code&gt; 、 &lt;code&gt;ms_struct&lt;/code&gt; 、および &lt;code&gt;gcc_struct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebb2dbbb4a85c3866aff412bba9f2a41a060bb7f" translate="yes" xml:space="preserve">
          <source>Thus for example to display all the undocumented target-specific switches supported by the compiler, use:</source>
          <target state="translated">例えば、コンパイラーがサポートしているドキュメント化されていないターゲット固有のスイッチをすべて表示するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="1a580d726772cc97718ddf7d30a624c944acce67" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;array (pointer (char), 4)&lt;/code&gt; is the type of arrays of 4 pointers to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">したがって、 &lt;code&gt;array (pointer (char), 4)&lt;/code&gt; は &lt;code&gt;char&lt;/code&gt; への4つのポインターの配列の型です。</target>
        </trans-unit>
        <trans-unit id="5de79caa39ed0efb8d6ccb9be9f4f52d25b8a9e8" translate="yes" xml:space="preserve">
          <source>To avoid complications from future changes to the semantics and the compatibility issues between compilers, consider replacing basic &lt;code&gt;asm&lt;/code&gt; with extended &lt;code&gt;asm&lt;/code&gt;. See &lt;a href=&quot;https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended&quot;&gt;How to convert from basic asm to extended asm&lt;/a&gt; for information about how to perform this conversion.</source>
          <target state="translated">セマンティクスへの将来の変更による複雑化およびコンパイラー間の互換性の問題を回避するには、基本的な &lt;code&gt;asm&lt;/code&gt; を拡張 &lt;code&gt;asm&lt;/code&gt; に置き換えることを検討してください。この変換の実行方法については&lt;a href=&quot;https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended&quot;&gt;、基本的なasmから拡張されたasmへの変換方法を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac3300fdd0a6bd75b07beded4de93f16de3369a5" translate="yes" xml:space="preserve">
          <source>To avoid exponential effects in the Graphite loop transforms, the number of parameters in a Static Control Part (SCoP) is bounded. A value of zero can be used to lift the bound. A variable whose value is unknown at compilation time and defined outside a SCoP is a parameter of the SCoP.</source>
          <target state="translated">Graphiteループ変換の指数効果を避けるために、スタティック制御部(SCoP)のパラメータ数は制限されています。この制限を解除するには0の値を使用することができます。コンパイル時に値が不明でSCoPの外で定義されている変数はSCoPのパラメータとなります。</target>
        </trans-unit>
        <trans-unit id="9b629b2d987ad7e3698e47dd90332bddf769c0ae" translate="yes" xml:space="preserve">
          <source>To be fully SVR4 ABI-compliant at the cost of some performance loss, specify</source>
          <target state="translated">多少の性能低下はあっても、SVR4 ABI に完全に準拠するためには</target>
        </trans-unit>
        <trans-unit id="80464eace90374e03d32650091e615c04e6c4a1e" translate="yes" xml:space="preserve">
          <source>To configure the hook, you set the global variable &lt;code&gt;__objc_msg_forward2&lt;/code&gt; to a function with the same argument and return types of &lt;code&gt;objc_msg_lookup()&lt;/code&gt;. When &lt;code&gt;objc_msg_lookup()&lt;/code&gt; cannot find a method implementation, it invokes the hook function you provided to get a method implementation to return. So, in practice &lt;code&gt;__objc_msg_forward2&lt;/code&gt; allows you to extend &lt;code&gt;objc_msg_lookup()&lt;/code&gt; by adding some custom code that is called to do a further lookup when no standard method implementation can be found using the normal lookup.</source>
          <target state="translated">フックを構成するには、グローバル変数 &lt;code&gt;__objc_msg_forward2&lt;/code&gt; を同じ引数と &lt;code&gt;objc_msg_lookup()&lt;/code&gt; の型を返す関数に設定します。とき &lt;code&gt;objc_msg_lookup()&lt;/code&gt; メソッドの実装を見つけることができない、それはあなたが返すようにメソッドの実装を取得するために設けられたフック関数を呼び出します。したがって、実際には &lt;code&gt;__objc_msg_forward2&lt;/code&gt; を使用すると、通常のルックアップを使用して標準メソッドの実装が見つからない場合にさらにルックアップを実行するために呼び出されるカスタムコードを追加することにより、 &lt;code&gt;objc_msg_lookup()&lt;/code&gt; を拡張できます。</target>
        </trans-unit>
        <trans-unit id="d0892f6a61a5ddf8739ac6a9df58e9ff15e317ea" translate="yes" xml:space="preserve">
          <source>To create a precompiled header file, simply compile it as you would any other file, if necessary using the</source>
          <target state="translated">プリコンパイルされたヘッダファイルを作成するには、必要に応じて</target>
        </trans-unit>
        <trans-unit id="3088551494e7c8fccec2e166c87f205757a7fee0" translate="yes" xml:space="preserve">
          <source>To declare a function inline, use the &lt;code&gt;inline&lt;/code&gt; keyword in its declaration, like this:</source>
          <target state="translated">関数をインラインで宣言するには、次のように、宣言で &lt;code&gt;inline&lt;/code&gt; キーワードを使用します。</target>
        </trans-unit>
        <trans-unit id="5797514daed065cb1f475967a5b0ae2a149a5bab" translate="yes" xml:space="preserve">
          <source>To determine what tree dumps are available or find the dump for a pass of interest follow the steps below.</source>
          <target state="translated">どのような木のダンプが利用可能かを判断したり、興味のあるパスのダンプを見つけたりするには、以下の手順に従ってください。</target>
        </trans-unit>
        <trans-unit id="f1d8395854f85aca3686a491adc6bbc80456cbb1" translate="yes" xml:space="preserve">
          <source>To disable &lt;code&gt;__gcc_isr&lt;/code&gt; generation for the whole compilation unit, there is option</source>
          <target state="translated">コンパイル単位全体で &lt;code&gt;__gcc_isr&lt;/code&gt; 生成を無効にするためのオプションがあります</target>
        </trans-unit>
        <trans-unit id="e0828348cc00b4bf17581e2c7550f1489803bf22" translate="yes" xml:space="preserve">
          <source>To do so, the runtime checks if the class of the receiver implements the method</source>
          <target state="translated">これを行うために、ランタイムはレシーバのクラスがメソッド</target>
        </trans-unit>
        <trans-unit id="881e567632131aa4c0fe4b9dfaf489bcd70667c6" translate="yes" xml:space="preserve">
          <source>To enable the creation of the dump file, append the pass code to the</source>
          <target state="translated">ダンプファイルの作成を有効にするには、パスコードを</target>
        </trans-unit>
        <trans-unit id="0aa9530acd994c840dc3d2acd1762406cfa124f4" translate="yes" xml:space="preserve">
          <source>To enable the support for it you have to configure the compiler using an additional argument, &lt;code&gt;--enable-objc-gc&lt;/code&gt;. This will build the boehm-gc library, and build an additional runtime library which has several enhancements to support the garbage collector. The new library has a new name,</source>
          <target state="translated">このサポートを有効にするには、追加の引数 &lt;code&gt;--enable-objc-gc&lt;/code&gt; を使用してコンパイラを設定する必要があります。これにより、boehm-gcライブラリーが構築され、ガベージコレクターをサポートするためにいくつかの拡張機能が追加されたランタイムライブラリーが構築されます。新しいライブラリは新しい名前になり、</target>
        </trans-unit>
        <trans-unit id="a03cac0a42ba20ca789fab6e33a836d7beda4b6b" translate="yes" xml:space="preserve">
          <source>To ensure proper alignment of this values on the stack, the stack boundary must be as aligned as that required by any value stored on the stack. Further, every function must be generated such that it keeps the stack aligned. Thus calling a function compiled with a higher preferred stack boundary from a function compiled with a lower preferred stack boundary most likely misaligns the stack. It is recommended that libraries that use callbacks always use the default setting.</source>
          <target state="translated">スタック上のこの値を適切に整列させるために、スタックの境界は、スタックに格納されている任意の値によって要求されるのと同じように整列されなければなりません。さらに、すべての関数は、スタックの整列を保つように生成されなければなりません。したがって、より高い優先スタック境界でコンパイルされた関数を、より低い優先スタック境界でコンパイルされた関数から呼び出すと、ほとんどの場合、スタックの位置がずれてしまいます。コールバックを使用するライブラリは、常にデフォルトの設定を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="71f72a9196daa0aa6fe25defa0d854e178b76e7c" translate="yes" xml:space="preserve">
          <source>To extract the real part of a complex-valued expression &lt;var&gt;exp&lt;/var&gt;, write &lt;code&gt;__real__ &lt;var&gt;exp&lt;/var&gt;&lt;/code&gt;. Likewise, use &lt;code&gt;__imag__&lt;/code&gt; to extract the imaginary part. This is a GNU extension; for values of floating type, you should use the ISO C99 functions &lt;code&gt;crealf&lt;/code&gt;, &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;creall&lt;/code&gt;, &lt;code&gt;cimagf&lt;/code&gt;, &lt;code&gt;cimag&lt;/code&gt; and &lt;code&gt;cimagl&lt;/code&gt;, declared in &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; and also provided as built-in functions by GCC.</source>
          <target state="translated">複素数値の式 &lt;var&gt;exp&lt;/var&gt; の実部を抽出するには、 &lt;code&gt;__real__ &lt;var&gt;exp&lt;/var&gt;&lt;/code&gt; と記述します。同様に、 &lt;code&gt;__imag__&lt;/code&gt; を使用して虚数部を抽出します。これはGNU拡張です。浮動型の値の場合、ISO C99関数 &lt;code&gt;crealf&lt;/code&gt; 、 &lt;code&gt;creal&lt;/code&gt; 、 &lt;code&gt;creall&lt;/code&gt; 、 &lt;code&gt;cimagf&lt;/code&gt; 、 &lt;code&gt;cimag&lt;/code&gt; 、および &lt;code&gt;cimagl&lt;/code&gt; を使用し、 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; で宣言され、GCCによって組み込み関数として提供される必要があります。</target>
        </trans-unit>
        <trans-unit id="7d03d577b7b5a669a7c4822e1a0edd45b2f8702a" translate="yes" xml:space="preserve">
          <source>To generate SSE/SSE2 instructions automatically from floating-point code (as opposed to 387 instructions), see</source>
          <target state="translated">浮動小数点コードからSSE/SSE2命令を自動的に生成するには、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="0e0fe141c8ecdca866163a97026bd7dfee64a0ff" translate="yes" xml:space="preserve">
          <source>To help solve this problem, CPP behaves specially for variable arguments used with the token paste operator, &amp;lsquo;</source>
          <target state="translated">この問題を解決するために、CPPはトークン貼り付け演算子で使用される可変引数に対して特別に動作します '</target>
        </trans-unit>
        <trans-unit id="fccb76de9b13c0e702133668a7f3b6ce8851c913" translate="yes" xml:space="preserve">
          <source>To help with returning the objects, the &lt;code&gt;objects&lt;/code&gt; array is a C array preallocated by the caller (on the stack) of size &lt;code&gt;len&lt;/code&gt;. In many cases you can put the objects you want to return in that &lt;code&gt;objects&lt;/code&gt; array, then do &lt;code&gt;itemsPtr = objects&lt;/code&gt;. But you don&amp;rsquo;t have to; if your collection already has the objects to return in some form of C array, it could return them from there instead.</source>
          <target state="translated">オブジェクトを返すために、 &lt;code&gt;objects&lt;/code&gt; 配列は、サイズ &lt;code&gt;len&lt;/code&gt; の（スタック上の）呼び出し元によって事前に割り当てられたC配列です。多くの場合、返したいオブジェクトをその &lt;code&gt;objects&lt;/code&gt; 配列に入れ、 &lt;code&gt;itemsPtr = objects&lt;/code&gt; 実行できます。しかし、そうする必要はありません。コレクションにC配列の形式で返すオブジェクトがすでにある場合は、代わりにそこからオブジェクトを返すことができます。</target>
        </trans-unit>
        <trans-unit id="36d0f609e4fa3e2ba377279a7e5054298d93e189" translate="yes" xml:space="preserve">
          <source>To initialize a range of elements to the same value, write &amp;lsquo;</source>
          <target state="translated">要素の範囲を同じ値に初期化するには、「</target>
        </trans-unit>
        <trans-unit id="9469a3d15175030b71c43e9782eac80132b4e50b" translate="yes" xml:space="preserve">
          <source>To make the above program fragment valid, place whitespace in front of the minus sign. This whitespace will end the preprocessing number.</source>
          <target state="translated">上記のプログラムの断片を有効にするには、マイナス記号の前に空白を入れてください。この空白は前処理番号の末尾になります。</target>
        </trans-unit>
        <trans-unit id="1cff9fedec936f586685a14aa955b37f35f7182a" translate="yes" xml:space="preserve">
          <source>To make the code valid either use &lt;code&gt;this-&amp;gt;f()&lt;/code&gt;, or &lt;code&gt;Base&amp;lt;T&amp;gt;::f()&lt;/code&gt;. Using the</source>
          <target state="translated">コードを有効にするには、 &lt;code&gt;this-&amp;gt;f()&lt;/code&gt; または &lt;code&gt;Base&amp;lt;T&amp;gt;::f()&lt;/code&gt; ます。を使用して</target>
        </trans-unit>
        <trans-unit id="9c492c2aa61afe70cee904ba589c05bee91367f4" translate="yes" xml:space="preserve">
          <source>To make whole program optimization effective, it is necessary to make certain whole program assumptions. The compiler needs to know what functions and variables can be accessed by libraries and runtime outside of the link-time optimized unit. When supported by the linker, the linker plugin (see</source>
          <target state="translated">プログラム全体の最適化を効果的に行うためには、一定のプログラム全体の前提が必要です。コンパイラは、リンク時間最適化されたユニットの外で、ライブラリやランタイムがアクセスできる関数や変数を知る必要があります。リンカによってサポートされている場合、リンカ・プラグイン(</target>
        </trans-unit>
        <trans-unit id="b10f010a5357171b19c82dd57547e3f7673eff6e" translate="yes" xml:space="preserve">
          <source>To obtain all the diagnostics required by any of the standard versions described above you should specify</source>
          <target state="translated">上記のいずれかの標準バージョンで必要とされるすべての診断を取得するには</target>
        </trans-unit>
        <trans-unit id="e4aa89809c1011def5d99d621c233ec275d1953d" translate="yes" xml:space="preserve">
          <source>To optimize the program based on the collected profile information, use</source>
          <target state="translated">収集したプロフィール情報に基づいてプログラムを最適化するには</target>
        </trans-unit>
        <trans-unit id="60b4fed3cfe7ddfce1a0ca3458206394c1a66615" translate="yes" xml:space="preserve">
          <source>To prevent this from happening, if any input operand uses the &amp;lsquo;</source>
          <target state="translated">これを防ぐために、入力オペランドが '</target>
        </trans-unit>
        <trans-unit id="b232f82880621b972c64ec90d9ff0ca83f771650" translate="yes" xml:space="preserve">
          <source>To reference a label in the assembler template, prefix it with &amp;lsquo;</source>
          <target state="translated">アセンブラテンプレートでラベルを参照するには、プレフィックスに 'を付けます</target>
        </trans-unit>
        <trans-unit id="da66ae5379009e523ed502eead6298d0e166f13e" translate="yes" xml:space="preserve">
          <source>To save space, do not emit out-of-line copies of inline functions controlled by &lt;code&gt;#pragma implementation&lt;/code&gt;. This causes linker errors if these functions are not inlined everywhere they are called.</source>
          <target state="translated">スペースを節約するために、 &lt;code&gt;#pragma implementation&lt;/code&gt; によって制御されるインライン関数のアウトオブラインコピーを発行しないでください。これらの関数が呼び出されるすべての場所でインライン化されていない場合、これによりリンカーエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="dd8d976d0714f674e209f146cbbc7e6de34ae80c" translate="yes" xml:space="preserve">
          <source>To see the meaning of the declaration using &lt;code&gt;typeof&lt;/code&gt;, and why it might be a useful way to write, rewrite it with these macros:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; を使用した宣言の意味と、それがなぜ記述に有用な方法であるかを確認するには、次のマクロを使用して記述を書き換えます。</target>
        </trans-unit>
        <trans-unit id="40f035db3f8f044bbb0c622fe1fb92f16b378d0b" translate="yes" xml:space="preserve">
          <source>To specify an array index, write &amp;lsquo;</source>
          <target state="translated">配列のインデックスを指定するには、「</target>
        </trans-unit>
        <trans-unit id="acb678e44477baccb18d5369a48bd2b0b5ec0599" translate="yes" xml:space="preserve">
          <source>To specify multiple attributes, separate them by commas within the double parentheses: for example, &amp;lsquo;</source>
          <target state="translated">複数の属性を指定するには、二重括弧内のコンマで属性を区切ります。たとえば、 '</target>
        </trans-unit>
        <trans-unit id="279b8a3b8509796e74c2ff0e52b4b2a1757b661c" translate="yes" xml:space="preserve">
          <source>To specify the assembler name for functions, write a declaration for the function before its definition and put &lt;code&gt;asm&lt;/code&gt; there, like this:</source>
          <target state="translated">関数のアセンブラ名を指定するには、次のように、その定義の前に関数の宣言を記述し、そこに &lt;code&gt;asm&lt;/code&gt; を配置します。</target>
        </trans-unit>
        <trans-unit id="3dcbee28f5f060da3b68aea636eb26d6ab9b499b" translate="yes" xml:space="preserve">
          <source>To support cross-profiling, a program compiled with</source>
          <target state="translated">クロスプロファイルをサポートするために</target>
        </trans-unit>
        <trans-unit id="96365bc4676b236073f125730e587d433f50ff7e" translate="yes" xml:space="preserve">
          <source>To suppress this warning use the &lt;code&gt;unused&lt;/code&gt; attribute (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;).</source>
          <target state="translated">この警告を抑制するには、 &lt;code&gt;unused&lt;/code&gt; 属性を使用します（&lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;変数属性を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="f4e4279a59e510b02bce48ca083689c7becefcae" translate="yes" xml:space="preserve">
          <source>To tell GCC to emit extra information for use by a debugger, in almost all cases you need only to add</source>
          <target state="translated">デバッガが使用するための余分な情報を GCC に出力するように指示するには、ほとんどの場合は</target>
        </trans-unit>
        <trans-unit id="c0b5eb5cc6d2fda96d56fc807ba5364d278d6687" translate="yes" xml:space="preserve">
          <source>To use the link-time optimizer,</source>
          <target state="translated">リンクタイムオプティマイザを使用するには</target>
        </trans-unit>
        <trans-unit id="89d57caa2b7e4b18d64025af8cb99faf45ba1cb2" translate="yes" xml:space="preserve">
          <source>To use these values, you need to be able to jump to one. This is done with the computed goto statement&lt;a href=&quot;#FOOT3&quot; id=&quot;DOCF3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;, &lt;code&gt;goto *&lt;var&gt;exp&lt;/var&gt;;&lt;/code&gt;. For example,</source>
          <target state="translated">これらの値を使用するには、1つの値にジャンプできる必要があります。これは、計算されたgotoステートメント&lt;a href=&quot;#FOOT3&quot; id=&quot;DOCF3&quot; name=&quot;DOCF3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;、 &lt;code&gt;goto *&lt;var&gt;exp&lt;/var&gt;;&lt;/code&gt; 行われます。。例えば、</target>
        </trans-unit>
        <trans-unit id="9a059b55deba4fe3359e7e786d89afe0aa93dd23" translate="yes" xml:space="preserve">
          <source>To verify full coverage during</source>
          <target state="translated">中に完全にカバーされているかどうかを確認するには</target>
        </trans-unit>
        <trans-unit id="ec197d950172e34ea76227a1a78e887c52db9d18" translate="yes" xml:space="preserve">
          <source>To write a constant with a complex data type, use the suffix &amp;lsquo;</source>
          <target state="translated">複雑なデータ型の定数を書き込むには、サフィックス「</target>
        </trans-unit>
        <trans-unit id="38062ec8cfdea338e4b4a324dec29b0cd9799659" translate="yes" xml:space="preserve">
          <source>Together with a linker garbage collection (linker</source>
          <target state="translated">リンカのガベージコレクション(リンカ</target>
        </trans-unit>
        <trans-unit id="d5e14b063514cb6630e55f0aeb0ad3b37897efca" translate="yes" xml:space="preserve">
          <source>Toggle</source>
          <target state="translated">Toggle</target>
        </trans-unit>
        <trans-unit id="e6173ef9d580540f096dfe977ae2b3f003d86077" translate="yes" xml:space="preserve">
          <source>Top of 80387 floating-point stack (&lt;code&gt;%st(0)&lt;/code&gt;).</source>
          <target state="translated">80387浮動小数点スタックの最上部（ &lt;code&gt;%st(0)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="55f1f61607f8ef773d398fa71f442e01700f516d" translate="yes" xml:space="preserve">
          <source>Total Store Order</source>
          <target state="translated">総店舗数</target>
        </trans-unit>
        <trans-unit id="6bc1b3768ce894366a90239dc16d691ba72ece66" translate="yes" xml:space="preserve">
          <source>Track locations of tokens across macro expansions. This allows the compiler to emit diagnostic about the current macro expansion stack when a compilation error occurs in a macro expansion. Using this option makes the preprocessor and the compiler consume more memory. The &lt;var&gt;level&lt;/var&gt; parameter can be used to choose the level of precision of token location tracking thus decreasing the memory consumption if necessary. Value &amp;lsquo;</source>
          <target state="translated">マクロ展開全体でトークンの場所を追跡します。これにより、マクロ展開でコンパイルエラーが発生したときに、コンパイラは現在のマクロ展開スタックに関する診断を出力できます。このオプションを使用すると、プリプロセッサとコンパイラがより多くのメモリを消費します。 &lt;var&gt;level&lt;/var&gt; パラメータは、必要に応じてこのようにメモリ消費量を減少させるトークン位置追跡の精度のレベルを選択するために使用することができます。値 '</target>
        </trans-unit>
        <trans-unit id="4293c6fc2d0c550f24f6474e968d410857105e2b" translate="yes" xml:space="preserve">
          <source>Track top N target addresses in indirect-call profile.</source>
          <target state="translated">間接通話プロファイルの上位N個のターゲットアドレスを追跡します。</target>
        </trans-unit>
        <trans-unit id="723c149c69cf2602683e7f446ef904f72610c870" translate="yes" xml:space="preserve">
          <source>Tracks stack adjustments (pushes and pops) and stack memory references and then tries to find ways to combine them.</source>
          <target state="translated">スタックの調整(プッシュとポップ)とスタックメモリ参照を追跡し、それらを組み合わせる方法を見つけようとします。</target>
        </trans-unit>
        <trans-unit id="e7d7d66b6e955c972dc5701e4823af12fb85cdf2" translate="yes" xml:space="preserve">
          <source>Traditional C allows the following erroneous pair of declarations to appear together in a given scope:</source>
          <target state="translated">伝統的なC言語では、以下のような誤った宣言のペアが、与えられたスコープ内で一緒に現れることができます。</target>
        </trans-unit>
        <trans-unit id="510d795979a46696182ad87a63664d2658cf856e" translate="yes" xml:space="preserve">
          <source>Traditionally, diagnostic messages have been formatted irrespective of the output device&amp;rsquo;s aspect (e.g. its width, &amp;hellip;). You can use the options described below to control the formatting algorithm for diagnostic messages, e.g. how many characters per line, how often source location information should be reported. Note that some language front ends may not honor these options.</source>
          <target state="translated">従来、診断メッセージは、出力デバイスのアスペクト（幅など）に関係なくフォーマットされていました。以下で説明するオプションを使用して、診断メッセージのフォーマットアルゴリズムを制御できます。たとえば、1行あたりの文字数、ソースの場所情報を報告する頻度などです。一部の言語のフロントエンドはこれらのオプションを受け入れない場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1ab7709810cc2dcfdfcf719c4862cab474121c8b" translate="yes" xml:space="preserve">
          <source>Transaction abort due to a debug trap.</source>
          <target state="translated">デバッグ・トラップによるトランザクションのアボート。</target>
        </trans-unit>
        <trans-unit id="cd7b3249c42fccf913301a9808dd3e7980d5264e" translate="yes" xml:space="preserve">
          <source>Transaction abort due to a memory conflict with another thread.</source>
          <target state="translated">他のスレッドとのメモリ競合によるトランザクションのアボート。</target>
        </trans-unit>
        <trans-unit id="049238f821868925f76adff4fc7870e16eef0c6a" translate="yes" xml:space="preserve">
          <source>Transaction abort due to the transaction using too much memory.</source>
          <target state="translated">トランザクションのメモリ使用量が多すぎるため、トランザクションが中断されました。</target>
        </trans-unit>
        <trans-unit id="ead551a83f5f5bb74300da039b768d5b00d30187" translate="yes" xml:space="preserve">
          <source>Transaction abort in an inner nested transaction.</source>
          <target state="translated">内部ネストされたトランザクションでのトランザクションのアボート。</target>
        </trans-unit>
        <trans-unit id="485e36de3e4a7d7cfcfa7ddabb0a849c973eb7dd" translate="yes" xml:space="preserve">
          <source>Transaction retry is possible.</source>
          <target state="translated">トランザクションのリトライが可能です。</target>
        </trans-unit>
        <trans-unit id="4c0bda536dbe2634713edf7ae5619b61d4b2b7ec" translate="yes" xml:space="preserve">
          <source>Transaction was explicitly aborted with &lt;code&gt;_xabort&lt;/code&gt;. The parameter passed to &lt;code&gt;_xabort&lt;/code&gt; is available with &lt;code&gt;_XABORT_CODE(status)&lt;/code&gt;.</source>
          <target state="translated">トランザクションは &lt;code&gt;_xabort&lt;/code&gt; で明示的に中止されました。 &lt;code&gt;_xabort&lt;/code&gt; に渡されるパラメーターは、 &lt;code&gt;_XABORT_CODE(status)&lt;/code&gt; で使用できます。</target>
        </trans-unit>
        <trans-unit id="50f4a1ebc38e5d0f03feed213fa084a39f1c4ca1" translate="yes" xml:space="preserve">
          <source>Transparent unions are designed for library functions that have multiple interfaces for compatibility reasons. For example, suppose the &lt;code&gt;wait&lt;/code&gt; function must accept either a value of type &lt;code&gt;int *&lt;/code&gt; to comply with POSIX, or a value of type &lt;code&gt;union wait *&lt;/code&gt; to comply with the 4.1BSD interface. If &lt;code&gt;wait&lt;/code&gt;&amp;rsquo;s parameter were &lt;code&gt;void *&lt;/code&gt;, &lt;code&gt;wait&lt;/code&gt; would accept both kinds of arguments, but it would also accept any other pointer type and this would make argument type checking less useful. Instead, &lt;code&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/code&gt; might define the interface as follows:</source>
          <target state="translated">トランスペアレントユニオンは、互換性の理由から複数のインターフェイスを持つライブラリ関数用に設計されています。たとえば、 &lt;code&gt;wait&lt;/code&gt; 関数が &lt;code&gt;int *&lt;/code&gt; 型の値を受け入れてPOSIXに準拠するか、 &lt;code&gt;union wait *&lt;/code&gt; 型の値を受け入れて4.1BSDインターフェースに準拠する必要があるとします。場合は &lt;code&gt;wait&lt;/code&gt; のパラメータがあっ &lt;code&gt;void *&lt;/code&gt; 型、 &lt;code&gt;wait&lt;/code&gt; 引数の両方の種類を受け入れるだろうが、それはまた、他のポインタ型を受け入れるだろうし、これは引数の型チェックはあまり便利になるだろう。代わりに、 &lt;code&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/code&gt; はインターフェースを次のように定義します。</target>
        </trans-unit>
        <trans-unit id="cc0f9c4ade227657a2baa1dad9f725c64aa01d3a" translate="yes" xml:space="preserve">
          <source>Trap (do not trap) on integer division by zero.</source>
          <target state="translated">ゼロによる整数除算でのトラップ(トラップしない)。</target>
        </trans-unit>
        <trans-unit id="6d00c4acc18e3548fcbf61342f9558417419f4a6" translate="yes" xml:space="preserve">
          <source>Treat a &lt;code&gt;throw()&lt;/code&gt; exception specification as if it were a &lt;code&gt;noexcept&lt;/code&gt; specification to reduce or eliminate the text size overhead relative to a function with no exception specification. If the function has local variables of types with non-trivial destructors, the exception specification actually makes the function smaller because the EH cleanups for those variables can be optimized away. The semantic effect is that an exception thrown out of a function with such an exception specification results in a call to &lt;code&gt;terminate&lt;/code&gt; rather than &lt;code&gt;unexpected&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;throw()&lt;/code&gt; 例外指定を &lt;code&gt;noexcept&lt;/code&gt; 指定であるかのように扱い、例外指定のない関数に比べてテキストサイズのオーバーヘッドを削減または排除します。関数に自明ではないデストラクタを持つ型のローカル変数がある場合、これらの変数のEHクリーンアップを最適化できるため、例外指定により実際に関数が小さくなります。セマンティックな効果は、そのような例外仕様を持つ関数からスローされた例外が、 &lt;code&gt;unexpected&lt;/code&gt; ではなく &lt;code&gt;terminate&lt;/code&gt; 呼び出しを引き起こすことです。</target>
        </trans-unit>
        <trans-unit id="efcf63ae910bd65526e3a00af5485e708789997f" translate="yes" xml:space="preserve">
          <source>Treat all calls as being far away (near). If calls are assumed to be far away, the compiler always loads the function&amp;rsquo;s address into a register, and calls indirect through the pointer.</source>
          <target state="translated">すべての通話を遠く（近く）にあるものとして扱います。呼び出しが遠くにあると想定されている場合、コンパイラーは常に関数のアドレスをレジスターにロードし、ポインターを介して間接的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="e657b1f5ccca3a3f8f766ebdbdec5db7187eaa45" translate="yes" xml:space="preserve">
          <source>Treat floating-point constants as single precision instead of implicitly converting them to double-precision constants.</source>
          <target state="translated">浮動小数点定数を暗黙のうちに倍精度定数に変換するのではなく、単精度として扱います。</target>
        </trans-unit>
        <trans-unit id="b9730fd8c54eee8a380dfaa34a9eb35908c0edfe" translate="yes" xml:space="preserve">
          <source>Treat the register named &lt;var&gt;reg&lt;/var&gt; as a fixed register; generated code should never refer to it (except perhaps as a stack pointer, frame pointer or in some other fixed role).</source>
          <target state="translated">&lt;var&gt;reg&lt;/var&gt; という名前のレジスタを固定レジスタとして扱います。生成されたコードはそれを参照してはなりません（おそらく、スタックポインター、フレームポインター、または他の固定された役割を除く）。</target>
        </trans-unit>
        <trans-unit id="24bec37045b31ff86b0699b95df9d95df0bb7391" translate="yes" xml:space="preserve">
          <source>Treat the register named &lt;var&gt;reg&lt;/var&gt; as an allocable register saved by functions. It may be allocated even for temporaries or variables that live across a call. Functions compiled this way save and restore the register &lt;var&gt;reg&lt;/var&gt; if they use it.</source>
          <target state="translated">&lt;var&gt;reg&lt;/var&gt; という名前のレジスタを、関数によって保存された割り当て可能なレジスタとして扱います。呼び出し全体に存在する一時変数や変数に対しても割り当てられる場合があります。この方法でコンパイルされた関数は、レジスタ &lt;var&gt;reg&lt;/var&gt; を使用する場合、それを保存および復元します。</target>
        </trans-unit>
        <trans-unit id="9ed7e368cac1e3940cdf973c2d7cc16201bdbf48" translate="yes" xml:space="preserve">
          <source>Treat the register named &lt;var&gt;reg&lt;/var&gt; as an allocable register that is clobbered by function calls. It may be allocated for temporaries or variables that do not live across a call. Functions compiled this way do not save and restore the register &lt;var&gt;reg&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;reg&lt;/var&gt; という名前のレジスタを、関数呼び出しによって破棄される割り当て可能なレジスタとして扱います。これは、呼び出し全体で存続しない一時変数または変数に割り当てることができます。この方法でコンパイルされた関数は、レジスタ &lt;var&gt;reg&lt;/var&gt; を保存および復元しません。</target>
        </trans-unit>
        <trans-unit id="b7012f8bdb10f107e038866fe0f141acd75a5071" translate="yes" xml:space="preserve">
          <source>Treat the register used for PIC addressing as read-only, rather than loading it in the prologue for each function. The runtime system is responsible for initializing this register with an appropriate value before execution begins.</source>
          <target state="translated">各関数のプロローグでロードするのではなく、PICアドレッシングに使用されるレジスタをリードオンリーとして扱う。ランタイムシステムは、実行開始前にこのレジスタを適切な値で初期化する責任があります。</target>
        </trans-unit>
        <trans-unit id="d6dc381ff0b0eaf3a75a3644a1928e76a876add7" translate="yes" xml:space="preserve">
          <source>Treat the stack pointer register as an 8-bit register, i.e. assume the high byte of the stack pointer is zero. In general, you don&amp;rsquo;t need to set this option by hand.</source>
          <target state="translated">スタックポインタレジスタを8ビットレジスタとして扱います。つまり、スタックポインタの上位バイトがゼロであると想定します。通常、このオプションを手動で設定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="18a09707746246ab1f81f3b198c6fce704d60805" translate="yes" xml:space="preserve">
          <source>Try to align labels to an 8-byte boundary by inserting NOPs into the previous packet. This option only has an effect when VLIW packing is enabled. It doesn&amp;rsquo;t create new packets; it merely adds NOPs to existing ones.</source>
          <target state="translated">前のパケットにNOPを挿入して、ラベルを8バイト境界に揃えます。このオプションは、VLIWパッキングが有効になっている場合にのみ効果があります。新しいパケットは作成されません。既存のものにNOPを追加するだけです。</target>
        </trans-unit>
        <trans-unit id="5d7f1893937b8021a0b45b38ecc6c5c5982860f9" translate="yes" xml:space="preserve">
          <source>Try to format error messages so that they fit on lines of about &lt;var&gt;n&lt;/var&gt; characters. If &lt;var&gt;n&lt;/var&gt; is zero, then no line-wrapping is done; each error message appears on a single line. This is the default for all front ends.</source>
          <target state="translated">エラーメッセージが約 &lt;var&gt;n&lt;/var&gt; 文字の行に収まるようにフォーマットしてみてください。場合 &lt;var&gt;n&lt;/var&gt; ゼロであり、その後、何行の折り返しが行われません。各エラーメッセージは1行で表示されます。これはすべてのフロントエンドのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="51ead7ad6ca24e037be309703712bdaf58fe0308" translate="yes" xml:space="preserve">
          <source>Try to imitate the behavior of pre-standard C preprocessors, as opposed to ISO C preprocessors. See the GNU CPP manual for details.</source>
          <target state="translated">ISO Cプリプロセッサとは対照的に、標準以前のCプリプロセッサの動作を真似してみてください。詳細はGNU CPPマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="c8878a439f989aa10bd1de06d6919d9cd9fccd45" translate="yes" xml:space="preserve">
          <source>Try to make the code as small as possible. At present, this just turns on the</source>
          <target state="translated">コードをできるだけ小さくしてみてください。現時点では、これは単に</target>
        </trans-unit>
        <trans-unit id="2943824dd1677f0ee45e17f3ad727f59c256ccaf" translate="yes" xml:space="preserve">
          <source>Try to reduce the number of symbolic address calculations by using shared &amp;ldquo;anchor&amp;rdquo; symbols to address nearby objects. This transformation can help to reduce the number of GOT entries and GOT accesses on some targets.</source>
          <target state="translated">共有の「アンカー」シンボルを使用して近くのオブジェクトをアドレス指定することにより、シンボリックアドレス計算の数を減らすようにしてください。この変換により、一部のターゲットでのGOTエントリとGOTアクセスの数を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="71689cce79c81b27513c53eda29d40ea96948251" translate="yes" xml:space="preserve">
          <source>Try to replace &lt;code&gt;CALL&lt;/code&gt; resp. &lt;code&gt;JMP&lt;/code&gt; instruction by the shorter &lt;code&gt;RCALL&lt;/code&gt; resp. &lt;code&gt;RJMP&lt;/code&gt; instruction if applicable. Setting</source>
          <target state="translated">&lt;code&gt;CALL&lt;/code&gt; resp を置き換えてみてください。短い &lt;code&gt;RCALL&lt;/code&gt; 応答による &lt;code&gt;JMP&lt;/code&gt; 命令。 &lt;code&gt;RJMP&lt;/code&gt; する場合はRJMP命令。設定</target>
        </trans-unit>
        <trans-unit id="7f5db504e6f50390be7556b15f1e06e74d98003b" translate="yes" xml:space="preserve">
          <source>Try to turn PIC calls that are normally dispatched via register &lt;code&gt;$25&lt;/code&gt; into direct calls. This is only possible if the linker can resolve the destination at link time and if the destination is within range for a direct call.</source>
          <target state="translated">通常はレジスター &lt;code&gt;$25&lt;/code&gt; 経由でディスパッチされるPIC呼び出しを直接呼び出しに変換してみます。これは、リンカーがリンク時に宛先を解決できる場合、および宛先が直接呼び出しの範囲内にある場合にのみ可能です。</target>
        </trans-unit>
        <trans-unit id="d986cee6514cc454cabe1b04f373619d70b76947" translate="yes" xml:space="preserve">
          <source>Tune for ARC600 CPU.</source>
          <target state="translated">ARC600 CPU用にチューニング。</target>
        </trans-unit>
        <trans-unit id="cd581f56e3b57950cd6ef9a480d293254a2ecd23" translate="yes" xml:space="preserve">
          <source>Tune for ARC601 CPU.</source>
          <target state="translated">ARC601 CPU用にチューニング。</target>
        </trans-unit>
        <trans-unit id="3d1d8bffb14bf81b97f78406c7f3b23782c05dcc" translate="yes" xml:space="preserve">
          <source>Tune for ARC700 CPU with XMAC block.</source>
          <target state="translated">XMACブロックでARC700 CPU用にチューニング。</target>
        </trans-unit>
        <trans-unit id="eb447e923ad8db257fca3ee02ccc66a1cc26b9c9" translate="yes" xml:space="preserve">
          <source>Tune for ARC700 CPU with standard multiplier block.</source>
          <target state="translated">標準的な乗算ブロックを持つARC700 CPU用にチューニングします。</target>
        </trans-unit>
        <trans-unit id="0124418dee31dd7297585683b0a95e9f65f2e8cc" translate="yes" xml:space="preserve">
          <source>Tune for ARC725D CPU.</source>
          <target state="translated">ARC725D CPUのチューニング。</target>
        </trans-unit>
        <trans-unit id="a99d4307ca5e0f869f7793d383503e6ec8def3af" translate="yes" xml:space="preserve">
          <source>Tune for ARC750D CPU.</source>
          <target state="translated">ARC750D CPU用にチューニング。</target>
        </trans-unit>
        <trans-unit id="57d5b9e241148e9c20bf6639665bc7f5200a0c7a" translate="yes" xml:space="preserve">
          <source>Tune the code for a particular microarchitecture within the constraints set by</source>
          <target state="translated">で設定された制約の中で、特定のマイクロアーキテクチャ用のコードをチューニングします。</target>
        </trans-unit>
        <trans-unit id="e11fd75fe2998bc88e3a55f06c902e5e06c31f2d" translate="yes" xml:space="preserve">
          <source>Tune the instruction scheduling for a particular CPU, Valid values are &amp;lsquo;</source>
          <target state="translated">特定のCPUの命令スケジューリングを調整します。有効な値は '</target>
        </trans-unit>
        <trans-unit id="73d6ee31240249a6f0e63fbef357f9d54da8845d" translate="yes" xml:space="preserve">
          <source>Tune to &lt;var&gt;architecture-type&lt;/var&gt; everything applicable about the generated code, except for the ABI and the set of available instructions. The choices for &lt;var&gt;architecture-type&lt;/var&gt; are the same as for</source>
          <target state="translated">ABIと使用可能な命令のセットを除いて、生成されたコードに適用可能なすべてを &lt;var&gt;architecture-type&lt;/var&gt; 合わせます。 &lt;var&gt;architecture-type&lt;/var&gt; の選択は、</target>
        </trans-unit>
        <trans-unit id="abe7006b22b302a45d8adf679048506cceec6621" translate="yes" xml:space="preserve">
          <source>Tune to &lt;var&gt;cpu-type&lt;/var&gt; everything applicable about the generated code, except for the ABI and the set of available instructions. The list of &lt;var&gt;cpu-type&lt;/var&gt; values is the same as for</source>
          <target state="translated">ABIおよび使用可能な命令のセットを除いて、生成されたコードに適用できるすべてを &lt;var&gt;cpu-type&lt;/var&gt; に調整します。 &lt;var&gt;cpu-type&lt;/var&gt; 値のリストは、</target>
        </trans-unit>
        <trans-unit id="8ce8ad1c804c3f77bbd9eaaa6bff5e1dd657796d" translate="yes" xml:space="preserve">
          <source>Tune to &lt;var&gt;cpu-type&lt;/var&gt; everything applicable about the generated code, except for the ABI and the set of available instructions. While picking a specific &lt;var&gt;cpu-type&lt;/var&gt; schedules things appropriately for that particular chip, the compiler does not generate any code that cannot run on the default machine type unless you use a</source>
          <target state="translated">ABIおよび使用可能な命令のセットを除いて、生成されたコードに適用できるすべてを &lt;var&gt;cpu-type&lt;/var&gt; に調整します。特定の &lt;var&gt;cpu-type&lt;/var&gt; を選択すると、その特定のチップに適切にスケジュールされますが、コンパイラーは、デフォルトのマシンタイプで実行できないコードを生成しません。</target>
        </trans-unit>
        <trans-unit id="2ff319ca41c83d456fd2660af1ba3a0a39ead43b" translate="yes" xml:space="preserve">
          <source>Turn off all access checking. This switch is mainly useful for working around bugs in the access control code.</source>
          <target state="translated">すべてのアクセスチェックをオフにします。このスイッチは主にアクセス制御コードのバグを回避するのに便利です。</target>
        </trans-unit>
        <trans-unit id="5aa7ded6e9138148782165f8ff6c917050fd8448" translate="yes" xml:space="preserve">
          <source>Turn off any specification of a language, so that subsequent files are handled according to their file name suffixes (as they are if</source>
          <target state="translated">言語の指定をすべてオフにして、後続のファイルがファイル名の接尾辞に従って処理されるようにします。</target>
        </trans-unit>
        <trans-unit id="05599d87457784f5e8fcf58f82a82201f42c5e95" translate="yes" xml:space="preserve">
          <source>Turn off generation of debug info, if leaving out this option generates it, or turn it on at level 2 otherwise. The position of this argument in the command line does not matter; it takes effect after all other options are processed, and it does so only once, no matter how many times it is given. This is mainly intended to be used with</source>
          <target state="translated">このオプションを省略するとデバッグ情報が生成される場合はデバッグ情報の生成をオフにし、そうでない場合はレベル 2 でオンにします。コマンドラインでのこの引数の位置は重要ではありません。このオプションは他のすべてのオプションが処理された後に有効になり、何度与えられても一度だけ有効になります。これは主に</target>
        </trans-unit>
        <trans-unit id="c6b5015cd05574d36521c886faa5f1fe72388eb1" translate="yes" xml:space="preserve">
          <source>Turn on all optimization options, i.e.,</source>
          <target state="translated">すべての最適化オプションをオンにします。</target>
        </trans-unit>
        <trans-unit id="1f38ffe59dc7af4e39268866c9d6bf540ff3e935" translate="yes" xml:space="preserve">
          <source>Turn on all options, except</source>
          <target state="translated">を除くすべてのオプションをオンにします。</target>
        </trans-unit>
        <trans-unit id="addc4296812df31340ecc8097c6637d705b4dc51" translate="yes" xml:space="preserve">
          <source>Turning on optimization flags makes the compiler attempt to improve the performance and/or code size at the expense of compilation time and possibly the ability to debug the program.</source>
          <target state="translated">最適化フラグをオンにすると、コンパイラはコンパイル時間やプログラムのデバッグ機能を犠牲にして、パフォーマンスやコードサイズを向上させようとします。</target>
        </trans-unit>
        <trans-unit id="0abd8c32d9b5b449c21960750d5d9b900609a45e" translate="yes" xml:space="preserve">
          <source>Tweak register allocation to help 16-bit instruction generation. This generally has the effect of decreasing the average instruction size while increasing the instruction count.</source>
          <target state="translated">16ビット命令の生成を助けるためにレジスタの割り当てを微調整します。これは一般的に、命令数を増加させながら平均命令サイズを減少させる効果があります。</target>
        </trans-unit>
        <trans-unit id="cc2345bb4c5df388b03bf38fa376e4f8708c805d" translate="yes" xml:space="preserve">
          <source>Two 16x16 multipliers, blocking, sequential. The following instructions are additionally enabled: &lt;code&gt;mpy&lt;/code&gt;, &lt;code&gt;mpyu&lt;/code&gt;, &lt;code&gt;mpym&lt;/code&gt;, &lt;code&gt;mpymu&lt;/code&gt;, and &lt;code&gt;mpy_s&lt;/code&gt;.</source>
          <target state="translated">2つの16x16乗算器、ブロッキング、シーケンシャル。次の命令がさらに有効になります： &lt;code&gt;mpy&lt;/code&gt; 、 &lt;code&gt;mpyu&lt;/code&gt; 、 &lt;code&gt;mpym&lt;/code&gt; 、 &lt;code&gt;mpymu&lt;/code&gt; 、および &lt;code&gt;mpy_s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b000d97aa40706cbe471fe85b50413fb0224467" translate="yes" xml:space="preserve">
          <source>Two additional variants of the o32 ABI are supported to enable a transition from 32-bit to 64-bit registers. These are FPXX (</source>
          <target state="translated">32ビットから64ビットレジスタへの移行を可能にするために、o32 ABIの2つの追加のバリアントがサポートされています。これらはFPXX (</target>
        </trans-unit>
        <trans-unit id="2bc5d51eed63377e23ba7ef70163b3178b799fe5" translate="yes" xml:space="preserve">
          <source>Two&amp;rsquo;s complement of a 6-bit unsigned integer constant.</source>
          <target state="translated">6ビットの符号なし整数定数の2の補数。</target>
        </trans-unit>
        <trans-unit id="65d021ad85f9ecc2bd4449ee63312946ef7cb6cb" translate="yes" xml:space="preserve">
          <source>Two-stage name lookup sometimes leads to situations with behavior different from non-template codes. The most common is probably this:</source>
          <target state="translated">二段階の名前検索では、非テンプレートコードとは異なる動作をすることがあります。最も一般的なのはおそらくこれです。</target>
        </trans-unit>
        <trans-unit id="575680b4fbe2bb6b6d519cf112b732f205e5669e" translate="yes" xml:space="preserve">
          <source>Type Attributes</source>
          <target state="translated">タイプ属性</target>
        </trans-unit>
        <trans-unit id="8492437da1bd59c92bb55d3921577991dfd8045e" translate="yes" xml:space="preserve">
          <source>Types &lt;code&gt;_Decimal32&lt;/code&gt;, &lt;code&gt;_Decimal64&lt;/code&gt;, and &lt;code&gt;_Decimal128&lt;/code&gt; are supported by the DWARF debug information format.</source>
          <target state="translated">タイプ &lt;code&gt;_Decimal32&lt;/code&gt; 、 &lt;code&gt;_Decimal64&lt;/code&gt; 、および &lt;code&gt;_Decimal128&lt;/code&gt; は、DWARFデバッグ情報フォ​​ーマットでサポートされています。</target>
        </trans-unit>
        <trans-unit id="92c5b269a787c7229d4b1731f191eb104665ea8a" translate="yes" xml:space="preserve">
          <source>Types, but not their members, are not hidden by default.</source>
          <target state="translated">型は、そのメンバではなく、デフォルトでは非表示になっていません。</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="2f40553950efdfee2da54d1ec023b02b81e2bf58" translate="yes" xml:space="preserve">
          <source>UHK</source>
          <target state="translated">UHK</target>
        </trans-unit>
        <trans-unit id="f1d002b3861d02936136d383f32b05c7363677ef" translate="yes" xml:space="preserve">
          <source>UHR</source>
          <target state="translated">UHR</target>
        </trans-unit>
        <trans-unit id="7770d04c7bfb791e7c95959f12d6797bee87a8d8" translate="yes" xml:space="preserve">
          <source>UK</source>
          <target state="translated">UK</target>
        </trans-unit>
        <trans-unit id="c297964acee362f7f2dba4952f8bafc43415d17b" translate="yes" xml:space="preserve">
          <source>UL</source>
          <target state="translated">UL</target>
        </trans-unit>
        <trans-unit id="f02a449aa1e45687b9dd404230f554d77889736a" translate="yes" xml:space="preserve">
          <source>ULK</source>
          <target state="translated">ULK</target>
        </trans-unit>
        <trans-unit id="23068141b1ba54cf3def8562e3144f8201f1de6d" translate="yes" xml:space="preserve">
          <source>ULL</source>
          <target state="translated">ULL</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
