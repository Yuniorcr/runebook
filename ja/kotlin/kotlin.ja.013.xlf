<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="8310a54b24568803ae04cc82e73e4ed7d64a2ce9" translate="yes" xml:space="preserve">
          <source>In Java:</source>
          <target state="translated">Javaでは。</target>
        </trans-unit>
        <trans-unit id="abb66954294d1e4253f6894befd4961b0fc88ece" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself. I.e.:</source>
          <target state="translated">JavaScriptでは、プロトタイプやクラス自体にメンバーを定義することができます。例えば</target>
        </trans-unit>
        <trans-unit id="b73e80ab874eb4a673c8b0548f2f4b1a57e2e5b0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.0, code in the lambda passed to &lt;code&gt;td&lt;/code&gt; has access to three implicit receivers: the one passed to &lt;code&gt;table&lt;/code&gt;, to &lt;code&gt;tr&lt;/code&gt; and to &lt;code&gt;td&lt;/code&gt;. This allows you to call methods that make no sense in the context - for example to call &lt;code&gt;tr&lt;/code&gt; inside &lt;code&gt;td&lt;/code&gt; and thus to put a &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tag in a &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.0では、 &lt;code&gt;td&lt;/code&gt; に渡されるラムダ内のコードは、3つの暗黙的なレシーバー（ &lt;code&gt;table&lt;/code&gt; 、 &lt;code&gt;tr&lt;/code&gt; 、および &lt;code&gt;td&lt;/code&gt; に渡されるもの）にアクセスできます。これにより、コンテキスト内で意味のないメソッドを呼び出すことができます。たとえば、 &lt;code&gt;td&lt;/code&gt; 内で &lt;code&gt;tr&lt;/code&gt; を呼び出して、 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; タグを &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; に配置できます。</target>
        </trans-unit>
        <trans-unit id="faca07a0c2f2dcf45e7526d00d395e3cdc377fcb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of &lt;code&gt;td&lt;/code&gt; will be available inside the lambda passed to &lt;code&gt;td&lt;/code&gt;. You do that by defining your annotation marked with the &lt;code&gt;@DslMarker&lt;/code&gt; meta-annotation and applying it to the base class of the tag classes.</source>
          <target state="translated">Kotlin 1.1では、 &lt;code&gt;td&lt;/code&gt; に渡されたラムダ内で &lt;code&gt;td&lt;/code&gt; の暗黙のレシーバーで定義されたメソッドのみが使用できるように、それを制限できます。 &lt;code&gt;@DslMarker&lt;/code&gt; メタ注釈でマークされた注釈を定義し、それをタグクラスの基本クラスに適用することにより、これを行います。</target>
        </trans-unit>
        <trans-unit id="24a213ee88ffeaa2bec3378db48986b075744611" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1.x, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; instead.</source>
          <target state="translated">Kotlin 1.1.xでは、 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; と &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="6ea3af6627b279c964f114bd464c51ab696c689f" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:</source>
          <target state="translated">Kotlin 1.3では、アノテーションにネストされたクラス、インターフェース、オブジェクト、コンパニオンを持たせることができます。</target>
        </trans-unit>
        <trans-unit id="3098d1aa730f31e91846c87eaae7ac71342cdc7e" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, it is now possible to capture the &lt;code&gt;when&lt;/code&gt; subject into variable:</source>
          <target state="translated">Kotlin 1.3では、サブジェクトを変数にキャプチャすることが可能 &lt;code&gt;when&lt;/code&gt; なりました。</target>
        </trans-unit>
        <trans-unit id="2a99d2573a55fb319e350044cce69239e344a488" translate="yes" xml:space="preserve">
          <source>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</source>
          <target state="translated">つまり、JavaやC#、Scalaなどの言語で必要とされるような、関数を保持するためのクラスを作成する必要がありません。トップレベルの関数に加えて、Kotlinの関数はメンバー関数や拡張関数としてローカルに宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="d5176ee2358fd7911cf590e90f48fd7d921131e2" translate="yes" xml:space="preserve">
          <source>In Kotlin there are two types of equality:</source>
          <target state="translated">コトリンでは2種類の平等があります。</target>
        </trans-unit>
        <trans-unit id="1307e7346626ce5c88b95620e1843731ae3969f4" translate="yes" xml:space="preserve">
          <source>In Kotlin this line can be concisely parsed with the following statement using &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;destructuring declaration&lt;/a&gt; from a list of integers:</source>
          <target state="translated">Kotlinでは、この行は整数のリストからの構造化&lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;宣言&lt;/a&gt;を使用して、次のステートメントで簡潔に解析できます。</target>
        </trans-unit>
        <trans-unit id="d2cb95a39c5087932a02f405cc63f954a5dedc22" translate="yes" xml:space="preserve">
          <source>In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</source>
          <target state="translated">Kotlinでは、一般的な型の上限を指定することができます。Objective-Cもこれをサポートしていますが、より複雑なケースではサポートされておらず、現在のところKotlin-Objective-Cの相互運用ではサポートされていません。ここでの例外は、非 null 上限を指定すると Objective-C のメソッドやプロパティが非 null になることです。</target>
        </trans-unit>
        <trans-unit id="ef29e345af9c063df71b3f01a21f78a928c57611" translate="yes" xml:space="preserve">
          <source>In Kotlin you can't work with fields directly, you work with &lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;. You annotate the property:</source>
          <target state="translated">Kotlinでは、フィールドを直接操作することはできません。&lt;a href=&quot;../reference/properties&quot;&gt;プロパティを操作&lt;/a&gt;します。プロパティに注釈を付けます。</target>
        </trans-unit>
        <trans-unit id="b1411aa40ea7c5b9a0de303333e37baf632f1665" translate="yes" xml:space="preserve">
          <source>In Kotlin you have to add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin to enable &lt;code&gt;kapt&lt;/code&gt;, and then replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Kotlinでは、 &lt;code&gt;kotlin-kapt&lt;/code&gt; プラグインを追加してkaptを有効にして &lt;code&gt;kapt&lt;/code&gt; 、 &lt;code&gt;annotationProcessor&lt;/code&gt; を &lt;code&gt;kapt&lt;/code&gt; に置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="da7a2b73e175cb7362740b3fbdff60c8cc8e5724" translate="yes" xml:space="preserve">
          <source>In Kotlin you specify the dependencies in a similar to Java way using &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation processing tool&lt;/a&gt; (&lt;code&gt;kapt&lt;/code&gt;) instead of &lt;code&gt;annotationProcessor&lt;/code&gt;.</source>
          <target state="translated">Kotlin では、 &lt;code&gt;annotationProcessor&lt;/code&gt; の代わりに&lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin注釈処理ツール&lt;/a&gt;（ &lt;code&gt;kapt&lt;/code&gt; ）を使用して、Javaと同様の方法で依存関係を指定します。</target>
        </trans-unit>
        <trans-unit id="0a2601b06937bb12c0744830de8e7b372473464e" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-&lt;/code&gt;) operators are defined for collections. They take a collection as the first operand; the second operand can be either an element or another collection. The return value is a new read-only collection:</source>
          <target state="translated">Kotlinでは、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;+&lt;/code&gt; ）および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;-&lt;/code&gt; ）演算子がコレクションに定義されています。彼らは最初のオペランドとしてコレクションを取ります。2番目のオペランドは、要素または別のコレクションです。戻り値は、新しい読み取り専用のコレクションです。</target>
        </trans-unit>
        <trans-unit id="630fd5574aed5de24f8dfa12e49c30f220082837" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary &lt;em&gt;if&lt;/em&gt; works fine in this role.</source>
          <target state="translated">Kotlinでは、&lt;em&gt;if&lt;/em&gt;が式、つまり値を返します。したがって、通常の&lt;em&gt;if&lt;/em&gt;がこの役割でうまく機能するため、3項演算子（条件？then：else）はありません。</target>
        </trans-unit>
        <trans-unit id="449834b1db02375da0148e9e57aea36e01ccf956" translate="yes" xml:space="preserve">
          <source>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</source>
          <target state="translated">Kotlinでは、すべての例外はチェックされていないので、コンパイラが強制的に例外をキャッチすることはありません。つまり、チェックされた例外を宣言するJavaメソッドを呼び出しても、Kotlinは何も強制しません。</target>
        </trans-unit>
        <trans-unit id="ccb7acc6feff10a66296746e0c93a95c37a6267f" translate="yes" xml:space="preserve">
          <source>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</source>
          <target state="translated">Kotlinでは、あらゆる変数のメンバ関数やプロパティを呼び出すことができるという意味で、すべてのものがオブジェクトです。型の中には特別な内部表現が可能なものもあります-例えば、数値、文字、ブーリアンは実行時にプリミティブ値として表現できますが、ユーザには普通のクラスのように見えます。このセクションでは、Kotlin で使われる基本的な型について説明します:数字、文字、ブーリアン、配列、文字列です。</target>
        </trans-unit>
        <trans-unit id="bcc1b8c2a992c6c34b455f92da91c74149cd8719" translate="yes" xml:space="preserve">
          <source>In Kotlin, functional types are represented as generic classes taking a different number of parameters: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt;, &amp;hellip; This approach has a problem in that this list is finite, and it currently ends with &lt;code&gt;Function22&lt;/code&gt;.</source>
          <target state="translated">Kotlinでは、関数型は異なる数のパラメーターを取る汎用クラスとして表されます： &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt; 、&amp;hellip;このアプローチには、このリストが有限であるという問題があります、現在は &lt;code&gt;Function22&lt;/code&gt; で終わります。</target>
        </trans-unit>
        <trans-unit id="dda94f8bd95fbc2c5d984c18e048611fb7b42dbc" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Kotlinでは、実装の継承は次のルールによって規制されます。クラスが同じメンバーの多くの実装を直接のスーパークラスから継承する場合、クラスはこのメンバーをオーバーライドし、独自の実装を提供する必要があります（おそらく、継承された実装の1つを使用します）。継承された実装の取得元であるスーパータイプを示すために、山かっこ内のスーパータイプ名で&lt;em&gt;スーパー&lt;/em&gt;修飾を使用します。例： &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7dcc76eece2b8bf2e4ff6b5b682eb767b78c7f50" translate="yes" xml:space="preserve">
          <source>In Kotlin, importing is a compile-time concept - importing something does not actually cause any code to run (unlike Python, where all top-level statements in a file are executed at import time). Therefore, circular imports are allowed, but they might suggest a design problem in your code. However, during execution, a class will be loaded the first time it (or any of its properties or functions) is referenced, and class loading causes &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt; to be initialized - this can lead to runtime exceptions if you have circular dependencies.</source>
          <target state="translated">Kotlinでは、インポートはコンパイル時の概念です。何かをインポートしても、実際にはコードが実行されません（Pythonとは異なり、ファイル内のすべてのトップレベルのステートメントがインポート時に実行されます）。したがって、循環インポートは許可されますが、コードの設計上の問題を示唆している可能性があります。ただし、実行時には、クラス（またはそのプロパティや関数）が初めて参照されたときにクラスが読み込まれ、クラスの読み込みによって&lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;コンパニオンオブジェクト&lt;/a&gt;が初期化されます。これにより、循環依存関係がある場合、ランタイム例外が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9724d2f4d0f2fb74f7ee2235878c749f495a0bad" translate="yes" xml:space="preserve">
          <source>In Kotlin, polymorphism is achieved via the class hierarchy, in such a way that it is impossible to run into a situation where a property or function is missing. The basic rule is that a variable/property/parameter whose declared type is &lt;code&gt;A&lt;/code&gt; may refer to an instance of a class &lt;code&gt;B&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt; is a subtype of &lt;code&gt;A&lt;/code&gt;. This means that either, &lt;code&gt;A&lt;/code&gt; must be a class and &lt;code&gt;B&lt;/code&gt; must be a subclass of &lt;code&gt;A&lt;/code&gt;, or that &lt;code&gt;A&lt;/code&gt; must be an interface and &lt;code&gt;B&lt;/code&gt; must be a class that implements that interface or be a subclass of a class that does. With our classes and interfaces from the previous sections, we can define these functions:</source>
          <target state="translated">Kotlinでは、ポリモーフィズムはクラス階層を介して実現され、プロパティまたは関数が欠落している状況に遭遇することは不可能です。基本的なルールは、宣言されたタイプが &lt;code&gt;A&lt;/code&gt; である変数/プロパティ/パラメータは、 &lt;code&gt;B&lt;/code&gt; が &lt;code&gt;A&lt;/code&gt; のサブタイプである場合に限り、クラス &lt;code&gt;B&lt;/code&gt; のインスタンスを参照することができるということです。これは、 &lt;code&gt;A&lt;/code&gt; がクラスであり、 &lt;code&gt;B&lt;/code&gt; が &lt;code&gt;A&lt;/code&gt; のサブクラスであるか、または &lt;code&gt;A&lt;/code&gt; がインターフェースであり、 &lt;code&gt;B&lt;/code&gt; がそのインターフェースを実装するクラスであるか、またはそのクラスのサブクラスである必要があることを意味します。前のセクションのクラスとインターフェースを使用して、次の関数を定義できます。</target>
        </trans-unit>
        <trans-unit id="1ea952e978cda6b66f0b076e1bf4afae5776a252" translate="yes" xml:space="preserve">
          <source>In Kotlin, the default implementation of &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; which you can think of as a resizable array.</source>
          <target state="translated">Kotlinでは、 &lt;code&gt;List&lt;/code&gt; のデフォルト実装は&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; で&lt;/a&gt;あり、サイズ変更可能な配列と考えることができます。</target>
        </trans-unit>
        <trans-unit id="b0f2e47b033955ac0009c7acc59029af121c0f6e" translate="yes" xml:space="preserve">
          <source>In Kotlin, the expression for a default value is evaluated every time the function is invoked. Therefore, you will avoid the above trap as long as you use an expression that produces a new list every time it is evaluated:</source>
          <target state="translated">Kotlinでは、デフォルト値の式は関数が呼び出されるたびに評価されます。したがって、評価されるたびに新しいリストを生成する式を使用している限り、上記の罠を回避することができます。</target>
        </trans-unit>
        <trans-unit id="1f711d573309109397667a32c94fd541ceecdc60" translate="yes" xml:space="preserve">
          <source>In Kotlin, the orders of objects can be defined in several ways.</source>
          <target state="translated">Kotlinでは、オブジェクトの順序をいくつかの方法で定義することができます。</target>
        </trans-unit>
        <trans-unit id="2339e3beff8d4c7968bd5b14328be82bd9a5b046" translate="yes" xml:space="preserve">
          <source>In Kotlin, the type system distinguishes between references that can hold &lt;em&gt;null&lt;/em&gt; (nullable references) and those that can not (non-null references). For example, a regular variable of type &lt;code&gt;String&lt;/code&gt; can not hold &lt;em&gt;null&lt;/em&gt;:</source>
          <target state="translated">Kotlinでは、型システムは&lt;em&gt;null&lt;/em&gt;を保持できる参照（null可能な参照）と保持できない参照（null以外の参照）を区別し&lt;em&gt;ます&lt;/em&gt;。たとえば、 &lt;code&gt;String&lt;/code&gt; 型の通常の変数は&lt;em&gt;nullを&lt;/em&gt;保持できません。</target>
        </trans-unit>
        <trans-unit id="832014b08edc07489a35f79862dd60fe09daab6f" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</source>
          <target state="translated">Kotlinでは、関数の最後のパラメータが関数の場合、対応する引数として渡されたラムダ式を括弧の外に置くことができます。</target>
        </trans-unit>
        <trans-unit id="c2a3923bf671e235e84ea1d045b896ec7fad1d7d" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called &lt;strong&gt;declaration-site variance&lt;/strong&gt;: we can annotate the &lt;strong&gt;type parameter&lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; of Source to make sure that it is only &lt;strong&gt;returned&lt;/strong&gt; (produced) from members of &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt;, and never consumed. To do this we provide the &lt;strong&gt;out&lt;/strong&gt; modifier:</source>
          <target state="translated">Kotlinには、この種のことをコンパイラーに説明する方法があります。これは&lt;strong&gt;宣言サイトバリアンス&lt;/strong&gt;と呼ばれます。Sourceの&lt;strong&gt;型パラメーター&lt;/strong&gt; &lt;code&gt;T&lt;/code&gt; に注釈を付けて、 &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; メンバーからのみ&lt;strong&gt;返され&lt;/strong&gt;（生成され）、消費されないようにすることができます。これを行うには、&lt;strong&gt;out&lt;/strong&gt;修飾子を提供します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feddf47fe54f2c3f729a6d26efa190cb7e973f88" translate="yes" xml:space="preserve">
          <source>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it's recommended to simply use package-level functions instead.</source>
          <target state="translated">Kotlin では、Java や C#とは異なり、クラスは静的メソッドを持ちません。ほとんどの場合、代わりに単にパッケージレベルの関数を使うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d5e92ec06e3b15b62ad5ec58ebeffa93765ab71a" translate="yes" xml:space="preserve">
          <source>In Kotlin, we can only use a normal, unqualified &lt;code&gt;return&lt;/code&gt; to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;, and a bare &lt;code&gt;return&lt;/code&gt; is forbidden inside a lambda, because a lambda cannot make the enclosing function return:</source>
          <target state="translated">Kotlinでは、名前の付いた関数または無名関数を終了するために、通常の修飾されていない &lt;code&gt;return&lt;/code&gt; のみを使用できます。これは、ラムダを終了するには&lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;を使用する必要があることを意味します。ラムダは囲み関数を返すことができないため、ラムダ内でのベア &lt;code&gt;return&lt;/code&gt; は禁止されています。</target>
        </trans-unit>
        <trans-unit id="6b416b284c329b83d138fdf71a7f58ad406d7c9b" translate="yes" xml:space="preserve">
          <source>In Maven</source>
          <target state="translated">メイヴンでは</target>
        </trans-unit>
        <trans-unit id="9ce095374b679dfd053dccebdba1f6ce80a67e34" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;jpa&lt;/code&gt; plugin:</source>
          <target state="translated">Mavenで &lt;code&gt;jpa&lt;/code&gt; プラグインを有効にします。</target>
        </trans-unit>
        <trans-unit id="4cf1f43e65b88c5f6958702897fafbb7af63f2e9" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;spring&lt;/code&gt; plugin:</source>
          <target state="translated">Mavenのでは、有効 &lt;code&gt;spring&lt;/code&gt; プラグインを：</target>
        </trans-unit>
        <trans-unit id="6dc887971001bc1cd4775889e759bfb59211b14c" translate="yes" xml:space="preserve">
          <source>In Python, function names must be unique within a module or a class. In Kotlin, we can &lt;em&gt;overload&lt;/em&gt; functions: there can be multiple declarations of functions that have the same name. Overloaded functions must be distinguishable from each other through their parameter lists. (The types of the parameter list, together with the return type, is known as a function's &lt;em&gt;signature&lt;/em&gt;, but the return type cannot be used to disambiguate overloaded functions.) For example, we can have both of these functions in the same file:</source>
          <target state="translated">Pythonでは、関数名はモジュールまたはクラス内で一意である必要があります。Kotlinでは、関数を&lt;em&gt;オーバーロード&lt;/em&gt;できます。同じ名前の関数が複数宣言されている可能性があります。オーバーロードされた関数は、それらのパラメーターリストを通じて互いに区別できる必要があります。（パラメーターリストの型は、戻り値の型とともに、関数の&lt;em&gt;シグネチャ&lt;/em&gt;と呼ばれますが、戻り値の型を使用して、オーバーロードされた関数を明確にすることはできません。）たとえば、これらの両方の関数を同じファイルに含めることができます。</target>
        </trans-unit>
        <trans-unit id="1c0f7f91981a6ecf109d226f21e3069c8aabc15a" translate="yes" xml:space="preserve">
          <source>In Python, the expression for a default value is evaluated once, at function definition time. That leads to this classic trap, where the developer hopes to get a new, empty list every time the function is called without a value for &lt;code&gt;numbers&lt;/code&gt;, but instead, the same list is being used every time:</source>
          <target state="translated">Pythonでは、デフォルト値の式は関数定義時に1回評価されます。これはこの古典的なトラップにつながります。開発者は、数値の値なしで関数が呼び出されるたびに新しい空のリストを取得することを望んでい &lt;code&gt;numbers&lt;/code&gt; が、代わりに同じリストが毎回使用されています。</target>
        </trans-unit>
        <trans-unit id="cd3d02ed8996a5f9eaf8b21aad3a4aaadb80de18" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;when&lt;/code&gt; statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</source>
          <target state="translated">で &lt;code&gt;when&lt;/code&gt; 、分岐は1行以上であれば文、空白行と隣接するケースブロックからそれを分離する検討します。</target>
        </trans-unit>
        <trans-unit id="3a1b36cf0bd1ee7bba19fe0760cca000ad48b849" translate="yes" xml:space="preserve">
          <source>In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; function returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; that can be used to cancel the running coroutine:</source>
          <target state="translated">長時間実行されるアプリケーションでは、バックグラウンドコルーチンをきめ細かく制御する必要がある場合があります。たとえば、ユーザーがコルーチンを起動したページを閉じたため、結果が不要になり、その操作をキャンセルできる場合があります。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;打ち上げ&lt;/a&gt;関数は返し&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;ジョブ&lt;/a&gt;実行中のコルーチンをキャンセルするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="e333c99581fbe52762649b5ab0c35c55ffcd093c" translate="yes" xml:space="preserve">
          <source>In a member of a &lt;a href=&quot;classes#inheritance&quot;&gt;class&lt;/a&gt;, &lt;em&gt;this&lt;/em&gt; refers to the current object of that class.</source>
          <target state="translated">&lt;a href=&quot;classes#inheritance&quot;&gt;クラスの&lt;/a&gt;メンバーでは、&lt;em&gt;これ&lt;/em&gt;はそのクラスの現在のオブジェクトを指します。</target>
        </trans-unit>
        <trans-unit id="15a56874c4866fabbe734af8a3fb102f28e0b12f" translate="yes" xml:space="preserve">
          <source>In a nutshell, you can use libraries such as &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; in your Kotlin projects.</source>
          <target state="translated">簡単に言えば、Kotlinプロジェクトで&lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt;や&lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt;などのライブラリを使用できます。</target>
        </trans-unit>
        <trans-unit id="5544e7dcfdd04da3eceaae6a1614ec1e4f550da9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;strong&gt;out&lt;/strong&gt;, Kotlin provides a complementary variance annotation: &lt;strong&gt;in&lt;/strong&gt;. It makes a type parameter &lt;strong&gt;contravariant&lt;/strong&gt;: it can only be consumed and never produced. A good example of a contravariant type is &lt;code&gt;Comparable&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;out&lt;/strong&gt;に加え&lt;strong&gt;て&lt;/strong&gt;、Kotlinは補完的な分散アノテーションを提供します：&lt;strong&gt;in&lt;/strong&gt;。型パラメーターを&lt;strong&gt;反変にし&lt;/strong&gt;ます：消費のみ可能で、生成はできません。反変タイプの良い例は &lt;code&gt;Comparable&lt;/code&gt; です：</target>
        </trans-unit>
        <trans-unit id="c6329f208d955601deb101d4b33fc1acdf8accac" translate="yes" xml:space="preserve">
          <source>In addition to common operations for &lt;a href=&quot;collection-parts&quot;&gt;Retrieving Collection Parts&lt;/a&gt;, lists provide the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt;&lt;code&gt;subList()&lt;/code&gt;&lt;/a&gt; function that returns a view of the specified elements range as a list. Thus, if an element of the original collection changes, it also changes in the previously created sublists and vice versa.</source>
          <target state="translated">&lt;a href=&quot;collection-parts&quot;&gt;コレクションパーツ&lt;/a&gt;を取得するための一般的な操作に加えて、リストには、指定された要素の範囲のビューをリストとして返す&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt; &lt;code&gt;subList()&lt;/code&gt; &lt;/a&gt;関数が用意されています。したがって、元のコレクションの要素が変更されると、以前に作成されたサブリストでも変更され、逆も同様です。</target>
        </trans-unit>
        <trans-unit id="9674c96ddd7757af7200ad4daae22ce260bb2047" translate="yes" xml:space="preserve">
          <source>In addition to removing elements, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt;&lt;code&gt;MutableListIterator&lt;/code&gt;&lt;/a&gt; can also insert and replace elements while iterating the list.</source>
          <target state="translated">要素の削除に加えて、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt; &lt;code&gt;MutableListIterator&lt;/code&gt; &lt;/a&gt;はリストの反復中に要素を挿入および置換することもできます。</target>
        </trans-unit>
        <trans-unit id="38a6e3c954dde3e3eb6edba41ad0b83ce52bd70c" translate="yes" xml:space="preserve">
          <source>In addition to scope functions, the standard library contains the functions &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;. These functions let you embed checks of the object state in call chains.</source>
          <target state="translated">スコープ関数に加えて、標準ライブラリには関数 &lt;code&gt;takeIf&lt;/code&gt; と &lt;code&gt;takeUnless&lt;/code&gt; が含まれています。これらの関数を使用すると、オブジェクトの状態のチェックを呼び出しチェーンに埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="acfd15e725bcfef6236f16c4782a0f3dc2126f4d" translate="yes" xml:space="preserve">
          <source>In addition to that, you can use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; to access the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; instance corresponding to the class. The &lt;code&gt;JsClass&lt;/code&gt; instance itself is a reference to the constructor function. This can be used to interoperate with JS functions that expect a reference to a constructor.</source>
          <target state="translated">さらに、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt;を使用して、クラスに対応する&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt;インスタンスにアクセスできます。 &lt;code&gt;JsClass&lt;/code&gt; のインスタンス自体は、コンストラクタ関数への参照です。これは、コンストラクターへの参照を期待するJS関数と相互運用するために使用できます。</target>
        </trans-unit>
        <trans-unit id="5594aa712f7692fd1a48c40180fe2939a4654a66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; dependency shown above, you need to add a dependency on the Kotlin standard library:</source>
          <target state="translated">上記の &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; 依存関係に加えて、Kotlin標準ライブラリへの依存関係を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea7c2f23dd342e78eba03e7edea502fd9fbb6ef4" translate="yes" xml:space="preserve">
          <source>In addition to the build tasks, the Gradle build includes helpful tasks to run the application directly via &lt;code&gt;runDebugExecutableNative&lt;/code&gt; and &lt;code&gt;runReleaseExecutableNative&lt;/code&gt;.</source>
          <target state="translated">ビルドタスクに加えて、Gradleビルドには、 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; および &lt;code&gt;runReleaseExecutableNative&lt;/code&gt; を介してアプリケーションを直接実行するための便利なタスクが含まれています。</target>
        </trans-unit>
        <trans-unit id="1d5b7f7ad1a1556c56ce8e8eb4580dccfbc4c337" translate="yes" xml:space="preserve">
          <source>In addition to the collection modification operations described in &lt;a href=&quot;collection-write&quot;&gt;Collection Write Operations&lt;/a&gt;, &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; lists support specific write operations. Such operations use the index to access elements to broaden the list modification capabilities.</source>
          <target state="translated">&lt;a href=&quot;collection-write&quot;&gt;コレクション書き込み&lt;/a&gt;操作で説明されているコレクション変更操作に加えて、&lt;a href=&quot;collections-overview#collection-types&quot;&gt;変更可能な&lt;/a&gt;リストは特定の書き込み操作をサポートします。このような操作では、インデックスを使用して要素にアクセスし、リスト変更機能を拡張します。</target>
        </trans-unit>
        <trans-unit id="edff8af41569526ee6f34e250c39b84435f2d3a3" translate="yes" xml:space="preserve">
          <source>In addition to the command line compiler and IntelliJ IDEA, you can also build Kotlin projects with Ant, Maven, and Gradle.</source>
          <target state="translated">コマンドラインコンパイラやIntelliJ IDEAに加えて、Ant、Maven、Gradleを使ってKotlinプロジェクトを構築することができます。</target>
        </trans-unit>
        <trans-unit id="13939289a96ed1a1e50225139ac3fbd7b0bc2be9" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete. The main difference between &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is that the latter does not block the current thread while waiting for all children to complete.</source>
          <target state="translated">別のビルダーによって提供さコルーチン範囲に加えて、使用して独自のスコープを宣言することが可能である&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;ビルダーを。コルーチンスコープを作成し、起動されたすべての子が完了するまで完了しません。主な違い&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;と&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeは&lt;/a&gt;完全にすべての子供たちを待っている間に、後者は現在のスレッドをブロックしていないということです。</target>
        </trans-unit>
        <trans-unit id="063fa2441ff30c74a010fc27ec5f2018d7ca4ef2" translate="yes" xml:space="preserve">
          <source>In addition to the output JavaScript file, the plugin by default creates an additional JS file with binary descriptors. This file is required if you're building a reusable library that other Kotlin modules can depend on, and should be distributed together with the result of translation. The generation is controlled by the &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; option:</source>
          <target state="translated">出力JavaScriptファイルに加えて、プラグインはデフォルトでバイナリ記述子を含む追加のJSファイルを作成します。このファイルは、他のKotlinモジュールが依存できる再利用可能なライブラリを構築する場合に必要であり、翻訳の結果とともに配布する必要があります。生成は、 &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; オプションによって制御されます。</target>
        </trans-unit>
        <trans-unit id="4c8c93a8699f08045725902510444a7e2a812bf3" translate="yes" xml:space="preserve">
          <source>In addition, Rx does introduce a somewhat nicer approach to error handling.</source>
          <target state="translated">加えて、Rx はエラー処理に多少マシなアプローチを導入しています。</target>
        </trans-unit>
        <trans-unit id="3434b058fadc1fd97196abc0cd226b5de0eff131" translate="yes" xml:space="preserve">
          <source>In addition, each of these also have a corresponding &lt;code&gt;{file}.meta.js&lt;/code&gt; meta file which will be used for reflection and other functionality.</source>
          <target state="translated">さらに、これらのそれぞれに対応する &lt;code&gt;{file}.meta.js&lt;/code&gt; メタファイルがあり、リフレクションやその他の機能に使用されます。</target>
        </trans-unit>
        <trans-unit id="adf05c9d4a5ea22db47de9f6cd0f0a1f61618f95" translate="yes" xml:space="preserve">
          <source>In all cases, the C string is supposed to be encoded as UTF-8.</source>
          <target state="translated">いずれの場合も、Cの文字列はUTF-8でエンコードされることになっています。</target>
        </trans-unit>
        <trans-unit id="2ad8a2cde437dc29e925bd2e2608bcf1efd428d2" translate="yes" xml:space="preserve">
          <source>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</source>
          <target state="translated">デフォルトのゲッターやセッターを使ったプライベート・プロパティへのアクセスが最適化されているため、関数呼び出しのオーバーヘッドが発生しません。</target>
        </trans-unit>
        <trans-unit id="af3fb6a2c1c95a7bcc9ea3f79ae7998d4cb1b27a" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; or a &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;&lt;em&gt;this&lt;/em&gt; denotes the &lt;em&gt;receiver&lt;/em&gt; parameter that is passed on the left-hand side of a dot.</source>
          <target state="translated">で&lt;a href=&quot;extensions&quot;&gt;拡張機能&lt;/a&gt;または&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;受信機と関数リテラル&lt;/a&gt;&lt;em&gt;この&lt;/em&gt;意味&lt;em&gt;受信&lt;/em&gt;ドットの左側に渡されるパラメータ。</target>
        </trans-unit>
        <trans-unit id="751813b87d30d6501d1bf6ea23fd73a02ca28ea0" translate="yes" xml:space="preserve">
          <source>In an inline function definition, you can use &lt;code&gt;noinline&lt;/code&gt; in front of any function-typed parameter to prevent the lambda that will be passed to it from also being inlined.</source>
          <target state="translated">インライン関数定義では、関数型パラメーターの前で &lt;code&gt;noinline&lt;/code&gt; を使用して、渡されるラムダもインライン化されないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="751fca68ff5e9efd6f13ba9f691a416e15e88e6e" translate="yes" xml:space="preserve">
          <source>In any lists, you can find the position of an element using the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt;&lt;code&gt;indexOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/a&gt;. They return the first and the last position of an element equal to the given argument in the list. If there are no such elements, both functions return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">どのリストでも、関数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt; &lt;code&gt;indexOf()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt; &lt;code&gt;lastIndexOf()&lt;/code&gt; &lt;/a&gt;を使用して要素の位置を見つけることができます。リスト内の指定された引数に等しい要素の最初と最後の位置を返します。そのような要素がない場合、両方の関数は &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c3c35f058a2881495687f9b24556ffc42c9b3b89" translate="yes" xml:space="preserve">
          <source>In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereby Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</source>
          <target state="translated">アプローチとしてはFuturesに非常に似ていますが、Futureは離散的な要素を返すと考えることができ、Rxはストリームを返すことになります。しかし、前のものと似ていますが、これはプログラミングモデルについての全く新しい考え方を導入しています。</target>
        </trans-unit>
        <trans-unit id="afaa57d188a4de777b467f6dcde31f2f2cfb5700" translate="yes" xml:space="preserve">
          <source>In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite the value associated with the former one.</source>
          <target state="translated">2つのエントリがイコールキーにマッピングされている場合、後者の値が前者の値を上書きします。</target>
        </trans-unit>
        <trans-unit id="ab773dc6434fe9e51f59bd2f39f7407e2e315f54" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed&lt;/a&gt; exceptions of the former.</source>
          <target state="translated">&lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;ブロック&lt;/a&gt;で発生した例外が原因でリソースが閉じられていて、閉じることも例外で失敗した場合、後者は前者の&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;抑制&lt;/a&gt;された例外に追加されます。</target>
        </trans-unit>
        <trans-unit id="a99d3de27a9334d7d61ccdc4fea1d3937e232802" translate="yes" xml:space="preserve">
          <source>In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the common indent is 0, and therefore this function doesn't change the indentation.</source>
          <target state="translated">空白でない行で先頭の空白文字がない(インデントが全くない)場合は、共通のインデントは0になりますので、この関数はインデントを変更しません。</target>
        </trans-unit>
        <trans-unit id="c60b20e0301bd757b71bb24ccc047d80b78f21b1" translate="yes" xml:space="preserve">
          <source>In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the &lt;a href=&quot;this-expressions#qualified&quot;&gt;qualified &lt;code&gt;this&lt;/code&gt; syntax&lt;/a&gt;.</source>
          <target state="translated">ディスパッチレシーバーと拡張レシーバーのメンバー間で名前が競合する場合、拡張レシーバーが優先されます。ディスパッチレシーバーのメンバーを参照するには、&lt;a href=&quot;this-expressions#qualified&quot;&gt;修飾された &lt;code&gt;this&lt;/code&gt; 構文を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="2564f2a33e66657de3341732c5e625e51d4323de" translate="yes" xml:space="preserve">
          <source>In case of the extension property in a class, the instance of the class should be passed first and the instance of the extension receiver second.</source>
          <target state="translated">クラス内の拡張プロパティの場合は、そのクラスのインスタンスを先に渡し、拡張受信側のインスタンスを後に渡します。</target>
        </trans-unit>
        <trans-unit id="1a1fb30f33e29cde0e4a9adce651bb450975c80d" translate="yes" xml:space="preserve">
          <source>In case this type is based on an inner class, the returned list contains the type arguments provided for the innermost class first, then its outer class, and so on. For example, in the type &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; the returned list is &lt;code&gt;[C, D, A, B]&lt;/code&gt;.</source>
          <target state="translated">この型が内部クラスに基づいている場合、返されるリストには、最初に最も内側のクラス、次にその外部クラスというように提供される型引数が含まれます。たとえば、タイプ &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; では、返されるリストは &lt;code&gt;[C, D, A, B]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="744293bc64c3188af17bab32f33333fe2cad85c9" translate="yes" xml:space="preserve">
          <source>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the &lt;code&gt;noinline&lt;/code&gt; modifier:</source>
          <target state="translated">インライン関数に渡される一部のラムダのみをインライン化する場合は、 &lt;code&gt;noinline&lt;/code&gt; 修飾子を使用して関数パラメーターの一部をマークできます。</target>
        </trans-unit>
        <trans-unit id="816f79d2ddebc85fd82a80af3cc580e6eeb81694" translate="yes" xml:space="preserve">
          <source>In case you're wondering about how &lt;code&gt;use&lt;/code&gt;, which is a function, can just be followed by a block like that, see the section on &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL support&lt;/a&gt;.</source>
          <target state="translated">関数である &lt;code&gt;use&lt;/code&gt; の後に、そのようなブロックを続ける方法について疑問がある場合は、&lt;a href=&quot;functional-programming#receivers&quot;&gt;DSLサポート&lt;/a&gt;に関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="de1e14373afc30cdce829d5ccf1028c05a1345bf" translate="yes" xml:space="preserve">
          <source>In common code:</source>
          <target state="translated">共通のコードで</target>
        </trans-unit>
        <trans-unit id="dbd13320c78fae25fd6f48673f77aea087d10896" translate="yes" xml:space="preserve">
          <source>In essence, this allows for the following code:</source>
          <target state="translated">本質的には、これにより以下のようなコードが可能になります。</target>
        </trans-unit>
        <trans-unit id="b797e297636a01e5f39faa44903e3922322a2f0c" translate="yes" xml:space="preserve">
          <source>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</source>
          <target state="translated">実際、プロパティの宣言やプライマリコンストラクタからの初期化については、Kotlinには簡潔な構文があります。</target>
        </trans-unit>
        <trans-unit id="8575e5bc9be645637c35224eaab5422d26408ea8" translate="yes" xml:space="preserve">
          <source>In further sections, these concepts are described in more detail along with the DSL to configure them in a project.</source>
          <target state="translated">後のセクションでは、これらの概念をプロジェクトで設定するためのDSLと一緒に、より詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="093d33db378ee271b0948a0579ab35389d4e97d5" translate="yes" xml:space="preserve">
          <source>In general, for small projects, we recommend converting all the files at once.</source>
          <target state="translated">一般的に、小規模なプロジェクトの場合は、一度にすべてのファイルを変換することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2ad6bf46a8b188e9bc3522dea93919d7678b502b" translate="yes" xml:space="preserve">
          <source>In general, identifiers may consist of letters, digits, and underscores, and may not begin with a digit. However, if you are writing code that e.g. autogenerates JSON based on identifiers and you want the JSON key to be a string that does not conform to these rules or that collides with a keyword, you can enclose it in backticks: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; is a valid identifier.</source>
          <target state="translated">一般に、識別子は文字、数字、アンダースコアで構成され、数字で始めることはできません。あなたが例えば自動生成識別子に基づいてJSONやキーワードでこれらの規則やその衝突に準拠していない文字列になるようにJSONのキーが欲しいというコードを書いている場合は、あなたはバッククォートで囲むことができます： &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; は有効な識別子です。</target>
        </trans-unit>
        <trans-unit id="def8cf1480d12ae42f29a02a77be00f6fa6a05e6" translate="yes" xml:space="preserve">
          <source>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</source>
          <target state="translated">一般的に、Kotlin のある構文の構成がオプションであり、IDE によって冗長であると強調されている場合は、コードの中でそれを省略するべきです。コードの中に不要な構文的要素を「わかりやすくするため」に残してはいけません。</target>
        </trans-unit>
        <trans-unit id="01b3fb6a7b9e95b734c635ce49024c6d660e14c4" translate="yes" xml:space="preserve">
          <source>In general, to create an instance of such a class, we need to provide the type arguments:</source>
          <target state="translated">一般的に、このようなクラスのインスタンスを作成するには、型の引数を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="450c32ce21d7e1cf7d82473c6445b4ccee4985e3" translate="yes" xml:space="preserve">
          <source>In generated code, the Kotlin compiler keeps a &lt;em&gt;wrapper&lt;/em&gt; for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how &lt;code&gt;Int&lt;/code&gt; can be &lt;a href=&quot;basic-types#representation&quot;&gt;represented&lt;/a&gt; either as a primitive &lt;code&gt;int&lt;/code&gt; or as the wrapper &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">生成されたコードでは、Kotlinコンパイラーは各インラインクラスの&lt;em&gt;ラッパー&lt;/em&gt;を保持し&lt;em&gt;ます&lt;/em&gt;。インラインクラスインスタンスは、実行時にラッパーまたは基になる型として表すことができます。これは、 &lt;code&gt;Int&lt;/code&gt; をプリミティブ &lt;code&gt;int&lt;/code&gt; またはラッパー &lt;code&gt;Integer&lt;/code&gt; として&lt;a href=&quot;basic-types#representation&quot;&gt;表す&lt;/a&gt;方法と似ています。</target>
        </trans-unit>
        <trans-unit id="fd80bee1bf4ef4cc9fdfdeda947dd40e1e56db38" translate="yes" xml:space="preserve">
          <source>In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible.</source>
          <target state="translated">ラムダ式では、中括弧の周りや、パラメータと本文を区切る矢印の周りにスペースを使用する必要があります。呼び出しが単一のラムダを取る場合は、可能な限り括弧の外に渡さなければなりません。</target>
        </trans-unit>
        <trans-unit id="80c8a890c9d273e819066140d09ce2d0bc285c7d" translate="yes" xml:space="preserve">
          <source>In lambdas which are short and not nested, it's recommended to use the &lt;code&gt;it&lt;/code&gt; convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</source>
          <target state="translated">短く、ネストされていないラムダでは、パラメーターを明示的に宣言する代わりに、 &lt;code&gt;it&lt;/code&gt; 規則を使用することをお勧めします。パラメータを持つネストされたラムダでは、パラメータは常に明示的に宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="0f96591676e8e90474bcc2e9cbd0fe550a87c6d7" translate="yes" xml:space="preserve">
          <source>In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. Group multiple closely related arguments on the same line.</source>
          <target state="translated">長い引数リストでは、最初の括弧の後に改行を入れます。引数を4スペースでインデントする。密接に関連する複数の引数を同じ行にグループ化する。</target>
        </trans-unit>
        <trans-unit id="e70f274fab45a9ad1cf0f5234b5a4c58fefd78f6" translate="yes" xml:space="preserve">
          <source>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the &lt;code&gt;is&lt;/code&gt;-checks and &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;explicit casts&lt;/a&gt; for immutable values and inserts (safe) casts automatically when needed:</source>
          <target state="translated">多くの場合、Kotlinで明示的なキャスト演算子を使用する必要はありません。コンパイラ &lt;code&gt;is&lt;/code&gt; 不変値のisチェックと&lt;a href=&quot;#unsafe-cast-operator&quot;&gt;明示的なキャスト&lt;/a&gt;を追跡し、必要に応じて（安全な）キャストを自動的に挿入します。</target>
        </trans-unit>
        <trans-unit id="d05a001b4fb4f64cd4a87d987f4f265545ae66a8" translate="yes" xml:space="preserve">
          <source>In mixed-language projects, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure (each file should be stored in the directory corresponding to each package statement).</source>
          <target state="translated">混合言語プロジェクトでは、Kotlin のソースファイルは Java のソースファイルと同じソースルートに存在し、同じディレクトリ構造に従ってください (各ファイルは各パッケージ文に対応するディレクトリに格納されていなければなりません)。</target>
        </trans-unit>
        <trans-unit id="a772373d726c1ea1dd1e4b5bd74e75bb5171d98d" translate="yes" xml:space="preserve">
          <source>In modules that don't provide their own API, such as application modules, you can use experimental APIs without propagating the experimental status to your code. In this case, mark your code with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental(Marker::class)&lt;/a&gt; annotation specifying the marker annotation of the experimental API:</source>
          <target state="translated">アプリケーションモジュールなど、独自のAPIを提供しないモジュールでは、試験的なステータスをコードに伝達せずに試験的なAPIを使用できます。この場合、実験的なAPIのマーカーアノテーションを指定する&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental（Marker :: class）&lt;/a&gt;アノテーションでコードをマークします。</target>
        </trans-unit>
        <trans-unit id="cfed7f25e3bb00e2797542765d6c2ca96af68b87" translate="yes" xml:space="preserve">
          <source>In most cases, Kotlin follows the Java coding conventions.</source>
          <target state="translated">ほとんどの場合、KotlinはJavaのコーディング規約に従っています。</target>
        </trans-unit>
        <trans-unit id="d126b0359662ea6c66b61b9e3af53b0d85339044" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence.</source>
          <target state="translated">複数行モードでは、式 &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;$&lt;/code&gt; は、それぞれ行末記号または入力シーケンスの終わりの直後または直前に一致します。</target>
        </trans-unit>
        <trans-unit id="6667a323602babcf47c04e12460b410e75814d22" translate="yes" xml:space="preserve">
          <source>In order to assemble an application, we also need to include the Kotlin standard library, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency, and the other libraries if any.</source>
          <target state="translated">アプリケーションをアセンブルするには、Kotlin標準ライブラリ、つまり依存関係として含まれていた &lt;code&gt;kotlin.js&lt;/code&gt; と、存在する場合は他のライブラリも含める必要があります。</target>
        </trans-unit>
        <trans-unit id="034cc52464c28236e3f8c4183a0d3673ce621a3f" translate="yes" xml:space="preserve">
          <source>In order to avoid compatibility issues during an Xcode build, the plugin requires using a &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle wrapper&lt;/a&gt;. To generate the wrapper automatically during execution of the &lt;code&gt;podspec&lt;/code&gt; task, run it with the parameter &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt;.</source>
          <target state="translated">Xcodeビルド中の互換性の問題を回避するために、プラグインは&lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradleラッパー&lt;/a&gt;を使用する必要があります。 &lt;code&gt;podspec&lt;/code&gt; タスクの実行中にラッパーを自動的に生成するには、パラメーター &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt; を指定してラッパーを実行します。</target>
        </trans-unit>
        <trans-unit id="4a047d1f6392366b3f681991fe461367b7be253f" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;set up the &lt;em&gt;kotlin-gradle&lt;/em&gt; plugin&lt;/a&gt;, &lt;a href=&quot;#targeting-the-jvm&quot;&gt;apply it&lt;/a&gt; to your project and &lt;a href=&quot;#configuring-dependencies&quot;&gt;add &lt;em&gt;kotlin-stdlib&lt;/em&gt; dependencies&lt;/a&gt;. Those actions may also be performed automatically in IntelliJ IDEA by invoking &lt;strong&gt;Tools | Kotlin | Configure Kotlin&lt;/strong&gt; in &lt;strong&gt;Project&lt;/strong&gt; action.</source>
          <target state="translated">GradleのでKotlinのプロジェクトをビルドするためには、あなたがすべき&lt;a href=&quot;#plugin-and-versions&quot;&gt;設定&lt;em&gt;kotlin-のGradle&lt;/em&gt;プラグインを&lt;/a&gt;、&lt;a href=&quot;#targeting-the-jvm&quot;&gt;それを適用する&lt;/a&gt;プロジェクトにし、&lt;a href=&quot;#configuring-dependencies&quot;&gt;追加&lt;em&gt;kotlin-STDLIBの&lt;/em&gt;依存関係を&lt;/a&gt;。それらのアクションは、IntelliJ IDEAで&lt;strong&gt;Tools | コトリン| &lt;/strong&gt;&lt;strong&gt;プロジェクト&lt;/strong&gt;アクションで&lt;strong&gt;Kotlin&lt;/strong&gt;を&lt;strong&gt;構成し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e347f51a9c40cc493b347c1bed8c2d5285726dad" translate="yes" xml:space="preserve">
          <source>In order to compile JavaScript code, you need to use the &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;test-js&lt;/code&gt; goals for the &lt;code&gt;compile&lt;/code&gt; execution:</source>
          <target state="translated">JavaScriptコードをコンパイルするには、 &lt;code&gt;compile&lt;/code&gt; 実行に &lt;code&gt;js&lt;/code&gt; および &lt;code&gt;test-js&lt;/code&gt; ゴールを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7888ab5509b34a7615518c3269c358c32f2dd548" translate="yes" xml:space="preserve">
          <source>In order to debug the application using IntelliJ IDEA, we need to perform two steps:</source>
          <target state="translated">IntelliJ IDEAを使ってアプリケーションをデバッグするためには、2つのステップを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="0d60abc6454bf0506cb62dd1ac746f025ab62610" translate="yes" xml:space="preserve">
          <source>In order to generate these bindings, we need to create a library definition &lt;code&gt;.def&lt;/code&gt; file that contains some information about the headers we need to generate. In our case we want to use the famous &lt;code&gt;libcurl&lt;/code&gt; library to make some HTTP calls, so we'll create a file named &lt;code&gt;libcurl.def&lt;/code&gt; with the following contents</source>
          <target state="translated">これらのバインディングを生成するには、生成する必要があるヘッダーに関する情報を含むライブラリ定義 &lt;code&gt;.def&lt;/code&gt; ファイルを作成する必要があります。この例では、有名な &lt;code&gt;libcurl&lt;/code&gt; ライブラリを使用してHTTP呼び出しを行いたいので、次の内容で &lt;code&gt;libcurl.def&lt;/code&gt; という名前のファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="ffbf97f9cc48e7603dadd7a45b25bf4f6b7e3989" translate="yes" xml:space="preserve">
          <source>In order to run, we need the corresponding WAR(s) for deploying. We can generate these using the &lt;em&gt;war&lt;/em&gt; task in Gradle which can easily be executed via the Gradle tool window in IntelliJ IDEA.</source>
          <target state="translated">実行するには、デプロイするための対応するWARが必要です。これらは、Gradle の&lt;em&gt;war&lt;/em&gt;タスクを使用して生成できます。これは、IntelliJ IDEAのGradleツールウィンドウから簡単に実行できます。</target>
        </trans-unit>
        <trans-unit id="24dcbfd34df21e70b79c4b2191a485e90cc3e450" translate="yes" xml:space="preserve">
          <source>In order to share the changes across the project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, it has to be committed to VCS. Alternatively &lt;strong&gt;kotlin.code.style&lt;/strong&gt;=&lt;strong&gt;obsolete&lt;/strong&gt; can be used for projects configured with Gradle or Maven.</source>
          <target state="translated">プロジェクト開発者の &lt;code&gt;.idea/codeStyle&lt;/code&gt; フォルダー間で変更を共有するには、VCSにコミットする必要があります。または、&lt;strong&gt;kotlin.code.style&lt;/strong&gt; = &lt;strong&gt;obsolete&lt;/strong&gt;は、GradleまたはMavenで構成されたプロジェクトに使用できます。</target>
        </trans-unit>
        <trans-unit id="155fb0f00f3221a063feea137fb0401c04ce9dd5" translate="yes" xml:space="preserve">
          <source>In order to share those changes for all project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder have to be committed to VCS.</source>
          <target state="translated">すべてのプロジェクト開発者がこれらの変更を共有するには、 &lt;code&gt;.idea/codeStyle&lt;/code&gt; フォルダーをVCSにコミットする必要があります。</target>
        </trans-unit>
        <trans-unit id="fa88cf692336fd455afd07788cc5c7d6ab06d938" translate="yes" xml:space="preserve">
          <source>In order to specify the module kind, we can add a configuration to our plugin as below</source>
          <target state="translated">モジュールの種類を指定するには、以下のようにプラグインに設定を追加します。</target>
        </trans-unit>
        <trans-unit id="59607fe0baf1ba77b3f9ca8983f516dc1d471c45" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objc header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">null可能性のある型をサポートするために、Objcヘッダーはnull可能の戻り値で &lt;code&gt;myVal&lt;/code&gt; を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="9aac89688353374371a7ae0f65a4346b1a58df3a" translate="yes" xml:space="preserve">
          <source>In order to use Gradle to target JavaScript, we need to use the &lt;code&gt;kotlin2js&lt;/code&gt; plugin as opposed to the &lt;code&gt;kotlin&lt;/code&gt; plugin.</source>
          <target state="translated">JavaScriptをターゲットにするのGradleを使用するために、我々は、使用する必要が &lt;code&gt;kotlin2js&lt;/code&gt; とは対照的に、プラグインを &lt;code&gt;kotlin&lt;/code&gt; プラグイン。</target>
        </trans-unit>
        <trans-unit id="33526a8ed38f3fde7c6b4f6af71779367c169bbc" translate="yes" xml:space="preserve">
          <source>In order to use Kotlin with node.js, we need to set the compiler option to use CommonJS. Once we do that, the output of the application should be accessible using the node module system.</source>
          <target state="translated">Kotlinをnode.jsで使うためには、コンパイラのオプションでCommonJSを使うように設定する必要があります。そうすれば、アプリケーションの出力はnodeモジュールシステムを使ってアクセスできるようになるはずです。</target>
        </trans-unit>
        <trans-unit id="5bdfd7a958cb3b5e6a62acec15106d2a72aa846c" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">このガイドの例に加えてコルーチンを使用するに&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;は、プロジェクトのREADMEで&lt;/a&gt;説明されているように、 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; モジュールへの依存関係を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="1cc60ead46c9defc457295413372bae706d2254f" translate="yes" xml:space="preserve">
          <source>In order to use something from a package, it is sufficient to use the package name to fully qualify the name of the symbol at the place where you use the symbol:</source>
          <target state="translated">パッケージから何かを使用するためには、そのシンボルを使用する場所のシンボルの名前を完全に修飾するためにパッケージ名を使用すれば十分です。</target>
        </trans-unit>
        <trans-unit id="9abc8ef7836ac20fac6436adb16fe6c5da1f6518" translate="yes" xml:space="preserve">
          <source>In order to use this, we also need to include the Kotlin standard library in our application, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency. By default, Maven does not expand the JAR as part of the build process, so we would need to add an additional step in our build to do so.</source>
          <target state="translated">これを使用するには、アプリケーションにKotlin標準ライブラリ、つまり依存関係として含まれていた &lt;code&gt;kotlin.js&lt;/code&gt; も含める必要があります。デフォルトでは、Mavenはビルドプロセスの一部としてJARを拡張しないため、ビルドに追加のステップを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="a5c6ba86278357c55cc58dbde4e4e54ec8ffad3f" translate="yes" xml:space="preserve">
          <source>In other words, inline classes introduce a truly &lt;em&gt;new&lt;/em&gt; type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</source>
          <target state="translated">つまり、インラインクラスは、既存のタイプの代替名（エイリアス）のみを導入するタイプエイリアスとは対照的に、真に&lt;em&gt;新しい&lt;/em&gt;タイプを導入します。</target>
        </trans-unit>
        <trans-unit id="2fcd261cf566bdf17c9a0226c120616065441d92" translate="yes" xml:space="preserve">
          <source>In our DSL all the tag classes extend the same superclass &lt;code&gt;Tag&lt;/code&gt;. It's enough to annotate only the superclass with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; and after that the Kotlin compiler will treat all the inherited classes as annotated:</source>
          <target state="translated">DSLでは、すべてのタグクラスが同じスーパークラス &lt;code&gt;Tag&lt;/code&gt; 拡張しています。 &lt;code&gt;@HtmlTagMarker&lt;/code&gt; でスーパークラスのみに注釈を付けるだけで十分です。その後、Kotlinコンパイラは継承されたすべてのクラスを注釈付きとして扱います。</target>
        </trans-unit>
        <trans-unit id="055ba8d22e98a479f59a07d7a075048bb0a20fe4" translate="yes" xml:space="preserve">
          <source>In our example, we have &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;コルーチンビルダーを使用してコルーチンに変換される &lt;code&gt;main&lt;/code&gt; 関数があります。 &lt;code&gt;runBlocking&lt;/code&gt; を含むすべてのコルーチンビルダーは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScopeの&lt;/a&gt;インスタンスをコードブロックのスコープに追加します。外部スコープ（この例では &lt;code&gt;runBlocking&lt;/code&gt; ）は、スコープ内で起動されたすべてのコルーチンが完了するまで完了しないため、明示的に &lt;code&gt;join&lt;/code&gt; 必要なく、このスコープ内でコルーチンを起動できます。したがって、例をより単純にすることができます。</target>
        </trans-unit>
        <trans-unit id="99c50d394fc235f8eeca8f1ea6662b1ec125d6bd" translate="yes" xml:space="preserve">
          <source>In our main function we create activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy activity after 500ms. This cancels all the coroutines that were launched which we can confirm by noting that it does not print onto the screen anymore if we wait:</source>
          <target state="translated">メイン関数でアクティビティを作成し、テストの &lt;code&gt;doSomething&lt;/code&gt; 関数を呼び出し、500ミリ秒後にアクティビティを破棄します。これにより、起動されたすべてのコルーチンがキャンセルされます。これを待つと、画面に出力されなくなることに注意して確認できます。</target>
        </trans-unit>
        <trans-unit id="4e33cfe3a798666f120dafc2300d3a53a316781b" translate="yes" xml:space="preserve">
          <source>In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file where the class itself is defined. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Do not create files just to hold &quot;all extensions of Foo&quot;.</source>
          <target state="translated">特に、あるクラスの拡張関数で、そのクラスのすべてのクライアントに関連するものを定義する場合は、そのクラス自体が定義されているのと同じファイルに記述してください。特定のクライアントにのみ意味のある拡張関数を定義する場合は、そのクライアントのコードの隣に置くようにしてください。Fooのすべての拡張子」を保持するためだけにファイルを作成しないでください。</target>
        </trans-unit>
        <trans-unit id="2683ff56288a092d85a9176c5ad7bb38fce09a9b" translate="yes" xml:space="preserve">
          <source>In practice some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through Release notes of version A that a change is coming in version B.</source>
          <target state="translated">実際には、コンパイル時に正確に検出できない変更もあるので、警告を報告することはできませんが、少なくともユーザにはバージョンAのリリースノートを通して、バージョンBに変更があることが通知されます。</target>
        </trans-unit>
        <trans-unit id="1e5d38479fe45d55c10d169d2b3903a772bc6139" translate="yes" xml:space="preserve">
          <source>In practice, quite a bit of code is affected, so this can be considered a major code style update.</source>
          <target state="translated">実際には、かなりのコードが影響を受けているので、これはコードスタイルのメジャーな更新と考えることができます。</target>
        </trans-unit>
        <trans-unit id="57e5b70de31acdb27d8d2c67fea04b3d16fdd8a7" translate="yes" xml:space="preserve">
          <source>In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with.</source>
          <target state="translated">実際には、大きな塊でスレッドを閉じ込めることが行われます。例えば、状態を更新するビジネスロジックの大きな部分はシングルスレッドに閉じ込められます。以下の例では、各コルーチンをシングルスレッドのコンテキストで実行しています。</target>
        </trans-unit>
        <trans-unit id="40969ff7e4fed85e58f626291a67f5273e20a573" translate="yes" xml:space="preserve">
          <source>In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:</source>
          <target state="translated">プログレッシブモードでは、言語セマンティクスのいくつかの修正がすぐに到着することがあります。これらの修正はすべて、2つの重要な性質を持っています。</target>
        </trans-unit>
        <trans-unit id="d10877f2d49f4fb7859f1ddc63051feb0cebe60b" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure is to follow the package structure with the common root package omitted (e.g. if all the code in the project is in the &quot;org.example.kotlin&quot; package and its subpackages, files with the &quot;org.example.kotlin&quot; package should be placed directly under the source root, and files in &quot;org.example.kotlin.foo.bar&quot; should be in the &quot;foo/bar&quot; subdirectory of the source root).</source>
          <target state="translated">純粋なKotlinプロジェクトでは、共通のルートパッケージを省略したパッケージ構造に従うことが推奨されます (例えば、プロジェクト内のすべてのコードが &quot;org.example.kotlin &quot;パッケージとそのサブパッケージに含まれている場合、&quot;org.example.kotlin &quot;パッケージのファイルはソースルートの直下に、&quot;org.example.kotlin.foo.bar &quot;のファイルはソースルートの &quot;foo/bar &quot;サブディレクトリに置くべきです)。</target>
        </trans-unit>
        <trans-unit id="7a5be9888b7ba5a318d3261861baf4d32fa8861a" translate="yes" xml:space="preserve">
          <source>In short: &lt;em&gt;think carefully through your declarations of integers, and be absolutely certain that the value will never ever need to be larger than the limits of the type!&lt;/em&gt; If you need an integer of unlimited size, use the non-primitive type &lt;code&gt;BigInteger&lt;/code&gt;.</source>
          <target state="translated">つまり&lt;em&gt;、整数の宣言を注意深く検討し、値が型の制限よりも大きくなる必要がないことを絶対に確認してください。&lt;/em&gt;サイズが無制限の整数が必要な場合は、非プリミティブ型 &lt;code&gt;BigInteger&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4a3b75ce2c9b15401d05148e77e0306873596e7e" translate="yes" xml:space="preserve">
          <source>In situations like this we can use the &lt;code&gt;dynamic&lt;/code&gt; type, which allows us to work with dynamic types when targeting JavaScript. The following variable is declared as &lt;code&gt;dynamic&lt;/code&gt; meaning that whatever we invoke on it will not result in a compile-time error:</source>
          <target state="translated">このような状況では、 &lt;code&gt;dynamic&lt;/code&gt; タイプを使用できます。これにより、JavaScriptをターゲットにするときに動的タイプを操作できます。次の変数は &lt;code&gt;dynamic&lt;/code&gt; として宣言されています。これは、この変数を呼び出してもコンパイル時エラーにはなりません。</target>
        </trans-unit>
        <trans-unit id="55bd36b85c22e6a1c4d10234a638ea714c3940ad" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">場合によっては（たとえば、オーバーロードをサポートするために）、KotlinコンパイラーはJavaScriptコードで生成された関数と属性の名前をマングルします。生成された名前を制御するには、 &lt;code&gt;@JsName&lt;/code&gt; アノテーションを使用できます。</target>
        </trans-unit>
        <trans-unit id="8f1f57175de66b286d8ac98729c81851940d41f3" translate="yes" xml:space="preserve">
          <source>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</source>
          <target state="translated">場合によっては、引数を持たない関数が読み取り専用のプロパティと互換性があるかもしれません。セマンティクスは似ていますが、いつ別のものを好むかについては、いくつかの文体上の決まりがあります。</target>
        </trans-unit>
        <trans-unit id="4526b2f446cfa690eb7c5baadbe7c8dea021438f" translate="yes" xml:space="preserve">
          <source>In some ways, this is easier to read because the operations are specified in the order they are applied to the values. The result will be an immutable &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is whichever type is produced by the transformations you use (in this case, &lt;code&gt;String&lt;/code&gt;). If you need a mutable list, call &lt;code&gt;toMutableList()&lt;/code&gt; at the end. If you want a set, call &lt;code&gt;toSet()&lt;/code&gt; or &lt;code&gt;toMutableSet()&lt;/code&gt; at the end. If you want to transform a collection into a map, call &lt;code&gt;associateBy()&lt;/code&gt;, which takes two lambdas that specify how to extract the key and the value from each element: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (you can omit the second lambda if you want the entire element to be the value, and you can call &lt;code&gt;toMutableMap()&lt;/code&gt; at the end if you want the result to be mutable).</source>
          <target state="translated">いくつかの点で、操作は値に適用される順序で指定されるため、これは読みやすくなります。結果は不変の &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; になります &lt;code&gt;T&lt;/code&gt; は、使用する変換（この場合は &lt;code&gt;String&lt;/code&gt; ）によって生成されるタイプです。変更可能なリストが必要な場合は、最後に &lt;code&gt;toMutableList()&lt;/code&gt; を呼び出します。セットが必要な場合は、最後に &lt;code&gt;toSet()&lt;/code&gt; または &lt;code&gt;toMutableSet()&lt;/code&gt; を呼び出します。コレクションをマップに変換する場合は、 &lt;code&gt;associateBy()&lt;/code&gt; 呼び出します。これは、各要素からキーと値を抽出する方法を指定する2つのラムダを取得します： &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; （要素全体を値にする場合は、2番目のラムダを省略できます。結果を変更可能にする場合は、最後に &lt;code&gt;toMutableMap()&lt;/code&gt; を呼び出します）。</target>
        </trans-unit>
        <trans-unit id="482c7a83b939d337af8bf0cb41a70749c1cb67ed" translate="yes" xml:space="preserve">
          <source>In spite of the &lt;code&gt;object&lt;/code&gt; keyword being used, a new instance of the anonymous class will be created whenever the object expression is evaluated.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; キーワードが使用されているにもかかわらず、オブジェクト式が評価されるたびに、匿名クラスの新しいインスタンスが作成されます。</target>
        </trans-unit>
        <trans-unit id="10fed13cfcbccf5e09d7648e3ceabcf9a0d8e2f5" translate="yes" xml:space="preserve">
          <source>In spite of this syntactical convenience, the companion object is a proper object on its own, and can have its own supertypes - and you can assign it to a variable and pass it around. If you're integrating with Java code and need a true &lt;code&gt;static&lt;/code&gt; member, you can &lt;a href=&quot;annotations&quot;&gt;annotate&lt;/a&gt; a member inside a companion object with &lt;code&gt;@JvmStatic&lt;/code&gt;.</source>
          <target state="translated">この構文上の便利さにもかかわらず、コンパニオンオブジェクトはそれ自体が適切なオブジェクトであり、独自のスーパータイプを持つことができます。また、それを変数に割り当てて渡すことができます。Javaコードと統合していて、真の &lt;code&gt;static&lt;/code&gt; メンバーが必要な場合は、コンパニオンオブジェクト内のメンバーに &lt;code&gt;@JvmStatic&lt;/code&gt; で&lt;a href=&quot;annotations&quot;&gt;注釈を付ける&lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="8be34c3c318a79f1a61390cd86ad3bb03f42aee7" translate="yes" xml:space="preserve">
          <source>In subsequent tutorials we'll show how you can influence the files generated, for example, change location, prefix and suffixes, and how you can work with modules.</source>
          <target state="translated">以降のチュートリアルでは、生成されたファイルにどのように影響を与えることができるのか、例えば場所の変更、接頭辞や接尾辞の変更、モジュールの操作方法などを説明します。</target>
        </trans-unit>
        <trans-unit id="de0700bb726b0915ca84006a652a9bb020053b41" translate="yes" xml:space="preserve">
          <source>In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">テストでは(テストでのみ)、バックトークで囲まれたスペース付きのメソッド名を使用しても構いません。(このようなメソッド名は現在のところ Android ランタイムではサポートされていないことに注意してください)。メソッド名のアンダースコアはテストコードでも使用可能です。</target>
        </trans-unit>
        <trans-unit id="e4ad3e9e93913c50444eb70a3c6d491b3cf74240" translate="yes" xml:space="preserve">
          <source>In that case you need to use the spread operator &lt;code&gt;*&lt;/code&gt; to pass the &lt;code&gt;IntArray&lt;/code&gt;:</source>
          <target state="translated">その場合は、スプレッド演算子 &lt;code&gt;*&lt;/code&gt; を使用して &lt;code&gt;IntArray&lt;/code&gt; を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="dfa4bedab09a124fc51fd33f0b20a721f3509f7a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental mode&lt;/a&gt;, you can specify any variant name (not only flavor), e.g. &lt;code&gt;freeDebug&lt;/code&gt; or &lt;code&gt;freeRelease&lt;/code&gt; will work as well.</source>
          <target state="translated">では&lt;a href=&quot;#enabling-experimental-features&quot;&gt;、実験モードで&lt;/a&gt;使用すると、任意のバリアント名（味だけではなく）を指定することができ、例えば、 &lt;code&gt;freeDebug&lt;/code&gt; または &lt;code&gt;freeRelease&lt;/code&gt; は同様に動作します。</target>
        </trans-unit>
        <trans-unit id="34502d3bacebdc9ab51090cbc1ee8b5aa02dcb57" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;libnative_api.h&lt;/code&gt;, we'll find the following code. We will discuss the code in parts to make it easier to understand.</source>
          <target state="translated">で &lt;code&gt;libnative_api.h&lt;/code&gt; 、我々は次のコードを見つけることができます。わかりやすくするために、コードを部分的に説明します。</target>
        </trans-unit>
        <trans-unit id="97cbe1bbd40fde30fcff61322aab402c1acd97ce" translate="yes" xml:space="preserve">
          <source>In the Gradle dependencies you use add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin and replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Gradleの依存関係では、 &lt;code&gt;kotlin-kapt&lt;/code&gt; プラグインを追加し、 &lt;code&gt;annotationProcessor&lt;/code&gt; を &lt;code&gt;kapt&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="a87144873c9b9ee0a65c1c2fda83f3948fb32756" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, a completely different set of APIs is availiable, so one could instead implement logging to the console:</source>
          <target state="translated">JavaScript の世界では、全く異なる API のセットが利用可能なので、代わりにコンソールへのロギングを実装することができます。</target>
        </trans-unit>
        <trans-unit id="952c75185ceff6a4ea2264e236a32b30e1121e70" translate="yes" xml:space="preserve">
          <source>In the code above, the parameter &lt;code&gt;combine&lt;/code&gt; has a &lt;a href=&quot;#function-types&quot;&gt;function type&lt;/a&gt;&lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt;, so it accepts a function that takes two arguments of types &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and returns a value of type &lt;code&gt;R&lt;/code&gt;. It is &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;invoked&lt;/a&gt; inside the &lt;em&gt;for&lt;/em&gt;-loop, and the return value is then assigned to &lt;code&gt;accumulator&lt;/code&gt;.</source>
          <target state="translated">上記のコードでは、パラメータは &lt;code&gt;combine&lt;/code&gt; 持つ&lt;a href=&quot;#function-types&quot;&gt;機能タイプ&lt;/a&gt; &lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt; が受け入れるように、種類の二つの引数を取る関数は &lt;code&gt;R&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; 型の戻り値 &lt;code&gt;R&lt;/code&gt; を。これは&lt;em&gt;for&lt;/em&gt;ループ内で&lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;呼び出さ&lt;/a&gt;れ、戻り値は &lt;code&gt;accumulator&lt;/code&gt; に割り当てられます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="983dc81454e62d4d8dfeb15d4d6704ae3670a9b1" translate="yes" xml:space="preserve">
          <source>In the example above, the production sources for the JVM target are compiled by its &lt;code&gt;main&lt;/code&gt; compilation and therefore include the sources and dependencies from the source sets &lt;code&gt;jvmMain&lt;/code&gt; and &lt;code&gt;commonMain&lt;/code&gt; (due to the &lt;em&gt;depends on&lt;/em&gt; relation):</source>
          <target state="translated">上記の例では、JVMターゲットのプロダクションソースは &lt;code&gt;main&lt;/code&gt; コンパイルによってコンパイルされるため、ソースセット &lt;code&gt;jvmMain&lt;/code&gt; および &lt;code&gt;commonMain&lt;/code&gt; からのソースと依存関係が含まれます（&lt;em&gt;依存&lt;/em&gt;関係による）。</target>
        </trans-unit>
        <trans-unit id="92a4732d4ba58bb8eb4b7a1a153809f54718cd39" translate="yes" xml:space="preserve">
          <source>In the example below, we assume that there is a &lt;code&gt;DbModel&lt;/code&gt; base class, and that every subclass has got a parameterless primary constructor. In the inline function, &lt;code&gt;T&lt;/code&gt; is reified, so we can get the class metadata. We pass this to the function that does the real work of talking to the database.</source>
          <target state="translated">以下の例では、 &lt;code&gt;DbModel&lt;/code&gt; 基本クラスがあり、すべてのサブクラスがパラメーターなしのプライマリコンストラクターを持っていると想定しています。インライン関数では &lt;code&gt;T&lt;/code&gt; が具体化されているため、クラスのメタデータを取得できます。これを、データベースと通信する実際の作業を行う関数に渡します。</target>
        </trans-unit>
        <trans-unit id="f9725b5629cf5c05b1dabad8df3abc795d27f14a" translate="yes" xml:space="preserve">
          <source>In the example we have the most popular ways to pass or receive a string in the C language. We should take the return of &lt;code&gt;return_string&lt;/code&gt; with care. In general, it is best to make sure we use the right function to dispose the returned &lt;code&gt;char*&lt;/code&gt; with the right &lt;code&gt;free(..)&lt;/code&gt; function call.</source>
          <target state="translated">この例では、C言語で文字列を渡したり受け取ったりする最も一般的な方法があります。 &lt;code&gt;return_string&lt;/code&gt; の戻りには注意が必要です。一般に、正しい関数を使用して、返された &lt;code&gt;char*&lt;/code&gt; を正しい &lt;code&gt;free(..)&lt;/code&gt; 関数呼び出しで破棄することを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="45b64e498fcd11490ca143779a88435b7d9e0b0c" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;findViewById()&lt;/code&gt; is only invoked once:</source>
          <target state="translated">次の例では、 &lt;code&gt;findViewById()&lt;/code&gt; は1回だけ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8cf0c93c6e85cb80e10b5e71f71e2e6899fc70c7" translate="yes" xml:space="preserve">
          <source>In the generated Kotlin declarations, we see that &lt;code&gt;str&lt;/code&gt; is represented as &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt;. The type is nullable, and we can simply pass Kotlin &lt;code&gt;null&lt;/code&gt; as the parameter value.</source>
          <target state="translated">生成されたKotlin宣言では、 &lt;code&gt;str&lt;/code&gt; が &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt; として表されていることがわかりますか？。タイプはnull可能であり、パラメーター値としてKotlin &lt;code&gt;null&lt;/code&gt; を単に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="6ffd682e74db1be23092050eecf5e03af23b3260" translate="yes" xml:space="preserve">
          <source>In the generated code, the &lt;code&gt;provideDelegate&lt;/code&gt; method is called to initialize the auxiliary &lt;code&gt;prop$delegate&lt;/code&gt; property. Compare the generated code for the property declaration &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; with the generated code &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;above&lt;/a&gt; (when the &lt;code&gt;provideDelegate&lt;/code&gt; method is not present):</source>
          <target state="translated">生成されたコードでは、 &lt;code&gt;provideDelegate&lt;/code&gt; メソッドが呼び出され、補助 &lt;code&gt;prop$delegate&lt;/code&gt; プロパティが初期化されます。プロパティ宣言のために生成されたコードを比較 &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; 生成されたコードを有する&lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;上記&lt;/a&gt;（場合 &lt;code&gt;provideDelegate&lt;/code&gt; の方法が存在しません）。</target>
        </trans-unit>
        <trans-unit id="f86f30c4d84e613891c93b386289b1fcc35ce4d5" translate="yes" xml:space="preserve">
          <source>In the last line &lt;code&gt;button&lt;/code&gt; is referenced by &lt;code&gt;id&lt;/code&gt; using the &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin. Consider using this plugin as an alternative which allows you to keep binding logic in code and have the concise syntax at the same time.</source>
          <target state="translated">最後の行では、 &lt;code&gt;button&lt;/code&gt; は&lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt;プラグインを使用して &lt;code&gt;id&lt;/code&gt; によって参照されます。このプラグインを代替ロジックとして使用することを検討してください。これにより、コードのバインディングロジックを維持し、同時に簡潔な構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="7da80e212e3fb5a8c2cf3d597abb266f174acf51" translate="yes" xml:space="preserve">
          <source>In the last line, there's an implicit &lt;code&gt;this.&lt;/code&gt; in front of both &lt;code&gt;memberFunction()&lt;/code&gt; and &lt;code&gt;memberProperty&lt;/code&gt; (if these exist on the type of &lt;code&gt;someExpression&lt;/code&gt;). The return value is that of the last expression.</source>
          <target state="translated">最後の行には、暗黙の &lt;code&gt;this.&lt;/code&gt; &lt;code&gt;memberFunction()&lt;/code&gt; と &lt;code&gt;memberProperty&lt;/code&gt; の両方の前（これらが &lt;code&gt;someExpression&lt;/code&gt; のタイプに存在する場合）。戻り値は最後の式の戻り値です。</target>
        </trans-unit>
        <trans-unit id="21de312c94f28c9a74e944cc50e80500b0df440a" translate="yes" xml:space="preserve">
          <source>In the next dialog, provide the project details:</source>
          <target state="translated">次のダイアログでは、プロジェクトの詳細を入力します。</target>
        </trans-unit>
        <trans-unit id="fb8d123847c0bf27cf6ffe6e978d7163ff9a921d" translate="yes" xml:space="preserve">
          <source>In the old model, common and platform-specific code needed to be placed in separate modules, linked by &lt;code&gt;expectedBy&lt;/code&gt; dependencies. Now, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.</source>
          <target state="translated">古いモデルでは、一般的なコードとプラットフォーム固有のコードを、 &lt;code&gt;expectedBy&lt;/code&gt; 依存関係によってリンクされた別々のモジュールに配置する必要がありました。現在、共通のプラットフォーム固有のコードは、同じモジュールの異なるソースルートに配置されており、プロジェクトの構成が容易になっています。</target>
        </trans-unit>
        <trans-unit id="ca766f4efd26534c30d9c87798187848fcb65628" translate="yes" xml:space="preserve">
          <source>In the presence of &lt;code&gt;maven-publish&lt;/code&gt; plugin the publications for all the binaries built are created. The plugin uses Gradle metadata to publish the artifacts so this feature must be enabled (see the &lt;a href=&quot;#dependencies&quot;&gt;dependencies&lt;/a&gt; section).</source>
          <target state="translated">&lt;code&gt;maven-publish&lt;/code&gt; プラグインが存在する場合、ビルドされたすべてのバイナリのパブリケーションが作成されます。プラグインはGradleメタデータを使用してアーティファクトを公開するため、この機能を有効にする必要があります（&lt;a href=&quot;#dependencies&quot;&gt;依存関係の&lt;/a&gt;セクションを参照）。</target>
        </trans-unit>
        <trans-unit id="d60dd59e4676a95bd7097287912e2ec3768e0f9a" translate="yes" xml:space="preserve">
          <source>In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new &lt;code&gt;.kt&lt;/code&gt; file for each package you import.</source>
          <target state="translated">前の例では、JavaScriptモジュールは単一のパッケージをエクスポートします。ただし、一部のJavaScriptライブラリは、モジュール内から複数のパッケージをエクスポートします。このケースはKotlinでもサポートされていますが、インポートするパッケージごとに新しい &lt;code&gt;.kt&lt;/code&gt; ファイルを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="42d1f7acaeec00a73953ae801ded4c35e710f59f" translate="yes" xml:space="preserve">
          <source>In the tutorial we will learn:</source>
          <target state="translated">チュートリアルでは、私たちは学びます。</target>
        </trans-unit>
        <trans-unit id="5c983473a452d20ce90bb4b7f97f64c188d78e2f" translate="yes" xml:space="preserve">
          <source>In the tutorial we:</source>
          <target state="translated">チュートリアルでは、私たち。</target>
        </trans-unit>
        <trans-unit id="095e7f10496f59e9c1f965ea0b808ca458b5529c" translate="yes" xml:space="preserve">
          <source>In this case the compiler will not be downloaded by the plugin.</source>
          <target state="translated">この場合、コンパイラはプラグインからダウンロードされません。</target>
        </trans-unit>
        <trans-unit id="f1f881dff617021acda0968035a0c51bb38a1c2d" translate="yes" xml:space="preserve">
          <source>In this case, JQuery will be imported as a module named &lt;code&gt;jquery&lt;/code&gt;. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</source>
          <target state="translated">この場合、JQueryは &lt;code&gt;jquery&lt;/code&gt; という名前のモジュールとしてインポートされます。または、Kotlinコンパイラーが使用するように構成されているモジュールシステムに応じて、$オブジェクトとして使用できます。</target>
        </trans-unit>
        <trans-unit id="c032e19443eb1eff2c0c1528c6eb2e5d72dfce23" translate="yes" xml:space="preserve">
          <source>In this case, we've set the output of our compilation to the &lt;code&gt;scripts&lt;/code&gt; folder. On running the application we should see the following output:</source>
          <target state="translated">この例では、コンパイルの出力を &lt;code&gt;scripts&lt;/code&gt; フォルダーに設定しています。アプリケーションを実行すると、次の出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="de0ac72463e7c41b8825d92484726f740a2112b2" translate="yes" xml:space="preserve">
          <source>In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; that allow to express &lt;a href=&quot;../reference/idioms&quot;&gt;idioms&lt;/a&gt; like &quot;take the value if it is positive or else use length&quot; with a concise and readable expressions like &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt;, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</source>
          <target state="translated">この密なコードでは、コレクションの変換に加えて、あなたは、このような便利なKotlinは地元の機能として備えており、見ることができる&lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;演算子をELVIS &lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 表現することを可能にするという&lt;a href=&quot;../reference/idioms&quot;&gt;イディオム&lt;/a&gt;簡潔で、「それは、正または他の使用の長さがある場合は、値を取る」などを &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt; ような読み取り可能な式ですが、追加の可変変数を作成して同じコードを命令型スタイルで表現することも、Kotlinでは完全に問題ありません。</target>
        </trans-unit>
        <trans-unit id="e691bb86d414ab1eeeac0ce8d8cf107c13b24d6b" translate="yes" xml:space="preserve">
          <source>In this doc, we'll sometimes specify the type unnecessarily, in order to highlight what type is produced by an expression. (Also, a good IDE will be able to show you the resulting type.)</source>
          <target state="translated">このドキュメントでは、式によってどのような型が生成されるかを強調するために、不必要に型を指定することがあります。(また、優れたIDEであれば、結果の型を表示することができます)。</target>
        </trans-unit>
        <trans-unit id="7d12593ba02967f080622029b34989f6d346aaf9" translate="yes" xml:space="preserve">
          <source>In this document we introduce several kinds of compatibility:</source>
          <target state="translated">このドキュメントでは、いくつかの種類の互換性を紹介します。</target>
        </trans-unit>
        <trans-unit id="537f8c16fc8f03cc135b33707b31eb29f9995ea0" translate="yes" xml:space="preserve">
          <source>In this example only members of the nearest implicit receiver &lt;code&gt;this@head&lt;/code&gt; must be available; &lt;code&gt;head()&lt;/code&gt; is a member of the outer receiver &lt;code&gt;this@html&lt;/code&gt;, so it must be illegal to call it.</source>
          <target state="translated">この例では、最も近い暗黙のレシーバの &lt;code&gt;this@head&lt;/code&gt; メンバーのみが使用可能でなければなりません。 &lt;code&gt;head()&lt;/code&gt; は、外側のレシーバ &lt;code&gt;this@html&lt;/code&gt; メンバーなので、呼び出すことは違法でなければなりません。</target>
        </trans-unit>
        <trans-unit id="67582c167007a9ba92244086b3d65c9a9e9700f4" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter on what thread the coroutine is executed. Thus, output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;を使用してバックグラウンドスレッドプールで新しいコルーチンを起動します。これにより、スレッドコルーチンはスレッドプールとは異なるスレッドで機能しますが、 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; を使用して指定したスレッドローカル変数の値がまだあります。 （値= &quot;launch&quot;）、コルーチンが実行されるスレッドに関係なく。したがって、（&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debugを使用した&lt;/a&gt;）出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="872d3ddd1be8b8c4ec3ab8cc792f3b5cde57d822" translate="yes" xml:space="preserve">
          <source>In this example, all values passed to the C API &lt;code&gt;new_menu()&lt;/code&gt; have a lifetime of the innermost &lt;code&gt;memScope&lt;/code&gt; it belongs to. Once the control flow leaves the &lt;code&gt;memScoped&lt;/code&gt; scope the C pointers become invalid.</source>
          <target state="translated">この例では、C API &lt;code&gt;new_menu()&lt;/code&gt; に渡されるすべての値は、それが属する最も内側の &lt;code&gt;memScope&lt;/code&gt; の有効期間を持っています。制御フローが &lt;code&gt;memScoped&lt;/code&gt; スコープを離れると、Cポインターは無効になります。</target>
        </trans-unit>
        <trans-unit id="5b70f0a7dd260f72c7acee91c3f5762c472a459a" translate="yes" xml:space="preserve">
          <source>In this example, the constructor takes a map:</source>
          <target state="translated">この例では、コンストラクタはマップを受け取ります。</target>
        </trans-unit>
        <trans-unit id="06698ce38b883fc740d14dcc830fa9e382960eb5" translate="yes" xml:space="preserve">
          <source>In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists.</source>
          <target state="translated">この例では、リストで同様の処理を行う場合の23ステップの代わりに、18ステップのシーケンス処理を行う。</target>
        </trans-unit>
        <trans-unit id="550b3c67b81cc4d4252fe83306649fc1df1e86da" translate="yes" xml:space="preserve">
          <source>In this example, using &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; from the previous section, we locate a member function reference by name and call it:</source>
          <target state="translated">この例では、前のセクションの &lt;code&gt;Person&lt;/code&gt; および &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; を使用して、メンバー関数参照を名前で見つけて呼び出します。</target>
        </trans-unit>
        <trans-unit id="25017fcbb3e37d1b9106fc29788136cb1c456365" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where suspension function is run or asynchronously later in the same thread or from a different thread of execution. Repeated invocation of any resume function produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">この関数では、&lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt;と&lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithExceptionの&lt;/a&gt;両方を、一時停止関数が実行される同じスタックフレームで同期的に使用することも、後で同じスレッドでまたは非同期に別の実行スレッドから使​​用することもできます。再開機能を繰り返し呼び出すと、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateExceptionが発生し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a802dce08d5c39703b387f16a864974235e44de0" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">この関数では、&lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt;と&lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithExceptionの&lt;/a&gt;両方を、suspend関数が実行される同じスタックフレームで同期的に使用することも、同じスレッドで後で非同期に、または別の実行スレッドから使​​用することもできます。その後に再開機能を呼び出すと、&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="677125a2bada551194ff25d8eec9f1b62a3c4ba4" translate="yes" xml:space="preserve">
          <source>In this section a commented DSL is shown. See also the example projects that use this plugin, e.g. &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;, &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http client&lt;/a&gt;</source>
          <target state="translated">このセクションでは、コメント付きのDSLが表示されます。このプラグインを使用するサンプルプロジェクトもご覧ください。例：&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;、&lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP httpクライアント&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d0e31509240af7f0d899e0847fb308f3f6c3d9" translate="yes" xml:space="preserve">
          <source>In this tutorial We will learn how to:</source>
          <target state="translated">このチュートリアルでは、以下の方法を学びます。</target>
        </trans-unit>
        <trans-unit id="b8d78e48aa113b25ef679f219669ead0543c6d9d" translate="yes" xml:space="preserve">
          <source>In this tutorial however, we'll see how to use some specific libraries, such as &lt;code&gt;libcurl&lt;/code&gt;. We'll learn to</source>
          <target state="translated">ただし、このチュートリアルでは、 &lt;code&gt;libcurl&lt;/code&gt; などの特定のライブラリの使用方法について説明します。私たちは学びます</target>
        </trans-unit>
        <trans-unit id="38ae904b992e64be7d6f1c95db212a698e90d2ef" translate="yes" xml:space="preserve">
          <source>In this tutorial we have:</source>
          <target state="translated">このチュートリアルでは</target>
        </trans-unit>
        <trans-unit id="814c4fd32a87a880ed24663823d0826f5fba0218" translate="yes" xml:space="preserve">
          <source>In this tutorial we see how to deal with C strings in Kotlin/Native. We will learn how to:</source>
          <target state="translated">このチュートリアルでは、Kotlin/NativeでC言語の文字列を扱う方法を見ていきます。その方法を学んでいきます。</target>
        </trans-unit>
        <trans-unit id="f187570814c6d6abda5a2c00ead30d73ef74a12e" translate="yes" xml:space="preserve">
          <source>In this tutorial we will create an iOS and Android application, by making use of Kotlin's code sharing features. For Android we'll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</source>
          <target state="translated">このチュートリアルでは、Kotlinのコード共有機能を利用して、iOSとAndroidのアプリケーションを作成します。AndroidではKotlin/JVMを使用し、iOSではKotlin/Nativeを使用します。</target>
        </trans-unit>
        <trans-unit id="e75dd7cce5c41f63288c1748bd5bfd1c78d1ff1b" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll see how to</source>
          <target state="translated">このチュートリアルでは</target>
        </trans-unit>
        <trans-unit id="73192ff47f695a8d1b74a36ad93cdb6ae37eb2de" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required to use the Kotlin Android Extensions plugin, enhancing the experience of Android development.</source>
          <target state="translated">このチュートリアルでは、Kotlin Android Extensionsプラグインを使用するために必要な手順を説明します。</target>
        </trans-unit>
        <trans-unit id="f0e340bf119483d38d43d3af161837206adf260c" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required. For a more thorough explanation of Spring Boot and Kotlin, please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルでは、必要な手順について説明します。Spring BootとKotlinの詳細については&lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;、Spring BootとKotlinを使用したウェブアプリケーションの構築&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="04ead99e3026a0a00111c1c9a4f51b0c3c739752" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll:</source>
          <target state="translated">このチュートリアルでは</target>
        </trans-unit>
        <trans-unit id="0f464678d81fef87702589d2f00f58596a930600" translate="yes" xml:space="preserve">
          <source>In this tutorial we're going to use IntelliJ IDEA. For instructions on how to compile and execute Kotlin applications using the command line compiler, see &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルでは、IntelliJ IDEAを使用します。コマンドラインコンパイラを使用してKotlinアプリケーションをコンパイルして実行する方法については、参照&lt;a href=&quot;command-line&quot;&gt;コマンドラインコンパイラを使用した作業を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d5b9a27b34d95239a0c33821d0a9b033c40bd3" translate="yes" xml:space="preserve">
          <source>In this tutorial we've seen how to create a Kotlin application that targets JavaScript, debug it as well as set compiler options. In other tutorials we'll cover more in-depth topics such as interacting with the DOM, etc.</source>
          <target state="translated">このチュートリアルでは、JavaScriptをターゲットにしたKotlinアプリケーションの作成方法、デバッグ方法、コンパイラオプションの設定方法を見てきました。他のチュートリアルでは、DOM との対話など、より深いトピックを取り上げていきます。</target>
        </trans-unit>
        <trans-unit id="15ab8dc4bd9f08f596ae63880b3958cb4434a6d7" translate="yes" xml:space="preserve">
          <source>In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will:</source>
          <target state="translated">このチュートリアルでは、Kotlin/Native ではどのような C 言語のデータ型が表示されるのか、またその逆の場合はどのようなデータ型が表示されるのかを学びます。このチュートリアルでは、以下のことを学びます。</target>
        </trans-unit>
        <trans-unit id="8a05d2cdb1fd77bc1ee6b2a0bfc489f7b20f51b2" translate="yes" xml:space="preserve">
          <source>In this tutorial, we look at how we can use the Kotlin/Native code from existing native applications or libraries. For this, we need to compile our Kotlin code into a dynamic library, &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, and &lt;code&gt;.dll&lt;/code&gt;.</source>
          <target state="translated">このチュートリアルでは、既存のネイティブアプリケーションまたはライブラリからKotlin / Nativeコードを使用する方法について説明します。そのためには、Kotlinコードを動的ライブラリ &lt;code&gt;.so&lt;/code&gt; 、 &lt;code&gt;.dylib&lt;/code&gt; 、および &lt;code&gt;.dll&lt;/code&gt; にコンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="701903e9f376cd1d8503774a4d299554e97196a0" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native. You will learn step-by-step how to create a multiplatform library which can be used from any other common code (e.g., one shared with Android and iOS), and how to write tests which will be executed on all platforms and use an efficient implementation provided by the concrete platform.</source>
          <target state="translated">このチュートリアルでは、JVM、JS、Native の世界から利用可能な小さなライブラリを構築します。他のどのような共通コード(例えば、AndroidやiOSと共有されているもの)からでも利用できるマルチプラットフォームライブラリを作成する方法や、すべてのプラットフォームで実行され、具体的なプラットフォームが提供する効率的な実装を利用するテストの書き方をステップバイステップで学びます。</target>
        </trans-unit>
        <trans-unit id="8459da0cf638e813dae1e5c0fa95e9568c3582bd" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will look at how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS. We will build a framework from Kotlin code.</source>
          <target state="translated">このチュートリアルでは、Objective-CやSwiftアプリのKotlin/NativeコードをmacOSやiOSで利用する方法を見ていきます。Kotlinのコードからフレームワークを構築していきます。</target>
        </trans-unit>
        <trans-unit id="864dde628feba0ddb56fa697c290d183bee8b077" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will:</source>
          <target state="translated">このチュートリアルでは、次のことを行います。</target>
        </trans-unit>
        <trans-unit id="98c10d04454a966f67cb1dfe790300722810cd2d" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll look at how to</source>
          <target state="translated">このチュートリアルでは、以下の方法を見ていきます。</target>
        </trans-unit>
        <trans-unit id="0c3ebd5f96036d4c23f2a9d6d5dd9911faa69aff" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">このチュートリアルでは、Gradleを使用しますが、IntelliJ IDEAプロジェクト構造またはMavenを使用しても同じことができます。Kotlinで動作するようにGradleを設定する方法の詳細については、「&lt;a href=&quot;../reference/using-gradle&quot;&gt;Gradleの使用&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="aa1a5fa948935055fc078b1993ec8baed9df514c" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;. The main dependency required for using HTTP servlets is the JavaEE API:</source>
          <target state="translated">このチュートリアルでは、Gradleを使用しますが、IntelliJ IDEAプロジェクト構造またはMavenを使用しても同じことができます。Kotlinで動作するようにGradleを設定する方法の詳細については、「&lt;a href=&quot;../reference/using-gradle&quot;&gt;Gradleの使用&lt;/a&gt;」を参照してください。HTTPサーブレットを使用するために必要な主な依存関係は、JavaEE APIです。</target>
        </trans-unit>
        <trans-unit id="23e1b785f9b5814cd84a43b0c10801c0740b41ac" translate="yes" xml:space="preserve">
          <source>In turn, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name &lt;code&gt;it&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is shorter than &lt;code&gt;this&lt;/code&gt; and expressions with &lt;code&gt;it&lt;/code&gt; are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like &lt;code&gt;this&lt;/code&gt;. Hence, having the context object as &lt;code&gt;it&lt;/code&gt; is better when the object is mostly used as an argument in function calls. &lt;code&gt;it&lt;/code&gt; is also better if you use multiple variables in the code block.</source>
          <target state="translated">ターンでは、 &lt;code&gt;let&lt;/code&gt; と &lt;code&gt;also&lt;/code&gt; ラムダ引数としてコンテキストオブジェクトを持っています。引数名が指定されていない場合、オブジェクトは暗黙のデフォルト名 &lt;code&gt;it&lt;/code&gt; でアクセスされます。 &lt;code&gt;it&lt;/code&gt; は &lt;code&gt;this&lt;/code&gt; より短く、通常、 &lt;code&gt;it&lt;/code&gt; を含む式は読みやすくなります。ただし、オブジェクトの関数またはプロパティを呼び出す場合、 &lt;code&gt;this&lt;/code&gt; ように暗黙的に使用できるオブジェクトはありません。したがって、コンテキストオブジェクトを有するように &lt;code&gt;it&lt;/code&gt; オブジェクトが主に関数呼び出しに引数として使用する場合より良好です。 &lt;code&gt;it&lt;/code&gt; あなたがコードブロックに複数の変数を使用している場合にも優れています。</target>
        </trans-unit>
        <trans-unit id="812b574e96ace8dd4cdbeccd6ad6e3f2e4f0aabb" translate="yes" xml:space="preserve">
          <source>In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; was a subtype of &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt;, you could insert other &lt;code&gt;Shape&lt;/code&gt; inheritors (for example, &lt;code&gt;Circle&lt;/code&gt;) into it, thus violating its &lt;code&gt;Rectangle&lt;/code&gt; type argument.</source>
          <target state="translated">一方、変更可能なコレクションは共変ではありません。そうしないと、ランタイムエラーが発生します。場合 &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; のサブタイプだった &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; 、あなたは他の挿入可能性 &lt;code&gt;Shape&lt;/code&gt; （例えば、相続を &lt;code&gt;Circle&lt;/code&gt; したがって、その違反し、その中に） &lt;code&gt;Rectangle&lt;/code&gt; 型引数を。</target>
        </trans-unit>
        <trans-unit id="2a50d6665033bbbaf15909f2a8b12edea9bb1926" translate="yes" xml:space="preserve">
          <source>In turn, set is not an ordered collection by &lt;a href=&quot;collections-overview&quot;&gt;definition&lt;/a&gt;. However, the Kotlin &lt;code&gt;Set&lt;/code&gt; stores elements in certain orders. These can be the order of insertion (in &lt;code&gt;LinkedHashSet&lt;/code&gt;), natural sorting order (in &lt;code&gt;SortedSet&lt;/code&gt;), or another order. The order of a set of elements can also be unknown. In such cases, the elements are still ordered somehow, so the functions that rely on the element positions still return their results. However, such results are unpredictable to the caller unless they know the specific implementation of &lt;code&gt;Set&lt;/code&gt; used.</source>
          <target state="translated">同様に、セットは&lt;a href=&quot;collections-overview&quot;&gt;定義&lt;/a&gt;により順序付けられたコレクションではありません。ただし、Kotlin &lt;code&gt;Set&lt;/code&gt; は特定の順序で要素を格納します。これらは、挿入の順序（ &lt;code&gt;LinkedHashSet&lt;/code&gt; 内）、自然なソート順（ &lt;code&gt;SortedSet&lt;/code&gt; 内）、または別の順序にすることができます。要素のセットの順序も不明な場合があります。そのような場合でも、要素はなんらかの方法で順序付けられているため、要素の位置に依存する関数は結果を返します。ただし、このような結果は、使用される &lt;code&gt;Set&lt;/code&gt; の特定の実装を知らない限り、呼び出し元には予測できません。</target>
        </trans-unit>
        <trans-unit id="01b654ef30cda18991ddded390d4b967ccf9e9a4" translate="yes" xml:space="preserve">
          <source>In your scratch, you can write any valid Kotlin code, including new functions and classes. Syntax highlighting, auto-completion, and other code editing features of IntelliJ IDEA are supported in scratches.</source>
          <target state="translated">スクラッチでは、新しい関数やクラスを含む有効なKotlinコードを書くことができます。スクラッチでは、IntelliJ IDEAのシンタックスハイライト、自動補完、その他のコード編集機能がサポートされています。</target>
        </trans-unit>
        <trans-unit id="f2699078d9287cbd90f76ee50448a4fec028de87" translate="yes" xml:space="preserve">
          <source>Including static library in your klib</source>
          <target state="translated">klibにスタティックライブラリを含める</target>
        </trans-unit>
        <trans-unit id="84996d5891b1f1a645c33eb5c3b22433a18e3eec" translate="yes" xml:space="preserve">
          <source>Incompatible Changes</source>
          <target state="translated">互換性のない変更</target>
        </trans-unit>
        <trans-unit id="8d41722fdaa1b8acfa42d80a00302ec1d80e560e" translate="yes" xml:space="preserve">
          <source>IncorrectDereferenceException</source>
          <target state="translated">IncorrectDereferenceException</target>
        </trans-unit>
        <trans-unit id="7c15aa041f9a78e640a95e3034dce236ee5d488b" translate="yes" xml:space="preserve">
          <source>Incremental Compilation</source>
          <target state="translated">インクリメンタルコンパイル</target>
        </trans-unit>
        <trans-unit id="1d25e364e8dc05079a68a8ada56d8fbeda70bc16" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing (since 1.3.30)</source>
          <target state="translated">増分アノテーション処理(1.3.30以降</target>
        </trans-unit>
        <trans-unit id="b1262b9eb921db266028505964086f28ad7e7f94" translate="yes" xml:space="preserve">
          <source>Incremental compilation</source>
          <target state="translated">インクリメンタルコンパイル</target>
        </trans-unit>
        <trans-unit id="33b5061796594b36b41f624484bcfb3853bb6d0c" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects. It's enabled by default since Kotlin 1.1.1 for Kotlin/JVM and 1.3.20 for Kotlin/JS.</source>
          <target state="translated">インクリメンタルコンパイルはKotlin/JVMとKotlin/JSプロジェクトでサポートされています。Kotlin/JVMではKotlin 1.1.1、Kotlin/JSでは1.3.20からデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="d6dbea2b53708e66e73d3f1a6a99defec97fa2a9" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Experimental features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">インクリメンタルリリースでは、ツールの更新 (多くの場合、機能を含む)、パフォーマンスの向上、バグの修正が行われます。このようなバージョンはお互いに互換性を保つようにしていますので、コンパイラの変更はほとんどが最適化と警告の追加/削除です。もちろん、実験的な機能はいつでも追加、削除、変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="9c0b336ea67b1169e696bcad497094e1948f51aa" translate="yes" xml:space="preserve">
          <source>Increments and decrements</source>
          <target state="translated">インクリメントとデクリメント</target>
        </trans-unit>
        <trans-unit id="51065cc396f6ec67a2538e872f538ab2d9ab75c9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;デルタ&lt;/a&gt;によって値を増分し、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="44233843d94836d1fccccf70b3b2b867d9acc067" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;デルタ&lt;/a&gt;によって値を増分し、新しい値を返します。</target>
        </trans-unit>
        <trans-unit id="28411949be3415589036a91826011ccfec40fbd4" translate="yes" xml:space="preserve">
          <source>Increments this value.</source>
          <target state="translated">この値を増加させます。</target>
        </trans-unit>
        <trans-unit id="b8fcfd847cda35bcb6945261dd3c4eb8f88f412a" translate="yes" xml:space="preserve">
          <source>Increments value by one.</source>
          <target state="translated">値を1つインクリメントします。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="83f705f84f3e506a637956b9907406ba6fe9f41e" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException</source>
          <target state="translated">IndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="4a12f879063aea0813ebab8015ddf21b727cd7af" translate="yes" xml:space="preserve">
          <source>Indexed access operator</source>
          <target state="translated">インデックス化されたアクセス演算子</target>
        </trans-unit>
        <trans-unit id="d4e1cf8d774b0c0bb9b5921ec7fa833544082d60" translate="yes" xml:space="preserve">
          <source>IndexedValue</source>
          <target state="translated">IndexedValue</target>
        </trans-unit>
        <trans-unit id="4ad24986a96806bcf716cdb15281ed398b1a31f5" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements:</source>
          <target state="translated">他のオブジェクトがこのオブジェクトと「等しい」かどうかを示す。実装は以下の要件を満たさなければならない。</target>
        </trans-unit>
        <trans-unit id="53f09d01b93a3110068a373094e1fb376a10c3c8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">正規表現が指定された&lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;入力&lt;/a&gt;で少なくとも1つの一致を見つけることができるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="cc670204f79af50c97c85084d6a41b77270ab6a4" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">正規表現が&lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;入力&lt;/a&gt;全体と一致するかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="767a32bb6d83112e90455e54a6dd8a16300ca86c" translate="yes" xml:space="preserve">
          <source>Infix calls for named functions</source>
          <target state="translated">名前付き関数のインフィックス呼び出し</target>
        </trans-unit>
        <trans-unit id="1cea4b28540c3fbdd2e2436ba68910be38a3f387" translate="yes" xml:space="preserve">
          <source>Infix function calls have lower precedence than the arithmetic operators, type casts, and the &lt;code&gt;rangeTo&lt;/code&gt; operator. The following expressions are equivalent:</source>
          <target state="translated">Infix関数呼び出しは、算術演算子、型キャスト、および &lt;code&gt;rangeTo&lt;/code&gt; 演算子よりも優先順位が低くなります。次の式は同等です。</target>
        </trans-unit>
        <trans-unit id="c345bbff4a1e1fc76b2e4ede7fbe52f5de947e6b" translate="yes" xml:space="preserve">
          <source>Infix functions</source>
          <target state="translated">インフィックス機能</target>
        </trans-unit>
        <trans-unit id="19c6abcd2f2f19793afb1f4565bae99cd5d50667" translate="yes" xml:space="preserve">
          <source>Infix notation</source>
          <target state="translated">インフィックス表記法</target>
        </trans-unit>
        <trans-unit id="c5a135f955f6a2349a2d4263f326ff3a2a3304ed" translate="yes" xml:space="preserve">
          <source>Information from explicit casts is used for type inference</source>
          <target state="translated">明示的なキャストからの情報は型推論に利用されます。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fc3ff49d31fe091e3831cd8bc1f2e6d38992276d" translate="yes" xml:space="preserve">
          <source>Inheritance from Java classes</source>
          <target state="translated">Javaクラスからの継承</target>
        </trans-unit>
        <trans-unit id="060c830dba717926ce4d26ef9693decc297e0680" translate="yes" xml:space="preserve">
          <source>Inheritance that leads to a &lt;code&gt;copy&lt;/code&gt; conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 競合につながる継承は、Kotlin 1.2では警告とともに廃止され、Kotlin 1.3ではエラーになります。</target>
        </trans-unit>
        <trans-unit id="fe8f308745a21bdbf9c67ae8f86198813253366c" translate="yes" xml:space="preserve">
          <source>Inherited Functions</source>
          <target state="translated">継承機能</target>
        </trans-unit>
        <trans-unit id="a97b2d009dc11ee2399b0468fc72e941eebbf165" translate="yes" xml:space="preserve">
          <source>Inherited Properties</source>
          <target state="translated">継承されたプロパティ</target>
        </trans-unit>
        <trans-unit id="f54b5bc69098e64d7fae998cd4e9df2d4fa8e7af" translate="yes" xml:space="preserve">
          <source>Inherited built-in functions</source>
          <target state="translated">継承された組み込み機能</target>
        </trans-unit>
        <trans-unit id="af6ed82fe139bda1a895add0ffee5c78ca3dcf12" translate="yes" xml:space="preserve">
          <source>Inheritors</source>
          <target state="translated">Inheritors</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="100b184b34b9bc80bfe5761ad8aa4a5db3c27036" translate="yes" xml:space="preserve">
          <source>Initialized with a value of type &lt;code&gt;String&lt;/code&gt; or a primitive type</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 型またはプリミティブ型の値で初期化されました</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cddbd43ce85bc15d27c1f2848a884d7030458b88" translate="yes" xml:space="preserve">
          <source>Initializer function can be called several times on concurrent access to uninitialized &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value, but only the first returned value will be used as the value of &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">初期化関数は、初期化されていないへの同時アクセスに複数回呼び出すことができます&lt;a href=&quot;../-lazy/index&quot;&gt;怠惰な&lt;/a&gt;インスタンス値が、唯一の最初の戻り値は、の値として使用されます&lt;a href=&quot;../-lazy/index&quot;&gt;レイジー&lt;/a&gt;インスタンス。</target>
        </trans-unit>
        <trans-unit id="8de9a4ea59b21de32db609afcfc607895faed0de" translate="yes" xml:space="preserve">
          <source>Initializer functions for lists</source>
          <target state="translated">リストの初期化関数</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="96e412fcc42808e35495dbc64ebcde5c69c261de" translate="yes" xml:space="preserve">
          <source>Initializes Kotlin runtime for the current thread, if not inited already.</source>
          <target state="translated">まだ起動していない場合は、現在のスレッドの Kotlin ランタイムを初期化します。</target>
        </trans-unit>
        <trans-unit id="be787dbbf62b5076f4a13439769f15509c2967ea" translate="yes" xml:space="preserve">
          <source>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but &lt;code&gt;noinline&lt;/code&gt; ones can be manipulated in any way we like: stored in fields, passed around etc.</source>
          <target state="translated">INLINABLEラムダは、インライン関数内と呼ばれるかINLINABLE引数として渡すことができるが &lt;code&gt;noinline&lt;/code&gt; ものは、私たちのような任意の方法で操作することができます。周りに渡され、フィールドに保存されているなど</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">インライン関数</target>
        </trans-unit>
        <trans-unit id="77dc1cce985d17f15f3bb54896d9ab82a2428c34" translate="yes" xml:space="preserve">
          <source>Inline JavaScript</source>
          <target state="translated">インライン JavaScript</target>
        </trans-unit>
        <trans-unit id="62d048ab15fe71589a192aa32dfde8cfed8f778a" translate="yes" xml:space="preserve">
          <source>Inline Markup</source>
          <target state="translated">インラインマークアップ</target>
        </trans-unit>
        <trans-unit id="5d360c4149ca0224f961067c92c26613a7104175" translate="yes" xml:space="preserve">
          <source>Inline classes</source>
          <target state="translated">インラインクラス</target>
        </trans-unit>
        <trans-unit id="9286e6770b0362425ca42b0e3ebc568ac630fc5b" translate="yes" xml:space="preserve">
          <source>Inline classes are allowed to inherit from interfaces:</source>
          <target state="translated">インラインクラスはインターフェイスを継承することができます。</target>
        </trans-unit>
        <trans-unit id="4c5881ab063c0ce817cf6f52ab599309c2d3110f" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">インラインクラスはKotlin 1.3以降でのみ利用可能で、現在&lt;em&gt;実験&lt;/em&gt;段階です。&lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;以下の&lt;/a&gt;詳細をご覧ください</target>
        </trans-unit>
        <trans-unit id="f253e2ca96472e7c3372c8639328c1d3867dc3b6" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">インラインクラスはKotlin 1.3以降でのみ利用可能で、現在&lt;em&gt;実験&lt;/em&gt;段階です。詳細は&lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;リファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="a7a2cb12c8331fe8180ea13004fae9e89ef3e1fd" translate="yes" xml:space="preserve">
          <source>Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:</source>
          <target state="translated">インライン・クラスは、通常のクラスのいくつかの機能をサポートしています。特に、プロパティや関数を宣言することができます。</target>
        </trans-unit>
        <trans-unit id="6c7769b31582b2d304756a0e1ee20904b47b72a0" translate="yes" xml:space="preserve">
          <source>Inline classes vs type aliases</source>
          <target state="translated">インラインクラスと型のエイリアス</target>
        </trans-unit>
        <trans-unit id="126b7ff7e58c488c8dbbe2c35dcf311f885d0926" translate="yes" xml:space="preserve">
          <source>Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</source>
          <target state="translated">プラットフォーム型のNULL値で呼び出されたインライン拡張関数は、レシーバーがNULLであるかどうかをチェックしないため、NULLが他のコードに逃げてしまうことがありました。Kotlin 1.2 では、コールサイトでこのチェックを強制的に行い、レシーバーが null の場合は例外をスローします。</target>
        </trans-unit>
        <trans-unit id="5c804513cadec43c33b180af13b2e9aec456a962" translate="yes" xml:space="preserve">
          <source>Inline functions</source>
          <target state="translated">インライン関数</target>
        </trans-unit>
        <trans-unit id="9d0d1200e09d5fde96bd026c2e6ca0b2d04d5ad5" translate="yes" xml:space="preserve">
          <source>Inline functions are explained &lt;a href=&quot;inline-functions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;inline-functions&quot;&gt;ここで&lt;/a&gt;はインライン関数について説明します。</target>
        </trans-unit>
        <trans-unit id="aa8db13612a09f046bbacee8122bb577b38d70fa" translate="yes" xml:space="preserve">
          <source>Inline functions are now allowed to have default values for their inlined functional parameters:</source>
          <target state="translated">インライン関数は、そのインライン関数のパラメータにデフォルト値を持つことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="d6c978967701dd3225fcc54de37cf91805dd0b8d" translate="yes" xml:space="preserve">
          <source>Inline functions with &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; have their actual type arguments inlined at each call site, which enables &lt;code&gt;arg is T&lt;/code&gt; checks for the type parameters, but if &lt;code&gt;arg&lt;/code&gt; is an instance of a generic type itself, &lt;em&gt;its&lt;/em&gt; type arguments are still erased. Example:</source>
          <target state="translated">&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;型パラメーター&lt;/a&gt;を具体化したインライン関数は、実際の型引数が各呼び出しサイトでインライン化されます。これにより、 &lt;code&gt;arg is T&lt;/code&gt; が型パラメーターをチェックできるようになりますが、 &lt;code&gt;arg&lt;/code&gt; がジェネリック型自体のインスタンスである場合&lt;em&gt;、&lt;/em&gt;型引数は消去されます。例：</target>
        </trans-unit>
        <trans-unit id="dad40d691cb152e5ea04161c10815db00953ebbb" translate="yes" xml:space="preserve">
          <source>Inline functions with default functional parameters</source>
          <target state="translated">デフォルトの機能パラメータを持つインライン関数</target>
        </trans-unit>
        <trans-unit id="e60dd1451a60d33b2eca72439470d0150cb5cb84" translate="yes" xml:space="preserve">
          <source>Inline properties (since 1.1)</source>
          <target state="translated">インラインプロパティ(1.1以降</target>
        </trans-unit>
        <trans-unit id="6fec8c0d06ca4be7ff0c4bc9fa753ee420aa8bbc" translate="yes" xml:space="preserve">
          <source>Inline property accessors</source>
          <target state="translated">インラインプロパティアクセサ</target>
        </trans-unit>
        <trans-unit id="01185d7fc605bc19fbe95771073571a841e3e817" translate="yes" xml:space="preserve">
          <source>Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at &quot;megamorphic&quot; call-sites inside loops.</source>
          <target state="translated">インライン化は生成されたコードを大きくする原因になるかもしれませんが、合理的な方法で行えば(大きな関数のインライン化を避けるなど)、特にループ内の「メガモルフィック」なコールサイトでは、パフォーマンスの面で報われます。</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">インナークラス</target>
        </trans-unit>
        <trans-unit id="bc3fa717af37b9f1e13149ace0b8f86497367e3c" translate="yes" xml:space="preserve">
          <source>Inner classes inheriting &lt;code&gt;Throwable&lt;/code&gt; that capture generic parameters from the outer class</source>
          <target state="translated">外部クラスからジェネリックパラメーターをキャプチャする &lt;code&gt;Throwable&lt;/code&gt; を継承する内部クラス</target>
        </trans-unit>
        <trans-unit id="258becf2f7c7396759bd76072890548fa224b9a4" translate="yes" xml:space="preserve">
          <source>Inner classes of generic types that inherit from &lt;code&gt;Throwable&lt;/code&gt; could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;Throwable&lt;/code&gt; から継承するジェネリック型の内部クラスは、throw-catchシナリオの型安全性に違反する可能性があるため、Kotlin 1.2の警告とKotlin 1.3のエラーで非推奨になりました。</target>
        </trans-unit>
        <trans-unit id="b14a7c09e5913aa9efafcb8d3f6e59361da51506" translate="yes" xml:space="preserve">
          <source>InputEventInit</source>
          <target state="translated">InputEventInit</target>
        </trans-unit>
        <trans-unit id="081e0fb72f26260fc891fc2cb6cbf71cf9e0d97f" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定したコレクション&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;要素の&lt;/a&gt;すべての要素を、このリストの指定した&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="887d8e7112f2b5499df8e54becfa68d97d70bd00" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">指定したコレクション&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;要素の&lt;/a&gt;すべての要素を、このリストの指定した&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="d0c7a2de4f7654463ee73faa30f98d50a3b73e7e" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">リストの指定された&lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="f6b6ae35f6d9d56e894884fb222d27eda900dc09" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">リストの指定された&lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="6c1226de8bd8dc851fb3874b9c31e306f3fa56c5" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">リストの指定された&lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;インデックスに&lt;/a&gt;要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">クラス内では、別のクラスの拡張を宣言できます。そのような拡張機能の内部には、複数の&lt;em&gt;暗黙的なレシーバー&lt;/em&gt;があり、そのメンバーには修飾子なしでアクセスできます。拡張が宣言されているクラスのインスタンスは&lt;em&gt;ディスパッチレシーバ&lt;/em&gt;と呼ば&lt;em&gt;れ&lt;/em&gt;、拡張メソッドのレシーバタイプのインスタンスは&lt;em&gt;拡張レシーバ&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">関数内では、タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;vararg&lt;/code&gt; パラメータは &lt;code&gt;T&lt;/code&gt; の配列として表示されます。つまり、上記の例の &lt;code&gt;ts&lt;/code&gt; 変数はタイプ &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; 持っています。</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">レシーバー付きのラムダ式の内部では、 &lt;code&gt;this&lt;/code&gt; を使用してレシーバーオブジェクト（この場合は &lt;code&gt;car&lt;/code&gt; ）を参照できます。いつものように、名前の競合がない場合は &lt;code&gt;this&lt;/code&gt; を省略できます。そのため、 &lt;code&gt;${this.horsepowers}&lt;/code&gt; 代わりに$ &lt;code&gt;$horsepowers&lt;/code&gt; とだけ言うことができます。 Kotlinでは、 &lt;code&gt;this&lt;/code&gt; はコンテキストに応じて異なる意味を持つ可能性があることに注意してください。レシーバーを持つ（ネストされている可能性がある）ラムダ式の内部で使用される場合、レシーバーを持つ最も内側の外側のラムダ式のレシーバーオブジェクトを参照します。関数リテラルを「抜け出し」、「元の」 &lt;code&gt;this&lt;/code&gt; を取得する必要がある場合（内部にいるメンバー関数が実行されているインスタンス）、 &lt;code&gt;this@&lt;/code&gt; を含むクラス名をthis @の後に記述します。したがって、Carのメンバー関数内にレシーバーがある関数リテラル内にいる場合は、 &lt;code&gt;this@Car&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">内部クラス内では、外部クラスのスーパークラスへのアクセスは、外部クラス名で修飾された&lt;em&gt;super&lt;/em&gt;キーワードで行われます： &lt;code&gt;super@Outer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">列挙型エントリ内で、 &lt;code&gt;inner class&lt;/code&gt; ではないネストされた型を定義することは、初期化ロジックの問題により廃止されました。これにより、Kotlin 1.2では警告が発生し、Kotlin 1.3ではエラーになります。</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; ブロック内では、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;maybeNull&lt;/code&gt; を参照します。 &lt;code&gt;memberPropertyA&lt;/code&gt; 、 &lt;code&gt;memberPropertyB&lt;/code&gt; 、および &lt;code&gt;memberFunctionA&lt;/code&gt; の前に暗黙の &lt;code&gt;this&lt;/code&gt; があります（maybeNullにこれらが存在しない場合を &lt;code&gt;maybeNull&lt;/code&gt; ます。その場合、それらは包含スコープで検索されます）。その後、 &lt;code&gt;memberFunctionB()&lt;/code&gt; も呼び出され &lt;code&gt;maybeNull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">関数リテラルの本体内で、呼び出しに渡されるレシーバーオブジェクトは&lt;em&gt;暗黙の&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;になるため、追加の修飾子なしでそのレシーバーオブジェクトのメンバーにアクセスしたり、&lt;a href=&quot;this-expressions&quot;&gt; &lt;code&gt;this&lt;/code&gt; 式&lt;/a&gt;を使用してレシーバーオブジェクトにアクセスしたりできます。</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">lateinitプロパティを宣言しているクラスの内部では、初期化されているかどうかを確認することができます。</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">ファイル内では、モジュール全体のドキュメントと個々のパッケージのドキュメントが、対応する第1レベルの見出しで紹介されています。見出しのテキストは、モジュールの場合は「モジュール &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; 」、パッケージの場合は「パッケージ &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; 」である必要があります。</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">スコープ関数のラムダ内では、コンテキストオブジェクトは、実際の名前の代わりに短い参照で利用できます。各スコープ関数は、ラムダ&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;レシーバー&lt;/a&gt;（ &lt;code&gt;this&lt;/code&gt; ）またはラムダ引数（ &lt;code&gt;it&lt;/code&gt; ）として、コンテキストオブジェクトにアクセスする2つの方法のいずれかを使用します。どちらも同じ機能を提供するため、さまざまなケースについてそれぞれの長所と短所を説明し、それらの使用に関する推奨事項を提供します。</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">生成されたKotlin APIをCライブラリから検査する</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">詳細については、ディストリビューションの &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; の内容を調べてください。</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">C ライブラリの生成された Kotlin API を検査する</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">カスタムのアンハンドレッド例外フックをインストールします。古いフックを返すか、指定されていない場合は null を返します。フックは、捕らえられなかった例外が Kotlin の世界の境界に到達したとき、つまりトップレベルの main()や、@Throws でマークされていない Objective-C から Kotlin への呼び出しで例外が発生したときに呼び出されます。フックはどのスレッドやワーカーからでも呼び出せるように、フリーズしたラムダでなければならない。フックは一度だけ呼び出され、その後はクリアされるので、カスタムの例外フックを使ってもメモリリークの検出は期待通りに動作します。</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">libgit2 をインストールし、git ライブラリ用のスタブを用意します。</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome拡張機能&lt;/a&gt;をインストールして、Chrome経由でIntelliJ IDEA内でデバッグできるようにします。これは、Kotlinだけでなく、IntelliJ IDEAで開発されたあらゆる種類のWebアプリケーションに役立ちます。</target>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">EduToolsプラグインのインストール</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">インスタンスチェック</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">インスタンスフィールド</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">メンバへの呼び出しに必要なインスタンス、またはインナー・クラスのコンストラクタのためのアウター・クラスのインスタンス。</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">関数型のインスタンス化</target>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">メソッド &lt;code&gt;matches&lt;/code&gt; 直接呼び出す代わりに、メソッドへの参照を保存します。そのような参照はそのレシーバーにバインドされています。（上記の例のように）直接呼び出すことも、関数型の式が期待される場合はいつでも使用できます。</target>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">パラメータの関数オブジェクトを作成して呼び出しを生成する代わりに、コンパイラは以下のコードを出力します。</target>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">スレッドの代わりに、Kotlin /ネイティブランタイムはワーカーの概念を提供します。これは、関連付けられたリクエストキューで同時に実行される制御フローストリームです。ワーカーは、アクターモデルのアクターとよく似ています。ワーカーはKotlinオブジェクトを別のワーカーと交換できるため、いつでも各可変オブジェクトは単一のワーカーによって所有されますが、所有権は譲渡できます。See section &lt;a href=&quot;#transfer&quot;&gt;オブジェクトの転送と凍結&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">&lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; ように、宣言サイトに差異があるパラメーターに対応する型引数のワイルドカードを生成または省略するようにコンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">宣言サイト分散を持つパラメータに対応する注釈付き型引数用のワイルドカードを生成するようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">Kotlin コンパイラがこのプロパティのゲッター/セッターを生成せず、フィールドとして公開するように指示します。</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、このファイルでパーツの1つとして宣言されたトップレベルの関数とプロパティを含むマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、このファイルでパーツの1つとして宣言されたトップレベルの関数とプロパティを含むマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、このファイルでパーツの1つとして宣言されたトップレベルの関数とプロパティを含むマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlinコンパイラーに、このファイルでパーツの1つとして宣言されたトップレベルの関数とプロパティを含むマルチファイルクラスを生成するように指示します。対応するマルチ&lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;ファイル&lt;/a&gt;クラスの名前は、JvmNameアノテーションによって提供されます。</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">Kotlinコンパイラにこの関数のオーバーロードを生成し、デフォルトのパラメータ値を代用するよう指示します。</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">Kotlinコンパイラに、アノテーションされたJavaクラスを、与えられたKotlinインターフェースの純粋な実装として扱うように指示します。&quot;純粋 &quot;とは、クラスの各型パラメータがそのインターフェースの非プラットフォーム型引数になることを意味します。</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">整数型</target>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">Pythonの任意の大きな整数とは対照的に、Kotlinの整数型は&lt;em&gt;サイズ&lt;/em&gt;が&lt;em&gt;制限さ&lt;/em&gt;れています。制限はタイプによって異なり、メモリ内でビットが何ビットを占有するかを決定します。</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">整数型の範囲（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt;）には、追加の機能があります。つまり、繰り返し使用できます。これらの範囲は、対応する整数型の&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;累進&lt;/a&gt;でもあります。このような範囲は、一般的に &lt;code&gt;for&lt;/code&gt; ループの反復に使用されます。</target>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEAはスクラッチを自動的に実行できます。しばらく入力をやめたときに実行結果を取得するには、&lt;strong&gt;インタラクティブモードを&lt;/strong&gt;オンにし&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEAは、対応するエントリを&lt;a href=&quot;#maven-configuration&quot;&gt;Maven構成に&lt;/a&gt;追加します。</target>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">DOM との相互作用</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">DOM との相互作用</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">インタラクティブモード</target>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptorを使用して&lt;/a&gt;継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptorを使用して&lt;/a&gt;継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">委譲されたプロパティのバインディングの傍受</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptorで&lt;/a&gt;この継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">インターフェースの実装レイアウト</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の値を返す中断ポイントの後の継続を表すインターフェース。</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の値を返す中断ポイントの後の継続を表すインターフェース。</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">インターフェース&lt;em&gt;A&lt;/em&gt;と&lt;em&gt;Bは&lt;/em&gt;どちらも関数&lt;em&gt;foo（）&lt;/em&gt;と&lt;em&gt;bar（）を&lt;/em&gt;宣言しています。それらの両方が実装&lt;em&gt;FOOを（）&lt;/em&gt;が、唯一の&lt;em&gt;B&lt;/em&gt;実装の&lt;em&gt;バー（） &lt;/em&gt;（&lt;em&gt;バーは（）&lt;/em&gt;で抽象的にマークされていない&lt;em&gt;A&lt;/em&gt;機能に本体がない場合、これは、インターフェイスのデフォルトであるため、）。ここで、&lt;em&gt;A&lt;/em&gt;から具象クラス&lt;em&gt;C&lt;/em&gt;を派生させる場合、明らかに、&lt;em&gt;bar（）&lt;/em&gt;をオーバーライドして実装を提供する必要があります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">インターフェース継承</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">KotlinのインターフェイスはJava 8と非常に似ています。インターフェースには、メソッドの実装だけでなく、抽象メソッドの宣言を含めることができます。抽象クラスと異なる点は、インターフェイスは状態を保存できないということです。プロパティを持つことはできますが、それらは抽象化されているか、アクセサの実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">JavaとのInterop</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">Java Reflectionとの相互運用性</target>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">Swift / Objective-Cとの相互運用性も提供されており、別のドキュメント&lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.mdで&lt;/a&gt;カバーされています。</target>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">式をローカルスコープの変数として導入： &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">コトリン入門(ロシア語</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">Kotlinプログラミング入門</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">この値のビットを反転させます。</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">この値の符号ビットを含むビットを反転させます。</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">呼び出し&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWithは&lt;/a&gt;経由せずに呼び出し元のスレッドに直接コルーチンを再開&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;コルーチンの中に存在するかもしれない&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;。適切な呼び出しコンテキストが確立されていることを確認するのは、呼び出し側の責任です。&lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt;を使用して、インターセプトされた継続を取得できます。</target>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">呼び出し演算子</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">元の継続が完了し、使用されなくなったときに、&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;によって返された継続インスタンスに対して呼び出されます。この関数は、&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;が呼び出されたインスタンスとは異なる継続インスタンスを返した場合にのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">関数オブジェクトで &lt;code&gt;call()&lt;/code&gt; を呼び出すと、関数が呼び出されます。メンバー関数の場合、最初のパラメーターは&lt;em&gt;レシーバー&lt;/em&gt;（関数が呼び出されるオブジェクト、この場合は &lt;code&gt;person&lt;/code&gt; ）で、残りのパラメーターは通常の関数パラメーター（この場合は &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ）でなければなりません。。</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">呼び出す &lt;code&gt;findViewById()&lt;/code&gt; Androidの拡張機能は最小限にしようとするので、特に巨大なビュー階層の場合には、遅くなることがあります &lt;code&gt;findViewById()&lt;/code&gt; は、コンテナ内のビューをキャッシュすることによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">関数型インスタンスの呼び出し</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">他のコレクションで関数を呼び出す</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">Kotlin はオブジェクト指向言語なのか、それとも関数型言語なのか?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">KotlinはJavaプログラミング言語と互換性がありますか?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">コトリンは無料ですか?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">コトリンは硬い?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">コトリンはソーシャルメディアを使っていますか?</target>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">拡張機能はありますか?</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">Kotlinの会議はありますか?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">最初から望んでいたことではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">別の JavaScript オブジェクトで宣言を分離する</target>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">メタアノテーションとの連携も可能です。</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">これは、&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScopeに&lt;/a&gt;コルーチンを作成する簡単な例で説明できます。</target>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">もちろん、単一の式として行うこともできます： &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">これは、いくつかの新しいテクニックを示しています。1つは明示的に指定されたコンテキストで&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;を使用しており、もう1つは&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt;関数を使用してコルーチンのコンテキストを変更しながら、次の出力で確認できるように同じコルーチンにとどまっています。</target>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">アクタ自体がどのようなコンテキストで実行されるかは(正確性のために)問題ではありません。アクタはコルーチンであり、コルーチンは順次実行されるので、特定のコルーチンに状態を限定することは、共有された変異可能な状態の問題の解決策として機能します。実際、アクタは自分自身のプライベートな状態を変更することができますが、メッセージを通してしかお互いに影響を与えることができません(ロックの必要性を回避します)。</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">ターゲットが &lt;code&gt;writeLogMessage&lt;/code&gt; のプラットフォーム固有の実装を提供することを期待しており、一般的なコードは、実装方法を考慮せずにこの宣言を使用できます。</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">ラムダの代わりに呼び出し可能な参照がある場合にも便利です。</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">また、プロジェクト内のすべてのKotlinコンパイルタスクを設定することも可能です。</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">標準のChromeデバッガーを使ってKotlinアプリケーションをデバッグすることも可能です。ただ、ソースマップを生成するようにしてください。</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">また、任意のステップ（必ずしも1である必要はありません）で数値を反復することもできます。これは、&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt;関数を介して行われます。</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">特定のレイアウトのウィジェットプロパティを一括でインポートできるのが便利です。</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">&lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; 関数を要素のソースにアタッチすることで作成されます。&lt;a href=&quot;index&quot;&gt;Groupingの&lt;/a&gt;インスタンスを取得するには、 &lt;code&gt;groupingBy&lt;/code&gt; 拡張関数のいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">それを行動で示すのは簡単です。</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">コンパイルされたKotlinコードを、C、C ++、Swift、Objective-C、およびその他の言語で記述された既存のプロジェクトに簡単に組み込むことができます。また、既存のネイティブコード、静的または動的&lt;a href=&quot;native/c_interop&quot;&gt;Cライブラリ&lt;/a&gt;、Swift / Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;フレームワーク&lt;/a&gt;、グラフィカルエンジンなど、Kotlin / Nativeから直接使用することも簡単です。</target>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">KotlinのC &lt;code&gt;struct&lt;/code&gt; 体型と &lt;code&gt;union&lt;/code&gt; 体型の生成されたラッパークラスを使用するのは簡単です。生成されたプロパティのおかげで、Kotlinコードでそれらを使用するのは自然なことです。これまでの唯一の問題は、これらのクラスに新しいインスタンスを作成する方法です。 &lt;code&gt;MyStruct&lt;/code&gt; と &lt;code&gt;MyUnion&lt;/code&gt; の宣言からわかるように、それらのコンストラクターには &lt;code&gt;NativePtr&lt;/code&gt; が必要です。もちろん、ポインターを手動で処理することはできません。代わりに、Kotlin APIを使用して、これらのオブジェクトをインスタンス化することができます。</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">このJavaコードに相当します。</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">インラインクラスがクラス階層に参加することは禁止されています。つまり、インラインクラスは他のクラスを拡張できず、&lt;em&gt;最終&lt;/em&gt;クラスでなければなりません。</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">&lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin / Nativeターゲットの&lt;/a&gt;一部は、適切なホストマシンでのみ構築できることに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">&lt;code&gt;callAnything()&lt;/code&gt; の場合と同様に、 &lt;code&gt;dataTable()&lt;/code&gt; 関数は実行時に存在する必要があることを理解することが重要です。この場合、プラグインに対応するスクリプトファイルが含まれていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">異なる依存関係を持っている場合に、製品フレーバーでグループ化された variant を公開することは推奨されません。</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">ディレクトリとパッケージを一致させる必要はありません:ソースファイルはファイルシステム内の任意の場所に置くことができます。</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">enumクラスの値を汎用的に列挙することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">プラットフォームに依存しません。JVMをターゲットにしていても、JavaScriptをターゲットにしていても、他のプラットフォームをターゲットにしていても、書くコードは同じです。カバーの下では、コンパイラが各プラットフォームに適応するように世話をしてくれます。</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">クラスが関数型をインターフェースのように実装することは可能です。次に、 &lt;code&gt;invoke&lt;/code&gt; と呼ばれる演算子関数を特定のシグネチャで提供する必要があります。そのクラスのインスタンスは、その関数型の変数に割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">一般的な型の型引数にもヌル可能性情報を提供するためにアノテーションを付けることができます。例えば、Java宣言に以下のようなアノテーションを付けることを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">すべてのソースセットの言語設定を一度に設定することができます。</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">Cの表現の範囲安定ポインタを作成することが可能である &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; 使用してインスタンス &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; 下で入手可能な、拡張性、 &lt;code&gt;memScoped { ... }&lt;/code&gt; 。特定の &lt;code&gt;MemScope&lt;/code&gt; に有効期間がバインドされたCポインターを必要とするAPIを使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">独自の関数のコントラクトを宣言することは可能ですが、現在の構文は初期のプロトタイプの状態にあり、おそらく変更されるため&lt;strong&gt;、&lt;/strong&gt;この機能は&lt;strong&gt;実験的&lt;/strong&gt;です。また、現時点ではKotlinコンパイラーは契約を検証しないため、正しい健全な契約を作成するのはプログラマーの責任であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">グロブでヘッダーをフィルタリングすることが可能です。 &lt;code&gt;.def&lt;/code&gt; ファイルの &lt;code&gt;headerFilter&lt;/code&gt; プロパティ値は、スペースで区切られたグロブのリストとして扱われます。インクルードされたヘッダーがグロブのいずれかに一致する場合、このヘッダーの宣言がバインディングに含まれます。</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">マルチプラットフォームライブラリでは、1 つのプラットフォームに対して複数のターゲットを持つことが可能です。例えば、これらのターゲットは同じ API を提供し、テストフレームワークやロギングソリューションのように、実行時に連携するライブラリが異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">どのビルドタイプを使用してバイナリを作成し、どのビルドタイプを使用しないかを指定することができます。次の例では、デバッグ用の実行ファイルのみを作成しています。</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">キーのリストがあり、これらの各キーをいくつかの値に関連付けることによってマップを構築することは、非常に一般的な状況です。以前は、 &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; 関数を使用してそれを行うことが可能でしたが、今では、より効率的で簡単に探索できる代替手段である &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; 導入しています。</target>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; を &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; &amp;gt;として扱うのは安全です。これにより、 &lt;code&gt;Apple&lt;/code&gt; インスタンスの追加のみに制限されますが、任意の &lt;code&gt;Fruit&lt;/code&gt; を受け取ることができるため、問題ありません。</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; を &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; ように扱うのは安全です。これにより生成されるのは &lt;code&gt;Apple&lt;/code&gt; インスタンスのみですが、これは問題ありません &lt;code&gt;Apple&lt;/code&gt; は &lt;code&gt;Fruit&lt;/code&gt; だからです。</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">設定した&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;エントリ&lt;/a&gt;のhashCodeと同じです。</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">KotlinプログラムのC関数を使用するときです。 &lt;code&gt;accept_fun&lt;/code&gt; 関数を呼び出して、C関数ポインターをKotlinラムダに渡します。</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">型パラメーターTを&lt;em&gt;out&lt;/em&gt;として宣言し、使用サイトでのサブタイプの問題を回避することは非常に便利ですが、一部のクラス&lt;strong&gt;は&lt;/strong&gt;実際には &lt;code&gt;T&lt;/code&gt; のみを返すように制限&lt;strong&gt;できません&lt;/strong&gt;。これの良い例は配列です：</target>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">10万個のコルーチンを起動して 1秒後に各コルーチンがドットを印刷します では、それをスレッドで試してみてください。どうなるでしょうか?(たいていの場合、あなたのコードは何らかのメモリ切れのエラーを出すでしょう)</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">それは、Kotlinで見られる以下のような署名につながります。</target>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">ワイルドカードがないとJavaからの宣言が不便そうな場合にのみ参考になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">宣言がJavaからだと不便そうな場合にのみ参考になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">この不明瞭さを取り除くために、IntelliJ IDEAのデフォルトを切り替えて、Kotlinのコーディング規約と整合性のあるフォーマットにすることは、論理的な次のステップのように思えるかもしれません。しかし、これはKotlinプラグインがインストールされた瞬間に、すべての既存のKotlinプロジェクトで新しいコードスタイルが有効になることを意味します。プラグインのアップデートではあまり期待していた結果ではないですよね?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">つまり、基本クラスコンストラクターの実行時には、派生クラスで宣言またはオーバーライドされたプロパティはまだ初期化されていません。これらのプロパティのいずれかが基本クラスの初期化ロジックで（直接または間接的に、別のオーバーライドさ&lt;em&gt;れたオープン&lt;/em&gt;メンバー実装を介して）使用される場合、不正な動作またはランタイムエラーが発生する可能性があります。したがって、基本クラスを設計するときは、コンストラクター、プロパティ初期化子、および&lt;em&gt;init&lt;/em&gt;ブロックで&lt;em&gt;オープン&lt;/em&gt;メンバーを使用しないようにする必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">あまり構造化されていない入力形式を解析するために、JVMの &lt;code&gt;java.util.Scanner&lt;/code&gt; クラスを使用するのは魅力的です。KotlinはJVMライブラリとうまく相互運用できるように設計されているため、Kotlinでの使用は非常に自然に感じられます。ただし、 &lt;code&gt;java.util.Scanner&lt;/code&gt; は非常に遅いことに注意してください。実際、非常に遅いため、10 &lt;sup&gt;5&lt;/sup&gt;以上の整数を解析すると、単純なKotlinの &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; が処理する通常の2秒の時間制限に収まらない可能性があります。</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;4つの&lt;/em&gt;容量を持つバッファ付きチャネルを使用して、「送信」を&lt;em&gt;5&lt;/em&gt;回印刷します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">以下の行を印刷します。</target>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;デバッグモードで&lt;/a&gt;実行すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">こんな感じのものが出てきます。</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">以下のような出力が得られます(順番が違うかもしれません)。</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">渡された2つの関数 &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; 合成を返します。これで、それを呼び出し可能な参照に適用できます。</target>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">2つの &lt;code&gt;Int&lt;/code&gt; パラメータを取り、 &lt;code&gt;Double&lt;/code&gt; を返すため、型は &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; です。名前の前に &lt;code&gt;::&lt;/code&gt; を付けて関数自体を参照し、変数に割り当てることができます（型は通常推論されますが、デモのために型シグネチャを示します）。</target>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">プラットフォーム固有の共有オブジェクト（Linuxでは.so、macOSでは.dylib、Windowsターゲットでは.dll）とC言語ヘッダーを生成し、C /からKotlin / Nativeプログラムで利用可能なすべてのパブリックAPIを使用できるようにしますC ++コード。このような共有オブジェクトを使用してPythonとKotlin / Native間のブリッジを提供する例については、 &lt;code&gt;samples/python_extension&lt;/code&gt; をご覧ください。</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">プラットフォーム固有の静的オブジェクト (.a ライブラリ形式)と C 言語ヘッダを生成し、C/C++コードから Kotlin/Native プログラムで利用可能なすべてのパブリック API を利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">Android開発にKotlinを使い始めるのは非常に簡単です。このチュートリアルでは、Android Studioを使用したウォーミングアッププロセスに従います。AndroidでIntellij IDEAを使用している場合、プロセスはほとんど同じです。</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">同じ配列を&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;に渡して、宛先範囲と重複するようにサブ範囲を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">同じ配列を&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;宛先&lt;/a&gt;に渡して、宛先範囲と重複するようにサブ範囲を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">IntelliJ IDEAコードスタイルをプロジェクトの正しいコードスタイルとして明示的に設定することは常に可能です。そうしてくださいスイッチを行うには&lt;em&gt;、プロジェクト&lt;/em&gt;におけるスキーム &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; と選択し&lt;em&gt;、「Kotlin時代遅れのIntelliJ IDEAのcodestyleを」&lt;/em&gt;中&lt;em&gt;「から使用デフォルト：」&lt;/em&gt;に&lt;em&gt;ロード&lt;/em&gt; ]タブをクリックします。</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">現在、varargsとして宣言されているメソッドに&lt;em&gt;null&lt;/em&gt;を渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">これは、罰金の継承の両方から &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; 、そして我々はに問題がない &lt;code&gt;a()&lt;/code&gt; と &lt;code&gt;b()&lt;/code&gt; ので、 &lt;code&gt;C&lt;/code&gt; は、これらの機能のそれぞれの唯一の実装を継承します。しかし、用 &lt;code&gt;f()&lt;/code&gt; 我々はによって継承された2つの実装持っている &lt;code&gt;C&lt;/code&gt; をので、私たちはオーバーライドする必要があり &lt;code&gt;f()&lt;/code&gt; 中に &lt;code&gt;C&lt;/code&gt; やあいまいさを排除し、当社独自の実装を提供します。</target>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">そうしないと、プログラムがファイルハンドルを漏らしてしまいます。そうしないと、あなたのプログラムはファイルハンドルを漏らしてしまいます。</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">[ &lt;em&gt;Include Kotlin support]&lt;/em&gt;チェックボックスがオンになっていることを確認することが重要です。とりあえず、ウィザードの次のステップではデフォルト設定のままにしておくことができます。&lt;em&gt;次に&lt;/em&gt;、[ &lt;em&gt;空のアクティビティ&lt;/em&gt; ]オプションを選択して[ &lt;em&gt;次へ&lt;/em&gt; ]をクリックし、最後に[ &lt;em&gt;完了&lt;/em&gt; ]を押します。</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">これがネイティブアプリケーションになったことを理解することが重要で、ランタイムや仮想マシンは必要ありません。コンパイルしたバイナリをコンソールから実行できるようになりました。</target>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Gradle Kotlin DSLの &lt;code&gt;apply&lt;/code&gt; でKotlinプラグインを適用することはお勧めしません。詳細は&lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;以下のとおり&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">オブジェクトの&lt;em&gt;一部&lt;/em&gt;のプロパティを変更しながら、残りの部分は変更せずにオブジェクトをコピーする必要がある場合がよくあります。これが &lt;code&gt;copy()&lt;/code&gt; 関数の生成対象です。上記の &lt;code&gt;User&lt;/code&gt; クラスの場合、その実装は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">コンポーネントのcinterop依存関係を宣言することができます。</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">Mavenリポジトリで以前に公開されたKotlin / Nativeライブラリに依存することは可能です。プラグインはGradleの&lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;メタデータ&lt;/a&gt;サポートに依存しているため、対応する機能を有効にする必要があります。 &lt;code&gt;settings.gradle&lt;/code&gt; に次の行を追加します。</target>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">符号なし型に依存するAPIにこのアノテーションを付けることで、実験的な状態を伝播させることが推奨されています。</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">クライアントが明示的にAPIの利用をオプトインするかどうかはあなた次第ですが、符号なし型は実験的な機能であり、言語の変更によってそれらを使用するAPIが突然壊れてしまう可能性があることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">長い汎用型を短縮するのは便利です。例えば、コレクション型を縮小したくなることがよくあります。</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">ラムダ式のパラメータが1つしかないことはよくあることです。</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">このリーダーの各行を反復処理し、読み込まれた各行の&lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;アクション&lt;/a&gt;を呼び出し、完了したら&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;リーダー&lt;/a&gt;を閉じます。</target>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">コレクションを反復処理します。</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">範囲を反復していく。</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">指定した文字列の文字のイテレータ。</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">Iterator &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt;関数を呼び出すことにより、 &lt;code&gt;Set&lt;/code&gt; や &lt;code&gt;List&lt;/code&gt; を含む&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;インターフェースの継承のためにイテレーターを取得できます。イテレータを取得すると、コレクションの最初の要素を指します。&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;関数を呼び出すと、この要素が返され、イテレータの位置が存在する場合は次の要素に移動します。イテレータが最後の要素を通過すると、要素を取得するために使用できなくなります。また、以前の位置にリセットすることもできません。コレクションを繰り返し処理するには、新しいイテレータを作成します。</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">&lt;code&gt;androidMain&lt;/code&gt; ソースセットからのAndroidプロジェクトのJARファイル</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">JPA支援</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305（ &lt;code&gt;javax.annotation&lt;/code&gt; 、詳細は以下）</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305 サポート</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">JVM 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVMバックエンド</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">JVMバックエンド</target>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">ジャーファイル</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">リソースを使ったJava 7の試み</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">Java 8 バイトコードサポート</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">Java 8 標準ライブラリのサポート</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">Java アノテーション</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">Java 配列</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Httpサーブレットは、他のJavaライブラリやフレームワークと同様にKotlinから使用することができます。Hello,World!&quot;を返すシンプルなコントローラを作る方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">ジャバ相互運用性</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">Java リフレクション</target>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">JVMターゲットでのJavaサポート</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">Java Varargs</target>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">JavaアノテーションはKotlinと100%互換性があります。</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">Javaのクラスは、可変数の引数(varargs)を持つインデックスのメソッド宣言を使うことがあります。</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">Java コンパイラオプション</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">Kotlin での Java ジェネリック</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">Javaの相互運用。</target>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Javaが関数型とラムダ式をサポートしたのは数年前のことです。以前のJavaでは、関数のシグネチャを定義するためにインターフェイスを使用し、インターフェイスを実装したクラスをインラインで匿名で定義できるようにすることで、この問題を回避していました。これはKotlinでも利用できます。これはJavaライブラリとの互換性のためと、イベントハンドラを指定するのに便利だからです(特に、同じリスナーオブジェクトでリッスンしなければならないイベントタイプが複数ある場合)。インターフェースや(抽象的な)クラス、そしてそのインスタンスを受け取る関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">JavaリフレクションはKotlinクラスで動作し、その逆も同様です。上記のように、 &lt;code&gt;instance::class.java&lt;/code&gt; 、 &lt;code&gt;ClassName::class.java&lt;/code&gt; または &lt;code&gt;instance.javaClass&lt;/code&gt; を使用して、 &lt;code&gt;java.lang.Class&lt;/code&gt; を介してJavaリフレクションに入ることができます。</target>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">nullabilityアノテーションを持つJavaの型は、プラットフォーム型としてではなく、実際のnullableまたはnon-nullのKotlin型として表現されます。コンパイラは、以下のようないくつかの種類のヌル可能性アノテーションをサポートしています。</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Javaの配列は、次のようにマップされ&lt;a href=&quot;java-interop#java-arrays&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">Javaの箱型プリミティブ型は、ヌル可能なKotlin型にマッピングされています。</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Javaの生の型は星の投影に変換されます。</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Javaのワイルドカードは型投影に変換されます。</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">ジャワデフォルトメソッド呼び出し</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">ジャバ式反射</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">ジャワツーコトリンコンバータ</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">JavaScriptバックエンド</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">JavaScript DCE</target>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">JavaScriptモジュール</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">JavaScript リフレクション</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">JavaScriptバックエンド</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">JavaScriptバックエンドは、より静的にチェック可能なコードを生成するようになり、ミニファイア、オプティマイザ、リンタなどのJSコード処理ツールとの親和性が向上しました。</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">JavaScriptには、パッケージ（名前空間）の概念はありません。これらは通常、ネストされたオブジェクトによってエミュレートされます。コンパイラーは、 &lt;code&gt;external&lt;/code&gt; 宣言への参照を、プレフィックスのないプレフィックス名（&lt;em&gt;プレーン&lt;/em&gt;モジュールの場合）またはプレーンインポートのいずれかに変換します。ただし、JavaScriptライブラリがその宣言をパッケージで提供する場合は、これで満足できません。 &lt;code&gt;@JsQualifier(...)&lt;/code&gt; アノテーションを使用して、 &lt;code&gt;external&lt;/code&gt; 宣言を参照する前に追加のプレフィックスを生成するようにコンパイラーに指示できます。</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">JavaScriptにはインターフェースの概念はありません。関数がそのパラメーターが &lt;code&gt;foo&lt;/code&gt; および &lt;code&gt;bar&lt;/code&gt; メソッドをサポートすることを期待する場合、実際にこれらのメソッドを持つオブジェクトを渡すだけです。インターフェースを使用して、静的に型付けされたKotlinに対してこれを表現できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrainsは、Reactコミュニティ専用のいくつかのツールを開発および保守しています&lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;。Reactバインディング&lt;/a&gt;と&lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlinアプリ&lt;/a&gt;です。後者は、ビルド構成のないKotlinでReactアプリのビルドを開始するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">文脈の中での仕事</target>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">Kotlin/Native での C 言語の型とその表現について、関連するチュートリアルに参加してみませんか?</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">コースに参加する</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">Joshua Blochは、&lt;strong&gt;Producers&lt;/strong&gt;からのみ&lt;strong&gt;読み取る&lt;/strong&gt;オブジェクトと、&lt;strong&gt;Consumersに&lt;/strong&gt;のみ&lt;strong&gt;書き込む&lt;/strong&gt;オブジェクトを呼び出します。「&lt;em&gt;柔軟性を最大にするために、プロデューサーまたはコンシューマーを表す入力パラメーターでワイルドカードタイプを使用する&lt;/em&gt;」ことを推奨し、次のニーモニックを提案します。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">スレッド間のジャンプ</target>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">プラグイン JAR ファイルをコンパイラプラグインのクラスパスに追加し、sam-with-receiver アノテーションのリストを指定するだけです。</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">Java 8と同様に、Kotlinでも数値リテラルの中でアンダースコアを使って数字のグループを区切ることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Java 8と同様に、KotlinはSAM変換をサポートしています。つまり、Kotlinの関数リテラルは、インターフェースメソッドのパラメータ型がKotlin関数のパラメータ型と一致する限り、デフォルトではない1つのメソッドでJavaインターフェースの実装に自動的に変換することができます。</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">JavaやJavaScriptと同様に、Kotlinは行末コメントやブロックコメントをサポートしています。</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">Javaの匿名内部クラスと同様に、オブジェクト式のコードは、囲んだスコープから変数にアクセスすることができます。(Javaとは異なり、これは最終的な変数や事実上の最終的な変数には限定されません)。</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">Javaと同様に、特殊なケースは &lt;code&gt;value&lt;/code&gt; パラメーターです。その値は明示的な名前なしで指定できます：</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">Javaと同じように、Kotlinの列挙型クラスには合成メソッドがあり、定義された列挙型定数をリストし、その名前で列挙型定数を取得できます。これらのメソッドのシグネチャは次のとおりです（列挙型クラスの名前が &lt;code&gt;EnumClass&lt;/code&gt; であると想定）。</target>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">コンパニオン・オブジェクトの通常のメンバと同様に、クラス名のみを修飾子として使用して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">JavaDocと同様に、KDocコメントは &lt;code&gt;/**&lt;/code&gt; で始まり、 &lt;code&gt;*/&lt;/code&gt; で終わります。コメントのすべての行はアスタリスクで始まる場合があり、コメントの内容の一部とは見なされません。</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">KDoc構文</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">KDocは現在、以下のブロックタグをサポートしています。</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDocは &lt;code&gt;@deprecated&lt;/code&gt; タグをサポートしていません。代わりに、 &lt;code&gt;@Deprecated&lt;/code&gt; アノテーションを使用してください。</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">KDoc構文</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">KaptはKotlinソースを生成できます。生成されたKotlinソースファイルを &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; で指定されたディレクトリに書き込むだけで、これらのファイルがメインソースとともにコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Kapt コンパイラプラグインは Kotlin コンパイラのバイナリディストリビューションで利用できます。</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kaptはアノテーションプロセッサを実行するためにJavaコンパイラを使用しています。</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">これは単なる構文上の砂糖であることを覚えておいてください。実際にクラスやそのインスタンスを変更するわけではありません。したがって、拡張機能/プロパティは、それを使用したい場所にインポートする必要があります（クラスのインスタンスと一緒に実行されないため）。同じ理由で、拡張メンバーをオーバーライドすることはできません-サブタイプ用にそれらを再実装できますが、解決は、呼び出している式の静的タイプに基づいてコンパイル時に行われます。したがって、 &lt;code&gt;Vehicle&lt;/code&gt; の拡張関数を宣言し、そのサブクラス &lt;code&gt;Car&lt;/code&gt; の名前とシグネチャが同じである関数を次のように宣言すると、 &lt;code&gt;v&lt;/code&gt; は実際には &lt;code&gt;Car&lt;/code&gt; ですが、呼び出されるのは &lt;code&gt;Vehicle&lt;/code&gt; の拡張関数です。</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">何年もかけて言葉を現代的なものにしましょう。</target>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">KeepsafeのApp Lockアプリも&lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;100％Kotlinに変換され&lt;/a&gt;、ソース行数が30％、メソッド数が10％減少しました。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;の要素のキー。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;は、このキーを持つ要素のタイプです。</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;の要素のキー。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;は、このキーを持つ要素のタイプです。コンテキスト内のキーは&lt;em&gt;参照によって&lt;/em&gt;比較&lt;em&gt;されます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">キーワードと演算子</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">コンパイラで生成されるモジュールの種類</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">このパラメータの種類。</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">種類は、インスタンス、拡張レシーバ・パラメータ、値パラメータなど、ソース・コード内のパラメータ宣言の特定の位置を表します。</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">既知の問題</target>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1はコルーチンを導入しました。これは、非同期の非ブロックコード（およびその他）を記述する新しい方法です。このチュートリアルでは、既存のJavaライブラリのヘルパーとラッパーのコレクションである &lt;code&gt;kotlinx.coroutines&lt;/code&gt; ライブラリを使用して、Kotlinコルーチンの基本的な使用方法をいくつか説明します。</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1では、Kotlin 1.0にあった封印されたクラスとデータクラスに関する制限のいくつかが取り除かれました。トップレベルの封印されたクラスのサブクラスを、封印されたクラスのネストされたクラスとしてだけでなく、同じファイル内でトップレベルの封印されたクラスのサブクラスを定義できるようになりました。データクラスは他のクラスを拡張できるようになりました。これにより、式クラスの階層をきれいに定義することができます。</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2では、 &lt;code&gt;BigInteger&lt;/code&gt; と &lt;code&gt;BigDecimal&lt;/code&gt; を操作し、他の数値型から作成するための一連の関数が導入されています。これらは：</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3 はスクリプト API の進化と改善を続けており、外部プロパティの追加、静的または動的な依存関係の提供など、スクリプトのカスタマイズのための実験的なサポートを導入しています。</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3は、ネイティブターゲットの改善と改良を続けています。詳細については、&lt;a href=&quot;native-overview&quot;&gt;Kotlin /ネイティブの概要&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3では、パラメーターを取らないシンプルな形式の &lt;code&gt;main&lt;/code&gt; が導入されました。Kotlinの「Hello、World」が19文字短くなりました。</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3では、新しい種類の宣言である &lt;code&gt;inline class&lt;/code&gt; が導入されています。インラインクラスは、通常のクラスの制限されたバージョンと見なすことができます。特に、インラインクラスはプロパティを1つだけ持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">Kotlin 1.3 では、サスペンド関数の呼び出し可能な参照と Reflection API の Coroutines のサポートが導入されました。</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">Kotlin 1.3では、実行可能なKotlin &lt;em&gt;スクラッチファイルの&lt;/em&gt;サポートが導入されてい&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt;スクラッチファイル&lt;/em&gt;は、拡張子が.ktsのkotlinスクリプトファイルで、エディターで直接実行して評価結果を取得できます。</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3では、IDEで&lt;a href=&quot;coding-conventions&quot;&gt;推奨されるコードスタイルの&lt;/a&gt;サポートが導入されています。チェックアウト&lt;a href=&quot;code-style-migration-guide&quot;&gt;このページを&lt;/a&gt;移行ガイドラインについて。</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">Kotlin 1.3では符号なし整数型が導入されました。</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3 ではこの制限が緩和され、より大きなアーティシティを持つ関数のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">Kotlin &lt;code&gt;object Object&lt;/code&gt; は、 &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; としてアクセスできます。オブジェクトの唯一のインスタンスを取得する &lt;code&gt;_instance&lt;/code&gt; 関数があります。</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">Kotlin Android拡張機能</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">Kotlinコーディング規約とIntelliJ IDEAフォーマッタ</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">コトリンコレクションの概要</target>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">コトリンの定義</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">Kotlin教育用プラグイン</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">コトリンの進化</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">コトリンの例</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Kotlin Gradleプラグイン1.3.41はAndroid Gradleプラグイン3.0以降で動作します。</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">Kotlin JavaScript の概要</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3CフェッチAPI&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3CファイルAPI&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest APIの&lt;/a&gt; Kotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing APIの&lt;/a&gt; Kotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web通知API&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;用のKotlin JavaScriptラッパー。</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">DOM API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">DOM CSS API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">DOM SVG API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">DOM URL API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">DOM イベント API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">DOM 解析 API 用の Kotlin JavaScript ラッパーです。</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">WebGL API用のKotlin JavaScriptラッパーです。</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">コトリンコーン</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Kotlin Koans は Kotlin 構文に慣れるための一連の練習問題です。それぞれの練習問題は失敗するユニットテストとして作成されており、あなたの仕事はそれを合格させることです。Kotlin Koansを使うには、以下の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Kotlin Multiplatform プロジェクトには Gradle のバージョン 4.7 以上が必要ですが、それ以前のバージョンの Gradle はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">Kotlin Multiplatformプロジェクトは、 &lt;code&gt;android&lt;/code&gt; プリセットを提供することでAndroidプラットフォームをサポートします。Androidターゲットを作成するには、 &lt;code&gt;com.android.application&lt;/code&gt; や &lt;code&gt;com.android.library&lt;/code&gt; などのAndroid Gradleプラグインの1つを手動でプロジェクトに適用する必要があります。Gradleサブプロジェクトごとに作成できるAndroidターゲットは1つだけです。</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">コトリンナンバーズとNSナンバーズ</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">Kotlin プログラミング。ビッグオタクランチガイド</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">Kotlin スクリプト API</target>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">Kotlin スクリプト (*.kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">コトリン標準図書館</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlinを使用すると、事前定義された一連の演算子の実装を型に提供できます。これらの演算子には、記号表現（ &lt;code&gt;+&lt;/code&gt; や &lt;code&gt;*&lt;/code&gt; など）と&lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;優先順位が&lt;/a&gt;固定されています。演算子を実装するために、対応する型（つまり、2項演算の左側の型と単項演算子の引数の型）の固定名を持つ&lt;a href=&quot;functions#member-functions&quot;&gt;メンバー関数&lt;/a&gt;または&lt;a href=&quot;extensions&quot;&gt;拡張関数&lt;/a&gt;を提供します。演算子をオーバーロードする関数は、 &lt;code&gt;operator&lt;/code&gt; 修飾子でマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlinでは、Kotlinプロジェクトを一般的なモジュールシステム用のJavaScriptモジュールにコンパイルすることができます。利用可能なオプションのリストは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlinを使用すると、シンボル宣言に配置できる&lt;em&gt;可視性修飾子を使用して&lt;/em&gt;、シンボルの可視性（Pythonではアンダースコアの規則を介してのみ実行されます）を適用できます。可視性修飾子を指定しない場合、デフォルトの可視性レベルである&lt;em&gt;public&lt;/em&gt;を取得します。</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">Kotlinには、ボックス化オーバーヘッドなしにプリミティブ型の配列を表すための特殊なクラスもあります： &lt;code&gt;ByteArray&lt;/code&gt; 、 &lt;code&gt;ShortArray&lt;/code&gt; 、 &lt;code&gt;IntArray&lt;/code&gt; など。これらのクラスには &lt;code&gt;Array&lt;/code&gt; クラスとの継承関係はありませんが、同じメソッドとプロパティのセットがあります。それぞれに対応するファクトリ関数もあります。</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlinは浮動小数点数の従来の記法もサポートしています。</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Kotlin と TeamCity での継続的インテグレーション</target>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">コトリンとOSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">KotlinとSwiftはどちらも型の仕様の一部としてヌル可能性を定義していますが、Objcは型のメソッドやプロパティに対してヌル可能性を定義しています。そのため、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Kotlinのアプリケーションは、Amazon Web ServicesやGoogle Cloud Platformなど、Java Webアプリケーションをサポートするあらゆるホストにデプロイすることができます。</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">静的型付けされたプログラミング言語である Kotlin は Gradle のビルドスクリプトを書くのに適しています。静的型推論のおかげで、Kotlin コンパイラはより早くエラーを検出し、重要なコンパイルエラーメッセージや警告を表示します。IDE とコンパイラは、型に関する情報を使って、指定されたスコープで利用可能な関数やプロパティを推論することができます。</target>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Kotlin はスクリプト言語としても使用できます。スクリプトとは、トップレベルの実行可能なコードを含む Kotlin のソースファイル (.kts)のことです。</target>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlinはいくつかの異なるプラットフォーム用にコンパイルすることができます。このドキュメントでは、ターゲットプラットフォームがJava仮想マシンであることを前提としていますが、これはいくつかの特別な機能を提供します。</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Kotlinは、サーバーサイド、クライアントサイドのWeb、Androidなど、あらゆる種類の開発に利用できます。現在Kotlin/Nativeが開発中で、組み込みシステム、macOS、iOSなどの他のプラットフォームのサポートも予定されています。モバイルやサーバーサイドのアプリケーション、JavaScriptやJavaFXを使ったクライアントサイド、データサイエンスなどにKotlinを使っています。</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlinは、jQueryやReactなどの既存のサードパーティライブラリやフレームワークと一緒に使用できます。強く型付けされたAPIを使用してサードパーティのフレームワークにアクセスするには、&lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt;ツールを使用して、TypeScript定義を&lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitionリポジトリからKotlinに変換できます。または、&lt;a href=&quot;dynamic-type&quot;&gt;動的な型&lt;/a&gt;を使用して、厳密な型指定なしで任意のフレームワークにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlinは、Pythonの &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 内包の簡潔さにかなり近づくことができます。 &lt;code&gt;people&lt;/code&gt; が、 &lt;code&gt;name&lt;/code&gt; プロパティを持つ &lt;code&gt;Person&lt;/code&gt; オブジェクトのコレクションであると想定します。</target>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlinは実行時に数値型を区別できません（ &lt;code&gt;kotlin.Long&lt;/code&gt; を除く）。つまり、次のコードは機能します。</target>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Kotlinはコードの安定性や下位互換性をかなり気にしています。Kotlin の互換性ポリシーによると、&quot;Breaking Change&quot; (例えば、以前は正常にコンパイルできていたコードをコンパイルできなくするような変更)はメジャーリリース (1.2,1.3 など)でのみ導入できるとされています。</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">Kotlinのクラスやインターフェースは、Swift/Objective-Cのクラスやプロトコルでサブクラス化することができます。</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">KotlinクラスにはObjective-Cの &lt;code&gt;KotlinBase&lt;/code&gt; 基本クラスがあり、このクラスは &lt;code&gt;NSObject&lt;/code&gt; クラスを拡張します。コレクションと例外のラッパーもあります。コレクションタイプのほとんどは、反対側から同様のコレクションタイプにマップされます。</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">KotlinのコードはJavaから簡単に呼び出すことができます。例えば、Kotlinクラスのインスタンスをシームレスに作成し、Javaのメソッドで操作することができます。しかし、JavaとKotlinの間には、KotlinのコードをJavaに統合する際に注意が必要な違いがあります。このページでは、KotlinコードのJavaクライアントとの相互接続を調整する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlinコレクション（つまり、 &lt;code&gt;List&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; 、 &lt;code&gt;Map&lt;/code&gt; など）は、特定のJavaScriptタイプにはマップされません。</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">Kotlinコレクションは、上記の表で説明されているようにSwift / Objective-Cコレクションに変換されます。 Swift / Objective-Cコレクションは、 &lt;code&gt;NSMutableSet&lt;/code&gt; と &lt;code&gt;NSMutableDictionary&lt;/code&gt; を除いて、同じ方法でKotlinにマップされます。 &lt;code&gt;NSMutableSet&lt;/code&gt; はKotlin &lt;code&gt;MutableSet&lt;/code&gt; に変換されません。 Kotlinのためのオブジェクト渡すには &lt;code&gt;MutableSet&lt;/code&gt; を、あなたは、例えばとKotlinでそれを作成することによって明示的にKotlinコレクションのこの種を作成することができます &lt;code&gt;mutableSetOf()&lt;/code&gt; 、または使用して &lt;code&gt;KotlinMutableSet&lt;/code&gt; のスウィフト（またはでクラスを &lt;code&gt;${prefix}MutableSet&lt;/code&gt; のObjective-C、に &lt;code&gt;prefix&lt;/code&gt; フレームワーク名の接頭辞です）。 &lt;code&gt;MutableMap&lt;/code&gt; についても同様です。</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Kotlinコレクションには、一般的に使用される&lt;em&gt;集計操作（&lt;/em&gt;コレクションの内容に基づいて単一の値を返す&lt;em&gt;操作）の&lt;/em&gt;関数が含まれています。それらのほとんどはよく知られており、他の言語と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Kotlin のコレクションには、コレクションから単一の要素を取得するための関数が用意されています。このページで説明する関数はリストとセットの両方に適用されます。</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">Kotlin コミュニティはオープンで親切で歓迎されています。遠慮なく参加して、好きなプラットフォームで質問してください。</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Kotlinコンパイラは、JavaScriptのコードから自由に使える普通のJavaScriptのクラスや関数、プロパティを生成してくれます。とはいえ、微妙に覚えておくべきことがあります。</target>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Kotlinコンパイラはバイトコードを生成するので、Javaで書かれたものとKotlinアプリケーションの見た目に違いはありません。</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">Kotlin コンパイラの仕様</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Kotlin コンパイラは以下のような出力を生成します。</target>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Kotlinのコンストラクタは、Swift/Objective-Cのイニシャライザとしてインポートされます。</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Kotlin のドキュメントは始めるには良い場所です。</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">KotlinにはPythonの&lt;em&gt;リソースマネージャー&lt;/em&gt;やJavaの&lt;em&gt;try-with-resources&lt;/em&gt;がありませんが、拡張関数のおかげで、次の &lt;code&gt;use&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">Kotlinは&lt;a href=&quot;exceptions&quot;&gt;例外&lt;/a&gt;を確認していません</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">Kotlinにはチェック済みの例外がありません。これには様々な理由がありますが、簡単な例を示します。</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">KotlinはJavaScriptのトップレベルプロパティの遅延初期化を実装していません。</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Kotlinは、コンパイル時に&lt;a href=&quot;generics&quot;&gt;ジェネリック&lt;/a&gt;を含む操作の型安全性を保証しますが、実行時には、ジェネリック型のインスタンスは実際の型引数に関する情報を保持しません。たとえば、 &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; は消去され、 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; だけになります。一般に、インスタンスが実行時に特定の型引数を持つジェネリック型に属しているかどうかを確認する方法はありません。</target>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin はそのパッケージ構造を JavaScript に公開しているので、ルートパッケージで宣言を定義しない限り、JavaScript で完全修飾名を使用しなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Kotlin は Java が抱える一連の問題を修正します。</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">KotlinはJavaの命名規則に従っています。特に</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Kotlin for Androidの導入事例</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">Android開発者のためのKotlin</target>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Java開発者のためのKotlin</target>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Kotlin関数型オブジェクト（ラムダなど）は、Swift関数/ Objective-Cブロックに変換されます。ただし、関数と関数の型を変換するときに、パラメーターの型と戻り値がマップされる方法には違いがあります。後者の場合、プリミティブ型はボックス化された表現にマップされます。 Kotlin &lt;code&gt;Unit&lt;/code&gt; 戻り値は、Swift / Objective-Cでは対応する &lt;code&gt;Unit&lt;/code&gt; シングルトンとして表されます。このシングルトンの値は、他のKotlin &lt;code&gt;object&lt;/code&gt; 場合と同じ方法で取得できます（上記の表のシングルトンを参照）。まとめると：</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Kotlin関数は&lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;ファーストクラス&lt;/em&gt;&lt;/a&gt;です。つまり、変数やデータ構造に格納し、引数として他の&lt;a href=&quot;#higher-order-functions&quot;&gt;高次関数&lt;/a&gt;に渡したり、他の高次関数から返したりすることができます。他の非関数値で可能な方法で関数を操作できます。</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlinは、非同期モジュール定義(AMD)、CommonJS、ユニバーサルモデル定義(UMD)と互換性のあるJavaScriptコードを生成します。</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">KotlinはJavaに近い方法で数値を扱いますが、全く同じではありません。例えば、数字には暗黙のワイド化変換はありませんし、リテラルも若干異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Kotlinの実行時のファイルサイズはかなり小さく、ライブラリは約964KBです(1.3.41現在)。つまり、Kotlinは.apkのファイルサイズにほんの少しだけ足しています。</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlinには、アプリケーションで使用できる標準ライブラリが豊富に用意されています。pomファイルに以下の依存関係を設定します。</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Kotlinは大手企業での採用に成功しており、その体験談をいくつか紹介しています。</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlinには、オブジェクト指向と機能の両方の構造があります。OOスタイルとFPスタイルの両方で使用することも、2つの要素を混在させることもできます。高階関数、関数型、ラムダなどの機能に対するファーストクラスのサポートを備えたKotlinは、関数型プログラミングを実行または探索する場合に最適です。</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlinにはクラスとそのメンバーがデフォルトで &lt;code&gt;final&lt;/code&gt; になっているため、クラスを &lt;code&gt;open&lt;/code&gt; 必要があるSpring AOPなどのフレームワークやライブラリを使用するのは不便です。&lt;em&gt;すべてのオープン&lt;/em&gt;コンパイラプラグインは、これらのフレームワークの要件にKotlinを適応し、特定のアノテーションを付けたクラスを作り、そのメンバーは、明示的に使われていないオープン &lt;code&gt;open&lt;/code&gt; キーワード。</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlinには独自のリフレクションライブラリがあります（ &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 必要があります）。JVMを対象とする場合、Javaリフレクション機能も使用できます。Kotlinリフレクションはまだ機能が完全ではないことに注意してください。特に、これを使用して &lt;code&gt;String&lt;/code&gt; などの組み込みクラスを検査することはできません。</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">Kotlinは、I / Oを実行するJavaの手間のかかる（ただし非常に柔軟な）方法を継承していますが、いくつかの追加の機能が簡素化されています。ここではすべてを説明するわけではないので、まず、これはファイルのすべての行を反復処理する方法です（ &lt;code&gt;import java.io.File&lt;/code&gt; が必要です）。</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">KotlinはJavaのフィジー配列システムを継承しているため、プリミティブ型には独自の配列型と変換関数がありますが、他の型は &lt;code&gt;.toTypedArray()&lt;/code&gt; で変換できる汎用の &lt;code&gt;Array&lt;/code&gt; 型を使用します。</target>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">Kotlinにはチェック済み例外の概念はありません。すべてのKotlin例外はチェックされていません。 Swiftがチェックしたのはエラーのみです。したがって、SwiftまたはObjective-Cのコードが、処理する例外をスローするKotlinメソッドを呼び出す場合、Kotlinメソッドは &lt;code&gt;@Throws&lt;/code&gt; アノテーションでマークする必要があります。この場合、すべてのKotlin例外（ &lt;code&gt;Error&lt;/code&gt; 、 &lt;code&gt;RuntimeException&lt;/code&gt; 、およびサブクラスのインスタンスを除く）はSwift error / &lt;code&gt;NSError&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlinには、Java 8バイトコードを生成するオプションがあります（ &lt;code&gt;-jvm-target 1.8&lt;/code&gt; コマンドラインオプション、またはAnt / Maven / Gradleの対応するオプション）。現時点では、これはバイトコードのセマンティクスを変更しません（特に、インターフェースとラムダのデフォルトメソッドはKotlin 1.0とまったく同じように生成されます）が、後でさらに使用する予定です。</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">JavaのSAM変換ではなく、Kotlinには適切な&lt;a href=&quot;lambdas#function-types&quot;&gt;関数型&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">Kotlinには3つの構造的なジャンプ表現があります。</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Kotlinには2種類の文字列リテラルがあります:エスケープ文字を含む可能性のあるエスケープ文字列と、改行や任意のテキストを含む可能性のある生の文字列です。エスケープされた文字列はJavaの文字列と非常によく似ています。</target>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">アクションのコトリン</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Kotlinでは、符号なし整数の型を以下のように紹介しています。</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">Kotlin はコンパイルされた静的型付けされた言語であり、解釈された動的型付けされた Python に慣れている人にとっては最初のハードルとなるかもしれません。このドキュメントでは、Kotlin の構文と概念のかなりの部分を、Python の対応する概念と比較して説明することを目的としています。</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">KotlinはAndroidアプリケーションの開発に最適で、新しい制限を導入することなく、現代の言語の利点をすべてAndroidプラットフォームにもたらします。</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlinはサーバーサイドアプリケーションの開発に最適で、既存のJavaベースのテクノロジースタックとの完全な互換性を維持しながら、簡潔で表現力豊かなコードを書くことができ、スムーズな学習曲線を実現します。</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">Kotlinは実用的で根拠のない言語であり、開発者をどちらかに向けることなく、命令型と関数型のプログラミングスタイルの両方をサポートします。関数 &lt;code&gt;f&lt;/code&gt; は、&lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;テール再帰&lt;/a&gt;などのKotlin機能を使用して、関数形式で実装できます。</target>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlinは、JVM、Android、JavaScript、ネイティブをターゲットとするOSS静的型付けプログラミング言語です。&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;によって開発されました。プロジェクトは2010年に開始され、当初からオープンソースでした。最初の公式1.0リリースは2016年2月でした。</target>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">KotlinはCommonJS、AMD、UMDと互換性があり、&lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;さまざまな&lt;/a&gt;モジュールシステムと簡単にやり取りできます。</target>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlinはプログラマのための実用的なツールとして設計されています。言語の進化に関して言えば、そのプラグマティックな性質は以下の原則によって捉えられています。</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、Javaをすでに知っている人が簡単に習得できるように設計されています。違いの簡単な概要は&lt;a href=&quot;../reference/comparison-to-java&quot;&gt;、公式比較ページに&lt;/a&gt;記載されています。ソフトウェア開発者向けのKotlinの基本構文の簡単な紹介は、基本構文から始まるWebサイトのリファレンスセクションに直接あり&lt;a href=&quot;../reference/basic-syntax&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">KotlinはJavaとの相互運用性を考慮して設計されています。既存のJavaコードをKotlinから自然な形で呼び出すことができ、KotlinのコードはJavaからもスムーズに利用することができます。ここでは、KotlinからJavaコードを呼び出す方法について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlinは、 &lt;code&gt;kotlin.js&lt;/code&gt; 標準ライブラリと共に単一のファイルとして配布され、それ自体がUMDモジュールとしてコンパイルされるため、上記の任意のモジュールシステムで使用できます。また、&lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt;パッケージとしてNPMで利用可能です</target>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Kotlinは、Java、C#、JavaScript、Scala、Groovyなどの既存の言語に触発されています。私たちは、Kotlinが簡単に学べるように心がけていますので、数日でKotlinを読み書きできるようになります。慣用的なKotlinの学習や高度な機能を使うには少し時間がかかるかもしれませんが、全体的には複雑な言語ではありません。</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">Kotlinはより簡潔です。概算では、コードの行数が約40％削減されています。また、タイプセーフです。たとえば、null可能でない型のサポートにより、アプリケーションがNPEになりにくくなります。スマートキャスティング、高次関数、拡張関数、レシーバー付きのラムダなどの他の機能により、表現力豊かなコードを記述し、DSLの作成を容易にすることができます。</target>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlinは主にJetBrainsのエンジニアのチームによって開発されています（現在のチームサイズは50歳以上）。主要言語デザイナーは&lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;です。コアチームに加えて、GitHubには250人を超える外部の寄稿者もいます。</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlinは、&lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;、&lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;、&lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt;、&lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;を含むすべての主要なJava IDEでサポートされています。さらに、&lt;a href=&quot;../tutorials/command-line&quot;&gt;コマンドラインコンパイラ&lt;/a&gt;を利用でき、アプリケーションのコンパイルと実行を簡単にサポートできます。</target>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Kotlinはオンラインコースでもしっかりとカバーしていますので、おすすめのコースはこちらからチェックしてみてください。</target>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">Kotlinは、あなたが簡単に使用して値の範囲を作成することができます&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt;から関数 &lt;code&gt;kotlin.ranges&lt;/code&gt; のパッケージとそのオペレータのフォームを &lt;code&gt;..&lt;/code&gt; .。通常、 &lt;code&gt;rangeTo()&lt;/code&gt; によって補完される &lt;code&gt;in&lt;/code&gt; または &lt;code&gt;!in&lt;/code&gt; 機能します。</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlinでは、コレクションに格納されているオブジェクトの正確なタイプとは関係なく、コレクションを操作できます。言い換えれば、あなたは追加 &lt;code&gt;String&lt;/code&gt; リストに &lt;code&gt;String&lt;/code&gt; あなたがするだろうとの同様 &lt;code&gt;Int&lt;/code&gt; Sまたはユーザー定義クラス。したがって、Kotlin標準ライブラリは、あらゆるタイプのコレクションを作成、入力、および管理するための汎用インターフェイス、クラス、および関数を提供します。</target>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">Kotlin メタデータ</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">Kotlinモジュールは、フレームワークにコンパイルされている場合、Swift / Objective-Cコードで使用できます（&lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradleプラグインのドキュメントの&lt;/a&gt;「ターゲットと出力の種類」セクションを参照）。例については、&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;電卓のサンプル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlinが&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt;（JSR-223）と統合されるようになりました。APIを使用すると、実行時にコードのスニペットを評価できます。</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlinは、バイトコードへのパラメーター名の格納をサポートするようになりました。これは、 &lt;code&gt;-java-parameters&lt;/code&gt; コマンドラインオプションを使用して有効にできます。</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">&lt;code&gt;kotlin.Long&lt;/code&gt; を除くKotlin数値型は、JavaScript番号にマップされます。</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Kotlin オブジェクトを固定することができます。つまり、固定されていない状態になるまでメモリ上での位置が安定していることが保証されており、そのようなオブジェクトの内部データへのポインタを C 関数に渡すことができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">IDEにはKotlinプラグイン1.3.21以降がインストールされている必要があります。&lt;em&gt;言語とフレームワークで&lt;/em&gt;確認できます&lt;em&gt;| &lt;/em&gt;IDEの&lt;em&gt;[設定]&lt;/em&gt;（または&lt;em&gt;[設定&lt;/em&gt;&lt;em&gt;]&lt;/em&gt;）の&lt;em&gt;Kotlin更新&lt;/em&gt;セクション。</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">IntelliJ IDEAのKotlinプラグインは&lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;スクラッチを&lt;/a&gt;サポートしています。スクラッチを使用すると、プロジェクトと同じIDEウィンドウでコードドラフトを作成し、その場で実行できます。スクラッチはプロジェクトに関連付けられていません。OSのIntelliJ IDEAウィンドウからすべてのスクラッチにアクセスして実行できます。</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Kotlin は JavaScript での遅延オブジェクトの初期化を保持します。</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlinはオーバーフロー用のセマンティクス保存し &lt;code&gt;kotlin.Int&lt;/code&gt; 、 &lt;code&gt;kotlin.Byte&lt;/code&gt; 、 &lt;code&gt;kotlin.Short&lt;/code&gt; 、 &lt;code&gt;kotlin.Char&lt;/code&gt; と &lt;code&gt;kotlin.Long&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Kotlinプリミティブ型ボックスは、特別なSwift / Objective-Cクラスにマップされます。たとえば、 &lt;code&gt;kotlin.Int&lt;/code&gt; ボックスは、Swift &lt;code&gt;KotlinInt&lt;/code&gt; クラスインスタンス（またはObjective-Cでは &lt;code&gt;${prefix}Int&lt;/code&gt; インスタンス、 &lt;code&gt;prefix&lt;/code&gt; はフレームワーク名のプレフィックス）として表されます。これらのクラスは &lt;code&gt;NSNumber&lt;/code&gt; から派生しているため、インスタンスはすべての対応する操作をサポートする適切な &lt;code&gt;NSNumber&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">名前付きオブジェクトやコンパニオンオブジェクトで宣言されたKotlinプロパティは、その名前付きオブジェクトかコンパニオンオブジェクトを含むクラスのどちらかに静的なバッキングフィールドを持ちます。</target>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlinには、IntelliJ IDEAでもアクセス可能な一連のコンパイラオプションが用意されています。先ほど見たソースマップを生成するためのものの他にも</target>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">：Kotlinは、指定されたオブジェクトのコンテキストでコードのブロックを実行するためにさまざまな機能を提供 &lt;code&gt;let&lt;/code&gt; 、 &lt;code&gt;run&lt;/code&gt; 、 &lt;code&gt;with&lt;/code&gt; 、 &lt;code&gt;apply&lt;/code&gt; 、および &lt;code&gt;also&lt;/code&gt; 。あなたのケースのための右のスコープ機能の選択に関するガイダンスについては、を参照してください&lt;a href=&quot;scope-functions&quot;&gt;スコープ機能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">Kotlinは、このためのいわゆる&lt;strong&gt;スター投影&lt;/strong&gt;構文を提供します。</target>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin は JavaScript をターゲットにする機能を提供します。これは、KotlinをJavaScriptにトランスパイリングすることで行います。現在の実装は ECMAScript 5.1 をターゲットにしていますが、最終的には ECMAScript 2015 もターゲットにする予定です。</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlinには、数値を表す以下の組み込み型が用意されています(これはJavaに近いです)。</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">コトリンはAntに3つのタスクを提供しています。</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlinでは、インスタンスの構築中にすべてのメンバープロパティを初期化する必要があります。場合によっては、すべてのプロパティを初期化するための十分な情報がコンストラクターにないようにクラスを使用することが意図されています（ビルダークラスを作成するときや、プロパティベースの依存関係注入を使用するときなど）。これらのプロパティをnull可能にする必要がないようにするために、&lt;em&gt;遅延初期化プロパティを&lt;/em&gt;使用でき&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;build.gradle.kts&lt;/code&gt; ファイル内のKotlinスクリプト</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">Kotlinシングルトン（ &lt;code&gt;companion object&lt;/code&gt; を含む &lt;code&gt;object&lt;/code&gt; 宣言で作成）は、単一のインスタンスを持つクラスとしてSwift / Objective-Cにインポートされます。インスタンスは、ファクトリメソッドを介して、つまりObjective-Cでは &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; として、Swift &lt;code&gt;MySingleton()&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">コトリンシングルトン</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">コンパイルする Kotlin ソースファイルまたはディレクトリ</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Kotlinソースセットは&lt;em&gt;「依存」&lt;/em&gt;関係に関連付けられている場合があるため、ソースセット &lt;code&gt;foo&lt;/code&gt; がソースセット &lt;code&gt;bar&lt;/code&gt; 依存する場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin のソースと Java のソースを同じフォルダに入れたり、別のフォルダに入れたりすることができます。デフォルトでは異なるフォルダを使用しています。</target>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Kotlin 標準ライブラリのアーティファクトとスプリットパッケージ</target>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlinは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;末尾再帰と&lt;/a&gt;呼ばれる関数型プログラミングのスタイルをサポートしています。これにより、通常ループを使用して記述される一部のアルゴリズムを、代わりに再帰関数を使用して記述できますが、スタックオーバーフローのリスクはありません。関数が &lt;code&gt;tailrec&lt;/code&gt; 修飾子でマークされ、必要な形式を満たすと、コンパイラは再帰を最適化し、代わりに高速で効率的なループベースのバージョンを残します。</target>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、&lt;em&gt;Kotlin注釈処理ツール&lt;/em&gt;（ &lt;code&gt;kapt&lt;/code&gt; ）による&lt;em&gt;注釈&lt;/em&gt;処理をサポートしています。Gradleでのkaptの使用法については、&lt;a href=&quot;kapt&quot;&gt;kaptページで&lt;/a&gt;説明しています。</target>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin はローカル関数、つまり別の関数の中にある関数をサポートしています。</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlinは単一親クラスの継承をサポートしているため、各クラス（ルートクラス &lt;code&gt;Any&lt;/code&gt; を除く）には、&lt;em&gt;スーパークラス&lt;/em&gt;と呼ばれる親クラスが1つだけあり&lt;em&gt;ます&lt;/em&gt;。 Kotlinは、クラスの設計を十分に検討して、実際に&lt;em&gt;サブクラス化し&lt;/em&gt;ても安全であることを確認することを求めています。そのため、クラスはデフォルトで&lt;em&gt;閉じ&lt;/em&gt;られており、クラスを&lt;em&gt;open&lt;/em&gt;または&lt;em&gt;abstract&lt;/em&gt;として明示的に宣言しない限り、クラスを継承できません。次に、コロンの後に親クラスを記述する新しいクラスを宣言することにより、そのクラスからサブクラス化できます。</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlinは以下の演算子と特殊記号をサポートしています。</target>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、適切なクラスのメンバーとして宣言されている数値に対する算術演算の標準セットをサポートしています（ただし、コンパイラーは、対応する命令までの呼び出しを最適化します）。&lt;a href=&quot;operator-overloading&quot;&gt;オペレーターのオーバーロードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">Kotlinは、ループ内の従来の&lt;em&gt;中断&lt;/em&gt;および&lt;em&gt;継続&lt;/em&gt;演算子をサポートしています。&lt;a href=&quot;returns&quot;&gt;リターンとジャンプを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlinは、インターフェースのデフォルトのメソッドが許可されていないJava 6やJava 7を含む幅広いJavaバージョンを対象としています。便宜上、Kotlinコンパイラはこの制限を回避しますが、この回避策はJava 8で導入された &lt;code&gt;default&lt;/code&gt; メソッドと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">コトリンからJavaScriptへ</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlinは一部のJavaタイプを特別に扱います。このような型はJavaから「そのまま」ロードされるのではなく、対応するKotlin型に&lt;em&gt;マップさ&lt;/em&gt;れます。マッピングはコンパイル時にのみ重要であり、ランタイム表現は変更されません。Javaのプリミティブ型は、対応するKotlin型にマップされます（&lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;プラットフォームの型&lt;/a&gt;を覚えておいてください）。</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlinは、関数ポインターの戻り値の型をnull可能な &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; オブジェクトに変換します。最初に明示的に &lt;code&gt;null&lt;/code&gt; をチェックする必要があります。そのために&lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis演算子&lt;/a&gt;を使用します。 &lt;code&gt;cinterop&lt;/code&gt; のツールは、私たちはKotlinでオブジェクトを呼び出すために簡単にC関数ポインタを回すのに役立ちます。これが最後の行で行ったものです。</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">Kotlinのような関数型のファミリーの使用 &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; の宣言のためにその機能との契約： &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlinは、作成された &lt;code&gt;libnative_api.h&lt;/code&gt; ファイルのすべての宣言に &lt;code&gt;libnative_&lt;/code&gt; プレフィックスを使用します。より読みやすい方法で型のマッピングを提示しましょう：</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlinは、Javaプラットフォームと簡単に相互運用できるように設計されています。 JavaクラスはKotlinクラスと見なされ、JavaはKotlinクラスをJavaクラスと見なします。ただし、JavaScriptは動的に型付けされる言語です。つまり、コンパイル時に型をチェックしません。&lt;a href=&quot;dynamic-type&quot;&gt;動的&lt;/a&gt;型を介してKotlinからJavaScriptに自由に通信できますが、Kotlin型システムの全機能を必要とする場合は、JavaScriptライブラリ用のKotlinヘッダーを作成できます。</target>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlinを使用すると、このプロパティを初期化せずに宣言でき、構築後のある時点で（直接または関数を介して）プロパティ値を設定できます。プロパティが設定される前にプロパティを読み取らないように注意するのは、クラス自体とそのユーザーの責任です。Kotlinを使用すると、 &lt;code&gt;name&lt;/code&gt; を読み取り、通常のnull不可のプロパティであるかのようにコードを記述できます。ただし、コンパイラは正しい使用法を適用できません。そのため、プロパティが設定される前にプロパティが読み取られると、実行時に &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlinは、Spring Bootと非常にスムーズに連携します。RESTfulサービスを作成するための&lt;a href=&quot;https://spring.io/guides&quot;&gt;Springガイドに記載&lt;/a&gt;されている手順の多くは、Kotlinをそのまま使用できます。ただし、Gradle構成とプロジェクトレイアウト構造、および初期化コードの定義に関しては、いくつかの小さな違いがあります。</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlinはさまざまな&lt;a href=&quot;build-tools&quot;&gt;ビルドツール&lt;/a&gt;で動作するため、Ant、Maven、Gradleなどの標準ツールを使用している場合、Kotlinプロジェクトを設定するプロセスは、これらのツールと統合する他の言語やライブラリと同じです。いくつかの小さな要件と違いがあるのは、IntelliJ IDEAが使用する内部ビルドシステムであるJBSを使用する場合です。これは、TeamCityでもサポートされています。</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Kotlinの非同期コードを扱うためのアプローチは、コルーチンを使ったもので、これはサスペンド可能な計算、つまり関数がある時点で実行を一時停止し、後で再開できるという考え方です。</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Kotlinのドキュメント生成ツールは&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;と呼ばれます。使用方法については、&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Kotlinのドキュメント構文は&lt;em&gt;KDoc&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。 KDocブロックは、それが記述する構成の上に配置され、 &lt;code&gt;/**&lt;/code&gt; で始まり &lt;code&gt;*/&lt;/code&gt; で終わります（1行である可能性があります。そうでない場合、各中間行はアスタリスクで整列する必要があります）。テキストの最初のブロックは要約です。次に、&lt;em&gt;ブロックタグ&lt;/em&gt;を使用して、構成の特定の部分に関する情報を提供できます。一部のブロックタグは、関数パラメーターとジェネリック型パラメーターの &lt;code&gt;@param&lt;/code&gt; 、および戻り値の &lt;code&gt;@return&lt;/code&gt; です。大括弧内の識別子にリンクできます。リンクとブロックタグ名の外側のすべてのテキストは、Markdown形式です。</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Kotlinのジェネリックは、Javaのジェネリックとは少し異なります（&lt;a href=&quot;generics&quot;&gt;ジェネリックを&lt;/a&gt;参照）。JavaタイプをKotlinにインポートするとき、いくつかの変換を実行します。</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">KotlinのループはPythonのループに似ています。 &lt;code&gt;for&lt;/code&gt; であるものを反復&lt;em&gt;反復可能&lt;/em&gt;（持つもの &lt;code&gt;iterator()&lt;/code&gt; を提供関数 &lt;code&gt;Iterator&lt;/code&gt; オブジェクト）、または反復子自体であるもの：</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">Kotlinのオブジェクトモデルは、Pythonのオブジェクトモデルとは大きく異なります。最も重要なのは、クラスは実行時に動的に変更&lt;em&gt;できないこと&lt;/em&gt;です。 （これにはいくつかの限定的な例外がありますが、通常は行うべきではありません。ただし、&lt;em&gt;リフレクション&lt;/em&gt;と呼ばれる機能を使用して、実行時にクラスとオブジェクトを動的に&lt;em&gt;検査する&lt;/em&gt;こと&lt;em&gt;は&lt;/em&gt;可能です。これは便利ですが、慎重に使用する必要があります。）すべてクラスで必要になる可能性のあるプロパティ（属性）と関数は、クラス本体で直接または&lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;拡張関数&lt;/em&gt;&lt;/a&gt;として宣言する必要があるため、クラスの設計を慎重に検討する必要があります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlinの型システムは、コードからのnull参照の危険性を排除することを目的としています。&lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;これ&lt;/a&gt;は、The Billion Dollar Mistakeとしても知られています。</target>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Kotlinの型システムは、コードから &lt;code&gt;NullPointerException&lt;/code&gt; を排除することを目的としています。NPEの唯一の考えられる原因は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlinは、言語として、標準ライブラリで最小限の低レベルAPIのみを提供し、他のさまざまなライブラリがコルーチンを利用できるようにします。同様の機能を持つ他の多くの言語とは異なり、 &lt;code&gt;async&lt;/code&gt; と &lt;code&gt;await&lt;/code&gt; はKotlinのキーワードではなく、標準ライブラリの一部でもありません。さらに、Kotlinの&lt;em&gt;一時停止機能&lt;/em&gt;の概念は、フューチャーやプロミスよりも安全でエラーの発生しにくい非同期操作の抽象化を提供します。</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">Kotlinは、C＃やGosuと同様に、クラスから継承したり、Decoratorなどのデザインパターンを使用したりすることなく、新しい機能でクラスを拡張する機能を提供します。これは、&lt;em&gt;extensions&lt;/em&gt;という特別な宣言を介して行われます。Kotlinは、&lt;em&gt;拡張関数&lt;/em&gt;と&lt;em&gt;拡張プロパティを&lt;/em&gt;サポートしてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="44cbff389316ebfe00ceb67daf169189d44ae420" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM</source>
          <target state="translated">Kotlin/JVM</target>
        </trans-unit>
        <trans-unit id="59ce5e2461e87e30bf83a0eb1faafe214139a6af" translate="yes" xml:space="preserve">
          <source>Kotlin/Native</source>
          <target state="translated">Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="ba24fc19201f933494d7dd5a5c0dfc8e159aaf9b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native &lt;a href=&quot;native/platform_libs&quot;&gt;libraries&lt;/a&gt; help to share Kotlin code between projects. POSIX, gzip, OpenGL, Metal, Foundation, and many other popular libraries and Apple frameworks are pre-imported and included as Kotlin/Native libraries into the compiler package.</source>
          <target state="translated">Kotlin /ネイティブ&lt;a href=&quot;native/platform_libs&quot;&gt;ライブラリは&lt;/a&gt;、プロジェクト間でKotlinコードを共有するのに役立ちます。POSIX、gzip、OpenGL、Metal、Foundation、および他の多くの一般的なライブラリとAppleフレームワークが事前にインポートされ、Kotlin /ネイティブライブラリとしてコンパイラパッケージに含まれています。</target>
        </trans-unit>
        <trans-unit id="87f61b22867c181628a95e8886f5b445415a504e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Gradle plugin</source>
          <target state="translated">Kotlin/Native Gradle プラグイン</target>
        </trans-unit>
        <trans-unit id="df149e18227e20b3ab9482b52698611b0a6fc13c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime Declarations</source>
          <target state="translated">Kotlin/ネイティブランタイム宣言</target>
        </trans-unit>
        <trans-unit id="491c504edd0672427d971480838eef4206234894" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Apple technologies. The &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</source>
          <target state="translated">Kotlin / NativeもAppleテクノロジーと緊密に統合されています。&lt;a href=&quot;apple-framework&quot;&gt;Appleフレームワークとして&lt;/a&gt;のKotlin / Nativeチュートリアルでは、KotlinコードをSwiftとObjective-Cのフレームワークにコンパイルする方法について説明しています。</target>
        </trans-unit>
        <trans-unit id="1d512deb7d342683898c6350ed1a11736984886b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / NativeはObjective-CおよびSwiftとも緊密に統合されています。これは&lt;a href=&quot;apple-framework&quot;&gt;、Apple Framework&lt;/a&gt;チュートリアルとしてKotlin / Nativeでカバーされています。</target>
        </trans-unit>
        <trans-unit id="08982dde24268c672ff4e00ffc1e0aa78c3c7edf" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as a Dynamic Library</source>
          <target state="translated">動的ライブラリとしてのKotlin/Native</target>
        </trans-unit>
        <trans-unit id="9337f3778507f31504f20c46b400d4ffe737a776" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as an Apple Framework</source>
          <target state="translated">AppleフレームワークとしてのKotlin/Native</target>
        </trans-unit>
        <trans-unit id="5920643ed2bd803efde8c74d41d4425c7caa2ab6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native can be used for many &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;targets&lt;/a&gt; and applications, including, but not limited to macOS, Windows, Linux, and &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Nativeは、macOS、Windows、Linux、&lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;など、多くの&lt;a href=&quot;basic-kotlin-native-app&quot;&gt;ターゲット&lt;/a&gt;とアプリケーションに使用できます。</target>
        </trans-unit>
        <trans-unit id="5a86ebad61bd5c0feb7bd99b7af759453735031a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool, the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details are discussed in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Nativeには &lt;code&gt;cinterop&lt;/code&gt; ツールが付属しており、このツールはC言語とKotlin間のバインディングを生成します。 &lt;code&gt;.def&lt;/code&gt; ファイルを使用して、インポートするCライブラリを指定します。詳細は&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;、Cライブラリと&lt;/a&gt;の相互運用のチュートリアルで説明されています。</target>
        </trans-unit>
        <trans-unit id="c8a9d6995d5deeb05943192825e878fac0954ca5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Nativeには &lt;code&gt;cinterop&lt;/code&gt; ツールが付属しています。このツールは、C言語とKotlin間のバインディングを生成します。 &lt;code&gt;.def&lt;/code&gt; ファイルを使用して、インポートするCライブラリを指定します。これに関する詳細は、&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Cライブラリと&lt;/a&gt;の相互運用のチュートリアルにあります。</target>
        </trans-unit>
        <trans-unit id="f608852356bc7f03f212743cacdba0d3e22a135a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial. The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;interop.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Kotlin / Nativeには &lt;code&gt;cinterop&lt;/code&gt; ツールが付属しています。このツールは、C言語とKotlin間のバインディングを生成します。 &lt;code&gt;.def&lt;/code&gt; ファイルを使用して、インポートするCライブラリを指定します。これに関する詳細は、&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Cライブラリと&lt;/a&gt;の相互運用のチュートリアルにあります。 C APIマッピングを試す最も簡単な方法は、 &lt;code&gt;.c&lt;/code&gt; ファイルの &lt;code&gt;.h&lt;/code&gt; をまったく作成せずに、すべてのC宣言を &lt;code&gt;interop.def&lt;/code&gt; ファイルに含めることです。次に、C宣言を &lt;code&gt;interop.def&lt;/code&gt; ファイルの特別な &lt;code&gt;---&lt;/code&gt; セパレータ行の後に配置します。</target>
        </trans-unit>
        <trans-unit id="02527cf62d35559073254c9faa21884b055d8fe5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a dynamic library out of the Kotlin code we have. A dynamic library often comes with a header file, a &lt;code&gt;.h&lt;/code&gt; file, which we will use to call compiled code from C.</source>
          <target state="translated">Kotlin /ネイティブコンパイラは、私たちが持っているKotlinコードから動的ライブラリを生成できます。多くの場合、ダイナミックライブラリにはヘッダーファイル（ &lt;code&gt;.h&lt;/code&gt; ファイル）が付属しており、Cからコンパイル済みコードを呼び出すために使用します。</target>
        </trans-unit>
        <trans-unit id="aa4881e31bc09168e1508d74717ea87e97808663" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</source>
          <target state="translated">Kotlin/Nativeコンパイラは、KotlinのコードからmacOSやiOS用のフレームワークを作成することができます。作成されたフレームワークには、Objective-CやSwiftで使用するために必要なすべての宣言とバイナリが含まれています。テクニックを理解するには、実際に試してみるのが一番です。まずは小さなKotlinライブラリを作って、Objective-Cプログラムから使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="4e70e70db2bb73d6cf1636bc883f8b53e7b6e7cb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native for Native</source>
          <target state="translated">コトリン/ネイティブのためのネイティブ</target>
        </trans-unit>
        <trans-unit id="7c2c0a3630334c277a8dc79b0ff364b848f6cdc2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</source>
          <target state="translated">Kotlin / Nativeには、Objective-CおよびSwift言語との双方向の相互運用機能があります。Kotlinオブジェクトは、Objective-C / Swift参照カウントと統合されます。未使用のKotlinオブジェクトは自動的に削除されます。&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-Cの相互運用の&lt;/a&gt;記事は、相互運用機能実装の詳細についての詳細情報が含まれています。もちろん、既存のフレームワークをインポートして、Kotlinから使用することもできます。Kotlin / Nativeには、事前にインポートされたシステムフレームワークの優れたセットが付属しています。</target>
        </trans-unit>
        <trans-unit id="fb79704d30655deeda4430e028a0903e865692a2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article contains more details on it. Also, there is the tutorial &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Nativeにはガベージコレクションがありますが、C言語のKotlinオブジェクトの処理には役立ちません。Kotlin / NativeはObjective-CおよびSwiftと相互運用性があり、それらの参照カウンターと統合します。&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-Cの相互運用&lt;/a&gt;ドキュメントの記事は、それについての詳細が含まれています。また、&lt;a href=&quot;apple-framework&quot;&gt;Appleフレームワークとしての&lt;/a&gt;チュートリアルKotlin / Nativeもあります。</target>
        </trans-unit>
        <trans-unit id="c4bedc3bea01878b4fcc1d82e743d0490ea2316b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native implements strict mutability checks, ensuring the important invariant that the object is either immutable or accessible from the single thread at that moment in time (&lt;code&gt;mutable XOR global&lt;/code&gt;).</source>
          <target state="translated">Kotlin / Nativeは厳密な &lt;code&gt;mutable XOR global&lt;/code&gt; 性チェックを実装しており、オブジェクトがその時点で単一スレッドから不変またはアクセス可能であるという重要な不変条件を保証します（可変XORグローバル）。</target>
        </trans-unit>
        <trans-unit id="36a59900f037725e245ca430f51e42774fdb92b1" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interop with Swift and Objective-C is covered in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;documentation&lt;/a&gt; article. Also, the same topic is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">SwiftおよびObjective-CとのKotlin / Native相互運用については、&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;ドキュメントの&lt;/a&gt;記事で説明しています。また、同じトピックが&lt;a href=&quot;apple-framework&quot;&gt;Kotlin / NativeでApple Framework&lt;/a&gt;チュートリアルとしてカバーされています。</target>
        </trans-unit>
        <trans-unit id="9fbae7a065c905b4b51aef1c8da31351fd4627d4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability</source>
          <target state="translated">Kotlin/ネイティブの相互運用性</target>
        </trans-unit>
        <trans-unit id="1610b5a5d3e7a47921adb6d92cccbad92bdc99b6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability with Swift/Objective-C</source>
          <target state="translated">Kotlin/Swift/Objective-Cとのネイティブ相互運用性</target>
        </trans-unit>
        <trans-unit id="d8be23859d14973d71698ea0e5cefbc7c40946a7" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; based backend for the Kotlin compiler and native implementation of the Kotlin standard library.</source>
          <target state="translated">Kotlin / Nativeは、Kotlinコードをネイティブバイナリにコンパイルするテクノロジーで、仮想マシンなしで実行できます。これは、KotlinコンパイラおよびKotlin標準ライブラリのネイティブ実装用の&lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt;ベースのバックエンドです。</target>
        </trans-unit>
        <trans-unit id="f0c84f3b6f232babbc963e394f0dc8678a4ccc49" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is currently &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;in the works&lt;/a&gt;. It compiles Kotlin to native code that can run without a VM. There is a Technology Preview released but it is not production-ready yet, and doesn&amp;rsquo;t yet target all the platforms that we plan to support for 1.0. For more information check out the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;blog post announcing Kotlin/Native&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Nativeは現在&lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;作業中&lt;/a&gt;です。KotlinをVMなしで実行できるネイティブコードにコンパイルします。テクノロジープレビューがリリースされましたが、まだ本番環境には対応しておらず、1.0をサポートする予定のすべてのプラットフォームをまだターゲットにしていません。詳細については、&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;Kotlin / Nativeを発表&lt;/a&gt;したブログ投稿をご覧ください。</target>
        </trans-unit>
        <trans-unit id="2e6e839c9eb016aad26e87b63395598581d37d86" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is primarily designed to allow compilation for platforms where &lt;em&gt;virtual machines&lt;/em&gt; are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine.</source>
          <target state="translated">Kotlin / Nativeは主に、組み込みデバイスやiOSなど、&lt;em&gt;仮想マシン&lt;/em&gt;が望ましくない、または不可能であるプラットフォームでのコンパイルを可能にするように設計されています。追加のランタイムや仮想マシンを必要としない自己完結型プログラムを開発者が作成する必要がある状況を解決します。</target>
        </trans-unit>
        <trans-unit id="0a635a513919c15b75bf38827975739bea97d9aa" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries</source>
          <target state="translated">Kotlin/ネイティブライブラリ</target>
        </trans-unit>
        <trans-unit id="e52aa2cf9fdcb60b58b2f9cbee9d5268ded14cfd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries are zip files containing a predefined directory structure, with the following layout:</source>
          <target state="translated">Kotlin/Native ライブラリは、あらかじめ定義されたディレクトリ構造を含む zip ファイルで、以下のようなレイアウトになっています。</target>
        </trans-unit>
        <trans-unit id="0c6f4cb92f825877d15d4e0409193ad150464dfb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native plugin requires a newer version of Gradle, let's patch the &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; and use the following &lt;code&gt;distrubutionUrl&lt;/code&gt;:</source>
          <target state="translated">Kotlin /ネイティブプラグインは、レッツ・パッチ、のGradleの新しいバージョンを必要とする &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; と、次の使用 &lt;code&gt;distrubutionUrl&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="bc9ab4e314800dbff8307a948abe9a382ccbda9f" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;. There is also the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for more information.</source>
          <target state="translated">Kotlin / Nativeは、Objective-C / Swiftとの双方向の相互運用性を提供します。Objective-Cフレームワークとライブラリは、Kotlinコードで使用できます。Kotlinモジュールは、Swift / Objective-Cコードでも使用できます。それ以外に、Kotlin / Nativeには&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interopがあり&lt;/a&gt;ます。詳細については&lt;a href=&quot;dynamic-libraries&quot;&gt;、ダイナミックライブラリ&lt;/a&gt;チュートリアルとしてのKotlin / Nativeもあります。</target>
        </trans-unit>
        <trans-unit id="c6b2dc69e2661f2073dd575f2affbfbd48e1816c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See e.g. &quot;Using cinterop&quot; in &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle plugin documentation&lt;/a&gt;. A Swift library can be used in Kotlin code if its API is exported to Objective-C with &lt;code&gt;@objc&lt;/code&gt;. Pure Swift modules are not yet supported.</source>
          <target state="translated">Kotlin / Nativeは、Objective-Cとの双方向の相互運用性を提供します。Objective-Cフレームワークとライブラリは、ビルドに適切にインポートされた場合、Kotlinコードで使用できます（システムフレームワークはデフォルトでインポートされます）。たとえば、&lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradleプラグインのドキュメントの&lt;/a&gt;「cinteropの使用」を参照してください。Swiftライブラリは、そのAPIが &lt;code&gt;@objc&lt;/code&gt; を使用してObjective-Cにエクスポートされている場合、Kotlinコードで使用できます。Pure Swiftモジュールはまだサポートされていません。</target>
        </trans-unit>
        <trans-unit id="b1c01f6b8c6b07e3bae6f070059599f6036610db" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides us with the ability to consume standard C libraries, opening up an entire ecosystem of functionality that exists for pretty much anything we could need. In fact, Kotlin/Native already ships with a set of prebuilt &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;platform libraries&lt;/a&gt; which provide some additional common functionality to that of the standard library.</source>
          <target state="translated">Kotlin / Nativeは、標準のCライブラリを使用する機能を提供し、必要なほぼすべてのものに存在する機能のエコシステム全体を開きます。実際、Kotlin / Nativeには、標準ライブラリの機能にいくつかの追加の共通機能を提供する一連のビルド済み&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;プラットフォームライブラリ&lt;/a&gt;がすでに付属しています。</target>
        </trans-unit>
        <trans-unit id="d5389b5d85aa38736c73eb5aa9a313b033cc4d19" translate="yes" xml:space="preserve">
          <source>Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency model with mutually exclusive code blocks and conditional variables, as this model is known to be error-prone and unreliable. Instead, we suggest a collection of alternative approaches, allowing you to use hardware concurrency and implement blocking IO. Those approaches are as follows, and they will be elaborated on in further sections:</source>
          <target state="translated">Kotlin/Native ランタイムでは、相互に排他的なコードブロックと条件変数を持つ古典的なスレッド指向の同時実行モデルを推奨していません。このモデルはエラーが発生しやすく信頼性が低いことが知られているからです。その代わりに、ハードウェア同時実行を使用して IO をブロッキングすることを可能にする代替アプローチを提案します。これらのアプローチは以下の通りで、さらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ac06a1726ed52d913d8c1eb5dbb2c82e723e185d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples</source>
          <target state="translated">コトリン/ネイティブのソースと例</target>
        </trans-unit>
        <trans-unit id="c4fa13c8ae49679dc61a192fdfe13c1f15f778dd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.tgz)</source>
          <target state="translated">Kotlin/ネイティブのソースと例 (.tgz)</target>
        </trans-unit>
        <trans-unit id="950455929874daa5e49199f24231f9f317130873" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.zip)</source>
          <target state="translated">Kotlin/ネイティブのソースとサンプル (.zip)</target>
        </trans-unit>
        <trans-unit id="120d75c1b3c3fba55f52d619ebc338f3dea2b2f3" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports C interop too. Check out the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for that, or have a look at the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Kotlin / NativeはC相互運用もサポートしています。そのための&lt;a href=&quot;dynamic-libraries&quot;&gt;動的ライブラリ&lt;/a&gt;チュートリアルとしてのKotlin / Nativeを確認するか、&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C相互運用&lt;/a&gt;ドキュメントの記事をご覧ください。</target>
        </trans-unit>
        <trans-unit id="8011eb11da7ebe065e7322454c19657ef14fbebd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports the following platforms:</source>
          <target state="translated">Kotlin/Native は以下のプラットフォームに対応しています。</target>
        </trans-unit>
        <trans-unit id="ab1b874667f8863029a4700ab21570b44d78ad0e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports two-way interoperability with the Native world. On the one hand, the compiler creates:</source>
          <target state="translated">Kotlin/Native はネイティブの世界との双方向の相互運用性をサポートしています。一方ではコンパイラが作成します。</target>
        </trans-unit>
        <trans-unit id="6804afabbebdb0087394548cd2a9146eb760288b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native target presets (see the &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;notes&lt;/a&gt; below):</source>
          <target state="translated">Kotlin /ネイティブターゲットプリセット（以下の&lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;注を&lt;/a&gt;参照）：</target>
        </trans-unit>
        <trans-unit id="48119a00acf039b3da2d7a8a891256a947a47f3e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native targets do not require additional test dependencies, and the &lt;code&gt;kotlin.test&lt;/code&gt; API implementations are built-in.</source>
          <target state="translated">Kotlin /ネイティブターゲットは追加のテスト依存関係を必要とせず、 &lt;code&gt;kotlin.test&lt;/code&gt; API実装が組み込まれています。</target>
        </trans-unit>
        <trans-unit id="5a2754b26e3f7ed0f09f6ac7ae0bd6b529fb311d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native uses the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin. We'll look at how to configure a Gradle build below. For some corner cases, a Kotlin/Native compiler can still be obtained manually (not recommended) from the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;Kotlin releases page on GitHub&lt;/a&gt;. In the tutorial, we are focusing on using the Gradle builds.</source>
          <target state="translated">Kotlin / Nativeは、&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインを介して&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt;ビルドシステムを使用します。以下で、Gradleビルドの構成方法を見ていきます。一部のまれなケースでは、&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;GitHubのKotlinリリースページ&lt;/a&gt;からKotlin /ネイティブコンパイラーを手動で取得できます（非推奨）。チュートリアルでは、Gradleビルドの使用に重点を置いています。</target>
        </trans-unit>
        <trans-unit id="8a3c5258f5b49cfb85ed7f0dcaee614a131a77c3" translate="yes" xml:space="preserve">
          <source>Kotlin:</source>
          <target state="translated">Kotlin:</target>
        </trans-unit>
        <trans-unit id="b43ff6724657fd16732a9b1a55f67abda3312ad7" translate="yes" xml:space="preserve">
          <source>KotlinConf Spinner app</source>
          <target state="translated">KotlinConfスピナーアプリ</target>
        </trans-unit>
        <trans-unit id="b1cd61d796dd3aa3454e388dffcf47f0812af913" translate="yes" xml:space="preserve">
          <source>KotlinConf app</source>
          <target state="translated">KotlinConf アプリ</target>
        </trans-unit>
        <trans-unit id="6047c8afd00f076fe5dfb352137d01b27268ea83" translate="yes" xml:space="preserve">
          <source>KotlinNullPointerException</source>
          <target state="translated">KotlinNullPointerException</target>
        </trans-unit>
        <trans-unit id="ee7e86f4510f7d7092cbe3960fdb6815985528a4" translate="yes" xml:space="preserve">
          <source>KotlinReflectionNotSupportedError</source>
          <target state="translated">KotlinReflectionNotSupportedError</target>
        </trans-unit>
        <trans-unit id="4b1b0c248352273cdb7b000d38d1c480106dbb58" translate="yes" xml:space="preserve">
          <source>KotlinVersion</source>
          <target state="translated">KotlinVersion</target>
        </trans-unit>
        <trans-unit id="399d4d156e1a5773fbf3b4b0cfd04b6e517c9fca" translate="yes" xml:space="preserve">
          <source>KtFunction</source>
          <target state="translated">KtFunction</target>
        </trans-unit>
        <trans-unit id="57da6543f61562be137bdbd9c9e157724aeffda4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT</source>
          <target state="translated">LEFT_TO_RIGHT</target>
        </trans-unit>
        <trans-unit id="a75ecccfbf31bd489981a90341d7e832ee10f3c8" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_EMBEDDING</source>
          <target state="translated">LEFT_TO_RIGHT_EMBEDDING</target>
        </trans-unit>
        <trans-unit id="51859752bb5b0316e072d757734043db04448fc4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_OVERRIDE</source>
          <target state="translated">LEFT_TO_RIGHT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="758213c577cf41a86fde124f3b88be88d415048d" translate="yes" xml:space="preserve">
          <source>LETTER_NUMBER</source>
          <target state="translated">LETTER_NUMBER</target>
        </trans-unit>
        <trans-unit id="e8e9a4d54a1399696ec25a431fcc0c615fbc2e7a" translate="yes" xml:space="preserve">
          <source>LINE_SEPARATOR</source>
          <target state="translated">LINE_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="e84f54372586b1a789f2b6cf056c7a1173be8141" translate="yes" xml:space="preserve">
          <source>LINUX</source>
          <target state="translated">LINUX</target>
        </trans-unit>
        <trans-unit id="7ec99800d18c128a406891a50a13ae7030c97a75" translate="yes" xml:space="preserve">
          <source>LITERAL</source>
          <target state="translated">LITERAL</target>
        </trans-unit>
        <trans-unit id="e893e5d306bb8ac993e8000a6af037f4725105be" translate="yes" xml:space="preserve">
          <source>LOCAL_VARIABLE</source>
          <target state="translated">LOCAL_VARIABLE</target>
        </trans-unit>
        <trans-unit id="99de6ad7c4876501b047c66fac1fc218394c8386" translate="yes" xml:space="preserve">
          <source>LOWERCASE_LETTER</source>
          <target state="translated">LOWERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="ebb1178c70d79da7a0d8f3efa343b4f1b5b8c8bd" translate="yes" xml:space="preserve">
          <source>Lambda Expressions and Anonymous Functions</source>
          <target state="translated">ラムダ式と匿名関数</target>
        </trans-unit>
        <trans-unit id="41d636c884bc5c4615a06b36835ca61116f4c96a" translate="yes" xml:space="preserve">
          <source>Lambda expression syntax</source>
          <target state="translated">ラムダ式の構文</target>
        </trans-unit>
        <trans-unit id="0b86dab2bd78e474cfa2ccedae83439dde48687c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared, but passed immediately as an expression. Consider the following example:</source>
          <target state="translated">ラムダ式や匿名関数は「関数リテラル」、つまり宣言されずに式としてすぐに渡される関数です。次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="5688b8dc62f61bfb17ef962f1f3970299059391c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are collectively called &lt;em&gt;function literals&lt;/em&gt;.</source>
          <target state="translated">ラムダ式と無名関数は、まとめて&lt;em&gt;関数リテラル&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7575b2907cada2fd0b97a753d13dd1b9c1b841f5" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt;:</source>
          <target state="translated">ラムダ式は、レシーバータイプをコンテキストから推測できる場合、レシーバーで関数リテラルとして使用できます。その使用法の最も重要な例の1つは、&lt;a href=&quot;type-safe-builders&quot;&gt;タイプセーフなビルダー&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ad3d3ff2619991da585042e4417d2462b7beccf2" translate="yes" xml:space="preserve">
          <source>Lambda formatting</source>
          <target state="translated">ラムダフォーマット</target>
        </trans-unit>
        <trans-unit id="13d6fc1369e9172c884961d85e8a1601ad741c0d" translate="yes" xml:space="preserve">
          <source>Lambda parameters</source>
          <target state="translated">ラムダパラメータ</target>
        </trans-unit>
        <trans-unit id="b220e56144b93a1600b71766a84e029644f0540d" translate="yes" xml:space="preserve">
          <source>Lambda result</source>
          <target state="translated">ラムダ結果</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="49ddf0eb799de42693040dadaac202ba4004f236" translate="yes" xml:space="preserve">
          <source>Language settings</source>
          <target state="translated">言語設定</target>
        </trans-unit>
        <trans-unit id="1ff5129754f331271a9a3fac5165d942c8cc5ff1" translate="yes" xml:space="preserve">
          <source>Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a Gradle build, only the language settings of the compilation's default source set are used and are applied to all of the sources participating in the compilation.</source>
          <target state="translated">ソースセットの言語設定は、IDEでソースがどのように解析されるかに影響します。現在の制限のため、Gradle のビルドでは、コンパイルのデフォルトソースセットの言語設定のみが使用され、コンパイルに参加しているすべてのソースに適用されます。</target>
        </trans-unit>
        <trans-unit id="d6774da675388cdd08014c6406478bff14597287" translate="yes" xml:space="preserve">
          <source>Late-Initialized Properties and Variables</source>
          <target state="translated">初期化されたプロパティと変数</target>
        </trans-unit>
        <trans-unit id="99322069c074a7f591d86eb26eeac43fa69f34bd" translate="yes" xml:space="preserve">
          <source>Lateinit</source>
          <target state="translated">Lateinit</target>
        </trans-unit>
        <trans-unit id="f84a3ef3e20f72377a42e84bdb45e09bb7b7843f" translate="yes" xml:space="preserve">
          <source>Lateinit top-level properties and local variables</source>
          <target state="translated">Lateinit トップレベルのプロパティとローカル変数</target>
        </trans-unit>
        <trans-unit id="b3bb9d6cae3f462e729059bd666f0ea34bc0ea80" translate="yes" xml:space="preserve">
          <source>Lazily started async</source>
          <target state="translated">怠惰に非同期を開始</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="be5e08be6cf0006ff0c341fef7d3f6b41fb802ed" translate="yes" xml:space="preserve">
          <source>Lazy property</source>
          <target state="translated">怠惰な性質</target>
        </trans-unit>
        <trans-unit id="54579fdbee70b6cb28a03b9cca5ce503dbf0fab9" translate="yes" xml:space="preserve">
          <source>LazyThreadSafetyMode</source>
          <target state="translated">LazyThreadSafetyMode</target>
        </trans-unit>
        <trans-unit id="aca4dc328f8e03ba7e98c1efbf5068f7d83287c3" translate="yes" xml:space="preserve">
          <source>Learn Kotlin</source>
          <target state="translated">ベースンを学ぶ</target>
        </trans-unit>
        <trans-unit id="b28b1c4866b45b6c232187eb0f49c55bd90b8a14" translate="yes" xml:space="preserve">
          <source>Learning Kotlin</source>
          <target state="translated">コトリンを学ぶ</target>
        </trans-unit>
        <trans-unit id="23f50e0c99ce18545a5c0af46eb7b9685859fd37" translate="yes" xml:space="preserve">
          <source>Learning Kotlin with EduTools plugin</source>
          <target state="translated">EduToolsプラグインでKotlinを学ぶ</target>
        </trans-unit>
        <trans-unit id="e19a030656541f97ece0fe153ca0f1966796261d" translate="yes" xml:space="preserve">
          <source>Leave other options with their default values and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">他のオプションはデフォルト値のままにし、[ &lt;strong&gt;完了&lt;/strong&gt; ]をクリックします。</target>
        </trans-unit>
        <trans-unit id="b8d43e4d61d6a5ac38163dd5c6fce699c5294311" translate="yes" xml:space="preserve">
          <source>Let us have two producers of strings: &lt;code&gt;fizz&lt;/code&gt; and &lt;code&gt;buzz&lt;/code&gt;. The &lt;code&gt;fizz&lt;/code&gt; produces &quot;Fizz&quot; string every 300 ms:</source>
          <target state="translated">文字列の2つのプロデューサー、 &lt;code&gt;fizz&lt;/code&gt; と &lt;code&gt;buzz&lt;/code&gt; があるとします。 &lt;code&gt;fizz&lt;/code&gt; 、すべて300ミリ「フィズ」の文字列を生成します。</target>
        </trans-unit>
        <trans-unit id="97c13d20ca41b326b3be0985ea83f77551576d93" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">100個のコルーチンを起動して、同じ動作を1000回行ってみましょう。さらに比較のために、それらの完了時間も測定してみましょう。</target>
        </trans-unit>
        <trans-unit id="00337a32763192378fa8ed88a3475bc09950f868" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie activity's and coroutines lifecycles, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction that encapsulates that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">コンテキスト、子供、仕事についての知識をまとめましょう。アプリケーションにライフサイクルを持つオブジェクトがあると仮定しますが、そのオブジェクトはコルーチンではありません。たとえば、Androidアプリケーションを作成し、Androidアクティビティのコンテキストでさまざまなコルーチンを起動して非同期操作を実行し、データのフェッチや更新、アニメーションなどを行います。メモリリークを回避するには、アクティビティが破棄されたときにこれらのコルーチンをすべてキャンセルする必要があります。 。私たちは、当然のことながら、活動のとコルーチンのライフサイクルを結びつけるために、手動でコンテキストとジョブを操作することができますが、 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; は抽象化を提供するカプセル化し：&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;。コルーチンスコープはすべてコルーチンビルダーに拡張機能として宣言されているため、コルーチンスコープに精通している必要があります。</target>
        </trans-unit>
        <trans-unit id="f17004be77e3f7094989ac66ca7a6fcece2d7637" translate="yes" xml:space="preserve">
          <source>Let us run it all seven times:</source>
          <target state="translated">全部で7回走らせてみましょう。</target>
        </trans-unit>
        <trans-unit id="887399487cb35f46c356a942974d9aca65f7d75b" translate="yes" xml:space="preserve">
          <source>Let us start a dozen of them with a random delay.</source>
          <target state="translated">ランダム遅延で十数個始めよう。</target>
        </trans-unit>
        <trans-unit id="413db7e1244403c1e2eef1bc015d6f2b29e5c10d" translate="yes" xml:space="preserve">
          <source>Let us take &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutines builder is defined as extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; we need to have it in the scope and that is what &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">&lt;a href=&quot;#concurrent-using-async&quot;&gt;非同期の&lt;/a&gt;例を使用してConcurrentを取り上げ、 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; と &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; を同時に実行してそれらの結果の合計を返す関数を抽出してみましょう。ので&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;非同期&lt;/a&gt;コルーチンビルダーは、上の拡張として定義されて&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt;我々はスコープでそれを持っている必要があり、それが何である&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScopeの&lt;/a&gt;機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="4952c7e38d872a3739e9ba60b2855b8019e8b9ca" translate="yes" xml:space="preserve">
          <source>Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; clauses in the same &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">遅延文字列値のチャネルを消費し、受信された各遅延値を待機するチャネルプロデューサー関数を記述しましょう。ただし、次の遅延値が発生するか、チャネルが閉じられるまでのみです。この例プット一緒&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;と&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt;同じで句 &lt;code&gt;select&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4731fc0f08644e9fc8c26a8f5800aec92b69f2ee" translate="yes" xml:space="preserve">
          <source>Let us write an example of producer of integers that sends its values to a &lt;code&gt;side&lt;/code&gt; channel when the consumers on its primary channel cannot keep up with it:</source>
          <target state="translated">プライマリチャネルのコンシューマーが対応できない場合に、値を &lt;code&gt;side&lt;/code&gt; チャネルに送信する整数のプロデューサーの例を書いてみましょう。</target>
        </trans-unit>
        <trans-unit id="9ad40ae1c76d7921aa80d947aae7e4174122ffe9" translate="yes" xml:space="preserve">
          <source>Let's also make sure that our coroutines actually run in parallel. If we add a 1-second &lt;code&gt;delay()&lt;/code&gt; to each of the &lt;code&gt;async&lt;/code&gt;'s, the resulting program won't run for 1'000'000 seconds (over 11,5 days):</source>
          <target state="translated">コルーチンが実際に並行して実行されることも確認しましょう。各 &lt;code&gt;async&lt;/code&gt; に 1秒の &lt;code&gt;delay()&lt;/code&gt; を追加すると、結果のプログラムは1'000'000秒（11.5日以上）実行されません。</target>
        </trans-unit>
        <trans-unit id="d5f68d829cd771ce134770e031cf5bf3966ac35a" translate="yes" xml:space="preserve">
          <source>Let's assume in the code above that &lt;code&gt;preparePost&lt;/code&gt; is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</source>
          <target state="translated">上記のコードで、 &lt;code&gt;preparePost&lt;/code&gt; が長時間実行されるプロセスであり、その結果ユーザーインターフェイスがブロックされると仮定します。私たちができることは、別のスレッドでそれを起動することです。これにより、UIのブロックを回避できます。これは非常に一般的な手法ですが、一連の欠点があります。</target>
        </trans-unit>
        <trans-unit id="0b36e6d9aeacb6946bbe6f44c31eebe2f8d34c7f" translate="yes" xml:space="preserve">
          <source>Let's call the framework from Objective-C. For that we create the &lt;code&gt;main.m&lt;/code&gt; file with the following content:</source>
          <target state="translated">Objective-Cからフレームワークを呼び出しましょう。そのために、次の内容の &lt;code&gt;main.m&lt;/code&gt; ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="de2db89a9bd54d886863702055b65232c802ea65" translate="yes" xml:space="preserve">
          <source>Let's check out the C API of our Kotlin library.`</source>
          <target state="translated">Kotlin ライブラリの C API を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ccdc7274b76228eb418fb01b25e4e0b2b1a04fe1" translate="yes" xml:space="preserve">
          <source>Let's click on the &lt;code&gt;App&lt;/code&gt; run configuration to get our project running either on a real Android Device or on the emulator.</source>
          <target state="translated">&lt;code&gt;App&lt;/code&gt; 実行構成をクリックして、実際のAndroidデバイスまたはエミュレーターでプロジェクトを実行します。</target>
        </trans-unit>
        <trans-unit id="1f650b1ab54a0b4e48ce9f7def949cc9e4127516" translate="yes" xml:space="preserve">
          <source>Let's click the &lt;em&gt;Run&lt;/em&gt; button in Xcode, and we'll see our application running</source>
          <target state="translated">Xcode の[ &lt;em&gt;実行&lt;/em&gt; ]ボタンをクリックして、アプリケーションが実行されていることを確認します</target>
        </trans-unit>
        <trans-unit id="735664d189535b1add7a525bb222b33a786f953e" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how C primitive type declarations are visible from Kotlin:</source>
          <target state="translated">次の内容の &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; スタブファイルを作成して、Cプリミティブ型宣言がKotlinからどのように見えるかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="10159fd0817061a10325f96cf0c251b77597ee1f" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how our C declarations are visible from Kotlin:</source>
          <target state="translated">次の内容の &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; スタブファイルを作成して、C宣言がKotlinからどのように見えるかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="a7acdfe9286fc908f1acf3c36443211f26fc104a" translate="yes" xml:space="preserve">
          <source>Let's create a million coroutines again, keeping their &lt;code&gt;Deferred&lt;/code&gt; objects. Now there's no need in the atomic counter, as we can just return the numbers to be added from our coroutines:</source>
          <target state="translated">&lt;code&gt;Deferred&lt;/code&gt; オブジェクトを保持したまま、100万個のコルーチンを作成してみましょう。これで、追加する数値をコルーチンから返すことができるため、アトミックカウンターは必要ありません。</target>
        </trans-unit>
        <trans-unit id="996aed5293f16fb62ea0b0ffc195f181e0ae218e" translate="yes" xml:space="preserve">
          <source>Let's create the class &lt;code&gt;Base64Test&lt;/code&gt; in &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; folder and write the basic tests for Base64.</source>
          <target state="translated">クラスを作成してみましょう &lt;code&gt;Base64Test&lt;/code&gt; をして &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; フォルダやBase64のための基本的なテストを書きます。</target>
        </trans-unit>
        <trans-unit id="bbdbbcfe4f2f14866b323983f8f8272c8a107004" translate="yes" xml:space="preserve">
          <source>Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</source>
          <target state="translated">関数f(x)をこのように表してみましょう:xに1を加え、その結果として得られる数の最後に少なくとも1つのゼロがある間に、そのゼロを除去します。</target>
        </trans-unit>
        <trans-unit id="b41c2ae19915325ca1208b1c0d9b4b01df9a8df1" translate="yes" xml:space="preserve">
          <source>Let's dig a little into what it means. The biggest merit of coroutines is that they can &lt;em&gt;suspend&lt;/em&gt; without blocking a thread. The compiler has to emit some special code to make this possible, so we have to mark functions that &lt;em&gt;may suspend&lt;/em&gt; explicitly in the code. We use the &lt;code&gt;suspend&lt;/code&gt; modifier for it:</source>
          <target state="translated">それが何を意味するかを少し掘り下げましょう。コルーチンの最大のメリットは、スレッドをブロックせずに&lt;em&gt;中断&lt;/em&gt;できることです。これを可能にするには、コンパイラーが特別なコードを発行する必要があるため、コード内で明示的に&lt;em&gt;中断さ&lt;/em&gt;れる&lt;em&gt;可能性のある&lt;/em&gt;関数をマークする必要&lt;em&gt;が&lt;/em&gt;あります。そのために &lt;code&gt;suspend&lt;/code&gt; 修飾子を使用します。</target>
        </trans-unit>
        <trans-unit id="b909fa7b179bbce71ededd8361a6bf68ecb8e547" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code you get a new function with &lt;code&gt;suspend&lt;/code&gt; modifier. That is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions, like &lt;code&gt;delay&lt;/code&gt; in this example, to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 内のコードのブロックを別の関数に抽出してみましょう。このコードで「関数の抽出」リファクタリングを実行すると、 &lt;code&gt;suspend&lt;/code&gt; 修飾子を持つ新しい関数が得られます。これが最初の&lt;em&gt;一時停止機能&lt;/em&gt;です。一時停止関数は、通常の関数と同じようにコルーチン内で使用できますが、追加機能として、この例の &lt;code&gt;delay&lt;/code&gt; などの他の一時停止関数を使用して、コルーチンの実行を&lt;em&gt;一時停止でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e7122eef62315ddd178e19521346dcd7b3d4f4ef" translate="yes" xml:space="preserve">
          <source>Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before new files are added.</source>
          <target state="translated">まず、プロジェクトフォルダを作成しましょう。このチュートリアルのすべてのパスは、このフォルダからの相対パスになります。時々、新しいファイルを追加する前に不足しているディレクトリを作成しなければならないことがあります。</target>
        </trans-unit>
        <trans-unit id="8cb38e1408559447345a86b525296d1eabcbbd05" translate="yes" xml:space="preserve">
          <source>Let's get straight to the point - type this into a file with the extension &lt;code&gt;.kt&lt;/code&gt;:</source>
          <target state="translated">ポイントにまっすぐに行きましょう-これを拡張子 &lt;code&gt;.kt&lt;/code&gt; のファイルに入力します：</target>
        </trans-unit>
        <trans-unit id="bd86f7e49e4cf62602c569422996655dedc19452" translate="yes" xml:space="preserve">
          <source>Let's include the dependency from the &lt;code&gt;SharedCode&lt;/code&gt; project to the Android project. We need to patch the &lt;code&gt;app/build.gradle&lt;/code&gt; file and include the following line into the &lt;code&gt;dependencies { .. }&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;SharedCode&lt;/code&gt; プロジェクトからAndroidプロジェクトへの依存関係を含めましょう。 &lt;code&gt;app/build.gradle&lt;/code&gt; ファイルにパッチを適用し、次の行を &lt;code&gt;dependencies { .. }&lt;/code&gt; ブロックに含める必要があります。</target>
        </trans-unit>
        <trans-unit id="3031affd63f3a34c70e027c9fb0083b3841cbbd1" translate="yes" xml:space="preserve">
          <source>Let's look at &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; which is implemented in an external library, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt;:</source>
          <target state="translated">外部ライブラリ&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutinesに&lt;/a&gt;実装され &lt;code&gt;await&lt;/code&gt; いる &lt;code&gt;async&lt;/code&gt; / awaitを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="957a84aa6afafd513ebe49ba72fc204fd5a6b335" translate="yes" xml:space="preserve">
          <source>Let's look at a full program that uses &lt;code&gt;launch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;launch&lt;/code&gt; を使用する完全なプログラムを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4e571fdb95d6ede65232f8b540598b12acfcf120" translate="yes" xml:space="preserve">
          <source>Let's look over it to spot what has changed. In Java you annotated the field, binding it with the corresponding view:</source>
          <target state="translated">何が変わったのかを見てみましょう。Javaでは、フィールドにアノテーションを付け、対応するビューにバインドしていました。</target>
        </trans-unit>
        <trans-unit id="1fb40ced67af4648c46e396667df192d29c4d5c8" translate="yes" xml:space="preserve">
          <source>Let's make sure we can run the application on the iPhone emulator or device.</source>
          <target state="translated">iPhoneのエミュレータやデバイスでアプリを実行できることを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="4c1369d1fff2907e87dbe0e51a95a4a2b1d68308" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">sourcesファイルをプロジェクトの &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーに移動します。これは、&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインが使用されている場合の、ソースが配置されているデフォルトのパスです。次のブロックを使用して、動的または共有ライブラリを生成するようにプロジェクトを構成します。</target>
        </trans-unit>
        <trans-unit id="684a72371b803184f7a1d16df5fdf49dd7a6a0de" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">sourcesファイルをプロジェクトの &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; フォルダーに移動します。これは、&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;プラグインを使用する場合の、ソースが配置されるデフォルトのパスです。次のブロックを使用して、動的または共有ライブラリを生成するようにプロジェクトに指示および構成します。</target>
        </trans-unit>
        <trans-unit id="a942f64f48ea1ece8880513eaa81ddefeb619b0a" translate="yes" xml:space="preserve">
          <source>Let's replace &lt;code&gt;testSolution()&lt;/code&gt; function content with the following:</source>
          <target state="translated">&lt;code&gt;testSolution()&lt;/code&gt; 関数の内容を次のように置き換えます。</target>
        </trans-unit>
        <trans-unit id="4a173594d073c26a036c43463ffde9097189a153" translate="yes" xml:space="preserve">
          <source>Let's run a lot of them</source>
          <target state="translated">たくさん走らせましょう</target>
        </trans-unit>
        <trans-unit id="4b01757c4af3890b2686d482b6ad16159167a6f9" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradleタスクを実行&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;して、IDEで&lt;/a&gt;ライブラリをビルドするか、次のコンソールコマンドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="ced335cd9fa401cb82913f0326e2577c06919225" translate="yes" xml:space="preserve">
          <source>Let's say that you're writing a simple ORM. Your database library represents a row as instances of a class &lt;code&gt;Entity&lt;/code&gt;, with functions like &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; and &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; for getting typed values from the given columns. We could create a typed wrapper class like this:</source>
          <target state="translated">単純なORMを作成しているとしましょう。データベースライブラリは、行をクラス &lt;code&gt;Entity&lt;/code&gt; のインスタンスとして表し、指定された列から型付き値を取得するための &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; や &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; などの関数を備えています。次のような型付きラッパークラスを作成できます。</target>
        </trans-unit>
        <trans-unit id="a18f6d560df8733728d2795ff272c64a409b9516" translate="yes" xml:space="preserve">
          <source>Let's say we need to return two things from a function. For example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;data class&lt;/em&gt;&lt;/a&gt; and return its instance:</source>
          <target state="translated">関数から2つのものを返す必要があるとしましょう。たとえば、結果オブジェクトとある種のステータス。Kotlinでこれを行うコンパクトな方法は、&lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;データクラス&lt;/em&gt;&lt;/a&gt;を宣言してそのインスタンスを返すことです。</target>
        </trans-unit>
        <trans-unit id="8eba6223ee182cc016df2825ffe27a1806c3d5dd" translate="yes" xml:space="preserve">
          <source>Let's see how &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are mapped to Objective-C and Swift. The generated &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; file contains the exact definitions for &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; と &lt;code&gt;object&lt;/code&gt; がどのようにObjective-CとSwiftにマッピングされるか見てみましょう。生成された &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; ファイルには、 &lt;code&gt;Class&lt;/code&gt; 、 &lt;code&gt;Interface&lt;/code&gt; 、および &lt;code&gt;Object&lt;/code&gt; の正確な定義が含まれています。</target>
        </trans-unit>
        <trans-unit id="2abb7f43d07915bd385a08f6f8eca1904f202535" translate="yes" xml:space="preserve">
          <source>Let's see now &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; is turned to a pointer first:</source>
          <target state="translated">&lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; がポインターに変わっているところを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0da8a1853bc3aa9296a82e748b06afcd60c8ff39" translate="yes" xml:space="preserve">
          <source>Let's summarize what we have in the table:</source>
          <target state="translated">表にあるものをまとめてみましょう。</target>
        </trans-unit>
        <trans-unit id="29489a663f002abc7aabbc10da61ddf3922c9137" translate="yes" xml:space="preserve">
          <source>Let's switch back to the Android Studio and execute the &lt;code&gt;build&lt;/code&gt; target of the &lt;code&gt;SharedCode&lt;/code&gt; project from the &lt;em&gt;Gradle&lt;/em&gt; tool window. The task looks for environment variables set by the Xcode build and copies the right variant of the framework into the &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; folder. We then include the framework from that folder into the build</source>
          <target state="translated">Android Studioに切り替えて、&lt;em&gt;Gradle&lt;/em&gt;ツールウィンドウから &lt;code&gt;SharedCode&lt;/code&gt; プロジェクトの &lt;code&gt;build&lt;/code&gt; ターゲットを実行します。タスクは、Xcodeビルドによって設定された環境変数を探し、フレームワークの適切なバリアントを &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; フォルダーにコピーします。次に、そのフォルダーのフレームワークをビルドに含めます&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5c06386e1b74a742a7f7576c52eff2fd2031ee" translate="yes" xml:space="preserve">
          <source>Let's take a look at Kotlin runtime declarations first:</source>
          <target state="translated">まずはKotlinのランタイム宣言を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0d3a04db62b13c25688a0e50c618e3bec15eb02a" translate="yes" xml:space="preserve">
          <source>Let's take a look at a concrete example.</source>
          <target state="translated">具体的な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d83be9a947c4ef371bac95dfdb52ba3f51a09f86" translate="yes" xml:space="preserve">
          <source>Let's take a look at the &lt;code&gt;kotlin.root.example&lt;/code&gt; field, it mimics the package structure of our Kotlin code with a &lt;code&gt;kotlin.root.&lt;/code&gt; prefix.</source>
          <target state="translated">&lt;code&gt;kotlin.root.example&lt;/code&gt; フィールドを見てみましょう &lt;code&gt;kotlin.root.&lt;/code&gt; は、kotlin.rootを使用してKotlinコードのパッケージ構造を模倣しています。接頭辞。</target>
        </trans-unit>
        <trans-unit id="7a1c41eab269c88a145c3bcd2eacac0f706a1202" translate="yes" xml:space="preserve">
          <source>Let's take a look at the difference between &lt;code&gt;Iterable&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; with an example.</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; と &lt;code&gt;Sequence&lt;/code&gt; の違いを例で見てみましょう。</target>
        </trans-unit>
        <trans-unit id="683ff410a92468b732cdb32c98685fb25b7caa78" translate="yes" xml:space="preserve">
          <source>Let's take a look at the generated functions that take our &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; as parameters. We see that by-value parameters are represented as &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt;. And for typed pointer parameters we see &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt;. Kotlin provides us with an API to deal with both types easily, let's try it and see.</source>
          <target state="translated">&lt;code&gt;MyStruct&lt;/code&gt; と &lt;code&gt;MyUnion&lt;/code&gt; をパラメーターとして取る生成された関数を見てみましょう。値 &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt; パラメーターがkotlinx.cinterop.CValue &amp;lt;T&amp;gt;として表されていることがわかります。また、型付きポインターパラメーターの場合、 &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; 表示されます。Kotlinは、両方のタイプを簡単に処理するためのAPIを提供しています。試して見てみましょう。</target>
        </trans-unit>
        <trans-unit id="640f277dd088f13964789f8075c590d21d6b9dfc" translate="yes" xml:space="preserve">
          <source>Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</source>
          <target state="translated">パイプラインを極端にして、コアーチンのパイプラインを使って素数を生成する例を挙げてみましょう。まず、無限の数列から始めます。</target>
        </trans-unit>
        <trans-unit id="3a85f4e1e0328af1a77f3960a6412ca2106e30f9" translate="yes" xml:space="preserve">
          <source>Let's try the same with coroutines:</source>
          <target state="translated">コルチンでも同じようにやってみましょう。</target>
        </trans-unit>
        <trans-unit id="7edcd7d839fe1e0dfdcd3a0fe161ec6c231e6fb0" translate="yes" xml:space="preserve">
          <source>Let's try to use the API from Kotlin. Let's call &lt;code&gt;pass_string&lt;/code&gt; first:</source>
          <target state="translated">KotlinのAPIを使ってみましょう。最初に &lt;code&gt;pass_string&lt;/code&gt; を呼び出しましょう：</target>
        </trans-unit>
        <trans-unit id="0627f0965e7ec33cbf1e065c2d05108d4f888350" translate="yes" xml:space="preserve">
          <source>Let's update the Gradle scripts now to implement that and configure our IDE.</source>
          <target state="translated">それでは、Gradleスクリプトを更新して実装し、IDEを設定してみましょう。</target>
        </trans-unit>
        <trans-unit id="cd1102ed7118f5a51e4a3d98942ad07717eaabd4" translate="yes" xml:space="preserve">
          <source>Let's use it with channel &lt;code&gt;a&lt;/code&gt; that produces &quot;Hello&quot; string four times and channel &lt;code&gt;b&lt;/code&gt; that produces &quot;World&quot; four times:</source>
          <target state="translated">チャネルで使用してみましょう &lt;code&gt;a&lt;/code&gt; 「こんにちは」の文字列の4倍とチャネル生成 &lt;code&gt;b&lt;/code&gt; 4回「世界」を生成します。</target>
        </trans-unit>
        <trans-unit id="9dbe6646e8e9a0c1dd5558c986bbdc08c0c317a1" translate="yes" xml:space="preserve">
          <source>Let's walk through the interfaces and their implementations.</source>
          <target state="translated">インターフェイスとその実装を見ていきましょう。</target>
        </trans-unit>
        <trans-unit id="83d65fd8bdf3a04f906b52d7b1ba67e299c6332e" translate="yes" xml:space="preserve">
          <source>Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, &lt;code&gt;HTML&lt;/code&gt; is a class that describes the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag, i.e. it defines children like &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. (See its declaration &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">Kotlinでタイプセーフなビルダーを実装するメカニズムを見ていきましょう。最初に、構築するモデルを定義する必要があります。この場合は、HTMLタグをモデル化する必要があります。たくさんのクラスで簡単にできます。たとえば、 &lt;code&gt;HTML&lt;/code&gt; は &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; タグを記述するクラスです。つまり、 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; や &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; などの子を定義します。（&lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;以下の&lt;/a&gt;宣言を参照してください。）</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="74fbbbbc56ff7a0c7c22c830abedb5e3565e5058" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and @Experimental annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">ライブラリの作者は、@Deprecatedアノテーションと@Experimentalアノテーションを使用して、API表面の進化を制御することができます。Deprecated(level=HIDDEN)は、APIから削除された宣言に対してもバイナリ互換性を維持するために使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0405ca8057bdd26aa8a71ed5b78eaef11cd20a80" translate="yes" xml:space="preserve">
          <source>Library code should always specify return types of public/protected functions and properties explicitly thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</source>
          <target state="translated">ライブラリコードでは、公開/保護された関数やプロパティの戻り値の型を常に明示的に指定しなければなりませんので、公開APIの型推論には決して依存しません。型推論の微妙な変更は、うっかりリターン型を変更してしまい、バイナリ互換性の問題につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2fc01b5cc1b2ec00feddd7cb533ccfb023b55321" translate="yes" xml:space="preserve">
          <source>Library search sequence</source>
          <target state="translated">ライブラリ検索シーケンス</target>
        </trans-unit>
        <trans-unit id="141acdd651d31f900ce141517e6e5b768c6f9865" translate="yes" xml:space="preserve">
          <source>Library support for the Kotlin annotation facility.</source>
          <target state="translated">Kotlin注釈機能のライブラリサポート。</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache License,Version 2.0の下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="8ca0dc8586d3cb640a4422d4f36e3b18f79a2fc2" translate="yes" xml:space="preserve">
          <source>Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; is indistinguishable from &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt;. This makes it impossible to perform &lt;em&gt;is&lt;/em&gt;-checks that take generics into account. Kotlin only allows &lt;em&gt;is&lt;/em&gt;-checks for star-projected generic types:</source>
          <target state="translated">Javaと同様に、Kotlinのジェネリックは実行時に保持されません。つまり、オブジェクトはコンストラクターに渡される実際の型引数に関する情報を保持しません。つまり、 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; は &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt; と区別できません。これにより、ジェネリックを考慮した&lt;em&gt;is&lt;/em&gt;チェックを実行できなくなります。Kotlinでは、スター投影されたジェネリック型の&lt;em&gt;is&lt;/em&gt; -checks のみ&lt;em&gt;が&lt;/em&gt;許可されます。</target>
        </trans-unit>
        <trans-unit id="134fca0c09908f36860692b90dc834d35d2666e9" translate="yes" xml:space="preserve">
          <source>Like in Python, functions in Kotlin are first-class values - they can be assigned to variables and passed around as parameters. The type a function is a &lt;em&gt;function type&lt;/em&gt;, which is indicated with a parenthesized parameter type list and an arrow to the return type. Consider this function:</source>
          <target state="translated">Pythonと同様に、Kotlinの関数は一流の値です。変数に割り当てて、パラメーターとして渡すことができます。&lt;em&gt;関数の型&lt;/em&gt;は&lt;em&gt;関数の型&lt;/em&gt;であり、括弧で囲まれたパラメーターの型リストと戻り値の型への矢印で示されます。この関数を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="4ddd56354c9749dcb1f4e69de6ab93bcbbe060ca" translate="yes" xml:space="preserve">
          <source>Like in Python, statements may be terminated by a semicolon, but it's discouraged. There is no line continuation character; instead, a line is automatically joined with one or more of the subsequent lines if that's the only way to make the code parse correctly. In practice, that means that a statement continues on the next line if we're inside an open parenthesis (like in Python), or if the line ends with a &quot;dangling operator&quot; (unlike in Python) or the following line doesn't parse unless it's joined to the previous one (also unlike in Python). Note that this is pretty much &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;the opposite of JavaScript&lt;/a&gt;, which generally will keep joining lines as long as the resulting code still parses. Thus, the following is two expressions in Kotlin and in Python (because &lt;code&gt;+&lt;/code&gt; can be unary, so the second line parses on its own), but one in JavaScript:</source>
          <target state="translated">Pythonと同様に、ステートメントはセミコロンで終了する場合がありますが、お勧めしません。行継続文字はありません。代わりに、コードを正しく解析する唯一の方法である場合、行は後続の1つ以上の行と自動的に結合されます。実際には、それは、（Pythonのように）開き括弧の中にいる場合、または行が「ダングリングオペレーター」で終わる場合（Pythonの場合とは異なります）、または次の行が次の行にない場合、ステートメントが次の行に続くことを意味します。前のものに結合されていない限り解析します（これもPythonとは異なります）。これは&lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;JavaScriptの反対で&lt;/a&gt;あることに注意してください。JavaScriptは通常、結果のコードが解析される限り、行を結合し続けます。したがって、以下はKotlinとPythonの2つの式です（ &lt;code&gt;+&lt;/code&gt; 単項の場合もあるため、2行目は単独で解析されますが、JavaScriptでは1行です。</target>
        </trans-unit>
        <trans-unit id="36d262d6365f0d350e9446c742577b066fb40895" translate="yes" xml:space="preserve">
          <source>Like in Python, you can write &lt;em&gt;lambda expressions&lt;/em&gt;: unnamed function declarations with a very compact syntax, which evaluate to callable function objects. In Kotlin, lambdas can contain multiple statements, which make them useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;more complex tasks&lt;/a&gt; than the single-expression lambdas of Python. The last statement must be an expression, whose result will become the return value of the lambda (unless &lt;code&gt;Unit&lt;/code&gt; is the return type of the variable/parameter that the lambda expression is assigned to, in which case the lambda has no return value). A lambda expression is enclosed in curly braces, and begins by listing its parameter names and possibly their types (unless the types can be inferred from context):</source>
          <target state="translated">Pythonの場合と同様に、&lt;em&gt;ラムダ式&lt;/em&gt;を記述できます。非常にコンパクトな構文を使用した名前のない関数宣言であり、呼び出し可能な関数オブジェクトとして評価されます。Kotlinでは、ラムダに複数のステートメントを含めることができるため、Pythonの単一式ラムダよりも&lt;a href=&quot;functional-programming#receivers&quot;&gt;複雑なタスクに&lt;/a&gt;役立ちます。最後のステートメントは式である必要があり、その結果はラムダの戻り値になります（ただし、 &lt;code&gt;Unit&lt;/code&gt; がラムダ式が割り当てられている変数/パラメーターの戻り値の型である場合を除きます。この場合、ラムダには戻り値がありません）。ラムダ式は中括弧で囲まれ、パラメーター名と場合によってはそれらのタイプをリストすることから始まります（コンテキストからタイプを推測できない場合）。</target>
        </trans-unit>
        <trans-unit id="4ee83e74db24116986fa00ee2921b9703634e255" translate="yes" xml:space="preserve">
          <source>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</source>
          <target state="translated">数字と同様に、文字はヌル可能な参照が必要な場合には箱詰めされます。箱詰めの操作では同一性は保持されません。</target>
        </trans-unit>
        <trans-unit id="dc3b674f534270e494afa035103eb57b636704df" translate="yes" xml:space="preserve">
          <source>Likewise, if a multiplatform library is published in the experimental &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle metadata publishing mode&lt;/a&gt; and the project is set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. Otherwise, each platform-specific source set should be provided with a corresponding platform module of the library, in addition to the common module, as shown above.</source>
          <target state="translated">同様に、マルチプラットフォームライブラリが試験的な&lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradleメタデータ公開モードで&lt;/a&gt;公開され、プロジェクトがメタデータも使用するように設定されている場合、共通のソースセットに対して依存関係を1回だけ指定するだけで十分です。それ以外の場合は、上記のように、各プラットフォーム固有のソースセットに、共通モジュールに加えて、ライブラリの対応するプラットフォームモジュールを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f8233d6f380a149df94d518228f2e14afd396052" translate="yes" xml:space="preserve">
          <source>Linear search</source>
          <target state="translated">線形検索</target>
        </trans-unit>
        <trans-unit id="b867f8dc43342a216856620ba5a0d8c96b534757" translate="yes" xml:space="preserve">
          <source>Link the library into the application</source>
          <target state="translated">ライブラリをアプリケーションにリンクする</target>
        </trans-unit>
        <trans-unit id="0084b300581a4369f50268c2c401f96431ea7f31" translate="yes" xml:space="preserve">
          <source>LinkStyle</source>
          <target state="translated">LinkStyle</target>
        </trans-unit>
        <trans-unit id="07410b317023eeb58eba0c065fa4e8416575a68f" translate="yes" xml:space="preserve">
          <source>LinkedHashMap</source>
          <target state="translated">LinkedHashMap</target>
        </trans-unit>
        <trans-unit id="9e6a957a7c69081b233af13d7e01702499988584" translate="yes" xml:space="preserve">
          <source>LinkedHashSet</source>
          <target state="translated">LinkedHashSet</target>
        </trans-unit>
        <trans-unit id="778915b1ca69b860077b72be4fd2810162ac2e59" translate="yes" xml:space="preserve">
          <source>Linking to Elements</source>
          <target state="translated">要素へのリンク</target>
        </trans-unit>
        <trans-unit id="ff0484f6287dafcb08eb0a886ac73a7153824af7" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, MIPS, MIPS little endian, Raspberry Pi)</source>
          <target state="translated">Linux (x86_64,arm32,MIPS,MIPSリトルエンディアン,Raspberry Pi)</target>
        </trans-unit>
        <trans-unit id="430e92ad771f5c7d80b45e64d2d47aa39cd97e1b" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host. Other Linux targets can be built on any supported host;</source>
          <target state="translated">Linux MIPSターゲット（ &lt;code&gt;linuxMips32&lt;/code&gt; および &lt;code&gt;linuxMipsel32&lt;/code&gt; ）にはLinuxホストが必要です。その他のLinuxターゲットは、サポートされている任意のホスト上に構築できます。</target>
        </trans-unit>
        <trans-unit id="bfb299cccd6e6b52b05aad6a92f9e230c0c907cf" translate="yes" xml:space="preserve">
          <source>Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; and &lt;code&gt;libnative.so&lt;/code&gt;</source>
          <target state="translated">Linux： &lt;code&gt;libnative_api.h&lt;/code&gt; および &lt;code&gt;libnative.so&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="1cf922153258f477bc71540c57fe2b01a501cd22" translate="yes" xml:space="preserve">
          <source>List Specific Operations</source>
          <target state="translated">特定の操作をリストアップ</target>
        </trans-unit>
        <trans-unit id="a159771f6ea4355d13f8450d01c0373e1562c782" translate="yes" xml:space="preserve">
          <source>List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and &lt;a href=&quot;equality#structural-equality&quot;&gt;structurally equal&lt;/a&gt; elements at the same positions.</source>
          <target state="translated">リスト要素（nullを含む）は複製できます。リストには、任意の数の同じオブジェクトまたは単一のオブジェクトのオカレンスを含めることができます。2つのリストは、同じサイズで同じ位置に&lt;a href=&quot;equality#structural-equality&quot;&gt;構造的に等しい&lt;/a&gt;要素がある場合、等しいと見なされます。</target>
        </trans-unit>
        <trans-unit id="06c25d6b7dd57683933b41c5deaf09d2d0ac5990" translate="yes" xml:space="preserve">
          <source>List iterators</source>
          <target state="translated">リストイテレータ</target>
        </trans-unit>
        <trans-unit id="18c411381841a95d683318d92c209a2833825015" translate="yes" xml:space="preserve">
          <source>List write operations</source>
          <target state="translated">リスト書き込み操作</target>
        </trans-unit>
        <trans-unit id="7c5f57edf1aaa5196cbc6ba79770c80aef15f3e5" translate="yes" xml:space="preserve">
          <source>List.listIterator</source>
          <target state="translated">List.listIterator</target>
        </trans-unit>
        <trans-unit id="48fb7de1e7f4ec62a77ab4aa73ec82916ebe8c3e" translate="yes" xml:space="preserve">
          <source>ListIterator</source>
          <target state="translated">ListIterator</target>
        </trans-unit>
        <trans-unit id="a204aa282b7f9617db30e92246b8efaf427d19cd" translate="yes" xml:space="preserve">
          <source>Lists also offer a function to replace an element at a given position - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and its operator form &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;set()&lt;/code&gt; doesn't change the indexes of other elements.</source>
          <target state="translated">リストは、指定された位置にある要素を置き換える関数も提供します-set &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt;とその演算子形式 &lt;code&gt;[]&lt;/code&gt; 。 &lt;code&gt;set()&lt;/code&gt; は他の要素のインデックスを変更しません。</target>
        </trans-unit>
        <trans-unit id="290d0482de491a9f1d45c4e717b747b40f336dfe" translate="yes" xml:space="preserve">
          <source>Lists and sets also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">リストとセットは、要素を更新するための操作も提供します。これらについては、&lt;a href=&quot;list-operations&quot;&gt;リスト固有の操作&lt;/a&gt;と&lt;a href=&quot;map-operations&quot;&gt;マップ固有の操作で説明してい&lt;/a&gt;ます。セットの場合、更新は実際には要素を削除して別の要素を追加するため、意味がありません。</target>
        </trans-unit>
        <trans-unit id="f70b0e65f09114560be2730b53b6dbbae2e2bd80" translate="yes" xml:space="preserve">
          <source>Lists support all common operations for element retrieval: &lt;code&gt;elementAt()&lt;/code&gt;, &lt;code&gt;first()&lt;/code&gt;, &lt;code&gt;last()&lt;/code&gt;, and others listed in &lt;a href=&quot;collection-elements&quot;&gt;Retrieving Single Elements&lt;/a&gt;. What is specific for lists is index access to the elements, so the simplest way to read an element is retrieving it by index. That is done with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; function with the index passed in the argument or the shorthand &lt;code&gt;[index]&lt;/code&gt; syntax.</source>
          <target state="translated">リストは、要素取得のすべての一般的な操作をサポートします &lt;code&gt;elementAt()&lt;/code&gt; 、 &lt;code&gt;first()&lt;/code&gt; 、 &lt;code&gt;last()&lt;/code&gt; 、および&lt;a href=&quot;collection-elements&quot;&gt;単一要素の取得に&lt;/a&gt;リストされているその他の操作です。リストに固有なのは要素へのインデックスアクセスであるため、要素を読み取る最も簡単な方法は、インデックスによって要素を取得することです。これは、引数で渡されたインデックスを使用した&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;関数または短縮形の &lt;code&gt;[index]&lt;/code&gt; 構文で行われます。</target>
        </trans-unit>
        <trans-unit id="1b8cc7b0ac11bf88cf97ed5fc81444ae44893988" translate="yes" xml:space="preserve">
          <source>Literal Constants</source>
          <target state="translated">リテラル定数</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="a354c605a19a501459267f5d2d15e3813a2622ea" translate="yes" xml:space="preserve">
          <source>Local Delegated Properties (since 1.1)</source>
          <target state="translated">ローカル委任プロパティ (1.1 以降)</target>
        </trans-unit>
        <trans-unit id="f5689c7ad8ad393161f3aa4e09dcfcbe8dae0b7c" translate="yes" xml:space="preserve">
          <source>Local Functions</source>
          <target state="translated">ローカル機能</target>
        </trans-unit>
        <trans-unit id="d7250510c8081d4daaa6df727eb914db9c33da3c" translate="yes" xml:space="preserve">
          <source>Local annotation classes</source>
          <target state="translated">ローカルアノテーションクラス</target>
        </trans-unit>
        <trans-unit id="69ebd822a58983be422bb598dba3c478ccd777d9" translate="yes" xml:space="preserve">
          <source>Local declarations</source>
          <target state="translated">ローカル宣言</target>
        </trans-unit>
        <trans-unit id="a1899e5981d8e839cbbac5a4b6b87631ee259818" translate="yes" xml:space="preserve">
          <source>Local delegated properties</source>
          <target state="translated">ローカルデリゲートされたプロパティ</target>
        </trans-unit>
        <trans-unit id="bcdcbb7562bc0be9df365ffa539169787154eb55" translate="yes" xml:space="preserve">
          <source>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the &lt;em&gt;visited&lt;/em&gt; can be a local variable:</source>
          <target state="translated">ローカル関数は外部関数のローカル変数（つまり、クロージャ）にアクセスできるため、上記の場合、&lt;em&gt;visited&lt;/em&gt;はローカル変数になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7a8cbb48d88b807f7bfba9d309d29524b5f02383" translate="yes" xml:space="preserve">
          <source>Local variable</source>
          <target state="translated">ローカル変数</target>
        </trans-unit>
        <trans-unit id="e41667e2ac3ba5cde0fdffb1b6bacda9d66718d9" translate="yes" xml:space="preserve">
          <source>Local variables are typically declared and initialized at the same time, in which case the type of the variable is &lt;em&gt;inferred&lt;/em&gt; to be the type of the expression you initialize it with:</source>
          <target state="translated">通常、ローカル変数は同時に宣言および初期化されます。その場合、変数のタイプは、初期化する式のタイプであると&lt;em&gt;推定さ&lt;/em&gt;れます。</target>
        </trans-unit>
        <trans-unit id="ac8a58b4422a8352e1dd6a3c1ee5296717d9a865" translate="yes" xml:space="preserve">
          <source>Local variables, functions and classes can not have visibility modifiers.</source>
          <target state="translated">ローカル変数、関数、クラスは可視性修飾子を持つことができません。</target>
        </trans-unit>
        <trans-unit id="a78aea5b0abb85e3e611fbf1ec8a29dd64f3f7a3" translate="yes" xml:space="preserve">
          <source>LocaleOptions</source>
          <target state="translated">LocaleOptions</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="4a56ee9bffd6aa6b4bd69f9a8fcf34ef4736447e" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">ロックは、単一のスレッドのみが&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;インスタンスを初期化できるようにするために使用されます。</target>
        </trans-unit>
        <trans-unit id="0003a9c1d32ac7d8fddd983e062e51e3d0daa934" translate="yes" xml:space="preserve">
          <source>Logarithms: &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;ln&lt;/code&gt;, &lt;code&gt;ln1p&lt;/code&gt;;</source>
          <target state="translated">対数： &lt;code&gt;log&lt;/code&gt; 、 &lt;code&gt;log2&lt;/code&gt; 、 &lt;code&gt;log10&lt;/code&gt; の、 &lt;code&gt;ln&lt;/code&gt; 、 &lt;code&gt;ln1p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3496a775372b202cf19086b7723a8ba07a1c1c15" translate="yes" xml:space="preserve">
          <source>Logos can be downloaded &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;here&lt;/a&gt;. When using the logos, please follow simple rules in the &lt;code&gt;guidelines.pdf&lt;/code&gt; inside the archive and &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin brand usage guidelines&lt;/a&gt;.</source>
          <target state="translated">ロゴは&lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;ここから&lt;/a&gt;ダウンロードできます。ロゴを使用するときは、アーカイブ内の &lt;code&gt;guidelines.pdf&lt;/code&gt; の簡単なルールと&lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlinブランドの使用ガイドラインに&lt;/a&gt;従ってください。</target>
        </trans-unit>
        <trans-unit id="3171584f38872fa4d8f17811d91544f7756eaffd" translate="yes" xml:space="preserve">
          <source>Lombok (&lt;code&gt;lombok.NonNull&lt;/code&gt;).</source>
          <target state="translated">ロンボク（ &lt;code&gt;lombok.NonNull&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="28da0e058738129fbcd7e6f45b76bc71f8a53660" translate="yes" xml:space="preserve">
          <source>LongArray</source>
          <target state="translated">LongArray</target>
        </trans-unit>
        <trans-unit id="4fccaadf63b5fc52428c158f51d57e23e947d24e" translate="yes" xml:space="preserve">
          <source>LongIterator</source>
          <target state="translated">LongIterator</target>
        </trans-unit>
        <trans-unit id="5845d554e07454310db9770fb728d9756ce6dae1" translate="yes" xml:space="preserve">
          <source>LongProgression</source>
          <target state="translated">LongProgression</target>
        </trans-unit>
        <trans-unit id="4fb8ec4ef48e7913a58002b0e63b73c29bff9f39" translate="yes" xml:space="preserve">
          <source>LongRange</source>
          <target state="translated">LongRange</target>
        </trans-unit>
        <trans-unit id="0b1c8c87dc520b4e01071e91d1f6a9ceb7e0e408" translate="yes" xml:space="preserve">
          <source>LongVar</source>
          <target state="translated">LongVar</target>
        </trans-unit>
        <trans-unit id="181cf892b1895d898b9744877c740407129f49dc" translate="yes" xml:space="preserve">
          <source>LongVarOf</source>
          <target state="translated">LongVarOf</target>
        </trans-unit>
        <trans-unit id="fd6299f672ee9cc3b8def57411eb0d0d9a44147d" translate="yes" xml:space="preserve">
          <source>Longs are tagged by a capital &lt;code&gt;L&lt;/code&gt;: &lt;code&gt;123L&lt;/code&gt;</source>
          <target state="translated">Longは大文字の &lt;code&gt;L&lt;/code&gt; でタグ付けされています： &lt;code&gt;123L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e38e907fc0523189431e466a50de278a09267fc" translate="yes" xml:space="preserve">
          <source>Looking for more APIs? It is easy to create a &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt; and share it!</source>
          <target state="translated">他のAPIをお探しですか？&lt;a href=&quot;../multiplatform-library&quot;&gt;マルチプラットフォームライブラリ&lt;/a&gt;を作成して共有するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="0c661eae6b65f74e27c40369060777e2f1a666bd" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;inc()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters, applicable to the receiver of type &lt;code&gt;T&lt;/code&gt;;</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のレシーバーに適用可能な、 &lt;code&gt;operator&lt;/code&gt; 修飾子を使用してパラメーターを指定せずに関数 &lt;code&gt;inc()&lt;/code&gt; を検索します。</target>
        </trans-unit>
        <trans-unit id="06f3cb08bca38254cb72407f33d24848ac5110e5" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;unaryPlus()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters for the receiver &lt;code&gt;T&lt;/code&gt;, i.e. a member function or an extension function;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; 修飾子を使用し、レシーバー &lt;code&gt;T&lt;/code&gt; のパラメーターを持たない関数 &lt;code&gt;unaryPlus()&lt;/code&gt; を検索します（メンバー関数または拡張関数など）。</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4c2bd8b7625ef46e049dcc97f3e97069511fe26a" translate="yes" xml:space="preserve">
          <source>Loops on ranges</source>
          <target state="translated">レンジのループ</target>
        </trans-unit>
        <trans-unit id="60369ad7d8b48a14f3d191172cf41bcfb71741f2" translate="yes" xml:space="preserve">
          <source>Low-level building blocks for libraries that provide coroutine-based APIs.</source>
          <target state="translated">コアラインベースのAPIを提供するライブラリのための低レベルのビルディングブロック。</target>
        </trans-unit>
        <trans-unit id="33c64772edef0388f14ce1b4adb0c6c1bb1aa8e4" translate="yes" xml:space="preserve">
          <source>Luckily, Kotlin has got &lt;em&gt;reified type parameters&lt;/em&gt;, which alleviates some of these problems. By writing &lt;code&gt;reified&lt;/code&gt; in front of a generic type parameter, it does become available at runtime, and you'll get to write &lt;code&gt;T::class&lt;/code&gt; to get the &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;class metadata&lt;/a&gt;. You can only do this in inline functions (because an inline function will be compiled into its callsite, where the type information &lt;em&gt;is&lt;/em&gt; available at runtime), but it still goes a long way. For example, you can make an inline wrapper function for a big function that has got a less elegant signature.</source>
          <target state="translated">幸いなことに、Kotlinには、これらの問題のいくつかを軽減する&lt;em&gt;具体化された型パラメーター&lt;/em&gt;があります。ジェネリック型パラメーターの前に &lt;code&gt;reified&lt;/code&gt; を書き込むと、実行時に使用可能になり、&lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;クラスメタデータ&lt;/a&gt;を取得するために &lt;code&gt;T::class&lt;/code&gt; を書き込むことができます。これはインライン関数でのみ実行できます（インライン関数は、実行時に型情報&lt;em&gt;が&lt;/em&gt;利用できるコールサイトにコンパイルされるため）が、それでも長い道のりです。たとえば、あまりエレガントでないシグネチャを持つ大きな関数のインラインラッパー関数を作成できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc6e5580de3bf07607e19a673cd1f05b259b2bd" translate="yes" xml:space="preserve">
          <source>MACOSX</source>
          <target state="translated">MACOSX</target>
        </trans-unit>
        <trans-unit id="c8341a27b6d81ce4872ef2e5c74c71c1fa656185" translate="yes" xml:space="preserve">
          <source>MATH_SYMBOL</source>
          <target state="translated">MATH_SYMBOL</target>
        </trans-unit>
        <trans-unit id="ccd2cb474249294edd8d61576efe0ac7d7c17d4c" translate="yes" xml:space="preserve">
          <source>MAX_CODE_POINT</source>
          <target state="translated">MAX_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="1a9fd1b3912908145111964e328d77ecf366fc06" translate="yes" xml:space="preserve">
          <source>MAX_COMPONENT_VALUE</source>
          <target state="translated">MAX_COMPONENT_VALUE</target>
        </trans-unit>
        <trans-unit id="6a3f20e248cb8672ba053480b2e5604ed15471fb" translate="yes" xml:space="preserve">
          <source>MAX_HIGH_SURROGATE</source>
          <target state="translated">MAX_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="93b95c89e3f09a5c822039fdb274e4e9543f7b4d" translate="yes" xml:space="preserve">
          <source>MAX_LOW_SURROGATE</source>
          <target state="translated">MAX_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="723df4d178ea35581b90fb4dff97fa4d9e1295a6" translate="yes" xml:space="preserve">
          <source>MAX_RADIX</source>
          <target state="translated">MAX_RADIX</target>
        </trans-unit>
        <trans-unit id="e1273ad446270c0c9cf3fd5cad44848e8250ffba" translate="yes" xml:space="preserve">
          <source>MAX_SURROGATE</source>
          <target state="translated">MAX_SURROGATE</target>
        </trans-unit>
        <trans-unit id="24fdbf54e8bc77709b6bd7478c1804e90d84d0ca" translate="yes" xml:space="preserve">
          <source>MAX_VALUE</source>
          <target state="translated">MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="030147a88935a9397a9625c627fb1af71a30209e" translate="yes" xml:space="preserve">
          <source>MF</source>
          <target state="translated">MF</target>
        </trans-unit>
        <trans-unit id="c93eded712b6299da78db6d4eb86c71d455d7389" translate="yes" xml:space="preserve">
          <source>MIN_CODE_POINT</source>
          <target state="translated">MIN_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="a8865ad11853a6b46e09f6d1cdddfd073f7d4851" translate="yes" xml:space="preserve">
          <source>MIN_HIGH_SURROGATE</source>
          <target state="translated">MIN_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="bd2ef64ddf3863a50e14b7b72bf632b54603d300" translate="yes" xml:space="preserve">
          <source>MIN_LOW_SURROGATE</source>
          <target state="translated">MIN_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="91631ed7ebe4f66d93a855f168fd993a18bbb9ae" translate="yes" xml:space="preserve">
          <source>MIN_RADIX</source>
          <target state="translated">MIN_RADIX</target>
        </trans-unit>
        <trans-unit id="ff3ed914be4d85796f20ffe750d11ae41f0c093d" translate="yes" xml:space="preserve">
          <source>MIN_SUPPLEMENTARY_CODE_POINT</source>
          <target state="translated">MIN_SUPPLEMENTARY_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="5aa1c9c7ed6ef1169c3e694d2e0558e797993672" translate="yes" xml:space="preserve">
          <source>MIN_SURROGATE</source>
          <target state="translated">MIN_SURROGATE</target>
        </trans-unit>
        <trans-unit id="ac7a7603646aca67877b81e10b36687c24f7d10a" translate="yes" xml:space="preserve">
          <source>MIN_VALUE</source>
          <target state="translated">MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="9028a909c025cf9d16590fd055950504b793f600" translate="yes" xml:space="preserve">
          <source>MIPS32</source>
          <target state="translated">MIPS32</target>
        </trans-unit>
        <trans-unit id="ac1d1ed5dec64feab585fa1220864d5680a5811e" translate="yes" xml:space="preserve">
          <source>MIPSEL32</source>
          <target state="translated">MIPSEL32</target>
        </trans-unit>
        <trans-unit id="7b5afc2e6529ad3bd8e57a7791978e690003bcdd" translate="yes" xml:space="preserve">
          <source>MODIFIER_LETTER</source>
          <target state="translated">MODIFIER_LETTER</target>
        </trans-unit>
        <trans-unit id="8f6a3829c268c3a50caa5a3744901aba89c88358" translate="yes" xml:space="preserve">
          <source>MODIFIER_SYMBOL</source>
          <target state="translated">MODIFIER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="84757851065b4eb5ddf781037790225276f37d3e" translate="yes" xml:space="preserve">
          <source>MULTILINE</source>
          <target state="translated">MULTILINE</target>
        </trans-unit>
        <trans-unit id="37a6f811775e72996553c62c5ef2ab8e4e658bea" translate="yes" xml:space="preserve">
          <source>MacOS (x86_64)</source>
          <target state="translated">マックオス</target>
        </trans-unit>
        <trans-unit id="07a4d61f0acbbb95318a8a2d2e1f3a3b76934273" translate="yes" xml:space="preserve">
          <source>MacPorts</source>
          <target state="translated">MacPorts</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="c22d87ecdb73737e3e9e79d9b2b16c5c79a06654" translate="yes" xml:space="preserve">
          <source>Make sure its return type is &lt;code&gt;Unit&lt;/code&gt;, and report an error otherwise,</source>
          <target state="translated">戻り値の型が &lt;code&gt;Unit&lt;/code&gt; であることを確認し、それ以外の場合はエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="2fba991ad8d6b5e98b20f4c1f0a7d640d19bbf4f" translate="yes" xml:space="preserve">
          <source>Make sure that you have CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;installed&lt;/a&gt;. We recommend using CocoaPods 1.6.1 or later.</source>
          <target state="translated">CocoaPodsが&lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;インストールされ&lt;/a&gt;ていることを確認してください。CocoaPods 1.6.1以降の使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="872ea4c8c9e3e67462cf45519bbed3ec439a01dd" translate="yes" xml:space="preserve">
          <source>Make sure that you load the &lt;code&gt;kotlin.js&lt;/code&gt; runtime first, and then your application.</source>
          <target state="translated">最初に &lt;code&gt;kotlin.js&lt;/code&gt; ランタイムをロードしてから、アプリケーションをロードしてください。</target>
        </trans-unit>
        <trans-unit id="eb5ad277768300cd65b74ec021eb800da7b06237" translate="yes" xml:space="preserve">
          <source>Make updating to new versions comfortable for the users.</source>
          <target state="translated">新しいバージョンへの更新をユーザーにとって快適なものにします。</target>
        </trans-unit>
        <trans-unit id="f677748d219b353836ae9469d4c8eb0bcdf46ffb" translate="yes" xml:space="preserve">
          <source>Makes Kotlin method in Objective-C class accessible through Objective-C dispatch to be used as action sent by control in UIKit or AppKit.</source>
          <target state="translated">Objective-CクラスのKotlinメソッドをObjective-Cディスパッチでアクセス可能にし、UIKitやAppKitのコントロールから送信されるアクションとして利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="09f808d1435cc07cd95f3ecbee1a2efed0c87454" translate="yes" xml:space="preserve">
          <source>Makes Kotlin property in Objective-C class settable through Objective-C dispatch to be used as IB outlet.</source>
          <target state="translated">Objective-C クラスの Kotlin プロパティを Objective-C ディスパッチで設定できるようにし、IB アウトレットとして使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="79cbb2384899cfe766ce2633e3ff22d2f36982b6" translate="yes" xml:space="preserve">
          <source>Makes Kotlin subclass of Objective-C class visible for runtime lookup after Kotlin &lt;code&gt;main&lt;/code&gt; function gets invoked.</source>
          <target state="translated">Kotlin &lt;code&gt;main&lt;/code&gt; 関数が呼び出された後、Objective-CクラスのKotlinサブクラスをランタイムルックアップで表示できるようにします。</target>
        </trans-unit>
        <trans-unit id="c05c0a0b46c6d81aa3deae4e473b3f5b195d9dae" translate="yes" xml:space="preserve">
          <source>Makes top level function available from C/C++ code with the given name.</source>
          <target state="translated">与えられた名前でC/C++コードからトップレベルの関数を利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="3dc9b78fb75740d031749aa0e1f6c2f20915be09" translate="yes" xml:space="preserve">
          <source>Making computation code cancellable</source>
          <target state="translated">計算コードをキャンセル可能にする</target>
        </trans-unit>
        <trans-unit id="d26e8b17246e39f5acbd44ce84cfe44e4708e7bc" translate="yes" xml:space="preserve">
          <source>Making frequent null checks is annoying, so if you have to allow for the possibility of nulls, there are several very useful operators in Kotlin to ease working with values that might be null, as described below.</source>
          <target state="translated">頻繁にヌルチェックをするのは面倒なので、ヌルの可能性を許容しなければならない場合、Kotlinには、以下に説明するように、ヌルになる可能性のある値の処理を簡単にするための非常に便利な演算子がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="f35727fd1febb5955e04a96a85cfbf28b11e18a0" translate="yes" xml:space="preserve">
          <source>Malformed byte sequences are replaced by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">不正なバイトシーケンスは、置換文字 &lt;code&gt;\uFFFD&lt;/code&gt; 置き換えられます。</target>
        </trans-unit>
        <trans-unit id="b2aee73bd2e79677bed872d3980e254bec42f2c5" translate="yes" xml:space="preserve">
          <source>Managing dependencies</source>
          <target state="translated">依存関係の管理</target>
        </trans-unit>
        <trans-unit id="f45216dfe5658802d5da85dd6691495f1dd5ee41" translate="yes" xml:space="preserve">
          <source>Managing sources</source>
          <target state="translated">ソースの管理</target>
        </trans-unit>
        <trans-unit id="b0426429a44f47228605bdec162f6e1798c46d34" translate="yes" xml:space="preserve">
          <source>Managing targets</source>
          <target state="translated">目標管理</target>
        </trans-unit>
        <trans-unit id="dc1586db5c7b55a74cd10223f2e3a7fe8bf95caa" translate="yes" xml:space="preserve">
          <source>Mangling</source>
          <target state="translated">Mangling</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">手動設定</target>
        </trans-unit>
        <trans-unit id="724adbdc3ff0031b5c79ad867a79546b920a65f6" translate="yes" xml:space="preserve">
          <source>Manual Install</source>
          <target state="translated">マニュアルインストール</target>
        </trans-unit>
        <trans-unit id="65a73e4ea7721ba692baf916576f5d262d09eb6e" translate="yes" xml:space="preserve">
          <source>Many modern IDEs support Kotlin and help in writing idiomatic Kotlin code:</source>
          <target state="translated">最近の多くのIDEはKotlinをサポートしており、慣用的なKotlinコードを書くのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="564f728d4accd1cab1faa6abd0808aa411a7afbc" translate="yes" xml:space="preserve">
          <source>Many of the options can also be configured through properties:</source>
          <target state="translated">オプションの多くは、プロパティからも設定できます。</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="1a3e682ff2754ef0b1db9651d934d18042efd51a" translate="yes" xml:space="preserve">
          <source>Map Specific Operations</source>
          <target state="translated">マップ固有の操作</target>
        </trans-unit>
        <trans-unit id="8a55ba4dc9c56793f4d86eafccdf893ff4dfc510" translate="yes" xml:space="preserve">
          <source>Map nullable value if not null</source>
          <target state="translated">null でない場合は、nullable 値をマップします。</target>
        </trans-unit>
        <trans-unit id="154baeb185088267d2e04dd13fb49c8faf1731b4" translate="yes" xml:space="preserve">
          <source>Map write operations</source>
          <target state="translated">マップ書き込み操作</target>
        </trans-unit>
        <trans-unit id="7c78455b5524d54dd5717439fdd75a3564e3b05c" translate="yes" xml:space="preserve">
          <source>Map.getValue()</source>
          <target state="translated">Map.getValue()</target>
        </trans-unit>
        <trans-unit id="ab6d914f12b0209ae12f1eaa021fab679f71fbd9" translate="yes" xml:space="preserve">
          <source>Map.minus(key)</source>
          <target state="translated">Map.minus(key)</target>
        </trans-unit>
        <trans-unit id="a1e3b9de38695948c83390c6219ada2b49d0eb03" translate="yes" xml:space="preserve">
          <source>Map.toMap() and Map.toMutableMap()</source>
          <target state="translated">Map.toMap()および Map.toMutableMap()</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">マップされたタイプ</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="ae3c45c6220c54a755f63c613acc1f9b440f728e" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointer Types from C</source>
          <target state="translated">C言語からの関数ポインタ型のマッピング</target>
        </trans-unit>
        <trans-unit id="3629da3c88dfc6308c1eb31a6616f2493b1b3a4a" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointers from C</source>
          <target state="translated">Cからの関数ポインタのマッピング</target>
        </trans-unit>
        <trans-unit id="1ab023f41f65f5d65722a6148006ad3ade089fb2" translate="yes" xml:space="preserve">
          <source>Mapping Primitive Data Types from C</source>
          <target state="translated">Cからのプリミティブデータ型のマッピング</target>
        </trans-unit>
        <trans-unit id="d6b4467553c4b4c986cbd21872e97a3c8e8ea762" translate="yes" xml:space="preserve">
          <source>Mapping Strings from C</source>
          <target state="translated">Cからの文字列のマッピング</target>
        </trans-unit>
        <trans-unit id="76a029f685d2ba76aaeecfdb2224f273ebee328a" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union C types</source>
          <target state="translated">マッピング構造とユニオンCタイプ</target>
        </trans-unit>
        <trans-unit id="565e074c9f98132ef0f9b4a1395ca391399b5fc8" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union Types from C</source>
          <target state="translated">Cから構造体とユニオンタイプのマッピング</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="4811d5bdec38d0b9bed7265f0e3355c78194b1ff" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;実装が高速のインデックス付きアクセスをサポートすることを示すマーカーインターフェイス。</target>
        </trans-unit>
        <trans-unit id="79f92c6a2f9b55de94523a0137df26f32b271fc3" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;実装が高速のインデックス付きアクセスをサポートすることを示すマーカーインターフェイス。</target>
        </trans-unit>
        <trans-unit id="deb9ed7bb61b8698d73e57af565358059241e0bd" translate="yes" xml:space="preserve">
          <source>Marking API elements</source>
          <target state="translated">API要素のマーキング</target>
        </trans-unit>
        <trans-unit id="39acae63028d11938c7d9a75f3ad9099e5f79972" translate="yes" xml:space="preserve">
          <source>Marking experimental API</source>
          <target state="translated">実験用APIのマーキング</target>
        </trans-unit>
        <trans-unit id="72ca39cc361248a73db4aa376ff098d3162e32bf" translate="yes" xml:space="preserve">
          <source>Marking rules: an implicit receiver is considered marked with @Ann if</source>
          <target state="translated">マーキングルール:暗黙のレシーバは、@Ann でマークされているとみなされます。</target>
        </trans-unit>
        <trans-unit id="33d0711db8fea3ba5bf0ebfba79cfe0cf8264458" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as immutable. It is possible to share such object between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">バッキングフィールドを持つトップレベルの変数やオブジェクトに不変のマークを付けます。このようなオブジェクトを複数のスレッド間で共有することは可能ですが、深く凍結されてしまうため、その状態や参照しているオブジェクトの状態を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="9c86911fdb83bb1e6cafe3509aa437cd672c34a9" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">バッキングフィールドやオブジェクトを持つトップレベルの変数をスレッドローカルとしてマークします。オブジェクトは変更可能なままで、その状態を変更することができますが、すべてのスレッドがこのオブジェクトの個別のコピーを持つことになるので、あるスレッドでの変更は別のスレッドには反映されません。</target>
        </trans-unit>
        <trans-unit id="6ec4d266890af2cb0a6aa9e1810055ba658008f8" translate="yes" xml:space="preserve">
          <source>Marks an expected annotation class that it isn't required to have actual counterparts in all platforms.</source>
          <target state="translated">すべてのプラットフォームで実際の対応するものを持つ必要がないことを期待される注釈クラスにマークを付けます。</target>
        </trans-unit>
        <trans-unit id="5c6f17834ff35593c5226191e98557d99d755e77" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="292a3151e7a72885408caf9ee437ad5d8673be4a" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="5be31e799227d8931dded0eeace958d0a3e43418" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="589152c67b668bc3a0e5e851927c4f25196aa066" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">コルーチンの継続をインターセプトするコルーチンコンテキスト要素をマークします。コルーチンフレームワークは&lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;を使用してインターセプターを取得し、&lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;呼び出しですべてのコルーチンの継続をインターセプトします。</target>
        </trans-unit>
        <trans-unit id="2df77c28828a089a19fdffaa1789ccacc76664f7" translate="yes" xml:space="preserve">
          <source>Marks the API that is dependent on the experimental unsigned types, including those types themselves.</source>
          <target state="translated">実験的な符号なし型に依存するAPIをマークします。</target>
        </trans-unit>
        <trans-unit id="73273d6a95cad7e50a139041438fbf00005e8089" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;transient&lt;/code&gt;, meaning that it is not part of the default serialized form of the object.</source>
          <target state="translated">注釈付きプロパティのJVMバッキングフィールドを &lt;code&gt;transient&lt;/code&gt; としてマークします。これは、オブジェクトのデフォルトのシリアル化された形式の一部ではないことを意味します。</target>
        </trans-unit>
        <trans-unit id="fd02a709ebd5dfcba6e63db7078d9717fce347a3" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;volatile&lt;/code&gt;, meaning that writes to this field are immediately made visible to other threads.</source>
          <target state="translated">注釈付きプロパティのJVMバッキングフィールドを &lt;code&gt;volatile&lt;/code&gt; としてマークします。つまり、このフィールドへの書き込みはすぐに他のスレッドから見えるようになります。</target>
        </trans-unit>
        <trans-unit id="1c403a59019182391a8ff7eb648d56329fc1e05f" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;strictfp&lt;/code&gt;, meaning that the precision of floating point operations performed inside the method needs to be restricted in order to achieve better portability.</source>
          <target state="translated">アノテーション付き関数から生成されたJVMメソッドを &lt;code&gt;strictfp&lt;/code&gt; としてマークします。つまり、メソッド内で実行される浮動小数点演算の精度を制限して、移植性を向上させる必要があります。</target>
        </trans-unit>
        <trans-unit id="58ecb1a8fc60ff73e8fc37346fd83ecb47a77bf8" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;synchronized&lt;/code&gt;, meaning that the method will be protected from concurrent execution by multiple threads by the monitor of the instance (or, for static methods, the class) on which the method is defined.</source>
          <target state="translated">注釈付き関数から生成されたJVMメソッドを &lt;code&gt;synchronized&lt;/code&gt; としてマークします。つまり、メソッドが定義されているインスタンス（または静的メソッドの場合はクラス）のモニターによって、メソッドが複数のスレッドによる同時実行から保護されます。</target>
        </trans-unit>
        <trans-unit id="fb96fdd73420dc05c701eb6e0838bd95d38438a9" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated.</source>
          <target state="translated">アノテーション宣言を非推奨とするマークを付けます。</target>
        </trans-unit>
        <trans-unit id="849bb03707fb20c75be09bfab7269367951a2e2c" translate="yes" xml:space="preserve">
          <source>MatchGroup</source>
          <target state="translated">MatchGroup</target>
        </trans-unit>
        <trans-unit id="dca62bbed6a25edcb571ec2b8d04d93aa72d3b21" translate="yes" xml:space="preserve">
          <source>MatchGroupCollection</source>
          <target state="translated">MatchGroupCollection</target>
        </trans-unit>
        <trans-unit id="40ee7a3cd8703b1f6d5c39fe97ef7bdbddff913a" translate="yes" xml:space="preserve">
          <source>MatchNamedGroupCollection</source>
          <target state="translated">MatchNamedGroupCollection</target>
        </trans-unit>
        <trans-unit id="e5e10479d7e48ed2ed4d8e1de8fc8b3e40fd01eb" translate="yes" xml:space="preserve">
          <source>MatchResult</source>
          <target state="translated">MatchResult</target>
        </trans-unit>
        <trans-unit id="3edf0df49942da6d11a1a217e4d3af4a5a8e64f2" translate="yes" xml:space="preserve">
          <source>Math</source>
          <target state="translated">Math</target>
        </trans-unit>
        <trans-unit id="386de788c6f8f526adcdfcc95893611a4f0f2a05" translate="yes" xml:space="preserve">
          <source>Math operations in kotlin-stdlib</source>
          <target state="translated">kotlin-stdlib での数学演算</target>
        </trans-unit>
        <trans-unit id="0ada0ff6418289ab78ea96388455f7b6c8654ca4" translate="yes" xml:space="preserve">
          <source>Mathematical functions and constants.</source>
          <target state="translated">数学的な関数と定数。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
