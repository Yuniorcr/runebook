<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="9e9fa36344bc0f04a7e81c8fa8066aa6b76c8c72" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle functions that appear in the WHERE clause of a join.</source>
          <target state="translated">バグ修正。ジョインのWHERE句に現れる関数を正しく処理するようになりました。</target>
        </trans-unit>
        <trans-unit id="b19417477425f028b30221d15629f2e13bb03e35" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle terms in the WHERE clause of a join that do not contain a comparison operator.</source>
          <target state="translated">バグ修正。比較演算子を含まないジョインのWHERE句の用語を正しく処理します。</target>
        </trans-unit>
        <trans-unit id="f1c7035443112823f2488a80b27044cd7dc930ca" translate="yes" xml:space="preserve">
          <source>Bug fix: Creating and dropping a table all within a single transaction was not working.</source>
          <target state="translated">バグ修正。1つのトランザクション内ですべてのテーブルを作成したりドロップしたりすることができない問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="a65ee45495a64aa4ac7b00532e7dcdea10a45c93" translate="yes" xml:space="preserve">
          <source>Bug fix: DISTINCT now recognizes that a &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; and a blob of all 0x00 bytes are the same thing. &lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;Ticket [fccbde530a]&lt;/a&gt;</source>
          <target state="translated">バグ修正：DISTINCTは、すべての0x00バイトの&lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;ゼロブロブ&lt;/a&gt;とブロブが同じものであることを認識します。&lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;チケット[fccbde530a]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e1c19457c6bcac61af13a07643a50b8996bac51" translate="yes" xml:space="preserve">
          <source>Bug fix: DROP TABLE followed by a CREATE TABLE with the same name all within a single transaction was causing a coredump.</source>
          <target state="translated">バグ修正。1つのトランザクション内でDROP TABLEに続いて同じ名前のCREATE TABLEを使用していた場合、コアダンプが発生していたのを修正しました。</target>
        </trans-unit>
        <trans-unit id="ba00de2c0632584e59e348681ca42b12b644bcbe" translate="yes" xml:space="preserve">
          <source>Bug fix: Database corruption can occur due to the optimization that was introduced in version 2.4.0 (check-in [410]). The problem should now be fixed. The use of versions 2.4.0 through 2.5.2 is not recommended.</source>
          <target state="translated">バグ修正を行いました。バージョン2.4.0で導入された最適化により、データベースの破損が発生することがあります(チェックイン[410])。この問題は現在修正されているはずです。バージョン2.4.0から2.5.2までの使用は推奨されません。</target>
        </trans-unit>
        <trans-unit id="bbe70e0c57d51f533365c58d207cdfb57683c5ef" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not allow a virtual table to cancel the ORDER BY clause unless all outer loops are guaranteed to return no more than one row result. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;.</source>
          <target state="translated">バグ修正：すべての外部ループが1行以下の結果を返すことが保証されていない限り、仮想テーブルがORDER BY句をキャンセルしないようにしてください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c3b898a085ef4e9fd7492842026dc724b1316d2" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not attempt the subquery flattening optimization on queries that lack a FROM clause. To do so causes a segfault.</source>
          <target state="translated">バグ修正。FROM句を持たないクエリで副問い合わせの平坦化最適化を試みないようにしました。これを行うとセグメンテーションフォールトが発生します。</target>
        </trans-unit>
        <trans-unit id="c7d832b024aa33f5c367340914044de719478c03" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not automatically remove the DISTINCT keyword from a SELECT that forms the right-hand side of an IN operator since it is necessary if the SELECT also contains a LIMIT. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;.</source>
          <target state="translated">バグ修正：SELECTにLIMITも含まれている場合に必要になるため、IN演算子の右側を形成するSELECTからDISTINCTキーワードを自動的に削除しないでください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ec8b17071def3e40c2a66c3efc8f85f8fbeb60d" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not discard the DISTINCT as superfluous unless a subset of the result set is subject to a UNIQUE constraint &lt;em&gt;and&lt;/em&gt; it none of the columns in that subset can be NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;.</source>
          <target state="translated">バグ修正：結果セットのサブセットがUNIQUE制約を受けない限り、DOは余分としてDISTINCTを破棄しない&lt;em&gt;と&lt;/em&gt;、それはそのサブセット内の列のどれもがNULLになることはできません。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d122c8d80295b61ea78f7985674ee07265e9fe63" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not move WHERE clause terms inside OR expressions that are contained within an ON clause of a LEFT JOIN. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</source>
          <target state="translated">バグ修正：LEFT JOINのON句に含まれるOR式内でWHERE句の用語を移動しないでください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b3ae0e3595ba9969a417594021c4332e3d08633" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not optimize away an ORDER BY clause that has the same terms as a UNIQUE index unless those terms are also NOT NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;.</source>
          <target state="translated">バグ修正：UNIQUEインデックスと同じ用語を持つORDER BY句を最適化して、それらの用語もNOT NULLでない限り、削除しないでください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6453e25436ce2c11dc1b6194ae2dc12f5ca5250" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not suppress the ORDER BY clause on a virtual table query if an IN constraint is used. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;.</source>
          <target state="translated">バグ修正：IN制約が使用されている場合、仮想テーブルクエリのORDER BY句を抑制しないでください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f89fece6f5c7d025fca0afff2d5506eaef79c01" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure that &quot;ORDER BY random()&quot; clauses do not get optimized out. &lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;Ticket [65bdeb9739]&lt;/a&gt;</source>
          <target state="translated">バグ修正：「ORDER BY random（）」句が最適化されないようにしました。&lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;チケット[65bdeb9739]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad5b813b289d7e750591bfb845e4ba940a74acee" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure the cached KeyInfo objects (an internal abstraction not visible to the application) do not go stale when operating in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and frequently closing and reopening some database connections while leaving other database connections on the same shared cache open continuously. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt;.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモードで動作&lt;/a&gt;し、同じ共有キャッシュ上の他のデータベース接続を継続的に開いたまま、一部のデータベース接続を頻繁に閉じて再度開くときに、キャッシュされたKeyInfoオブジェクト（アプリケーションから見えない内部抽象化）が古くならないようにします。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c94982c68fc72ac2f6ac980a3323226e84f8466" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a 32-bit overflow problem on CREATE INDEX for databases larger than 16GB.</source>
          <target state="translated">バグ修正。16GB以上のデータベースのCREATE INDEXで32ビットオーバーフローの問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="b6580b5e5232c84824bf613c858acbb24fc5f483" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a potential &lt;b&gt;database corruption bug&lt;/b&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; when one &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed while another is in the middle of a write transaction. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</source>
          <target state="translated">バグ修正：ある&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が書き込みトランザクションの最中にあるときに別のデータベース接続が閉じられた場合の、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;での潜在的な&lt;b&gt;データベース破損のバグを修正&lt;/b&gt;しました。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28f644aa67590d02891787c2b2d9de10e303faef" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an assertion failure that occurred when ROWID was a column in a SELECT statement on a view.</source>
          <target state="translated">バグ修正。ビューの SELECT 文で ROWID がカラムであった場合に発生していたアサーションの失敗を修正しました。</target>
        </trans-unit>
        <trans-unit id="6de63655427b8362357e0b9729e0309dea102b68" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an uninitialized variable in the VDBE that would could an assert failure.</source>
          <target state="translated">バグ修正。VDBEで初期化されていない変数がアサートに失敗する可能性があったのを修正しました。</target>
        </trans-unit>
        <trans-unit id="15567e970418f92d21404d2b997ca55ed7870f2d" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix column default values expressions of the form &quot;DEFAULT(-(-9223372036854775808))&quot; so that they work correctly, initializing the column to a floating point value approximately equal to +9223372036854775808.0.</source>
          <target state="translated">バグ修正。DEFAULT(-(-9223372036854775808)&quot;形式の列のデフォルト値式を修正し、列を+9223372036854775808.0にほぼ等しい浮動小数点値に初期化して正しく動作するようにしました。</target>
        </trans-unit>
        <trans-unit id="b572be392d93fe8f8aa3c731cb70e9adb855b95a" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; SQL function so that it returns an empty string rather than an &quot;out of memory&quot; error when called with zero arguments.</source>
          <target state="translated">バグ修正：引数なしで呼び出されたときに「メモリ不足」エラーではなく空の文字列を返すように、&lt;a href=&quot;lang_corefunc#char&quot;&gt;char（）&lt;/a&gt; SQL関数を修正しました。</target>
        </trans-unit>
        <trans-unit id="ec8ef57ae219363ebc2f9d36c425f7585ca571b1" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; command so that it does not cancel pending queries. This repairs a problem introduced in 3.7.11.</source>
          <target state="translated">バグ修正：保留中のクエリがキャンセルされないように&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;コマンドを修正しました。これにより、3.7.11で導入された問題が修正されます。</target>
        </trans-unit>
        <trans-unit id="df416fd402ae79122987fd712ad3deeb5c8f5458" translate="yes" xml:space="preserve">
          <source>Bug fix: Generate correct column headers when a compound SELECT is used as a subquery.</source>
          <target state="translated">バグ修正。複合SELECTがサブクエリとして使用されている場合に正しいカラムヘッダを生成するようになりました。</target>
        </trans-unit>
        <trans-unit id="8607f97a039e79f9d7bbfb840d1dbfffbf0765f7" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; CSV import feature, do not end a field when an escaped double-quote occurs at the end of a CRLN line.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt; CSVインポート機能で、エスケープされた二重引用符がCRLN行の最後にある場合、フィールドを終了しないでください。</target>
        </trans-unit>
        <trans-unit id="d77f01bc12cfaa192da17d51a33bb2f997769b11" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;, treat all private code points as identifier symbols.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;fts3#unicode61&quot;&gt;FTS4&lt;/a&gt;の&lt;a href=&quot;fts3#fts4&quot;&gt;unicode61トークナイザーで&lt;/a&gt;、すべてのプライベートコードポイントを識別子シンボルとして扱います。</target>
        </trans-unit>
        <trans-unit id="fc0e959c372e361cf7f33ef8b8f20d674104ba00" translate="yes" xml:space="preserve">
          <source>Bug fix: Issue an error message if the 16-bit reference counter on a view overflows due to an overly complex query.</source>
          <target state="translated">バグ修正。複雑すぎるクエリが原因でビュー上の16ビット参照カウンタがオーバーフローした場合、エラーメッセージを発行するようにしました。</target>
        </trans-unit>
        <trans-unit id="796cd2d86e5fad8940076a58510533a97b2c56bf" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &quot;rowid&quot; columns are correctly resolved in joins between normal tables and WITHOUT ROWID tables. &lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;Ticket [c34d0557f7]&lt;/a&gt;</source>
          <target state="translated">バグ修正：通常のテーブルとWITHOUT ROWIDテーブルの間の結合で、「rowid」列が正しく解決されていることを確認してください。&lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;チケット[c34d0557f7]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adf0baa27394f8041aaae283cf02f3ee1bfa8b41" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements appear in &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; output.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）の&lt;/a&gt;出力に&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;ステートメントが表示されることを確認してください。</target>
        </trans-unit>
        <trans-unit id="2334a8bc658fa8a7b723fcf78436e06aa632b55a" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure an error is always reported when attempting to preform an operation that requires a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; that is missing. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</source>
          <target state="translated">バグ修正：欠落している&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;を必要とする操作を実行しようとすると、常にエラーが報告されるようにしてください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b7a3c06c81b08010533a335b71314ea1246750e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure that NULL results from OP_Column are fully and completely NULL and do not have the MEM_Ephem bit set. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;.</source>
          <target state="translated">バグ修正：OP_ColumnからのNULL結果が完全かつ完全にNULLであり、MEM_Ephemビットが設定されていないことを確認してください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b6a649b8a7464f814f81388b6be52f54e12c25e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the journal file directory entry is committed to disk before writing the database file.</source>
          <target state="translated">バグ修正。データベースファイルを書き込む前に、ジャーナルファイルのディレクトリエントリがディスクにコミットされていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="e185f43b49a3251f6e6597892c2f724efa586d32" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the same temporary registers are not used in concurrent co-routines used to implement compound SELECT statements containing ORDER BY clauses, as such use can lead to incorrect answers. &lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;Ticket [8c63ff0eca]&lt;/a&gt;</source>
          <target state="translated">バグ修正：ORDER BY句を含む複合SELECTステートメントを実装するために使用される同時コルーチンで同じ一時レジスタが使用されていないことを確認してください。このような使用は誤った回答を引き起こす可能性があります。&lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;チケット[8c63ff0eca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51326d84193d9019e013ecb68f17ddd96b5b7cd8" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the schema is up-to-date prior to running pragmas table_info, index_list, index_info, and foreign_key_list.</source>
          <target state="translated">バグ修正。pragmas table_info,index_list,index_info,foreign_key_listを実行する前に、スキーマが最新であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="21876ec37a821c06e59ab2273c8a26e3a12144f2" translate="yes" xml:space="preserve">
          <source>Bug fix: Makes sure the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer&lt;/a&gt; callback gets a valid pointer to the string &quot;ROWID&quot; for the column-name parameter when doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; that changes the rowid. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</source>
          <target state="translated">バグ修正：ROWID を変更する&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;を実行するときに、&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;Authorizer&lt;/a&gt;コールバックがcolumn-nameパラメーターの文字列「ROWID」への有効なポインターを確実に取得するようにしました。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa2f91d43fa97f1a5999350e4addb5cbb3edaca1" translate="yes" xml:space="preserve">
          <source>Bug fix: Only consider AS names from the result set as candidates for resolving identifiers in the WHERE clause if there are no other matches. In the ORDER BY clause, AS names take priority over any column names. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</source>
          <target state="translated">バグ修正：他に一致するものがなければ、結果セットのAS名をWHERE句の識別子を解決する候補としてのみ検討します。ORDER BY句では、AS名が列名よりも優先されます。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="141fde2a748db5215be1ecb9d4a778d891f1cb31" translate="yes" xml:space="preserve">
          <source>Bug fix: Passing in a NULL as the 3rd parameter to &lt;b&gt;sqlite_open()&lt;/b&gt; would sometimes cause a coredump.</source>
          <target state="translated">バグ修正：&lt;b&gt;sqlite_open（）の&lt;/b&gt; 3番目のパラメーターとしてNULLを渡すと、コアダンプが発生することがありました。</target>
        </trans-unit>
        <trans-unit id="2ab06e54b175379ab13bc77c3e0d9c481bc0c496" translate="yes" xml:space="preserve">
          <source>Bug fix: Recognize that any column in the right-hand table of a LEFT JOIN can be NULL even if the column has a NOT NULL constraint. Do not apply optimizations that assume the column is never NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">バグ修正：列にNOT NULL制約がある場合でも、LEFT JOINの右側のテーブルの列はNULLになる可能性があることを認識してください。列がNULLになることはないと想定して最適化を適用しないでください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03f2e3e890c570259cec0056bb1e5602f41a8fe5" translate="yes" xml:space="preserve">
          <source>Bug fix: Repair a name-resolution error that can occur in sub-select statements contained within a TRIGGER. &lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;Ticket [4ef7e3cfca]&lt;/a&gt;</source>
          <target state="translated">バグ修正：TRIGGERに含まれる副選択ステートメントで発生する可能性がある名前解決エラーを修復します。&lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;チケット[4ef7e3cfca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179d04a255aba0b12c6e57bf1304a5f158b18e87" translate="yes" xml:space="preserve">
          <source>Bug fix: SQL functions created using the TCL interface honor the &quot;nullvalue&quot; setting.</source>
          <target state="translated">バグ修正。TCLインターフェースを使用して作成されたSQL関数は &quot;nullvalue &quot;設定を尊重します。</target>
        </trans-unit>
        <trans-unit id="0cd3dbb56d1124c2a6604fca7c97c5b4d246ad99" translate="yes" xml:space="preserve">
          <source>Bug fix: Sometimes arbitrary strings were passed to the callback function when the actual value of a column was NULL.</source>
          <target state="translated">バグ修正。カラムの実際の値がNULLの場合に任意の文字列がコールバック関数に渡されることがありました。</target>
        </trans-unit>
        <trans-unit id="e6069685c787f1f2374ad59005630cac33f83a18" translate="yes" xml:space="preserve">
          <source>Bug fix: The %c format in sqlite3_mprintf() is able to handle precisions greater than 70.</source>
          <target state="translated">バグ修正。sqlite3_mprintf()の %c 形式は、70 より大きいプリシティを扱えるようになりました。</target>
        </trans-unit>
        <trans-unit id="8545ae69eab7462c35ca27db0ca5feb48e882da0" translate="yes" xml:space="preserve">
          <source>Bug fix: The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; gives an exit code of 0 when terminated using the &quot;.quit&quot; command.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;は、「。quit」コマンドを使用して終了すると、終了コード0を示します。</target>
        </trans-unit>
        <trans-unit id="3c4dbfc44f9dd05912067f94c3eb5f1e8372f6d5" translate="yes" xml:space="preserve">
          <source>Bug fix: There was an incorrect assert() in pager.c. The real code was all correct (as far as is known) so everything should work OK if you compile with -DNDEBUG=1. When asserts are not disabled, there could be a fault.</source>
          <target state="translated">バグ修正。実際のコードは (知られている限りでは)すべて正しいので、-DNDEBUG=1 でコンパイルすれば、すべて正常に動作するはずです。assert が無効化されていない場合は、フォールトが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ad7bd89e49a8af821827d6b028e2e799f12e2e1e" translate="yes" xml:space="preserve">
          <source>Bug fix: Updates to tables containing an INTEGER PRIMARY KEY and an index could fail.</source>
          <target state="translated">バグ修正。INTEGER PRIMARY KEY とインデックスを含むテーブルへの更新に失敗する可能性がありました。</target>
        </trans-unit>
        <trans-unit id="6b758d1f8710d23a2038913ec37dece3bec7abf6" translate="yes" xml:space="preserve">
          <source>Bug fix: Virtual tables now handle IS NOT NULL constraints correctly.</source>
          <target state="translated">バグ修正。仮想テーブルがIS NOT NULL制約を正しく扱うようになりました。</target>
        </trans-unit>
        <trans-unit id="332e05b490c4cb7238853c006e2e916e2a9e4dbc" translate="yes" xml:space="preserve">
          <source>Bug fix: When a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; that uses an ORDER BY clause with a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, make sure that the sorting occurs according to the specified collation and that the comparisons associate with the compound query use the native collation. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE演算子&lt;/a&gt;でORDER BY句を使用する&lt;a href=&quot;lang_select#compound&quot;&gt;複合クエリの&lt;/a&gt;場合、指定した照合に従ってソートが行われ、複合クエリに関連付けられている比較でネイティブ照合が使用されていることを確認してください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cfdb97a345b3ce143f2abc5fd945ed42741b35a" translate="yes" xml:space="preserve">
          <source>Bug fix: allow a VACUUM (without segfaulting) on an empty database after setting the EMPTY_RESULT_CALLBACKS pragma.</source>
          <target state="translated">EMPTY_RESULT_CALLBACKS pragmaを設定した後、空のデータベースでVACUUMを許可するようにしました(セグメンテーションフォールトなし)。</target>
        </trans-unit>
        <trans-unit id="1e76d1db13ab52fcac380bd0ae95fbf87bf5df38" translate="yes" xml:space="preserve">
          <source>Bug fix: an assertion was failing if the disk holding the database file became full or stopped accepting writes for some other reason. New tests were added to detect similar problems in the future.</source>
          <target state="translated">バグ修正:データベースファイルを保持しているディスクが一杯になったり、何らかの理由で書き込みを受け付けなくなったりした場合にアサーションが失敗していたのを修正しました。将来的に同様の問題を検出するための新しいテストが追加されました。</target>
        </trans-unit>
        <trans-unit id="f481a7837f1627a5d4384fe68dbbc8fae1d3d0ad" translate="yes" xml:space="preserve">
          <source>Bug fix: an obscure and relatively harmless bug was causing one of the tests to fail when gcc optimizations are turned on. This release fixes the problem.</source>
          <target state="translated">バグ修正:gcc の最適化を有効にしているときにテストが失敗する原因となっていたバグがありました。このリリースはこの問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="1817a2a23947bcba57e850537b31bddd01fd4808" translate="yes" xml:space="preserve">
          <source>Bug fix: correctly evaluate a view of a view without segfaulting.</source>
          <target state="translated">バグ修正:セグフェルトを行わずにビューのビューを正しく評価するようにしました。</target>
        </trans-unit>
        <trans-unit id="0bbfec3e6b5b062aa0e10ea3e3ec25c68f3b48e5" translate="yes" xml:space="preserve">
          <source>Bug fix: do not invoke the authorizer when reparsing the schema after a schema change.</source>
          <target state="translated">スキーマ変更後にスキーマを修復する際にオーサライザーを呼び出さないようにした。</target>
        </trans-unit>
        <trans-unit id="ff59932ad9e1623e668bc5144d9efca6daa5ff06" translate="yes" xml:space="preserve">
          <source>Bug fix: if an integer value will not fit in a 32-bit int, store it in a double instead.</source>
          <target state="translated">バグ修正:整数値が32ビットのintに収まらない場合、代わりにdoubleに格納するようにしました。</target>
        </trans-unit>
        <trans-unit id="09579acd43ac94145eab3e50236de9b1df09778c" translate="yes" xml:space="preserve">
          <source>Bug fix: incorrect VDBE code was being generated for the following circumstance: a query on an indexed table containing a WHERE clause with an IN operator that had a subquery on its right-hand side.</source>
          <target state="translated">バグ修正:以下の状況で不正なVDBEコードが生成されていました:右側に副問い合わせを持つIN演算子を持つWHERE句を含むインデックス付きテーブルの問い合わせ。</target>
        </trans-unit>
        <trans-unit id="e8c1bb430eed1f84c250a2cbb94468adfcff9f43" translate="yes" xml:space="preserve">
          <source>Bug fix: prevent database corruption if you dropped a trigger that had the same name as a table.</source>
          <target state="translated">バグ修正:テーブルと同じ名前のトリガーをドロップした場合のデータベースの破損を防止しました。</target>
        </trans-unit>
        <trans-unit id="77f87bfdf4072c6e0867b3768c5f7d3818056770" translate="yes" xml:space="preserve">
          <source>Bug fix: repair a long-standing problem that could cause incorrect query results in a 3-way or larger join that compared INTEGER fields against TEXT fields in two or more places. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</source>
          <target state="translated">バグ修正：3ウェイ以上の結合でINTEGERフィールドと2か所以上のTEXTフィールドを比較する不正なクエリ結果の原因となる長年の問題を修正しました。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c0e4c435db089ba66d14c6f426f1ca923c3e24a" translate="yes" xml:space="preserve">
          <source>Bug fix: the &lt;b&gt;sqlite_busy_timeout()&lt;/b&gt; function was delaying 1000 times too long before failing.</source>
          <target state="translated">バグ修正：&lt;b&gt;sqlite_busy_timeout（）&lt;/b&gt;関数が失敗するまでに1000倍の遅延が発生していました。</target>
        </trans-unit>
        <trans-unit id="1de9526f456e5138884e0e01586b12298617b6e1" translate="yes" xml:space="preserve">
          <source>Bug fixes</source>
          <target state="translated">バグ修正</target>
        </trans-unit>
        <trans-unit id="9af1a1169b55646981d441c46e6271c5d4e76c17" translate="yes" xml:space="preserve">
          <source>Bug fixes and performance enhancements in the query optimizer</source>
          <target state="translated">クエリオプティマイザのバグ修正とパフォーマンスの向上</target>
        </trans-unit>
        <trans-unit id="c92ef11c871ae07b2d656ca889c918e8054c9d2e" translate="yes" xml:space="preserve">
          <source>Bug fixes and speed improvements. Improved test coverage.</source>
          <target state="translated">バグ修正と速度の改善。テストカバレッジの改善。</target>
        </trans-unit>
        <trans-unit id="fa58e385720020fa0c169f308e1843b2e873b0c1" translate="yes" xml:space="preserve">
          <source>Bug fixes in fts1 and fts2 modules.</source>
          <target state="translated">fts1とfts2モジュールのバグ修正。</target>
        </trans-unit>
        <trans-unit id="7084081296e3ad1cf8f7221181be2c129e0aee5c" translate="yes" xml:space="preserve">
          <source>Bug fixes in the TCL interface identified by Oleg Oleinick.</source>
          <target state="translated">Oleg Oleinickによって特定されたTCLインターフェースのバグ修正。</target>
        </trans-unit>
        <trans-unit id="e8aa6f5aee0afe8811b93445b5db21495039c63d" translate="yes" xml:space="preserve">
          <source>Bug fixes in the experimental date/time functions.</source>
          <target state="translated">実験的な日時関数のバグ修正。</target>
        </trans-unit>
        <trans-unit id="b9c7777bb06388cb9dbb8f975e3fd09b2142a8c1" translate="yes" xml:space="preserve">
          <source>Bug fixes to date/time functions.</source>
          <target state="translated">日付・時刻機能のバグ修正。</target>
        </trans-unit>
        <trans-unit id="081661d86510940c54a252302be8551477973958" translate="yes" xml:space="preserve">
          <source>Bug fixes too numerous to mention (see the change log).</source>
          <target state="translated">バグ修正が多すぎて言及できません(変更ログを参照)。</target>
        </trans-unit>
        <trans-unit id="54d964bde3b45008273493e091d5fc828d1a6056" translate="yes" xml:space="preserve">
          <source>Bug fixes:</source>
          <target state="translated">バグ修正。</target>
        </trans-unit>
        <trans-unit id="a6d45e893c4329669744195bd786da10bdc76da3" translate="yes" xml:space="preserve">
          <source>Bug fixes: Correctly handle nested correlated subqueries used with indices in a WHERE clause.</source>
          <target state="translated">バグ修正。WHERE句のインデックスで使用される入れ子になった相関副問い合わせを正しく処理するようになりました。</target>
        </trans-unit>
        <trans-unit id="24673ce72a32d2ab5eb79f34d4f1d1eb683d14be" translate="yes" xml:space="preserve">
          <source>Bug fixes: Multiple problems in the legacy query optimizer were fixed by the move to &lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt;.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt;への移行により、従来のクエリオプティマイザーの複数の問題が修正されました。</target>
        </trans-unit>
        <trans-unit id="58535f3c8aa73d70d81e761cda2cb8486c811f2f" translate="yes" xml:space="preserve">
          <source>Bugs are far less likely in SQLite than in custom-written file I/O code.</source>
          <target state="translated">SQLiteのバグは、カスタマイズされたファイルのI/Oコードよりもはるかに少ない可能性があります。</target>
        </trans-unit>
        <trans-unit id="5a61f35b0599148f4a6890e52dcef0661cb0913e" translate="yes" xml:space="preserve">
          <source>Bugs in the FTS3/4 virtual table. (The &quot;integrity-check&quot; command was original conceived as part of the test suite for FTS3/4.)</source>
          <target state="translated">FTS3/4仮想テーブルのバグ。(Integrity-checkコマンドはFTS3/4のテストスイートの一部として考案されたものです)</target>
        </trans-unit>
        <trans-unit id="8f202605eb190dddba6e0719369e8fd2b96ba2d8" translate="yes" xml:space="preserve">
          <source>Build the &quot;fts5.c&quot; target. Which also creates fts5.h.</source>
          <target state="translated">fts5.c &quot;ターゲットをビルドします。これは fts5.h も作成します。</target>
        </trans-unit>
        <trans-unit id="00497bbc4dcbda4f80e1ffef6721bc5a34a86a97" translate="yes" xml:space="preserve">
          <source>Building SQLite directly from individual source code files is certainly possible, but it is not recommended. For some specialized applications, it might be necessary to modify the build process in ways that cannot be done using just the prebuilt amalgamation source file downloaded from the website. For those situations, it is recommended that a customized amalgamation be built (as described &lt;a href=&quot;howtocompile#amal&quot;&gt;below&lt;/a&gt;) and used. In other words, even if a project requires building SQLite beginning with individual source files, it is still recommended that an amalgamation source file be used as an intermediate step.</source>
          <target state="translated">個別のソースコードファイルから直接SQLiteを構築することは確かに可能ですが、お勧めできません。一部の特殊なアプリケーションでは、Webサイトからダウンロードされたビルド済みの統合ソースファイルだけでは実行できない方法でビルドプロセスを変更する必要がある場合があります。これらの状況では、カスタマイズされた融合を構築し（&lt;a href=&quot;howtocompile#amal&quot;&gt;以下で&lt;/a&gt;説明）、使用することをお勧めします。言い換えれば、プロジェクトが個々のソースファイルからSQLiteをビルドする必要がある場合でも、中間ステップとして融合ソースファイルを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0a71cb495d76b612c809648873b36b593c7393c1" translate="yes" xml:space="preserve">
          <source>Building a DLL</source>
          <target state="translated">DLLの構築</target>
        </trans-unit>
        <trans-unit id="280b6f6ad70e8ba6e9e400ea3d8e0a9edc8b3677" translate="yes" xml:space="preserve">
          <source>Building shared libraries for Mac OS X and Windows is not nearly so simple, unfortunately. For those platforms it is best to use the configure script and makefile that is included with the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="translated">Mac OS XとWindows用の共有ライブラリの構築は、残念ながらそれほど単純ではありません。これらのプラットフォームでは、&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarballに&lt;/a&gt;含まれているconfigureスクリプトとmakefileを使用するのが最善です。</target>
        </trans-unit>
        <trans-unit id="22bc37f7023e946a78cac7bbfe5894c0db4b3f89" translate="yes" xml:space="preserve">
          <source>Building the amalgamation</source>
          <target state="translated">アマルガムの構築</target>
        </trans-unit>
        <trans-unit id="c2d49de15987506a3eaf80acc91b361f30b458bf" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that return the results of &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements for use within ordinary SQL queries.</source>
          <target state="translated">通常のSQLクエリ内で使用するために&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;ステートメントの結果を返す組み込みの&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb80809ef25b3a813f862af2f128324a798b2745" translate="yes" xml:space="preserve">
          <source>Built-in functions may be overloaded by new application-defined functions.</source>
          <target state="translated">内蔵関数は、新しいアプリケーション定義関数によってオーバーロードされることがあります。</target>
        </trans-unit>
        <trans-unit id="224b755bc066a07e060bb8deb0ae84ff72d8c6e6" translate="yes" xml:space="preserve">
          <source>Built-in window functions honor any PARTITION BY clause in the same way as aggregate window functions - each selected row is assigned to a partition and each partition is processed separately. The ways in which any ORDER BY clause affects each built-in window function is described below. Some of the window functions (rank(), dense_rank(), percent_rank() and ntile()) use the concept of &quot;peer groups&quot; (rows within the same partition that have the same values for all ORDER BY expressions). In these cases, it does not matter whether the frame-spec specifies ROWS, GROUPS, or RANGE. For the purposes of built-in window function processing, rows with the same values for all ORDER BY expressions are considered peers regardless of the frame type.</source>
          <target state="translated">組込みウィンドウ関数は、集約ウィンドウ関数と同じように、任意のPARTITION BY句を尊重します-選択された行はそれぞれパーティションに割り当てられ、各パーティションは別々に処理されます。ORDER BY句が各組み込みウィンドウ関数にどのような影響を与えるかについては、以下に説明します。いくつかのウィンドウ関数(rank()、dense_rank()、percent_rank()、ntile())では、&quot;ピアグループ &quot;の概念を使用しています(同じパーティション内の行で、すべてのORDER BY式で同じ値を持つ行)。これらの場合、フレーム仕様が ROWS、GROUPS、RANGE のいずれを指定していても問題ではありません。ビルトインウィンドウ関数処理の目的では、すべてのORDER BY式に対して同じ値を持つ行は、フレームタイプに関係なくピアとみなされます。</target>
        </trans-unit>
        <trans-unit id="5a25ccfc2ab6b23f400787b0cd05318c6367c6b9" translate="yes" xml:space="preserve">
          <source>Builtin window functions</source>
          <target state="translated">ビルトインウィンドウ機能</target>
        </trans-unit>
        <trans-unit id="3fddbac5f0f5f0b32fe70d555580cce7a2b2229b" translate="yes" xml:space="preserve">
          <source>Bundle sqlite_encode_binary() and sqlite_decode_binary() with the library.</source>
          <target state="translated">sqlite_encode_binary()とsqlite_decode_binary()をライブラリと一緒にバンドルしてください。</target>
        </trans-unit>
        <trans-unit id="f637663e6355164a78b8db75eb1fc4755242d81d" translate="yes" xml:space="preserve">
          <source>Bury the dead.</source>
          <target state="translated">死者を埋めろ</target>
        </trans-unit>
        <trans-unit id="c86307059b070b415312a3a5cc51007f6e153433" translate="yes" xml:space="preserve">
          <source>But SQLite does use the declared type of a column as a hint that you prefer values in that format. So, for example, if a column is of type INTEGER and you try to insert a string into that column, SQLite will attempt to convert the string into an integer. If it can, it inserts the integer instead. If not, it inserts the string. This feature is called &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt;.</source>
          <target state="translated">しかし、SQLiteは、宣言された列の型を、その形式の値を好むというヒントとして使用します。したがって、たとえば、列のタイプがINTEGERで、その列に文字列を挿入しようとすると、SQLiteは文字列を整数に変換しようとします。可能であれば、代わりに整数を挿入します。そうでない場合は、文字列を挿入します。この機能は、&lt;a href=&quot;datatype3#affinity&quot;&gt;タイプアフィニティ&lt;/a&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="23199e0b44d24bd1ee4c96e22ea9bb3d1c2f67f4" translate="yes" xml:space="preserve">
          <source>But SQLite is built into the application. So if the data is on a separate device from the application, it is required that the higher bandwidth engine-to-disk link be across the network. This works, but it is suboptimal. Hence, it is usually better to select a client/server database engine when the data is on a separate device from the application.</source>
          <target state="translated">しかし、SQLiteはアプリケーションに組み込まれています。そのため、データがアプリケーションとは別のデバイスにある場合は、より高い帯域幅のエンジン対ディスクリンクがネットワークを越えていることが要求されます。これはうまくいきますが、最適ではありません。したがって、データがアプリケーションとは別のデバイス上にある場合は、クライアント/サーバ・データベース・エンジンを選択した方が良いのが一般的です。</target>
        </trans-unit>
        <trans-unit id="09ce2891d1601356f9a03f1d38be77a08462a437" translate="yes" xml:space="preserve">
          <source>But an SQLite database is not limited to a simple key/value structure like a pile-of-files database. An SQLite database can have dozens or hundreds or thousands of different tables, with dozens or hundreds or thousands of fields per table, each with different datatypes and constraints and particular meanings, all cross-referencing each other, appropriately and automatically indexed for rapid retrieval, and all stored efficiently and compactly in a single disk file. And all of this structure is succinctly documented for humans by the SQL schema.</source>
          <target state="translated">しかし、SQLiteデータベースは、pile-of-filesデータベースのような単純なキー/値構造に限定されません。SQLiteデータベースは、テーブルごとに数十、数百、数千の異なるテーブル、数十、数百、数千のフィールドを持ち、それぞれが異なるデータ型や制約、特定の意味を持ち、すべて相互参照し、迅速な検索のために適切かつ自動的にインデックス化され、すべてが単一のディスクファイルに効率的かつコンパクトに格納されています。そして、この構造はすべてSQLスキーマによって簡潔に文書化されています。</target>
        </trans-unit>
        <trans-unit id="d929882a8a439200f669cf52bfce1643d73dfffb" translate="yes" xml:space="preserve">
          <source>But as with any query planner change, upgrading to the NGQP does carry a small risk of introducing performance regressions. The problem here is not that the NGQP is incorrect or buggy or inferior to the legacy query planner. Given reliable information about the selectivity of indexes, the NGQP should always pick a plan that is as good or better than before. The problem is that some applications may be using low-quality and low-selectivity indexes without having run &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. The older query planners look at many fewer possible implementations for each query and so they may have stumbled over a good plan by stupid luck. The NGQP, on the other hand, looks at many more query plan possibilities, and it may choose a different query plan that works better in theory, assuming good indexes, but which gives a performance regression in practice, because of the shape of the data.</source>
          <target state="translated">ただし、クエリプランナーの変更と同様に、NGQPへのアップグレードには、パフォーマンスの低下を招く小さなリスクがあります。ここでの問題は、NGQPが正しくない、バグがある、またはレガシークエリプランナーよりも劣ることではありません。インデックスの選択性に関する信頼できる情報が与えられると、NGQPは常に以前と同じかそれ以上の計画を選択する必要があります。問題は、一部のアプリケーションが&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;を実行せずに低品質で選択性の低いインデックスを使用している可能性があることです。。古いクエリプランナーは、クエリごとに考えられる実装の数がはるかに少ないため、愚かな運によって良いプランに出くわした可能性があります。一方、NGQPはより多くのクエリプランの可能性を検討し、適切なインデックスを想定して理論的にはより適切に機能する別のクエリプランを選択しますが、実際にはデータの形状によりパフォーマンスが低下します。 。</target>
        </trans-unit>
        <trans-unit id="bcf6c11e8e6d47ec28df41f7ffce035dc6edbeac" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">しかし、&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントはデータベースファイルを直接変更しないため、sqlite3_stmt_readonly（）はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="452ab026c840b3ee756da71d85f2e4c8edc72d0b" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">しかし、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントはデータベースファイルを直接変更しないため、sqlite3_stmt_readonly（）はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="f3654dae88afc03c2b5b644ec401c70beb10ac13" translate="yes" xml:space="preserve">
          <source>But does this really save time? The number of steps in the &lt;a href=&quot;#fig16&quot;&gt;original indexless sort&lt;/a&gt; is proportional to NlogN since that is how much time it takes to sort N rows. But when we use Idx1 as shown here, we have to do N rowid lookups which take logN time each, so the total time of NlogN is the same!</source>
          <target state="translated">しかし、これは本当に時間を節約するのでしょうか？&lt;a href=&quot;#fig16&quot;&gt;元のインデックスレスソート&lt;/a&gt;のステップ数はNlogNに比例します。これは、N行をソートするのにかかる時間だからです。ただし、ここに示すようにIdx1を使用する場合、それぞれlogN時間を必要とするN個のROWIDルックアップを実行する必要があるため、NlogNの合計時間は同じです。</target>
        </trans-unit>
        <trans-unit id="d6fc31d48c09d06ad4b37abcbcf5f0dce6a8ec76" translate="yes" xml:space="preserve">
          <source>But from the point of view of the VDBE, a CREATE works pretty much like an INSERT and a DROP works like a DELETE. When the SQLite library opens to an existing database, the first thing it does is a SELECT to read the &quot;sql&quot; columns from all entries of the sqlite_master table. The &quot;sql&quot; column contains the complete SQL text of the CREATE statement that originally generated the index or table. This text is fed back into the SQLite parser and used to reconstruct the internal data structures describing the index or table.</source>
          <target state="translated">しかし、VDBEの観点から見ると、CREATEはINSERTのように動作し、DROPはDELETEのように動作します。SQLiteライブラリが既存のデータベースを開くとき、最初に行うことはSELECTで、sqlite_masterテーブルのすべてのエントリから &quot;sql &quot;カラムを読み込むことです。sql &quot;カラムには、元々インデックスやテーブルを生成したCREATE文の完全なSQLテキストが含まれています。このテキストはSQLiteパーサにフィードバックされ、インデックスやテーブルを記述する内部データ構造を再構築するために使用されます。</target>
        </trans-unit>
        <trans-unit id="48911d596580c34107a4030f62db573e6c27c85f" translate="yes" xml:space="preserve">
          <source>But if SQLite wants to access a page of the database file and memory mapped I/O is enabled, it first calls the xFetch() method. The xFetch() method asks the operating system to return a pointer to the requested page, if possible. If the requested page has been or can be mapped into the application address space, then xFetch returns a pointer to that page for SQLite to use without having to copy anything. Skipping the copy step is what makes memory mapped I/O faster.</source>
          <target state="translated">しかし、SQLite がデータベースファイルのページにアクセスしたい場合で、メモリマップされた I/O が有効になっている場合は、まず xFetch()メソッドを呼び出します。xFetch()メソッドは、可能であれば要求されたページへのポインタを返すようにオペレーティングシステムに要求します。要求されたページがアプリケーションのアドレス空間にマップされている、あるいはマップできる場合、xFetch はそのページへのポインタを返し、SQLite が何もコピーせずに使用できるようにします。コピーステップをスキップすることで、メモリマップされたI/Oがより高速になります。</target>
        </trans-unit>
        <trans-unit id="29180962652da325c9c8e705d40a3befafb60fff" translate="yes" xml:space="preserve">
          <source>But if a hacker is able to run arbitrary SQL, he might run a slightly different query, like this:</source>
          <target state="translated">しかし、ハッカーが任意のSQLを実行できるようになれば、次のような少し変わったクエリを実行するかもしれません。</target>
        </trans-unit>
        <trans-unit id="560c7f07ebe8e7827f02303fd33e3696ffc6d5d9" translate="yes" xml:space="preserve">
          <source>But if the</source>
          <target state="translated">しかし、もし</target>
        </trans-unit>
        <trans-unit id="a0cdbfa12f5d3945de1878cd75d88dc29371bd31" translate="yes" xml:space="preserve">
          <source>But if the EMPTY_RESULT_CALLBACKS pragma is ON, then the following is returned:</source>
          <target state="translated">しかし、EMPTY_RESULT_CALLBACKS pragmaがONの場合は、以下のように返されます。</target>
        </trans-unit>
        <trans-unit id="3b2f2e220bf3a85ffdbd93e68cd80fcba741ecfe" translate="yes" xml:space="preserve">
          <source>But if the case_sensitive_like pragma is enabled as follows:</source>
          <target state="translated">しかし、以下のようにcase_sensitive_like pragmaが有効になっている場合は。</target>
        </trans-unit>
        <trans-unit id="917ffdb9308404a9f9ecbb2338ae37ba101af829" translate="yes" xml:space="preserve">
          <source>But if the i-th parameter is NULL we will get:</source>
          <target state="translated">しかし、i 番目のパラメータが NULL の場合は、このようになります。</target>
        </trans-unit>
        <trans-unit id="418b21f56edf736ac615f67f52f5ff8cd5de8694" translate="yes" xml:space="preserve">
          <source>But if we change the ORDER BY clause to add the &quot;DESC&quot; modifier, that will cause lower levels in the organization (with larger &quot;level&quot; values) to be processed first by the recursive-select, resulting in a depth-first search:</source>
          <target state="translated">しかし、ORDER BY句を変更して &quot;DESC &quot;修飾子を追加すると、組織内の低レベル(より大きな &quot;レベル &quot;値を持つ)が再帰的選択によって最初に処理され、結果として深さ優先の検索になります。</target>
        </trans-unit>
        <trans-unit id="b73aaf5e4e2de9f2adc91308c0011207fcb7df2b" translate="yes" xml:space="preserve">
          <source>But in a coverage measuring build, the &lt;code&gt;testcase()&lt;/code&gt; macro generates code that evaluates the conditional expression in its argument. Then during analysis, a check is made to ensure tests exist that evaluate the conditional to both true and false. &lt;code&gt;Testcase()&lt;/code&gt; macros are used, for example, to help verify that boundary values are tested. For example:</source>
          <target state="translated">ただし、カバレッジ測定ビルドでは、 &lt;code&gt;testcase()&lt;/code&gt; マクロは、引数の条件式を評価するコードを生成します。次に、分析中に、条件付きを真と偽の両方に評価するテストが存在することを確認するためのチェックが行われます。 &lt;code&gt;Testcase()&lt;/code&gt; マクロは、たとえば、境界値がテストされていることを確認するのに役立ちます。例えば：</target>
        </trans-unit>
        <trans-unit id="6cba989629259efaf3551fd795674dc99bb4d48d" translate="yes" xml:space="preserve">
          <source>But in the following logically equivalent formulation of the same query, the substitution of &quot;CROSS JOIN&quot; for the &quot;,&quot; means that the order of tables must be N1, E, N2.</source>
          <target state="translated">しかし、同じクエリの次の論理的に等価な定式化では、「,」に「CROSS JOIN」を代入すると、テーブルの順序がN1,E,N2にならなければならないことになります。</target>
        </trans-unit>
        <trans-unit id="07070136c4e43ff98642891d2498eeab4c61ffd9" translate="yes" xml:space="preserve">
          <source>But the &quot;.tables&quot; command does more. It queries the sqlite_master table for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases, not just the primary database. And it arranges its output into neat columns.</source>
          <target state="translated">しかし、「。tables」コマンドはさらに多くのことを行います。プライマリデータベースだけでなく、&lt;a href=&quot;lang_attach&quot;&gt;接続さ&lt;/a&gt;れているすべてのデータベースについてsqlite_masterテーブルをクエリします。そして、出力を整然とした列に配置します。</target>
        </trans-unit>
        <trans-unit id="cc1b6b83457a776880f02cbe1ed99910a24b8fb2" translate="yes" xml:space="preserve">
          <source>But the following declaration does not result in &quot;x&quot; being an alias for the rowid:</source>
          <target state="translated">しかし、以下の宣言では、&quot;x &quot;がrowidのエイリアスにはならない。</target>
        </trans-unit>
        <trans-unit id="2d13a39c7ff19d1a4a67287041174bb7cee527dd" translate="yes" xml:space="preserve">
          <source>But the next query can not use the partial index:</source>
          <target state="translated">しかし、次のクエリでは部分インデックスを使用できません。</target>
        </trans-unit>
        <trans-unit id="4968c094e6119e8a687db966e94b26bef2ebe4a4" translate="yes" xml:space="preserve">
          <source>But the use of subtypes does nothing to prevent the value of a pointer from being read using SQL code like this:</source>
          <target state="translated">しかし、サブタイプを使用しても、このようなSQLコードを使用してポインタの値が読み込まれるのを防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="6310277e9a108b401d7850bc8ffad69350ce478c" translate="yes" xml:space="preserve">
          <source>But there are also disadvantages:</source>
          <target state="translated">しかし、デメリットもあります。</target>
        </trans-unit>
        <trans-unit id="f1e940122523fbd2f68feec81164dcb25704b65b" translate="yes" xml:space="preserve">
          <source>But those routines are optional can can be omitted using a &lt;a href=&quot;compile#zero_malloc&quot;&gt;compile-time option&lt;/a&gt;.</source>
          <target state="translated">ただし、これらのルーチンはオプションであり、&lt;a href=&quot;compile#zero_malloc&quot;&gt;コンパイル時オプション&lt;/a&gt;を使用して省略できます。</target>
        </trans-unit>
        <trans-unit id="b843ee326d7f7cdf5b63dd9bf52bb27bf7756e78" translate="yes" xml:space="preserve">
          <source>But what value to choose for N? One might try N=K. This makes the algorithm O(K&lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt;) which is actually still quite efficient, since the maximum value of K is 64 and K rarely exceeds 10. But that is not enough for the TPC-H Q8 problem. With N=8 on TPC-H Q8 the N3 algorithm finds the solution R-N1-C-O-L-S-N2-P with a cost of 29.78. That is a big improvement over NN, but it is still not optimal. N3 finds the optimal solution for TPC-H Q8 when N is 10 or greater.</source>
          <target state="translated">しかし、Nにはどのような値を選択すればよいでしょうか。N = Kを試すかもしれません。K の最大値は64であり、Kはめったに10を超えないため、これはアルゴリズムO（K &lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt;）を実際には非常に効率的にしますが、TPC-H Q8問題には十分ではありません。TPC-H Q8でN = 8の場合、N3アルゴリズムは、29.78のコストでソリューションR-N1-COLS-N2-Pを見つけます。これはNNと比べて大きな改善ですが、それでも最適ではありません。N3は、Nが10以上の場合にTPC-H Q8の最適解を見つけます。</target>
        </trans-unit>
        <trans-unit id="65129801103eda08bf342c707b068d5b768e6daf" translate="yes" xml:space="preserve">
          <source>But with SQLite, 200 or more SQL statement per webpage is not a problem.</source>
          <target state="translated">しかし、SQLiteの場合、1ページあたり200文以上のSQL文があれば問題ありません。</target>
        </trans-unit>
        <trans-unit id="36f51675b3471666e7cff23ca3ceb542e736b084" translate="yes" xml:space="preserve">
          <source>But, generally speaking, the more constraints that the R*Tree module has to work with, and the smaller the bounding box, the faster the results will come back.</source>
          <target state="translated">しかし、一般的には、R*Treeモジュールが作業しなければならない制約が多いほど、また、バウンディングボックスが小さければ小さいほど、結果は早く戻ってきます。</target>
        </trans-unit>
        <trans-unit id="bb3dd504a4ceaa15395efbf567f6c35a7b699cba" translate="yes" xml:space="preserve">
          <source>By &quot;static string&quot;, we mean a zero-terminated array of bytes that is fixed and unchanging for the life of the program. In other words, the pointer type string should be a string constant. In contrast, a &quot;dynamic string&quot; is a zero-terminated array of bytes that is held in memory allocated from the heap, and which must be freed to avoid a memory leak. Do not use dynamic strings as the pointer type string.</source>
          <target state="translated">静的文字列」とは、プログラムの寿命の間、固定で不変のゼロ終端バイト配列を意味します。つまり、ポインタ型の文字列は文字列定数でなければなりません。これに対して、「動的文字列」とは、ヒープから割り当てられたメモリに保持され、メモリリークを避けるために解放しなければならないゼロ終端のバイト配列のことです。ポインタ型文字列として動的文字列を使用してはいけません。</target>
        </trans-unit>
        <trans-unit id="f606d9b23ace8996276bde7ccd24b4d280a3c7c4" translate="yes" xml:space="preserve">
          <source>By adding multiple synonyms for a single term to the FTS index. Using this method, when tokenizing document text, the tokenizer provides multiple synonyms for each token. So that when a document such as &quot;I won first place&quot; is tokenized, entries are added to the FTS index for &quot;i&quot;, &quot;won&quot;, &quot;first&quot;, &quot;1st&quot; and &quot;place&quot;.</source>
          <target state="translated">1つの用語に対する複数の同義語をFTSインデックスに追加することによって。この方法を使用すると、文書テキストをトークン化する際に、トークン化器は各トークンに対して複数の同義語を提供します。そのため、&quot;I won first place &quot;のような文書がトークン化されると、&quot;i&quot;、&quot; won&quot;、&quot;first&quot;、&quot;1st&quot;、&quot;place &quot;のエントリがFTSインデックスに追加されます。</target>
        </trans-unit>
        <trans-unit id="80b3f84643451df0998b16a1d70d04019fc8e45c" translate="yes" xml:space="preserve">
          <source>By combining location data and related information into the same table, auxiliary columns can provide a cleaner model and reduce the need to joins. For example, the earlier &lt;a href=&quot;#diquery&quot;&gt;join between demo_index and demo_data&lt;/a&gt; can now be written as a simple query, like this:</source>
          <target state="translated">位置データと関連情報を同じテーブルに結合することにより、補助列はよりクリーンなモデルを提供し、結合の必要性を減らすことができます。たとえば、&lt;a href=&quot;#diquery&quot;&gt;demo_indexとdemo_dataの間&lt;/a&gt;の以前の結合は、次のように単純なクエリとして記述できます。</target>
        </trans-unit>
        <trans-unit id="e37637c9870320bdf8cbf8ef62058290a2f74da5" translate="yes" xml:space="preserve">
          <source>By configuring a callback to be invoked the first time each table is written to that indicates to the session module whether or not changes on the table should be monitored.</source>
          <target state="translated">各テーブルが最初に書き込まれたときに呼び出されるコールバックを設定することで、テーブルの変更を監視するかどうかをセッションモジュールに指示します。</target>
        </trans-unit>
        <trans-unit id="06b847c7709546cccdb0e536dbda4965ee6a96e1" translate="yes" xml:space="preserve">
          <source>By contrast, if foreign key errors can be recognized simply by looking at the definition of the child table and without having to consult the parent table definition, then the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement for the child table fails. Because the error occurs during a schema change, this is a DDL error. Foreign key DDL errors are reported regardless of whether or not foreign key constraints are enabled when the table is created.</source>
          <target state="translated">対照的に、子テーブルの定義を確認するだけで、親テーブルの定義を調べなくても外部キーエラーを認識できる場合、子テーブルの&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントは失敗します。エラーはスキーマの変更中に発生するため、これはDDLエラーです。テーブルの作成時に外部キー制約が有効かどうかに関係なく、外部キーDDLエラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="aedeaa844f352e8e17d5cb589064ea1e4109a539" translate="yes" xml:space="preserve">
          <source>By default a session object does not monitor changes on any database table. Before it does so it must be configured. There are three ways to configure the set of tables to monitor changes on:</source>
          <target state="translated">デフォルトでは、セッションオブジェクトはどのデータベーステーブルの変更も監視しません。その前に設定しなければなりません。変更を監視するテーブルのセットを設定するには、3つの方法があります。</target>
        </trans-unit>
        <trans-unit id="55442bbcc7ceaf84de94fa28a3aed619ae9955e0" translate="yes" xml:space="preserve">
          <source>By default, &quot;unicode61&quot; attempts to remove diacritics from Latin script characters. This behaviour can be overridden by adding the tokenizer argument &quot;remove_diacritics=0&quot;. For example:</source>
          <target state="translated">デフォルトでは、&quot;unicode61 &quot;はラテン文字から字句を削除しようとします。この動作は、トークン化引数 &quot;remove_diacritics=0&quot; を追加することで上書きすることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="be3a7476bfd030e836d226174214b4408b10de5a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are considered to be non-deterministic. However, if the 4th parameter to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; is OR-ed with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, then SQLite will treat that function as if it were deterministic.</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は非決定的であると見なされます。 4番目のパラメータただし、&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2は（）&lt;/a&gt;とOR結合されている&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;それは決定論的であるかのように、その後、SQLiteは、その関数を処理します。</target>
        </trans-unit>
        <trans-unit id="78cc7d781eb449f29366e3574bdcdf238af76b02" translate="yes" xml:space="preserve">
          <source>By default, FTS queries (those that use the MATCH operator) consider only those rows with the languageid column set to 0. To query for rows with other languageid values, a constraint of the form &quot;</source>
          <target state="translated">デフォルトでは、FTSクエリ(MATCH演算子を使用するクエリ)は、languageid列が0に設定されている行のみを考慮します。 他のlanguageid値を持つ行にクエリを行うには、&quot;</target>
        </trans-unit>
        <trans-unit id="a4ce99b6ecd6b9193290236a519a16ace8c29ade" translate="yes" xml:space="preserve">
          <source>By default, FTS3/4 occasionally merges together two or more of the b-trees that make up its full-text index within an INSERT, UPDATE or DELETE statement executed by the user. This means that any operation on an FTS3/4 table may turn out to be surprisingly slow, as FTS3/4 may unpredictably choose to merge together two or more large b-trees within it. FTS5 uses incremental merging by default, which limits the amount of processing that may take place within any given INSERT, UPDATE or DELETE operation.</source>
          <target state="translated">デフォルトでは、FTS3/4は、ユーザによって実行されたINSERT、UPDATEまたはDELETE文の中で、その全文インデックスを構成する2つ以上のb-木をマージすることがあります。これは、FTS3/4が予測不能に、その中で2つ以上の大きなb-木をマージすることを選択する可能性があるため、FTS3/4テーブルに対する操作が驚くほど遅くなることを意味します。FTS5はデフォルトでインクリメンタルマージを使用しており、INSERT、UPDATE、DELETE操作の中で行われる処理量を制限しています。</target>
        </trans-unit>
        <trans-unit id="f6e0aaa9f2f3d9d7bf351208161c2a3a5ac7e955" translate="yes" xml:space="preserve">
          <source>By default, FTS5 full-text searches are case-independent. Like any other SQL query that does not contain an ORDER BY clause, the example above returns results in an arbitrary order. To sort results by relevance (most to least relevant), an ORDER BY may be added to a full-text query as follows:</source>
          <target state="translated">既定では、FTS5 のフルテキスト検索は大文字と小文字に依存しません。ORDER BY 節を含まない他の SQL クエリと同様に、上記の例では任意の順序で結果を返します。結果を関連性 (最も関連性の高いものから最も関連性の低いものまで)で並べ替えるには、以下のように ORDER BY をフルテキスト クエリに追加することができます。</target>
        </trans-unit>
        <trans-unit id="9bae9dce645a20ac5b291708dfb54aa225ce0774" translate="yes" xml:space="preserve">
          <source>By default, FTS5 maintains a single index recording the location of each token instance within the document set. This means that querying for complete tokens is fast, as it requires a single lookup, but querying for a prefix token can be slow, as it requires a range scan. For example, to query for the prefix token &quot;abc*&quot; requires a range scan of all tokens greater than or equal to &quot;abc&quot; and less than &quot;abd&quot;.</source>
          <target state="translated">デフォルトでは、FTS5はドキュメントセット内の各トークンインスタンスの位置を記録した単一のインデックスを保持します。つまり、完全なトークンのクエリは1回のルックアップで済むので高速ですが、プレフィックストークンのクエリは範囲スキャンが必要なので、時間がかかることがあります。たとえば、プレフィックストークン &quot;abc*&quot;のクエリを行うには、&quot;abc &quot;以上 &quot;abd &quot;未満のすべてのトークンを範囲スキャンする必要があります。</target>
        </trans-unit>
        <trans-unit id="ff82a6b03b77139ee1bba47d5624340bd5b1daef" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that all data uses a fixed-size 8-bit character (iso8859). But if you give the --enable-utf8 option to the configure script, then the library assumes UTF-8 variable sized characters. This makes a difference for the LIKE and GLOB operators and the LENGTH() and SUBSTR() functions. The static string &lt;b&gt;sqlite_encoding&lt;/b&gt; will be set to either &quot;UTF-8&quot; or &quot;iso8859&quot; to indicate how the library was compiled. In addition, the &lt;b&gt;sqlite.h&lt;/b&gt; header file will define one of the macros &lt;b&gt;SQLITE_UTF8&lt;/b&gt; or &lt;b&gt;SQLITE_ISO8859&lt;/b&gt;, as appropriate.</source>
          <target state="translated">デフォルトでは、SQLiteはすべてのデータが固定サイズの8ビット文字（iso8859）を使用すると想定しています。ただし、configureスクリプトに--enable-utf8オプションを指定すると、ライブラリはUTF-8の可変サイズの文字を想定します。これにより、LIKE演算子とGLOB演算子、およびLENGTH（）関数とSUBSTR（）関数に違いが生じます。静的文字列&lt;b&gt;sqlite_encoding&lt;/b&gt;は、「UTF-8」または「iso8859」のいずれかに設定され、ライブラリのコンパイル方法を示します。さらに、&lt;b&gt;sqlite.h&lt;/b&gt;ヘッダーファイルは、必要に応じて、マクロ&lt;b&gt;SQLITE_UTF8&lt;/b&gt;または&lt;b&gt;SQLITE_ISO8859の&lt;/b&gt;&lt;b&gt;いずれ&lt;/b&gt;かを定義します。</target>
        </trans-unit>
        <trans-unit id="cbc8ea1232230a6d65d66bdbfc39e47fe8c9edc5" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that an operating system call to write a range of bytes will not damage or alter any bytes outside of that range even if a power loss or OS crash occurs during that write. We call this the &quot;&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;&quot; property. Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;version 3.7.9&lt;/a&gt; (2011-11-01), SQLite did not assume powersafe overwrite. But with the standard sector size increasing from 512 to 4096 bytes on most disk drives, it has become necessary to assume powersafe overwrite in order to maintain historical performance levels and so powersafe overwrite is assumed by default in recent versions of SQLite. The assumption of powersafe overwrite property can be disabled at compile-time or a run-time if desired. See the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite documentation&lt;/a&gt; for further details.</source>
          <target state="translated">デフォルトでは、SQLiteは、ある範囲のバイトを書き込むためのオペレーティングシステムコールが、その書き込み中に停電やOSクラッシュが発生した場合でも、その範囲外のバイトを損傷または変更しないと想定しています。これを「&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;」プロパティと呼びます。&lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;バージョン3.7.9&lt;/a&gt;（2011-11-01）より前は、SQLiteはpowersafe overwriteを想定していませんでした。ただし、ほとんどのディスクドライブで標準セクターサイズが512から4096バイトに増加しているため、履歴パフォーマンスレベルを維持するためにパワーセーフ上書きを想定する必要があり、SQLiteの最近のバージョンではデフォルトでパワーセーフ上書きが想定されています。 powersafe overwriteプロパティの前提は、必要に応じてコンパイル時または実行時に無効にすることができます。詳細については、&lt;a href=&quot;psow&quot;&gt;powersafe overwriteのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f018eca355fa9ae5d020ba88bd8ea21f258703c5" translate="yes" xml:space="preserve">
          <source>By default, SQLite does a checkpoint automatically when the WAL file reaches a threshold size of 1000 pages. (The &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; compile-time option can be used to specify a different default.) Applications using WAL do not have to do anything in order to for these checkpoints to occur. But if they want to, applications can adjust the automatic checkpoint threshold. Or they can turn off the automatic checkpoints and run checkpoints during idle moments or in a separate thread or process.</source>
          <target state="translated">デフォルトでは、WALファイルがしきい値サイズの1000ページに達すると、SQLiteは自動的にチェックポイントを実行します。 （&lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;コンパイル時オプションを使用して、別のデフォルトを指定できます。）WALを使用するアプリケーションは、これらのチェックポイントを発生させるために何もする必要はありません。ただし、必要に応じて、アプリケーションで自動チェックポイントしきい値を調整できます。または、自動チェックポイントをオフにして、アイドル時に、または別のスレッドやプロセスでチェックポイントを実行することもできます。</target>
        </trans-unit>
        <trans-unit id="c47d73038962ba3e0484234ad47892e41a6eccb3" translate="yes" xml:space="preserve">
          <source>By default, SQLite keeps statistics on its memory usage. These statistics are useful in helping to determine how much memory an application really needs. The statistics can also be used in high-reliability system to determine if the memory usage is coming close to or exceeding the limits of the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; and hence that the memory allocation subsystem is liable to breakdown.</source>
          <target state="translated">デフォルトでは、SQLiteはメモリ使用量の統計を保持します。これらの統計は、アプリケーションが実際に必要とするメモリの量を決定するのに役立ちます。統計を高信頼性システムで使用して、メモリ使用量が&lt;a href=&quot;malloc#nofrag&quot;&gt;ロブソン証明の&lt;/a&gt;制限に近づいている、または超えているかどうか、したがってメモリ割り当てサブシステムが故障している可能性があるかどうかを判断することもできます。</target>
        </trans-unit>
        <trans-unit id="45a42d60e1bd3a274255ba5930fab23192de66e7" translate="yes" xml:space="preserve">
          <source>By default, SQLite obtains the memory it needs for objects and cache from the malloc()/free() implementation of the standard library. There is also on-going work with experimental memory allocators that satisfy all memory requests from a single fixed memory buffer handed to SQLite at application start. Additional information on these experimental memory allocators will be provided in a future revision of this document.</source>
          <target state="translated">デフォルトでは、SQLite はオブジェクトとキャッシュに必要なメモリを標準ライブラリの malloc()/free()の実装から取得します。また、アプリケーションの起動時に SQLite に渡される単一の固定メモリバッファからすべてのメモリ要求を満たす実験的なメモリアロケータの開発も進行中です。これらの実験的なメモリアロケータに関する追加情報は、このドキュメントの将来のリビジョンで提供される予定です。</target>
        </trans-unit>
        <trans-unit id="f1f4239650661b10de63616260d0037b2cc6746e" translate="yes" xml:space="preserve">
          <source>By default, SQLite uses the malloc(), realloc(), and free() routines from the standard C library for its memory allocation needs. These routines are surrounded by a thin wrapper that also provides a &quot;memsize()&quot; function that will return the size of an existing allocation. The memsize() function is needed to keep an accurate count of the number of bytes of outstanding memory; memsize() determines how many bytes to remove from the outstanding count when an allocation is freed. The default allocator implements memsize() by always allocating 8 extra bytes on each malloc() request and storing the size of the allocation in that 8-byte header.</source>
          <target state="translated">デフォルトでは、SQLite は標準 C ライブラリの malloc()、realloc()、free()ルーチンをメモリ割り当てのために使用します。これらのルーチンは薄いラッパーで囲まれており、既存のアロケーションのサイズを返す &quot;memsize()&quot; 関数も提供しています。memsize()関数は、未処理メモリのバイト数を正確にカウントするために必要です。デフォルトのアロケータは、malloc()リクエストごとに常に 8 バイトの余分なバイトを割り当て、その 8 バイトのヘッダにアロケーションのサイズを格納することで memsize()を実装しています。</target>
        </trans-unit>
        <trans-unit id="ac7bf7e7f400c7dac01c89761055dce039c96113" translate="yes" xml:space="preserve">
          <source>By default, SQLite will automatically checkpoint whenever a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs that causes the WAL file to be 1000 pages or more in size, or when the last database connection on a database file closes. The default configuration is intended to work well for most applications. But programs that want more control can force a checkpoint using the &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The automatic checkpoint threshold can be changed or automatic checkpointing can be completely disabled using the &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; C interface. A program can also use &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; to register a callback to be invoked whenever any transaction commits to the WAL. This callback can then invoke &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; or &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; based on whatever criteria it thinks is appropriate. (The automatic checkpoint mechanism is implemented as a simple wrapper around &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;.)</source>
          <target state="translated">デフォルトでは、SQLiteは、WALファイルのサイズが1000ページ以上になる&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;が発生したとき、またはデータベースファイルの最後のデータベース接続が閉じたときに、自動的にチェックポイントを設定します。デフォルトの構成は、ほとんどのアプリケーションで適切に機能するように設計されています。しかし、より多くの制御を必要とするプログラムは、&lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpointプラグマ&lt;/a&gt;を使用するか、&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; Cインターフェースを呼び出すことにより、チェックポイントを強制できます。&lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpointプラグマ&lt;/a&gt;を使用するか、&lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（）&lt;/a&gt; Cインターフェースを呼び出すことにより、自動チェックポイントのしきい値を変更したり、自動チェックポイントを完全に無効にしたりできます。プログラムは&lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;も使用できますトランザクションがWALにコミットするたびに呼び出されるコールバックを登録します。このコールバックは、適切と思われる基準に基づいて、&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt;または&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;を呼び出すことができます。（自動チェックポイントメカニズムは、&lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook（）の&lt;/a&gt;単純なラッパーとして実装されています。）</target>
        </trans-unit>
        <trans-unit id="dfe31588b0add6c729f8eab371bfea7925cb6297" translate="yes" xml:space="preserve">
          <source>By default, VACUUM only works only on the main database. &lt;a href=&quot;lang_attach&quot;&gt;Attached databases&lt;/a&gt; can be vacuumed by appending the appropriate schema-name to the VACUUM statement.</source>
          <target state="translated">デフォルトでは、VACUUMはメインデータベースでのみ機能します。&lt;a href=&quot;lang_attach&quot;&gt;アタッチされたデータベース&lt;/a&gt;は、適切なスキーマ名をVACUUMステートメントに追加することでバキュームできます。</target>
        </trans-unit>
        <trans-unit id="609f717a6d90d2816632d1db2908a5d9109c172f" translate="yes" xml:space="preserve">
          <source>By default, coordinates are stored in an R*Tree using 32-bit floating point values. When a coordinate cannot be exactly represented by a 32-bit floating point number, the lower-bound coordinates are rounded down and the upper-bound coordinates are rounded up. Thus, bounding boxes might be slightly larger than specified, but will never be any smaller. This is exactly what is desired for doing the more common &quot;overlapping&quot; queries where the application wants to find every entry in the R*Tree that overlaps a query bounding box. Rounding the entry bounding boxes outward might cause a few extra entries to appears in an overlapping query if the edge of the entry bounding box corresponds to an edge of the query bounding box. But the overlapping query will never miss a valid table entry.</source>
          <target state="translated">デフ ォ ル ト では、 座標は 32 ビ ッ ト 浮動小数点値を用いて R*Tree に格納されます。座標が32ビット浮動小数点数で正確に表現できない場合は、下位境界の座標は切り捨てられ、上位境界の座標は切り上げられます。したがって、バウンディングボックスは指定されたよりもわずかに大きくなるかもしれませんが、これ以上小さくなることはありません。これは、アプリケーションがR*Treeの中で、クエリのバウンディングボックスと重なるエントリをすべて見つけたいという、より一般的な &quot;オーバーラップ &quot;クエリを行う場合にまさに必要とされるものです。エントリのバウンディングボックスを外側に丸めてしまうと、エントリのバウンディングボックスの端がクエリのバウンディングボックスの端と一致している場合に、重複クエリの中にいくつかの余分なエントリが現れることになります。しかし、オーバーラッピングクエリで有効なテーブルエントリを見逃すことはありません。</target>
        </trans-unit>
        <trans-unit id="199efd35071a0aa576610e8f4fe7005becc87773" translate="yes" xml:space="preserve">
          <source>By default, diacritics are removed from all Latin script characters. This means, for example, that &quot;A&quot;, &quot;a&quot;, &quot;&amp;Agrave;&quot;, &quot;&amp;agrave;&quot;, &quot;&amp;Acirc;&quot; and &quot;&amp;acirc;&quot; are all considered to be equivalent.</source>
          <target state="translated">デフォルトでは、すべてのラテン文字から発音区別符号が削除されます。これは、たとえば、「A」、「a」、「&amp;Agrave;」、「&amp;agrave;」、「&amp;Acirc;」、「&amp;acirc;」はすべて同等と見なされることを意味します。</target>
        </trans-unit>
        <trans-unit id="bb034dd2f0250c21e84e164917272d1dc5842d40" translate="yes" xml:space="preserve">
          <source>By default, differences in the schema or content of virtual tables are not reported on.</source>
          <target state="translated">デフォルトでは、仮想テーブルのスキーマや内容の違いは報告されません。</target>
        </trans-unit>
        <trans-unit id="b77f26d39d106302cf0e476c578f7ebf5e3ef7c7" translate="yes" xml:space="preserve">
          <source>By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced.</source>
          <target state="translated">デフォルトでは、各INSERTステートメントは独自のトランザクションです。ただし、&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;で複数のINSERTステートメントを囲むと、すべての挿入が1つのトランザクションにグループ化されます。トランザクションをコミットするのに必要な時間は、含まれているすべての挿入ステートメントにわたって償却されるため、挿入ステートメントごとの時間が大幅に短縮されます。</target>
        </trans-unit>
        <trans-unit id="6a7a241c9fa980ec6fabd179e76034fe7898c1e2" translate="yes" xml:space="preserve">
          <source>By default, each column is between 1 and 10 characters wide, depending on the column header name and the width of the first column of data. Data that is too wide to fit in a column is truncated. Use the &quot;.width&quot; dot-command to adjust column widths, like this:</source>
          <target state="translated">デフォルトでは、各カラムの幅は、カラムヘッダ名とデータの最初のカラムの幅に応じて、1文字から10文字の間になります。幅が広すぎて列に収まらないデータは切り捨てられます。列の幅を調整するには、このように「.width」ドットコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="5e4318cdb175f91c3caf7375a2080f232459374d" translate="yes" xml:space="preserve">
          <source>By default, every row in SQLite has a special column, usually called the &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;&quot;, that uniquely identifies that row within the table. However if the phrase &quot;WITHOUT ROWID&quot; is added to the end of a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, then the special &quot;rowid&quot; column is omitted. There are sometimes space and performance advantages to omitting the rowid.</source>
          <target state="translated">デフォルトでは、SQLiteのすべての行には、通常「&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;」と呼ばれる特別な列があり、テーブル内のその行を一意に識別します。ただし、「WITHOUT ROWID」という句が&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントの最後に追加される場合、特別な「rowid」列は省略されます。ROWIDを省略した方が、スペースとパフォーマンスの面で有利な場合があります。</target>
        </trans-unit>
        <trans-unit id="d6ef17af0abc70adef74ccbccb6e7ada9c1f618f" translate="yes" xml:space="preserve">
          <source>By default, kvtest runs the database I/O measurements all within a single transaction. Use the --multitrans option to run each blob read or write in a separate transaction. The --multitrans option makes SQLite much slower, and uncompetitive with direct disk I/O. This option proves, yet again, that to get the most performance out of SQLite, you should group as much database interaction as possible within a single transaction.</source>
          <target state="translated">デフォルトでは、kvtestはデータベースのI/O測定をすべて1つのトランザクション内で実行します。multitransオプションを使用すると、各ブロブの読み書きを別々のトランザクションで実行することができます。multitransオプションはSQLiteの動作をかなり遅くし、直接のディスクI/Oとは競合しません。このオプションは、SQLite のパフォーマンスを最大限に引き出すためには、できるだけ多くのデータベースの相互作用を単一のトランザクション内でグループ化する必要があることを改めて証明しています。</target>
        </trans-unit>
        <trans-unit id="a027e685d0b82e63c37ab615c6c8b1bef894cf6d" translate="yes" xml:space="preserve">
          <source>By default, sqldiff attempts to process all non-virtual tables within the two databases provided to it. If any table appears in one database but not the other, or if any table has a slightly different schema in one database it is an error. The &quot;--table&quot; option may be useful if this causes a problem</source>
          <target state="translated">デフォルトでは、sqldiffは提供された2つのデータベース内のすべての非仮想テーブルを処理しようとします。片方のデータベースにはテーブルがあってももう片方のデータベースにはない場合や、片方のデータベースにあるテーブルのスキーマが微妙に異なる場合はエラーとなります。これが問題を引き起こす場合は、&quot;--table &quot;オプションが便利です。</target>
        </trans-unit>
        <trans-unit id="46b22419bd1a4fd00ad28b08bf067b6f9f4f5e90" translate="yes" xml:space="preserve">
          <source>By default, sqlite3 sends query results to standard output. You can change this using the &quot;.output&quot; and &quot;.once&quot; commands. Just put the name of an output file as an argument to .output and all subsequent query results will be written to that file. Or use the .once command instead of .output and output will only be redirected for the single next command before reverting to the console. Use .output with no arguments to begin writing to standard output again. For example:</source>
          <target state="translated">デフォルトでは、sqlite3はクエリ結果を標準出力に送ります。これは&quot;.output &quot;と&quot;.once &quot;コマンドを使って変更することができます。.outputの引数に出力ファイル名を指定するだけで、それ以降の全てのクエリ結果はそのファイルに書き込まれます。あるいは、.outputの代わりに.onceコマンドを使用すると、出力はコンソールに戻る前に次のコマンドのためだけにリダイレクトされます。再び標準出力への書き込みを開始するには、引数なしの.outputを使用します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e508a45fb514da22df2b29ba2714c0232eb3c718" translate="yes" xml:space="preserve">
          <source>By default, swarmvtab attempts to limit the number of simultaneously open databases to nine. This parameter allows that limit to be changed. For example, to create a swarmvtab table that may hold up to 30 databases open simultaneously:</source>
          <target state="translated">既定では、swarmvtabは同時に開くデータベースの数を9個に制限しようとします。このパラメータでは、この制限を変更することができます。たとえば、同時に開いているデータベースを最大 30 個まで保持する swarmvtab テーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="aac34cb1103bf35fa437aa535e48e93e51a7d344" translate="yes" xml:space="preserve">
          <source>By default, the &quot;.expert&quot; command recommends indexes based on the query and database schema alone. This is similar to the way the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; selects indexes for queries if the user has not run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on the database to generate data distribution statistics.</source>
          <target state="translated">デフォルトでは、「。expert」コマンドは、クエリとデータベーススキーマのみに基づいてインデックスを推奨します。これは、ユーザーがデータベースで&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドを実行してデータ分散統計を生成していない場合に、&lt;a href=&quot;optoverview&quot;&gt;SQLiteクエリプランナー&lt;/a&gt;がクエリのインデックスを選択する方法に似ています。</target>
        </trans-unit>
        <trans-unit id="79e59781472aaf1cab549c7756351e991a52f37c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will automatically invoke &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; to reset the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; if necessary. This compile-time option changes that behavior so that &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; will return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it called again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, or &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; unless there was an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;.</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;インターフェースは自動的に&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;を呼び出し、必要に応じて&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;をリセットします。そのように、このコンパイル時のオプションは、その動作を変更&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）が&lt;/a&gt;返されます&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;、それ以外の何も戻った後、再び呼び出された場合&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;、&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;、または&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKEDを&lt;/a&gt;する介在呼び出しがあった場合を除き&lt;a href=&quot;c3ref/reset&quot;&gt;（）sqlite3_resetを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8f030cbd6427054daf45dea55ca6b9a3924a3dd" translate="yes" xml:space="preserve">
          <source>By default, the SQLite core double checks all constraints on each row of the virtual table that it receives. If such a check is redundant, the xBestFilter method can suppress that double-check by setting aConstraintUsage[].omit.</source>
          <target state="translated">デフォルトでは、SQLiteコアは受信した仮想テーブルの各行のすべての制約をダブルチェックします。そのようなチェックが冗長な場合、xBestFilterメソッドは、aConstraintUsage[].omitを設定することで、そのダブルチェックを抑制することができます。</target>
        </trans-unit>
        <trans-unit id="fa0f172004db89e74c2b903c6ed15681a8554ce0" translate="yes" xml:space="preserve">
          <source>By default, the output of EXPLAIN QUERY PLAN commands does not include output for any operations performed by trigger programs. This option is used to set or clear (the default) a flag that governs this behavior. The first parameter passed to this operation is an integer - positive to enable output for trigger programs, or zero to disable it, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if it is not disabled, 1 if it is.</source>
          <target state="translated">デフォルトでは、EXPLAIN QUERY PLANコマンドの出力には、トリガプログラムによって実行された操作の出力は含まれません。このオプションは、この動作を制御するフラグを設定またはクリア(デフォルト)するために使用されます。この操作に渡される最初のパラメータは整数で、正の場合はトリガプログラムの出力を有効にし、ゼロの場合は無効にし、負の場合は設定を変更しないままにします。2 番目のパラメータは整数へのポインタで、0 または 1 が書き込まれ、トリガ用出力が無効化されているかどうかを示します-無効化されていない場合は 0、無効化されている場合は 1 となります。</target>
        </trans-unit>
        <trans-unit id="d45ac6e349cce0d243d17d663e9e87155d75add6" translate="yes" xml:space="preserve">
          <source>By default, the porter tokenizer operates as a wrapper around the default tokenizer (unicode61). Or, if one or more extra arguments are added to the &quot;tokenize&quot; option following &quot;porter&quot;, they are treated as a specification for the underlying tokenizer that the porter stemmer uses. For example:</source>
          <target state="translated">デフォルトでは、porter トークン化機能は、デフォルトのトークン化機能 (unicode61)のラッパーとして動作します。あるいは、&quot;porter&quot; の後の &quot;tokenize&quot; オプションに 1 つ以上の追加引数が追加された場合、それらは、 porter ステム機能が使用するトークン化方式の指定として扱われます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="923e8b64eceb6502080849392eadafdbb5ce98eb" translate="yes" xml:space="preserve">
          <source>By default, the sessions module streaming interfaces attempt to input and output data in approximately 1 KiB chunks. This operand may be used to set and query the value of this configuration setting. The pointer passed as the second argument must point to a value of type (int). If this value is greater than 0, it is used as the new streaming data chunk size for both input and output. Before returning, the (int) value pointed to by pArg is set to the final value of the streaming interface chunk size.</source>
          <target state="translated">デフォルトでは、セッション・モジュールのストリーミング・インターフェースは、約1KiBのチャンクでデータを入出力しようとします。このオペランドは、この構成設定の値を設定したり、問い合わせたりするために使用することができます。第2引数として渡されるポインタは、型(int)の値を指す必要があります。この値が0より大きい場合は、入力と出力の両方の新しいストリーミング・データ・チャンク・サイズとして使用されます。復帰する前に、pArgが指す(int)型の値は、ストリーミング・インタフェース・チャンク・サイズの最終値に設定されます。</target>
        </trans-unit>
        <trans-unit id="ed67e473742eb7c111c47a0cfdbbdb68f21a394b" translate="yes" xml:space="preserve">
          <source>By default, the shell is now in &quot;auto-explain&quot; mode. The output of &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; commands is automatically formatted.</source>
          <target state="translated">デフォルトでは、シェルは「自動説明」モードになっています。&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;コマンドの出力は自動的にフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="52d930b9eee7711ba25f4fd9b5cbc893a2bf348f" translate="yes" xml:space="preserve">
          <source>By default, the spellfix1 table returns no more than 20 results. (It might return less than 20 if there were fewer good matches.) You can change the upper bound on the number of returned rows by adding a &quot;top=N&quot; term to the WHERE clause of your query, where N is the new maximum. For example, to see the 5 best matches:</source>
          <target state="translated">デフォルトでは、spellfix1 テーブルが返す結果は 20 件以下となっています (マッチするものが少ない場合は 20 件以下になるかもしれません)。返される行数の上限を変更するには、クエリの WHERE 句に &quot;top=N&quot; を追加します。例えば、ベストマッチ5を表示するには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="fa387565dd5968c7d1760a2e2262809354a9a035" translate="yes" xml:space="preserve">
          <source>By enclosing it in double quotes (&quot;). Within a string, any embedded double quote characters may be escaped SQL-style - by adding a second double-quote character.</source>
          <target state="translated">二重引用符(&quot;)で囲むことで、文字列の中に埋め込まれた二重引用符はSQLスタイルでエスケープすることができます。文字列の中に二重引用符で囲まれた文字は、二重引用符の二番目の文字を追加することで、SQLスタイルでエスケープすることができます。</target>
        </trans-unit>
        <trans-unit id="84617083eaab12542d0a6d482dc6332adeedf772" translate="yes" xml:space="preserve">
          <source>By explicitly specifying tables using one call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; for each table, or</source>
          <target state="translated">テーブルごとに&lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach（）&lt;/a&gt;への1回の呼び出しを使用してテーブルを明示的に指定する、または</target>
        </trans-unit>
        <trans-unit id="7ec7970e0cfef9d2d98bfdb89f93e1b8b4b4b117" translate="yes" xml:space="preserve">
          <source>By invoking the xCheckReservedLock() method of the file-handle opened on the database file, SQLite checks if some other connection holds a</source>
          <target state="translated">データベースファイル上で開かれたファイルハンドルの xCheckReservedLock()メソッドを呼び出すことで、SQLite は他の接続が</target>
        </trans-unit>
        <trans-unit id="e392907538e008d1f980f80b5391101815ed2a70" translate="yes" xml:space="preserve">
          <source>By mapping all synonyms to a single token. In this case, the In the above example, this means that the tokenizer returns the same token for inputs &quot;first&quot; and &quot;1st&quot;. Say that token is in fact &quot;first&quot;, so that when the user inserts the document &quot;I won 1st place&quot; entries are added to the index for tokens &quot;i&quot;, &quot;won&quot;, &quot;first&quot; and &quot;place&quot;. If the user then queries for '1st + place', the tokenizer substitutes &quot;first&quot; for &quot;1st&quot; and the query works as expected.</source>
          <target state="translated">すべての同義語を1つのトークンにマッピングすることで この場合は 上記の例では、トークンライザは入力「1位」と「1位」に対して同じトークンを返すことを意味しています。トークンが実際には「1st」であるとすると、ユーザーがドキュメント「I won 1st place」を挿入すると、トークン「i」、「 won」、「first」、「place」のインデックスにエントリが追加されます。ユーザーが「1st+place」のクエリを行うと、トークンライザは「1st」を「1st」に置き換え、クエリは期待通りに動作します。</target>
        </trans-unit>
        <trans-unit id="f19cb00f7026582f508ec895d006b5124a9aeb30" translate="yes" xml:space="preserve">
          <source>By querying the index for all synonyms of each query term separately. In this case, when tokenizing query text, the tokenizer may provide multiple synonyms for a single term within the document. FTS5 then queries the index for each synonym individually. For example, faced with the query:</source>
          <target state="translated">各クエリ用語のすべての同義語を別々にインデックスに問い合わせることによって。この場合、クエリテキストをトークン化するとき、トークン化器は文書内の単一の用語に対して複数の同義語を提供することがある。FTS5は、各同義語のインデックスを個別に問い合わせます。例えば、クエリに直面した場合。</target>
        </trans-unit>
        <trans-unit id="55b05786af4043a1be86d71e95ee1411780e7ee4" translate="yes" xml:space="preserve">
          <source>By setting it to an empty string to create a contentless FTS5 table. In this case FTS5 assumes that the original column values are unavailable to it when processing queries. Full-text queries and some auxiliary functions can still be used, but no column values apart from the rowid may be read from the table.</source>
          <target state="translated">空の文字列に設定することで、コンテントレスなFTS5テーブルを作成します。この場合、FTS5は、クエリを処理する際に元のカラム値が利用できないことを前提としています。フルテキストクエリやいくつかの補助関数はまだ使用できますが、 rowid以外のカラム値はテーブルから読み取れません。</target>
        </trans-unit>
        <trans-unit id="61a66a14e7dcfe0861d93ec30802747dfb7523a1" translate="yes" xml:space="preserve">
          <source>By setting it to the name of a database object (table, virtual table or view) that may be queried by FTS5 at any time to retrieve the column values. This is known as an &quot;external content&quot; table. In this case all FTS5 functionality may be used, but it is the responsibility of the user to ensure that the contents of the full-text index are consistent with the named database object. If they are not, query results may be unpredictable.</source>
          <target state="translated">これを設定することで、FTS5が列の値を取得するためにいつでも照会できるデータベースオブジェクト(テーブル、仮想テーブル、またはビュー)の名前にすることができます。これは「外部コンテンツ」テーブルとして知られています。この場合、FTS5のすべての機能を使用することができますが、フルテキストインデックスの内容が名前のついたデータベースオブジェクトと一致していることを確認するのはユーザーの責任です。もしそうでない場合、クエリの結果は予測できないものになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b65e88a6a0b747d6c1e54c4edd9925d09b470f08" translate="yes" xml:space="preserve">
          <source>By specifying that all tables in the database should be monitored for changes using a call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; with a NULL argument, or</source>
          <target state="translated">NULL引数を指定した&lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach（）の&lt;/a&gt;呼び出しを使用して、データベース内のすべてのテーブルの変更を監視するように指定する、または</target>
        </trans-unit>
        <trans-unit id="63f834f4a2da63acc54bc935f1fd1ad5ded1c97a" translate="yes" xml:space="preserve">
          <source>By the time &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is invoked by wait_for_unlock_notify(), it is possible that the blocking connection that prevented the sqlite3_step() or sqlite3_prepare_v2() call from succeeding has already finished its transaction. In this case, the unlock-notify callback is invoked immediately, before &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; returns. Or, it is possible that the unlock-notify callback is invoked by a second thread after &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called but before the thread starts waiting to be asynchronously signaled.</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;がwait_for_unlock_notify（）によって呼び出されるときまでに、sqlite3_step（）またはsqlite3_prepare_v2（）呼び出しの成功を妨げていたブロッキング接続がすでにトランザクションを終了している可能性があります。この場合、&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;が戻る前に、すぐにロック解除通知コールバックが呼び出されます。または、&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;が呼び出された後で、スレッドが非同期にシグナルされるのを待機する前に、2番目のスレッドによってロック解除通知コールバックが呼び出される可能性があります。</target>
        </trans-unit>
        <trans-unit id="294016815718412ee0c20270b6745c8ced5712e1" translate="yes" xml:space="preserve">
          <source>By using its own built-in implementation, SQLite guarantees that the output will be the same on all platforms and in all LOCALEs. This is important for consistency and for testing. It would be problematic if one machine gave and answer of &quot;5.25e+08&quot; and another gave an answer of &quot;5.250e+008&quot;. Both answers are correct, but it is better when SQLite always gives the same answer.</source>
          <target state="translated">独自の組み込み実装を使用することで、SQLiteはすべてのプラットフォームとすべてのLOCALEで出力が同じであることを保証します。これは一貫性とテストのために重要です。あるマシンが &quot;5.25e+08 &quot;と答え、別のマシンが &quot;5.250e+008 &quot;と答えたとします。どちらの答えも正しいのですが、SQLiteが常に同じ答えを出す方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="478bcd9433faa7931ee1c7c1b62ccda2a8f4f8e8" translate="yes" xml:space="preserve">
          <source>By using standard SQL expressions in the WHERE clause of a SELECT query, a programmer can query for all R*Tree entries that intersect with or are contained within a particular bounding-box. Custom R*Tree queries, using the MATCH operator in the WHERE clause of a SELECT, allow the programmer to query for the set of R*Tree entries that intersect any arbitrary region or shape, not just a box. This capability is useful, for example, in computing the subset of objects in the R*Tree that are visible from a camera positioned in 3-D space.</source>
          <target state="translated">SELECTクエリのWHERE句で標準SQL式を使用することで、プログラマは特定のバウンディングボックスと交差する、または特定のバウンディングボックス内に含まれるすべてのR*Treeエントリをクエリすることができます。SELECTのWHERE句でMATCH演算子を使用したカスタムR*Treeクエリでは、プログラマは、ボックスだけでなく、任意の領域や形状と交差するR*Treeエントリのセットを検索することができます。この機能は、例えば、3D空間に配置されたカメラから見えるR*Tree内のオブジェクトのサブセットを計算するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="89a11056dc1624db725c970738aa5aaf2b86e420" translate="yes" xml:space="preserve">
          <source>Byte offset</source>
          <target state="translated">バイトオフセット</target>
        </trans-unit>
        <trans-unit id="40c37d34180ee81abeec6396f466a7bf1d1f2f45" translate="yes" xml:space="preserve">
          <source>Bytecode Engine</source>
          <target state="translated">バイトコードエンジン</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="6e99d2b1b3cf05d1cb901ea3f769e34d773ba90a" translate="yes" xml:space="preserve">
          <source>Bytes 12-15 of the</source>
          <target state="translated">のバイト12~15</target>
        </trans-unit>
        <trans-unit id="89a9bc1f87191389726b0ed1804032da963a975c" translate="yes" xml:space="preserve">
          <source>Bytes 16-19 of the</source>
          <target state="translated">の16~19バイト目</target>
        </trans-unit>
        <trans-unit id="24778eba404891c29eb268fa4b3c469a05e3f5af" translate="yes" xml:space="preserve">
          <source>Bytes 20-23 of the</source>
          <target state="translated">の20~23バイト目の</target>
        </trans-unit>
        <trans-unit id="5e820fc3c84f6f51bd1f6afe4e8dd983524446cf" translate="yes" xml:space="preserve">
          <source>Bytes 24-27 of the</source>
          <target state="translated">の24~27バイト目の</target>
        </trans-unit>
        <trans-unit id="eb167d60299b524eb07991d2141957c03c9ee5cd" translate="yes" xml:space="preserve">
          <source>Bytes 8-11 of the</source>
          <target state="translated">の8~11バイト目</target>
        </trans-unit>
        <trans-unit id="a3587157a4089ec8301b2d0f784b91a32e9749e3" translate="yes" xml:space="preserve">
          <source>Bytes of unused &quot;reserved&quot; space at the end of each page. Usually 0.</source>
          <target state="translated">各ページの最後にある未使用の「予約済み」スペースのバイト数。通常は0。</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="4f3cd44d015b24e6fbf168b36aa5120966aaf5ed" translate="yes" xml:space="preserve">
          <source>C API Requirements Document.</source>
          <target state="translated">C API 要件ドキュメント。</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">Cインタフェース</target>
        </trans-unit>
        <trans-unit id="d5efbb98716c6e33e7f3412795c630f8a8a66abd" translate="yes" xml:space="preserve">
          <source>C Interface: Session Module</source>
          <target state="translated">C インターフェイス。セッションモジュール</target>
        </trans-unit>
        <trans-unit id="444516d338383f2d17d8f93aa996b6cd1762c79a" translate="yes" xml:space="preserve">
          <source>C is a great language for writing fast code. C is sometimes described as &quot;portable assembly language&quot;. It enables to developers to code as close to the underlying hardware as possible while still remaining portable across platforms.</source>
          <target state="translated">C言語は高速なコードを書くのに最適な言語です。C言語は「ポータブルなアセンブリ言語」と表現されることもあります。開発者は、プラットフォーム間での移植性を維持しながら、可能な限り基盤となるハードウェアに近いコードを書くことができます。</target>
        </trans-unit>
        <trans-unit id="58790293552f75d17353d3ee29e85a197a62dcbb" translate="yes" xml:space="preserve">
          <source>C-language Interface Specification for SQLite</source>
          <target state="translated">SQLite 用 C 言語インタフェース仕様書</target>
        </trans-unit>
        <trans-unit id="1ac091b19baa70bc10c3d1156fe018d4a8f6ef6b" translate="yes" xml:space="preserve">
          <source>C-style comments are now accepted by the tokenizer.</source>
          <target state="translated">C スタイルのコメントがトークンizer で受け入れられるようになりました。</target>
        </trans-unit>
        <trans-unit id="d4948b1f21c9b5ee92aa9e005ab2ec94317e417f" translate="yes" xml:space="preserve">
          <source>C-style comments begin with &quot;/*&quot; and extend up to and including the next &quot;*/&quot; character pair or until the end of input, whichever comes first. C-style comments can span multiple lines.</source>
          <target state="translated">C スタイルのコメントは &quot;/*&quot; で始まり、次の &quot;*/&quot; 文字ペアまで、または入力終了時まで、どちらか早い方の行になります。C スタイルのコメントは複数行に渡ることができます。</target>
        </trans-unit>
        <trans-unit id="e693971cd8c5db36eaa639a8f7f4320b5c7557fd" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3</source>
          <target state="translated">SQLite バージョン 3 の C/C++インターフェイス</target>
        </trans-unit>
        <trans-unit id="b7c9ebb838da580ee5ce0a6b6d3fb9492aadd0cf" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3 (old)</source>
          <target state="translated">C/C++Interface For SQLite Version 3 (旧版)</target>
        </trans-unit>
        <trans-unit id="629369eadf6dbb7e5f1900a3d284a7d0ebdf8449" translate="yes" xml:space="preserve">
          <source>CASCADE</source>
          <target state="translated">CASCADE</target>
        </trans-unit>
        <trans-unit id="55c417bda058d7601349aeb7556e3d8607c77f5d" translate="yes" xml:space="preserve">
          <source>CASE</source>
          <target state="translated">CASE</target>
        </trans-unit>
        <trans-unit id="24e95e83710f86d66debac57b5addb22a9ce7983" translate="yes" xml:space="preserve">
          <source>CASE WHEN x=w1 THEN r1 WHEN x=w2 THEN r2 ELSE r3 END</source>
          <target state="translated">CASE WHEN X=W1 THEN r1 WHEN X=W2 THEN r2 ELSE r3 END</target>
        </trans-unit>
        <trans-unit id="fcb688501c6a701cda488771d9ab7d2ba8fccbb2" translate="yes" xml:space="preserve">
          <source>CASE expression</source>
          <target state="translated">ケース式</target>
        </trans-unit>
        <trans-unit id="c688feeff7f51b86a16bfff0e478b5a113fd0c4a" translate="yes" xml:space="preserve">
          <source>CASE x WHEN w1 THEN r1 WHEN w2 THEN r2 ELSE r3 END</source>
          <target state="translated">CASE x WHEN w1 THEN r1 WHEN w2 THEN r2 ELSE r3 END</target>
        </trans-unit>
        <trans-unit id="274ad8f8387ab7001d3681011456578f35fd9e46" translate="yes" xml:space="preserve">
          <source>CAST</source>
          <target state="translated">CAST</target>
        </trans-unit>
        <trans-unit id="bc9630c4f8bc64a9ad87f06d690b75d5f8954d78" translate="yes" xml:space="preserve">
          <source>CAST expressions</source>
          <target state="translated">CAST式</target>
        </trans-unit>
        <trans-unit id="2bab9f8d26cc3165f0ac936b287a5e9381a51aad" translate="yes" xml:space="preserve">
          <source>CAST operator</source>
          <target state="translated">CAST演算子</target>
        </trans-unit>
        <trans-unit id="57c58f87e406bfa72b5233a68e16e6ce57b58a9a" translate="yes" xml:space="preserve">
          <source>CHANGESET_CONFLICT is passed as the second argument to the conflict handler while processing an INSERT change if the operation would result in duplicate primary key values.</source>
          <target state="translated">CHANGESET_CONFLICTは、主キーの値が重複している場合にINSERT変更を処理する際に、コンフリクト・ハンドラの第2引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="49279edf04879138e2ca01fe4da87f165bb8a556" translate="yes" xml:space="preserve">
          <source>CHAR</source>
          <target state="translated">CHAR</target>
        </trans-unit>
        <trans-unit id="ec67cd542d6d42f84f8aea6727411112c2a9eee5" translate="yes" xml:space="preserve">
          <source>CHARACTER(20)</source>
          <target state="translated">CHARACTER(20)</target>
        </trans-unit>
        <trans-unit id="d37267cb2995cccac2283009e1ea4f3a6dd37db3" translate="yes" xml:space="preserve">
          <source>CHECK</source>
          <target state="translated">CHECK</target>
        </trans-unit>
        <trans-unit id="7c8e71cdac81d935a110e970f2e16db27f75d5ec" translate="yes" xml:space="preserve">
          <source>CHECK constraint</source>
          <target state="translated">チェック制約</target>
        </trans-unit>
        <trans-unit id="91f48f96fc5990f4b552ae5c63dd0114792c0da9" translate="yes" xml:space="preserve">
          <source>CHECK constraints</source>
          <target state="translated">チェック制約</target>
        </trans-unit>
        <trans-unit id="6c581d4e90f448ac099620dc82b1bf15e3863e36" translate="yes" xml:space="preserve">
          <source>CHECK constraints use conflict resolution algorithms correctly.</source>
          <target state="translated">CHECK 制約は、紛争解決アルゴリズムを正しく使用します。</target>
        </trans-unit>
        <trans-unit id="700b401ca52b1bd3071dc838bf11be9cdb19fc5f" translate="yes" xml:space="preserve">
          <source>CLI</source>
          <target state="translated">CLI</target>
        </trans-unit>
        <trans-unit id="eb02003c667c1e9ee2fcede2fd0524e495d8ec1b" translate="yes" xml:space="preserve">
          <source>CLOB</source>
          <target state="translated">CLOB</target>
        </trans-unit>
        <trans-unit id="28248452f38e0300dc7c45ab12fbe5d41f97e047" translate="yes" xml:space="preserve">
          <source>COLLATE</source>
          <target state="translated">COLLATE</target>
        </trans-unit>
        <trans-unit id="114fac2d95aa36c73c87444e3e119061a6c497e8" translate="yes" xml:space="preserve">
          <source>COLLATE operator</source>
          <target state="translated">コレクト演算子</target>
        </trans-unit>
        <trans-unit id="d59db8880904cdfee22d4bdd9e5cb72c42fae180" translate="yes" xml:space="preserve">
          <source>COLUMN</source>
          <target state="translated">COLUMN</target>
        </trans-unit>
        <trans-unit id="17e4d773881595e83eed7274990576cb3c33d081" translate="yes" xml:space="preserve">
          <source>COMMIT</source>
          <target state="translated">COMMIT</target>
        </trans-unit>
        <trans-unit id="b8bace9ba33552e80165d3ede409bac3b53e9442" translate="yes" xml:space="preserve">
          <source>COMMIT TRANSACTION</source>
          <target state="translated">コミットトランザクション</target>
        </trans-unit>
        <trans-unit id="5be9cfb9ef50ef7a3f4855f3a3912ced47c9cd37" translate="yes" xml:space="preserve">
          <source>COMMIT;</source>
          <target state="translated">COMMIT;</target>
        </trans-unit>
        <trans-unit id="716a4859cb65ba79cf0a75301f937ee8dd84b958" translate="yes" xml:space="preserve">
          <source>CONFLICT</source>
          <target state="translated">CONFLICT</target>
        </trans-unit>
        <trans-unit id="eb44b374436f71b41c8c59982685ea220ef821e2" translate="yes" xml:space="preserve">
          <source>CONSTRAINT</source>
          <target state="translated">CONSTRAINT</target>
        </trans-unit>
        <trans-unit id="cabc2219177d43a5c1d71e3003445f83b9a7195f" translate="yes" xml:space="preserve">
          <source>CREATE</source>
          <target state="translated">CREATE</target>
        </trans-unit>
        <trans-unit id="4dfe073e739c382b273bdf0f1bdd27e7f10f38af" translate="yes" xml:space="preserve">
          <source>CREATE INDEX</source>
          <target state="translated">CREATE INDEX</target>
        </trans-unit>
        <trans-unit id="d5c16f75a09033a1e8f65102b202f3992bcbc039" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2a ON t2(a);</source>
          <target state="translated">CREATE INDEX i2a ON t2(a).</target>
        </trans-unit>
        <trans-unit id="219d80e293971a20fc410c1cb42fe81ee5be3296" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2b ON t2(b);</source>
          <target state="translated">CREATE INDEX i2b ON t2(b).</target>
        </trans-unit>
        <trans-unit id="015ef83633db6629be0b04929a85c6e8362366cf" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i3 ON t3(c);</source>
          <target state="translated">CREATE INDEX i3 ON t3(c).</target>
        </trans-unit>
        <trans-unit id="979ae29e43d609d39c91f43b7d2c9c6f0170c84c" translate="yes" xml:space="preserve">
          <source>CREATE TABLE</source>
          <target state="translated">クリエイトテーブル</target>
        </trans-unit>
        <trans-unit id="61fe1c0db27d323fd657d34129f0370eddfd6b9e" translate="yes" xml:space="preserve">
          <source>CREATE TABLE ... AS SELECT Statements</source>
          <target state="translated">CREATE TABLE ...AS SELECT ステートメント</target>
        </trans-unit>
        <trans-unit id="fdc5603516a1557309c21e74d5f3a300d7053f48" translate="yes" xml:space="preserve">
          <source>CREATE TABLE AS</source>
          <target state="translated">CREATE TABLE AS</target>
        </trans-unit>
        <trans-unit id="5c1879760c0ac0151021a298b71fc43dd31ae043" translate="yes" xml:space="preserve">
          <source>CREATE TABLE Statement</source>
          <target state="translated">CREATE TABLE ステートメント</target>
        </trans-unit>
        <trans-unit id="ef4e542d71b6fc791055be2754c8bba0c238f3b8" translate="yes" xml:space="preserve">
          <source>CREATE TABLE and DROP TABLE now work correctly as prepared statements.</source>
          <target state="translated">CREATE TABLEとDROP TABLEが準備されたステートメントとして正しく動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="6a035b079a1ff283fd14f7d5c5ea363c26b68cda" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t1(a INTEGER,b INTEGER,c VARCHAR(100))。</target>
        </trans-unit>
        <trans-unit id="4619a9be564e2fbde661edf547e025b44154bc1f" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b PRIMARY KEY);</source>
          <target state="translated">CREATE TABLE t1(a,b PRIMARY KEY).</target>
        </trans-unit>
        <trans-unit id="7b5a4e879f5838c381c1aaf9522123d8eb51ef28" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b UNIQUE);</source>
          <target state="translated">CREATE TABLE t1(a,b UNIQUE).</target>
        </trans-unit>
        <trans-unit id="472c250359f0aac3ac59d709bce28e56fc427ab7" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b);</source>
          <target state="translated">CREATE TABLE t1(a,b).</target>
        </trans-unit>
        <trans-unit id="b180c72a56f1e353661ad8a8bf096de1e31921fa" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(c1 VARIANT);</source>
          <target state="translated">CREATE TABLE t1(c1 VARIANT).</target>
        </trans-unit>
        <trans-unit id="6c723a031c86a4c7b06f2a3f8d60439c8dcf6107" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t2(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t2(a INTEGER,b INTEGER,c VARCHAR(100))。</target>
        </trans-unit>
        <trans-unit id="ffb49dd96e70cfeec18ece99b548162395148801" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t3(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t3(a INTEGER,b INTEGER,c VARCHAR(100))。</target>
        </trans-unit>
        <trans-unit id="cf6418466d171e86053f358e78bdbbeb775f1f4f" translate="yes" xml:space="preserve">
          <source>CREATE TRIGGER</source>
          <target state="translated">CREATE TRIGGER</target>
        </trans-unit>
        <trans-unit id="4862717c14fde4c95f9fc018bad5f1bcdf240d46" translate="yes" xml:space="preserve">
          <source>CREATE UNIQUE INDEX t1b ON t1(b);</source>
          <target state="translated">CREATE UNIQUE INDEX t1b ON t1(b).</target>
        </trans-unit>
        <trans-unit id="c6d65be0664c12895eed3811d312f2344a61a809" translate="yes" xml:space="preserve">
          <source>CREATE VIEW</source>
          <target state="translated">クリエイトビュー</target>
        </trans-unit>
        <trans-unit id="d37bcac589dd2e6a2d9d1fe15b402952fac86edd" translate="yes" xml:space="preserve">
          <source>CREATE VIRTUAL TABLE</source>
          <target state="translated">CREATE VIRTUAL TABLE</target>
        </trans-unit>
        <trans-unit id="3fed731b971838462d00ae70d200fd38b7750b9e" translate="yes" xml:space="preserve">
          <source>CREATE and DROP</source>
          <target state="translated">CREATE と DROP</target>
        </trans-unit>
        <trans-unit id="7ea4fbcff919d74664df2b3abbe9c64927134ca1" translate="yes" xml:space="preserve">
          <source>CROSS</source>
          <target state="translated">CROSS</target>
        </trans-unit>
        <trans-unit id="23cb1ba2135af54bb7f9dc4ac628c8c16b1274c8" translate="yes" xml:space="preserve">
          <source>CSV export</source>
          <target state="translated">CSVエクスポート</target>
        </trans-unit>
        <trans-unit id="41b55f7f4ea3b51535ca8d9719be622b0aa72549" translate="yes" xml:space="preserve">
          <source>CSV import</source>
          <target state="translated">CSVインポート</target>
        </trans-unit>
        <trans-unit id="17e29dae877981f4c14c3c548258e66edf22daf5" translate="yes" xml:space="preserve">
          <source>CSV output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; now always uses CRNL for the row separator and avoids inserting CR in front of NLs contained in data.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;からのCSV出力は、行セパレーターに常にCRNLを使用し、データに含まれるNLの前にCRを挿入することを回避するようになりました。</target>
        </trans-unit>
        <trans-unit id="e6303ccf1ceff324ad3a408b48244faf8b681b0a" translate="yes" xml:space="preserve">
          <source>CURRENT</source>
          <target state="translated">CURRENT</target>
        </trans-unit>
        <trans-unit id="988c655ab1a28987e3b7f4aa07b43ec2f252df71" translate="yes" xml:space="preserve">
          <source>CURRENT_DATE</source>
          <target state="translated">CURRENT_DATE</target>
        </trans-unit>
        <trans-unit id="2c91dc4d76138fb01afa917b2a5880a2ce68218e" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME</source>
          <target state="translated">CURRENT_TIME</target>
        </trans-unit>
        <trans-unit id="b12c7ec3f538b492b9b7b22b81788480777716ca" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP added</source>
          <target state="translated">CURRENT_TIME、CURRENT_DATE、CURRENT_TIMESTAMPを追加しました。</target>
        </trans-unit>
        <trans-unit id="a5fb7adeaa54144ee5b07100bdd633a9a88f29b3" translate="yes" xml:space="preserve">
          <source>CURRENT_TIMESTAMP</source>
          <target state="translated">CURRENT_TIMESTAMP</target>
        </trans-unit>
        <trans-unit id="97154728871232f8ec1e18c7f99aae1f66258be4" translate="yes" xml:space="preserve">
          <source>Cache Validation</source>
          <target state="translated">キャッシュ検証</target>
        </trans-unit>
        <trans-unit id="243348169a35fc01acf2950edac2a8317e1d5705" translate="yes" xml:space="preserve">
          <source>Cache sharing is enabled and disabled for an entire process. This is a change as of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04). In prior versions of SQLite, sharing was enabled or disabled for each thread separately.</source>
          <target state="translated">キャッシュ共有は、プロセス全体で有効または無効になります。これはSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;バージョン3.5.0&lt;/a&gt;（2007-09-04）からの変更です。SQLiteの以前のバージョンでは、共有はスレッドごとに個別に有効または無効にされていました。</target>
        </trans-unit>
        <trans-unit id="dfad78f93ed55c3b8305d2de17eb36b19e276c8b" translate="yes" xml:space="preserve">
          <source>Call sqlite3_reset() on the statement handle. Since an SQLITE_LOCKED error may only occur on the first call to sqlite3_step() (it is not possible for one call to sqlite3_step() to return SQLITE_ROW and then the next SQLITE_LOCKED), the statement handle may be reset at this point without affecting the results of the query from the point of view of the caller. If sqlite3_reset() were not called at this point, the next call to sqlite3_step() would return SQLITE_MISUSE.</source>
          <target state="translated">文ハンドルでsqlite3_reset()を呼び出してください。SQLITE_LOCKEDエラーはsqlite3_step()の最初の呼び出しでのみ発生する可能性があるので(sqlite3_step()の1回の呼び出しでSQLITE_ROWを返し、次の呼び出しでSQLITE_LOCKEDを返すことは不可能です)、呼び出し元から見て問い合わせの結果に影響を与えることなく、この時点で文ハンドルをリセットすることができます。この時点でsqlite3_reset()が呼ばれなかった場合、次のsqlite3_step()の呼び出しはSQLITE_MISUSEを返します。</target>
        </trans-unit>
        <trans-unit id="e7253d4d62ac064583560f235c4dc54e68e830f1" translate="yes" xml:space="preserve">
          <source>Call sqlite3_step() on the supplied statement handle. If the call returns anything other than SQLITE_LOCKED, then return this value to the caller. Otherwise, continue.</source>
          <target state="translated">与えられたステートメントハンドル上でsqlite3_step()を呼び出します。呼び出しがSQLITE_LOCKED以外の値を返した場合は、この値を呼び出し元に返します。それ以外の場合は続行します。</target>
        </trans-unit>
        <trans-unit id="ac89c336f7b9f31230fa306e89f0a63e33ec5741" translate="yes" xml:space="preserve">
          <source>Call sqlite3rbu_close(X) to destroy the sqlite3rbu object pointer. If sqlite3rbu_step(X) has been called enough times to completely apply the update to the target database, then the RBU database is marked as fully applied. Otherwise, the state of the RBU update application is saved in the state database (or in the RBU database if the name of the state database file in sqlite3rbu_open() is NULL) for later resumption of the update.</source>
          <target state="translated">sqlite3rbuオブジェクト・ポインタを破棄するためにsqlite3rbu_close(X)を呼び出します。sqlite3rbu_step(X)がターゲット・データベースに更新を完全に適用するのに十分な回数呼び出された場合、RBUデータベースは完全に適用されたものとしてマークされます。そうでなければ、RBU更新アプリケーションの状態は、後で更新を再開するために、状態データベースに保存されます(sqlite3rbu_open()の状態データベースファイル名がNULLの場合はRBUデータベースに保存されます)。</target>
        </trans-unit>
        <trans-unit id="f4cfaf571c0396d88e7a8a5942129605eebc5000" translate="yes" xml:space="preserve">
          <source>Call the table named by the &lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt; in a recursive common table expression the &quot;recursive table&quot;. In the &lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte&lt;/a&gt; bubble diagram above, the recursive table must appear exactly once in the FROM clause of the recursive-select and must not appear anywhere else in either the initial-select or the recursive-select, including subqueries. The initial-select may be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;, but it may not include an ORDER BY, LIMIT, or OFFSET. The recursive-select must be a simple select, not a compound. The recursive-select is allowed to include an ORDER BY, LIMIT, and/or OFFSET.</source>
          <target state="translated">指定されたテーブル呼び出し&lt;a href=&quot;syntax/cte-table-name&quot;&gt;CTE-table-nameの&lt;/a&gt;再帰共通テーブル式「再帰テーブル」にします。上記の&lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;バブル図では、再帰的テーブルは、再帰的選択のFROM句に1回だけ出現し、initial-selectまたはrecursive-selectのほかのサブクエリを含むどこにも出現してはなりません。 initial-selectには&lt;a href=&quot;lang_select#compound&quot;&gt;複合selectを使用できます&lt;/a&gt;が、ORDER BY、LIMIT、またはOFFSETを含めることはできません。再帰的選択は、複合ではなく単純な選択でなければなりません。再帰選択には、ORDER BY、LIMIT、OFFSETを含めることができます。</target>
        </trans-unit>
        <trans-unit id="42fb639b7313463881ed7d9bae34cc709237f03b" translate="yes" xml:space="preserve">
          <source>Callback</source>
          <target state="translated">Callback</target>
        </trans-unit>
        <trans-unit id="fc3110a84b56463b6ac2be236d2d0ee212bb9db8" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_auto_extension(X) with an entry point X that is already on the list of automatic extensions is a harmless no-op. No entry point will be called more than once for each database connection that is opened.</source>
          <target state="translated">すでに自動拡張のリストにあるエントリポイントXでsqlite3_auto_extension(X)を呼び出すことは、無害なノーオペです。開かれたデータベース接続ごとに複数回呼び出されることはありません。</target>
        </trans-unit>
        <trans-unit id="fdd02e84dcaceaea19448095c3e09a162e5292ae" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_free() with a pointer previously returned by sqlite3_malloc() or sqlite3_realloc() releases that memory so that it might be reused. The sqlite3_free() routine is a no-op if is called with a NULL pointer. Passing a NULL pointer to sqlite3_free() is harmless. After being freed, memory should neither be read nor written. Even reading previously freed memory might result in a segmentation fault or other severe error. Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free() is called with a non-NULL pointer that was not obtained from sqlite3_malloc() or sqlite3_realloc().</source>
          <target state="translated">sqlite3_malloc()やsqlite3_realloc()で以前に返されたポインタでsqlite3_free()を呼び出すと、そのメモリを解放して再利用できるようにします。sqlite3_free()ルーチンはNULLポインタを指定して呼ばれた場合は実行しません。sqlite3_free()にNULLポインタを渡すことは無害です。解放された後は、メモリを読み書きしてはいけません。解放された後は、メモリを読み込んだり書き込んだりしてはいけません。解放された後にメモリを読み込んでも、セグメンテーション・フォールトやその他の重大なエラーが発生する可能性があります。sqlite3_malloc()やsqlite3_realloc()で取得したものではないNULLではないポインタでsqlite3_free()を呼び出すと、メモリ破壊やセグメンテーション・フォールト、その他の深刻なエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="3358427e1a8ed1bea8f5a2ad2f5555efabc90a34" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">NULLポインターまたは開いているblobハンドルではない引数を指定してこの関数を呼び出すと、動作が未定義になります。 nullポインターを使用してこのルーチンを呼び出す（&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）の&lt;/a&gt;呼び出しが失敗した場合に返されるなど）と、無害な何もしません。それ以外の場合、この関数に有効なオープンBLOBハンドルが渡されると、sqlite3_errcode（）およびsqlite3_errmsg（）関数によって返される値は、戻る前に設定されます。</target>
        </trans-unit>
        <trans-unit id="508bbd8f844cc227cec9347e436cbdd9ffc04285" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">NULLポインターまたは開いているblobハンドルではない引数を指定してこの関数を呼び出すと、動作が未定義になります。 nullポインターを使用してこのルーチンを呼び出す（&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）の&lt;/a&gt;呼び出しが失敗した場合に返されるなど）と、無害な何もしません。それ以外の場合、この関数に有効なオープンBLOBハンドルが渡されると、sqlite3_errcode（）およびsqlite3_errmsg（）関数によって返される値は、戻る前に設定されます。</target>
        </trans-unit>
        <trans-unit id="64d7627e8fc4bb3206a4244a29e5baede1745ef4" translate="yes" xml:space="preserve">
          <source>Calling this routine with an argument less than or equal to zero turns off all busy handlers.</source>
          <target state="translated">ゼロ以下の引数でこのルーチンを呼び出すと、すべてのビジー・ハンドラがオフになります。</target>
        </trans-unit>
        <trans-unit id="f8f92cf7b8aea43c60bffe0c687691a21c0c3628" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db、SQLITE_VTAB_CONSTRAINT_SUPPORT、X）という形式の呼び出しがサポートされています。Xは整数です。 Xがゼロの場合、&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;または&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;メソッドが&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config（）を&lt;/a&gt;呼び出した&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;は制約をサポートしません。呼び出した場合（デフォルト）この構成で&lt;a href=&quot;vtab#xupdate&quot;&gt;のXUpdate&lt;/a&gt;メソッドが返す&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINTを&lt;/a&gt;、その後、文全体がロールバックかのように&lt;a href=&quot;lang_conflict&quot;&gt;OR ABORTは&lt;/a&gt;、ユーザーのSQL文の一部として指定されていたにかかわらず、実際のON CONFLICTモードの指定。</target>
        </trans-unit>
        <trans-unit id="9cd59c58ce5ea212cbfa095730fc7d7c0c018f0a" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;../lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db、SQLITE_VTAB_CONSTRAINT_SUPPORT、X）という形式の呼び出しがサポートされています。Xは整数です。 Xがゼロの場合、&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;または&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;メソッドが&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config（）を&lt;/a&gt;呼び出した&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;は制約をサポートしません。呼び出した場合（デフォルト）この構成で&lt;a href=&quot;../vtab#xupdate&quot;&gt;のXUpdate&lt;/a&gt;メソッドが返す&lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINTを&lt;/a&gt;、その後、文全体がロールバックかのように&lt;a href=&quot;../lang_conflict&quot;&gt;OR ABORTは&lt;/a&gt;、ユーザーのSQL文の一部として指定されていたにかかわらず、実際のON CONFLICTモードの指定。</target>
        </trans-unit>
        <trans-unit id="86477778aa30209993df2ed08e9c32fc5e63a6fa" translate="yes" xml:space="preserve">
          <source>Calls to sqlite3_db_config() return SQLITE_OK if and only if the call is considered successful.</source>
          <target state="translated">sqlite3_db_config()への呼び出しは、呼び出しが成功したとみなされた場合にのみSQLITE_OKを返します。</target>
        </trans-unit>
        <trans-unit id="98e68b9f843bbc24802b164860be76398c7c74b1" translate="yes" xml:space="preserve">
          <source>Can I use SQLite in my commercial product without paying royalties?</source>
          <target state="translated">商用製品でロイヤリティを払わずにSQLiteを使用することはできますか?</target>
        </trans-unit>
        <trans-unit id="a99feeb9b762e6e46c563375f506a5cca89929e5" translate="yes" xml:space="preserve">
          <source>Can multiple applications or multiple instances of the same application access a single database file at the same time?</source>
          <target state="translated">複数のアプリケーション、または同じアプリケーションの複数のインスタンスが同時に1つのデータベースファイルにアクセスすることはできますか?</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">自動延長の読み込みをキャンセル</target>
        </trans-unit>
        <trans-unit id="0f1e2a9d130c394f768ce03af8c9cfdba772362c" translate="yes" xml:space="preserve">
          <source>Capture Changes Using Triggers</source>
          <target state="translated">トリガーを使用して変更をキャプチャする</target>
        </trans-unit>
        <trans-unit id="8d319a418b8f56b5238017081c3f614d4e2d2c3a" translate="yes" xml:space="preserve">
          <source>Carray($PTR,$N) is a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; with a single column (named &quot;value&quot;) and zero or more rows. The &quot;value&quot; of each row in the carray() is taken from a C-language array that is $N elements long. $PTR is a pointer to the beginning of the array. In this way, the carray() function provides a convenient mechanism to bind C-language arrays to SQL queries.</source>
          <target state="translated">Carray（$ PTR、$ N）は、単一の列（「値」という名前）と0個以上の行を持つ&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;です。carray（）の各行の「値」は、$ N要素の長さのC言語配列から取得されます。$ PTRは、配列の先頭へのポインターです。このように、carray（）関数は、C言語の配列をSQLクエリにバインドするための便利なメカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="8c3b32ddf313031d687668680d0df3a761eedc08" translate="yes" xml:space="preserve">
          <source>Case-folding is only performed for ASCII characters. So while &quot;A&quot; and &quot;a&quot; are considered to be equivalent, &quot;&amp;Atilde;&quot; and &quot;&amp;atilde;&quot; are distinct.</source>
          <target state="translated">大文字小文字変換は、ASCII文字に対してのみ実行されます。したがって、「A」と「a」は同等と見なされますが、「&amp;Atilde;」と「&amp;atilde;」は区別されます。</target>
        </trans-unit>
        <trans-unit id="ddb2cf0a81747a42bb2a318554bfc6f3310b70d2" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching of Unicode characters does not work.</source>
          <target state="translated">Unicode 文字の大文字小文字を区別しないマッチングが機能しない。</target>
        </trans-unit>
        <trans-unit id="4a24bc7f7fc1b1e11b0cb6ad38cd14985ad78efd" translate="yes" xml:space="preserve">
          <source>Cases in which the underlying content table has an explicit INTEGER PRIMARY KEY column are slightly more difficult, as the text values stored in the rbu_control column are slightly different for the FTS index and its underlying content table. For the underlying content table, a character must be included in any rbu_control text values for the explicit IPK, but for the FTS table itself, which has an implicit rowid, it should not. This is inconvenient, but can be solved using a more complicated view, as follows:</source>
          <target state="translated">基底コンテンツ・テーブルが明示的なINTEGER PRIMARY KEYカラムを持つ場合は、FTSインデックスとその基底コンテンツ・テーブルでは、rbu_controlカラムに格納されるテキスト値が若干異なるため、少し難しくなります。基底となるコンテンツ・テーブルの場合、明示的なIPKのためのrbu_controlテキスト値には文字が含まれていなければなりませんが、暗黙的なrowidを持つFTSテーブル自体の場合は含まれてはなりません。これは不便ですが、以下のように、より複雑なビューを使用して解決することができます。</target>
        </trans-unit>
        <trans-unit id="6d2fbd5980d329d5d6af3be31953582204f59e3e" translate="yes" xml:space="preserve">
          <source>Cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; include the following:</source>
          <target state="translated">WALモードのデータベースに対するクエリが&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;を返す可能性があるのは、次のような場合です。</target>
        </trans-unit>
        <trans-unit id="15a2b7aaa72451fad3138411af4836bb6aea25de" translate="yes" xml:space="preserve">
          <source>Cases where the page-sizes of database pInMemory and zFilename are different could be handled better.</source>
          <target state="translated">データベースの pInMemory と zFilename のページサイズが異なる場合の対応を改善した。</target>
        </trans-unit>
        <trans-unit id="60745aef336b682ec827697b3e47b80c7d7555b3" translate="yes" xml:space="preserve">
          <source>Cast</source>
          <target state="translated">Cast</target>
        </trans-unit>
        <trans-unit id="8e96ef594fff82e127e63864e75e54aa6b53b266" translate="yes" xml:space="preserve">
          <source>Casting a REAL or INTEGER value to NUMERIC is a no-op, even if a real value could be losslessly converted to an integer.</source>
          <target state="translated">REAL や INTEGER の値を NUMERIC にキャストすることは、たとえ実数をロスなく整数に変換できたとしても、実行できません。</target>
        </trans-unit>
        <trans-unit id="383678fdbb040838c4ceb85e8d73bcffcce4db9f" translate="yes" xml:space="preserve">
          <source>Casting a TEXT or BLOB value into NUMERIC yields either an INTEGER or a REAL result. If the input text looks like an integer (there is no decimal point nor exponent) and the value is small enough to fit in a 64-bit signed integer, then the result will be INTEGER. Input text that looks like floating point (there is a decimal point and/or an exponent) and the text describes a value that can be losslessly converted back and forth between IEEE 754 64-bit float and a 51-bit signed integer, then the result is INTEGER. (In the previous sentence, a 51-bit integer is specified since that is one bit less than the length of the mantissa of an IEEE 754 64-bit float and thus provides a 1-bit of margin for the text-to-float conversion operation.) Any text input that describes a value outside the range of a 64-bit signed integer yields a REAL result.</source>
          <target state="translated">TEXT や BLOB の値を NUMERIC にキャストすると、INTEGER か REAL のどちらかの結果が得られます。入力テキストが整数のように見えて(小数点も指数もない)、値が 64 ビットの符号付き整数に収まるほど小さい場合、結果は INTEGER になります。入力テキストが浮動小数点のように見え(小数点および/または指数がある)、そのテキストがIEEE 754の64ビット浮動小数点と51ビット符号付き整数の間でロスレスに前後に変換できる値を記述している場合、結果はINTEGERになります。(前の文では51ビットの整数を指定していますが、これはIEEE 754 64ビットフロートの正接の長さよりも1ビット小さいため、テキストからフロートへの変換操作に1ビットのマージンを与えるためです)。64ビット符号付き整数の範囲外の値を記述したテキスト入力は、REALの結果を返します。</target>
        </trans-unit>
        <trans-unit id="6f9cada34f4e450b6e71343e035a2f6e0689a6ef" translate="yes" xml:space="preserve">
          <source>Casting a value to a type-name with no affinity causes the value to be converted into a BLOB. Casting to a BLOB consists of first casting the value to TEXT in the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection, then interpreting the resulting byte sequence as a BLOB instead of as TEXT.</source>
          <target state="translated">アフィニティのないtype-nameに値をキャストすると、値がBLOBに変換されます。BLOBへのキャストは、まずデータベース接続の&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;エンコード&lt;/a&gt;で値をTEXTにキャストし、次に結果のバイトシーケンスをTEXTではなくBLOBとして解釈することで構成されます。</target>
        </trans-unit>
        <trans-unit id="6fddff049ee62a8963c9618826e1a03cc952e4f9" translate="yes" xml:space="preserve">
          <source>Casting an INTEGER or REAL value into TEXT renders the value as if via &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; except that the resulting TEXT uses the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection.</source>
          <target state="translated">INTEGERまたはREAL値をTEXTにキャストすると、結果のTEXT がデータベース接続の&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;エンコーディング&lt;/a&gt;を使用することを除いて、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;経由であるかのように値がレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="250b5faac42b62665141b9500e3ff0cde556b9c8" translate="yes" xml:space="preserve">
          <source>Casual readers are not expected to understand all of these rules. A key take-away from this section is that the rules for determining when query flatting is safe and when it is unsafe are subtle and complex. There have been multiple bugs over the years caused by over-aggressive query flattening. On the other hand, performance of complex queries and/or queries involving views tends to suffer if query flattening is more conservative.</source>
          <target state="translated">カジュアルな読者は、これらのルールのすべてを理解することは期待していません。このセクションで重要なことは、クエリフラット化が安全な場合と安全でない場合を判断するためのルールは、微妙で複雑であるということです。クエリのフラット化を過度に攻撃的に行うことによって引き起こされたバグは、長年に渡って複数発生しています。一方で、複雑なクエリやビューを含むクエリのパフォーマンスは、 クエリフラット化をより保守的に行うと低下する傾向にあります。</target>
        </trans-unit>
        <trans-unit id="8907a1b62f0f750985eefc9ce844fea83efeb9a9" translate="yes" xml:space="preserve">
          <source>Cause precompiled statements to expire. When an expired statement is executed using sqlite3_step() it will either automatically reprepare itself (if it was originally created using sqlite3_prepare_v2()) or it will fail with SQLITE_SCHEMA.</source>
          <target state="translated">プリコンパイルされたステートメントを期限切れにします。期限切れのステートメントがsqlite3_step()を使用して実行されると、自動的に(元々sqlite3_prepare_v2()を使用して作成されていた場合)自分自身を再準備するか、SQLITE_SCHEMAで失敗するかのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="a305305010fac4c32d5e753f973a3552e1f13215" translate="yes" xml:space="preserve">
          <source>Causes the customer.cust_addr field to be updated for a specific customer entry that has customer.cust_id equal to the $cust_id parameter. Note how the values assigned to the view are made available as field in the special &quot;NEW&quot; table within the trigger body.</source>
          <target state="translated">customer.cust_idが$cust_idパラメータと等しい customer.cust_idを持つ特定の顧客エントリのために customer.cust_addrフィールドが更新されるようにします。ビューに割り当てられた値が、トリガー本体内の特別な &quot;NEW &quot;テーブルのフィールドとして利用可能になる方法に注意してください。</target>
        </trans-unit>
        <trans-unit id="dbad4a6e3280246beefd6847d2978b258b3988cb" translate="yes" xml:space="preserve">
          <source>Cautions On The Use Of BEFORE triggers</source>
          <target state="translated">BEFOREトリガの使用上の注意点</target>
        </trans-unit>
        <trans-unit id="b150cf72e99af84282f28eb7200853b8c0ee4cf4" translate="yes" xml:space="preserve">
          <source>Caveats And Bugs</source>
          <target state="translated">警告とバグ</target>
        </trans-unit>
        <trans-unit id="ff583586588dbe1c7f2b18104da572d7a5f33f25" translate="yes" xml:space="preserve">
          <source>Celebrating the SQLite &quot;</source>
          <target state="translated">祝SQLite &quot;</target>
        </trans-unit>
        <trans-unit id="59bd6eed6ef43faee3a8233d127e632eb210e7f2" translate="yes" xml:space="preserve">
          <source>Cell content is stored in the cell content region of the b-tree page. SQLite strives to place cells as far toward the end of the b-tree page as it can, in order to leave space for future growth of the cell pointer array. The area in between the last cell pointer array entry and the beginning of the first cell is the unallocated region.</source>
          <target state="translated">セルの内容は、b-tree ページのセル内容領域に格納されます。SQLite では、セルポインタ配列を将来的に成長させるためのスペースを残すために、できる限り b-tree ページの最後の方にセルを配置するように努力しています。セルポインタ配列の最後のエントリと最初のセルの先頭の間の領域が未割り当て領域です。</target>
        </trans-unit>
        <trans-unit id="3b0cca36895145060f4680c61a83b1cba94677a3" translate="yes" xml:space="preserve">
          <source>Cell format summary</source>
          <target state="translated">セル形式の概要</target>
        </trans-unit>
        <trans-unit id="7ba571bb64ab9af59eb4c60e06ccece4c22b6946" translate="yes" xml:space="preserve">
          <source>Cell payload</source>
          <target state="translated">セルペイロード</target>
        </trans-unit>
        <trans-unit id="4467e902ad5ceab8af5cb553065bb45a1d9e0f01" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;cli#arinsup&quot;&gt;--update option&lt;/a&gt; in the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; so that it skips files that are already in the archive and are unchanged. Add the new --insert option that works like --update used to work.</source>
          <target state="translated">&lt;a href=&quot;cli#sqlar&quot;&gt;.archiveコマンドの&lt;/a&gt;&lt;a href=&quot;cli#arinsup&quot;&gt;--updateオプション&lt;/a&gt;を変更して、アーカイブに既に存在し、変更されていないファイルをスキップするようにします。以前使用されていた--updateのように機能する新しい--insertオプションを追加します。</target>
        </trans-unit>
        <trans-unit id="f2cdcfee54f6e63221834526df456ae33f4748c1" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt; from 100 to 20, for improved performance.</source>
          <target state="translated">パフォーマンスを改善するために、&lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt;を100から20に変更します。</target>
        </trans-unit>
        <trans-unit id="89533c2ad87297c6b1814e96c92819fffab5d853" translate="yes" xml:space="preserve">
          <source>Change both unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to report a sector size of 4096 instead of the old default of 512.</source>
          <target state="translated">UNIXとWindowsの両方の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を変更して、以前のデフォルトの512ではなく、4096のセクターサイズを報告します。</target>
        </trans-unit>
        <trans-unit id="a9b62dcab530abf089ef055d542c538c769edd17" translate="yes" xml:space="preserve">
          <source>Change counter</source>
          <target state="translated">カウンターの変更</target>
        </trans-unit>
        <trans-unit id="78284963454462cded2891e165a76967ce7ebecf" translate="yes" xml:space="preserve">
          <source>Change in Default Page Size in SQLite Version 3.12.0</source>
          <target state="translated">SQLite バージョン 3.12.0 でのデフォルトページサイズの変更</target>
        </trans-unit>
        <trans-unit id="8ef7213e575119b9063a9829bf0081766983433e" translate="yes" xml:space="preserve">
          <source>Change log</source>
          <target state="translated">チェンジログ</target>
        </trans-unit>
        <trans-unit id="a9b88ee2ce690ee5c74f615e035bfd14907be3b4" translate="yes" xml:space="preserve">
          <source>Change tclsqlite.c to use the Tcl_Obj interface</source>
          <target state="translated">tclsqlite.cをTcl_Objインタフェースを使用するように変更します。</target>
        </trans-unit>
        <trans-unit id="c9502e13b89a0e998e0002cc9dd2ac28edd6e8ea" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt; source code to avoid calling C-library functions that OpenBSD considers dangerous. (Ex: sprintf).</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;レモンの&lt;/a&gt;ソースコードを変更して、OpenBSDが危険だと見なしているCライブラリ関数を呼び出さないようにします。（例：sprintf）。</target>
        </trans-unit>
        <trans-unit id="5d77baa02e54aeb22b238c0441152b1e5304decd" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;tempfiles#tempdir&quot;&gt;temporary directory search algorithm&lt;/a&gt; on Unix to allow directories with write and execute permission, but without read permission, to serve as temporary directories. Apply this same standard to the &quot;.&quot; fallback directory.</source>
          <target state="translated">Unix の&lt;a href=&quot;tempfiles#tempdir&quot;&gt;一時ディレクトリ検索アルゴリズム&lt;/a&gt;を変更して、書き込みと実行の権限を持つが、読み取り権限のないディレクトリが一時ディレクトリとして機能できるようにします。同じ基準を「。」に適用します。フォールバックディレクトリ。</target>
        </trans-unit>
        <trans-unit id="ddfd791371cc9a6cd54b126954447b1ad9112604" translate="yes" xml:space="preserve">
          <source>Change the &lt;b&gt;sqlite&lt;/b&gt; program so that it can read databases for which it lacks write permission. (It used to refuse all access if it could not write.)</source>
          <target state="translated">&lt;b&gt;sqlite&lt;/b&gt;プログラムを変更して、書き込み権限のないデータベースを読み取れるようにします。（以前は書き込みができなかった場合、すべてのアクセスを拒否していました。）</target>
        </trans-unit>
        <trans-unit id="cbf993184d73b432fd33a6a4967c4e16c588f384" translate="yes" xml:space="preserve">
          <source>Change the code so that version 2.1.1 databases that were rendered unreadable by the above bug can be read by this version of the library even though the SQLITE_MASTER table is (slightly) corrupted.</source>
          <target state="translated">SQLITE_MASTERテーブルが(わずかに)破損していても、上記のバグで読めなくなったバージョン2.1.1のデータベースが、このバージョンのライブラリで読めるようにコードを変更しました。</target>
        </trans-unit>
        <trans-unit id="1b2c3ec73b516454d30b27549240c5be169d57e9" translate="yes" xml:space="preserve">
          <source>Change the datatype of SrcList.nSrc from type u8 to type int to work around an issue in the C compiler on AIX.</source>
          <target state="translated">AIX上のCコンパイラの問題を回避するため、SrcList.nSrcのデータ型をu8型からint型に変更しました。</target>
        </trans-unit>
        <trans-unit id="03b6774f351d6b79789eab0049e6b7dfa776c60c" translate="yes" xml:space="preserve">
          <source>Change the format of data records so that records up to 16MB in size can be stored.</source>
          <target state="translated">データレコードのフォーマットを変更し、16MBまでのレコードを保存できるようにします。</target>
        </trans-unit>
        <trans-unit id="cb9d727fc495b196f0a9e9dcf746f3b21fc8137d" translate="yes" xml:space="preserve">
          <source>Change the format of indices to allow for better query optimization.</source>
          <target state="translated">インデックスのフォーマットを変更して、より良いクエリ最適化ができるようにします。</target>
        </trans-unit>
        <trans-unit id="5c9b7b0951ce0a0f4a0c1e9e79102e0b6bc620be" translate="yes" xml:space="preserve">
          <source>Change the format of indices to correct a design flaw the originated with version 2.1.0. *** This is an incompatible file format change *** When version 2.6.0 or later of the library attempts to open a database file created by version 2.5.6 or earlier, it will automatically and irreversibly convert the file format. &lt;b&gt;Make backup copies of older database files before opening them with version 2.6.0 of the library.&lt;/b&gt;</source>
          <target state="translated">インデックスの形式を変更して、バージョン2.1.0に起因する設計上の欠陥を修正します。 ***これは互換性のないファイル形式の変更です***ライブラリのバージョン2.6.0以降がバージョン2.5.6以前で作成されたデータベースファイルを開こうとすると、ファイル形式が自動的かつ不可逆的に変換されます。&lt;b&gt;ライブラリのバージョン2.6.0で開く前に、古いデータベースファイルのバックアップコピーを作成します。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b18ff5a16f7817612045bc810baefbc9f406946f" translate="yes" xml:space="preserve">
          <source>Change the journal mode of database P1 to P3. P3 must be one of the PAGER_JOURNALMODE_XXX values. If changing between the various rollback modes (delete, truncate, persist, off and memory), this is a simple operation. No IO is required.</source>
          <target state="translated">データベースP1のジャーナルモードをP3に変更します。P3はPAGER_JOURNALMODE_XXXの値のいずれかでなければなりません。様々なロールバックモード(削除、切り捨て、パーシスト、オフ、メモリ)の間で変更する場合、これは簡単な操作です。IOは必要ありません。</target>
        </trans-unit>
        <trans-unit id="6a5f740ae4d06bae054615ec1ed93d10f35a1f54" translate="yes" xml:space="preserve">
          <source>Change the makefile so that it no longer requires GNUmake extensions</source>
          <target state="translated">GNUmake 拡張機能を必要としなくなるように makefile を変更する</target>
        </trans-unit>
        <trans-unit id="1b024f79cb0f34e36e5e78085bb24625608ab395" translate="yes" xml:space="preserve">
          <source>Change the name of new_X to X using: ALTER TABLE new_X RENAME TO X.</source>
          <target state="translated">を使ってnew_Xの名前をXに変更します。ALTER TABLE new_X RENAME TO X.</target>
        </trans-unit>
        <trans-unit id="0f9e3a306b4bd9af67f4b8c1e8cb9e151f5fea94" translate="yes" xml:space="preserve">
          <source>Change the name of the sanity_check PRAGMA to &lt;b&gt;integrity_check&lt;/b&gt; and make it available in all compiles.</source>
          <target state="translated">sanity_check PRAGMAの名前を&lt;b&gt;完全性&lt;/b&gt;チェックに変更し、すべてのコンパイルで使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="a87afe8ac8040316feb3c86d9f29d7a0de41424f" translate="yes" xml:space="preserve">
          <source>Change the round() function to return REAL instead of TEXT.</source>
          <target state="translated">round()関数が TEXT ではなく REAL を返すように変更。</target>
        </trans-unit>
        <trans-unit id="4cc900222ca19ab1e3c50fea1f145e841c36bab9" translate="yes" xml:space="preserve">
          <source>Change the schema parser so that it will error out if any of the type, name, and tbl_name columns of the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt; have been corrupted and the database connection is not in &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; mode.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_masterテーブル&lt;/a&gt;のtype、name、およびtbl_name列のいずれかが破損していて、データベース接続が&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt;モードでない場合にエラーになるように、スキーマパーサーを変更します。</target>
        </trans-unit>
        <trans-unit id="8cf246de2a9b8a88c663c6913b8ed3a48191818d" translate="yes" xml:space="preserve">
          <source>Change the table_info pragma so that it returns NULL for the default value if there is no default value</source>
          <target state="translated">デフォルト値が存在しない場合は、デフォルト値に対して NULL を返すように table_info プラグマを変更します。</target>
        </trans-unit>
        <trans-unit id="b05df024c90267a155027a34482c97ed1e176816" translate="yes" xml:space="preserve">
          <source>Change the tclsqlite &quot;eval&quot; method to return a list of results if no callback script is specified.</source>
          <target state="translated">コールバックスクリプトが指定されていない場合、結果のリストを返すように tclsqlite の &quot;eval&quot; メソッドを変更しました。</target>
        </trans-unit>
        <trans-unit id="17fc584f1b3f79a52638c936555356d72a9a526e" translate="yes" xml:space="preserve">
          <source>Change the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to be tolerant of read() system calls that return less then the full number of requested bytes.</source>
          <target state="translated">unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を変更して、要求されたバイトの総数よりも少ない値を返すread（）システムコールに対応できるようにします。</target>
        </trans-unit>
        <trans-unit id="a542a095188ddcc6129238423271833568a2c07f" translate="yes" xml:space="preserve">
          <source>Change the way SUM() handles NULL values in order to comply with the SQL standard</source>
          <target state="translated">SQL 標準に準拠するために SUM()で NULL 値を処理する方法を変更します。</target>
        </trans-unit>
        <trans-unit id="5b5328bf106285a23dec346b5145893a33e1e8c9" translate="yes" xml:space="preserve">
          <source>Change the xFileControl() methods on all built-in VFSes to return &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; for an unrecognized operation code.</source>
          <target state="translated">上xFileControl（）メソッドを変更し、すべてのビルトイン返すためにVFSes &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;の代わり&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERRORを&lt;/a&gt;認識できない操作コードのために。</target>
        </trans-unit>
        <trans-unit id="eca73e726e881b6d471428b557f6268ef3f59ed9" translate="yes" xml:space="preserve">
          <source>Change to use strncmp() or the equivalent instead of memcmp() when comparing non-zero-terminated strings.</source>
          <target state="translated">ゼロ終端でない文字列を比較する際に、memcmp()の代わりに strncmp()または同等のものを使用するように変更。</target>
        </trans-unit>
        <trans-unit id="5514a8922a61fec2577edc11821f533a39d0a9ca" translate="yes" xml:space="preserve">
          <source>Changed the comparison function so that numbers in exponential notation (ex: 1.234e+05) sort in numerical order.</source>
          <target state="translated">指数表記の数値(例:1.234e+05)を数値順に並べ替えるように比較機能を変更した。</target>
        </trans-unit>
        <trans-unit id="df02ed3983d83060874d040fa7eb3a189bd673c0" translate="yes" xml:space="preserve">
          <source>Changed the default configuration of the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; from 500 slots of 128 bytes each into 125 slots of 512 bytes each.</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;ルックアサイドメモリアロケータ&lt;/a&gt;のデフォルト設定を、128バイトの500スロットから、512バイトの125スロットに変更しました。</target>
        </trans-unit>
        <trans-unit id="7e34599469a327d2e948bcc9862b0322f2e510f5" translate="yes" xml:space="preserve">
          <source>Changed the defined behavior for the &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; when floating point values greater than +9223372036854775807 are cast into into integers so that the result is the largest possible integer, +9223372036854775807, instead of the smallest possible integer, -9223372036854775808. After this change, CAST(9223372036854775809.0 as INT) yields +9223372036854775807 instead of -9223372036854775808. &lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt; Potentially Incompatible Change!&lt;/b&gt;</source>
          <target state="translated">+9223372036854775807より大きい浮動小数点値が整数にキャストされるときの&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST式&lt;/a&gt;の定義済み動作を変更し、結果が可能な最小の整数-9223372036854775808ではなく、最大の整数+9223372036854775807になるようにしました。この変更後、CAST（9223372036854775809.0 as INT）は-9223372036854775808ではなく+9223372036854775807になります。&lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt;互換性がない可能性のある変更！&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8caa23815a1a8b1a9c4e9cdf79d42cbf41197489" translate="yes" xml:space="preserve">
          <source>Changed the print format for floating point values from &quot;%g&quot; to &quot;%.15g&quot;.</source>
          <target state="translated">浮動小数点値の印刷形式を &quot;%g&quot; から &quot;%.15g&quot; に変更しました。</target>
        </trans-unit>
        <trans-unit id="24a6e547edd1d04eb53e9f5fe5f292726e669a13" translate="yes" xml:space="preserve">
          <source>Changed the prototype of the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface in a way that is backwards compatible but which might cause warnings in new builds of applications that use that interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;インターフェースのプロトタイプを下位互換性のある方法で変更しましたが、そのインターフェースを使用するアプリケーションの新しいビルドで警告が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f51c4a6bf59ab3184542658dacdac319c7bb7606" translate="yes" xml:space="preserve">
          <source>Changed the signature of the xDlSym method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in a way that is backwards compatible but which might cause compiler warnings.</source>
          <target state="translated">下位互換性がある方法で&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxDlSymメソッドのシグネチャを変更しましたが、コンパイラ警告が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="09eb09203ab84e8c2e6e475c70c299202b24c3d8" translate="yes" xml:space="preserve">
          <source>Changegroup Handle</source>
          <target state="translated">変更グループハンドル</target>
        </trans-unit>
        <trans-unit id="11562ffd183a3f8082c848cac1f5dad1ab2f2843" translate="yes" xml:space="preserve">
          <source>Changes In SQLite Version 3.7.10</source>
          <target state="translated">SQLite バージョン 3.7.10 の変更点</target>
        </trans-unit>
        <trans-unit id="2995749ac68f24f9806cbd53a3147e4763d74488" translate="yes" xml:space="preserve">
          <source>Changes are made to the database by executing SQL statements. The session object records these changes.</source>
          <target state="translated">SQL文を実行することでデータベースに変更が加えられます。セッションオブジェクトはこれらの変更を記録します。</target>
        </trans-unit>
        <trans-unit id="3feb747c2cf9c224527b83786a30acbbf79e8f1b" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for individual rows that have NULL values stored in one or more of their PRIMARY KEY columns.</source>
          <target state="translated">1つ以上のPRIMARY KEY列にNULL値が格納されている個々の行については、変更は記録されません。</target>
        </trans-unit>
        <trans-unit id="5ba7ed905184ce22787b0029a4544681dc28b3db" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for rows that have NULL values stored in one or more of their PRIMARY KEY columns. If such a row is inserted or deleted, no corresponding change is present in the changesets returned by this function. If an existing row with one or more NULL values stored in PRIMARY KEY columns is updated so that all PRIMARY KEY columns are non-NULL, only an INSERT is appears in the changeset. Similarly, if an existing row with non-NULL PRIMARY KEY values is updated so that one or more of its PRIMARY KEY columns are set to NULL, the resulting changeset contains a DELETE change only.</source>
          <target state="translated">1つ以上のPRIMARY KEY列にNULL値が格納されている行については、変更は記録されません。そのような行が挿入されたり削除されたりした場合、この関数が返すチェンジセットには対応する変更はありません。PRIMARY KEY列に格納された1つ以上のNULL値を持つ既存の行が、すべてのPRIMARY KEY列がNULL以外の値になるように更新された場合、チェンジセットにはINSERTのみが表示されます。同様に、PRIMARY KEYの値がNULLでない既存の行が、そのPRIMARY KEYカラムの1つ以上がNULLに設定されるように更新された場合、結果として生じるチェンジセットにはDELETE変更のみが含まれます。</target>
        </trans-unit>
        <trans-unit id="f6e50ec4a352fdec5ac39c386ca001416ca1e482" translate="yes" xml:space="preserve">
          <source>Changes can only be recorded for tables that have a PRIMARY KEY explicitly defined as part of their CREATE TABLE statement. It does not matter if the PRIMARY KEY is an &quot;INTEGER PRIMARY KEY&quot; (rowid alias) or not. The PRIMARY KEY may consist of a single column, or may be a composite key.</source>
          <target state="translated">変更は、CREATE TABLE文の一部としてPRIMARY KEYが明示的に定義されているテーブルに対してのみ記録されます。PRIMARY KEYが &quot;INTEGER PRIMARY KEY&quot; (rowidエイリアス)であるかどうかは関係ありません。PRIMARY KEYは単一のカラムで構成されていてもよいし、複合キーであってもよい。</target>
        </trans-unit>
        <trans-unit id="c0acee58dba4e45c8d5f0399ec1f0d4976436ff2" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">&lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;外部キーアクションの&lt;/a&gt;一部として行われた変更はカウントに含まれますが、REPLACE制約の解決の一部として行われた変更は含まれません。INSTEAD OFトリガーによってインターセプトされたビューへの変更はカウントされません。</target>
        </trans-unit>
        <trans-unit id="b4615c7abb16118eca044200ca3ffb2d42e109f3" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外部キーアクションの&lt;/a&gt;一部として行われた変更はカウントに含まれますが、REPLACE制約の解決の一部として行われた変更は含まれません。INSTEAD OFトリガーによってインターセプトされたビューへの変更はカウントされません。</target>
        </trans-unit>
        <trans-unit id="1e424444f79aa5098cffaecbf261fdab95101506" translate="yes" xml:space="preserve">
          <source>Changes made in one database connection are invisible to all other database connections prior to commit.</source>
          <target state="translated">1つのデータベース接続で行われた変更は、コミット前に他のすべてのデータベース接続からは見えなくなります。</target>
        </trans-unit>
        <trans-unit id="f8bcc1bfedf61a4d6d2302f5aebd841ed0c31154" translate="yes" xml:space="preserve">
          <source>Changes to CREATE VIRTUAL TABLE statements</source>
          <target state="translated">CREATE VIRTUAL TABLE ステートメントの変更</target>
        </trans-unit>
        <trans-unit id="39b78ad4f8a76dbe4baff285b9df3d3da0888670" translate="yes" xml:space="preserve">
          <source>Changes to SELECT statements</source>
          <target state="translated">SELECT文の変更</target>
        </trans-unit>
        <trans-unit id="220e3088537dbb26a066213f366f942dc49c0e70" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">&lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OFトリガー&lt;/a&gt;によってインターセプトされたビューへの変更はカウントされません。ビューでINSERT、UPDATE、またはDELETEステートメントを実行した直後にsqlite3_changes（）から返される値は常に0です。実際のテーブルに加えられた変更のみがカウントされます。</target>
        </trans-unit>
        <trans-unit id="5d6b66157c1ebd92a27f45e6d4f023a3d4bc6e87" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">&lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OFトリガー&lt;/a&gt;によってインターセプトされたビューへの変更はカウントされません。ビューでINSERT、UPDATE、またはDELETEステートメントを実行した直後にsqlite3_changes（）から返される値は常に0です。実際のテーブルに加えられた変更のみがカウントされます。</target>
        </trans-unit>
        <trans-unit id="3ac2cb6fb5d947302cd716dd294d872e94891de1" translate="yes" xml:space="preserve">
          <source>Changes to comments.</source>
          <target state="translated">コメントの変更。</target>
        </trans-unit>
        <trans-unit id="c84397dcd0da39654544ab29ddec3a05373f0685" translate="yes" xml:space="preserve">
          <source>Changes to compile-time options:</source>
          <target state="translated">コンパイル時のオプションを変更しました。</target>
        </trans-unit>
        <trans-unit id="101e26bd8ffca056c8adaec28f53e8804617dcdd" translate="yes" xml:space="preserve">
          <source>Changes to rows that do not already appear in the changegroup are simply copied into it. Or, if both the new changeset and the changegroup contain changes that apply to a single row, the final contents of the changegroup depends on the type of each change, as follows:</source>
          <target state="translated">まだ changegroup に現れていない行への変更は、単に changegroup にコピーされます。あるいは、新しいチェンジセットとチェンジグループの両方に単一の行に適用される変更が含まれている場合、チェンジグループの最終的な内容は、以下のように各変更のタイプに依存します。</target>
        </trans-unit>
        <trans-unit id="3fc8393d45e2f151d9e20c436cc969f753e757c8" translate="yes" xml:space="preserve">
          <source>Changes to some test scripts so that they work on Windows in addition to Unix.</source>
          <target state="translated">いくつかのテストスクリプトを変更し、Unix に加えて Windows でも動作するようにしました。</target>
        </trans-unit>
        <trans-unit id="e4c26ff789d743fb895c4925c581702e142ed6c8" translate="yes" xml:space="preserve">
          <source>Changes to support 64-bit architectures.</source>
          <target state="translated">64ビットアーキテクチャをサポートするための変更。</target>
        </trans-unit>
        <trans-unit id="0e15c1197ceca55511517525b0c74a6a5dfd3ac1" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトの変更</target>
        </trans-unit>
        <trans-unit id="062c3354f76067d89f734b31e5b499c574c81bb7" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; to help it work better when compiled using MSVC.</source>
          <target state="translated">MSVCを使用してコンパイルしたときの動作を改善するための&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーターの&lt;/a&gt;変更。</target>
        </trans-unit>
        <trans-unit id="d0bc6551b6a2c8af14e74911872297e41927e492" translate="yes" xml:space="preserve">
          <source>Changes to the FULL_COLUMN_NAMES pragma to help out the ODBC driver.</source>
          <target state="translated">FULL_COLUMN_NAMESプラグマを変更し、ODBCドライバを支援するようにしました。</target>
        </trans-unit>
        <trans-unit id="7e96fb7803c57c4c013f472a7a7b6294655eae95" translate="yes" xml:space="preserve">
          <source>Changes to the OS-layer interface: mutexes must now be recursive.</source>
          <target state="translated">OS 層インターフェースの変更:ミューテックスは再帰的でなければならないようになりました。</target>
        </trans-unit>
        <trans-unit id="32f6cdea79e8215becbb15cf7bd7e55cdcee90d2" translate="yes" xml:space="preserve">
          <source>Changes within a patchset are ordered in the same way as for changesets generated by the sqlite3session_changeset() function (i.e. all changes for a single table are grouped together, tables appear in the order in which they were attached to the session object).</source>
          <target state="translated">パッチセット内の変更は、sqlite3session_changeset()関数によって生成されたチェンジセットと同じ方法で順序付けられます(すなわち、1つのテーブルに対するすべての変更はグループ化され、テーブルはセッションオブジェクトにアタッチされた順番で表示されます)。</target>
        </trans-unit>
        <trans-unit id="da04970767ae72464882ac8a4e16564000ecf171" translate="yes" xml:space="preserve">
          <source>Changes within the local changeset are rebased as follows:</source>
          <target state="translated">ローカル チェンジセット内の変更は、以下のようにリベースされます。</target>
        </trans-unit>
        <trans-unit id="3a336eee124955ea62ce9395beedef4d114ca005" translate="yes" xml:space="preserve">
          <source>Changeset Generation</source>
          <target state="translated">チェンジセット生成</target>
        </trans-unit>
        <trans-unit id="83360005f23e00ab75cb5a31e370b474e7cda3dd" translate="yes" xml:space="preserve">
          <source>Changeset Iterator Handle</source>
          <target state="translated">チェンジセット イテレータ ハンドル</target>
        </trans-unit>
        <trans-unit id="e80a51a4aaef4428a67700502b5f7dc75dbd4588" translate="yes" xml:space="preserve">
          <source>Changesets may only be applied to databases that contain tables matching the above three criteria as stored in the changeset.</source>
          <target state="translated">チェンジセットは、チェンジセットに格納されている上記の3つの基準に一致するテーブルを含むデータベースにのみ適用できます。</target>
        </trans-unit>
        <trans-unit id="ac1c3813780e3748f7f89bcb8cde7110310ebb74" translate="yes" xml:space="preserve">
          <source>Changing Filesystems</source>
          <target state="translated">ファイルシステムの変更</target>
        </trans-unit>
        <trans-unit id="5f75f4f19ef2482e0ee092a7ab747ab2b4de6353" translate="yes" xml:space="preserve">
          <source>Changing the &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt; while other database connections are open.</source>
          <target state="translated">他のデータベース接続が開いている間に&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt;を変更する。</target>
        </trans-unit>
        <trans-unit id="9851972ccfb6ddbbe4682022996c0b7f4c61ad78" translate="yes" xml:space="preserve">
          <source>Changing the data_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the data_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the data_store_directory setting writes to the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">data_store_directory設定の変更はスレッドセーフではあり&lt;u&gt;ません&lt;/u&gt;。アプリケーション内の別のスレッドが同時にSQLiteインターフェイスを実行している場合は、data_store_directory設定を変更しないでください。これを行うと、未定義の動作が発生します。data_store_directory設定を変更すると、&lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;グローバル変数に書き込まれ、そのグローバル変数はミューテックスによって保護されません。</target>
        </trans-unit>
        <trans-unit id="430a2be1381002d87b9b8ff73223fcbf66c5e87f" translate="yes" xml:space="preserve">
          <source>Changing the foreign_keys setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the foreign_keys setting is changed.</source>
          <target state="translated">foreign_keys設定を変更すると、設定が変更される前に準備されたステートメントを含め、データベース接続を使用して準備されたすべてのステートメントの実行に影響します。既存の文は、レガシー用いて調製&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;で失敗することがインターフェイスを&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMAの&lt;/a&gt; FOREIGN_KEYSの設定が変更された後、エラー。</target>
        </trans-unit>
        <trans-unit id="e64e5108f8dce99580f41bdd628fb1a43e13fc20" translate="yes" xml:space="preserve">
          <source>Changing the recursive_triggers setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the recursive_triggers setting is changed.</source>
          <target state="translated">recursive_triggers設定を変更すると、設定が変更される前に準備されたステートメントを含め、データベース接続を使用して準備されたすべてのステートメントの実行に影響します。従来の&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;インターフェースを使用して準備された既存のステートメントは、recursive_triggers設定が変更された後、&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;エラーで失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="859510e9fde4ba7098039dc9d57957c57590e8ad" translate="yes" xml:space="preserve">
          <source>Changing the temp_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the temp_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the temp_store_directory setting writes to the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">temp_store_directory設定の変更はスレッドセーフではあり&lt;u&gt;ません&lt;/u&gt;。アプリケーション内の別のスレッドが同時にSQLiteインターフェイスを実行している場合は、temp_store_directory設定を変更しないでください。これを行うと、未定義の動作が発生します。temp_store_directory設定を変更すると、&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;グローバル変数に書き込まれ、そのグローバル変数はミューテックスによって保護されません。</target>
        </trans-unit>
        <trans-unit id="4a3e8791cfca3d884c74337ea57def9c05ece108" translate="yes" xml:space="preserve">
          <source>Changing the value of this variable while a database connection is open can result in a corrupt database.</source>
          <target state="translated">データベース接続が開いている間にこの変数の値を変更すると、データベースが破損する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="cea842266549b8d9e4991a72c7996837bc0ff6f1" translate="yes" xml:space="preserve">
          <source>Characters in the matchinfo format string are processed from left to right. Each character in the format string causes one or more 32-bit unsigned integer values to be added to the returned array. The &quot;values&quot; column in the following table contains the number of integer values appended to the output buffer for each supported format string character. In the formula given,</source>
          <target state="translated">matchinfo 形式文字列の文字は、左から右へ処理されます。フォーマット文字列の各文字によって、1 つ以上の 32 ビット符号なし整数値が返された配列に追加されます。次の表の「values」列には、サポートされているフォーマット文字列の各文字について、出力バッファに追加される整数値の数が含まれています。与えられた式の中で</target>
        </trans-unit>
        <trans-unit id="901d44a58ef0c59ab99643a19134ba47c238ad29" translate="yes" xml:space="preserve">
          <source>Chart 1: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">図1:ファイルシステムの直接読み取りに対するSQLiteの読み取りレイテンシ。</target>
        </trans-unit>
        <trans-unit id="27276d4efc029611aba60cde7d26cce5f51fc924" translate="yes" xml:space="preserve">
          <source>Chart 2: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">図2:ファイルシステムの直接読み取りに対するSQLiteの読み取りレイテンシ。</target>
        </trans-unit>
        <trans-unit id="9b63c13706e018a965e9ad083cf8558f0ea7a319" translate="yes" xml:space="preserve">
          <source>Chart 3: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">図3:ファイルシステムの直接読み取りに対するSQLiteの読み取りレイテンシ。</target>
        </trans-unit>
        <trans-unit id="d2affd8c541db58f31c69f6910d1f00260d88617" translate="yes" xml:space="preserve">
          <source>Chart 4: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">図4:ファイルシステムへの直接書き込みに対するSQLiteの書き込みレイテンシ。</target>
        </trans-unit>
        <trans-unit id="3ac7623b08d5a3f0968ebaaaf80eef331d89a328" translate="yes" xml:space="preserve">
          <source>Chart 5: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">図5:ファイルシステムへの直接書き込みに対するSQLiteの書き込みレイテンシ。</target>
        </trans-unit>
        <trans-unit id="145b22ca4b4508601bd80ce10219fd8d551a1cef" translate="yes" xml:space="preserve">
          <source>Chastise the body.</source>
          <target state="translated">体を懲らしめる。</target>
        </trans-unit>
        <trans-unit id="0018d2d0130bb05c6b042cf37fbaadc3d3c580d7" translate="yes" xml:space="preserve">
          <source>Check local (non foreign key) constraints,</source>
          <target state="translated">ローカル(非外部キー)制約をチェックします。</target>
        </trans-unit>
        <trans-unit id="b2b621da54eb725e76b59b6aa64ddca11509ebb6" translate="yes" xml:space="preserve">
          <source>Check the cursor P1 to see if it is currently pointing at a NULL row. If it is, then set register P3 to NULL and jump immediately to P2. If P1 is not on a NULL row, then fall through without making any changes.</source>
          <target state="translated">カーソルP1が現在NULL行を指しているかどうかを確認します。もしそうであれば、レジスタP3をNULLに設定し、すぐにP2にジャンプします。P1がNULL行を指していなければ、何も変更せずにフォールスルーする。</target>
        </trans-unit>
        <trans-unit id="09e577018637d04e97c17b023b39748cce6a0852" translate="yes" xml:space="preserve">
          <source>Check the value in register P3. If it is NULL then &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; using parameter P1, P2, and P4 as if this were a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction. If the value in register P3 is not NULL, then this routine is a no-op. The P5 parameter should be 1.</source>
          <target state="translated">レジスタP3の値を確認します。それがNULLである場合、&lt;a href=&quot;opcode#Halt&quot;&gt;停止し&lt;/a&gt;、これはあたかもP1、P2、およびP4パラメータ使用&lt;a href=&quot;opcode#Halt&quot;&gt;ホールト&lt;/a&gt;命令。レジスタP3の値がNULLでない場合、このルーチンは何もしません。P5パラメータは1である必要があります。</target>
        </trans-unit>
        <trans-unit id="853e2972eec38f585243beee1676c957c81ad890" translate="yes" xml:space="preserve">
          <source>Check to see if the database file has a hot journal. If the file does not have a hot journal, we are done. Return immediately. If there is a hot journal, that journal must be rolled back by the subsequent steps of this algorithm.</source>
          <target state="translated">データベースファイルにホットジャーナルがあるかどうかを確認します。ファイルにホットジャーナルがない場合は、これで終了です。すぐに戻ります。ホット・ジャーナルがある場合、そのジャーナルはこのアルゴリズムの後続のステップでロールバックする必要があります。</target>
        </trans-unit>
        <trans-unit id="a2f036a3bd46936cd9d2c40c2e45e1005b34f3dd" translate="yes" xml:space="preserve">
          <source>Checklist For Choosing The Right Database Engine</source>
          <target state="translated">正しいデータベースエンジンを選択するためのチェックリスト</target>
        </trans-unit>
        <trans-unit id="812e4bd3b7c47c7f81d4167d8aab871141a8c91b" translate="yes" xml:space="preserve">
          <source>Checklists</source>
          <target state="translated">Checklists</target>
        </trans-unit>
        <trans-unit id="5cb9afc05957645058216dd6772ded2e46522ec1" translate="yes" xml:space="preserve">
          <source>Checkpoint</source>
          <target state="translated">Checkpoint</target>
        </trans-unit>
        <trans-unit id="6c8f9631542e10f31e77b7a465542d388b6decdb" translate="yes" xml:space="preserve">
          <source>Checkpoint Information and Locks</source>
          <target state="translated">チェックポイント情報とロック</target>
        </trans-unit>
        <trans-unit id="2a00fbbeacd66d1129876c4f2a120582b60dcc8f" translate="yes" xml:space="preserve">
          <source>Checkpoint Mode Values</source>
          <target state="translated">チェックポイントモード値</target>
        </trans-unit>
        <trans-unit id="f8b00f7fe2c53994a3c2e16e9fff90f46c54af6d" translate="yes" xml:space="preserve">
          <source>Checkpoint a database</source>
          <target state="translated">データベースのチェックポイント</target>
        </trans-unit>
        <trans-unit id="37924a2fe97c6ebb27cab5b2e8b0b2d0894bd2b5" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">データベースリーダーまたはライターが完了するのを待たずに、できるだけ多くのフレームをチェックポイントし、ログ内のすべてのフレームにチェックポイントが設定されている場合は、データベースファイルを同期します。&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;ビジーハンドラのコールバックは&lt;/a&gt; SQLITE_CHECKPOINT_PASSIVEモードで呼び出されることはありません。一方、パッシブモードでは、リーダーまたはライターが同時に存在する場合、チェックポイントが未完成のままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="65bebe73feb47e6a7a12e61f091ce204dad0258a" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">データベースリーダーまたはライターが完了するのを待たずに、できるだけ多くのフレームをチェックポイントし、ログ内のすべてのフレームにチェックポイントが設定されている場合は、データベースファイルを同期します。&lt;a href=&quot;busy_handler&quot;&gt;ビジーハンドラのコールバックは&lt;/a&gt; SQLITE_CHECKPOINT_PASSIVEモードで呼び出されることはありません。一方、パッシブモードでは、リーダーまたはライターが同時に存在する場合、チェックポイントが未完成のままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="11999bbd94b14ea8ec845c4fcad50ea24f0a3d45" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish. Sync the db file if all frames in the log are checkpointed. This mode is the same as calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in this mode.</source>
          <target state="translated">データベースのリーダーまたはライターの終了を待たずに、できるだけ多くのフレームをチェックポイントします。ログ内のすべてのフレームがチェックポイントされている場合は、dbファイルを同期します。このモードは、&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; Cインターフェースを呼び出すのと同じです。&lt;a href=&quot;c3ref/busy_handler&quot;&gt;ビジーハンドラのコールバックは&lt;/a&gt;、このモードで呼び出されることはありません。</target>
        </trans-unit>
        <trans-unit id="4db6d205b349663d744b71f2a117e634b9469124" translate="yes" xml:space="preserve">
          <source>Checkpoint database P1. This is a no-op if P1 is not currently in WAL mode. Parameter P2 is one of SQLITE_CHECKPOINT_PASSIVE, FULL, RESTART, or TRUNCATE. Write 1 or 0 into mem[P3] if the checkpoint returns SQLITE_BUSY or not, respectively. Write the number of pages in the WAL after the checkpoint into mem[P3+1] and the number of pages in the WAL that have been checkpointed after the checkpoint completes into mem[P3+2]. However on an error, mem[P3+1] and mem[P3+2] are initialized to -1.</source>
          <target state="translated">チェックポイントデータベースP1。P1が現在WALモードになっていない場合、これは実行されません。パラメータP2はSQLITE_CHECKPOINT_PASSIVE、FULL、RESTART、TRUNCATEのいずれかです。チェックポイントがSQLITE_BUSYを返した場合は1、返さなかった場合は0をそれぞれmem[P3]に書き込む。mem[P3+1]にはチェックポイント後のWALのページ数、mem[P3+2]にはチェックポイント終了後にチェックポイントされたWALのページ数を書き込む。ただし、エラー時には、mem[P3+1]とmem[P3+2]は-1に初期化される。</target>
        </trans-unit>
        <trans-unit id="c93c7ed9eb6c55536fc1fa5a09dd161c7c872485" translate="yes" xml:space="preserve">
          <source>Checkpoint sequence number</source>
          <target state="translated">チェックポイントシーケンス番号</target>
        </trans-unit>
        <trans-unit id="73420aa2c87505947c6412ba6601937a69b34e0a" translate="yes" xml:space="preserve">
          <source>Checkpointing does require sync operations in order to avoid the possibility of database corruption following a power loss or hard reboot. The WAL must be synced to persistent storage prior to moving content from the WAL into the database and the database file must by synced prior to resetting the WAL. Checkpoint also requires more seeking. The checkpointer makes an effort to do as many sequential page writes to the database as it can (the pages are transferred from WAL to database in ascending order) but even then there will typically be many seek operations interspersed among the page writes. These factors combine to make checkpoints slower than write transactions.</source>
          <target state="translated">チェックポイントは、停電やハードリブート後のデータベース破損の可能性を避けるために、同期操作を必要とします。WALからデータベースにコンテンツを移動する前にWALを永続的なストレージに同期させ、WALをリセットする前にデータベースファイルを同期させなければなりません。チェックポイントはまた、より多くのシークを必要とします。チェックポイントはデータベースへのシーケンシャルなページ書き込みを可能な限り多く行うように努力しますが(ページはWALからデータベースへ昇順に転送されます)、それでも一般的にはページ書き込みの間に多くのシーク操作が散在することになります。これらの要因が組み合わさって、チェックポイントは書き込みトランザクションよりも遅くなります。</target>
        </trans-unit>
        <trans-unit id="13a5691b3271955325bfbd27f548fc8c0c82dfae" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">このメカニズムによって開始されたチェックポイントは&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;パッシブ&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ab8c79d054f22aac4eeb01b5ef4d71f862efa21c" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">このメカニズムによって開始されたチェックポイントは&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;パッシブ&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="df9b91c031577503e347c145ff1b0094db4452ef" translate="yes" xml:space="preserve">
          <source>Checks if the &quot;fired&quot; flag has been set. If so, the unlock-notify callback has already been invoked. Release the mutex and continue.</source>
          <target state="translated">fired&quot; フラグが設定されているかどうかをチェックします。セットされている場合は、 unlock-notify コールバックが既に呼び出されています。ミューテックスを解放して続行します。</target>
        </trans-unit>
        <trans-unit id="d8fcd1cd020581d6d23f7d74cd403fc559263ad5" translate="yes" xml:space="preserve">
          <source>Checksum</source>
          <target state="translated">Checksum</target>
        </trans-unit>
        <trans-unit id="c2d50b4086a2009c1329398de62782c1b322789e" translate="yes" xml:space="preserve">
          <source>Checksum of the last frame in the WAL file.</source>
          <target state="translated">WAL ファイルの最後のフレームのチェックサム。</target>
        </trans-unit>
        <trans-unit id="36775ac61bbdc09836e15e4ec7e669eae516b3d3" translate="yes" xml:space="preserve">
          <source>Checksum-1: Cumulative checksum up through and including this page</source>
          <target state="translated">チェックサム-1:このページまでの累積チェックサム</target>
        </trans-unit>
        <trans-unit id="0f0241436226dd5ad15b784282d744ddcaf53796" translate="yes" xml:space="preserve">
          <source>Checksum-1: First part of a checksum on the first 24 bytes of header</source>
          <target state="translated">Checksum-1:ヘッダの最初の24バイトのチェックサムの最初の部分</target>
        </trans-unit>
        <trans-unit id="25d65b4024e29fd560da0ace1eb3f77896847390" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second half of the cumulative checksum.</source>
          <target state="translated">Checksum-2:累積チェックサムの後半。</target>
        </trans-unit>
        <trans-unit id="abcb92542826823bd4a635495c66df0db032424c" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second part of the checksum on the first 24 bytes of header</source>
          <target state="translated">Checksum-2:ヘッダの最初の24バイト目のチェックサムの2番目の部分</target>
        </trans-unit>
        <trans-unit id="2e6fc2f66d5cb19af415e45034e0124b71cc4cce" translate="yes" xml:space="preserve">
          <source>Cherrypick fixes for other obscure problems found since the 3.30.0 release</source>
          <target state="translated">3.30.0リリース以降に発見された他の不明瞭な問題をCherrypickで修正</target>
        </trans-unit>
        <trans-unit id="38f9d9f26118d80f3d659b4ee2e2b654e7c605c0" translate="yes" xml:space="preserve">
          <source>Choose the column names in a compound query from the left-most SELECT instead of the right-most.</source>
          <target state="translated">複合クエリのカラム名は、右端のSELECTではなく、左端のSELECTから選択します。</target>
        </trans-unit>
        <trans-unit id="11cfd2c677994d3ba2e81eb3cb8ff4634809c573" translate="yes" xml:space="preserve">
          <source>Choosing good indexes for each loop</source>
          <target state="translated">各ループに適したインデックスの選択</target>
        </trans-unit>
        <trans-unit id="070374ff80947b819eb8815e8d492bf0a862577e" translate="yes" xml:space="preserve">
          <source>Chronology</source>
          <target state="translated">Chronology</target>
        </trans-unit>
        <trans-unit id="d697c3a479d4940e72936c6c5796e737d83de121" translate="yes" xml:space="preserve">
          <source>Clean up comments and variable names. Changes to documentation. No functional changes to the code.</source>
          <target state="translated">コメントと変数名のクリーンアップ。ドキュメントの変更。コードの機能的な変更はありません。</target>
        </trans-unit>
        <trans-unit id="719ea396ad92e01b4757ec2b93bb1e5f270f771d" translate="yes" xml:space="preserve">
          <source>Clear</source>
          <target state="translated">Clear</target>
        </trans-unit>
        <trans-unit id="7fe36a4f7ea83f99a8ac259b32e3aa3e06a3e0ea" translate="yes" xml:space="preserve">
          <source>Clearly, a hardware or operating system fault that introduces incorrect data into the middle of the database file or journal will cause problems. Likewise, if a rogue process opens a database file or journal and writes malformed data into the middle of it, then the database will become corrupt. There is not much that can be done about these kinds of problems so they are given no further attention.</source>
          <target state="translated">明らかに、データベースファイルやジャーナルの途中に不正なデータを挿入するハードウェアやオペレーティングシステムの障害が問題を引き起こすことになります。同様に、不正なプロセスがデータベースファイルやジャーナルを開き、その中に不正なデータを書き込むと、データベースが破損します。これらの種類の問題については、対処できることはあまりないので、これ以上の注意を払う必要はありません。</target>
        </trans-unit>
        <trans-unit id="95490bb933b1b789f5f61256736c0ee3697b1303" translate="yes" xml:space="preserve">
          <source>Client applications typically use a generic database interface that allows connections to various SQL database engines. It makes good sense to include SQLite in the mix of supported databases and to statically link the SQLite engine in with the client. That way the client program can be used standalone with an SQLite data file for testing or for demonstrations.</source>
          <target state="translated">クライアントアプリケーションは通常、様々な SQL データベースエンジンへの接続を可能にする汎用データベースインターフェースを使用します。サポートされているデータベースの中に SQLite を含め、SQLite エンジンをクライアントと静的にリンクすることは理にかなっています。そうすれば、クライアントプログラムはテストやデモンストレーションのために、SQLiteデータファイルを使ってスタンドアロンで使用することができます。</target>
        </trans-unit>
        <trans-unit id="525256fa1745ebe5497d79cf726d90129b04804e" translate="yes" xml:space="preserve">
          <source>Client/server SQL database engines strive to implement a shared repository of enterprise data. They emphasize scalability, concurrency, centralization, and control. SQLite strives to provide local data storage for individual applications and devices. SQLite emphasizes economy, efficiency, reliability, independence, and simplicity.</source>
          <target state="translated">クライアント/サーバーSQLデータベースエンジンは、企業データの共有リポジトリの実装に努めています。拡張性、同時実行性、集中化、制御を重視しています。SQLite は、個々のアプリケーションやデバイス用のローカルデータストレージを提供することを目指しています。SQLite は経済性、効率性、信頼性、独立性、シンプルさを重視しています。</target>
        </trans-unit>
        <trans-unit id="e1dbee15a55011ce9dd54d220174f35b9020dbef" translate="yes" xml:space="preserve">
          <source>Client/server database engines are designed to live inside a lovingly-attended datacenter at the core of the network. SQLite works there too, but SQLite also thrives at the edge of the network, fending for itself while providing fast and reliable data services to applications that would otherwise have dodgy connectivity.</source>
          <target state="translated">クライアント/サーバ・データベース・エンジンは、ネットワークの中核にある、愛情を込めて管理されたデータセンターの中で動作するように設計されています。SQLite はそこでも動作しますが、SQLite はネットワークのエッジでも活躍しており、接続性が悪いアプリケーションに高速で信頼性の高いデータサービスを提供しながら、自分自身を守っています。</target>
        </trans-unit>
        <trans-unit id="63b283ce3f8b364e187012832c04f432c579a52d" translate="yes" xml:space="preserve">
          <source>Client/server databases like MySQL, PostgreSQL, SQL Server, Oracle, and others are an important component of modern systems. These systems solve an important problem. But SQLite solves a different problem. Both SQLite and client/server databases have their role. Developers who are comparing SQLite against other SQL database engines need to clearly understand this distinction.</source>
          <target state="translated">MySQL、PostgreSQL、SQL Server、Oracleなどのクライアント/サーバデータベースは、現代のシステムの重要な構成要素となっています。これらのシステムは重要な問題を解決します。しかし、SQLite は別の問題を解決します。SQLite とクライアント/サーバーデータベースの両方にはそれぞれ役割があります。SQLite を他の SQL データベースエンジンと比較する開発者は、この区別を明確に理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="bbfa773e5a63a5ea58c9b6207e608ca0120e592a" translate="yes" xml:space="preserve">
          <source>Close</source>
          <target state="translated">Close</target>
        </trans-unit>
        <trans-unit id="d692c2c202249e9e4fe0069f00e6bff039f0c2b5" translate="yes" xml:space="preserve">
          <source>Close A BLOB Handle</source>
          <target state="translated">BLOBハンドルを閉じる</target>
        </trans-unit>
        <trans-unit id="2e50e33188cf1bf73dcb5e4643c391e4e29a00af" translate="yes" xml:space="preserve">
          <source>Close a cursor previously opened as P1. If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">P1として開いていたカーソルを閉じます。P1が現在開いていない場合、この命令は実行されません。</target>
        </trans-unit>
        <trans-unit id="0e4d537da92d49358e224a4a747dea32342b05b1" translate="yes" xml:space="preserve">
          <source>Close both cursors.</source>
          <target state="translated">両方のカーソルを閉じて</target>
        </trans-unit>
        <trans-unit id="29aaf7cec2af0b1f202abf31695f4cd37d74e8ff" translate="yes" xml:space="preserve">
          <source>Close the cursor.</source>
          <target state="translated">カーソルを閉じます。</target>
        </trans-unit>
        <trans-unit id="f1ceaea1ade786b6daac7b066c7f274b9fd722f8" translate="yes" xml:space="preserve">
          <source>Closing A Database Connection</source>
          <target state="translated">データベース接続を閉じる</target>
        </trans-unit>
        <trans-unit id="e0046ff4ec6b0abe476379971c2a006ff70bf46c" translate="yes" xml:space="preserve">
          <source>Closing a Connection</source>
          <target state="translated">接続を閉じる</target>
        </trans-unit>
        <trans-unit id="8661917419fb7cc5ef82c55b2e68e555b2266617" translate="yes" xml:space="preserve">
          <source>Closing a connection.</source>
          <target state="translated">接続を閉じる</target>
        </trans-unit>
        <trans-unit id="db1b559a50c46dcb478b73c9953c212ac94e2736" translate="yes" xml:space="preserve">
          <source>Closing a database connection is a simple matter. The open VFS file-handle is closed and in-memory</source>
          <target state="translated">データベース接続を閉じるのは簡単です。開いているVFSファイルハンドルは閉じられ、インメモリの</target>
        </trans-unit>
        <trans-unit id="7c60089a30c51b5540b0120bd48683a09f4c83f6" translate="yes" xml:space="preserve">
          <source>Clothe the naked.</source>
          <target state="translated">裸に服を着せろ</target>
        </trans-unit>
        <trans-unit id="bb887cae0ad4591660280c949ded3080d0ff24a8" translate="yes" xml:space="preserve">
          <source>Clustered Indexes and the WITHOUT ROWID Optimization</source>
          <target state="translated">クラスター化インデックスとWITHOUT ROWID最適化</target>
        </trans-unit>
        <trans-unit id="79a91b7b9e81e75043a22ebed1514d4b90a130a5" translate="yes" xml:space="preserve">
          <source>Clustered indexes</source>
          <target state="translated">クラスター化されたインデックス</target>
        </trans-unit>
        <trans-unit id="339841482704071d6be66d22a76e8ac915ed405e" translate="yes" xml:space="preserve">
          <source>Co-routines are better than storing the complete result set of the subquery in a transient table because co-routines use less memory. With a co-routine, only a single row of the result needs to be remembered, whereas all rows of the result must be stored for a transient table. Also, because the co-routine does not need to run to completion before the outer query begins its work, the first rows of output can appear much sooner, and if the overall query is aborted, less work is done overall.</source>
          <target state="translated">コ・サブルーチンは、副問い合わせの完全な結果セットを一時的なテーブルに格納するよりも、使用するメモリが少なくて済むので優れています。結果の全行を一過性のテーブルに格納しなければならないのに対し、コ・ルーチンでは結果の1行だけを記憶する必要があります。また、外部クエリが作業を開始する前にコ・ルーチンを完了まで実行する必要がないため、出力の最初の行をより早く表示することができ、クエリ全体が中断された場合、全体的に行われる作業が少なくなります。</target>
        </trans-unit>
        <trans-unit id="fd74b2a71394e7ee81bb386b6917d0be84ba18b0" translate="yes" xml:space="preserve">
          <source>Code Generator</source>
          <target state="translated">コードジェネレータ</target>
        </trans-unit>
        <trans-unit id="47dea711cabe6deab879a9b733dd07b05a63631b" translate="yes" xml:space="preserve">
          <source>Code Of Conduct</source>
          <target state="translated">行動規範</target>
        </trans-unit>
        <trans-unit id="74e1db16aadf744876e02c6a4f106f1aa7afb651" translate="yes" xml:space="preserve">
          <source>Code Of Ethics</source>
          <target state="translated">倫理規定</target>
        </trans-unit>
        <trans-unit id="ae87810899e1431de7026ce043d8dda320fed1e7" translate="yes" xml:space="preserve">
          <source>Code change inspection</source>
          <target state="translated">コード変更検査</target>
        </trans-unit>
        <trans-unit id="b5a54c50fda17aa53c6eedfc8045f9c24c210470" translate="yes" xml:space="preserve">
          <source>Code changes to compile cleanly using OpenWatcom.</source>
          <target state="translated">OpenWatcomを使ってきれいにコンパイルできるようにコードを変更しました。</target>
        </trans-unit>
        <trans-unit id="478104ea503bb6e0eff3a5e3bdba87d5231ae12a" translate="yes" xml:space="preserve">
          <source>Code optimization and refactoring for improved performance.</source>
          <target state="translated">パフォーマンス向上のためのコード最適化とリファクタリング。</target>
        </trans-unit>
        <trans-unit id="c2b53cecb4c71a1d486f72dfb3a0761cddc764ad" translate="yes" xml:space="preserve">
          <source>Coincidentally, that same index is useful for locating the team leader of a particular team:</source>
          <target state="translated">偶然にも、その同じインデックスは、特定のチームのチームリーダーを探すのに便利です。</target>
        </trans-unit>
        <trans-unit id="d5e560637618ccf843afba6188e722395d88af53" translate="yes" xml:space="preserve">
          <source>CollSeq</source>
          <target state="translated">CollSeq</target>
        </trans-unit>
        <trans-unit id="d660ea76dd255d7ad9c4922511054c5e967af78f" translate="yes" xml:space="preserve">
          <source>Collating sequences are used for comparing two text strings. The collating sequence does not change the ordering of NULLs, numbers, or BLOBs, only text.</source>
          <target state="translated">照合シーケンスは、2 つのテキスト文字列を比較するために使用されます。照合シーケンスは、NULL、数値、BLOBの順序を変更せず、テキストのみを比較します。</target>
        </trans-unit>
        <trans-unit id="1e254a056c86801f8b560ebd071943f8829e763e" translate="yes" xml:space="preserve">
          <source>Collation Needed Callbacks</source>
          <target state="translated">照合が必要なコールバック</target>
        </trans-unit>
        <trans-unit id="e0c052d2751435fee70a8eb47de4eb3956e79de1" translate="yes" xml:space="preserve">
          <source>Collectively, the aPgno entries record the database page number stored in all frames of the WAL file. The aPgno[0] entry on the first hash table records the database page number stored in the very first frame in the WAL file. The aPgno[i] entry from the first hash table is the database page number for the i-th frame in the WAL file. The aPgno[k] entry for the second hash table is the database page number for the (k+4062)-th frame in the WAL file. The aPgno[k] entry for the n-th 32768-byte hash table in the shm file (for n&amp;gt;1) holds the database page number stored in the (k+4062+4096*(n-2))-th frame of the WAL file.</source>
          <target state="translated">まとめると、aPgnoエントリは、WALファイルのすべてのフレームに保存されているデータベースページ番号を記録します。最初のハッシュテーブルのaPgno [0]エントリは、WALファイルの最初のフレームに格納されているデータベースページ番号を記録します。最初のハッシュテーブルのaPgno [i]エントリは、WALファイルのi番目のフレームのデータベースページ番号です。 2番目のハッシュテーブルのaPgno [k]エントリは、WALファイルの（k + 4062）番目のフレームのデータベースページ番号です。 shmファイル（n&amp;gt; 1の場合）のn番目の32768バイトのハッシュテーブルのaPgno [k]エントリは、（k + 4062 + 4096 *（n-2））番目のフレームに格納されているデータベースページ番号を保持しますWALファイルの。</target>
        </trans-unit>
        <trans-unit id="d2925a5d74339b84bdd408d91b33688b6815af58" translate="yes" xml:space="preserve">
          <source>Colloquially, the Robson proof shows that in order to guarantee breakdown-free operation, any memory allocator must use a memory pool of size &lt;b&gt;N&lt;/b&gt; which exceeds the maximum amount of memory ever used &lt;b&gt;M&lt;/b&gt; by a multiplier that depends on &lt;b&gt;n&lt;/b&gt;, the ratio of the largest to the smallest allocation size. In other words, unless all memory allocations are of exactly the same size (&lt;b&gt;n&lt;/b&gt;=1) then the system needs access to more memory than it will ever use at one time. Furthermore, we see that the amount of surplus memory required grows rapidly as the ratio of largest to smallest allocations increases, and so there is strong incentive to keep all allocations as near to the same size as possible.</source>
          <target state="translated">口語、保証絶縁破壊のない動作するために、任意のメモリアロケータサイズのメモリ・プールを使用する必要があるロブソンプルーフショー&lt;b&gt;N&lt;/b&gt;今まで使用されるメモリの最大量を超えた&lt;b&gt;M&lt;/b&gt;に依存する乗算器により&lt;b&gt;N&lt;/b&gt;、最大の比率を最小の割り当てサイズに。つまり、すべてのメモリ割り当てがまったく同じサイズ（&lt;b&gt;n&lt;/b&gt; = 1）でない限り、システムは、一度に使用するよりも多くのメモリにアクセスする必要があります。さらに、必要な余剰メモリの量は、最大の割り当てと最小の割り当ての比率が増加するにつれて急速に増加することがわかります。そのため、すべての割り当てをできるだけ同じサイズに近づけたいという強い動機があります。</target>
        </trans-unit>
        <trans-unit id="65ba00e95e60fb8971e699c771908e7c41d91624" translate="yes" xml:space="preserve">
          <source>Column</source>
          <target state="translated">Column</target>
        </trans-unit>
        <trans-unit id="7457b5eaf3d7bfc87797ee1a1767fe0cb49411af" translate="yes" xml:space="preserve">
          <source>Column Contents</source>
          <target state="translated">コラム内容</target>
        </trans-unit>
        <trans-unit id="dc9eb343792aa10d2e4b6816e5d06cae705abefb" translate="yes" xml:space="preserve">
          <source>Column Declared Type</source>
          <target state="translated">カラム宣言型</target>
        </trans-unit>
        <trans-unit id="edbb850ee1e2303abaa75179e5da0bca25a8e6e9" translate="yes" xml:space="preserve">
          <source>Column Definitions</source>
          <target state="translated">カラムの定義</target>
        </trans-unit>
        <trans-unit id="f0e08cc3301877a460436bcf15d46df904fa1c8f" translate="yes" xml:space="preserve">
          <source>Column Name</source>
          <target state="translated">カラム名</target>
        </trans-unit>
        <trans-unit id="cfbfc51b4b3062caab10bcf86299598910467bc8" translate="yes" xml:space="preserve">
          <source>Column Names In A Result Set</source>
          <target state="translated">結果セットのカラム名</target>
        </trans-unit>
        <trans-unit id="2a8d5de5174e3943971a2875266b6881264de3bb" translate="yes" xml:space="preserve">
          <source>Column definition</source>
          <target state="translated">カラムの定義</target>
        </trans-unit>
        <trans-unit id="087b86714eee3da08b0eea49abe7223a80fbe1f7" translate="yes" xml:space="preserve">
          <source>Column filter queries are not available.</source>
          <target state="translated">カラムフィルタクエリは使用できません。</target>
        </trans-unit>
        <trans-unit id="1fb21b8e379e9449d53a5880fcc60a3256a75dc9" translate="yes" xml:space="preserve">
          <source>Column filter specifications may also be applied to arbitrary expressions enclosed in parenthesis. In this case the column filter applies to all phrases within the expression. Nested column filter operations may only further restrict the subset of columns matched, they can not be used to re-enable filtered columns. For example:</source>
          <target state="translated">カラムフィルタの指定は、括弧で囲まれた任意の式にも適用することができます。この場合、カラムフィルタは式内のすべての語句に適用されます。入れ子になったカラムフィルタ操作は、マッチするカラムのサブセットをさらに制限するだけで、フィルタリングされたカラムを再び有効にするために使用することはできません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8cf5932e078596670c3be6928bc34be28df50868" translate="yes" xml:space="preserve">
          <source>Column names in UPDATE statements were case sensitive. This mistake has now been fixed.</source>
          <target state="translated">UPDATE文のカラム名が大文字と小文字を区別していました。この間違いは修正されました。</target>
        </trans-unit>
        <trans-unit id="c8e2e6347929b3f4a547cbe78f19fbf98ffe174e" translate="yes" xml:space="preserve">
          <source>Column names in the expressions of a DO UPDATE refer to the original unchanged value of the column, before the attempted INSERT. To use the value that would have been inserted had the constraint not failed, add the special &quot;excluded.&quot; table qualifier to the column name.</source>
          <target state="translated">DO UPDATE の式の列名は、INSERT を試行する前の列の元の変更されていない値を参照します。制約が失敗しなかった場合に挿入されていた値を使用するには、特別なテーブル修飾子 &quot;excluded.&quot; を列名に追加します。</target>
        </trans-unit>
        <trans-unit id="032e3b2732306732c32848d470fa8748f95c6026" translate="yes" xml:space="preserve">
          <source>Column zColumn does not exist,</source>
          <target state="translated">列 zColumn が存在しません。</target>
        </trans-unit>
        <trans-unit id="ce5679997a2153bf86b8f374126d7b829b91fac4" translate="yes" xml:space="preserve">
          <source>Column zColumn is part of an index, PRIMARY KEY or UNIQUE constraint and the blob is being opened for read/write access,</source>
          <target state="translated">列 zColumn はインデックス、PRIMARY KEY、または UNIQUE 制約の一部であり、読み書きアクセスのために blob をオープンしています。</target>
        </trans-unit>
        <trans-unit id="e8afcd3f4d854da704b3aef5efd35d7f5bc218f3" translate="yes" xml:space="preserve">
          <source>Column-separator is an optional column separator string. The default is the ASCII tab character \t.</source>
          <target state="translated">Column-separator は、オプションの列区切り文字列です。デフォルトは、ASCII タブ文字の \t です。</target>
        </trans-unit>
        <trans-unit id="cf723c59b62a173547c39c3d661c4ee7c240bab1" translate="yes" xml:space="preserve">
          <source>Columns</source>
          <target state="translated">Columns</target>
        </trans-unit>
        <trans-unit id="56b17410d6d1be4171831dc03181ac757a05e7fe" translate="yes" xml:space="preserve">
          <source>Columns of type INTEGER PRIMARY KEY are actually used as the primary key in underlying B-Tree representation of the table.</source>
          <target state="translated">INTEGER PRIMARY KEY 型のカラムは、テーブルの B-Tree 表現では実際に主キーとして使用されます。</target>
        </trans-unit>
        <trans-unit id="2c97a82dbca5a469c866fbcfd4a0a433b2a0bbf3" translate="yes" xml:space="preserve">
          <source>ColumnsUsed</source>
          <target state="translated">ColumnsUsed</target>
        </trans-unit>
        <trans-unit id="7dbd619aad6c366ee15f8ec72b738cda247ce874" translate="yes" xml:space="preserve">
          <source>Combine the implementations of LIKE and GLOB into a single pattern-matching subroutine.</source>
          <target state="translated">LIKEとGLOBの実装を1つのパターンマッチングサブルーチンに結合します。</target>
        </trans-unit>
        <trans-unit id="1f542b583ad5e9c038e3b491fcfbca274b74980c" translate="yes" xml:space="preserve">
          <source>Combining all the code for SQLite into one big file makes SQLite easier to deploy &amp;mdash; there is just one file to keep track of. And because all code is in a single translation unit, compilers can do better inter-procedure optimization resulting in machine code that is between 5% and 10% faster.</source>
          <target state="translated">SQLiteのすべてのコードを1つの大きなファイルに結合すると、SQLiteの展開が容易になります。追跡するファイルは1つだけです。また、すべてのコードが単一の翻訳単位に含まれているため、コンパイラーはプロシージャー間の最適化を改善して、マシンコードを5％から10％高速化できます。</target>
        </trans-unit>
        <trans-unit id="833e395a74a9048d3a6708096c9bceb3c4d61ab8" translate="yes" xml:space="preserve">
          <source>Comes with a standalone &lt;a href=&quot;cli&quot;&gt;command-line interface&lt;/a&gt; (CLI) client that can be used to administer SQLite databases.</source>
          <target state="translated">SQLiteデータベースの管理に使用できるスタンドアロンの&lt;a href=&quot;cli&quot;&gt;コマンドラインインターフェイス&lt;/a&gt;（CLI）クライアントが付属しています。</target>
        </trans-unit>
        <trans-unit id="606ffe665dbeafe4183539a3e178cfb9ca0e425d" translate="yes" xml:space="preserve">
          <source>Command Line Shell For SQLite</source>
          <target state="translated">SQLite用コマンドラインシェル</target>
        </trans-unit>
        <trans-unit id="0538dff4886a4148d161292cddf7f24f025bd278" translate="yes" xml:space="preserve">
          <source>Comments are not SQL commands, but can occur within the text of SQL queries passed to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces. Comments are treated as whitespace by the parser. Comments can begin anywhere whitespace can be found, including inside expressions that span multiple lines.</source>
          <target state="translated">コメントはSQLコマンドではありませんが、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;および関連するインターフェースに渡されるSQLクエリのテキスト内で発生する可能性があります。コメントはパーサーによって空白として扱われます。コメントは、複数行にまたがる式の中など、空白が見つかる場所ならどこからでも開始できます。</target>
        </trans-unit>
        <trans-unit id="ce2337551468efeca0ed2bee143ae11b7529f35e" translate="yes" xml:space="preserve">
          <source>Comments can appear anywhere whitespace can occur, including inside expressions and in the middle of other SQL statements. Comments do not nest.</source>
          <target state="translated">コメントは、式の中や他のSQL文の途中など、空白が発生する可能性のある場所に表示することができます。コメントはネストしません。</target>
        </trans-unit>
        <trans-unit id="ffc61bb49c86bffaff083a2ed5fcbad20841a45a" translate="yes" xml:space="preserve">
          <source>Commit And Rollback Notification Callbacks</source>
          <target state="translated">コミットとロールバック通知のコールバック</target>
        </trans-unit>
        <trans-unit id="b67528525c7cbe3a2bdfe091a15601f0cfe434dc" translate="yes" xml:space="preserve">
          <source>Commit the transaction started in step 2.</source>
          <target state="translated">ステップ2で開始したトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="3e921ad8fb3469be1c1aae1e9c542f259ea843f7" translate="yes" xml:space="preserve">
          <source>Commit the transaction started on step 1 above.</source>
          <target state="translated">上記のステップ1で開始したトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="dcb41d75c37afedd19b91ddeac8ef4a861184289" translate="yes" xml:space="preserve">
          <source>Committing a</source>
          <target state="translated">コミット</target>
        </trans-unit>
        <trans-unit id="ca50d239d0c5f707752157b74490a4762cc31cc1" translate="yes" xml:space="preserve">
          <source>Committing a Transaction</source>
          <target state="translated">トランザクションのコミット</target>
        </trans-unit>
        <trans-unit id="a6b2b4078078c94d88c10ba671b8570bcd19b64c" translate="yes" xml:space="preserve">
          <source>Committing a multi-file transaction.</source>
          <target state="translated">複数ファイルのトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="938c8ff92d76193cdabf706c7c9bd4d6322fdb0d" translate="yes" xml:space="preserve">
          <source>Committing a read-write transaction.</source>
          <target state="translated">読み書き可能なトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="7f07598efa7d083be720757f9b4819e013d7faa3" translate="yes" xml:space="preserve">
          <source>Committing a statement transaction.</source>
          <target state="translated">ステートメントトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="3d0965b4050b33d43b6f8f1d0b90555ef5b6f358" translate="yes" xml:space="preserve">
          <source>Common Table Expressions or CTEs act like temporary &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; that exist only for the duration of a single SQL statement. There are two kinds of common table expressions: &quot;ordinary&quot; and &quot;recursive&quot;. Ordinary common table expressions are helpful for making queries easier to understand by factoring subqueries out of the main SQL statement. Recursive common table expressions provide the ability to do hierarchical or recursive queries of trees and graphs, a capability that is not otherwise available in the SQL language.</source>
          <target state="translated">共通テーブル式またはCTE は、単一のSQLステートメントの間だけ存在する一時&lt;a href=&quot;lang_createview&quot;&gt;ビューの&lt;/a&gt;ように機能します。一般的なテーブル式には、「通常」と「再帰的」の2種類があります。通常の共通テーブル式は、メインSQLステートメントからサブクエリを分解してクエリを理解しやすくするのに役立ちます。再帰的共通テーブル式は、ツリーやグラフの階層的または再帰的クエリを実行する機能を提供します。これは、SQL言語では使用できない機能です。</target>
        </trans-unit>
        <trans-unit id="8d105cf44d3926289e65c1c83d8e37cb23fd049e" translate="yes" xml:space="preserve">
          <source>Compare</source>
          <target state="translated">Compare</target>
        </trans-unit>
        <trans-unit id="61bf40991dc6cf79e005a417dde1c212c92bf988" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles</source>
          <target state="translated">2つのスナップショットハンドルの年齢を比較する</target>
        </trans-unit>
        <trans-unit id="c69b8e330786eb35150cb1cdb917926c81985161" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles.</source>
          <target state="translated">2つのスナップショットハンドルの年齢を比較します。</target>
        </trans-unit>
        <trans-unit id="b7893f36396a39c33c9b065563149f1fc3b7de3a" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)&amp;lt;reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5 store the result of comparison (0 or 1 or NULL) into register P2.</source>
          <target state="translated">レジスタP1とP3の値を比較します。reg（P3）&amp;lt;reg（P1）の場合、アドレスP2にジャンプします。または、SQLITE_STOREP2フラグがP5で設定されている場合は、比較結果（0または1またはNULL）をレジスタP2に格納します。</target>
        </trans-unit>
        <trans-unit id="64f72da6a28852747af852811f0159350ec037fd" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)==reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5, then store the result of comparison in register P2.</source>
          <target state="translated">レジスタP1とP3の値を比較します。reg(P3)==reg(P1)ならば、アドレスP2にジャンプします。または、P5 に SQLITE_STOREP2 フラグが設定されている場合は、比較結果をレジスタ P2 に格納します。</target>
        </trans-unit>
        <trans-unit id="716736d76052378cdb4fa2fb220c0af66c296429" translate="yes" xml:space="preserve">
          <source>Compare two vectors of registers in reg(P1)..reg(P1+P3-1) (call this vector &quot;A&quot;) and in reg(P2)..reg(P2+P3-1) (&quot;B&quot;). Save the result of the comparison for use by the next &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; instruct.</source>
          <target state="translated">reg（P1）.. reg（P1 + P3-1）（このベクトルを &quot;A&quot;と呼ぶ）とreg（P2）.. reg（P2 + P3-1）（ &quot;B&quot;）の2つのレジスターのベクトルを比較します。比較の結果を保存して、次の&lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt;命令で使用します。</target>
        </trans-unit>
        <trans-unit id="83d5898be3634e470654cbd85b9deec85a9c9f73" translate="yes" xml:space="preserve">
          <source>Comparison affinity rules</source>
          <target state="translated">比較親和性のルール</target>
        </trans-unit>
        <trans-unit id="134badaaa974d64bb5437d6b34d1293f7d86554c" translate="yes" xml:space="preserve">
          <source>Comparison expressions</source>
          <target state="translated">表現の比較</target>
        </trans-unit>
        <trans-unit id="8f31c13dc4b4da5bf8cbe8bac8ef033f779731d8" translate="yes" xml:space="preserve">
          <source>Comparison with fts4</source>
          <target state="translated">fts4との比較</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="7637a56b8025cf4632b2ae465571d61372b6d40e" translate="yes" xml:space="preserve">
          <source>Compatibility node: Prior to SQLite version 3.28.0 (2019-04-16) only the --update option was supported but that option worked like --insert in that it always reinserted every file regardless of whether or not it had changed.</source>
          <target state="translated">互換性のあるノードです。SQLite バージョン 3.28.0 (2019-04-16)より前のバージョンでは --update オプションのみがサポートされていましたが、このオプションは --insert と同様に動作し、ファイルが変更されたかどうかに関わらず、常にすべてのファイルを再挿入していました。</target>
        </trans-unit>
        <trans-unit id="633ffa201e66fd459288742adf70c255cf4ddcdc" translate="yes" xml:space="preserve">
          <source>Compile SQLite in an as-delivered configuration, without any special telemetry or debugging options.</source>
          <target state="translated">特別なテレメトリやデバッグオプションを使用せずに、配信された構成でSQLiteをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="7a5b8e5cc0e47f26d2d005f2486e0f5c2a2c206c" translate="yes" xml:space="preserve">
          <source>Compile fts</source>
          <target state="translated">ftsをコンパイル</target>
        </trans-unit>
        <trans-unit id="107e25274d1b787330bb17ec68cf503455bc4672" translate="yes" xml:space="preserve">
          <source>Compile the SQLite library with the either the compile-time options &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; or &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt;. Support for 8+3 filenames is not included in SQLite by default because it does introduce some overhead. The overhead is tiny, but even so, we do not want to burden the billions of SQLite applications that do not need 8+3 filename support.</source>
          <target state="translated">コンパイル時オプション&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt;または&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2を&lt;/a&gt;使用して、SQLiteライブラリをコンパイルします。8 + 3のファイル名のサポートは、オーバーヘッドを引き起こすため、デフォルトではSQLiteに含まれていません。オーバーヘッドはわずかですが、それでも、8 + 3のファイル名サポートを必要としない何十億ものSQLiteアプリケーションに負担をかけたくありません。</target>
        </trans-unit>
        <trans-unit id="c8149cd52fe785ecf8f59126442a4f04b3761167" translate="yes" xml:space="preserve">
          <source>Compile-Time Authorization Callbacks</source>
          <target state="translated">コンパイル時認可コールバック</target>
        </trans-unit>
        <trans-unit id="5ce286997996977a2b237b29a86f8db1efc35204" translate="yes" xml:space="preserve">
          <source>Compile-Time Library Version Numbers</source>
          <target state="translated">コンパイルタイムライブラリのバージョン番号</target>
        </trans-unit>
        <trans-unit id="ab7d35e46c49beab638f326c5a28b5f3ad2b8c85" translate="yes" xml:space="preserve">
          <source>Compile-time Options</source>
          <target state="translated">コンパイル時間オプション</target>
        </trans-unit>
        <trans-unit id="1453f0519dea087605be7dc19703a1f478ff0ab3" translate="yes" xml:space="preserve">
          <source>Compile-time options OS_UNIX, OS_WIN, OS_OS2, OS_OTHER, and TEMP_STORE have been renamed to include an &quot;SQLITE_&quot; prefix in order to help avoid namespace collisions with application software. The new names of these options are respectively: SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, SQLITE_OS_OTHER, and &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;.</source>
          <target state="translated">コンパイル時オプションOS_UNIX、OS_WIN、OS_OS2、OS_OTHER、およびTEMP_STOREの名前が変更され、アプリケーションソフトウェアとのネームスペースの競合を回避するために「SQLITE_」プレフィックスが含まれるようになりました。これらのオプションの新しい名前は、それぞれSQLITE_OS_UNIX、SQLITE_OS_WIN、SQLITE_OS_OS2、SQLITE_OS_OTHER、および&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b67395ae5988ac5f1079e7140abc23ed771501d4" translate="yes" xml:space="preserve">
          <source>Compile-time options to SQLite are controlled by C-preprocessor macros. SQLite version 3.6.0 changes the names of some of these macros so that all C-preprocessor macros that are specific to SQLite begin with the &quot;SQLITE_&quot; prefix. This is done to reduce the risk of name collisions with other software modules.</source>
          <target state="translated">SQLite のコンパイル時オプションは、C プリプロセッサ マクロによって制御されます。SQLite バージョン 3.6.0 では、これらのマクロの一部の名前が変更され、SQLite に固有の C プリプロセッサ マクロはすべて接頭辞 &quot;SQLITE_&quot; で始まるようになりました。これは、他のソフトウェア モジュールと名前が衝突するリスクを減らすためです。</target>
        </trans-unit>
        <trans-unit id="7bfb67af50943c68cc8db4a086f448c070c20b10" translate="yes" xml:space="preserve">
          <source>Compiling An SQL Statement</source>
          <target state="translated">SQLステートメントのコンパイル</target>
        </trans-unit>
        <trans-unit id="5aad775a4fde57c9a7d789da7ebb4f28bacbccb3" translate="yes" xml:space="preserve">
          <source>Compiling Loadable Extensions</source>
          <target state="translated">ロード可能な拡張機能のコンパイル</target>
        </trans-unit>
        <trans-unit id="17dae604367670c84a2179095a23e948fe606538" translate="yes" xml:space="preserve">
          <source>Compiling the CLI</source>
          <target state="translated">CLIのコンパイル</target>
        </trans-unit>
        <trans-unit id="42bc083c37979291f51503e346021e5adf7ef736" translate="yes" xml:space="preserve">
          <source>Compiling the TCL interface</source>
          <target state="translated">TCLインターフェースのコンパイル</target>
        </trans-unit>
        <trans-unit id="f6b7336de511d34be1007604b55dc1686fbabd26" translate="yes" xml:space="preserve">
          <source>Compiling with GCC and -Os results in a binary that is slightly less than 500KB in size. (Update 2018-07-07: Due to the addition of new features such as &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; and &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;, the library footprint is now slightly larger than 500KB.)</source>
          <target state="translated">GCCおよび-Oを使用してコンパイルすると、サイズが500KBをわずかに下回るバイナリが生成されます。（2018-07-07の更新：&lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;や&lt;a href=&quot;windowfunctions&quot;&gt;ウィンドウ関数&lt;/a&gt;などの新機能の追加により、ライブラリのフットプリントは500KBよりわずかに大きくなりました。）</target>
        </trans-unit>
        <trans-unit id="016600cc08f9b09c5ede26e00051860d386d3258" translate="yes" xml:space="preserve">
          <source>Completely disable all mutexing for use in single-threaded applications.</source>
          <target state="translated">シングルスレッドアプリケーションで使用するために、すべてのミューテックスを完全に無効にします。</target>
        </trans-unit>
        <trans-unit id="92cab31e763f04f0a9379d06fa22ebdf435b210d" translate="yes" xml:space="preserve">
          <source>Completion = 100% * (pagecount() - remaining()) / pagecount()</source>
          <target state="translated">完成度=100%*(pagecount()-remaining())/pagecount()</target>
        </trans-unit>
        <trans-unit id="0e8198cb08e14211a17b2113a2bd05ad2475de6d" translate="yes" xml:space="preserve">
          <source>Complex SQL queries that compile down to large &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">コンパイルして大きな&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメントに&lt;/a&gt;変換する複雑なSQLクエリ。</target>
        </trans-unit>
        <trans-unit id="2a71a43f0af5e946760833a731194bc756332728" translate="yes" xml:space="preserve">
          <source>Component tables must not be declared WITHOUT ROWID, and must all have the same schema, but may have different names within their databases. In this context, &quot;the same schema&quot; means that:</source>
          <target state="translated">コンポーネントテーブルは、WITHOUT ROWIDで宣言されてはならず、すべて同じスキーマを持っていなければなりませんが、そのデータベース内では異なる名前を持つことができます。この文脈では、「同じスキーマ」とは、次のような意味です。</target>
        </trans-unit>
        <trans-unit id="73fefbebc7ea5875c1b1def30f50ddaec200fca3" translate="yes" xml:space="preserve">
          <source>Compound SELECT Statements</source>
          <target state="translated">複合SELECT文</target>
        </trans-unit>
        <trans-unit id="fc1dbf04d5c2c01646f4f6f5a41a610a2c9e6452" translate="yes" xml:space="preserve">
          <source>Compound SELECT statements joined by UNION, EXCEPT, or INTERSECT</source>
          <target state="translated">UNION、EXCEPT、またはINTERSECTで結合された複合SELECT文</target>
        </trans-unit>
        <trans-unit id="b777b90633cd6198da59fc74556aaf318e15c82b" translate="yes" xml:space="preserve">
          <source>Compound Select Statements</source>
          <target state="translated">複合セレクト文</target>
        </trans-unit>
        <trans-unit id="41afde278d24cef38341e9c639a6f290a66a33e9" translate="yes" xml:space="preserve">
          <source>Compound select</source>
          <target state="translated">コンパウンドセレクト</target>
        </trans-unit>
        <trans-unit id="e99b67d469ceb0e0903f3fdb83544c4883bac6aa" translate="yes" xml:space="preserve">
          <source>Compressed FTS4 content</source>
          <target state="translated">圧縮されたFTS4コンテンツ</target>
        </trans-unit>
        <trans-unit id="d750266cb42e04add18c2049e2c2458292889a29" translate="yes" xml:space="preserve">
          <source>Compute all columns for the current row of the result.</source>
          <target state="translated">結果の現在の行のすべての列を計算します。</target>
        </trans-unit>
        <trans-unit id="83c78585de25cd96c1c2ab80c2c2412af55dbfdf" translate="yes" xml:space="preserve">
          <source>Compute the Mandelbrot set</source>
          <target state="translated">マンデルブロ集合を計算する</target>
        </trans-unit>
        <trans-unit id="b448f9527d237644e1fc4a194d188e6a4b4d1334" translate="yes" xml:space="preserve">
          <source>Compute the current date.</source>
          <target state="translated">現在の日付を計算します。</target>
        </trans-unit>
        <trans-unit id="41873a1f5500f4b614234079571f3016e43ab82f" translate="yes" xml:space="preserve">
          <source>Compute the current unix timestamp.</source>
          <target state="translated">現在の unix タイムスタンプを計算します。</target>
        </trans-unit>
        <trans-unit id="e04bc35c7b102a71d56a8c32d3bd5fac01970545" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone.</source>
          <target state="translated">日付と時刻を計算し、UNIXタイムスタンプ1092941466を与えられ、あなたのローカルタイムゾーンを補正します。</target>
        </trans-unit>
        <trans-unit id="a79ce5022e7222955180721f104a747e76cc865d" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466.</source>
          <target state="translated">unix タイムスタンプ 1092941466 が与えられた日時を計算します。</target>
        </trans-unit>
        <trans-unit id="876432c3d5981b5bb35c00fb0bc71a0643cea495" translate="yes" xml:space="preserve">
          <source>Compute the date of the first Tuesday in October for the current year.</source>
          <target state="translated">現在の年の10月の第1火曜日の日付を計算します。</target>
        </trans-unit>
        <trans-unit id="85e08c9c66c5c14d3d7f7fdaf91b03031363b7fc" translate="yes" xml:space="preserve">
          <source>Compute the hash value: h = P * 383</source>
          <target state="translated">ハッシュ値を計算する:h=P*383</target>
        </trans-unit>
        <trans-unit id="7548a41024e6603fd25f9fadf45476eb046bf623" translate="yes" xml:space="preserve">
          <source>Compute the last day of the current month.</source>
          <target state="translated">現在の月の最終日を計算します。</target>
        </trans-unit>
        <trans-unit id="1c0a0d1208aea03d34c1fcb88dbad15854e8464f" translate="yes" xml:space="preserve">
          <source>Compute the number of days since the signing of the US Declaration of Independence.</source>
          <target state="translated">アメリカの独立宣言に署名してからの日数を計算します。</target>
        </trans-unit>
        <trans-unit id="5d82004a2aadc6ec6baebba8982b8bfbd8ed18a8" translate="yes" xml:space="preserve">
          <source>Compute the number of seconds since a particular moment in 2004:</source>
          <target state="translated">2004年のある瞬間からの秒数を計算します。</target>
        </trans-unit>
        <trans-unit id="9240e490f170f5bfe9b5ac2684f082567e717920" translate="yes" xml:space="preserve">
          <source>Compute the remainder after integer register P2 is divided by register P1 and store the result in register P3. If the value in register P1 is zero the result is NULL. If either operand is NULL, the result is NULL.</source>
          <target state="translated">整数レジスタP2をレジスタP1で除算した後の余りを計算し、その結果をレジスタP3に格納します。レジスタP1の値が0の場合、結果はNULLになります。どちらかのオペランドがNULLの場合、結果はNULLになります。</target>
        </trans-unit>
        <trans-unit id="f47380023b575b27550d43814811cc725e477ad2" translate="yes" xml:space="preserve">
          <source>Compute the time since the unix epoch in seconds (like strftime('%s','now') except includes fractional part):</source>
          <target state="translated">unix エポックからの時間を秒単位で計算します (strftime('%s','now')のように、小数点以下の部分を除いて)。</target>
        </trans-unit>
        <trans-unit id="e144db42c7fe7841a847f92a642087b247050e3f" translate="yes" xml:space="preserve">
          <source>Compute the transitive closure of a set.</source>
          <target state="translated">集合の推移的閉塞を計算します。</target>
        </trans-unit>
        <trans-unit id="6ad79ab6353b1eee8ebbc085e10d17c4fcfb024f" translate="yes" xml:space="preserve">
          <source>Concat</source>
          <target state="translated">Concat</target>
        </trans-unit>
        <trans-unit id="bbae6853fb6e0fd40e4ce00a77adbb0072630198" translate="yes" xml:space="preserve">
          <source>Concatenate Two Changeset Objects</source>
          <target state="translated">2 つのチェンジセットオブジェクトを連結</target>
        </trans-unit>
        <trans-unit id="dbcb0f9023d09dcdfc6e54ecf5de70332ecf46a5" translate="yes" xml:space="preserve">
          <source>Conceptually, the wal-index is shared memory, though the current VFS implementations use a memory-mapped file for operating-system portability. The memory-mapped file is in the same directory as the database and has the same name as the database with a &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; suffix appended. Because the wal-index is shared memory, SQLite does not support &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=WAL&lt;/a&gt; on a network filesystem when clients are on different machines, as all clients of the database must be able to share the same memory.</source>
          <target state="translated">概念的には、wal-indexは共有メモリですが、現在のVFS実装では、オペレーティングシステムの移植性のためにメモリマップファイルを使用しています。メモリマップファイルはデータベースと同じディレクトリにあり、データベースと同じ名前に &quot; &lt;code&gt;-shm&lt;/code&gt; &quot;サフィックスが追加されています。 wal-indexは共有メモリであるため、クライアントが異なるマシン上にある場合、データベースのすべてのクライアントが同じメモリを共有できる必要があるため、SQLiteはネットワークファイルシステムでの&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = WAL&lt;/a&gt;をサポートしません。</target>
        </trans-unit>
        <trans-unit id="49b7441ed47d615d68b5fa69e66989fb88012252" translate="yes" xml:space="preserve">
          <source>Conceptually, there is just a single DELETE-mode lock. The DELETE-mode lock for a single database connection can be in exactly one of the following states:</source>
          <target state="translated">概念的には、単一のDELETEモードロックが存在するだけです。単一のデータベース接続のDELETEモードロックは、以下の状態のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="7a3f4c2c7a172166630a7d362c10fe1d0fc91c29" translate="yes" xml:space="preserve">
          <source>Concurrent Use By Multiple Processes</source>
          <target state="translated">複数プロセスによる同時使用</target>
        </trans-unit>
        <trans-unit id="eef82957c155636f622355147508a53bea076447" translate="yes" xml:space="preserve">
          <source>Configurable edit distances</source>
          <target state="translated">設定可能な編集距離</target>
        </trans-unit>
        <trans-unit id="b8577c99aaca7f628cb921ee68fce4bf962909c4" translate="yes" xml:space="preserve">
          <source>Configuration Options</source>
          <target state="translated">設定オプション</target>
        </trans-unit>
        <trans-unit id="5d3a088dea7acb9fc65cbb6e86dc351c6aa1d47c" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object</source>
          <target state="translated">チェンジセットリベイザーオブジェクトを構成する</target>
        </trans-unit>
        <trans-unit id="c2e506c363291ec2edbc4c00e46f58bf68ba2d4e" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object.</source>
          <target state="translated">チェンジセットリベイザーオブジェクトを構成します。</target>
        </trans-unit>
        <trans-unit id="1cfd39d93ce243f8209e2cb0fd6a72bd5199a441" translate="yes" xml:space="preserve">
          <source>Configure an auto-checkpoint</source>
          <target state="translated">自動チェックポイントの設定</target>
        </trans-unit>
        <trans-unit id="5cda84f2fffb92ec6200fae3e17f21d369027339" translate="yes" xml:space="preserve">
          <source>Configure database connections</source>
          <target state="translated">データベース接続の設定</target>
        </trans-unit>
        <trans-unit id="9104fdd73ba3ec2b0c456f6d3cca5876e340e73f" translate="yes" xml:space="preserve">
          <source>Configure global parameters</source>
          <target state="translated">グローバルパラメータの設定</target>
        </trans-unit>
        <trans-unit id="fffa5ae7207c4ce72ae9a5c16488369d68b30ee7" translate="yes" xml:space="preserve">
          <source>Configure the changeset rebaser object to rebase changesets according to the conflict resolutions described by buffer pRebase (size nRebase bytes), which must have been obtained from a previous call to sqlite3changeset_apply_v2().</source>
          <target state="translated">バッファpRebase (サイズnRebaseバイト)で記述された競合解決に従ってチェンジセットをリベースするようにチェンジセットリベースオブジェクトを構成します。</target>
        </trans-unit>
        <trans-unit id="037fffb22a00fbc77fceb8bfd136c7237a83b229" translate="yes" xml:space="preserve">
          <source>Configuring Memory-Mapped I/O</source>
          <target state="translated">メモリマップドI/Oの構成</target>
        </trans-unit>
        <trans-unit id="9d3bc7d832ae044f63c47a2f9e7fae292f78d77f" translate="yes" xml:space="preserve">
          <source>Configuring The SQLite Library</source>
          <target state="translated">SQLite ライブラリの設定</target>
        </trans-unit>
        <trans-unit id="3479acef100487d6ec8205ddc884e90381568fa7" translate="yes" xml:space="preserve">
          <source>Configuring an ON UPDATE or ON DELETE action does not mean that the foreign key constraint does not need to be satisfied. For example, if an &quot;ON DELETE SET DEFAULT&quot; action is configured, but there is no row in the parent table that corresponds to the default values of the child key columns, deleting a parent key while dependent child keys exist still causes a foreign key violation. For example:</source>
          <target state="translated">ON UPDATEまたはON DELETEアクションを構成しても、外部キー制約を満たす必要がないという意味ではありません。例えば、&quot;ON DELETE SET DEFAULT &quot;アクションが構成されていても、親テーブルに子キー列のデフォルト値に対応する行がない場合、従属する子キーが存在する間に親キーを削除すると、外部キー違反が発生します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="377ada5c437e4e8ecbb86b359c764c7d510c3e88" translate="yes" xml:space="preserve">
          <source>Conflict Resolution Algorithms</source>
          <target state="translated">紛争解決アルゴリズム</target>
        </trans-unit>
        <trans-unit id="8975355354bcb513bcd2981e89b88a2159127a86" translate="yes" xml:space="preserve">
          <source>Conflict resolution modes</source>
          <target state="translated">紛争解決モード</target>
        </trans-unit>
        <trans-unit id="9658bf354692dbe100fe5694b8f321b7b117d4a0" translate="yes" xml:space="preserve">
          <source>Conflict-algorithm must be one of the SQLite conflict algorithms for the INSERT statement:</source>
          <target state="translated">競合アルゴリズムは、INSERT文のSQLite競合アルゴリズムの1つでなければなりません。</target>
        </trans-unit>
        <trans-unit id="af76481a91ddbca2a009d9ab58cd9c8e2ed5ef31" translate="yes" xml:space="preserve">
          <source>Connections hold an exclusive lock when change in between WAL mode and any of the various rollback-modes. Connections might also attempt to obtain an EXCLUSIVE lock when they disconnect from WAL mode. If a connection is able to obtain an EXCLUSIVE lock, that means it is the only connection to the database and so it may attempt to checkpoint and then delete the WAL-index and WAL files.</source>
          <target state="translated">接続は、WAL モードとさまざまなロールバック・モードの間で変更するときに排他的なロックを保持します。また、接続は、WALモードから切断したときに排他的ロックを取得しようとすることがあります。接続がEXCLUSIVEロックを取得できた場合、それはデータベースへの唯一の接続であることを意味し、チェックポイントしてからWAL-indexとWALファイルを削除しようとするかもしれません。</target>
        </trans-unit>
        <trans-unit id="aec1d9b262374bdba4b3ad5a6350b6ef2fd31b30" translate="yes" xml:space="preserve">
          <source>Consider a different database with &quot;CREATE TABLE big(json JSON)&quot;. To see a complete line-by-line decomposition of the data:</source>
          <target state="translated">CREATE TABLE big(json JSON)」で別のデータベースを考えてみましょう。データを1行ごとに完全に分解したものを見るには</target>
        </trans-unit>
        <trans-unit id="89d5e40d39c9d5acb3a34ddf23480e47ca55947d" translate="yes" xml:space="preserve">
          <source>Consider a slightly different scenario:</source>
          <target state="translated">少し変わったシナリオを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="c5d0d6c9988bc87a91e1eceb2b1190187ebda45c" translate="yes" xml:space="preserve">
          <source>Consider a table (shown below) intended to store a vocabulary of words together with a count of the number of occurrences of each word in some text corpus:</source>
          <target state="translated">あるテキストコーパスに含まれる各単語の出現回数のカウントと一緒に単語の語彙を保存するための表(以下に示す)を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="8ec68a1b2150a873bc929bf5c86810425d54b691" translate="yes" xml:space="preserve">
          <source>Consider a table such as the following:</source>
          <target state="translated">以下のような表を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="163f9a2c7a0b11befe42d8af38ac3f4e6b7bc949" translate="yes" xml:space="preserve">
          <source>Consider a table that describes the members of an organization as well as the chain-of-command within that organization:</source>
          <target state="translated">組織のメンバーと、その組織内での指揮命令系統を記述した表を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="4d89aaebca400a1430435ad2d544ef0799645f0e" translate="yes" xml:space="preserve">
          <source>Consider an example. Suppose you are trying to insert a string value into a database table where the string value was obtained from user input. Suppose the string to be inserted is stored in a variable named zString. The code to do the insertion might look like this:</source>
          <target state="translated">例を考えてみましょう。文字列の値がユーザ入力から取得されたデータベース・テーブルに文字列の値を挿入しようとしているとします。挿入する文字列が zString という名前の変数に格納されているとします。挿入するコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="968f255a5a54f60fb698955e4fcb28ea4353bc5f" translate="yes" xml:space="preserve">
          <source>Consider explicit collate clauses when matching WHERE constraints to indices in the query optimizer. Ticket #2391</source>
          <target state="translated">クエリオプティマイザでWHERE制約をインデックスにマッチングさせる際に、明示的な照合句を考慮するようにしました。チケット #2391</target>
        </trans-unit>
        <trans-unit id="444e122b76db00a9b4c3d12c64b80faed572e3e1" translate="yes" xml:space="preserve">
          <source>Consider how this query works. The initial-select runs first and returns a single row with a single column &quot;1&quot;. This one row is added to the queue. In step 2a, that one row is extracted from the queue and added to &quot;cnt&quot;. Then the recursive-select is run in accordance with step 2c generating a single new row with value &quot;2&quot; to add to the queue. The queue still has one row, so step 2 repeats. The &quot;2&quot; row is extracted and added to the recursive table by steps 2a and 2b. Then the row containing 2 is used as if it were the complete content of the recursive table and the recursive-select is run again, resulting in a row with value &quot;3&quot; being added to the queue. This repeats 999999 times until finally at step 2a the only value on the queue is a row containing 1000000. That row is extracted and added to the recursive table. But this time, the WHERE clause causes the recursive-select to return no rows, so the queue remains empty and the recursion stops.</source>
          <target state="translated">このクエリがどのように動作するかを考えてみましょう。最初に初期選択が実行され、1つの列 &quot;1 &quot;を持つ1つの行が返されます。この1行がキューに追加される。ステップ2aでは、その1行がキューから抽出され、&quot;cnt &quot;に追加される。その後、再帰的選択は、ステップ2cに従って実行され、キューに追加するために、値 &quot;2 &quot;を持つ単一の新しい行を生成する。キューはまだ1つの行を持っているので、ステップ2が繰り返されます。2 &quot;行は抽出され、ステップ2aと2bによって再帰テーブルに追加される。その後、2を含む行は、あたかも再帰テーブルの完全な内容であるかのように使用され、再帰的選択が再び実行され、結果として、値 &quot;3 &quot;を持つ行がキューに追加される。これは、最終的にステップ2aでキュー上の唯一の値が1000000を含む行になるまで9999回繰り返されます。その行は抽出され、再帰テーブルに追加されます。しかし、今回は、WHERE句によって、再帰的選択は行を返さないので、キューは空のままで、再帰は停止します。</target>
        </trans-unit>
        <trans-unit id="f8fa74d8815f89442ddf62f70a180b631fe1665c" translate="yes" xml:space="preserve">
          <source>Consider querying this table to find the number of occurrences of the word &quot;xyzzy&quot;.:</source>
          <target state="translated">このテーブルにクエリを実行して、&quot;xyzzy &quot;という単語の出現数を検索してみてください。</target>
        </trans-unit>
        <trans-unit id="e890ad26c51af96d02d41774ffeaa333b700b830" translate="yes" xml:space="preserve">
          <source>Consider the following two command sequences:</source>
          <target state="translated">次の2つのコマンドシーケンスを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="38f2ce12e9214d8cde3ab5b6d1808e89b342965a" translate="yes" xml:space="preserve">
          <source>Consider using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface to limit the scope of SQL that will be processed. For example, an application that does not need to change the database schema might add an sqlite3_set_authorizer() callback that causes any CREATE or DROP statement to fail.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;インターフェースを使用して、処理されるSQLのスコープを制限することを検討してください。たとえば、データベーススキーマを変更する必要のないアプリケーションがsqlite3_set_authorizer（）コールバックを追加すると、CREATEまたはDROPステートメントが失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f881ec6e1c51116405b7bd7506d06d9368faea1" translate="yes" xml:space="preserve">
          <source>Consider what would happen if disk sector writes are interrupted by a power loss. If an application writes two or three bytes in the middle of some file, the operating system will implement this by first reading the entire sector containing those bytes, making the change to the sector in memory, then writing the entire sector back to the disk. If a power loss occurs during the writeback and the sector was not completely written, then on the next read after reboot, error correcting codes in the sector will probably detect irreparable damage and the disk controller will read out the sector as all zeros or all ones. Thus values will have changed outside of the range of the two or three bytes that were written at the application level - a violation of the powersafe overwrite property.</source>
          <target state="translated">ディスクセクタへの書き込みが停電で中断された場合に何が起こるかを考えてみましょう。アプリケーションがファイルの途中で 2 バイトか 3 バイトを書き込む場合、オペレーティングシステムは、まずそのバイトを含むセクタ全体を読み込み、メモリ内のセクタに変更を加えてから、セクタ全体をディスクに書き戻すという方法でこれを実装します。もし、ライトバック中に停電が発生し、セクタが完全に書き込まれなかった場合、再起動後の次の読み取りでは、セクタ内のエラー訂正コードが修復不可能な損傷を検出し、ディスクコントローラはセクタをすべてゼロまたはすべて1として読み出すことになります。このように、値はアプリケーションレベルで書き込まれた2~3バイトの範囲外で変更されることになり、パワーセーフ上書きプロパティの違反となります。</target>
        </trans-unit>
        <trans-unit id="454478261b68992469d64496e9cfb5f053cfbed3" translate="yes" xml:space="preserve">
          <source>Console the sorrowing.</source>
          <target state="translated">悲しみを慰めろ</target>
        </trans-unit>
        <trans-unit id="c51c1399ff5b435aa7c4c51efe988981e74f0189" translate="yes" xml:space="preserve">
          <source>Constant value 0.</source>
          <target state="translated">定数値 0。</target>
        </trans-unit>
        <trans-unit id="f14defda3a0615f9817e1062360bb6f9e7654bb6" translate="yes" xml:space="preserve">
          <source>Constant value 1. This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">定数値 1。このフィールドは、列 0 に関連付けられたタームオフセットリストでは省略されます。</target>
        </trans-unit>
        <trans-unit id="f7d639ba9c48f5467c4d1a8f0152a2dc90222051" translate="yes" xml:space="preserve">
          <source>Constants Defining Special Destructor Behavior</source>
          <target state="translated">特殊デストラクタの動作を定義する定数</target>
        </trans-unit>
        <trans-unit id="af7e74633bc458147e8d5da16df8562d003b392e" translate="yes" xml:space="preserve">
          <source>Constants Passed To The Conflict Handler</source>
          <target state="translated">コンフリクトハンドラに渡される定数</target>
        </trans-unit>
        <trans-unit id="aa0aeb15b7dcd6d473c7d1bf166a40ca61fee668" translate="yes" xml:space="preserve">
          <source>Constants Returned By The Conflict Handler</source>
          <target state="translated">コンフリクトハンドラが返す定数</target>
        </trans-unit>
        <trans-unit id="6337f09e95dde3b3b58675d8b6f0257adf22ba40" translate="yes" xml:space="preserve">
          <source>Constants:</source>
          <target state="translated">Constants:</target>
        </trans-unit>
        <trans-unit id="f37e46006a1745cf96ebe1f73c1de5744dcf1d1d" translate="yes" xml:space="preserve">
          <source>Constraint Conflict Resolution in SQLite</source>
          <target state="translated">SQLite での制約の競合の解決</target>
        </trans-unit>
        <trans-unit id="6889aa68d48cec7c8c38bf28801d4701520ff0dc" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a878fca8a43e71d4ec596dfa4ec029c0c81a75d0" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a2c5628cdcd91822efac04edcb216499727358f" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1cdc0adde4d7b415af1d0d33bde5ec5e8f55638" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d43a93e241e64f205e9be40e6849d360ecb314d2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e9fffe66b7ccd965b3d8281c4189b6873e699b" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e898f79bdd10cd47ee3054a83ab75f61437a7aa4" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08db86cfe6351f2012dbf46992a9fa7d1631a5e2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38014e350b2ec610dc63ea6835bc8bf20566c178" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f94c6d14960e90153f9e56ef05e080f43ace38fd" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3617dc14ae8be730219fa2aabd32aaa900ccfc3a" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">コンストラクタ：&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2da4ffc9b2e344254d3be3ef8d1b5463c6c55d3" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b84725656dbaa01e32202bf862175e15f3aa743" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">コンストラクタ：&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63842448f26d096823a3c51f076ae6fb704d1709" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;、&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e8adbf806de9adae308cb1a722a2834efb03d01" translate="yes" xml:space="preserve">
          <source>Contains the actual data inserted into the FTS5 table. This shadow table is not present for &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; FTS5 tables.</source>
          <target state="translated">FTS5テーブルに挿入された実際のデータが含まれます。このシャドウテーブルには、のために存在していない&lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt;または&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部コンテンツ&lt;/a&gt; FTS5テーブル。</target>
        </trans-unit>
        <trans-unit id="6773795897579cbc7647c6d1ac1d4b8bc25387d4" translate="yes" xml:space="preserve">
          <source>Contains the size of each column of each row in the virtual table in tokens. This shadow table is not present if the &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt; is set to 0.</source>
          <target state="translated">仮想テーブルの各行の各列のサイズがトークンに含まれています。&lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;「columnsize」オプション&lt;/a&gt;が0に設定されている場合、このシャドウテーブルは存在しません。</target>
        </trans-unit>
        <trans-unit id="c6336221afe18ddc0e53b18acd141d3c916c6884" translate="yes" xml:space="preserve">
          <source>Contains the text of the term for this row.</source>
          <target state="translated">この行の用語のテキストを含みます。</target>
        </trans-unit>
        <trans-unit id="8149ba57ba940e5c3672ef00fa60ad0d2afcb776" translate="yes" xml:space="preserve">
          <source>Contains the values of persistent configuration parameters.</source>
          <target state="translated">永続的な構成パラメータの値を保持します。</target>
        </trans-unit>
        <trans-unit id="17ad25c1af7990d50b53a9e2d46ba0f493597884" translate="yes" xml:space="preserve">
          <source>Content Size</source>
          <target state="translated">コンテンツサイズ</target>
        </trans-unit>
        <trans-unit id="311a2e63246045d0ca04704e25eb8fe09678745a" translate="yes" xml:space="preserve">
          <source>Content can be accessed and updated using concise SQL queries instead of lengthy and error-prone procedural routines.</source>
          <target state="translated">長くてエラーが発生しやすい手続きルーチンの代わりに、簡潔なSQLクエリを使用して、コンテンツにアクセスして更新することができます。</target>
        </trans-unit>
        <trans-unit id="54e6a597c2b0fe05466617946d21001a0e849ccf" translate="yes" xml:space="preserve">
          <source>Content can be updated continuously and atomically so that little or no work is lost in a power failure or crash.</source>
          <target state="translated">コンテンツは、継続的かつ原子的に更新することができるので、停電やクラッシュでほとんど作業ができなくなることはありません。</target>
        </trans-unit>
        <trans-unit id="5a0ca8d8e7e6987ce002e1b9cc19498346916cd0" translate="yes" xml:space="preserve">
          <source>Content stored in an SQLite database is more likely to be recoverable decades in the future, long after all traces of the original application have been lost. Data lives longer than code.</source>
          <target state="translated">SQLite データベースに保存されているコンテンツは、元のアプリケーションの痕跡がすべて失われた後も、数十年後には回復可能な可能性が高くなります。データはコードよりも長生きします。</target>
        </trans-unit>
        <trans-unit id="2d4a0281b46f5532a617239a67837a43f539390e" translate="yes" xml:space="preserve">
          <source>Contentless FTS4 tables also support SELECT statements. However, it is an error to attempt to retrieve the value of any table column other than the docid column. The auxiliary function matchinfo() may be used, but snippet() and offsets() may not. For example:</source>
          <target state="translated">Contentless FTS4テーブルはSELECT文もサポートしています。しかし、docidカラム以外のテーブルカラムの値を取得しようとするとエラーになります。補助関数 matchinfo()は使用できますが、snippet()と offsets()は使用できません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="466e0c80c6a0ee6d90e9a1cf84c5c7f81c6af7ec" translate="yes" xml:space="preserve">
          <source>Contentless FTS5 tables do not support UPDATE or DELETE statements, or INSERT statements that do not supply a non-NULL value for the rowid field. Contentless tables do not support REPLACE conflict handling. REPLACE and INSERT OR REPLACE statements are treated as regular INSERT statements. Rows may be deleted from a contentless table using an &lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5 delete command&lt;/a&gt;.</source>
          <target state="translated">コンテンツレスFTS5テーブルは、UPDATEまたはDELETEステートメント、またはROWIDフィールドにNULL以外の値を提供しないINSERTステートメントをサポートしません。コンテンツのないテーブルは、REPLACE競合処理をサポートしていません。REPLACEおよびINSERT OR REPLACEステートメントは、通常のINSERTステートメントとして扱われます。&lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5削除コマンド&lt;/a&gt;を使用して、コンテンツのないテーブルから行を削除できます。</target>
        </trans-unit>
        <trans-unit id="450f660f2dc175257d82b71bd1a3662299271f61" translate="yes" xml:space="preserve">
          <source>Contentless fts4 tables</source>
          <target state="translated">内容のないfts4テーブル</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="38c62e79a8a690e9f86401a7b90826fac3d70fe4" translate="yes" xml:space="preserve">
          <source>Continuing enhancements and improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3の&lt;/a&gt;継続的な拡張と改善。</target>
        </trans-unit>
        <trans-unit id="2009f584db4b6762c01a87103a205a43fe3cb848" translate="yes" xml:space="preserve">
          <source>Continuing improvements to the test suite and fixes to obscure bugs and inconsistencies that the test suite improvements are uncovering.</source>
          <target state="translated">テストスイートの継続的な改善と、テストスイートの改善が明らかにしている不明瞭なバグや矛盾を修正します。</target>
        </trans-unit>
        <trans-unit id="1ca7bf3d67fb3020228ac37bd4bc93280daba832" translate="yes" xml:space="preserve">
          <source>Contrary to the intuition of many, &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; does not reset the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. Use this routine to reset all host parameters to NULL.</source>
          <target state="translated">多くの直感に反して、&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;は&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメントの&lt;/a&gt;&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;バインディング&lt;/a&gt;をリセットしません。このルーチンを使用して、すべてのホストパラメータをNULLにリセットします。</target>
        </trans-unit>
        <trans-unit id="cdcbd7d39f460823aca9b9fc7f28e86a6837fad5" translate="yes" xml:space="preserve">
          <source>Contrary to the intuition of many, &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; does not reset the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; on a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. Use this routine to reset all host parameters to NULL.</source>
          <target state="translated">多くの直感に反して、&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;は&lt;a href=&quot;stmt&quot;&gt;準備されたステートメントの&lt;/a&gt;&lt;a href=&quot;bind_blob&quot;&gt;バインディング&lt;/a&gt;をリセットしません。このルーチンを使用して、すべてのホストパラメータをNULLにリセットします。</target>
        </trans-unit>
        <trans-unit id="56e3d51f494e6dd366ee62fae61ac03a93a7f2a3" translate="yes" xml:space="preserve">
          <source>Controlling Depth-First Versus Breadth-First Search Of a Tree Using ORDER BY</source>
          <target state="translated">ORDER BYによる木の深さ優先検索と幅優先検索の制御</target>
        </trans-unit>
        <trans-unit id="ea782105450bbc3723c1b76880caef4ed08032a7" translate="yes" xml:space="preserve">
          <source>Convenience Routines For Running Queries</source>
          <target state="translated">クエリーを実行するための便利なルーチン</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="5e7d5a98bcc47f452d8a4ce28a7202d2ed515e6c" translate="yes" xml:space="preserve">
          <source>Conversion Processing</source>
          <target state="translated">変換処理</target>
        </trans-unit>
        <trans-unit id="d77ae256c17778b6b22cdb6d26f46c01f50b1386" translate="yes" xml:space="preserve">
          <source>Conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer references will have been modified. Other kinds of conversion are done in place when it is possible, but sometimes they are not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">UTF-16be と UTF-16le 間の変換は常にその場で行われ、先行ポ イ ン タ ーは無効にはなりません。他の種類の変換は可能な場合にはその場で行われますが、可能でない場合もあり、その場合は先行ポインタが無効になります。</target>
        </trans-unit>
        <trans-unit id="8527a14f28507a486e3c2038fa5167e707f4acec" translate="yes" xml:space="preserve">
          <source>Convert P2 registers beginning with P1 into the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; use as a data record in a database table or as a key in an index. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode can decode the record later.</source>
          <target state="translated">P1で始まるP2レジスタを&lt;a href=&quot;fileformat2#record_format&quot;&gt;レコード形式に&lt;/a&gt;変換し、データベーステーブルのデータレコードとして、またはインデックスのキーとして使用します。&lt;a href=&quot;opcode#Column&quot;&gt;列の&lt;/a&gt;オペコードは、後にレコードをデコードすることができます。</target>
        </trans-unit>
        <trans-unit id="6110d61a4f0b93f4f1786cc181b877ffbc07b6f5" translate="yes" xml:space="preserve">
          <source>Convert all &quot;&lt;code&gt;#&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;%23&lt;/code&gt;&quot;.</source>
          <target state="translated">すべての「 &lt;code&gt;#&lt;/code&gt; 」文字を「 &lt;code&gt;%23&lt;/code&gt; 」に変換します。</target>
        </trans-unit>
        <trans-unit id="cb7da03590965d6f39aa9b4cc1a3abd9c78729ec" translate="yes" xml:space="preserve">
          <source>Convert all &quot;&lt;code&gt;?&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;%3f&lt;/code&gt;&quot;.</source>
          <target state="translated">すべての「 &lt;code&gt;?&lt;/code&gt; 」文字を「 &lt;code&gt;%3f&lt;/code&gt; 」に変換します。</target>
        </trans-unit>
        <trans-unit id="aba96b2a30818bbfb1c821c9fb2ff8c5dd760ffc" translate="yes" xml:space="preserve">
          <source>Convert all sequences of two or more &quot;&lt;code&gt;/&lt;/code&gt;&quot; characters into a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">2以上「のすべてのシーケンスに変換 &lt;code&gt;/&lt;/code&gt; シングル」へ「の文字を &lt;code&gt;/&lt;/code&gt; 」文字。</target>
        </trans-unit>
        <trans-unit id="9218bd4afe759364703b183410a2dc13af3bfd80" translate="yes" xml:space="preserve">
          <source>Convert array constants in the code to have type &quot;const&quot;.</source>
          <target state="translated">コード内の配列定数を &quot;const&quot; 型に変換します。</target>
        </trans-unit>
        <trans-unit id="efad9a1cd6300f3155adba4fdbf6f2272fac9217" translate="yes" xml:space="preserve">
          <source>Convert from integer to float</source>
          <target state="translated">整数から浮動小数点への変換</target>
        </trans-unit>
        <trans-unit id="2d1e75be417c65c8d6a61a4be607d4baf9fd907e" translate="yes" xml:space="preserve">
          <source>Convert the underlying virtual machine to be a register-based machine rather than a stack-based machine. The only user-visible change is in the output of EXPLAIN.</source>
          <target state="translated">基礎となる仮想マシンをスタックベースのマシンではなくレジスタベースのマシンに変換します。ユーザから見える変更は、EXPLAINの出力のみです。</target>
        </trans-unit>
        <trans-unit id="293e7888094e60e7ae942b34aacf8692de6ac28c" translate="yes" xml:space="preserve">
          <source>Convert to the new website: http://www.sqlite.org/</source>
          <target state="translated">新しいウェブサイトに変換:http://www.sqlite.org/</target>
        </trans-unit>
        <trans-unit id="af74f7c5362aaee985bf8cda3dd75fc80751ce51" translate="yes" xml:space="preserve">
          <source>Copy</source>
          <target state="translated">Copy</target>
        </trans-unit>
        <trans-unit id="62e344ae607b939275b619f121fe73746c0c7f9a" translate="yes" xml:space="preserve">
          <source>Copy And Free SQL Values</source>
          <target state="translated">コピーとフリーSQL値</target>
        </trans-unit>
        <trans-unit id="2a054004f4716fcfdd66797784227739af6ae2e6" translate="yes" xml:space="preserve">
          <source>Copy data</source>
          <target state="translated">コピーデータ</target>
        </trans-unit>
        <trans-unit id="a8edd5c34da27f929be29297a3e1a0b2b7d510c9" translate="yes" xml:space="preserve">
          <source>Copy the contents of all</source>
          <target state="translated">すべての内容をコピーします。</target>
        </trans-unit>
        <trans-unit id="206ba42d17a054137e160f699cf45b4c2254d889" translate="yes" xml:space="preserve">
          <source>Copy the database file using an external tool (for example the unix 'cp' utility or the DOS 'copy' command).</source>
          <target state="translated">外部ツールを使ってデータベースファイルをコピーします(例えば、Unixの'cp'ユーティリティやDOSの'copy'コマンドなど)。</target>
        </trans-unit>
        <trans-unit id="c901be66df5ef99ab4f24023bacf5da468cc8855" translate="yes" xml:space="preserve">
          <source>Copying a database file without also copying its journal.</source>
          <target state="translated">ジャーナルもコピーせずにデータベースファイルをコピーする。</target>
        </trans-unit>
        <trans-unit id="9a851d1cd68948a591dc0c34333564d39d950b93" translate="yes" xml:space="preserve">
          <source>Copyright on all code was disclaimed. The library is now in the public domain.</source>
          <target state="translated">すべてのコードの著作権は放棄されました。ライブラリーはパブリックドメインになりました。</target>
        </trans-unit>
        <trans-unit id="3bc488c7530d4abc0197fb3c29656e9202c9e37f" translate="yes" xml:space="preserve">
          <source>Core Functions</source>
          <target state="translated">コア機能</target>
        </trans-unit>
        <trans-unit id="c93aea3a25070916d94552b3271d6e2cb60ffbf1" translate="yes" xml:space="preserve">
          <source>Core URI query parameters</source>
          <target state="translated">コア URI クエリパラメータ</target>
        </trans-unit>
        <trans-unit id="48e09e45c570a5fc20d51a90faf1c88a9a965b16" translate="yes" xml:space="preserve">
          <source>Correct</source>
          <target state="translated">Correct</target>
        </trans-unit>
        <trans-unit id="ab43f5950b771276d5096eea017224ae40627bd3" translate="yes" xml:space="preserve">
          <source>Correct affinity computations for a SELECT on the RHS of an IN operator. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/199df4168c&quot;&gt;199df4168c&lt;/a&gt;.</source>
          <target state="translated">IN演算子のRHSでのSELECTの類似性計算を修正しました。チケット&lt;a href=&quot;https://sqlite.org/src/info/199df4168c&quot;&gt;199df4168cの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="0a9b4eee2570183dd2ddac6a6366a16f57f34e60" translate="yes" xml:space="preserve">
          <source>Correct column meta-information returned for aggregate queries</source>
          <target state="translated">集計クエリで返された正しい列のメタ情報</target>
        </trans-unit>
        <trans-unit id="27273ddb3178ccf762d7085c22704a1fb0549237" translate="yes" xml:space="preserve">
          <source>Correct handling of columns with redundant unique indexes when those columns are used on the LHS of an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/0eab1ac759&quot;&gt;0eab1ac759&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN演算子の&lt;/a&gt; LHSで列が使用されている場合に、重複しない一意のインデックスを持つ列の正しい処理。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/0eab1ac759&quot;&gt;0eab1ac759の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="cfd7a02e00c8b2f225f8799044d14f56f7302d29" translate="yes" xml:space="preserve">
          <source>Correct handling of integers in SQL expressions that are larger than what can be represented by the machine integer.</source>
          <target state="translated">マシン整数で表現できるものよりも大きい整数をSQL式で正しく処理するようになりました。</target>
        </trans-unit>
        <trans-unit id="cd691a2e765f41b11a9cf96cd3df086682295d23" translate="yes" xml:space="preserve">
          <source>Correct miscounts in the sqlite3_analyzer.exe utility related to WITHOUT ROWID tables.</source>
          <target state="translated">WITHOUT ROWIDテーブルに関連するsqlite3_analyzer.exeユーティリティのミスカウントを修正しました。</target>
        </trans-unit>
        <trans-unit id="4bfdca133fa3a4141a30355604a149499e687b80" translate="yes" xml:space="preserve">
          <source>Correctly compute a LEFT OUTER JOINs that is constrained on the left table only</source>
          <target state="translated">左テーブルのみに制約のあるLEFT OUTER JOINsを正しく計算します。</target>
        </trans-unit>
        <trans-unit id="ad24fffac831d94ed1f6d73e123b29057262887e" translate="yes" xml:space="preserve">
          <source>Correctly handle NULL filenames in ATTACH and DETACH</source>
          <target state="translated">ATTACHおよびDETACHでNULLファイル名を正しく扱う</target>
        </trans-unit>
        <trans-unit id="f488953bdefc614e6154ab271713b957ab57b302" translate="yes" xml:space="preserve">
          <source>Correctly handle comparisons between an INTEGER PRIMARY KEY and a floating point number.</source>
          <target state="translated">INTEGER PRIMARY KEYと浮動小数点数の比較を正しく処理します。</target>
        </trans-unit>
        <trans-unit id="35c4ec0c87f0e558ee367fb68087e03066aab5fb" translate="yes" xml:space="preserve">
          <source>Correctly handle quoted names in CREATE INDEX statements.</source>
          <target state="translated">CREATE INDEX文で引用符で囲まれた名前を正しく処理します。</target>
        </trans-unit>
        <trans-unit id="352dc237e245240eb4ea083bad4ff8dfb11f6950" translate="yes" xml:space="preserve">
          <source>Correctly handle the integer literal -0x8000000000000000 in the query planner.</source>
          <target state="translated">クエリプランナで整数リテラル -0x8000000000000000 を正しく処理します。</target>
        </trans-unit>
        <trans-unit id="88e07d9ff26fe66b408e72d9ac5048ccb06e2c58" translate="yes" xml:space="preserve">
          <source>Correctly interpret negative &quot;PRAGMA cache_size&quot; values when determining the cache size used for sorting large amounts of data.</source>
          <target state="translated">大量のデータをソートするために使用されるキャッシュサイズを決定する際に、負の「PRAGMA cache_size」値を正しく解釈するようにしました。</target>
        </trans-unit>
        <trans-unit id="ee9849f5daa0323fb5d424718df3f8368eafb771" translate="yes" xml:space="preserve">
          <source>Correlated Subqueries</source>
          <target state="translated">関連する副次式</target>
        </trans-unit>
        <trans-unit id="f13b587e5391fe217559af3492527b67d6307d3d" translate="yes" xml:space="preserve">
          <source>Correlated subqueries</source>
          <target state="translated">関連する副問い合わせ</target>
        </trans-unit>
        <trans-unit id="44355aa8b49da824d97a083ad2a8a3860b7b6f30" translate="yes" xml:space="preserve">
          <source>Corresponds to a puzzle like this:</source>
          <target state="translated">こんなパズルに対応しています。</target>
        </trans-unit>
        <trans-unit id="9de7bd4ef28516474c07432e4cafa11ec15920ae" translate="yes" xml:space="preserve">
          <source>Corruption to the underlying SQLite database file. (See documentation on &lt;a href=&quot;howtocorrupt&quot;&gt;how to corrupt&lt;/a&gt; and SQLite database for additional information.)</source>
          <target state="translated">基になるSQLiteデータベースファイルの破損。（詳細については、SQLiteデータベースの&lt;a href=&quot;howtocorrupt&quot;&gt;破損方法&lt;/a&gt;に関するドキュメントを参照してください。）</target>
        </trans-unit>
        <trans-unit id="66e12969c225cc6d65e18210488acb826eba907e" translate="yes" xml:space="preserve">
          <source>Count</source>
          <target state="translated">Count</target>
        </trans-unit>
        <trans-unit id="0939fecded0f0c9d546d71641c3908e28d8f44d4" translate="yes" xml:space="preserve">
          <source>Count The Number Of Rows Modified</source>
          <target state="translated">変更された行の数をカウントする</target>
        </trans-unit>
        <trans-unit id="2b8bef37451c2cbce07a23488203e5542d9f4dd1" translate="yes" xml:space="preserve">
          <source>Count the number of CPU cycles consumed using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;を使用して消費されたCPUサイクルの数をカウントします。</target>
        </trans-unit>
        <trans-unit id="49d2ca2c89047e9021ce54796bb5abdb2fd3bc0c" translate="yes" xml:space="preserve">
          <source>Countless bug fixes</source>
          <target state="translated">無数のバグ修正</target>
        </trans-unit>
        <trans-unit id="00252cf377dd27368f8326fbe29b91bd69acc82e" translate="yes" xml:space="preserve">
          <source>Countless minor bug fixes, documentation improvements, new and improved test cases, and code simplifications and cleanups.</source>
          <target state="translated">数え切れないほどのマイナーなバグ修正、ドキュメントの改善、新しいテストケースや改善されたテストケース、コードの簡素化とクリーンアップ。</target>
        </trans-unit>
        <trans-unit id="30106347ab7dfc885850c282c1789d99c22c045f" translate="yes" xml:space="preserve">
          <source>Coverage Testing</source>
          <target state="translated">カバレッジテスト</target>
        </trans-unit>
        <trans-unit id="1c7ccdf4836b4b91d53aaf066e241e1e63bcb54a" translate="yes" xml:space="preserve">
          <source>Covering indexes</source>
          <target state="translated">カバリングインデックス</target>
        </trans-unit>
        <trans-unit id="cf43e93921ba031c40cac261f4d24c6115ca0a3e" translate="yes" xml:space="preserve">
          <source>Covering indices</source>
          <target state="translated">インデックスをカバーする</target>
        </trans-unit>
        <trans-unit id="ba58feb4df54a21eed20b23d82daa39d2f414cf2" translate="yes" xml:space="preserve">
          <source>Crash and power loss tests</source>
          <target state="translated">衝突および電力損失試験</target>
        </trans-unit>
        <trans-unit id="d1e3f610852d10da5d8935701b8e1938e2ea49d4" translate="yes" xml:space="preserve">
          <source>Crash testing seeks to demonstrate that an SQLite database will not go corrupt if the application or operating system crashes or if there is a power failure in the middle of a database update. A separate white-paper titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit in SQLite&lt;/a&gt; describes the defensive measure SQLite takes to prevent database corruption following a crash. Crash tests strive to verify that those defensive measures are working correctly.</source>
          <target state="translated">クラッシュテストは、アプリケーションやオペレーティングシステムがクラッシュした場合、またはデータベースの更新中に電源障害が発生した場合に、SQLiteデータベースが破損しないことを実証することを目的としています。&lt;a href=&quot;atomiccommit&quot;&gt;SQLiteのAtomic Commit&lt;/a&gt;というタイトルの別のホワイトペーパーでは、クラッシュ後のデータベースの破損を防ぐためにSQLiteがとる防御策について説明しています。クラッシュテストでは、これらの防御策が正しく機能していることを確認するよう努めています。</target>
        </trans-unit>
        <trans-unit id="a6531b5d9a390a38e977f855630c550e6d918ac6" translate="yes" xml:space="preserve">
          <source>Crash tests in SQLite use a modified VFS that can simulate the kinds of filesystem damage that occur during a power loss or operating system crash. The crash-test VFS can simulate incomplete sector writes, pages filled with garbage data because a write has not completed, and out of order writes, all occurring at varying points during a test scenario. Crash tests execute transactions over and over, varying the time at which a simulated power loss occurs and the properties of the damage inflicted. Each test then reopens the database after the simulated crash and verifies that the transaction either occurred completely or not at all and that the database is in a completely consistent state.</source>
          <target state="translated">SQLite のクラッシュテストでは、停電やオペレーティングシステムのクラッシュ時に発生するファイルシステムの損傷をシミュレートするために、修正された VFS を使用しています。クラッシュテスト用のVFSは、不完全なセクタ書き込み、書き込みが完了していないためにガベージデータでいっぱいになったページ、順番外の書き込みなど、テストシナリオ中のさまざまなポイントで発生するすべての現象をシミュレートすることができます。クラッシュテストでは、シミュレーションされた停電が発生する時間と、与えられるダメージの特性を変化させながら、何度も何度もトランザクションを実行します。各テストでは、シミュレーションされたクラッシュの後にデータベースを再オープンし、トランザクションが完全に発生したか、全く発生していないか、データベースが完全に一貫した状態にあるかを検証します。</target>
        </trans-unit>
        <trans-unit id="b3391e1c037afbc39bd6f7690619a52ba958e865" translate="yes" xml:space="preserve">
          <source>Crash when calling undocumented SQL function sqlite_rename_parent() with NULL parameters. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/264b970c4379fd&quot;&gt;264b970c43&lt;/a&gt;</source>
          <target state="translated">ドキュメントに記載されていないSQL関数sqlite_rename_parent（）をNULLパラメータで呼び出すとクラッシュする。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/264b970c4379fd&quot;&gt;264b970c43&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbedd1aa577cfa78e4159988e6015e4a622476e7" translate="yes" xml:space="preserve">
          <source>Create A New Changegroup Object</source>
          <target state="translated">新しい変更グループオブジェクトの作成</target>
        </trans-unit>
        <trans-unit id="0eb8a02be6b191c11fc9bb259dafebba87dc4f53" translate="yes" xml:space="preserve">
          <source>Create A New Database</source>
          <target state="translated">新しいデータベースの作成</target>
        </trans-unit>
        <trans-unit id="49b9f541df9267a1e81a2e1318c39164b9049cf8" translate="yes" xml:space="preserve">
          <source>Create A New Dynamic String Object</source>
          <target state="translated">新しい動的文字列オブジェクトの作成</target>
        </trans-unit>
        <trans-unit id="b6fb0a01eeb8fbfa08db1af0e99f321400dca595" translate="yes" xml:space="preserve">
          <source>Create A New Session Object</source>
          <target state="translated">新しいセッションオブジェクトの作成</target>
        </trans-unit>
        <trans-unit id="b8c295ec5c8d9e2d803be8b00c7291210939416a" translate="yes" xml:space="preserve">
          <source>Create An Iterator To Traverse A Changeset</source>
          <target state="translated">変更セットをトラバースするためのイテレータの作成</target>
        </trans-unit>
        <trans-unit id="f738b7c71ee4fcfa212cb684acc179c459d0f67c" translate="yes" xml:space="preserve">
          <source>Create Or Redefine SQL Functions</source>
          <target state="translated">SQL関数の作成または再定義</target>
        </trans-unit>
        <trans-unit id="fd00ea9a768424e224cb5c7effdeb94d4b4041fe" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;を使用して&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="f9c0f9f8f5c2a818fac05ebd0144409b195c2755" translate="yes" xml:space="preserve">
          <source>Create a Makefile as described in &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;howtocompile&quot;&gt;How to Compile SQLiteの&lt;/a&gt;説明に従ってMakefileを作成します。</target>
        </trans-unit>
        <trans-unit id="340fd5cb0d944699f9f2262601f8e8515f6277c0" translate="yes" xml:space="preserve">
          <source>Create a background thread to perform write operations and call sqlite3async_run().</source>
          <target state="translated">書き込み操作を行うためのバックグラウンドスレッドを作成し、sqlite3async_run()を呼び出します。</target>
        </trans-unit>
        <trans-unit id="af7db7815d1cb1d51e5af0cd7f358563250421b6" translate="yes" xml:space="preserve">
          <source>Create a changeset rebaser object</source>
          <target state="translated">チェンジセットリベイザーオブジェクトの作成</target>
        </trans-unit>
        <trans-unit id="08a7eb180eb01b1b848907571f8cab91fa3fadc5" translate="yes" xml:space="preserve">
          <source>Create a changeset rebaser object.</source>
          <target state="translated">チェンジセットリベイザーオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="43d32b083ccd73d48458a8a788df239ec0749647" translate="yes" xml:space="preserve">
          <source>Create a fossil repository to host the private branch using the following command:</source>
          <target state="translated">以下のコマンドを使用して、プライベートブランチをホストする化石リポジトリを作成します。</target>
        </trans-unit>
        <trans-unit id="020976ba5dc8b4a36c10d54c801ec1a4a89f48ac" translate="yes" xml:space="preserve">
          <source>Create a master-journal. The name of the master-journal is arbitrary. (The current implementation appends random suffixes to the name of the main database file until it finds a name that does not previously exist.) Fill the master journal with the names of all the individual journals and flush its contents to disk.</source>
          <target state="translated">マスタージャーナルを作成します。マスタージャーナルの名前は任意です。(現在の実装では、これまでに存在しなかった名前が見つかるまで、メインデータベースファイルの名前にランダムな接尾辞を追加します)。マスタージャーナルをすべての個々のジャーナルの名前で埋め、その内容をディスクにフラッシュします。</target>
        </trans-unit>
        <trans-unit id="da3af537bba9d7121766b2210dfaab8be2fac3f3" translate="yes" xml:space="preserve">
          <source>Create a new archive containing specified files.</source>
          <target state="translated">指定したファイルを含む新規アーカイブを作成します。</target>
        </trans-unit>
        <trans-unit id="afef83edf1b36bb49d450af9b70529ceb53e63d8" translate="yes" xml:space="preserve">
          <source>Create a new archive, overwriting any existing archive (either in the current &quot;main&quot; db or in the file specified by a --file option). Each argument following the options is a file to add to the archive. Directories are imported recursively. See above for examples.</source>
          <target state="translated">既存のアーカイブを上書きして、新しいアーカイブを作成します(現在の &quot;main &quot;dbにあるか、--fileオプションで指定したファイルにあるかのいずれか)。オプションに続く各引数は、アーカイブに追加するファイルです。ディレクトリは再帰的にインポートされます。例については上記を参照してください。</target>
        </trans-unit>
        <trans-unit id="6c399fd2512bbe2d0e4a05efd898526951d10b8a" translate="yes" xml:space="preserve">
          <source>Create a new session object attached to database handle db. If successful, a pointer to the new object is written to *ppSession and SQLITE_OK is returned. If an error occurs, *ppSession is set to NULL and an SQLite error code (e.g. SQLITE_NOMEM) is returned.</source>
          <target state="translated">データベースハンドルdbにアタッチされた新しいセッションオブジェクトを作成します。成功した場合、新しいオブジェクトへのポインタが *ppSession に書き込まれ、SQLITE_OK が返されます。エラーが発生した場合、*ppSessionはNULLに設定され、SQLiteエラーコード(例:SQLITE_NOMEM)が返されます。</target>
        </trans-unit>
        <trans-unit id="7ef7c8e6020507b3b903b737530a1a743ade6fb2" translate="yes" xml:space="preserve">
          <source>Create a partial index by adding a WHERE clause to the end of an ordinary &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement.</source>
          <target state="translated">通常の&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントの最後にWHERE句を追加して、部分インデックスを作成します。</target>
        </trans-unit>
        <trans-unit id="7044aef02f57d684bf1ace2c33f2aa3769b845ad" translate="yes" xml:space="preserve">
          <source>Create a static and constant &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object containing pointers to the methods from the previous step.</source>
          <target state="translated">前の手順のメソッドへのポインターを含む静的で定数の&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="ce77c2b32feacc25a54f9d8046773c75cc6d0f0f" translate="yes" xml:space="preserve">
          <source>Create an instance of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure containing pointers to all the methods from step 1.</source>
          <target state="translated">手順1のすべてのメソッドへのポインターを含む&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;構造のインスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="0a8ad313a3f6f92e33200837c1d1b7d9a66475fb" translate="yes" xml:space="preserve">
          <source>Create an iterator used to iterate through the contents of a changeset. If successful, *pp is set to point to the iterator handle and SQLITE_OK is returned. Otherwise, if an error occurs, *pp is set to zero and an SQLite error code is returned.</source>
          <target state="translated">チェンジセットの内容を反復処理するために使用されるイテレータを作成します。成功した場合、*pp はイテレータハンドルを指すように設定され、SQLITE_OK が返されます。そうでなければ、エラーが発生した場合、*pp はゼロに設定され、SQLite エラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="f282c6f0dcaa864a9b91c1b0857728fb4f3b6cf7" translate="yes" xml:space="preserve">
          <source>Create if does not exist?</source>
          <target state="translated">存在しない場合に作成しますか?</target>
        </trans-unit>
        <trans-unit id="a6746bd3f5b981be1960788a63b361beb206e80d" translate="yes" xml:space="preserve">
          <source>Create new table</source>
          <target state="translated">新規テーブルの作成</target>
        </trans-unit>
        <trans-unit id="552737e86fdab069e1553393c32b2d735d03da2b" translate="yes" xml:space="preserve">
          <source>Create the prepared statement object using &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;を使用して、準備済みステートメントオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="b3aaf4f3bc8aa8975fba3c24e7982e7ad410e2d3" translate="yes" xml:space="preserve">
          <source>Create the prepared statement object using &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;を使用して、準備済みステートメントオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="b6cd0fb8dc0636107f3c2eeec94775a363db607d" translate="yes" xml:space="preserve">
          <source>CreateBtree</source>
          <target state="translated">CreateBtree</target>
        </trans-unit>
        <trans-unit id="f6d526ccd323387bacc30fe97239e7bfe08e6f7e" translate="yes" xml:space="preserve">
          <source>Created a new mutex subsystem and made it replicable at compile-time.</source>
          <target state="translated">新しいミューテックスサブシステムを作成し、コンパイル時に複製可能にしました。</target>
        </trans-unit>
        <trans-unit id="015db039081a96e714bbc870bb70163882fcd0ef" translate="yes" xml:space="preserve">
          <source>Created the &lt;a href=&quot;dbhash&quot;&gt;dbhash.exe&lt;/a&gt; command-line utility.</source>
          <target state="translated">&lt;a href=&quot;dbhash&quot;&gt;dbhash.exe&lt;/a&gt;コマンドラインユーティリティを作成しました。</target>
        </trans-unit>
        <trans-unit id="acf789d2331ea2a8bf5399f72dadd8b178eecbe4" translate="yes" xml:space="preserve">
          <source>Creation of a transient imposter table involves a special &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; call. Unlike all other SQLite APIs, &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface is subject to incompatible changes from one release to the next, and so the mechanism described below is not guaranteed to work in future releases of SQLite. The SQLite developers do not consider this a problem because imposter tables should not be used in applications. Imposter tables are for analysis and testing use only.</source>
          <target state="translated">一時的な詐称者テーブルの作成には、特別な&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;呼び出しが含まれます。他のすべてのSQLite APIとは異なり、&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;インターフェースはリリースごとに互換性のない変更の影響を受けるため、以下で説明するメカニズムはSQLiteの将来のリリースでの動作が保証されていません。SQLite開発者は、偽のテーブルをアプリケーションで使用してはならないため、これを問題とは見なしません。Imposterテーブルは、分析およびテスト専用です。</target>
        </trans-unit>
        <trans-unit id="bfac50d6424b5166c3ee2808c85ae7c139b5182f" translate="yes" xml:space="preserve">
          <source>Credits</source>
          <target state="translated">Credits</target>
        </trans-unit>
        <trans-unit id="f3072cfe38995c94aede1e379bdbc87872e32b2e" translate="yes" xml:space="preserve">
          <source>Cross-Platform</source>
          <target state="translated">Cross-Platform</target>
        </trans-unit>
        <trans-unit id="a84c73487927d0c8de6b6f553d91f81e8f3c67ef" translate="yes" xml:space="preserve">
          <source>Cross-platform: Android, *BSD, iOS, Linux, Mac, Solaris, VxWorks, and Windows (Win32, WinCE, WinRT) are supported out of the box. Easy to port to other systems.</source>
          <target state="translated">クロスプラットフォーム対応。Android、*BSD、iOS、Linux、Mac、Solaris、VxWorks、Windows(Win32、WinCE、WinRT)に対応しています。他のシステムへの移植が容易。</target>
        </trans-unit>
        <trans-unit id="fe50f9415f0538595ee673bee95f6e9b7af30913" translate="yes" xml:space="preserve">
          <source>Currently the asynchronous IO extension is compatible with win32 systems and systems that support the pthreads interface, including Mac OS X, Linux, and other varieties of Unix.</source>
          <target state="translated">現在のところ、非同期 IO 拡張は、win32 システムと、Mac OS X、Linux、および他の Unix の他の種類を含む pthreads インターフェイスをサポートするシステムと互換性があります。</target>
        </trans-unit>
        <trans-unit id="5527dcef9928e4b30b2e113bf906b6aad70626b4" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 contains any NULL value, jump immediately to P2. If all terms of the record are not-NULL then a check is done to determine if any row in the P1 index btree has a matching key prefix. If there are no matches, jump immediately to P2. If there is a match, fall through and leave the P1 cursor pointing to the matching row.</source>
          <target state="translated">カーソルP1はインデックスbtree上にある。P3とP4で識別されたレコードにNULL値が含まれている場合、直ちにP2にジャンプします。レコードの全ての項がNULLでない場合は、P1のインデックス・ツリーの中に一致するキー接頭辞を持つ行があるかどうかをチェックします。一致するものがなければ、すぐにP2にジャンプします。一致するものがあれば、P1カーソルは一致する行を指したままにしておきます。</target>
        </trans-unit>
        <trans-unit id="d32c868a8066f0bb0c8cbc2fdacd1dcc4df55aff" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 is a prefix of any entry in P1 then a jump is made to P2 and P1 is left pointing at the matching entry.</source>
          <target state="translated">カーソルP1はインデックスbtree上にある。P3とP4で識別されたレコードがP1のいずれかのエントリの接頭辞である場合、P2にジャンプし、P1は一致するエントリを指したままになります。</target>
        </trans-unit>
        <trans-unit id="e4499a408e8cf9ba0a64b6a7abae32a3e8598a9c" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 is not the prefix of any entry in P1 then a jump is made to P2. If P1 does contain an entry whose prefix matches the P3/P4 record then control falls through to the next instruction and P1 is left pointing at the matching entry.</source>
          <target state="translated">カーソルP1はインデックスbtree上にある。P3とP4で識別されたレコードがP1のどのエントリの接頭辞でもない場合、P2にジャンプします。もしP1にP3/P4レコードの接頭辞が一致するエントリがあれば、制御は次の命令に移り、P1は一致するエントリを指したままになります。</target>
        </trans-unit>
        <trans-unit id="cce417cb09cb0e87ed39f345b9827448814078c5" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the seekHit flag is set on P1, then this opcode is a no-op. But if the seekHit flag of P1 is clear, then check to see if there is any entry in P1 that matches the prefix identified by P3 and P4. If no entry matches the prefix, jump to P2. Otherwise fall through.</source>
          <target state="translated">カーソル P1 はインデックス btree 上にある。P1のseekHitフラグがセットされている場合、このオペコードはノーオペである。しかし、P1のseekHitフラグがクリアされている場合は、P1にP3とP4で識別された接頭辞に一致するエントリがあるかどうかをチェックする。プレフィックスに一致するエントリがなければ、P2にジャンプする。そうでなければフォールスルーする。</target>
        </trans-unit>
        <trans-unit id="22ec5d401662b5703126ca0123e136b6c810e79d" translate="yes" xml:space="preserve">
          <source>CursorHint</source>
          <target state="translated">CursorHint</target>
        </trans-unit>
        <trans-unit id="836bce7485bd48ef5bf35926e3fb08781cfcdae7" translate="yes" xml:space="preserve">
          <source>Custom Builds Of SQLite</source>
          <target state="translated">SQLite のカスタムビルド</target>
        </trans-unit>
        <trans-unit id="dfcc51a98311f46893672f2fb6d173d44d66fc77" translate="yes" xml:space="preserve">
          <source>Custom Page Cache Object</source>
          <target state="translated">カスタム ページ キャッシュ オブジェクト</target>
        </trans-unit>
        <trans-unit id="076c8e2f21c1b5d23882403c8926d30c1101585d" translate="yes" xml:space="preserve">
          <source>Custom auxiliary functions</source>
          <target state="translated">カスタム補助機能</target>
        </trans-unit>
        <trans-unit id="c77373601428abf208eee7bad389ec98739fcb31" translate="yes" xml:space="preserve">
          <source>Custom r-tree queries</source>
          <target state="translated">カスタム r-tree クエリ</target>
        </trans-unit>
        <trans-unit id="7057308b175a54061ae194ee69576ebf4bb75f55" translate="yes" xml:space="preserve">
          <source>Custom tokenizers</source>
          <target state="translated">カスタム トークナイザー</target>
        </trans-unit>
        <trans-unit id="c9cb8f8539741bdce4da7c0edbda58f7c8a5bb30" translate="yes" xml:space="preserve">
          <source>Custom tokenizers may also support synonyms. Consider a case in which a user wishes to query for a phrase such as &quot;first place&quot;. Using the built-in tokenizers, the FTS5 query 'first + place' will match instances of &quot;first place&quot; within the document set, but not alternative forms such as &quot;1st place&quot;. In some applications, it would be better to match all instances of &quot;first place&quot; or &quot;1st place&quot; regardless of which form the user specified in the MATCH query text.</source>
          <target state="translated">カスタムトークナイザーは、同義語をサポートしている場合もあります。ユーザーが「first place」のようなフレーズを検索したい場合を考えてみましょう。組み込みのトークナイザーを使用すると、FTS5のクエリ「first+place」は、ドキュメントセット内の「first place」のインスタンスにはマッチしますが、「1st place」のような代替形式にはマッチしません。アプリケーションによっては、ユーザがMATCHクエリテキストで指定した形式に関係なく、&quot;first place &quot;または &quot;1st place &quot;のすべてのインスタンスをマッチさせた方が良い場合もあります。</target>
        </trans-unit>
        <trans-unit id="5ffd763a855efd9c913568b8cd20dab17c4af423" translate="yes" xml:space="preserve">
          <source>Cut over configuration management to a new CVS repository with its own CVSTrac bug tracking system.</source>
          <target state="translated">設定管理を、独自の CVSTrac バグ追跡システムを備えた新しい CVS リポジトリに移行します。</target>
        </trans-unit>
        <trans-unit id="fd5aaa888331e7fdbb9873b0f3118383cbd0f6f2" translate="yes" xml:space="preserve">
          <source>Cut-over to the &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt; for faster and better query plans.</source>
          <target state="translated">より高速で優れたクエリプランを実現するために、&lt;a href=&quot;queryplanner-ng&quot;&gt;次世代クエリプランナー&lt;/a&gt;に切り替えます。</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="339588e68f8e2dd5f57cc156ab01c5b4dcaa9da0" translate="yes" xml:space="preserve">
          <source>DATABASE</source>
          <target state="translated">DATABASE</target>
        </trans-unit>
        <trans-unit id="8c76abdec41a7652375d00f4bf05256b82c68494" translate="yes" xml:space="preserve">
          <source>DATE</source>
          <target state="translated">DATE</target>
        </trans-unit>
        <trans-unit id="6e915cae90d2c29f2358559dc05c3df58595f55d" translate="yes" xml:space="preserve">
          <source>DATETIME</source>
          <target state="translated">DATETIME</target>
        </trans-unit>
        <trans-unit id="e37624f858dc2af6156398ee78609c8c3c886ca3" translate="yes" xml:space="preserve">
          <source>DB2</source>
          <target state="translated">DB2</target>
        </trans-unit>
        <trans-unit id="645f10d83e7588e1eb33d0d2939905688a530e61" translate="yes" xml:space="preserve">
          <source>DB2, SQL Anywhere, and Borland Interbase do not allow NULLs in a UNIQUE column.</source>
          <target state="translated">DB2、SQL Anywhere、およびボーランド・インターベースでは、UNIQUE カラムでの NULL は許可されません。</target>
        </trans-unit>
        <trans-unit id="cbdd0b7d0c739234955599c5455d354e4fae19b3" translate="yes" xml:space="preserve">
          <source>DDDDDDDDDD</source>
          <target state="translated">DDDDDDDDDD</target>
        </trans-unit>
        <trans-unit id="3a98757f7ab109581d6b2954839e6421cda4bacd" translate="yes" xml:space="preserve">
          <source>DECIMAL(10,5)</source>
          <target state="translated">DECIMAL(10,5)</target>
        </trans-unit>
        <trans-unit id="c189207a55da45305c884fe2b50e086fcad4724b" translate="yes" xml:space="preserve">
          <source>DEFAULT</source>
          <target state="translated">DEFAULT</target>
        </trans-unit>
        <trans-unit id="b79011ba88d8043cebb3f51bd20a68d85873c9ee" translate="yes" xml:space="preserve">
          <source>DEFAULT VALUES&quot; form of the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement is not supported.</source>
          <target state="translated">&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;ステートメントのDEFAULT VALUES &quot;形式はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="eb9fe9e9d3e08f670bce95fe32d00c47dbc6b299" translate="yes" xml:space="preserve">
          <source>DEFERRABLE</source>
          <target state="translated">DEFERRABLE</target>
        </trans-unit>
        <trans-unit id="10f984f7d502771d13c63406af087a7b917fd1aa" translate="yes" xml:space="preserve">
          <source>DEFERRED</source>
          <target state="translated">DEFERRED</target>
        </trans-unit>
        <trans-unit id="5d0190695366a57cfee9ace793fdb8c89b47bb42" translate="yes" xml:space="preserve">
          <source>DEFERRED means that the transaction does not actually start until the database is first accessed. Internally, the BEGIN DEFERRRED statement merely sets a flag on the database connection that turns off the automatic commit that would normally occur when the last statement finishes. This causes the transaction that is automatically started to persist until an explicit COMMIT or ROLLBACK or until a rollback is provoked by an error or an ON CONFLICT ROLLBACK clause. If the first statement after BEGIN DEFERRED is a SELECT, then a read transaction is started. Subsequent write statements will upgrade the transaction to a write transaction if possible, or return SQLITE_BUSY. If the first statement after BEGIN DEFERRED is a write statement, then a write transaction is started.</source>
          <target state="translated">DEFERREDは、データベースに最初にアクセスされるまでトランザクションが実際に開始されないことを意味します。内部的には、BEGIN DEFERRRED文は単にデータベース接続にフラグを設定するだけで、最後の文が終了したときに通常発生する自動コミットをオフにします。これにより、明示的なCOMMITまたはROLLBACKが実行されるまで、またはエラーまたはON CONFLICT ROLLBACK句によってロールバックが誘発されるまで、自動的に開始されたトランザクションが持続するようになります。BEGIN DEFERREDの後の最初のステートメントがSELECTである場合、読み取りトランザクションが開始されます。それ以降の書き込み文は、可能であればそのトランザクションを書き込みトランザクションにアップグレードするか、SQLITE_BUSYを返します。BEGIN DEFERRED の後の最初の文が書き込み文の場合、書き込みトランザクションが開始されます。</target>
        </trans-unit>
        <trans-unit id="c44f0fc249bf9f56573cce35739bdbf358753ec9" translate="yes" xml:space="preserve">
          <source>DEFERRED, IMMEDIATE, and EXCLUSIVE transactions</source>
          <target state="translated">遅延、即時、および排他的な取引</target>
        </trans-unit>
        <trans-unit id="d6f5636098cd458ce9d22939f8e3e8deab0e9bd0" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="translated">DELETE</target>
        </trans-unit>
        <trans-unit id="ddf5a8b95a67a245ead92340f3a1d492b967db1c" translate="yes" xml:space="preserve">
          <source>DELETE Changes</source>
          <target state="translated">DELETE 変更点</target>
        </trans-unit>
        <trans-unit id="6d2d8ff5f66968f5a9016744e065d7b055778fa4" translate="yes" xml:space="preserve">
          <source>DELETE FROM t1;</source>
          <target state="translated">DELETE FROM t1.</target>
        </trans-unit>
        <trans-unit id="ee62fe04ef6c5b85e13e87e697e2bed7ca49475c" translate="yes" xml:space="preserve">
          <source>DELETE FROM t2 WHERE a&amp;gt;10 AND a&amp;lt;20000;</source>
          <target state="translated">t2から削除WHERE a&amp;gt; 10 AND a &amp;lt;20000;</target>
        </trans-unit>
        <trans-unit id="a5ebf9c0b02aa24303cdb7fb5cf5371c628bba2a" translate="yes" xml:space="preserve">
          <source>DELETE FROM t2 WHERE c LIKE '%fifty%';</source>
          <target state="translated">DELETE FROM t2 WHERE c LIKE '%fifty%'.</target>
        </trans-unit>
        <trans-unit id="b4aac6d0cf9ea3a89dec994c5ddb8ad46701ed40" translate="yes" xml:space="preserve">
          <source>DELETE records consist of the primary key fields only. The original values of other fields are omitted.</source>
          <target state="translated">DELETE レコードは、主キー・フィールドのみで構成されています。他のフィールドの元の値は省略されます。</target>
        </trans-unit>
        <trans-unit id="b5093023417eb749513563ec16d8c0c821aa5aff" translate="yes" xml:space="preserve">
          <source>DESC</source>
          <target state="translated">DESC</target>
        </trans-unit>
        <trans-unit id="a26814be2b9a9bc0d8c52b43abfaf6e5c82a51a4" translate="yes" xml:space="preserve">
          <source>DESC indices</source>
          <target state="translated">DESC指数</target>
        </trans-unit>
        <trans-unit id="c10fec47e3203a12a4865741f863a30dc8d9e348" translate="yes" xml:space="preserve">
          <source>DETACH</source>
          <target state="translated">DETACH</target>
        </trans-unit>
        <trans-unit id="53dda846085ef522df42849d527936da7055a14d" translate="yes" xml:space="preserve">
          <source>DETACH DATABASE</source>
          <target state="translated">DETACH DATABASE</target>
        </trans-unit>
        <trans-unit id="45b1a3f093ba639c208b0bbbbe6cad9eff65396f" translate="yes" xml:space="preserve">
          <source>DISTINCT</source>
          <target state="translated">DISTINCT</target>
        </trans-unit>
        <trans-unit id="3804145294052baefad623cd8cebfa752f431578" translate="yes" xml:space="preserve">
          <source>DISTINCT, ORDER BY, GROUP BY, HAVING, LIMIT, and OFFSET</source>
          <target state="translated">DISTINCT、ORDER BY、GROUP BY、HAVING、LIMIT、OFFSET</target>
        </trans-unit>
        <trans-unit id="8feb29077a1df95bd8e261f267cf55119b1eac74" translate="yes" xml:space="preserve">
          <source>DO</source>
          <target state="translated">DO</target>
        </trans-unit>
        <trans-unit id="9bf5aa462fedb77794614582aa9cb6f368384112" translate="yes" xml:space="preserve">
          <source>DOC - Word Perfect and Microsoft Office documents</source>
          <target state="translated">DOC-Word PerfectとMicrosoft Officeの文書</target>
        </trans-unit>
        <trans-unit id="097274c5c7abaa172853282efd2062239c4afe9d" translate="yes" xml:space="preserve">
          <source>DOUBLE</source>
          <target state="translated">DOUBLE</target>
        </trans-unit>
        <trans-unit id="0282a2e2726b5fdbd89b48e12c5edb38b5d2c29e" translate="yes" xml:space="preserve">
          <source>DOUBLE PRECISION</source>
          <target state="translated">ダブルプレシジョン</target>
        </trans-unit>
        <trans-unit id="39514a7a66f0433579dbc23ecfbb8c6c3e079395" translate="yes" xml:space="preserve">
          <source>DROP</source>
          <target state="translated">DROP</target>
        </trans-unit>
        <trans-unit id="383ac905b2bc5cb0e45bdf7ad063398c7f4d0280" translate="yes" xml:space="preserve">
          <source>DROP INDEX</source>
          <target state="translated">ドロップインデックス</target>
        </trans-unit>
        <trans-unit id="ac02c0b871c5f0a59ae432b32af6203946972208" translate="yes" xml:space="preserve">
          <source>DROP TABLE</source>
          <target state="translated">ドロップテーブル</target>
        </trans-unit>
        <trans-unit id="1627fd06710bbc68919d746def7dc2f189b53feb" translate="yes" xml:space="preserve">
          <source>DROP TABLE t1;</source>
          <target state="translated">DROP TABLE t1.</target>
        </trans-unit>
        <trans-unit id="d1be8c338ef5a7bcca5157c5203b61e7d14d5f12" translate="yes" xml:space="preserve">
          <source>DROP TABLE t2;</source>
          <target state="translated">DROP TABLE t2.</target>
        </trans-unit>
        <trans-unit id="5771355d686a88f9aec56e2304026908b55bffb4" translate="yes" xml:space="preserve">
          <source>DROP TABLE t3;</source>
          <target state="translated">DROP TABLE t3.</target>
        </trans-unit>
        <trans-unit id="fc6194eca24e844585523f3d0e5cb90acd2f1cd1" translate="yes" xml:space="preserve">
          <source>DROP TRIGGER</source>
          <target state="translated">ドロップトリガー</target>
        </trans-unit>
        <trans-unit id="6a23d5fa27b31fab3e560233e685dfb52af23fcc" translate="yes" xml:space="preserve">
          <source>DROP VIEW</source>
          <target state="translated">ドロップビュー</target>
        </trans-unit>
        <trans-unit id="6a98041e1291d5c0fcb8031e8dc6b0f10dbdcd21" translate="yes" xml:space="preserve">
          <source>DWG - AutoCAD drawings</source>
          <target state="translated">DWG-AutoCAD の図面</target>
        </trans-unit>
        <trans-unit id="4b5fe1d0668c6a074a9b45de43a0ab7e93ea3537" translate="yes" xml:space="preserve">
          <source>Daily in your prayers, with tears and sighs, confess your past sins to God, and amend them for the future.</source>
          <target state="translated">毎日の祈りの中で、涙とため息をつきながら、過去の罪を神に告白し、未来のために修正してください。</target>
        </trans-unit>
        <trans-unit id="352953a16a74f0790135416ee3270f630371240c" translate="yes" xml:space="preserve">
          <source>Data Change Notification Callbacks</source>
          <target state="translated">データ変更通知コールバック</target>
        </trans-unit>
        <trans-unit id="a073b1a4a370adc09bf5c624ac412d5da3300853" translate="yes" xml:space="preserve">
          <source>Data can be inserted into such an FTS4 table using an INSERT statements. However, unlike ordinary FTS4 tables, the user must supply an explicit integer docid value. For example:</source>
          <target state="translated">このようなFTS4テーブルには、INSERT文を用いてデータを挿入することができる。しかし、通常のFTS4テーブルとは異なり、ユーザは明示的な整数のdocid値を与えなければならない。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="9dd6b7f9a7a5a10b73550e3715829adf5933cc29" translate="yes" xml:space="preserve">
          <source>Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.</source>
          <target state="translated">データが支配しています。正しいデータ構造を選択し、物事をうまく整理していれば、アルゴリズムはほとんどの場合、自明のことです。プログラミングの中心はアルゴリズムではなくデータ構造です。</target>
        </trans-unit>
        <trans-unit id="7765119a34cb37ce325b7908102a741f5f04decc" translate="yes" xml:space="preserve">
          <source>Data format conversions can invalidate the pointer returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16(). Pointers might be invalided in the following cases:</source>
          <target state="translated">データ形式の変換は、sqlite3_column_blob()、sqlite3_column_text()、および/またはsqlite3_column_text16()の前の呼び出しによって返されたポインタを無効にすることができます。以下の場合、ポインタは無効になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d6f53192d7efb1f452daf4e4ce9588f68c43c7ab" translate="yes" xml:space="preserve">
          <source>Data read while in the process of opening a read-only transaction (see section</source>
          <target state="translated">読み取り専用のトランザクションを開いている間に読み込まれたデータ(セクション</target>
        </trans-unit>
        <trans-unit id="ee503fe5765b8d9456bf21def7f9e06d2b12ebb6" translate="yes" xml:space="preserve">
          <source>Data type</source>
          <target state="translated">データ型</target>
        </trans-unit>
        <trans-unit id="c0b1a7d66556ee25336c34353c17486dba3e302f" translate="yes" xml:space="preserve">
          <source>Data-types specified as part of the &quot;CREATE VIRTUAL TABLE&quot; statement used to create an FTS table are ignored completely. Instead of the normal rules for applying type &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; to inserted values, all values inserted into FTS table columns (except the special rowid column) are converted to type TEXT before being stored.</source>
          <target state="translated">FTSテーブルの作成に使用される「CREATE VIRTUAL TABLE」ステートメントの一部として指定されたデータ型は完全に無視されます。挿入された値にタイプ&lt;a href=&quot;datatype3#affinity&quot;&gt;アフィニティ&lt;/a&gt;を適用する通常のルールの代わりに、FTSテーブルの列（特別なROWID列を除く）に挿入されたすべての値は、格納される前にタイプTEXTに変換されます。</target>
        </trans-unit>
        <trans-unit id="5c196bb9b92e16036aa92c8d07d6256ad34cf47b" translate="yes" xml:space="preserve">
          <source>Database Connection Configuration Options</source>
          <target state="translated">データベース接続設定オプション</target>
        </trans-unit>
        <trans-unit id="87ad120a4ba60c79863260e10eca7015248baadd" translate="yes" xml:space="preserve">
          <source>Database Connection For Functions</source>
          <target state="translated">機能のデータベース接続</target>
        </trans-unit>
        <trans-unit id="f77d22fb96d5dfa5073b2fe8ffcf8caa0f1f055f" translate="yes" xml:space="preserve">
          <source>Database Connection Handle</source>
          <target state="translated">データベース接続ハンドル</target>
        </trans-unit>
        <trans-unit id="ed913bb076648fca64b8de1c707bbce02bda0945" translate="yes" xml:space="preserve">
          <source>Database Connection Status</source>
          <target state="translated">データベース接続状態</target>
        </trans-unit>
        <trans-unit id="d7a15726be6aee139cc047e8d19aae61e2286733" translate="yes" xml:space="preserve">
          <source>Database Connections</source>
          <target state="translated">データベース接続</target>
        </trans-unit>
        <trans-unit id="3390636be52618dc7d118d178ce5ea03789b0200" translate="yes" xml:space="preserve">
          <source>Database Corruption Warning</source>
          <target state="translated">データベース破損の警告</target>
        </trans-unit>
        <trans-unit id="e9ab5f94bcd6c1898d03a1e6b8469a59f0ed3a77" translate="yes" xml:space="preserve">
          <source>Database File Format</source>
          <target state="translated">データベースファイル形式</target>
        </trans-unit>
        <trans-unit id="ff50d56bfc81a7b956e4d1921d6d66d7a383a42b" translate="yes" xml:space="preserve">
          <source>Database Header Format</source>
          <target state="translated">データベースヘッダー形式</target>
        </trans-unit>
        <trans-unit id="a3535d6748b55df8651025dc19ca0f9492aecee6" translate="yes" xml:space="preserve">
          <source>Database Object Name Resolution</source>
          <target state="translated">データベースオブジェクト名の解決</target>
        </trans-unit>
        <trans-unit id="bd8632f168d3516aef62fc843146b450c3c26a99" translate="yes" xml:space="preserve">
          <source>Database Page Size</source>
          <target state="translated">データベースのページサイズ</target>
        </trans-unit>
        <trans-unit id="4f02b6e9702df3600e6e312d593f7caa8819e1dd" translate="yes" xml:space="preserve">
          <source>Database Snapshot</source>
          <target state="translated">データベースのスナップショット</target>
        </trans-unit>
        <trans-unit id="bd1d5e56dd1e83bbe0ee14778f6008e4f92501fb" translate="yes" xml:space="preserve">
          <source>Database Speed Comparison</source>
          <target state="translated">データベースの速度比較</target>
        </trans-unit>
        <trans-unit id="a8dad839985eddb5586b8b561fd417de9bc6e759" translate="yes" xml:space="preserve">
          <source>Database URI</source>
          <target state="translated">データベースのURI</target>
        </trans-unit>
        <trans-unit id="2d4c00611e1b6734ce538563059febb504705359" translate="yes" xml:space="preserve">
          <source>Database as object</source>
          <target state="translated">オブジェクトとしてのデータベース</target>
        </trans-unit>
        <trans-unit id="83a5cb19e95dc1d8b5d7e1441d8c579a45d5724b" translate="yes" xml:space="preserve">
          <source>Database cache can be optionally shared between connections in the same thread</source>
          <target state="translated">データベースキャッシュは、オプションで同じスレッド内のコネクション間で共有することができます。</target>
        </trans-unit>
        <trans-unit id="e7de38dba43f0a278e3056a00a39519bfc9b665e" translate="yes" xml:space="preserve">
          <source>Database connections can now be used by multiple threads, not just the thread in which they were created.</source>
          <target state="translated">データベース接続は、作成されたスレッドだけでなく、複数のスレッドで使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="212efa9f11c5959aadd0fce19cdf94993470615e" translate="yes" xml:space="preserve">
          <source>Database corruption caused by inconsistent use of 8+3 filenames</source>
          <target state="translated">8+3 ファイル名の一貫性のない使用によるデータベースの破損</target>
        </trans-unit>
        <trans-unit id="053ad514468635665438176cd86a58d603813544" translate="yes" xml:space="preserve">
          <source>Database filename aliasing</source>
          <target state="translated">データベースファイル名のエイリアシング</target>
        </trans-unit>
        <trans-unit id="3b7f204e04933e97d6ac68630583c1313b9cb271" translate="yes" xml:space="preserve">
          <source>Database files can now grow to be up to 2^41 bytes. The old limit was 2^31 bytes.</source>
          <target state="translated">データベースファイルは2^41バイトまで成長できるようになりました。以前の制限は2^31バイトでした。</target>
        </trans-unit>
        <trans-unit id="73a52851158627ec8f4a087842d9a7bc471fcd2f" translate="yes" xml:space="preserve">
          <source>Database files that contain partial indices are not readable or writable by versions of SQLite prior to 3.8.0. However, a database file created by SQLite 3.8.0 is still readable and writable by prior versions as long as its schema contains no partial indexes. A database that is unreadable by legacy versions of SQLite can be made readable simply by running &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; on the partial indexes.</source>
          <target state="translated">部分的なインデックスを含むデータベースファイルは、SQLite 3.8.0より前のバージョンでは読み取りまたは書き込みができません。ただし、SQLite 3.8.0で作成されたデータベースファイルは、スキーマに部分的なインデックスが含まれていない限り、以前のバージョンでも読み取りと書き込みが可能です。SQLiteのレガシーバージョンで読み取れないデータベースは、部分インデックスで&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;を実行するだけで読み取り可能にすることができます。</target>
        </trans-unit>
        <trans-unit id="b78486fa6ae30389540b15aab7739d7ecbc3140a" translate="yes" xml:space="preserve">
          <source>Database header</source>
          <target state="translated">データベースヘッダ</target>
        </trans-unit>
        <trans-unit id="d8a9d9190c53a37330666f4da1d52eb4d5397265" translate="yes" xml:space="preserve">
          <source>Database locks obtained by a connection in EXCLUSIVE mode may be released either by closing the database connection, or by setting the locking-mode back to NORMAL using this pragma and then accessing the database file (for read or write). Simply setting the locking-mode to NORMAL is not enough - locks are not released until the next time the database file is accessed.</source>
          <target state="translated">EXCLUSIVEモードでの接続によって得られたデータベースロックは、データベース接続を閉じるか、このプラグマを使用してロックモードをNORMALに戻してからデータベースファイルにアクセスすることで解除することができます(読み込みまたは書き込み)。ロックモードをNORMALに設定するだけでは十分ではありません-次にデータベースファイルにアクセスするまでロックは解除されません。</target>
        </trans-unit>
        <trans-unit id="9118c7b06bcc534b6f4c486616838692892faa73" translate="yes" xml:space="preserve">
          <source>Database page size. Example: 1024</source>
          <target state="translated">データベースのページサイズ。例:1024</target>
        </trans-unit>
        <trans-unit id="19e5379d75e917575fd8db9bff227b50947f62a7" translate="yes" xml:space="preserve">
          <source>Database read and write operations, and the way in which they interact with and use the</source>
          <target state="translated">データベースの読み書き操作と、それらがどのように相互作用して</target>
        </trans-unit>
        <trans-unit id="c8a8e97f4d032178ae62a7d1cf0df7f938947c9e" translate="yes" xml:space="preserve">
          <source>Database zDb does not exist,</source>
          <target state="translated">データベース zDb が存在しません。</target>
        </trans-unit>
        <trans-unit id="684ece0a836446078b844add11528674b80daff5" translate="yes" xml:space="preserve">
          <source>Databases are opened using &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; when the --append flag is used on the command line or with the .open command.</source>
          <target state="translated">--appendフラグがコマンドラインまたは.openコマンドで使用される場合、データベースは&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt;を使用して開かれます。</target>
        </trans-unit>
        <trans-unit id="537610cacac4e984aff9fc9a16523e33b6616036" translate="yes" xml:space="preserve">
          <source>Databases created by the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command always use the same encoding as the main database. An attempt to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; a database with a different text encoding from the &quot;main&quot; database will fail.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;コマンドで作成されたデータベースは、常にメインデータベースと同じエンコーディングを使用します。「メイン」データベースとは異なるテキストエンコーディングでデータベースを&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;しようとすると失敗します。</target>
        </trans-unit>
        <trans-unit id="3c4ce966e1af83816196cb8a675f0d67e707135b" translate="yes" xml:space="preserve">
          <source>Databases generated with this option enabled are not readable by SQLite version 3.1.6 (2005-03-17) and earlier. Also, databases generated with this option enabled are prone to triggering the &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46&lt;/a&gt; bug in the &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface. For those reasons, this optimization is disabled by default. However, this optimization may be enabled by default in a future release of SQLite.</source>
          <target state="translated">このオプションを有効にして生成されたデータベースは、SQLiteバージョン3.1.6（2005-03-17）以前では読み取ることができません。また、このオプションを有効にして生成されたデータベースは、&lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;インターフェースの&lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46&lt;/a&gt;バグをトリガーする傾向があります。これらの理由により、この最適化はデフォルトで無効になっています。ただし、SQLiteの将来のリリースでは、この最適化がデフォルトで有効になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2b3b2437f86ea4a0a8830ee6f8676cb1c3fc7da2" translate="yes" xml:space="preserve">
          <source>Datatype</source>
          <target state="translated">Datatype</target>
        </trans-unit>
        <trans-unit id="8562930b64d8c57b6dc3907022c61a4e6a5ac83f" translate="yes" xml:space="preserve">
          <source>Datatypes</source>
          <target state="translated">Datatypes</target>
        </trans-unit>
        <trans-unit id="baca0ff89b200ca165a0e54ccac355e7a923a643" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite Version 2</source>
          <target state="translated">SQLite バージョン 2 のデータ型</target>
        </trans-unit>
        <trans-unit id="1148668ae941abc0a854dc721e03d190e3485da6" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite Version 3</source>
          <target state="translated">SQLite バージョン 3 のデータ型</target>
        </trans-unit>
        <trans-unit id="1c55ea91377b3b902abf3a2f501f4ea2f40cdee4" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite version 2</source>
          <target state="translated">SQLite バージョン 2 のデータ型</target>
        </trans-unit>
        <trans-unit id="233589836b520dde667809090f43b167594ea046" translate="yes" xml:space="preserve">
          <source>Date And Time Functions</source>
          <target state="translated">日付と時間関数</target>
        </trans-unit>
        <trans-unit id="6e2d2613130a40dc5bf62f65d270a32aa2b8b643" translate="yes" xml:space="preserve">
          <source>Date and time datatype</source>
          <target state="translated">日付と時刻のデータ型</target>
        </trans-unit>
        <trans-unit id="75a33d1bae263935cd17a2f9f5d07d057859dce8" translate="yes" xml:space="preserve">
          <source>Dbhash can be used to compare two databases to confirm that they are equivalent, even though their representation on disk is quite different. Dbhash might also be used to verify the content of a remote database without having to transmit the entire content of the remote database over a slow link.</source>
          <target state="translated">Dbhashは、2つのデータベースを比較して、ディスク上での表現が全く異なっていても、同等であることを確認するために使用することができます。また、Dbhashは、リモートデータベースのコンテンツ全体を低速なリンクで転送することなく、リモートデータベースのコンテンツを検証するために使用されることもあります。</target>
        </trans-unit>
        <trans-unit id="3bbc93e532fc52d7a861418ae6b728933b34062d" translate="yes" xml:space="preserve">
          <source>Dbhash ignores extraneous formatting details and hashes only the database schema and content. Hence the hash is constant even if the database file is modified by:</source>
          <target state="translated">Dbhashは余計なフォーマットの詳細を無視し、データベースのスキーマと内容のみをハッシュします。したがって、データベースファイルが変更されてもハッシュは一定です。</target>
        </trans-unit>
        <trans-unit id="fb601abda7bdb73c50bfb1396b0751c831eb5fce" translate="yes" xml:space="preserve">
          <source>Dbhash is a command-line utility. To run it, type &quot;dbhash&quot; on a command-line prompt followed by the names of one or more SQLite database files that are to be hashed. The database hashes will be displayed on standard output. For example:</source>
          <target state="translated">Dbhashはコマンドラインユーティリティです。実行するには、コマンドラインプロンプトで &quot;dbhash &quot;と入力し、その後にハッシュ化する1つ以上のSQLiteデータベースファイルの名前を入力します。データベースのハッシュは標準出力に表示されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e18681716fd7987f00ad554ff7f96da73e19fc13" translate="yes" xml:space="preserve">
          <source>Dbhash supports command-line options that can restrict the tables of the database file that are hashed, or restrict the hash to only content or only the schema. Run &quot;dbhash --help&quot; for further information.</source>
          <target state="translated">Dbhashはコマンドラインオプションをサポートしており、ハッシュされるデータベースファイルのテーブルを制限したり、ハッシュをコンテンツのみに制限したり、スキーマのみに制限したりすることができます。詳細は &quot;dbhash --help&quot; を実行してください。</target>
        </trans-unit>
        <trans-unit id="4a3882260abac88b66d6979bfd1282ccb93420d4" translate="yes" xml:space="preserve">
          <source>Deactivate the &lt;a href=&quot;lang_select#distinct&quot;&gt;DISTINCT&lt;/a&gt; keyword on subqueries on the right-hand side of the &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN演算子の&lt;/a&gt;右側にあるサブクエリの&lt;a href=&quot;lang_select#distinct&quot;&gt;DISTINCT&lt;/a&gt;キーワードを無効にします。</target>
        </trans-unit>
        <trans-unit id="7f6794b197abfdc80b581fdd1340dcd8182be7db" translate="yes" xml:space="preserve">
          <source>Debugging Hints</source>
          <target state="translated">デバッグのヒント</target>
        </trans-unit>
        <trans-unit id="6558db0cb9f4028912366a41e3c7533d49d4b391" translate="yes" xml:space="preserve">
          <source>Debugging memory allocator</source>
          <target state="translated">メモリアロケータのデバッグ</target>
        </trans-unit>
        <trans-unit id="7c281fc0eea49fa90d5204752efe02a46e78181a" translate="yes" xml:space="preserve">
          <source>Debugging mode. Do not actually perform any optimizations but instead return one line of text for each optimization that would have been done. Off by default.</source>
          <target state="translated">デバッグモード。実際に最適化を実行するのではなく、実行されたであろう最適化ごとに1行のテキストを返します。デフォルトではオフになっています。</target>
        </trans-unit>
        <trans-unit id="e4c3a2d0cc24a4535ef91791064ffe989cbd382a" translate="yes" xml:space="preserve">
          <source>Decimal</source>
          <target state="translated">Decimal</target>
        </trans-unit>
        <trans-unit id="4884a58f8854eaff9e14e4541fa2bfc15e139d8a" translate="yes" xml:space="preserve">
          <source>Declare The Schema Of A Virtual Table</source>
          <target state="translated">仮想テーブルのスキーマを宣言する</target>
        </trans-unit>
        <trans-unit id="c657d4e9ebee4c198c968bcba7aff6eeab9209c1" translate="yes" xml:space="preserve">
          <source>Declared Datatype Of A Query Result</source>
          <target state="translated">クエリ結果の宣言されたデータ型</target>
        </trans-unit>
        <trans-unit id="52f7f00d0ba2d4f4aaef6d6440932d8183870fe3" translate="yes" xml:space="preserve">
          <source>Decompose the &quot;settings.xml&quot; file into an SQL table that is more easily viewed and edited by separate applications.</source>
          <target state="translated">settings.xml」ファイルを、別のアプリケーションでより見やすく編集しやすいSQLテーブルに分解します。</target>
        </trans-unit>
        <trans-unit id="e090288f7922e2e7bbb158d2a90c3c98da108024" translate="yes" xml:space="preserve">
          <source>DecrJumpZero</source>
          <target state="translated">DecrJumpZero</target>
        </trans-unit>
        <trans-unit id="7078198f7cae420890a1abe183a812a6a35f8ed6" translate="yes" xml:space="preserve">
          <source>Default Value</source>
          <target state="translated">デフォルト値</target>
        </trans-unit>
        <trans-unit id="349c243fc47f07030e17a3729d694bcfe2dadb05" translate="yes" xml:space="preserve">
          <source>Default builds of SQLite contain appropriate &lt;a href=&quot;vfs&quot;&gt;VFS objects&lt;/a&gt; for talking to underlying operating system, and those VFS objects will contain operating system calls such as open(), read(), write(), fsync(), and so forth. All of these interfaces are readily available on most platforms, and custom VFSes can be designed to run SQLite on even the most austere embedded devices.</source>
          <target state="translated">SQLiteのデフォルトのビルドには、基盤となるオペレーティングシステムと&lt;a href=&quot;vfs&quot;&gt;通信する&lt;/a&gt;ための適切なVFSオブジェクトが含まれ、それらのVFSオブジェクトには、open（）、read（）、write（）、fsync（）などのオペレーティングシステムコールが含まれます。これらのインターフェースはすべて、ほとんどのプラットフォームですぐに利用でき、カスタムVFSは、最も厳しい組み込みデバイスでもSQLiteを実行するように設計できます。</target>
        </trans-unit>
        <trans-unit id="038803a5a725763be7d5665007510dd34ef1f8ce" translate="yes" xml:space="preserve">
          <source>Default memory allocator</source>
          <target state="translated">デフォルトのメモリアロケータ</target>
        </trans-unit>
        <trans-unit id="e25af978372277845b3d313829fc8e2e019d17ec" translate="yes" xml:space="preserve">
          <source>Default page cache size.</source>
          <target state="translated">デフォルトのページキャッシュサイズ。</target>
        </trans-unit>
        <trans-unit id="bdffe654f8554300a98d2acefcbbf1d894339b2b" translate="yes" xml:space="preserve">
          <source>Default value</source>
          <target state="translated">デフォルト値</target>
        </trans-unit>
        <trans-unit id="f9d91891053643138161539927c04de3021744dd" translate="yes" xml:space="preserve">
          <source>Defense Against Dark Arts</source>
          <target state="translated">闇の魔術に対する防御</target>
        </trans-unit>
        <trans-unit id="c78392ffee2ec805b3bc60c680fa04c8a3bfdd3e" translate="yes" xml:space="preserve">
          <source>DeferredSeek</source>
          <target state="translated">DeferredSeek</target>
        </trans-unit>
        <trans-unit id="2a32a694b454b48f0c6093b3ea95bcc7ae1e63ab" translate="yes" xml:space="preserve">
          <source>Define New Collating Sequences</source>
          <target state="translated">新しい照合シーケンスの定義</target>
        </trans-unit>
        <trans-unit id="7a8df33d7a4ee8c98b8a16229139f0094608d9e9" translate="yes" xml:space="preserve">
          <source>Define a static (but not constant) &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure that contains pointers to the xOpen method and the other methods and which contains the appropriate values for iVersion, szOsFile, mxPathname, zName, and pAppData.</source>
          <target state="translated">xOpenメソッドおよびその他のメソッドへのポインターを含み、iVersion、szOsFile、mxPathname、zName、およびpAppDataの適切な値を含む静的（ただし定数ではない）&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;構造を定義します。</target>
        </trans-unit>
        <trans-unit id="d00d0274d811a9571e6a7d0d105251d14e6c534a" translate="yes" xml:space="preserve">
          <source>Define an appropriate subclass of the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトの適切なサブクラスを定義します。</target>
        </trans-unit>
        <trans-unit id="8eb6b16d370a1014df05c39f19a4497ee0d61573" translate="yes" xml:space="preserve">
          <source>Define the &quot;payload&quot; of a cell to be the arbitrary length section of the cell. For an index b-tree, the key is always arbitrary in length and hence the payload is the key. There are no arbitrary length elements in the cells of interior table b-tree pages and so those cells have no payload. Table b-tree leaf pages contain arbitrary length content and so for cells on those pages the payload is the content.</source>
          <target state="translated">セルの「ペイロード」を、セルの任意の長さの部分と定義する。インデックスb-treeの場合、キーは常に任意の長さであり、したがってペイロードはキーである。内部の表 b-tree ページのセルには任意の長さの要素は存在しないので、それらのセルはペイロードを持たない。表 b-tree リーフページは、任意の長さの内容を含んでいるので、それらのページのセルのペイロードは内容となる。</target>
        </trans-unit>
        <trans-unit id="09695710d6ec87af0ba3720c928922e55056227a" translate="yes" xml:space="preserve">
          <source>Define the depth of a leaf b-tree to be 1 and the depth of any interior b-tree to be one more than the maximum depth of any of its children. In a well-formed database, all children of an interior b-tree have the same depth.</source>
          <target state="translated">リーフb-treeの深さを1とし、内部b-treeの深さをその子の最大深さよりも1以上と定義します。整ったデータベースでは,内部b-treeのすべての子は同じ深さを持ちます.</target>
        </trans-unit>
        <trans-unit id="e75225c3111252da2f1b0958f137acf031ed75f2" translate="yes" xml:space="preserve">
          <source>Defining this option causes the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; command to be omitted from the library. Attempting to execute an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; statement will cause a parse error.</source>
          <target state="translated">このオプションを定義すると、&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;コマンドがライブラリーから省略されます。&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;ステートメントを実行しようとすると、解析エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="95e30519291de496ce9227bf803508402c5b0e39" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas for querying and modifying the database schema version and user version from the build. Specifically, the &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; PRAGMAs are omitted.</source>
          <target state="translated">このオプションを定義すると、ビルドからデータベーススキーマバージョンとユーザーバージョンを照会および変更するためのプラグマが省略されます。具体的には、&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt;および&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; PRAGMAが省略されています。</target>
        </trans-unit>
        <trans-unit id="438bf5a3e905d9e27a03501948a3300c579faa96" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas for querying the database schema from the build.</source>
          <target state="translated">このオプションを定義すると、ビルドからデータベーススキーマをクエリするためのプラグマが省略されます。</target>
        </trans-unit>
        <trans-unit id="fb53b1a942ec49b6ce242dc0903a83562676a9de" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas related to the pager subsystem from the build.</source>
          <target state="translated">このオプションを定義すると、ページャーサブシステムに関連するプラグマがビルドから除外されます。</target>
        </trans-unit>
        <trans-unit id="dc2296b74c87da37e10da27f66b21bb73a4427d7" translate="yes" xml:space="preserve">
          <source>Defining this option omits support for TRIGGER objects. Neither the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; or &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; commands are available in this case, and attempting to execute either will result in a parse error. This option also disables enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;, since the code that implements triggers and which is omitted by this option is also used to implement &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;.</source>
          <target state="translated">このオプションを定義すると、TRIGGERオブジェクトのサポートが省略されます。どちらも&lt;a href=&quot;lang_createtrigger&quot;&gt;、CREATE TRIGGER&lt;/a&gt;または&lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;コマンドは、この場合には利用できません、とのいずれかを実行しようとすると、パースエラーとなります。このオプションでは、トリガーを実装し、このオプションでは省略されるコードが&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外部キーアクションの&lt;/a&gt;実装にも使用されるため、&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約の適用&lt;/a&gt;も無効になります。</target>
        </trans-unit>
        <trans-unit id="15c4cfc354a842ec38f01dc56ced3bf25c4ad5b6" translate="yes" xml:space="preserve">
          <source>Defining this option omits support for VIEW objects. Neither the &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; nor the &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; commands are available in this case, and attempting to execute either will result in a parse error.</source>
          <target state="translated">このオプションを定義すると、VIEWオブジェクトのサポートが省略されます。どちらも&lt;a href=&quot;lang_createview&quot;&gt;VIEWを作成しないで&lt;/a&gt;も、&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEWの&lt;/a&gt;コマンドは、この場合には使用可能であり、いずれかを実行しようとすると、パースエラーとなります。</target>
        </trans-unit>
        <trans-unit id="a8d0bb74e48c16e4de7827a8ffc7d0dc3f87633f" translate="yes" xml:space="preserve">
          <source>Defining this option omits the authorization callback feature from the library. The &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; API function is not present in the library.</source>
          <target state="translated">このオプションを定義すると、ライブラリから認証コールバック機能が省略されます。&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt; API関数は、ライブラリ内に存在しません。</target>
        </trans-unit>
        <trans-unit id="83f644802e49a1cbe2ffeee1f4e6042a39cd0de9" translate="yes" xml:space="preserve">
          <source>Definition: A &lt;b&gt;result table&lt;/b&gt; is memory data structure created by the &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface. A result table records the complete query results from one or more queries.</source>
          <target state="translated">定義：&lt;b&gt;結果テーブル&lt;/b&gt;は、&lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;インターフェースによって作成されたメモリデータ構造です。結果テーブルは、1つ以上のクエリからの完全なクエリ結果を記録します。</target>
        </trans-unit>
        <trans-unit id="e259d1f20b6fd6c9ce46ea6e1dc31fde6f204fb8" translate="yes" xml:space="preserve">
          <source>Definition: A &lt;b&gt;result table&lt;/b&gt; is memory data structure created by the &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface. A result table records the complete query results from one or more queries.</source>
          <target state="translated">定義：&lt;b&gt;結果テーブル&lt;/b&gt;は、&lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;インターフェースによって作成されたメモリデータ構造です。結果テーブルは、1つ以上のクエリからの完全なクエリ結果を記録します。</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="6ae0a530b1b7677b78998487aadb9d2cadf7f88f" translate="yes" xml:space="preserve">
          <source>Delete A Changegroup Object</source>
          <target state="translated">変更グループ オブジェクトの削除</target>
        </trans-unit>
        <trans-unit id="2b620c0b18464aba1294c125c40ed5d238146244" translate="yes" xml:space="preserve">
          <source>Delete A Session Object</source>
          <target state="translated">セッションオブジェクトの削除</target>
        </trans-unit>
        <trans-unit id="12eda7c48435244e864fe35cc6d11a7bc5eebd9b" translate="yes" xml:space="preserve">
          <source>Delete a changeset rebaser object</source>
          <target state="translated">チェンジセットリベスターオブジェクトの削除</target>
        </trans-unit>
        <trans-unit id="6ccb779f78fa4c2f40b79e1431ac32a6c85e1c13" translate="yes" xml:space="preserve">
          <source>Delete a changeset rebaser object.</source>
          <target state="translated">チェンジセット・リベスター・オブジェクトを削除します。</target>
        </trans-unit>
        <trans-unit id="12991bc9bb4a12d326aa6753050041d7a4fabc24" translate="yes" xml:space="preserve">
          <source>Delete a session object previously allocated using &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;. Once a session object has been deleted, the results of attempting to use pSession with any other session module function are undefined.</source>
          <target state="translated">以前に&lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;を使用して割り当てられたセッションオブジェクトを削除します。セッションオブジェクトが削除されると、他のセッションモジュール関数でpSessionを使用した結果は未定義になります。</target>
        </trans-unit>
        <trans-unit id="d762d1040e85482796c9fd4d534519cef24d74ed" translate="yes" xml:space="preserve">
          <source>Delete a session object previously allocated using &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;. Once a session object has been deleted, the results of attempting to use pSession with any other session module function are undefined.</source>
          <target state="translated">以前に&lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;を使用して割り当てられたセッションオブジェクトを削除します。セッションオブジェクトが削除されると、他のセッションモジュール関数でpSessionを使用した結果は未定義になります。</target>
        </trans-unit>
        <trans-unit id="02512a6317bed133605bfc468e6ef4822f972b23" translate="yes" xml:space="preserve">
          <source>Delete all contents from the ephemeral table or sorter that is open on cursor P1.</source>
          <target state="translated">カーソルP1で開いているエフェメラルテーブルまたはソーターからすべてのコンテンツを削除します。</target>
        </trans-unit>
        <trans-unit id="aedb82abe0e510f8fa2d29632ac81d5268819e7f" translate="yes" xml:space="preserve">
          <source>Delete all contents of the database table or index whose root page in the database file is given by P1. But, unlike &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;, do not remove the table or index from the database file.</source>
          <target state="translated">データベースファイルのルートページがP1によって指定されているデータベーステーブルまたはインデックスのすべてのコンテンツを削除します。ただし、&lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;とは異なり、データベースファイルからテーブルまたはインデックスを削除しないでください。</target>
        </trans-unit>
        <trans-unit id="6f095a0ada2906d2012dfcefd96beaf7902bce51" translate="yes" xml:space="preserve">
          <source>Delete all individual journal files.</source>
          <target state="translated">個別のジャーナルファイルをすべて削除します。</target>
        </trans-unit>
        <trans-unit id="bf1b9b7fadc6e867c3913361047ae2f1e082e237" translate="yes" xml:space="preserve">
          <source>Delete an entire database table or index whose root page in the database file is given by P1.</source>
          <target state="translated">データベースファイルのルートページがP1で指定されているデータベーステーブルまたはインデックス全体を削除します。</target>
        </trans-unit>
        <trans-unit id="5bc9013dca7ae3cd28443b3643084c1962bbbebb" translate="yes" xml:space="preserve">
          <source>Delete the changeset rebaser object and all associated resources. There should be one call to this function for each successful invocation of sqlite3rebaser_create().</source>
          <target state="translated">チェンジセット・リベイザー・オブジェクトと関連するすべてのリソースを削除します。sqlite3rebaser_create()の呼び出しが成功するたびに、この関数を1回呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="60bf70613708367f728d96356276360d98741581" translate="yes" xml:space="preserve">
          <source>Delete the journal file (or truncate the journal to zero bytes in length if &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; is set, or zero the journal header if &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=PERSIST&lt;/a&gt; is set).</source>
          <target state="translated">ジャーナルファイルを削除します（または、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = TRUNCATE&lt;/a&gt;が設定されている場合はジャーナルを長さ0バイトに切り捨て、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = PERSIST&lt;/a&gt;が設定されている場合はジャーナルヘッダーをゼロにします）。</target>
        </trans-unit>
        <trans-unit id="424c686346d72ee424e3afead9478d41b73e0e95" translate="yes" xml:space="preserve">
          <source>Delete the journal file. (Or if the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is TRUNCATE or PERSIST, truncate the journal file or zero the header of the journal file, respectively.) This is the instant when the changes are committed. Prior to deleting the journal file, if a power failure or crash occurs, the next process to open the database will see that it has a hot journal and will roll the changes back. After the journal is deleted, there will no longer be a hot journal and the changes will persist.</source>
          <target state="translated">ジャーナルファイルを削除します。（または、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt;がTRUNCATEまたはPERSISTの場合、それぞれジャーナルファイルを切り捨てるか、ジャーナルファイルのヘッダーをゼロにします。）これは、変更がコミットされる瞬間です。ジャーナルファイルを削除する前に、停電やクラッシュが発生した場合、データベースを開く次のプロセスでは、データベースにホットジャーナルがあることがわかり、変更がロールバックされます。ジャーナルが削除されると、ホットジャーナルはなくなり、変更は保持されます。</target>
        </trans-unit>
        <trans-unit id="aae017b3d4b04098148419004c202430e143c042" translate="yes" xml:space="preserve">
          <source>Delete the master journal file if it is safe to do so. This step is optional. It is here only to prevent stale master journals from cluttering up the disk drive. See the discussion below for details.</source>
          <target state="translated">マスター・ジャーナル・ファイルを削除しても問題がなければ削除します。このステップはオプションです。これは、古くなったマスタージャーナルがディスクドライブを汚すのを防ぐためだけに行われます。詳細については、以下の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="e10f41bbb6b9a5c4d90c81334bd806252b81f5b3" translate="yes" xml:space="preserve">
          <source>Delete the master journal file. This is the instant when the changes are committed. Prior to deleting the master journal file, if a power failure or crash occurs, the individual file journals will be considered hot and will be rolled back by the next process that attempts to read them. After the master journal has been deleted, the file journals will no longer be considered hot and the changes will persist.</source>
          <target state="translated">マスタージャーナルファイルを削除します。これは変更がコミットされた瞬間です。マスター・ジャーナル・ファイルを削除する前に、停電やクラッシュが発生した場合、個々のファイル・ジャーナルはホットとみなされ、それらを読み込もうとする次のプロセスによってロールバックされます。マスター・ジャーナルが削除されると、ファイル・ジャーナルはもはやホットとはみなされず、変更は持続します。</target>
        </trans-unit>
        <trans-unit id="29e75bc2e3dd1128b5b5e72142f38e94e6c04b31" translate="yes" xml:space="preserve">
          <source>Delete the record at which the P1 cursor is currently pointing.</source>
          <target state="translated">P1 カーソルが現在ポイントしているレコードを削除します。</target>
        </trans-unit>
        <trans-unit id="91c899cb9487830103f86062414b65279777c00c" translate="yes" xml:space="preserve">
          <source>Delete triggers fire when rows are removed due to a &lt;a href=&quot;lang_conflict&quot;&gt;REPLACE conflict resolution&lt;/a&gt;. This feature is only enabled when recursive triggers are enabled.</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;REPLACE競合解決&lt;/a&gt;により行が削除されると、削除トリガーが起動します。この機能は、再帰トリガーが有効になっている場合にのみ有効になります。</target>
        </trans-unit>
        <trans-unit id="f97f11b2a9d7f4d5cfcb9f5b6bc157b876524629" translate="yes" xml:space="preserve">
          <source>Deleting a file is an expensive operation on many systems. So as an optimization, SQLite can be configured to avoid the delete operation of &lt;a href=&quot;#section_3_11&quot;&gt;section 3.11&lt;/a&gt;. Instead of deleting the journal file in order to commit a transaction, the file is either truncated to zero bytes in length or its header is overwritten with zeros. Truncating the file to zero length saves having to make modifications to the directory containing the file since the file is not removed from the directory. Overwriting the header has the additional savings of not having to update the length of the file (in the &quot;inode&quot; on many systems) and not having to deal with newly freed disk sectors. Furthermore, at the next transaction the journal will be created by overwriting existing content rather than appending new content onto the end of a file, and overwriting is often much faster than appending.</source>
          <target state="translated">ファイルの削除は、多くのシステムで負荷の高い操作です。したがって、最適化として、SQLiteは&lt;a href=&quot;#section_3_11&quot;&gt;セクション3.11の&lt;/a&gt;削除操作を回避するように構成できます。。トランザクションをコミットするためにジャーナルファイルを削除する代わりに、ファイルの長さがゼロバイトに切り捨てられるか、ヘッダーがゼロで上書きされます。ファイルを長さゼロに切り捨てると、ファイルがディレクトリから削除されないため、ファイルを含むディレクトリに変更を加える必要がなくなります。ヘッダーを上書きすると、ファイルの長さを更新する必要がなくなり（多くのシステムでは「iノード」で）、新しく解放されたディスクセクターを処理する必要がなくなります。さらに、次のトランザクションでは、ファイルの最後に新しいコンテンツを追加するのではなく、既存のコンテンツを上書きすることによってジャーナルが作成され、多くの場合、上書きは追加よりもはるかに高速です。</target>
        </trans-unit>
        <trans-unit id="2696b8d0813903709611732c9e8977b50fd62e40" translate="yes" xml:space="preserve">
          <source>Deleting a file is not really an atomic operation, but it appears to be from the point of view of a user process. A process is always able to ask the operating system &quot;does this file exist?&quot; and the process will get back a yes or no answer. After a power failure that occurs during a transaction commit, SQLite will ask the operating system whether or not the rollback journal file exists. If the answer is &quot;yes&quot; then the transaction is incomplete and is rolled back. If the answer is &quot;no&quot; then it means the transaction did commit.</source>
          <target state="translated">ファイルを削除することは、実際には原子的な操作ではないが、ユーザープロセスの観点からはそう見える。プロセスは常にオペレーティングシステムに「このファイルは存在しますか」と尋ねることができ、プロセスはイエスかノーの答えを返します。トランザクションのコミット中に停電が発生した場合、SQLite はオペレーティングシステムにロールバック・ジャーナル・ファイルが存在するかどうかを尋ねます。答えが &quot;yes &quot;の場合、そのトランザクションは不完全であり、ロールバックされます。答えが &quot;no &quot;の場合は、トランザクションがコミットされたことを意味します。</target>
        </trans-unit>
        <trans-unit id="c09fda80ecfdf9e281d56a4afdd3670077682c0b" translate="yes" xml:space="preserve">
          <source>Deleting a hot journal</source>
          <target state="translated">ホットジャーナルの削除</target>
        </trans-unit>
        <trans-unit id="9d50c7931911f099d06f9c5c9dcef20c05a1a010" translate="yes" xml:space="preserve">
          <source>Deliberately changing out of WAL mode changes the database file format version numbers back to 1 so that older versions of SQLite can once again access the database file.</source>
          <target state="translated">WALモードから意図的に変更すると、データベースファイルのフォーマットのバージョン番号が1に戻り、古いバージョンのSQLiteが再びデータベースファイルにアクセスできるようになります。</target>
        </trans-unit>
        <trans-unit id="94c24d036a23e21672451696acb1226b9371946b" translate="yes" xml:space="preserve">
          <source>Deny oneself in order to follow Christ.</source>
          <target state="translated">キリストに従うために自分を否定する。</target>
        </trans-unit>
        <trans-unit id="4b72ef41c3b1c98245c65c2469b7a10fdf627d58" translate="yes" xml:space="preserve">
          <source>Depending how badly your database is corrupted, you may be able to recover some of the data by using the CLI to dump the schema and contents to a file and then recreate. Unfortunately, once humpty-dumpty falls off the wall, it is generally not possible to put him back together again.</source>
          <target state="translated">データベースの破損の程度にもよりますが、CLIを使用してスキーマとコンテンツをファイルにダンプしてから再作成することで、データの一部を回復できるかもしれません。残念ながら、一度ハンプティ・ダンプティが壁から落ちてしまうと、一般的には元に戻すことはできません。</target>
        </trans-unit>
        <trans-unit id="5466f1e1c1f4f0fffe016c26643a67d2ad503e26" translate="yes" xml:space="preserve">
          <source>Depending on the query, SQLite might need to materialize the &quot;(SELECT b FROM ex2)&quot; subquery into a temporary table, then perform the join between ex1 and the temporary table. The query optimizer tries to avoid this by &quot;flattening&quot; the query. In the previous example the query can be flattened, and SQLite will automatically transform the query into</source>
          <target state="translated">クエリによっては、SQLiteは&quot;(SELECT b FROM ex2)&quot;サブクエリを一時テーブルに実体化し、ex1と一時テーブル間の結合を実行する必要があるかもしれません。クエリオプティマイザは、クエリを「平坦化」することでこれを回避しようとします。前の例では、クエリを平坦化することができ、SQLiteはクエリを自動的に次のように変換します。</target>
        </trans-unit>
        <trans-unit id="886d67dc402c58b18f059201de3cb182bdcca2d0" translate="yes" xml:space="preserve">
          <source>Depending on the type of conflict, a sessions application has a variety of configurable options for dealing with conflicts, ranging from omitting the conflicting change, aborting the entire changeset application or applying the change despite the conflict. For details, refer to the documentation for the &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">競合の種類に応じて、セッションアプリケーションには、競合する変更の省略、変更セットアプリケーション全体の中止、競合にもかかわらず変更の適用など、競合に対処するためのさまざまな構成可能なオプションがあります。詳細については、&lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt; APIのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="99099b8d7e1bb8542438e0ec64f4aa03573d7d34" translate="yes" xml:space="preserve">
          <source>Depending on which parameter is being interrogated, one of the VALUE or HIWTR mark measurements might be undefined. For example, only the high-water mark is meaningful for &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmallocsize&quot;&gt;SQLITE_STATUS_MALLOC_SIZE&lt;/a&gt;, and only the current value is meaningful for &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt;. For rows where one or the other of VALUE or HIWTR is not meaningful, that value is returned as NULL. the interfaces, with the initial</source>
          <target state="translated">問い合わせの対象となるパラメーターによっては、VALUEまたはHIWTRマーク測定のいずれかが未定義になる場合があります。たとえば、最高水準点のみが&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmallocsize&quot;&gt;SQLITE_STATUS_MALLOC_SIZE&lt;/a&gt;に意味があり、現在の値だけが&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USEDに&lt;/a&gt;意味があります。VALUEまたはHIWTRのいずれかが意味を持たない行の場合、その値はNULLとして返されます。インターフェース、初期</target>
        </trans-unit>
        <trans-unit id="3a49085fe4eb15cab436b357201995ee9bf9e4bd" translate="yes" xml:space="preserve">
          <source>Depending on your hardware and operating system, you should see that reads from the test1.db database file are about 35% faster than reads from individual files in the test1.dir or test1.tree folders. Results can vary significantly from one run to the next due to caching, so it is advisable to run tests multiple times and take an average or a worst case or a best case, depending on your requirements.</source>
          <target state="translated">ハードウェアとオペレーティングシステムにもよりますが、test1.dirやtest1.treeフォルダ内の個々のファイルからの読み込みよりも、test1.dbデータベースファイルからの読み込みの方が約35%高速であることがわかるはずです。結果はキャッシュのため、1回の実行から次の実行まで大きく変わることがあるので、複数回テストを実行して、要件に応じて平均値、最悪のケース、ベストケースを取ることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="42a66abe1669ce3ffad7695dbe407c22ed591eb2" translate="yes" xml:space="preserve">
          <source>Deprecated Functions</source>
          <target state="translated">非推奨関数</target>
        </trans-unit>
        <trans-unit id="bfc32553e9a3941dedadb9fb40b33e7008f653d9" translate="yes" xml:space="preserve">
          <source>Deprecated Soft Heap Limit Interface</source>
          <target state="translated">非推奨のソフトヒープ制限インタフェース</target>
        </trans-unit>
        <trans-unit id="3a682fd508565521834d60be19ff2f936a43d34b" translate="yes" xml:space="preserve">
          <source>Deprecated interfaces have been superceded by better methods of accomplishing the same thing and should be avoided in new applications. Deprecated interfaces continue to be supported for the sake of backwards compatibility. At some point in the future, it is possible that deprecated interfaces may be removed.</source>
          <target state="translated">非推奨のインターフェースは、同じことを達成するより優れた方法に取って代わられているので、新しいアプリケーションでは避けるべきです。非推奨インターフェースは後方互換性のためにサポートされ続けています。将来的には、非推奨のインターフェースが削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="2bd86ca0936a352d07e01faf8385985c6bcfbe7d" translate="yes" xml:space="preserve">
          <source>Deprecated interfaces should not be used in new code and might be removed in some future release.</source>
          <target state="translated">非推奨のインターフェイスは新しいコードでは使用されるべきではなく、将来のリリースで削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="384385f4ecfb14efac5a6de95da0a3708e15bd88" translate="yes" xml:space="preserve">
          <source>Descending indices</source>
          <target state="translated">降順インデックス</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="4d25e019c14ea4edb8919779e923685a3363cdef" translate="yes" xml:space="preserve">
          <source>Description Of File Format Change</source>
          <target state="translated">ファイル形式の変更の説明</target>
        </trans-unit>
        <trans-unit id="cd8429891c87cd83470eecb59eba348d84f2f5d1" translate="yes" xml:space="preserve">
          <source>Deserialize a database</source>
          <target state="translated">データベースのデシリアライズ</target>
        </trans-unit>
        <trans-unit id="99d0530263d176ccac0fdc529fd7f2dedfa20826" translate="yes" xml:space="preserve">
          <source>Designing software is hard. It takes a lot of focus. A good version control system should provide the developer with assistance, not frustration. Git has gotten better in this regard over the past decade, but it still has a long way to go.</source>
          <target state="translated">ソフトウェアを設計するのは難しい。多くの集中力が必要です。優れたバージョン管理システムは、開発者にフラストレーションを与えるのではなく、開発者を支援するものでなければなりません。Git はこの10年でこの点では良くなってきましたが、まだまだ先は長いです。</target>
        </trans-unit>
        <trans-unit id="a83ebad2040aac26354ce69d33c75a8e23379288" translate="yes" xml:space="preserve">
          <source>Desire eternal life with all the passion of the spirit.</source>
          <target state="translated">魂の情熱をもって永遠の命を望みなさい。</target>
        </trans-unit>
        <trans-unit id="7cd8f751199e13822ef7d9714c88c6e47db10e8e" translate="yes" xml:space="preserve">
          <source>Despite the name, this function always returns a value between 0.0 and 1.0 equal to (</source>
          <target state="translated">名前にもかかわらず、この関数は常に 0.0 から 1.0 の間の値を返します。</target>
        </trans-unit>
        <trans-unit id="577ef7dc1516f4b3c43ddbe63327a8a039a0edec" translate="yes" xml:space="preserve">
          <source>Destroy</source>
          <target state="translated">Destroy</target>
        </trans-unit>
        <trans-unit id="839c441dcc29d361bfacf38afa416f18a1637928" translate="yes" xml:space="preserve">
          <source>Destroy A Prepared Statement Object</source>
          <target state="translated">準備されたステートメントオブジェクトの破棄</target>
        </trans-unit>
        <trans-unit id="8a43abf112611732f3dfb583fa8f44e2049379d4" translate="yes" xml:space="preserve">
          <source>Destroy a snapshot</source>
          <target state="translated">スナップショットの破棄</target>
        </trans-unit>
        <trans-unit id="7d83f3ed4b5d324ccef4af3b6f9a3539eb93e67c" translate="yes" xml:space="preserve">
          <source>Destroy the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;を使用して、&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;を破棄します。</target>
        </trans-unit>
        <trans-unit id="c75278c7e28535f5ea9e950ab84092bdea32a614" translate="yes" xml:space="preserve">
          <source>Destroy the object using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;を使用してオブジェクトを破棄します。</target>
        </trans-unit>
        <trans-unit id="64b1ed1f1b53763efdc1c78265116d5fa0da95e8" translate="yes" xml:space="preserve">
          <source>Destroy the object using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;を使用してオブジェクトを破棄します。</target>
        </trans-unit>
        <trans-unit id="5284d7d2a9c5b9dbf72aafe5558f4a26a439739f" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1afb291d062f0484331555f28baeeafd003c3dfa" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be5ef256fde14f27a6be2d2b33459ee64ab4a321" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1bc54ba31c2c513271f833dc8e2d60c1be1b1091" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="689b80c76ccc07fa3d2942a087706f3eef81d330" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;#sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c105a9f0c702f6cd4ef79cd3b0f385965920de3c" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed39236d0e8e7446d0cb599cd5b738b2811bcf10" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d822a3174515e8f21e47ce59b4339bb51f6db978" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f60221cb8d7f3a49adecb2493f31cebddcb5e00c" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e83f5c6e38c161fc2b5c1d7abe156cb9aad8f5f3" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41e4345992429802aea5872bac2716f7c77be8e3" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6b6c509cccb52d51368c6e4ebb375738475d8f0" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="359201cc8ce5eb69bceb0fd81af7a37ed2f96a48" translate="yes" xml:space="preserve">
          <source>Destructors: &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e0b565701116b40edb353da662ba766f93f65b1" translate="yes" xml:space="preserve">
          <source>Destructors: &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;, &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;</source>
          <target state="translated">デストラクタ：&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;、&lt;a href=&quot;close&quot;&gt;sqlite3_close_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="3ee5fd57c6234479272be39f53b7a756c8fad2c3" translate="yes" xml:space="preserve">
          <source>Details of the low-level B-tree format used in SQLite version 3.0 can be found in header comments to the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/btreeInt.h&quot;&gt;btreeInt.h&lt;/a&gt; source file and in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation.</source>
          <target state="translated">SQLiteバージョン3.0で使用される低レベルのBツリー形式の詳細は、&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/btreeInt.h&quot;&gt;btreeInt.h&lt;/a&gt;ソースファイルへのヘッダーコメントと&lt;a href=&quot;fileformat2&quot;&gt;ファイル形式の&lt;/a&gt;ドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="057c54e32daecfe5f3f91aea6c17b8880637989a" translate="yes" xml:space="preserve">
          <source>Detect integer overflow in abs().</source>
          <target state="translated">abs()で整数オーバーフローを検出。</target>
        </trans-unit>
        <trans-unit id="0cb93bae74fdeaac6fc236f4e82d733ebb774f3f" translate="yes" xml:space="preserve">
          <source>Determine If A Prepared Statement Has Been Reset</source>
          <target state="translated">作成されたステートメントがリセットされたかどうかの判断</target>
        </trans-unit>
        <trans-unit id="db966195ad1f618275836e22992513b99d0a007c" translate="yes" xml:space="preserve">
          <source>Determine If An SQL Statement Is Complete</source>
          <target state="translated">SQLステートメントが完全であるかどうかの判断</target>
        </trans-unit>
        <trans-unit id="625d5f335e20e089846651b3578340604a6b4c2f" translate="yes" xml:space="preserve">
          <source>Determine If An SQL Statement Writes The Database</source>
          <target state="translated">SQLステートメントがデータベースを書き込むかどうかの判断</target>
        </trans-unit>
        <trans-unit id="eb26a9bebe8d2e098f033d011256a86267629d8a" translate="yes" xml:space="preserve">
          <source>Determine If Virtual Table Column Access Is For UPDATE</source>
          <target state="translated">仮想テーブルのカラムアクセスがUPDATE用であるかどうかの判断</target>
        </trans-unit>
        <trans-unit id="5ad12b059791066c3ea756f7418d5b987aa492a2" translate="yes" xml:space="preserve">
          <source>Determine The Collation For a Virtual Table Constraint</source>
          <target state="translated">仮想テーブル制約の照合を決定する</target>
        </trans-unit>
        <trans-unit id="c8aa46b4240b68859dbf6ca40dcc17adbb0b5d9d" translate="yes" xml:space="preserve">
          <source>Determine The Number Of Foreign Key Constraint Violations</source>
          <target state="translated">外国人キー制約違反の数の決定</target>
        </trans-unit>
        <trans-unit id="3e28f586fecd10c20cfef343cf0e0a2554afa731" translate="yes" xml:space="preserve">
          <source>Determine The Virtual Table Conflict Policy</source>
          <target state="translated">仮想テーブル競合ポリシーの決定</target>
        </trans-unit>
        <trans-unit id="378e53b0c9705af12aa3d20a3dfea2de180d3964" translate="yes" xml:space="preserve">
          <source>Determine if a database is read-only</source>
          <target state="translated">データベースが読み取り専用かどうかの判断</target>
        </trans-unit>
        <trans-unit id="ec9ead520b9e56d263fd7de0b9b24771183e3061" translate="yes" xml:space="preserve">
          <source>Deterministic SQL Functions</source>
          <target state="translated">決定的なSQL関数</target>
        </trans-unit>
        <trans-unit id="96de162ae9388387b4d27ffd24dfdaec4b72faef" translate="yes" xml:space="preserve">
          <source>Developers report that SQLite is often faster than a client/server SQL database engine in this scenario. Database requests are serialized by the server, so concurrency is not an issue. Concurrency is also improved by &quot;database sharding&quot;: using separate database files for different subdomains. For example, the server might have a separate SQLite database for each user, so that the server can handle hundreds or thousands of simultaneous connections, but each SQLite database is only used by one connection.</source>
          <target state="translated">開発者の報告によると、このシナリオではクライアント/サーバ型のSQLデータベースエンジンよりもSQLiteの方が高速であることが多いとのことです。データベースのリクエストはサーバーによってシリアライズされるため、同時実行性は問題になりません。並行処理は「データベースのシャーディング」によっても改善されます。例えば、サーバーはユーザーごとに別々の SQLite データベースを持っているかもしれません。これにより、サーバーは何百、何千もの同時接続を処理することができますが、各 SQLite データベースは 1 つの接続でしか使用されません。</target>
        </trans-unit>
        <trans-unit id="b17665b2663239e18f10a989ee4b32e6490c33f2" translate="yes" xml:space="preserve">
          <source>Developers sometimes experience trouble debugging the 185,000-line-long amalgamation source file because some debuggers are only able to handle source code line numbers less than 32,768. The amalgamation source code runs fine. One just cannot single-step through it in a debugger.</source>
          <target state="translated">一部のデバッガは 32,768 未満のソースコードの行数しか扱えないため、185,000 行に及ぶアマルガムのソースファイルのデバッグに問題が発生することがあります。アマルガムのソースコードは正常に動作します。ただ、デバッガではシングルステップでは動作しません。</target>
        </trans-unit>
        <trans-unit id="db23e94c152c3c70f28ce4fd2250cf8e7e90d0ef" translate="yes" xml:space="preserve">
          <source>Device Characteristics</source>
          <target state="translated">デバイス特性</target>
        </trans-unit>
        <trans-unit id="10fe8e0881142639bc54f8ec9a79de4f49557439" translate="yes" xml:space="preserve">
          <source>Devote yourself frequently to prayer.</source>
          <target state="translated">頻繁に祈りに専念しましょう。</target>
        </trans-unit>
        <trans-unit id="d2bfc098e435319899700359a7c7ade5b2cceea5" translate="yes" xml:space="preserve">
          <source>Direct writes to &lt;a href=&quot;../vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xshadowname&quot;&gt;シャドウテーブル&lt;/a&gt;への直接書き込み。</target>
        </trans-unit>
        <trans-unit id="3ea4196b155e79b0ed2d425b768b9f76a1de7e8d" translate="yes" xml:space="preserve">
          <source>Direct writes to &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vtab#xshadowname&quot;&gt;シャドウテーブル&lt;/a&gt;への直接書き込み。</target>
        </trans-unit>
        <trans-unit id="d9d75aac27ba7c6d07be6644243da8087e5f97b8" translate="yes" xml:space="preserve">
          <source>Disable schema editing using &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = OFF&lt;/a&gt;を使用してスキーマ編集を無効にします。</target>
        </trans-unit>
        <trans-unit id="d741b71f5f87bb5b09855b9b7b964ab4719c4656" translate="yes" xml:space="preserve">
          <source>Disable the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; while reparsing the schema.</source>
          <target state="translated">スキーマの再解析中は、オーソライザー&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;コールバック&lt;/a&gt;を無効にします。</target>
        </trans-unit>
        <trans-unit id="2b94299f848122e7aa2027a43aba54a8bdf1eb66" translate="yes" xml:space="preserve">
          <source>Disable the use of posix_fallocate() on all (unix) systems unless the HAVE_POSIX_FALLOCATE compile-time option is used.</source>
          <target state="translated">コンパイル時オプション HAVE_POSIX_FALLOCATE が使用されていない限り、すべての (unix)システムで posix_fallocate()の使用を無効にします。</target>
        </trans-unit>
        <trans-unit id="dc4409d907665c9eda9e8c714ab538568a93fe4c" translate="yes" xml:space="preserve">
          <source>Disable the use of the strchrnul() C-library routine unless it is specifically enabled using the -DHAVE_STRCHRNULL compile-time option.</source>
          <target state="translated">コンパイル時オプション -DHAVE_STRCHRNULL を使用して特別に有効にしない限り、strchrchnul()C-library ルーチンの使用を無効にします。</target>
        </trans-unit>
        <trans-unit id="44313c14bb780bbf9fd9d83b8ed923886b89675b" translate="yes" xml:space="preserve">
          <source>Disabled optimization tests</source>
          <target state="translated">無効化された最適化テスト</target>
        </trans-unit>
        <trans-unit id="801e1c0ae6276f6c1470108fe61a442d30ca4372" translate="yes" xml:space="preserve">
          <source>Disabling mutexes at run-time is not as effective as disabling them at compile-time since SQLite still must do a test of a boolean variable to see if mutexes are enabled or disabled at each point where a mutex might be required. But there is still a performance advantage for disabling mutexes at run-time.</source>
          <target state="translated">ランタイムでミューテックスを無効にすることは、コンパイル時にミューテックスを無効にするよりも効果的ではありません。しかし、ランタイムでミューテックスを無効にする方がパフォーマンス的には有利です。</target>
        </trans-unit>
        <trans-unit id="db38b8db0ff11ad2083b7f6905b27367bbd64018" translate="yes" xml:space="preserve">
          <source>Disallow &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; in the &lt;a href=&quot;lang_with&quot;&gt;WITH clause&lt;/a&gt; of triggers and views. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/b918d4b4e546d&quot;&gt;b918d4b4e546d&lt;/a&gt;</source>
          <target state="translated">トリガーとビューの&lt;a href=&quot;lang_with&quot;&gt;WITH句の&lt;/a&gt;&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;を禁止します。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/b918d4b4e546d&quot;&gt;b918d4b4e546d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a4f5b6881f751cbf37ca7be8a10d5fc1ce5e931" translate="yes" xml:space="preserve">
          <source>Disallow control characters inside of strings in JSON. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6c9b5514077fed34551&quot;&gt;6c9b5514077fed34551&lt;/a&gt;.</source>
          <target state="translated">JSONの文字列内の制御文字を禁止します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/6c9b5514077fed34551&quot;&gt;6c9b5514077fed34551の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="4fbe5a75e7ecac67d383efc523453d8ca0e96ce9" translate="yes" xml:space="preserve">
          <source>Disallow leading zeros in numeric constants in JSON. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/b93be8729a895a528e2&quot;&gt;b93be8729a895a528e2&lt;/a&gt;.</source>
          <target state="translated">JSONの数値定数の先行ゼロを許可しません。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/b93be8729a895a528e2&quot;&gt;b93be8729a895a528e2の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="2630cbc2f1d0549bdb067048921921ca0d31c770" translate="yes" xml:space="preserve">
          <source>Disallow temporary indices on permanent tables.</source>
          <target state="translated">恒久的なテーブルの一時的なインデックスを禁止します。</target>
        </trans-unit>
        <trans-unit id="5acb0a0adde49aba96e6fc288d48b3950eb87672" translate="yes" xml:space="preserve">
          <source>Disallow the use of &quot;rowid&quot; in &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_with&quot;&gt;共通テーブル式&lt;/a&gt;での「ROWID」の使用を禁止します。</target>
        </trans-unit>
        <trans-unit id="664d42cee9dc2838800ae0429fea3975df123ee1" translate="yes" xml:space="preserve">
          <source>Disallow the use of &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; in the recursive part of a CTE. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e8275b415a2f03bee&quot;&gt;e8275b415a2f03bee&lt;/a&gt;</source>
          <target state="translated">CTEの再帰部分での&lt;a href=&quot;windowfunctions&quot;&gt;ウィンドウ関数&lt;/a&gt;の使用を禁止します。チケット&lt;a href=&quot;https://sqlite.org/src/info/e8275b415a2f03bee&quot;&gt;e8275b415a2f03bee&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="268c696f729a3bb7208ee6e45627908c164ce6fd" translate="yes" xml:space="preserve">
          <source>Disclose wrongful thoughts to your spiritual mentor.</source>
          <target state="translated">霊的な師匠に間違った考えを開示しましょう。</target>
        </trans-unit>
        <trans-unit id="df353315b1ac203fbf0fbde5acfa1d6dd139f099" translate="yes" xml:space="preserve">
          <source>Discontinue the use of posix_fallocate() on unix, as it does not work on all filesystems.</source>
          <target state="translated">すべてのファイルシステムで動作しないため、unix での posix_fallocate()の使用を中止しました。</target>
        </trans-unit>
        <trans-unit id="630ed0127b8c49cb6701137391eeab0c764d29db" translate="yes" xml:space="preserve">
          <source>Discontinue the use of thread-specific data for out-of-memory exception handling</source>
          <target state="translated">メモリ外例外処理のためのスレッド固有のデータの使用を中止します。</target>
        </trans-unit>
        <trans-unit id="dc4ca73be659333abaa3afecb8d712a96bb9f569" translate="yes" xml:space="preserve">
          <source>Disk I/O operations tends to be more sequential using WAL.</source>
          <target state="translated">ディスクのI/O操作はWALを使用してシーケンシャルになる傾向があります。</target>
        </trans-unit>
        <trans-unit id="875cf7c3c58abcb6b2af3c59e6f41f8c4ce9ca26" translate="yes" xml:space="preserve">
          <source>Distinctive Features Of SQLite</source>
          <target state="translated">SQLite の特徴的な機能</target>
        </trans-unit>
        <trans-unit id="f327b00a868bc2fc77c6168d0e2d509cf7d8a51a" translate="yes" xml:space="preserve">
          <source>Diverse content which might otherwise be stored as a &quot;pile-of-files&quot; is encapsulated into a single disk file for simpler transport via scp/ftp, USB stick, and/or email attachment.</source>
          <target state="translated">ファイルの山」として保存されている可能性のある多様なコンテンツは、単一のディスクファイルにカプセル化されており、scp/ftp、USBスティック、電子メールの添付ファイルを介してより簡単に転送することができます。</target>
        </trans-unit>
        <trans-unit id="104ed7c21cfc9b8ba11824e5729cef81f421e172" translate="yes" xml:space="preserve">
          <source>Divide</source>
          <target state="translated">Divide</target>
        </trans-unit>
        <trans-unit id="6a4bfffd32ff9d65b9739b01f6b92d5a2a406ec8" translate="yes" xml:space="preserve">
          <source>Divide the value in register P1 by the value in register P2 and store the result in register P3 (P3=P2/P1). If the value in register P1 is zero, then the result is NULL. If either input is NULL, the result is NULL.</source>
          <target state="translated">レジスタP1の値をレジスタP2の値で除算し、その結果をレジスタP3に格納します(P3=P2/P1)。レジスタP1の値が0の場合、結果はNULLとなる。どちらかの入力がNULLの場合、結果はNULLになります。</target>
        </trans-unit>
        <trans-unit id="4bd6c15a025907299e44072515501d69283cf065" translate="yes" xml:space="preserve">
          <source>Do an analysis of the currently open database. Store in register P1 the text of an error message describing any problems. If no problems are found, store a NULL in register P1.</source>
          <target state="translated">現在開いているデータベースの分析を行う。何か問題があれば、それを記述したエラーメッセージのテキストをレジスタP1に格納します。問題が見つからない場合は、NULLをレジスタP1に格納します。</target>
        </trans-unit>
        <trans-unit id="b58dc41668bbf2d2a5ac0f7843e60d1fd0b29a30" translate="yes" xml:space="preserve">
          <source>Do full-table scans using covering indices when possible, under the theory that an index will be smaller and hence can be scanned with less I/O.</source>
          <target state="translated">インデックスが小さくなるので、より少ないI/Oでスキャンできるという理論のもと、可能な限りカバリングインデックスを使用してフルテーブルスキャンを行います。</target>
        </trans-unit>
        <trans-unit id="d61e75c7c6aa57e44ccfb36bea2e0d2cd4826003" translate="yes" xml:space="preserve">
          <source>Do no wrong to anyone, and bear patiently wrongs done to yourself.</source>
          <target state="translated">誰にも間違ったことをしないように、そして自分自身に行われた過ちを辛抱強く耐えてください。</target>
        </trans-unit>
        <trans-unit id="c7acd87886221e65424bf1acce3086f3655acf30" translate="yes" xml:space="preserve">
          <source>Do not allocate a new page. Return NULL.</source>
          <target state="translated">新しいページを割り当てません。NULLを返します。</target>
        </trans-unit>
        <trans-unit id="d1baafbd29f15f73b5db2bd55006fe595ca88606" translate="yes" xml:space="preserve">
          <source>Do not allow dot-commands of the command-line shell to occur in the middle of a real SQL command.</source>
          <target state="translated">コマンドラインシェルのドットコマンドが実際のSQLコマンドの途中で発生しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="722464d20a4d3822872080ca5426f1791b661a71" translate="yes" xml:space="preserve">
          <source>Do not apply the WHERE-clause pushdown optimization on terms that originate in the ON or USING clause of a LEFT JOIN. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c2a19d81652f40568c&quot;&gt;c2a19d81652f40568c&lt;/a&gt;.</source>
          <target state="translated">LEFT JOINのON句またはUSING句に由来する用語には、WHERE句のプッシュダウン最適化を適用しないでください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/c2a19d81652f40568c&quot;&gt;c2a19d81652f40568cの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="9e626f7dec3803cf39b9ed3c8d4b8ddd26aa3a01" translate="yes" xml:space="preserve">
          <source>Do not apply the flattening optimization if the outer query is an aggregate and the inner query contains ORDER BY. (Ticket #2943)</source>
          <target state="translated">外側のクエリが集約で、内側のクエリにORDER BYが含まれている場合は、平坦化最適化を適用しないようにしてください。(チケット番号2943)</target>
        </trans-unit>
        <trans-unit id="47f951dc04aa5e685ae032b56eb35642da21ee4e" translate="yes" xml:space="preserve">
          <source>Do not attempt to use terms from the WHERE clause to enable indexed lookup of the right-hand table of a LEFT JOIN. Ticket &lt;a href=&quot;https://sqlite.org/src/info/4ba5abf65c5b0f9a96a7a&quot;&gt;4ba5abf65c5b0f9a96a7a&lt;/a&gt;</source>
          <target state="translated">LEFT JOINの右側のテーブルのインデックス付きルックアップを有効にするために、WHERE句の用語を使用しないでください。チケット&lt;a href=&quot;https://sqlite.org/src/info/4ba5abf65c5b0f9a96a7a&quot;&gt;4ba5abf65c5b0f9a96a7a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb440372f32dec89b9398b09a9e6e2779b9db126" translate="yes" xml:space="preserve">
          <source>Do not attempt to use the strchrnul() function from the standard C library unless the HAVE_STRCHRNULL compile-time option is set.</source>
          <target state="translated">コンパイル時オプション HAVE_STRCHRNULL が設定されていない限り、標準 C ライブラリの strchrnul()関数を使用しようとしないでください。</target>
        </trans-unit>
        <trans-unit id="b64adffd7b86aaa3092ff02c70021235bc894300" translate="yes" xml:space="preserve">
          <source>Do not be afraid to explore and experiment. Without a log-in you won't be able to push back any changes you make, so you cannot damage the project.</source>
          <target state="translated">探検したり、実験したりすることを恐れないでください。ログインしていないと、あなたが行った変更をプッシュバックすることができないので、プロジェクトにダメージを与えることはできません。</target>
        </trans-unit>
        <trans-unit id="d05159095924dcadc1e25110c5f5f929ebba2a2a" translate="yes" xml:space="preserve">
          <source>Do not be confused by the fact that a column might have a &quot;numeric&quot; datatype. This does not mean that the column can contain only numbers. It merely means that if the column does contain a number, that number will sort in numerical order.</source>
          <target state="translated">カラムが &quot;数値 &quot;のデータ型を持っている可能性があるという事実に惑わされないでください。これは、列が数字だけを含むことができるという意味ではありません。これは単に、列に数値が含まれている場合、その数値は数値順にソートされるということを意味しています。</target>
        </trans-unit>
        <trans-unit id="7b5c9cbefc6ca63f2b182857e9018d39b28c3534" translate="yes" xml:space="preserve">
          <source>Do not be misled by the &quot;Lite&quot; in the name. SQLite has a full-featured SQL implementation, including:</source>
          <target state="translated">名前の「Lite」に惑わされないでください。SQLiteには、以下のようなフル機能のSQLが実装されています。</target>
        </trans-unit>
        <trans-unit id="83ad576ed2750422c0fb9b979bec85d0e4fc99e1" translate="yes" xml:space="preserve">
          <source>Do not bear false witness.</source>
          <target state="translated">虚偽の証言をしてはいけません。</target>
        </trans-unit>
        <trans-unit id="dc340a536129d864cf116ede217fe057492374c8" translate="yes" xml:space="preserve">
          <source>Do not become attached to pleasures.</source>
          <target state="translated">快楽に執着してはいけない。</target>
        </trans-unit>
        <trans-unit id="47541d37d26b95f8c181a2dc345a039022162ef4" translate="yes" xml:space="preserve">
          <source>Do not commit adultery.</source>
          <target state="translated">不倫をしてはいけません。</target>
        </trans-unit>
        <trans-unit id="0527e2ce52914545d104d45569846431699a53a2" translate="yes" xml:space="preserve">
          <source>Do not confuse automatic indexes with the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; (having names like &quot;sqlite_autoindex_</source>
          <target state="translated">自動インデックスを&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部&lt;/a&gt;インデックスと混同しないでください（ &quot;sqlite_autoindex_</target>
        </trans-unit>
        <trans-unit id="5b87dbbc2f82f39fe5e094dea4061b8791b8238e" translate="yes" xml:space="preserve">
          <source>Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags with the &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=NORMAL and &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=FULL settings. The &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt; determines when calls to the xSync VFS method occur and applies uniformly across all platforms. The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how energetic or rigorous or forceful the sync operations are and only make a difference on Mac OSX for the default SQLite code. (Third-party VFS implementations might also make the distinction between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the operating systems natively supported by SQLite, only Mac OSX cares about the difference.)</source>
          <target state="translated">SQLITE_SYNC_NORMALフラグとSQLITE_SYNC_FULLフラグを&lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt; = NORMALおよび&lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt; = FULL設定と混同しないでください。&lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;同期プラグマは&lt;/a&gt; XSYNC VFSメソッドへの呼び出しが発生したときを判断し、すべてのプラットフォームにわたって一様に適用されます。 SQLITE_SYNC_NORMALフラグとSQLITE_SYNC_FULLフラグは、同期操作がどの程度精力的、または厳密、または強力であるかを決定し、デフォルトのSQLiteコードに対してMac OSXでのみ違いを生じさせます。 （サードパーティのVFS実装もSQLITE_SYNC_NORMALとSQLITE_SYNC_FULLを区別する場合がありますが、SQLiteでネイティブにサポートされているオペレーティングシステムの中で、Mac OSXのみが違いを考慮します。）</target>
        </trans-unit>
        <trans-unit id="002e1751e184528adf8c6f1d702e80e85446806a" translate="yes" xml:space="preserve">
          <source>Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags with the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=NORMAL and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=FULL settings. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt; determines when calls to the xSync VFS method occur and applies uniformly across all platforms. The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how energetic or rigorous or forceful the sync operations are and only make a difference on Mac OSX for the default SQLite code. (Third-party VFS implementations might also make the distinction between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the operating systems natively supported by SQLite, only Mac OSX cares about the difference.)</source>
          <target state="translated">SQLITE_SYNC_NORMALフラグとSQLITE_SYNC_FULLフラグを&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt; = NORMALおよび&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt; = FULL設定と混同しないでください。&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;同期プラグマは&lt;/a&gt; XSYNC VFSメソッドへの呼び出しが発生したときを判断し、すべてのプラットフォームにわたって一様に適用されます。 SQLITE_SYNC_NORMALフラグとSQLITE_SYNC_FULLフラグは、同期操作がどの程度精力的、または厳密、または強力であるかを決定し、デフォルトのSQLiteコードに対してMac OSXでのみ違いを生じさせます。 （サードパーティのVFS実装もSQLITE_SYNC_NORMALとSQLITE_SYNC_FULLを区別する場合がありますが、SQLiteでネイティブにサポートされているオペレーティングシステムの中で、Mac OSXのみが違いを考慮します。）</target>
        </trans-unit>
        <trans-unit id="ad2017a368e4acba6381b0a256f7226272260dc0" translate="yes" xml:space="preserve">
          <source>Do not count rows where the IGNORE conflict resolution occurs in the row count.</source>
          <target state="translated">行のカウントでIGNORE競合解決が発生している行はカウントしないでください。</target>
        </trans-unit>
        <trans-unit id="b7c755ee6b849cdf60ae59e908ab1fc867a27494" translate="yes" xml:space="preserve">
          <source>Do not covet.</source>
          <target state="translated">欲しがってはいけません。</target>
        </trans-unit>
        <trans-unit id="db62bb840a97eee5b8883ebcef3e582e3e673f43" translate="yes" xml:space="preserve">
          <source>Do not curse those who curse you, but rather bless them.</source>
          <target state="translated">あなたを呪う者を呪うのではなく、むしろ祝福しなさい。</target>
        </trans-unit>
        <trans-unit id="2d234151c3e9c3911335b0f3da32177b2942f1e3" translate="yes" xml:space="preserve">
          <source>Do not do to another what you would not have done to yourself.</source>
          <target state="translated">自分がしなかったことを他人にしてはいけません。</target>
        </trans-unit>
        <trans-unit id="acd5314ee2a0e4064ce9351ca89b05b07641e78e" translate="yes" xml:space="preserve">
          <source>Do not enable memory-mapped I/O. In other words, make sure that &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size=0&lt;/a&gt;.</source>
          <target state="translated">メモリマップI / Oを有効にしないでください。つまり、&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size = 0&lt;/a&gt;であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="034edd930627c1bd6308a4139c12b6665fcb2787" translate="yes" xml:space="preserve">
          <source>Do not entertain deceit in your heart.</source>
          <target state="translated">あなたの心に偽りを受け入れてはいけません。</target>
        </trans-unit>
        <trans-unit id="81fd74cab483c5a336f294ba599bad0042897a37" translate="yes" xml:space="preserve">
          <source>Do not escape the backslash '\' character in the output of the &lt;b&gt;sqlite&lt;/b&gt; command-line access program.</source>
          <target state="translated">&lt;b&gt;sqlite&lt;/b&gt;コマンドラインアクセスプログラムの出力では、バックスラッシュ「\」文字をエスケープしないでください。</target>
        </trans-unit>
        <trans-unit id="c890cde5441c19e16767be21e8b596d667fd4a4d" translate="yes" xml:space="preserve">
          <source>Do not even call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on a database connection from a child process if the connection was opened in the parent. It is safe to close the underlying file descriptor, but the &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; interface might invoke cleanup activities that will delete content out from under the parent, leading to errors and perhaps even database corruption.</source>
          <target state="translated">接続が親で開かれている場合は、子プロセスからのデータベース接続で&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;を呼び出さないでください。基礎となるファイル記述子を閉じても安全ですが、&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;インターフェースがクリーンアップアクティビティを呼び出し、親の下からコンテンツを削除して、エラーを引き起こし、場合によってはデータベースを破壊することさえあります。</target>
        </trans-unit>
        <trans-unit id="9842d9ca1b62003346b1050ca3868a78c6e6df5b" translate="yes" xml:space="preserve">
          <source>Do not flush the page cache (and thus avoiding a cache refill) unless another process changes the underlying database file.</source>
          <target state="translated">別のプロセスが基盤となるデータベースファイルを変更しない限り、ページキャッシュをフラッシュしないでください(したがって、キャッシュの再充填を回避できます)。</target>
        </trans-unit>
        <trans-unit id="2176e7264952425c2f250491ec533bbb7089a674" translate="yes" xml:space="preserve">
          <source>Do not forsake charity.</source>
          <target state="translated">慈善事業を見捨ててはいけない。</target>
        </trans-unit>
        <trans-unit id="bca45f5adbe0136828b61d27215211c39ce6b83c" translate="yes" xml:space="preserve">
          <source>Do not give a false peace.</source>
          <target state="translated">偽りの平和を与えてはならない。</target>
        </trans-unit>
        <trans-unit id="0fe47eb7b363d5a152896bf66373bc2d500a51a8" translate="yes" xml:space="preserve">
          <source>Do not give way to anger.</source>
          <target state="translated">怒りに屈してはいけません。</target>
        </trans-unit>
        <trans-unit id="3d1cede4ac2a286b898864b92bb8c0cd08137e3b" translate="yes" xml:space="preserve">
          <source>Do not love much or boisterous laughter.</source>
          <target state="translated">多くのことを愛してはいけませんし、騒々しい笑い声もありません。</target>
        </trans-unit>
        <trans-unit id="3c45d126a4940542085bf1e96a3ac522f5385ee4" translate="yes" xml:space="preserve">
          <source>Do not love much talking.</source>
          <target state="translated">多くの話を愛してはいけません。</target>
        </trans-unit>
        <trans-unit id="68cc3d30139a8559e135cd4c8f558235d11abccb" translate="yes" xml:space="preserve">
          <source>Do not love quarreling.</source>
          <target state="translated">喧嘩を愛してはいけない。</target>
        </trans-unit>
        <trans-unit id="629a7228998a89704c92b419f13085418997b310" translate="yes" xml:space="preserve">
          <source>Do not misunderstand: There is nothing technically wrong with displaying the error logger messages to end users. The messages do not contain sensitive or private information that must be protected from unauthorized viewing. Rather the messages are technical in nature and are not useful or meaningful to the typical end user. The messages coming from the error logger are intended for database geeks. Display them accordingly.</source>
          <target state="translated">誤解しないでください。エンド ユーザーにエラー ロガー メッセージを表示することに技術的に問題はありません。メッセージには、許可されていない閲覧から保護されなければならない機密情報や個人情報は含まれていません。むしろ、メッセージは本質的に技術的なものであり、一般的なエンド ユーザーにとっては有用ではなく、意味のあるものではありません。エラー ロガーからのメッセージは、データベース オタク向けのものです。それに応じて表示してください。</target>
        </trans-unit>
        <trans-unit id="8f8ddbae63c42651d375c0bd04cebf3413348f90" translate="yes" xml:space="preserve">
          <source>Do not murder.</source>
          <target state="translated">人を殺してはいけません。</target>
        </trans-unit>
        <trans-unit id="1f35225b21f15dae6087ed7eeacb7e2fc8285c86" translate="yes" xml:space="preserve">
          <source>Do not nurse a grudge.</source>
          <target state="translated">恨みをナメてはいけません。</target>
        </trans-unit>
        <trans-unit id="0a1c640222a0771668990edc889cc0113169d8ac" translate="yes" xml:space="preserve">
          <source>Do not open an SQLite database connection, then fork(), then try to use that database connection in the child process. All kinds of locking problems will result and you can easily end up with a corrupt database. SQLite is not designed to support that kind of behavior. Any database connection that is used in a child process must be opened in the child process, not inherited from the parent.</source>
          <target state="translated">SQLite データベース接続を開いてから fork()し、子プロセスでそのデータベース接続を使用しようとしないでください。あらゆる種類のロック問題が発生し、簡単に破損したデータベースになってしまう可能性があります。SQLite はそのような動作をサポートするように設計されていません。子プロセスで使用されるデータベース接続は、親プロセスから継承されるものではなく、子プロセスで開かれなければなりません。</target>
        </trans-unit>
        <trans-unit id="3df8aad94da73f8e621cafc5e1cbb5ccbe166028" translate="yes" xml:space="preserve">
          <source>Do not put write locks on the file used to hold TEMP tables.</source>
          <target state="translated">TEMPテーブルを保持するために使用するファイルに書き込みロックをかけないでください。</target>
        </trans-unit>
        <trans-unit id="167222828b6a7323e00470f04ccff91439f97f91" translate="yes" xml:space="preserve">
          <source>Do not read in the (meaningless) content of pages extracted from the freelist.</source>
          <target state="translated">フリーリストから抽出したページの(意味のない)内容を読み込まないこと。</target>
        </trans-unit>
        <trans-unit id="88443743067599e18c7d1c7b495b0aed7fcc56ac" translate="yes" xml:space="preserve">
          <source>Do not read the last page of an overflow chain when deleting the row - just add that page to the freelist.</source>
          <target state="translated">行を削除するときにオーバーフローチェーンの最後のページを読まないでください-そのページをフリーリストに追加するだけです。</target>
        </trans-unit>
        <trans-unit id="a7d06580230b34d6f8a726d493bee6f3225055ed" translate="yes" xml:space="preserve">
          <source>Do not require commas between constraints in CREATE TABLE statements.</source>
          <target state="translated">CREATE TABLE文では、制約間のカンマを必要としません。</target>
        </trans-unit>
        <trans-unit id="7fc4941b3cd021627fe69bb109677c3c3d923f4e" translate="yes" xml:space="preserve">
          <source>Do not return evil for evil.</source>
          <target state="translated">悪のために悪を返してはならない。</target>
        </trans-unit>
        <trans-unit id="21dd78a660444cf8065985daa16f5a53b2b94b26" translate="yes" xml:space="preserve">
          <source>Do not steal.</source>
          <target state="translated">盗んではいけません。</target>
        </trans-unit>
        <trans-unit id="ad5e34ebf9599545e50b3a0dc2ba3f44f88168b2" translate="yes" xml:space="preserve">
          <source>Do not store pages being deleted in the rollback journal.</source>
          <target state="translated">削除中のページをロールバックジャーナルに保存しないでください。</target>
        </trans-unit>
        <trans-unit id="4db470ddd81b2b754811d69f10c92e79bba57171" translate="yes" xml:space="preserve">
          <source>Do not swear, for fear of perjuring yourself.</source>
          <target state="translated">偽証を恐れて誓ってはいけません。</target>
        </trans-unit>
        <trans-unit id="ec7cd9078e5c61634a562846d1cb709ab20d0358" translate="yes" xml:space="preserve">
          <source>Do not use a partial index to do a table scan on an IN operator. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1d958d90596593a774&quot;&gt;1d958d90596593a774&lt;/a&gt;.</source>
          <target state="translated">IN演算子でテーブルスキャンを実行するために部分インデックスを使用しないでください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/1d958d90596593a774&quot;&gt;1d958d90596593a774&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20680b9a624f1f557a55b0811ddc984091848e37" translate="yes" xml:space="preserve">
          <source>Do not use the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; for a sub-query on the RHS of a LEFT JOIN if that subquery reads data from a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; as doing so prevents the query planner from creating &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; on the results of the sub-query, which can slow down the query.</source>
          <target state="translated">LEFT JOINのRHSでサブクエリに&lt;a href=&quot;optoverview#flattening&quot;&gt;フラット化最適化&lt;/a&gt;を使用しないでください。サブクエリが&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;からデータを読み取ると、クエリプランナーがサブクエリの結果に&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス&lt;/a&gt;を作成できなくなり、速度が低下する可能性があります。クエリをダウンします。</target>
        </trans-unit>
        <trans-unit id="f5a36cf13f2d75f5b1d063cbaf3e6dabed9e5e96" translate="yes" xml:space="preserve">
          <source>Do not wish to be called holy before one is holy; but first to be holy, that you may be truly so called.</source>
          <target state="translated">人が聖なる前に聖なる者と呼ばれることを望んではならない。</target>
        </trans-unit>
        <trans-unit id="5969cbceed42549abcad3776ee3d2a22161ed52f" translate="yes" xml:space="preserve">
          <source>Do not write changes to standard output. Instead, write a (binary) changeset file into FILE. The changeset can be interpreted using the sessions extension to SQLite.</source>
          <target state="translated">変更を標準出力に書き込まないでください。その代わりに、(バイナリの)チェンジセットファイルをFILEに書き込みます。チェンジセットはSQLiteのセッション拡張を使用して解釈することができます。</target>
        </trans-unit>
        <trans-unit id="9ab50d236c22af4547ec015790d6040a4642e45e" translate="yes" xml:space="preserve">
          <source>Do nothing. This instruction is often useful as a jump destination.</source>
          <target state="translated">何もしないでください。この指示は、ジャンプ先としてよく使われます。</target>
        </trans-unit>
        <trans-unit id="19eb9de9fe2776c399eac9b123129daec5f5dd94" translate="yes" xml:space="preserve">
          <source>Document Lists And Indexes</source>
          <target state="translated">文書リストとインデックス</target>
        </trans-unit>
        <trans-unit id="8c461e6b3d5184a9059cf94be86da7dbc747e4cf" translate="yes" xml:space="preserve">
          <source>Document Structure</source>
          <target state="translated">文書構造</target>
        </trans-unit>
        <trans-unit id="3a469072b5974a6ac1b0b86818461b57cc048dea" translate="yes" xml:space="preserve">
          <source>Document the hazards of type conversions in &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt; and related APIs. Fix unnecessary type conversions. Ticket #2321.</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_blob（）&lt;/a&gt;と関連するAPI で型変換の危険性を文書化します。不要な型変換を修正します。チケット＃2321。</target>
        </trans-unit>
        <trans-unit id="28ddcac222be4dd54f888cc20f015c092a5e040c" translate="yes" xml:space="preserve">
          <source>Document versioning</source>
          <target state="translated">ドキュメントのバージョン管理</target>
        </trans-unit>
        <trans-unit id="fe7304ab51248437db8b4b66ad9ad43f8b781a02" translate="yes" xml:space="preserve">
          <source>Documentation updates</source>
          <target state="translated">ドキュメントの更新</target>
        </trans-unit>
        <trans-unit id="e7eabf63bf0b622355ee7928fc5a397625e241a7" translate="yes" xml:space="preserve">
          <source>Documentation updates and typo fixes</source>
          <target state="translated">ドキュメントの更新とタイプミスの修正</target>
        </trans-unit>
        <trans-unit id="b3606774842986999d74ead8587f30081f764162" translate="yes" xml:space="preserve">
          <source>Documentation updates.</source>
          <target state="translated">ドキュメントの更新。</target>
        </trans-unit>
        <trans-unit id="b4f8a8a7e46cd0f4bef297d6b523710d4bbf11e1" translate="yes" xml:space="preserve">
          <source>Documentation updates. Mostly fixing of typos and spelling errors.</source>
          <target state="translated">ドキュメントの更新。主に誤字脱字やスペルミスの修正。</target>
        </trans-unit>
        <trans-unit id="2014de1c64e4558d3e684536a5eead31d8646480" translate="yes" xml:space="preserve">
          <source>Documented support for the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt;. This feature has actually been in the code since &lt;a href=&quot;#version_3_7_9&quot;&gt;version 3.7.9&lt;/a&gt; but is only now considered to be officially supported.</source>
          <target state="translated">&lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4コンテンツオプションの&lt;/a&gt;サポートの文書化。この機能は実際には&lt;a href=&quot;#version_3_7_9&quot;&gt;バージョン3.7.9&lt;/a&gt;以降のコードに含まれていますが、正式にサポートされるようになったのは、現在のところです。</target>
        </trans-unit>
        <trans-unit id="1141953a3cac893e565c0cb7afc09130be28d815" translate="yes" xml:space="preserve">
          <source>Does SQLite support a BLOB type?</source>
          <target state="translated">SQLiteはBLOB型をサポートしていますか?</target>
        </trans-unit>
        <trans-unit id="d7ac8ab68849b9ef0f13b08bdcc3c9b49215d5ba" translate="yes" xml:space="preserve">
          <source>Does SQLite support foreign keys?</source>
          <target state="translated">SQLiteは外部キーをサポートしていますか?</target>
        </trans-unit>
        <trans-unit id="e2a8b45f99cb6f35744147d23ba67820b9196a7e" translate="yes" xml:space="preserve">
          <source>Does not support ZIP archives that span multiple files.</source>
          <target state="translated">複数のファイルにまたがる ZIP アーカイブには対応していません。</target>
        </trans-unit>
        <trans-unit id="f67d427a021b49d829af064322fcd164d0d520fe" translate="yes" xml:space="preserve">
          <source>Does not support encryption.</source>
          <target state="translated">暗号化には対応していません。</target>
        </trans-unit>
        <trans-unit id="a182c94fa152e112192c0491165a8fdd3fd894bc" translate="yes" xml:space="preserve">
          <source>Does not support zip64 extensions.</source>
          <target state="translated">zip64の拡張子には対応していません。</target>
        </trans-unit>
        <trans-unit id="266906722673b9d89a70b9366dca968b0e3c9bf4" translate="yes" xml:space="preserve">
          <source>Dot-commands do not recognize comments.</source>
          <target state="translated">ドットコマンドはコメントを認識しません。</target>
        </trans-unit>
        <trans-unit id="8a31aee94d3aa206ec99f016bf029e559e48bfac" translate="yes" xml:space="preserve">
          <source>Dot-file locking style. This locking style is used when neither flock nor POSIX locking styles are supported by the file system. Database locks are obtained by creating and entry in the file-system at a well-known location relative to the database file (a &quot;dot-file&quot;) and relinquished by deleting the same file.</source>
          <target state="translated">ドットファイルのロックスタイル。このロックスタイルは、ファイルシステムがフロックもPOSIXロックスタイルもサポートしていない場合に使用されます。データベースロックは、データベースファイル(&quot;ドットファイル&quot;)からの相対的なよく知られた場所でファイルシステム内に作成してエントリすることで得られ、同じファイルを削除することで放棄されます。</target>
        </trans-unit>
        <trans-unit id="5886a74b53398ec47ad06e2d60de33d78d94131a" translate="yes" xml:space="preserve">
          <source>Double-Quoted Strings Allowed</source>
          <target state="translated">二重引用符付き弦の使用が可能</target>
        </trans-unit>
        <trans-unit id="9527eaee4dc6adf69520b29f63dfd254ba6893eb" translate="yes" xml:space="preserve">
          <source>Double-quoted strings interpreted as column names not text literals.</source>
          <target state="translated">二重引用符で囲まれた文字列は、テキストリテラルではなく列名として解釈されます。</target>
        </trans-unit>
        <trans-unit id="ffe7363e8f5e47f6d5cff2a021a49b0ba15973c3" translate="yes" xml:space="preserve">
          <source>Download The Code</source>
          <target state="translated">コードのダウンロード</target>
        </trans-unit>
        <trans-unit id="2bf81ffb06a97ae87b64f9122c76cd7ce2c19062" translate="yes" xml:space="preserve">
          <source>Download the self-contained Fossil executable from &lt;a href=&quot;https://fossil-scm.org/fossil/uv/download.html&quot;&gt;https://fossil-scm.org/fossil/uv/download.html&lt;/a&gt; and put the executable somewhere on your $PATH.</source>
          <target state="translated">自己完結型のFossil実行可能ファイルを&lt;a href=&quot;https://fossil-scm.org/fossil/uv/download.html&quot;&gt;https://fossil-scm.org/fossil/uv/download.html&lt;/a&gt;からダウンロードし、実行可能ファイルを$ PATHのどこかに配置します。</target>
        </trans-unit>
        <trans-unit id="bf164a21eb062e18af9a991c052f3c70484a26df" translate="yes" xml:space="preserve">
          <source>Dozens of minor bug fixes</source>
          <target state="translated">数十のマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="a929098ee87888960431567bedaf2f19daf292b0" translate="yes" xml:space="preserve">
          <source>Drop all support for the &lt;a href=&quot;malloc#memsysx&quot;&gt;experimental memory allocators&lt;/a&gt; memsys4 and memsys6.</source>
          <target state="translated">&lt;a href=&quot;malloc#memsysx&quot;&gt;試験的なメモリアロケータ&lt;/a&gt; memsys4およびmemsys6のサポートをすべて削除します。</target>
        </trans-unit>
        <trans-unit id="1f3f7deb8c2edee3371b95381860beff36c9b366" translate="yes" xml:space="preserve">
          <source>Drop built-in support for OS/2. If you need to upgrade an OS/2 application to use this or a later version of SQLite, then add an application-defined &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface. The code removed in this release can serve as a baseline for the application-defined VFS.</source>
          <target state="translated">OS / 2の組み込みサポートを削除します。このバージョンまたはそれ以降のバージョンのSQLiteを使用するようにOS / 2アプリケーションをアップグレードする必要がある場合は、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;インターフェースを使用してアプリケーション定義の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を追加します。このリリースで削除されたコードは、アプリケーション定義のVFSのベースラインとして機能します。</target>
        </trans-unit>
        <trans-unit id="c3e9878b7430ec40bb0aac87c5455cd33a663347" translate="yes" xml:space="preserve">
          <source>Drop old table</source>
          <target state="translated">古いテーブルを落とす</target>
        </trans-unit>
        <trans-unit id="831cee7fe7313360794c461d24e27019d0aa0fa8" translate="yes" xml:space="preserve">
          <source>Drop support for SQLITE_ENABLE_TREE_EXPLAIN. The SELECTTRACE mechanism provides more useful diagnostics information.</source>
          <target state="translated">SQLITE_ENABLE_TREE_EXPLAIN のサポートを削除します。SELECTTRACE メカニズムは、より有用な診断情報を提供します。</target>
        </trans-unit>
        <trans-unit id="0bd2f0f029e99d0a73743bc173e5b08aa4ae2984" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks but retain the SHARED lock.</source>
          <target state="translated">EXCLUSIVEロックとPENDINGロックを削除しますが、SHAREDロックは保持します。</target>
        </trans-unit>
        <trans-unit id="cece823a856676f78f4a41646b3bcd314a06e9ba" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks from all database files.</source>
          <target state="translated">すべてのデータベースファイルからEXCLUSIVEロックとPENDINGロックを削除します。</target>
        </trans-unit>
        <trans-unit id="41ede7277f5fa3c98b30f351e4b2a0728bbb7eac" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks from the database file.</source>
          <target state="translated">データベースファイルからEXCLUSIVEロックとPENDINGロックを削除します。</target>
        </trans-unit>
        <trans-unit id="daced6c943d50569fdbed0b8c852df4819f96d8b" translate="yes" xml:space="preserve">
          <source>Drop the old table X: &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE X&lt;/a&gt;.</source>
          <target state="translated">古いテーブルX：&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE Xを&lt;/a&gt;ドロップします。</target>
        </trans-unit>
        <trans-unit id="0e57de85bbf5c15a59892ff50c8f7c01032ec317" translate="yes" xml:space="preserve">
          <source>DropIndex</source>
          <target state="translated">DropIndex</target>
        </trans-unit>
        <trans-unit id="4a8749bce90b847b8afa8914da8c1204a28e572c" translate="yes" xml:space="preserve">
          <source>DropTable</source>
          <target state="translated">DropTable</target>
        </trans-unit>
        <trans-unit id="5194da2ad6f6b74ff6082f247ce4ac8437a9ce02" translate="yes" xml:space="preserve">
          <source>DropTrigger</source>
          <target state="translated">DropTrigger</target>
        </trans-unit>
        <trans-unit id="e5c413032a9c5e630e19fe262e62d7fb21ec3a73" translate="yes" xml:space="preserve">
          <source>Dropped support for the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt;コンパイル時オプションのサポートを終了しました。</target>
        </trans-unit>
        <trans-unit id="13fc6ee3a5aa40fdb0e1d5ecf732cd2ab210b40a" translate="yes" xml:space="preserve">
          <source>Duplicate ephemeral cursors are used for self-joins of materialized views.</source>
          <target state="translated">重複したエフェメラルカーソルは、マテリアライズされたビューの自己結合に使用されます。</target>
        </trans-unit>
        <trans-unit id="22bb6bc640d9e76642a03f301228df50bc0c544a" translate="yes" xml:space="preserve">
          <source>Duplicate row returned on a query against a table with more than 16 indices, each on a separate column, and all used via OR-connected constraints. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/10fb063b11&quot;&gt;10fb063b11&lt;/a&gt;</source>
          <target state="translated">16を超えるインデックスを持つテーブルに対するクエリで返される重複した行で、それぞれが個別の列にあり、すべてOR接続制約を介して使用されます。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/10fb063b11&quot;&gt;10fb063b11&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93d7730f8826a2d54d04e212d85d32152f0ff3ce" translate="yes" xml:space="preserve">
          <source>During a transaction, SQLite stores additional information in a second file called the &quot;rollback journal&quot;, or if SQLite is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, a write-ahead log file.</source>
          <target state="translated">トランザクション中に、SQLiteは追加情報を「ロールバックジャーナル」と呼ばれる2番目のファイルに保存します。SQLiteが&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt;場合は、先行書き込みログファイルを保存します。</target>
        </trans-unit>
        <trans-unit id="d30f21585fed5c23f99fb922e9805bc00a1eabdf" translate="yes" xml:space="preserve">
          <source>During a transaction, some of the data written to an FTS table may be cached in memory and written to the database only when the transaction is committed. However the implementation of the fts4aux module is only able to read data from the database. In practice this means that if an fts4aux table is queried from within a transaction in which the associated FTS table has been modified, the results of the query are likely to reflect only a (possibly empty) subset of the changes made.</source>
          <target state="translated">トランザクションの間、FTSテーブルに書き込まれたデータの一部はメモリにキャッシュされ、トランザクションがコミットされたときにのみデータベースに書き込まれるかもしれません。しかし、fts4auxモジュールの実装は、データベースからデータを読み出すことしかできません。実際には、これは関連するFTSテーブルが変更されたトランザクション内から fts4auxテーブルが問い合わせられた場合、問い合わせの結果は変更された内容の(おそらく空の)サブセットのみを反映する可能性が高いことを意味します。</target>
        </trans-unit>
        <trans-unit id="ad42e3b2740327c2dba977f94946673b656caef3" translate="yes" xml:space="preserve">
          <source>During most testing, however, these macros will throw an assertion fault if their argument does not have the expected truth value. This alerts the developers quickly to incorrect design assumptions.</source>
          <target state="translated">しかし、ほとんどのテストでは、これらのマクロの引数が期待される真理値を持っていない場合、アサーション・フォールトをスローします。これにより、開発者は設計上の仮定が間違っていることに素早く気づくことができます。</target>
        </trans-unit>
        <trans-unit id="12f7d01f7aef91494af4f6f7a834f78084a02691" translate="yes" xml:space="preserve">
          <source>During part of SQLite's INSERT and SELECT processing, the complete content of each row in the database is encoded as a single BLOB. So the SQLITE_MAX_LENGTH parameter also determines the maximum number of bytes in a row.</source>
          <target state="translated">SQLiteのINSERTおよびSELECT処理の一部では、データベース内の各行の完全な内容が1つのBLOBとしてエンコードされます。そのため、SQLITE_MAX_LENGTH パラメータは、行の最大バイト数も決定します。</target>
        </trans-unit>
        <trans-unit id="11df476623628b473251d2d86924a52d99a7ec80" translate="yes" xml:space="preserve">
          <source>During recovery of the global shared-memory WAL-index, exclusive locks are held on WAL_WRITE_LOCK, WAL_CKPT_LOCK, WAL_RECOVER_LOCK, and WAL_READ_LOCK(1) through WAL_READ_LOCK(4). In other words, all locks associated with the WAL-index except for WAL_READ_LOCK(0) are held exclusively. This prevents any other thread from writing the database and from reading any transactions that are held in the WAL, until the recovery is complete.</source>
          <target state="translated">グローバル共有メモリWAL-indexの復旧時には、WAL_WRITE_LOCK、WAL_CKPT_LOCK、WAL_RECOVER_LOCK、WAL_READ_LOCK(1)~WAL_READ_LOCK(4)に排他的なロックが保持される。つまり、WAL_READ_LOCK(0)以外のWAL-indexに関連付けられた全てのロックは排他的に保持される。これにより、復旧が完了するまで、他のスレッドがデータベースを書き込んだり、WALに保持されているトランザクションを読み込んだりすることができなくなります。</target>
        </trans-unit>
        <trans-unit id="1358f8df690459d3328e508cecf523a429f80164" translate="yes" xml:space="preserve">
          <source>During testing, the SQLite library is compiled with special instrumentation that allows the test scripts to simulate a wide variety of failures in order to verify that SQLite recovers correctly. Memory allocation is carefully tracked and no memory leaks occur, even following memory allocation failures. A custom VFS layer is used to simulate operating system crashes and power failures in order to ensure that transactions are atomic across these events. A mechanism for deliberately injecting I/O errors shows that SQLite is resilient to such malfunctions. (As an experiment, try inducing these kinds of errors on other SQL database engines and see what happens!)</source>
          <target state="translated">テスト中、SQLite ライブラリは、SQLite が正しく回復することを検証するために、テスト スクリプトがさまざまな障害をシミュレートできるように、特別な計装を用いてコンパイルされています。メモリ割り当ては慎重に追跡され、メモリ割り当てに失敗した場合でもメモリリークは発生しません。カスタムの VFS レイヤーを使用してオペレーティングシステムのクラッシュや電源障害をシミュレートし、これらのイベント間でトランザクションがアトミックになるようにしています。意図的に I/O エラーを注入するメカニズムは、SQLite がそのような誤動作に強いことを示しています(実験として、I/O エラーを注入してみてください)。(実験として、他の SQL データベースエンジンでこの種のエラーを発生させてみて、何が起こるか見てみましょう。)</target>
        </trans-unit>
        <trans-unit id="083eeb3cf3761acd0b9b1944cd026822ab96a1ec" translate="yes" xml:space="preserve">
          <source>During the 250 ms sleep in step 3 above, no read-lock is held on the database file and the mutex associated with pDb is not held. This allows other threads to use &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pDb and other connections to write to the underlying database file.</source>
          <target state="translated">上記のステップ3の250ミリ秒のスリープ中、データベースファイルの読み取りロックは保持されず、pDbに関連付けられたミューテックスは保持されません。これにより、他のスレッドが&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt; pDbと他の接続を使用して、基になるデータベースファイルに書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="5bc5d8e5dea4ffc98e00ec0c1ec074dd1e7d3ff2" translate="yes" xml:space="preserve">
          <source>During the conclusion of a</source>
          <target state="translated">の結論の間に</target>
        </trans-unit>
        <trans-unit id="fe8ce31db6eecdb3f85f2298aa1ab49d66128d02" translate="yes" xml:space="preserve">
          <source>Dynamic Memory Allocation</source>
          <target state="translated">動的メモリ割り当て</target>
        </trans-unit>
        <trans-unit id="720d5bb7b021bd57042c2b5aa6c65c1226f1ffcd" translate="yes" xml:space="preserve">
          <source>Dynamic Memory Allocation In SQLite</source>
          <target state="translated">SQLite での動的なメモリ割り当て</target>
        </trans-unit>
        <trans-unit id="6a1ec417f9656bfa58ac913f9a623361c31817a1" translate="yes" xml:space="preserve">
          <source>Dynamic String Object</source>
          <target state="translated">動的文字列オブジェクト</target>
        </trans-unit>
        <trans-unit id="75da5571b32189815fa4662789976e48c0ca6b04" translate="yes" xml:space="preserve">
          <source>Dynamic analysis refers to internal and external checks on the SQLite code which are performed while the code is live and running. Dynamic analysis has proven to be a great help in maintaining the quality of SQLite.</source>
          <target state="translated">動的解析とは、SQLite コードの内部および外部チェックのことで、コードがライブで実行されている間に実行されます。動的解析はSQLiteの品質を維持する上で大きな助けとなることが証明されています。</target>
        </trans-unit>
        <trans-unit id="a5cb0906656acf2bda3bc32fbfc18bd37f772de3" translate="yes" xml:space="preserve">
          <source>Dynamic and static analysis of the code</source>
          <target state="translated">コードの動的および静的解析</target>
        </trans-unit>
        <trans-unit id="758e372147a13eab85e0e2348816aeca5a5cf87b" translate="yes" xml:space="preserve">
          <source>Dynamically Typed Value Object</source>
          <target state="translated">動的型付き値オブジェクト</target>
        </trans-unit>
        <trans-unit id="dd5afbce0893bc1f40078bd68b471379645389da" translate="yes" xml:space="preserve">
          <source>EACH</source>
          <target state="translated">EACH</target>
        </trans-unit>
        <trans-unit id="bf4cc46f7f1441b1500c1ac4cef239d17020ff30" translate="yes" xml:space="preserve">
          <source>ELSE</source>
          <target state="translated">ELSE</target>
        </trans-unit>
        <trans-unit id="d205abee3d2a71688a6b66568be289a94050031c" translate="yes" xml:space="preserve">
          <source>END</source>
          <target state="translated">END</target>
        </trans-unit>
        <trans-unit id="79e27d141723fbb1d4275c9dc81bef88d08e1858" translate="yes" xml:space="preserve">
          <source>END TRANSACTION</source>
          <target state="translated">トランザクション終了</target>
        </trans-unit>
        <trans-unit id="4351e320e43aa32eebed42b35b21b2097a23c049" translate="yes" xml:space="preserve">
          <source>END TRANSACTION is an alias for COMMIT.</source>
          <target state="translated">END TRANSACTIONはCOMMITの別名です。</target>
        </trans-unit>
        <trans-unit id="01dce0e5ecf8d5b17ab6b7c1ca9a8662e220cefd" translate="yes" xml:space="preserve">
          <source>EPUB - The Electronic Publication format used by non-Kindle eBooks</source>
          <target state="translated">EPUB-Kindle以外の電子書籍で使用される電子出版フォーマット</target>
        </trans-unit>
        <trans-unit id="ac47189c9768197d8574c8f14988b8ef7e5d8f6d" translate="yes" xml:space="preserve">
          <source>ESCAPE</source>
          <target state="translated">ESCAPE</target>
        </trans-unit>
        <trans-unit id="c23142c6f147963dd2685f230238ef6772802e99" translate="yes" xml:space="preserve">
          <source>EXCEPT</source>
          <target state="translated">EXCEPT</target>
        </trans-unit>
        <trans-unit id="9cb33cc90a8a55873e7bc639c8e97e85186cc428" translate="yes" xml:space="preserve">
          <source>EXCLUDE</source>
          <target state="translated">EXCLUDE</target>
        </trans-unit>
        <trans-unit id="6a142f6999680571fa05b1a87552e101c1e3b874" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE</source>
          <target state="translated">EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="e374cc411cf56ba9d22e8a8dfb723b4ab3e4424c" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE is similar to IMMEDIATE in that a write transaction is started immediately. EXCLUSIVE and IMMEDIATE are the same in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, but in other journaling modes, EXCLUSIVE prevents other database connections from reading the database while the transaction is underway.</source>
          <target state="translated">EXCLUSIVEは、書き込みトランザクションがすぐに開始されるという点でIMMEDIATEに似ています。EXCLUSIVEとIMMEDIATEは&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;でも同じですが、他のジャーナリングモードでは、EXCLUSIVEはトランザクションの進行中に他のデータベース接続がデータベースを読み取るのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="644b5806e118fe0af3936c64572a1496ddda7507" translate="yes" xml:space="preserve">
          <source>EXISTS</source>
          <target state="translated">EXISTS</target>
        </trans-unit>
        <trans-unit id="4f7eee905948e6076168f8edbc3bf97ae8823930" translate="yes" xml:space="preserve">
          <source>EXPLAIN</source>
          <target state="translated">EXPLAIN</target>
        </trans-unit>
        <trans-unit id="2fbf78b206db15c2139a66a9634e3bf1d2176ccc" translate="yes" xml:space="preserve">
          <source>EXPLAIN QUERY PLAN</source>
          <target state="translated">EXPLAIN QUERY PLAN</target>
        </trans-unit>
        <trans-unit id="38addf8721d2c74e08b308b7b8b2dd7a72f15eb2" translate="yes" xml:space="preserve">
          <source>EXPLAIN QUERY PLAN is most useful on a SELECT statement, but may also appear with other statements that read data from database tables (e.g. UPDATE, DELETE, INSERT INTO ... SELECT).</source>
          <target state="translated">EXPLAIN QUERY PLANは、SELECT文で最も便利ですが、データベーステーブルからデータを読み込む他の文(UPDATE、DELETE、INSERT INTO ...SELECTなど)でも表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="8e9da9a85266351f71e77f3e9609cc22715ef94e" translate="yes" xml:space="preserve">
          <source>EXPLAIN operates at run-time, not at prepare-time</source>
          <target state="translated">EXPLAINは準備時ではなく実行時に動作します。</target>
        </trans-unit>
        <trans-unit id="18fd69d15aa01be81ef0e1d97815be761eb30270" translate="yes" xml:space="preserve">
          <source>EXTRA synchronous is like FULL with the addition that the directory containing a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; is synced after that journal is unlinked to commit a transaction in DELETE mode. EXTRA provides additional durability if the commit is followed closely by a power loss.</source>
          <target state="translated">EXTRA同期はFULLに似ていますが、&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;を含むディレクトリは、DELETEモードでトランザクションをコミットするためにそのジャーナルがリンク解除された後に同期されます。EXTRAは、コミットの後に電力損失が続く場合に、耐久性を向上させます。</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="483d2106efe09daa894eea6a0c9033d9a67cc38c" translate="yes" xml:space="preserve">
          <source>Each 5-byte entry on a ptrmap page provides back-link information about one of the pages that immediately follow the pointer map. If page B is a ptrmap page then back-link information about page B+1 is provided by the first entry on the pointer map. Information about page B+2 is provided by the second entry. And so forth.</source>
          <target state="translated">ptrmapページの各5バイトのエントリは、ポインタマップの直後に続くページの1つに関するバックリンク情報を提供する。ページBがptrmapページの場合、ページB+1に関するバックリンク情報は、ポインタマップの最初のエントリによって提供される。ページB+2に関する情報は、2番目のエントリによって提供される。といった具合です。</target>
        </trans-unit>
        <trans-unit id="1aabd87ca95da90a5c129eaf9247506c8bd66646" translate="yes" xml:space="preserve">
          <source>Each 5-byte ptrmap entry consists of one byte of &quot;page type&quot; information followed by a 4-byte big-endian page number. Five page types are recognized:</source>
          <target state="translated">各5バイトのptrmapエントリは、1バイトの「ページタイプ」情報と4バイトのビッグエンディアンページ番号で構成される。5 つのページタイプが認識される。</target>
        </trans-unit>
        <trans-unit id="9a01146dc5470d97274ce8927b43f8fec82d7371" translate="yes" xml:space="preserve">
          <source>Each DELETE change is changed to an INSERT, and</source>
          <target state="translated">各DELETE変更はINSERTに変更され</target>
        </trans-unit>
        <trans-unit id="eeb9033e1e45a2bbbcad76e978600d892c37b372" translate="yes" xml:space="preserve">
          <source>Each INSERT change is changed to a DELETE, and</source>
          <target state="translated">各INSERT変更はDELETEに変更され</target>
        </trans-unit>
        <trans-unit id="7b99091b54756df2ed9f1a0564ab23ebb66063ec" translate="yes" xml:space="preserve">
          <source>Each ORDER BY expression is processed as follows:</source>
          <target state="translated">各ORDER BY式は以下のように処理されます。</target>
        </trans-unit>
        <trans-unit id="90ec8a858058608d92c79ea2b4e9e7b9bbccd9eb" translate="yes" xml:space="preserve">
          <source>Each SQL index, whether explicitly declared via a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement or implied by a UNIQUE or PRIMARY KEY constraint, corresponds to an index b-tree in the database file. Each entry in the index b-tree corresponds to a single row in the associated SQL table. The key to an index b-tree is a record composed of the columns that are being indexed followed by the key of the corresponding table row. For ordinary tables, the row key is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, and for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables the row key is the PRIMARY KEY. Because every row in the table has a unique row key, all keys in an index are unique.</source>
          <target state="translated">各SQLインデックスは、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントで明示的に宣言されているか、UNIQUEまたはPRIMARY KEY制約によって暗示されているかに関係なく、データベースファイル内のインデックスBツリーに対応しています。インデックスBツリーの各エントリは、関連付けられたSQLテーブルの1つの行に対応しています。インデックスBツリーのキーは、インデックスが付けられている列とそれに対応するテーブル行のキーで構成されるレコードです。通常のテーブルの場合、行キーは&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;であり、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの場合、行キーはPRIMARY KEYです。テーブルのすべての行には一意の行キーがあるため、インデックスのすべてのキーは一意です。</target>
        </trans-unit>
        <trans-unit id="972d3bbdff7b7be08051158b4855057f49ea49cd" translate="yes" xml:space="preserve">
          <source>Each SQL statement in the statement list is an instance of the following:</source>
          <target state="translated">ステートメントリストの各SQL文は、以下のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="8780624428063f8d9d37cbf9ecae097671b04573" translate="yes" xml:space="preserve">
          <source>Each SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; records cases when the query planner would benefit from having accurate results of ANALYZE at hand. These records are held in memory and accumulate over the life of a database connection. The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command looks at those records and runs ANALYZE on only those tables for which new or updated ANALYZE data seems likely to be useful. In most cases &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; will not run ANALYZE, but it will occasionally do so either for tables that have never before been analyzed, or for tables that have grown significantly since they were last analyzed.</source>
          <target state="translated">各SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、クエリプランナーがANALYZEの正確な結果を手に入れることで利益を得るケースを記録します。これらのレコードはメモリに保持され、データベース接続の存続期間にわたって蓄積されます。&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA最適化&lt;/a&gt;それらの記録と実行のコマンドルックスは、新規またはANALYZE更新されたデータは有用であると思われるテーブルだけを上ANALYZE。ほとんどの場合、&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA最適化&lt;/a&gt;はANALYZEを実行しませんが、これまで分析されたことがないテーブル、または最後に分析されてから大幅に増加したテーブルのいずれかで実行されることがあります。</target>
        </trans-unit>
        <trans-unit id="830748b5154094e00d6f1556c43a3fc63fc4833c" translate="yes" xml:space="preserve">
          <source>Each VFS implementation will subclass the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; by adding additional fields at the end to hold whatever information the VFS needs to know about an open file. It does not matter what information is stored as long as the total size of the structure does not exceed the szOsFile value recorded in the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">各VFS実装は、VFSが開いているファイルについて知る必要のある情報を保持するために末尾に追加のフィールドを追加することにより、&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;をサブクラス化します。構造体の合計サイズが&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトに記録されたszOsFile値を超えない限り、どの情報が保存されていてもかまいません。</target>
        </trans-unit>
        <trans-unit id="096a69c85e04b646e0b565d9908edc0c892b7052" translate="yes" xml:space="preserve">
          <source>Each argument specified as part of a &quot;CREATE VIRTUAL TABLE ... USING fts5 ...&quot; statement is either a column declaration or a configuration option. A &lt;b&gt;column declaration&lt;/b&gt; consists of one or more whitespace separated FTS5 barewords or string literals quoted in any manner acceptable to SQLite.</source>
          <target state="translated">「CREATE VIRTUAL TABLE ... USING fts5 ...」ステートメントの一部として指定された各引数は、列宣言または構成オプションのいずれかです。&lt;b&gt;カラムの宣言は、&lt;/b&gt; SQLiteのに許容される任意の様式で引用FTS5裸の単語または文字列リテラルを分離空白一つ以上から成ります。</target>
        </trans-unit>
        <trans-unit id="c100bec1aacd96fc583726f3228e69edd0918c29" translate="yes" xml:space="preserve">
          <source>Each call to &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; affects subsequent database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Database connections that already exist are unaffected. Each call to &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; overrides all previous calls within the same process.</source>
          <target state="translated">各コール&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）は&lt;/a&gt;、後続のデータベース接続を使用して作成した影響&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（） &lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（） &lt;/a&gt;、または&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）を&lt;/a&gt;。すでに存在するデータベース接続は影響を受けません。&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）を&lt;/a&gt;呼び出すたびに、同じプロセス内の以前のすべての呼び出しが上書きされます。</target>
        </trans-unit>
        <trans-unit id="f53a6a65a1ce3426676e4e3e0eefc393f32a825e" translate="yes" xml:space="preserve">
          <source>Each call to either sqlite3_trace() or sqlite3_trace_v2() overrides (cancels) any prior calls to sqlite3_trace() or sqlite3_trace_v2().</source>
          <target state="translated">sqlite3_trace()またはsqlite3_trace_v2()を呼び出すたびに、それ以前のsqlite3_trace()またはsqlite3_trace_v2()を上書き(キャンセル)します。</target>
        </trans-unit>
        <trans-unit id="210d7d62dedd7b7a03aaed5a472bf17f4f31c5cb" translate="yes" xml:space="preserve">
          <source>Each call to sqlite3rbu_step() does a small amount of work towards completing the vacuum operation. Depending on the size of the database, a single vacuum may require thousands of calls to sqlite3rbu_step(). sqlite3rbu_step() returns SQLITE_DONE if the vacuum operation has finished, SQLITE_OK if the vacuum operation has not finished but no error has occurred, and an SQLite error code if an error is encountered. If an error does occur, all subsequent calls to sqlite3rbu_step() immediately return the same error code.</source>
          <target state="translated">sqlite3rbu_step()の各呼び出しは、バキューム操作を完了させるための少量の作業を行います。データベースのサイズによっては、1つのバキュームで何千回もsqlite3rbu_step()を呼び出す必要があるかもしれません。 sqlite3rbu_step()はバキューム処理が終了した場合はSQLITE_DONEを、バキューム処理が終了していないがエラーが発生していない場合はSQLITE_OKを、エラーが発生した場合はSQLiteエラーコードを返します。エラーが発生した場合、それ以降のsqlite3rbu_step()の呼び出しはすべて直ちに同じエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="945385f146c601eb7773bb4497e85e560cda1868" translate="yes" xml:space="preserve">
          <source>Each call to xUpdate will fall into one of cases shown below. Not that references to &lt;b&gt;argv[i]&lt;/b&gt; mean the SQL value held within the argv[i] object, not the argv[i] object itself.</source>
          <target state="translated">xUpdateへの各呼び出しは、以下に示すいずれかのケースに分類されます。&lt;b&gt;argv [i]&lt;/b&gt;への参照は、argv [i]オブジェクト自体ではなく、argv [i]オブジェクト内に保持されるSQL値を意味するわけではありません。</target>
        </trans-unit>
        <trans-unit id="fc164ad4bbc60e4e26ece4689029d1fc885eb00a" translate="yes" xml:space="preserve">
          <source>Each change recorded by a session object is marked as either direct or indirect. A change is marked as indirect if either:</source>
          <target state="translated">セッションオブジェクトによって記録された各変更は、直接または間接のいずれかとしてマークされます。どちらかが記録されている場合、変更は間接的なものとしてマークされます。</target>
        </trans-unit>
        <trans-unit id="23f47a6b73c8dc551b62d8a4d686a08cd0fe7e37" translate="yes" xml:space="preserve">
          <source>Each column in an SQLite 3 database is assigned one of the following type affinities:</source>
          <target state="translated">SQLite 3 データベースの各カラムには、以下の型の親和性のいずれかが割り当てられています。</target>
        </trans-unit>
        <trans-unit id="b225a6098d76a95e7290e27ffd041b5076929def" translate="yes" xml:space="preserve">
          <source>Each column name or expression can be followed by one of the &quot;ASC&quot; or &quot;DESC&quot; keywords to indicate sort order. The sort order may or may not be ignored depending on the database file format, and in particular the &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt;. The &quot;legacy&quot; schema format (1) ignores index sort order. The descending index schema format (4) takes index sort order into account. Only versions of SQLite 3.3.0 (2006-01-11) and later are able to understand the descending index format. For compatibility, version of SQLite between 3.3.0 and 3.7.9 use the legacy schema format by default. The newer schema format is used by default in version 3.7.10 (2012-01-16) and later. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to change set the specific behavior for any version of SQLite.</source>
          <target state="translated">各列名または式の後には、「ASC」または「DESC」キーワードのいずれかを続けて、ソート順を示すことができます。ソート順月またはデータベースファイル形式に応じて無視できない場合があり、特に&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;スキーマフォーマット番号&lt;/a&gt;。 「レガシー」スキーマ形式（1）では、インデックスのソート順が無視されます。降順の索引スキーマ形式（4）では、索引のソート順が考慮されます。 SQLite 3.3.0（2006-01-11）以降のバージョンのみが降順のインデックス形式を理解できます。互換性のために、3.3.0と3.7.9の間のバージョンのSQLiteはデフォルトでレガシースキーマ形式を使用します。バージョン3.7.10（2012-01-16）以降では、新しいスキーマ形式がデフォルトで使用されます。&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_formatプラグマは、&lt;/a&gt; SQLiteのいずれかのバージョンのための具体的な動作を設定変更するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="49f9ccaac189604c31d61c6229cff4580f28bbe6" translate="yes" xml:space="preserve">
          <source>Each component query of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; (UNION, UNION ALL, EXCEPT or INTERSECT) is assigned computed separately and is given its own line in the EXPLAIN QUERY PLAN output.</source>
          <target state="translated">&lt;a href=&quot;lang_select#compound&quot;&gt;複合クエリの&lt;/a&gt;各コンポーネントクエリ（UNION、UNION ALL、EXCEPT、またはINTERSECT）は個別に計算されて割り当てられ、EXPLAIN QUERY PLAN出力で独自の行が与えられます。</target>
        </trans-unit>
        <trans-unit id="a75cebae36bdcbe0495a4d634fceea0a434ea48a" translate="yes" xml:space="preserve">
          <source>Each condition in a decision is shown to independently affect the outcome of the decision.</source>
          <target state="translated">意思決定の各条件は、独立して意思決定の結果に影響を与えることが示されています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
