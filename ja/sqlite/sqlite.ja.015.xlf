<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="1bd6a18e90f1a8ee8256e02fe4825c2a58f166f7" translate="yes" xml:space="preserve">
          <source>The dynamic webpages on the SQLite website are mostly generated by the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. A typical dynamic page would be a timeline such as &lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt;. A log of all SQL used by the timeline is shown below.</source>
          <target state="translated">SQLite Webサイトの動的Webページは、主に&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossilバージョン管理システム&lt;/a&gt;によって生成されます。典型的な動的ページは、&lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https：&lt;/a&gt; //www.sqlite.org/src/timelineなどのタイムラインです。タイムラインで使用されるすべてのSQLのログを以下に示します。</target>
        </trans-unit>
        <trans-unit id="f53c608dfb99715244babeb0f18e6bedb4ce61c6" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep引数は、照合関数コールバックxCallbackに渡される文字列のエンコーディングを決定します。&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;と&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;ネイティブのバイト順でUTF16なるようにeTextRep力文字列の値。&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; eTextRepの値は偶数バイトアドレスに開始するように文字列を強制します。</target>
        </trans-unit>
        <trans-unit id="1f8a73896c29d2961fd12e3fd13060416db06dbd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep引数は、照合関数コールバックxCallbackに渡される文字列のエンコーディングを決定します。&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;と&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;ネイティブのバイト順でUTF16なるようにeTextRep力文字列の値。&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; eTextRepの値は偶数バイトアドレスに開始するように文字列を強制します。</target>
        </trans-unit>
        <trans-unit id="af71ae840c72707272be3031b3c3ee6f45c5d71f" translate="yes" xml:space="preserve">
          <source>The edit distance coefficients are normally read from the APPCOST table once and there after stored in memory. Hence, run-time changes to the APPCOST table will not normally affect the edit distance results. However, inserting the special string 'reset' into the &quot;command&quot; column of the virtual table causes the edit distance coefficients to be reread the APPCOST table. Hence, applications should run a SQL statement similar to the following when changes to the APPCOST table occur:</source>
          <target state="translated">編集距離係数は通常、APPCOSTテーブルから一度読み出され、その後メモリに格納されます。したがって、APPCOSTテーブルへのランタイム変更は、通常、編集距離の結果には影響しません。しかし、仮想テーブルの &quot;command &quot;列に特別な文字列'reset'を挿入すると、編集距離係数がAPPCOSTテーブルから再読み込みされる。したがって、アプリケーションは、APPCOSTテーブルへの変更が発生したときに、以下のようなSQL文を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="49994af0743488763f79d75d2c9c86ebfda2dfb6" translate="yes" xml:space="preserve">
          <source>The edit program can also be used as a viewer, by simply ignoring the return value. For example, to merely look at the image above, you might run:</source>
          <target state="translated">編集プログラムは、単に戻り値を無視することで、ビューアとしても使用することができます。例えば、単に上の画像を見るためには、次のように実行します。</target>
        </trans-unit>
        <trans-unit id="47a4a763ba31495e47240c644f7558e9498bae30" translate="yes" xml:space="preserve">
          <source>The edit() function can be used to make changes to large text values. For example:</source>
          <target state="translated">edit()関数を使用すると、大きなテキスト値に変更を加えることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fd34f0d751c4ddc69b221f64ffd45f8927b66781" translate="yes" xml:space="preserve">
          <source>The editdist3 algorithm is a function that computes the minimum edit distance (a.k.a. the Levenshtein distance) between two input strings. The editdist3 algorithm is a configurable alternative to the default edit distance function of spellfix1. Features of editdist3 include:</source>
          <target state="translated">editdist3 アルゴリズムは、2 つの入力文字列間の最小編集距離 (別名 Levenshtein 距離)を計算する関数です。editdist3 アルゴリズムは、spellfix1 のデフォルトの編集距離関数に代わるものとして設定可能です。editdist3 の特徴は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="870b1bf5bd7c0178ecc9a04d5313cc57bc40b4f1" translate="yes" xml:space="preserve">
          <source>The effects of a &lt;b&gt;truncate file&lt;/b&gt; operation are not assumed to be made persistent until after the corresponding file has been</source>
          <target state="translated">&lt;b&gt;ファイル&lt;/b&gt;の&lt;b&gt;切り捨て&lt;/b&gt;操作の影響は、対応するファイルが削除されるまで、永続化されるとは想定されていません</target>
        </trans-unit>
        <trans-unit id="393d1077fa976da06b2c81028e0e667751bfce07" translate="yes" xml:space="preserve">
          <source>The empty-result-callbacks flag affects the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API only. Normally, when the empty-result-callbacks flag is cleared, the callback function supplied to the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is not invoked for commands that return zero rows of data. When empty-result-callbacks is set in this situation, the callback function is invoked exactly once, with the third parameter set to 0 (NULL). This is to enable programs that use the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API to retrieve column-names even when a query returns no data.</source>
          <target state="translated">empty-result-callbacksフラグは&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt; APIにのみ影響します。通常、empty-result-callbacksフラグがクリアされている場合、&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）に&lt;/a&gt;提供されるコールバック関数は、データのゼロ行を返すコマンドに対して呼び出されません。この状況でempty-result-callbacksが設定されている場合、コールバック関数は1回だけ呼び出され、3番目のパラメーターは0（NULL）に設定されます。これは、クエリがデータを返さない場合でも、&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt; APIを使用するプログラムが列名を取得できるようにするためです。</target>
        </trans-unit>
        <trans-unit id="f1a25180fc453bfc9b7157e5b028aa8235fc10f5" translate="yes" xml:space="preserve">
          <source>The end-user executes DML or DDL SQL statements that require the structure of the database file of the database file to be modified. These modifications may be any combination of operations to</source>
          <target state="translated">のデータベースファイルの構造を修正することを要求するDMLまたはDDL SQL文をエンドユーザが実行する。これらの修正は、以下の操作の任意の組み合わせとすることができます。</target>
        </trans-unit>
        <trans-unit id="5b923462226ca9a3f1ea2da34aa276431384d659" translate="yes" xml:space="preserve">
          <source>The ending frame boundary can be omitted (if the BETWEEN and AND keywords that surround the starting frame boundary are also omitted), in which case the ending frame boundary defaults to CURRENT ROW.</source>
          <target state="translated">終了フレーム境界は省略することができます(開始フレーム境界を囲むBETWEENキーワードとANDキーワードも省略されている場合)。</target>
        </trans-unit>
        <trans-unit id="b26c1d5670afb707a661dd133bd85c139805e555" translate="yes" xml:space="preserve">
          <source>The ending frame boundary may not take a form that appears higher in the above list than the starting frame boundary.</source>
          <target state="translated">前記終了フレーム境界は、前記開始フレーム境界よりも上位に出現する形態を取らないようにしてもよい。</target>
        </trans-unit>
        <trans-unit id="1133a1a20cf9f9901ca7376082c18ed0b6c4a36d" translate="yes" xml:space="preserve">
          <source>The engine no longer consults the main table if it can get all the information it needs from an index.</source>
          <target state="translated">インデックスから必要な情報をすべて取得できるのであれば、エンジンはもはやメインテーブルを参照しません。</target>
        </trans-unit>
        <trans-unit id="b873e4983f185f34587580faeee301ccc43a5a88" translate="yes" xml:space="preserve">
          <source>The enhanced query syntax supports the AND, OR and NOT binary set operators. Each of the two operands to an operator may be a basic FTS query, or the result of another AND, OR or NOT set operation. Operators must be entered using capital letters. Otherwise, they are interpreted as basic term queries instead of set operators.</source>
          <target state="translated">拡張クエリ構文は、AND、ORおよびNOTバイナリセット演算子をサポートしています。演算子への2つのオペランドのそれぞれは、基本的なFTSクエリ、または別のAND、OR、NOTセット演算の結果となります。演算子は、大文字で入力する必要があります。そうでない場合、それらはセット演算子ではなく、基本的なタームクエリとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="ec0a2d5aa63b2e3b719340bb237dcfc9aebe4443" translate="yes" xml:space="preserve">
          <source>The entries above might represent (for example) a bounding box around the main office for SQLite.org and bounding box around the 12th Congressional District of North Carolina (prior to the 2011 redistricting) in which SQLite.org was located.</source>
          <target state="translated">上記のエントリは、(例えば)SQLite.orgのメインオフィス周辺のバウンディングボックスと、SQLite.orgが置かれていたノースカロライナ州第12議会区(2011年の再編成前)周辺のバウンディングボックスを表しているかもしれません。</target>
        </trans-unit>
        <trans-unit id="df23c9e0d03ef84c1b3ecc39ad637f8b14bf70ea" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">エントリポイントはzProcです。 zProcは0の場合があります。その場合、SQLiteは独自にエントリポイント名を考え出そうとします。最初に「sqlite3_extension_init」を試行します。それが機能しない場合は、「sqlite3_X_init」という名前を作成します。Xは、ファイル名の最後の「/」から最初の「。」までのすべてのASCIIアルファベット文字の小文字に相当する文字で構成されます。最初の「lib」は省略します。 sqlite3_load_extension（）インターフェースは、成功すると&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを返し&lt;/a&gt;、何かがうまくいかない場合は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;を返します。エラーが発生し、pzErrMsgが0でない場合、&lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;インターフェースは、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;から取得したメモリに格納されたエラーメッセージテキストで* pzErrMsgを埋めようとします。。呼び出し元の関数は、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）を&lt;/a&gt;呼び出してこのメ​​モリを解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="4f2e7b718e4064a2f8cc8acbe7a051458f014ce0" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">エントリポイントはzProcです。 zProcは0の場合があります。その場合、SQLiteは独自にエントリポイント名を考え出そうとします。最初に「sqlite3_extension_init」を試行します。それが機能しない場合は、「sqlite3_X_init」という名前を作成します。Xは、ファイル名の最後の「/」から最初の「。」までのすべてのASCIIアルファベット文字の小文字に相当する文字で構成されます。最初の「lib」は省略します。 sqlite3_load_extension（）インターフェースは、成功すると&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_OKを返し&lt;/a&gt;、何かがうまくいかない場合は&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_ERROR&lt;/a&gt;を返します。エラーが発生し、pzErrMsgが0でない場合、&lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;インターフェースは、&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;から取得したメモリに格納されたエラーメッセージテキストで* pzErrMsgを埋めようとします。。呼び出し元の関数は、&lt;a href=&quot;free&quot;&gt;sqlite3_free（）を&lt;/a&gt;呼び出してこのメ​​モリを解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="40007c6bf4af7619580a2e5c3ec81a4fee4ad813" translate="yes" xml:space="preserve">
          <source>The error code is changed to &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; (instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;) when an attempt is made to &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; while one or more queries are still pending.</source>
          <target state="translated">1つ以上のクエリがまだ保留中であるときに&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;が試行されると、エラーコードは&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;（&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;ではなく）に変更されます。</target>
        </trans-unit>
        <trans-unit id="2e60aa60ea376ea9ca807c8cc7d0b0b91ec054e5" translate="yes" xml:space="preserve">
          <source>The error codes for SQLite version 3 are unchanged from version 2. They are as follows:</source>
          <target state="translated">SQLite バージョン 3 のエラーコードはバージョン 2 から変更されていません。エラーコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2ccece93e5a00d5f5d9d7a6919183b3a66f82129" translate="yes" xml:space="preserve">
          <source>The error logger callback function might look something like this:</source>
          <target state="translated">エラーロガーのコールバック関数は、次のようなものです。</target>
        </trans-unit>
        <trans-unit id="8ad007677ae545b2ad036dc3fbfd526afb2a9647" translate="yes" xml:space="preserve">
          <source>The error logger callback should be treated like a signal handler. The application should save off or otherwise process the error, then return as soon as possible. No other SQLite APIs should be invoked, directly or indirectly, from the error logger. SQLite is &lt;u&gt;not&lt;/u&gt; reentrant through the error logger callback. In particular, the error logger callback is invoked when a memory allocation fails, so it is generally a bad idea to try to allocate memory inside the error logger. Do not even think about trying to store the error message in another SQLite database.</source>
          <target state="translated">エラーロガーコールバックは、シグナルハンドラーのように扱う必要があります。アプリケーションはエラーを保存するか、そうでなければエラーを処理してから、できるだけ早く戻る必要があります。エラーロガーから他のSQLite APIを直接または間接的に呼び出すことはできません。SQLiteは、エラーロガーコールバックを通じて再入可能ではあり&lt;u&gt;ません&lt;/u&gt;。特に、エラーロガーコールバックはメモリの割り当てに失敗したときに呼び出されるため、一般的にエラーロガー内にメモリを割り当てようとすることはお勧めできません。エラーメッセージを別のSQLiteデータベースに格納しようとすることさえ考えないでください。</target>
        </trans-unit>
        <trans-unit id="931b7a49e1d266b8f7af8c59c48646cf4fc9a825" translate="yes" xml:space="preserve">
          <source>The error messages that might be sent to the error logger and their exact format is subject to changes from one release to the next. So applications should not depend on any particular error message text formats or error codes. Things do not change capriciously, but they do sometimes changes.</source>
          <target state="translated">エラーロガーに送信される可能性のあるエラーメッセージとその正確なフォーマットは、あるリリースから次のリリースへと変更される可能性があります。そのため、アプリケーションは特定のエラーメッセージのテキスト形式やエラーコードに依存すべきではありません。物事は気まぐれに変化するものではありませんが、時々変更されることがあります。</target>
        </trans-unit>
        <trans-unit id="6f0f73d0eed4daf2fa7ce504b606f01da04260dc" translate="yes" xml:space="preserve">
          <source>The estimatedCost field should be set to the estimated number of disk access operations required to execute this query against the virtual table. The SQLite core will often call xBestIndex multiple times with different constraints, obtain multiple cost estimates, then choose the query plan that gives the lowest estimate. The SQLite core initializes estimatedCost to a very large value prior to invoking xBestIndex, so if xBestIndex determines that the current combination of parameters is undesirable, it can leave the estimatedCost field unchanged to discourage its use.</source>
          <target state="translated">estimatedCost フィールドには、仮想テーブルに対してこのクエリを実行するのに必要なディスクアクセス操作の推定数を設定する必要があります。SQLite コアは多くの場合、異なる制約条件で xBestIndex を複数回呼び出し、複数のコスト推定値を取得した後、最も低い推定値を与えるクエリプランを選択します。SQLite コアは、xBestIndex を呼び出す前に estimatedCost を非常に大きな値に初期化するので、もし xBestIndex が現在のパラメータの組み合わせが望ましくないと判断した場合には、その使用を避けるために estimatedCost フィールドを変更しないでおくことができます。</target>
        </trans-unit>
        <trans-unit id="9110d26065cfada658af48dd22a731f2e42c4634" translate="yes" xml:space="preserve">
          <source>The estimatedCost value is an estimate of the cost of a particular strategy. A cost of N indicates that the cost of the strategy is similar to a linear scan of an SQLite table with N rows. A cost of log(N) indicates that the expense of the operation is similar to that of a binary search on a unique indexed field of an SQLite table with N rows.</source>
          <target state="translated">estimatedCost値は、特定のストラテジーのコストの推定値です。Nのコストは、その戦略のコストがN行のSQLiteテーブルのリニアスキャンに似ていることを示します。log(N)のコストは、その操作のコストが、N行のSQLiteテーブルの一意のインデックス付きフィールドのバイナリ検索のコストに似ていることを示しています。</target>
        </trans-unit>
        <trans-unit id="a1d11ebb28b1bb46c038273ece9416f81d29642b" translate="yes" xml:space="preserve">
          <source>The estimatedRows value is an estimate of the number of rows that will be returned by the strategy.</source>
          <target state="translated">estimatedRows値は、ストラテジーが返す行数の推定値です。</target>
        </trans-unit>
        <trans-unit id="6e98b869e8e492045895b07f0da4a451a3b65571" translate="yes" xml:space="preserve">
          <source>The exact logic used to determine if a</source>
          <target state="translated">のかどうかを判断するために使用される正確なロジックは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="c7341ca7ddb26c5a501b148a51edcbd920ab7841" translate="yes" xml:space="preserve">
          <source>The exact same source code can be used for both a run-time loadable shared library or DLL and as a module that is statically linked with your application. This provides flexibility and allows you to reuse the same code in different ways.</source>
          <target state="translated">全く同じソースコードを、実行時にロード可能な共有ライブラリや DLL と、アプリケーションと静的にリンクされたモジュールの両方に使用することができます。これは柔軟性を提供し、同じコードを異なる方法で再利用することを可能にします。</target>
        </trans-unit>
        <trans-unit id="51d3ce62c3eb93876d401465d70f8ba808604db2" translate="yes" xml:space="preserve">
          <source>The example above causes the database file named &quot;ex1.db&quot; to be opened and used. The &quot;ex1.db&quot; file is created if it does not previously exist. You might want to use a full pathname to ensure that the file is in the directory that you think it is in. Use forward-slashes as the directory separator character. In other words use &quot;c:/work/ex1.db&quot;, not &quot;c:\work\ex1.db&quot;.</source>
          <target state="translated">上の例では、&quot;ex1.db &quot;という名前のデータベースファイルを開いて使用しています。ex1.db」ファイルは、以前に存在しなかった場合に作成されます。ファイルがあると思われるディレクトリにあることを確認するために、フルパス名を使用するとよいでしょう。ディレクトリの区切り文字としてフォワードスラッシュを使用します。言い換えれば、&quot;c:/work/ex1.db &quot;ではなく、&quot;c:\workex1.db &quot;を使用してください。</target>
        </trans-unit>
        <trans-unit id="97b14b6298ce84315e618c11d7722d98fb92421a" translate="yes" xml:space="preserve">
          <source>The example above contains two &quot;SCALAR&quot; subqueries. The subqueries are SCALAR in the sense that they return a single value - a one-row, one-column table. If the actual query returns more than that, then only the first column of the first row is used.</source>
          <target state="translated">上の例では、2つの &quot;SCALAR &quot;副問い合わせが含まれています。これらのサブクエリは、1つの値、つまり1行1列のテーブルを返すという意味でSCALARです。実際のクエリがそれ以上の値を返す場合は、最初の行の最初の列のみが使用されます。</target>
        </trans-unit>
        <trans-unit id="d7a7c3999051bd06566a95bdd9bc9de8e3e4adaa" translate="yes" xml:space="preserve">
          <source>The example above illustrates the signature of the error logger callback. However, in an embedded application, one usually does not print messages on stderr. Instead, one might store the messages in a preallocated circular buffer where they can be accessed when diagnostic information is needed during debugging. Or perhaps the messages can be sent to &lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;. Somehow, the messages need to be stored where they are accessible to developers, not displayed to end users.</source>
          <target state="translated">上記の例は、エラーロガーコールバックの署名を示しています。ただし、組み込みアプリケーションでは、通常はstderrにメッセージを出力しません。代わりに、事前に割り当てられた循環バッファにメッセージを保存し、デバッグ中に診断情報が必要になったときにメッセージにアクセスできるようにします。または、メッセージを&lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;に送信することもできます。どういうわけか、メッセージは、エンドユーザーに表示するのではなく、開発者がアクセスできる場所に保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="d307547a7cd9c2e8e0dc86cacf98f3de8afb55c2" translate="yes" xml:space="preserve">
          <source>The example above showed a single &lt;b&gt;filename='thefile.csv'&lt;/b&gt; argument for the CSV virtual table. But other arguments are also possible.</source>
          <target state="translated">上記の例は、CSV仮想テーブルの単一の&lt;b&gt;filename = 'thefile.csv'&lt;/b&gt;引数を示しています。しかし、他の議論も可能です。</target>
        </trans-unit>
        <trans-unit id="11a05b76af4570008579a529531a96eb802e047d" translate="yes" xml:space="preserve">
          <source>The example above shows SQLite picking full-table scan will visit all rows in the table. If the query were able to use an index, then the SCAN/SEARCH record would include the name of the index and, for a SEARCH record, an indication of how the subset of rows visited is identified. For example:</source>
          <target state="translated">上記の例では、SQLiteがフルテーブルスキャンをピックして、テーブル内のすべての行を訪問することを示しています。クエリがインデックスを使用できる場合、SCAN/SEARCHレコードにはインデックスの名前と、SEARCHレコードの場合は、訪問した行のサブセットがどのように識別されるかの表示が含まれます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="abd381887f2ea42f76bfd9ebc8b17425d16e2957" translate="yes" xml:space="preserve">
          <source>The example below uses ntile() to divide the six rows into two groups (the ntile(2) call) and into four groups (the ntile(4) call). For ntile(2), there are three rows assigned to each group. For ntile(4), there are two groups of two and two groups of one. The larger groups of two appear first.</source>
          <target state="translated">以下の例では、ntile()を使用して6行を2つのグループ(ntile(2)呼び出し)と4つのグループ(ntile(4)呼び出し)に分割しています。ntile(2)では、各グループに3つの行が割り当てられています。ntile(4)では、2つのグループが2つ、1つのグループが2つあります。大きい方の2つのグループが最初に現れます。</target>
        </trans-unit>
        <trans-unit id="c8ad72613a1253e10b2aeefbfa091cedb3448e07" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the steps involved in capturing a changeset while executing SQL commands. In summary:</source>
          <target state="translated">以下のコード例は、SQL コマンドの実行中にチェンジセットをキャプチャする手順を示しています。要約すると</target>
        </trans-unit>
        <trans-unit id="cfda7c494f05312b3bf7826ec92aff6df2e44b46" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the techniques used to iterate through and extract the data related to all changes in a changeset. To summarize:</source>
          <target state="translated">以下のコード例は、チェンジセット内のすべての変更に関連するデータを反復処理して抽出するために使用されるテクニックを示しています。要約すると</target>
        </trans-unit>
        <trans-unit id="5dde8802fcba008ca09e765d610fcb4f5bf326ca" translate="yes" xml:space="preserve">
          <source>The example code below uses the second of the methods enumerated above - it monitors for changes on all database tables.</source>
          <target state="translated">以下のコード例では、上で列挙したメソッドの 2 番目のメソッドを使用しています-すべてのデータベーステーブルの変更を監視します。</target>
        </trans-unit>
        <trans-unit id="3f036ecd22d9629ed467ac2dbb67b517f12166ad" translate="yes" xml:space="preserve">
          <source>The examples above all use basic full-text term queries as both operands of the set operations demonstrated. Phrase and NEAR queries may also be used, as may the results of other set operations. When more than one set operation is present in an FTS query, the precedence of operators is as follows:</source>
          <target state="translated">上記の例では、基本的なフルテキスト語クエリをセット操作のオペランドとして使用しています。フレーズ検索やNEAR検索も、他のセット操作の結果と同様に使用することができます。FTS クエリで複数のセット操作が存在する場合、演算子の優先順位は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="1921013ee1678e9933f635ab4c9457e39025bfc3" translate="yes" xml:space="preserve">
          <source>The examples below identify the collating sequences that would be used to determine the results of text comparisons that may be performed by various SQL statements. Note that a text comparison may not be required, and no collating sequence used, in the case of numeric, blob or NULL values.</source>
          <target state="translated">以下の例では、さまざまな SQL 文で実行されるテキスト比較の結果を決定するために使用される照合順序を示します。数値、ブロブ、またはNULL値の場合、テキスト比較は必須ではなく、照合シーケンスは使用されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="367a92feb39a9287f4306f6946c319f7064a8b02" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume that the database is populated as follows:</source>
          <target state="translated">このセクションの例はすべて、以下のようにデータベースが格納されていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="c2bd8a896b6e33422d64448169403c1bc373cf0d" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume the following data:</source>
          <target state="translated">このセクションの例では、すべて以下のデータを想定しています。</target>
        </trans-unit>
        <trans-unit id="4d8c3a17bac2c4be1cb9b2d64248454f5513cff9" translate="yes" xml:space="preserve">
          <source>The exception mentioned above is that if the declaration of a column with declared type &quot;INTEGER&quot; includes an &quot;PRIMARY KEY DESC&quot; clause, it does not become an alias for the rowid and is not classified as an integer primary key. This quirk is not by design. It is due to a bug in early versions of SQLite. But fixing the bug could result in backwards incompatibilities. Hence, the original behavior has been retained (and documented) because odd behavior in a corner case is far better than a compatibility break. This means that the following three table declarations all cause the column &quot;x&quot; to be an alias for the rowid (an integer primary key):</source>
          <target state="translated">上述の例外は、宣言された型が「INTEGER」のカラムの宣言に「PRIMARY KEY DESC」句が含まれている場合、そのカラムはROWIDのエイリアスにならず、整数の主キーとして分類されないということです。この奇妙な現象は設計上のものではありません。これはSQLiteの初期バージョンのバグによるものです。しかし、このバグを修正すると後方互換性がなくなる可能性があります。そこで、コーナーケースでの奇妙な動作は互換性を失うよりもはるかに優れているため、元の動作が保持されています (そして文書化されています)。つまり、以下の 3 つのテーブル宣言では、列 &quot;x&quot; が rowid (整数の主キー)のエイリアスになっているということです。</target>
        </trans-unit>
        <trans-unit id="f41b51d024f674a1f6149c31aede1e868d7d56cf" translate="yes" xml:space="preserve">
          <source>The existence of a transaction depends on whether or not the rollback journal file exists and the deletion of a file appears to be an atomic operation from the point of view of a user-space process. Therefore, a transaction appears to be an atomic operation.</source>
          <target state="translated">トランザクションの存在は、ロールバック・ジャーナル・ファイルが存在するかどうかに依存し、ファイルの削除は、ユーザ空間プロセスから見ればアトミックな操作に見える。したがって、トランザクションはアトミックな操作であるように見えます。</target>
        </trans-unit>
        <trans-unit id="6021cb5e88d7481ca7795a9ddd0c04e6033fc0e0" translate="yes" xml:space="preserve">
          <source>The existing INSERT is removed from the changegroup. The DELETE is not added.</source>
          <target state="translated">既存のINSERTはchangegroupから削除されます。DELETEは追加されません。</target>
        </trans-unit>
        <trans-unit id="4a2b5a6b7a6bdb1833a8cf1e839e065d174385dc" translate="yes" xml:space="preserve">
          <source>The existing UPDATE is replaced by the new DELETE within the changegroup.</source>
          <target state="translated">既存のUPDATEは、changegroup内の新しいDELETEに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="5c1e2e9de2a17cfdc315c14e1e74a36e45b9c92f" translate="yes" xml:space="preserve">
          <source>The existing UPDATE remains within the changegroup. It is amended so that the accompanying values are as if the row was updated once by the existing change and then again by the new change.</source>
          <target state="translated">既存のUPDATEはchangegroup内に残ります。これは、行が既存の変更によって一度更新され、その後、新しい変更によって再び更新されたかのように、付随する値が修正されています。</target>
        </trans-unit>
        <trans-unit id="fca9185c8e0eb9e3e49b7068e021cf8a710c066e" translate="yes" xml:space="preserve">
          <source>The explicit COMMIT command runs immediately, even if there are pending &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. However, if there are pending write operations, the COMMIT command will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">保留中の&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントがある場合でも、明示的なCOMMITコマンドはすぐに実行されます。ただし、保留中の書き込み操作がある場合、COMMITコマンドはエラーコード&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSYで&lt;/a&gt;失敗します。</target>
        </trans-unit>
        <trans-unit id="e2d16a733bb795b8f24e0161c9bf1e3201567a34" translate="yes" xml:space="preserve">
          <source>The expression &quot;+column&quot; is now considered the same as &quot;column&quot; when computing the collating sequence to use on the expression.</source>
          <target state="translated">式 &quot;+column &quot;は、式に使用する照合順序を計算する際に &quot;column &quot;と同じとみなされるようになりました。</target>
        </trans-unit>
        <trans-unit id="fee373e0e83d3368c40362493777ab8e984bd97b" translate="yes" xml:space="preserve">
          <source>The expression &quot;a BETWEEN b AND c&quot; is treated as two separate binary comparisons &quot;a &amp;gt;= b AND a &amp;lt;= c&quot;, even if that means different affinities are applied to 'a' in each of the comparisons. Datatype conversions in comparisons of the form &quot;x IN (SELECT y ...)&quot; are handled is if the comparison were really &quot;x=y&quot;. The expression &quot;a IN (x, y, z, ...)&quot; is equivalent to &quot;a = +x OR a = +y OR a = +z OR ...&quot;. In other words, the values to the right of the IN operator (the &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; values in this example) are considered to have no affinity, even if they happen to be column values or CAST expressions.</source>
          <target state="translated">「a BETWEEN b AND c」という表現は、2つの異なるバイナリ比較「a&amp;gt; = b AND a &amp;lt;= c」として扱われます。これは、各比較で「a」に異なるアフィニティが適用されることを意味します。 &quot;x IN（SELECT y ...）&quot;形式の比較でのデータ型変換は、比較が実際に &quot;x = y&quot;であった場合に行われます。 「a IN（x、y、z、...）」という表現は、「a = + x OR a = + y OR a = + z OR ...」と同等です。つまり、IN演算子の右側の値（この例では「x」、「y」、および「z」の値）は、たとえ列の値またはCAST式であっても、類似性がないと見なされます。 。</target>
        </trans-unit>
        <trans-unit id="15a424b3e7e4f20cd419dc00af0824f2446f3f50" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x.</source>
          <target state="translated">式 &quot;x BETWEEN y and z&quot;は、2つの比較 &quot;x&amp;gt; = y AND x &amp;lt;= z&quot;と論理的に同等であり、2つの別個の比較であるかのように照合関数に関して機能します。式「x IN（SELECT y ...）」は、照合シーケンスを決定するために、式「x = y」と同じ方法で処理されます。「x IN（y、z、...）」の形式の式に使用される照合シーケンスは、xの照合シーケンスです。</target>
        </trans-unit>
        <trans-unit id="0c6d1934b411c6401d1051c4d7453826ea7a9843" translate="yes" xml:space="preserve">
          <source>The expression attached to the optional OFFSET clause that may follow a LIMIT clause must also evaluate to an integer, or a value that can be losslessly converted to an integer. If an expression has an OFFSET clause, then the first M rows are omitted from the result set returned by the SELECT statement and the next N rows are returned, where M and N are the values that the OFFSET and LIMIT clauses evaluate to, respectively. Or, if the SELECT would return less than M+N rows if it did not have a LIMIT clause, then the first M rows are skipped and the remaining rows (if any) are returned. If the OFFSET clause evaluates to a negative value, the results are the same as if it had evaluated to zero.</source>
          <target state="translated">LIMIT句に続くオプションのOFFSET句に接続された式は、整数、または可逆的に整数に変換できる値を評価しなければなりません。式にOFFSET句がある場合、最初のM行はSELECT文によって返される結果セットから省略され、次のN行が返されます。または、SELECT文がLIMIT句を持たない場合、返される行数がM+N行よりも少ない場合、最初のM行はスキップされ、残りの行(あれば)が返されます。OFFSET句が負の値として評価された場合、結果はゼロとして評価された場合と同じです。</target>
        </trans-unit>
        <trans-unit id="1cd8c2a06181abbb52fb772c5e4393bf493adec9" translate="yes" xml:space="preserve">
          <source>The expression following the WHERE clause may contain operators, literal values, and names of columns in the table being indexed. The WHERE clause may &lt;em&gt;not&lt;/em&gt; contain subqueries, references to other tables, &lt;a href=&quot;deterministic&quot;&gt;non-deterministic functions&lt;/a&gt;, or &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">WHERE句に続く式には、演算子、リテラル値、およびインデックス付けされるテーブルの列の名前を含めることができます。WHERE句には、サブクエリ、他のテーブルへの参照、&lt;a href=&quot;deterministic&quot;&gt;非決定的関数&lt;/a&gt;、または&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメータを&lt;/a&gt;含めることはでき&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fa57007d3af78002775463ea997fdbb172a0c191" translate="yes" xml:space="preserve">
          <source>The extension loading mechanism of SQLite (accessed using the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function) is turned off by default. This is a security precaution. If an application wants to make use of the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; function it must first turn the capability on using this method.</source>
          <target state="translated">SQLiteの拡張機能読み込みメカニズム&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;（&lt;/a&gt; SQL関数load_extension（）を使用してアクセス）は、デフォルトでオフになっています。これはセキュリティ上の予防措置です。アプリケーションが&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;関数を使用する場合は、まずこのメソッドを使用して機能をオンにする必要があります。</target>
        </trans-unit>
        <trans-unit id="bbd9a40496de97ba5cfcabba824166980ee9d8c1" translate="yes" xml:space="preserve">
          <source>The extra write overhead prompted a reexamination of assumptions about powersafe overwrite. With modern disk drives, the capacity has become so large and the data density so great that a single sector is very small and writing a single sector takes very little time. We know that disk drives can detect an impending power loss and continue to operate for some small amount of time on residual energy because those drives are able to park their heads before spinning down. And so if an impending power loss is detectable by the disk controller, it seems reasonable that the controller will finish writing whatever sector it is current working on when the imminent power loss is first detected, prior to parking the heads, as long as doing so does not take too long, which it should not with small and dense sectors. Hence it seems reasonable to assume powersafe overwrite for modern disks. Indeed, BerkeleyDB has made this assumption for decades, we are told. Caution is advised though. As Roger Binns noted on the SQLite developers mailing list: &quot;'poorly written' should be the main assumption about drive firmware.&quot;</source>
          <target state="translated">余分な書き込みオーバーヘッドは、パワーセーフの上書きに関する前提条件の再検討を促しました。最新のディスクドライブでは、容量が非常に大きくなり、データ密度が非常に高くなっているため、1 セクタは非常に小さく、1 セクタの書き込みにはほとんど時間がかかりません。私たちは、ディスクドライブが差し迫った停電を検知して、わずかな時間でも残余エネルギーで動作し続けることができることを知っています。したがって、差し迫った電力損失がディスクコントローラによって検出された場合、コントローラは、差し迫った電力損失が最初に検出されたときに、ヘッドを駐車する前に、現在作業しているセクタの書き込みを終了するのが合理的であると思われる。したがって、最新のディスクではパワーセーフな上書きが可能であると仮定するのが妥当なようです。実際、BerkeleyDBは何十年にもわたってこの仮定をしてきたと聞いている。しかし、注意が必要である。Roger BinnsがSQLite開発者メーリングリストで指摘しているように ドライブのファームウェアについては、「&quot;書き込まれていない &quot;というのが主な前提であるべきだ」と。</target>
        </trans-unit>
        <trans-unit id="f31765748ec404a72a387c3ce457db0e7fddb3f0" translate="yes" xml:space="preserve">
          <source>The fact that NULLs are distinct for UNIQUE columns but are indistinct for SELECT DISTINCT and UNION continues to be puzzling. It seems that NULLs should be either distinct everywhere or nowhere. And the SQL standards documents suggest that NULLs should be distinct everywhere. Yet as of this writing, no SQL engine tested treats NULLs as distinct in a SELECT DISTINCT statement or in a UNION.</source>
          <target state="translated">NULLはUNIQUE列では区別されますが、SELECT DISTINCTやUNIONでは区別されないという事実には、引き続き不可解さを感じます。NULLはどこでもはっきりしていなければならないようですが、どこでもはっきりしていなければなりません。そして、SQL標準ドキュメントでは、NULLはどこでも明瞭であるべきであることを示唆しています。しかし、この記事を書いている時点では、テストしたSQLエンジンではSELECT DISTINCT文やUNIONでNULLを区別して扱うものはありません。</target>
        </trans-unit>
        <trans-unit id="36716fd190ed79338836da067e34479b294afa61" translate="yes" xml:space="preserve">
          <source>The fact that SQLite is embedded and &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt; instead of being client/server is a feature, not a bug.</source>
          <target state="translated">SQLiteが組み込まれ、クライアント/サーバーではなく&lt;a href=&quot;serverless&quot;&gt;サーバーレスである&lt;/a&gt;という事実は機能であり、バグではありません。</target>
        </trans-unit>
        <trans-unit id="893ade2ecf018b089d7d0c2f18f2d37a93397ea0" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">BLOBと文字列バインディングインターフェイスの5番目の引数は、SQLiteがBLOBまたは文字列を使い終わった後に、BLOBまたは文字列を破棄するために使用されるデストラクタです。バインドAPIの呼び出しが失敗した場合でも、BLOBまたは文字列を破棄するためにデストラクタが呼び出されます。ただし、3番目のパラメータがNULLポインタまたは4番目のパラメータが負の場合は、デストラクタが呼び出されません。 5番目の引数が特別な値&lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;である場合、SQLiteは情報が静的な非管理スペースにあり、解放する必要がないと想定します。 5番目の引数の値が&lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENTの&lt;/a&gt;場合、SQLiteはsqlite3_bind _ *（）ルーチンが戻る前に、データの独自のプライベートコピーをすぐに作成します。</target>
        </trans-unit>
        <trans-unit id="e68c8434fb7585b2fc0da0f853455aed19727f06" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">BLOBと文字列バインディングインターフェイスの5番目の引数は、SQLiteがBLOBまたは文字列を使い終わった後に、BLOBまたは文字列を破棄するために使用されるデストラクタです。バインドAPIの呼び出しが失敗した場合でも、BLOBまたは文字列を破棄するためにデストラクタが呼び出されます。ただし、3番目のパラメータがNULLポインタまたは4番目のパラメータが負の場合は、デストラクタが呼び出されません。 5番目の引数が特別な値&lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;である場合、SQLiteは情報が静的な非管理スペースにあり、解放する必要がないと想定します。 5番目の引数の値が&lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENTの&lt;/a&gt;場合、SQLiteはsqlite3_bind _ *（）ルーチンが戻る前に、データの独自のプライベートコピーをすぐに作成します。</target>
        </trans-unit>
        <trans-unit id="901b5e438fd14b98c5489ac30117b7e4f79582ec" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCallback, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCallback argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="translated">5 番目の引数 xCallback は照合関数へのポインタです。複数の照合関数を同じ名前を使用して登録することができますが、eTextRep のパラメータが異なるため、SQLite はデータ変換の量が最も少ない関数を使用します。xCallback 引数が NULL の場合、照合関数は削除されます。同じ名前の照合関数がすべて削除されると、その照合はもう使えなくなります。</target>
        </trans-unit>
        <trans-unit id="3a3d71778e0851af7f19eb98c05ebd04280b893c" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">5番目のパラメーターは任意のポインターです。関数の実装は、&lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;を使用してこのポインターにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="8991c375d182bf0ed874e01ceb3c3fba4c90a4d1" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">5番目のパラメーターは任意のポインターです。関数の実装は、&lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;を使用してこのポインターにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="8b5fa94425e25711d656d2caafbaef27474f2b42" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to change the way it deals with files. For example, an application that does not care about crash recovery or rollback might make the open of a journal file a no-op. Writes to this journal would also be no-ops, and any attempt to read the journal would return SQLITE_IOERR. Or the implementation might recognize that a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly.</source>
          <target state="translated">ファイルI/Oの実装では、オブジェクトタイプフラグを使用してファイルの扱い方を変更することができます。例えば、クラッシュのリカバリやロールバックを気にしないアプリケーションでは、ジャーナルファイルをオープンすることはできません。このジャーナルへの書き込みも無効となり、ジャーナルを読もうとすると SQLITE_IOERR を返すことになります。あるいは、データベースファイルがページアラインメントされたセクタの読み書きをランダムな順序で行うことを認識し、それに応じてI/Oサブシステムをセットアップする実装も考えられます。</target>
        </trans-unit>
        <trans-unit id="2ace627b4eb1891a06a62ee2e61523c0922ec242" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to changes the way it deals with files. For example, an application that does not care about crash recovery or rollback, might make the open of a journal file a no-op. Writes to this journal are also a no-op. Any attempt to read the journal returns &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;. Or the implementation might recognize the a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly. SQLite might also add one of the following flags to the xOpen method:</source>
          <target state="translated">ファイルI / O実装は、オブジェクトタイプフラグを使用して、ファイルの処理方法を変更できます。たとえば、クラッシュからの回復やロールバックを気にしないアプリケーションでは、ジャーナルファイルを開くことができない場合があります。このジャーナルへの書き込みもノーオペレーションです。ジャーナルを読み取ろうとすると、&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;が返されます。あるいは、データベースファイルがランダムな順序でページ揃えされたセクターの読み取りと書き込みを行い、それに応じてI / Oサブシステムをセットアップすることを実装が認識する場合があります。SQLiteは、xOpenメソッドに次のフラグのいずれかを追加する場合もあります。</target>
        </trans-unit>
        <trans-unit id="339116ded6000b1bbd01c16fbc4b426fdbec3ebf" translate="yes" xml:space="preserve">
          <source>The file change counter is a 4-byte big-endian integer at offset 24 that is incremented whenever the database file is unlocked after having been modified. When two or more processes are reading the same database file, each process can detect database changes from other processes by monitoring the change counter. A process will normally want to flush its database page cache when another process modified the database, since the cache has become stale. The file change counter facilitates this.</source>
          <target state="translated">ファイル変更カウンタはオフセット24にある4バイトのビッグエンディアン整数で、データベースファイルが変更された後にロックが解除されるたびにインクリメントされます。2つ以上のプロセスが同じデータベースファイルを読み込んでいる場合、各プロセスは変更カウンタを監視することで他のプロセスからのデータベースの変更を検出することができます。プロセスは通常、別のプロセスがデータベースを変更した場合、キャッシュが古くなっているため、データベースページのキャッシュをフラッシュしたいと思うでしょう。ファイル変更カウンタはこれを容易にします。</target>
        </trans-unit>
        <trans-unit id="3144a807afc9a81e0cce3e084ad085692d9830bb" translate="yes" xml:space="preserve">
          <source>The file format can be extended in future releases simply by adding new tables and/or column, preserving backwards compatibility.</source>
          <target state="translated">ファイル形式は、新しいテーブルや列を追加するだけで、将来のリリースで拡張でき、下位互換性を保つことができます。</target>
        </trans-unit>
        <trans-unit id="e6aaed4a8d57b71607b8967869bcc7f23189ec3d" translate="yes" xml:space="preserve">
          <source>The file format for indices was changed slightly in order to work around an inefficiency that can sometimes come up with GDBM when there are large indices having many entries with the same key. ** Incompatible Change **</source>
          <target state="translated">インデックスのファイル形式が少し変更されたのは、同じキーを持つ多数のエントリを持つ大きなインデックスがある場合に、GDBMで時々発生する非効率性を回避するためです。**互換性のない変更</target>
        </trans-unit>
        <trans-unit id="227aafe2527e84f2018568e74a1b6b84889b7a1b" translate="yes" xml:space="preserve">
          <source>The file format write version and file format read version at offsets 18 and 19 are intended to allow for enhancements of the file format in future versions of SQLite. In current versions of SQLite, both of these values are 1 for rollback journalling modes and 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; journalling mode. If a version of SQLite coded to the current file format specification encounters a database file where the read version is 1 or 2 but the write version is greater than 2, then the database file must be treated as read-only. If a database file with a read version greater than 2 is encountered, then that database cannot be read or written.</source>
          <target state="translated">オフセット18と19でのファイル形式書き込みバージョンとファイル形式読み取りバージョンは、SQLiteの将来のバージョンでファイル形式を拡張できるようにすることを目的としています。 SQLiteの現在のバージョンでは、これらの値はどちらも、ロールバックジャーナリングモードの場合は1、&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;ジャーナリングモードの場合は2 です。現在のファイル形式仕様にコーディングされたSQLiteのバージョンが、読み取りバージョンが1または2であるが書き込みバージョンが2より大きいデータベースファイルを検出した場合、データベースファイルは読み取り専用として扱う必要があります。読み取りバージョンが2より大きいデータベースファイルが検出された場合、そのデータベースの読み取りまたは書き込みはできません。</target>
        </trans-unit>
        <trans-unit id="57007ced430f8a0cf3127ebbd04af2dceb5d897b" translate="yes" xml:space="preserve">
          <source>The file-handle open on the</source>
          <target state="translated">で開いているファイルハンドルは</target>
        </trans-unit>
        <trans-unit id="b75893e55d63ac0a30441dba63c6c7335b33555b" translate="yes" xml:space="preserve">
          <source>The file-system</source>
          <target state="translated">ファイルシステム</target>
        </trans-unit>
        <trans-unit id="c1f230eea69094b4593dd99813cb077b78f99716" translate="yes" xml:space="preserve">
          <source>The filename for the database to be attached is the value of the expression that occurs before the AS keyword. The filename of the database follows the same semantics as the filename argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;; the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; results in an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and an empty string results in a new temporary database. The filename argument can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filename processing is enable on the database connection. The default behavior is for URI filenames to be disabled, however that might change in a future release of SQLite, so application developers are advised to plan accordingly.</source>
          <target state="translated">接続するデータベースのファイル名は、ASキーワードの前にある式の値です。データベースのファイル名は、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;および&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;のファイル名引数と同じセマンティクスに従います。特別な名前 &quot; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &quot; &lt;a href=&quot;inmemorydb&quot;&gt;はインメモリデータベースを作成&lt;/a&gt;し、空の文字列は新しい一時データベースを作成します。データベース接続でURIファイル名処理が有効になっている場合、filename引数には&lt;a href=&quot;uri&quot;&gt;URIファイル&lt;/a&gt;名を指定できます。デフォルトの動作ではURIファイル名が無効になりますが、SQLiteの将来のリリースで変更される可能性があるため、アプリケーション開発者はそれに応じて計画することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f17e1c0d84ff3c2fe25d0856ea88c3fbd19c5fb1" translate="yes" xml:space="preserve">
          <source>The filename in the INTO clause can be an arbitrary SQL expression that evaluates to a string. The file named by the INTO clause must not previously exist, or else it must be an empty file, or the VACUUM INTO command will fail with an error.</source>
          <target state="translated">INTO句のファイル名には、文字列として評価される任意のSQL式を指定することができます。INTO句で指定されたファイルは、以前に存在していないか、空のファイルでなければなりません。</target>
        </trans-unit>
        <trans-unit id="d4df05c7fc29b7702e9fa3ab7eeeb629cbcad3f5" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">この関数によって返されるファイル名は、&lt;a href=&quot;../vfs&quot;&gt;VFSの&lt;/a&gt; xFullPathnameメソッドの出力です。つまり、データベースを開くために使用されたファイル名が元々URIまたは相対パス名であったとしても、ファイル名は絶対パス名になります。</target>
        </trans-unit>
        <trans-unit id="9485b160522d31184c8916615322f5219f0612b8" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">この関数によって返されるファイル名は、&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt; xFullPathnameメソッドの出力です。つまり、データベースを開くために使用されたファイル名が元々URIまたは相対パス名であったとしても、ファイル名は絶対パス名になります。</target>
        </trans-unit>
        <trans-unit id="fc318f399f5ecbc4db919258057f39b26883fdf3" translate="yes" xml:space="preserve">
          <source>The final answer is found by looking for a string with ind==0. If the original sudoku problem did not have a unique solution, then the query will return all possible solutions. If the original problem was unsolvable, then no rows will be returned. In this case, the unique answer is:</source>
          <target state="translated">最終的な答えは、ind==0の文字列を探して見つけます。 元のすどくの問題が一意の解を持っていなかった場合、クエリは可能性のあるすべての解を返します。元の問題が解けなかった場合、行は何も返されません。この場合、ユニークな解答は</target>
        </trans-unit>
        <trans-unit id="0fa7031611bf07c03077958f2b8ed29a77590306" translate="yes" xml:space="preserve">
          <source>The final argument is an output variable. If successful, (*ppOut) should be set to point to the new tokenizer handle and SQLITE_OK returned. If an error occurs, some value other than SQLITE_OK should be returned. In this case, fts5 assumes that the final value of *ppOut is undefined.</source>
          <target state="translated">最後の引数は出力変数です。成功した場合、(*ppOut)は新しいトークナイザーハンドルを指すように設定され、SQLITE_OKが返されます。エラーが発生した場合は、SQLITE_OK以外の値を返さなければなりません。この場合、fts5 は *ppOut の最終値が未定義であることを前提としています。</target>
        </trans-unit>
        <trans-unit id="3adcbd65298a5982e7a64803692e07245861c301" translate="yes" xml:space="preserve">
          <source>The final byte of an encoded FTS varint has its most significant bit cleared. All preceding bytes have the most significant bit set. Data is stored in the remaining seven least significant bits of each byte. The first byte of the encoded representation contains the least significant seven bits of the encoded integer value. The second byte of the encoded representation, if it is present, contains the seven next least significant bits of the integer value, and so on. The following table contains examples of encoded integer values:</source>
          <target state="translated">エンコードされた FTS varint の最後のバイトは、その最上位ビットがクリアされます。それ以前のすべてのバイトは最上位ビットがセットされています。データは各バイトの残りの最下位7ビットに格納される。符号化された表現の最初のバイトは、符号化された整数値の最下位7ビットを含む。符号化された表現の2番目のバイトは、存在する場合、整数値の次の最下位7ビットを含みます。符号化された整数値の例を以下の表に示す。</target>
        </trans-unit>
        <trans-unit id="c65b7966b6f5867eece6741b751cabc0c349ca6a" translate="yes" xml:space="preserve">
          <source>The final line of the example (the &quot;.system c:/work/dataout.csv&quot;) has the same effect as double-clicking on the c:/work/dataout.csv file in windows. This will typically bring up a spreadsheet program to display the CSV file.</source>
          <target state="translated">例の最後の行(「.system c:/work/dataout.csv」)は、ウィンドウズのc:/work/dataout.csvファイルをダブルクリックしたのと同じ効果があります。これにより、通常はCSVファイルを表示するための表計算プログラムが表示されます。</target>
        </trans-unit>
        <trans-unit id="312ab3f0c70e0337ccdf666710177cbb51a2f6d3" translate="yes" xml:space="preserve">
          <source>The final query in the block above may not work as expected. Because the &quot;*&quot; character is inside the double-quotes, it will be passed to the tokenizer, which will likely discard it (or perhaps, depending on the specific tokenizer in use, include it as part of the final token) instead of recognizing it as a special FTS character.</source>
          <target state="translated">上のブロックの最後のクエリは期待通りには動作しないかもしれません。文字 &quot;*&quot; はダブルクォートの中に入っているため、トークン化ツールに渡され、トークン化ツールはこれを特別な FTS 文字として認識するのではなく、破棄します (使用しているトークン化ツールによっては、最終的なトークンの一部として含めることもあります)。</target>
        </trans-unit>
        <trans-unit id="a564ec7adef18f2e787e1258b9aed3803202963e" translate="yes" xml:space="preserve">
          <source>The final recovery step is to reduce the exclusive lock back to a shared lock. Once this happens, the database is back in the state that it would have been if the aborted transaction had never started. Since all of this recovery activity happens completely automatically and transparently, it appears to the program using SQLite as if the aborted transaction had never begun.</source>
          <target state="translated">最終的な回復ステップは、排他ロックを共有ロックに戻すことです。これが起こると、データベースは、中断されたトランザクションが開始されなかった場合の状態に戻ります。この復旧作業はすべて完全に自動的かつ透過的に行われるため、SQLiteを使用するプログラムからは、中断されたトランザクションが開始されていなかったかのように見えます。</target>
        </trans-unit>
        <trans-unit id="434e32f7c5be2c22a40571665c3031a75ce803d2" translate="yes" xml:space="preserve">
          <source>The final source of large memory allocations is the space to hold the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that result from compiling complex SQL operations. Ongoing work by the SQLite developers is reducing the amount of space required here. But large and complex queries might still require &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that are several kilobytes in size. The only workaround at the moment is for the application to break complex SQL operations up into two or more smaller and simpler operations contained in separate &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">大量のメモリ割り当ての最後のソースは、複雑なSQL操作のコンパイルから生じる&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;を保持するスペースです。 SQLite開発者による進行中の作業により、ここで必要なスペースの量が減少しています。ただし、大規模で複雑なクエリでは、サイズが数キロバイトの&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;が必要になる場合があります。現時点での唯一の回避策は、アプリケーションが、複雑なSQL操作を、別々の&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメントに&lt;/a&gt;含まれる2つ以上のより単純な操作に分割することです。</target>
        </trans-unit>
        <trans-unit id="2e5be990568c2b06d13617fdb20a3f4473d59b9c" translate="yes" xml:space="preserve">
          <source>The final step in a multi-file commit is to delete the individual rollback journals and drop the exclusive locks on the database files so that other processes can see the changes. This corresponds to &lt;a href=&quot;#section_3_12&quot;&gt;step 3.12&lt;/a&gt; in the single-file commit sequence.</source>
          <target state="translated">マルチファイルコミットの最後の手順は、個々のロールバックジャーナルを削除し、データベースファイルの排他ロックを削除して、他のプロセスが変更を確認できるようにすることです。これは、単一ファイルのコミットシーケンスの&lt;a href=&quot;#section_3_12&quot;&gt;ステップ3.12&lt;/a&gt;に対応します。</target>
        </trans-unit>
        <trans-unit id="570119a07afaf61a9f20cf9abd68b217ebf33834" translate="yes" xml:space="preserve">
          <source>The final three arguments passed to the auxiliary function callback are similar to the three arguments passed to the implementation of a scalar SQL function. All arguments except the first passed to the auxiliary function are available to the implementation in the apVal[] array. The implementation should return a result or error via the content handle pCtx.</source>
          <target state="translated">補助関数のコールバックに渡される最後の3つの引数は、スカラーSQL関数の実装に渡される3つの引数と似ています。補助関数に渡される最初の引数以外のすべての引数は、実装ではapVal[]配列で利用可能です。実装は、結果またはエラーをコンテンツハンドルpCtxを介して返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="72acf6716754df5bf7660108439b7caacc7e6afa" translate="yes" xml:space="preserve">
          <source>The first 100 bytes of the database file comprise the database file header. The database file header is divided into fields as shown by the table below. All multibyte fields in the database file header are stored with the most significant byte first (big-endian).</source>
          <target state="translated">データベースファイルの最初の100バイトは、データベースファイルヘッダからなる。データベースファイルヘッダは、以下の表に示すようにフィールドに分割されています。データベースファイルヘッダ内のすべてのマルチバイトフィールドは、最上位バイトを先頭にして格納されます(ビッグエンディアン)。</target>
        </trans-unit>
        <trans-unit id="7ad8baeb9b6a7d25df8e53c7bba57a3b07d6a12e" translate="yes" xml:space="preserve">
          <source>The first 136 bytes of the shm file are a header. The shm header has three main divisions as follows:</source>
          <target state="translated">shmファイルの最初の136バイトはヘッダです。shmのヘッダは以下のように3つの主要な分割があります。</target>
        </trans-unit>
        <trans-unit id="32a4d848523b5982a35dd9ccae2a5e300c48ac95" translate="yes" xml:space="preserve">
          <source>The first 8 bytes of the</source>
          <target state="translated">の最初の8バイトは</target>
        </trans-unit>
        <trans-unit id="31e639e14579d85dee4c60a5aeaa903eaa1984f2" translate="yes" xml:space="preserve">
          <source>The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex() method. The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex. This function returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint.</source>
          <target state="translated">第一引数は、xBestIndex()メソッドの第一引数であるsqlite3_index_infoオブジェクトでなければなりません。第2引数は、xBestIndexに渡されたsqlite3_index_info構造体に属するaConstraint[]配列へのインデックスでなければなりません。この関数は、対応する制約の照合順序の名前を含むバッファへのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="756a3aef230a7b2fc01840e9c05f1d8a68c861b7" translate="yes" xml:space="preserve">
          <source>The first argument passed should be the database handle to register the extension with. The second and third arguments should both be passed 0.</source>
          <target state="translated">最初の引数には、拡張機能を登録するデータベースハンドルを渡す必要があります。第二引数と第三引数はどちらも0を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="7fa580625e479f237836af3af275aa2f6a47351d" translate="yes" xml:space="preserve">
          <source>The first argument passed to an auxiliary function callback is a pointer to a structure containing methods that may be invoked in order to obtain information regarding the current query or row. The second argument is an opaque handle that should be passed as the first argument to any such method invocation. For example, the following auxiliary function definition returns the total number of tokens in all columns of the current row:</source>
          <target state="translated">補助関数コールバックに渡される第一引数は、現在のクエリまたは行に関する情報を取得するために呼び出される可能性のあるメソッドを含む構造体へのポインタです。第2引数は不透明なハンドルで、このようなメソッド呼び出しの第1引数として渡されるべきものです。例えば、以下の補助関数の定義は、現在の行の全列のトークンの総数を返します。</target>
        </trans-unit>
        <trans-unit id="d4428415829da9afdeca7abddd54df2e62906cce" translate="yes" xml:space="preserve">
          <source>The first argument passed to this function is a copy of the (void*) pointer provided by the application when the fts5_tokenizer object was registered with FTS5 (the third argument to xCreateTokenizer()). The second and third arguments are an array of nul-terminated strings containing the tokenizer arguments, if any, specified following the tokenizer name as part of the CREATE VIRTUAL TABLE statement used to create the FTS5 table.</source>
          <target state="translated">この関数に渡される第一引数は、fts5_tokenizerオブジェクトがFTS5に登録されたときにアプリケーションによって提供された(void*)ポインタのコピーです(xCreateTokenizer()の第三引数)。2 番目と 3 番目の引数は、FTS5 テーブルを作成するために使用された CREATE VIRTUAL TABLE 文の一部としてトーケナイザー名の後に指定されたトーケナイザー引数があれば、それを含むヌル終端文字列の配列です。</target>
        </trans-unit>
        <trans-unit id="3ddc48958f41facca8a1ecdc60ac948a59cb2349" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must be the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pointer as the first parameter to this method. The second argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must a zero-terminated UTF-8 string that contains a well-formed &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that defines the columns in the virtual table and their data types. The name of the table in this CREATE TABLE statement is ignored, as are all constraints. Only the column names and datatypes matter. The CREATE TABLE statement string need not to be held in persistent memory. The string can be deallocated and/or reused as soon as the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; routine returns.</source>
          <target state="translated">最初の引数&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）は&lt;/a&gt;同じである必要があり&lt;a href=&quot;c3ref/sqlite3&quot;&gt;、データベース接続&lt;/a&gt;この方法の最初のパラメータとして、ポインタ。&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;の2番目の引数は、仮想テーブルの列とそのデータ型を定義する整形式の&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントを含む、ゼロで終了するUTF-8文字列である必要があります。このCREATE TABLEステートメントのテーブルの名前は、すべての制約と同様に無視されます。重要なのは列名とデータ型だけです。 CREATE TABLEステートメント文字列は、永続メモリに保持する必要はありません。&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;ルーチンが戻るとすぐに、文字列の割り当てを解除したり、再利用したりできます。</target>
        </trans-unit>
        <trans-unit id="1aed5522193a69fc6ff8aa89cff3e41266a3f600" translate="yes" xml:space="preserve">
          <source>The first argument to all three special SQL scalar functions must be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table that the function is applied to. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically-generated column found on all FTS tables that has the same name as the FTS table itself. For example, given an FTS table named &quot;mail&quot;:</source>
          <target state="translated">3つの特別なSQLスカラー関数すべての最初の引数は、関数が適用されるFTSテーブルの&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS非表示列&lt;/a&gt;である必要があります。&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隠された列は、&lt;/a&gt; FTSテーブル自体と同じ名前を持つすべてのFTSテーブルで見つかっ自動的に生成された列です。たとえば、「mail」という名前のFTSテーブルがあるとします。</target>
        </trans-unit>
        <trans-unit id="952294bca557c59738bac0e545034c52a263067f" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">sqlite3_config（）の最初の引数は、SQLite のどのプロパティを&lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;構成&lt;/a&gt;するかを決定する整数構成オプションです。後続の引数は、最初の引数の&lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;構成オプション&lt;/a&gt;によって異なります。</target>
        </trans-unit>
        <trans-unit id="f875f5d7c01e9a29524328575e142babf2bae3ae" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">sqlite3_config（）の最初の引数は、SQLite のどのプロパティを&lt;a href=&quot;c_config_covering_index_scan&quot;&gt;構成&lt;/a&gt;するかを決定する整数構成オプションです。後続の引数は、最初の引数の&lt;a href=&quot;c_config_covering_index_scan&quot;&gt;構成オプション&lt;/a&gt;によって異なります。</target>
        </trans-unit>
        <trans-unit id="3f0ed77e9965fa2c39bb9cbb993108ef55b7d05b" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">busyハンドラーの最初の引数は、sqlite3_busy_handler（）の3番目の引数であるvoid *ポインターのコピーです。ビジーハンドラーコールバックの2番目の引数は、ビジーハンドラーが同じロックイベントに対して以前に呼び出された回数です。ビジーコールバックが0を返した場合、データベースへのアクセスは試行されず、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;がアプリケーションに返されます。コールバックがゼロ以外を返す場合、データベースへのアクセスが再度試行され、サイクルが繰り返されます。</target>
        </trans-unit>
        <trans-unit id="73aa47dd980f8a887b15a2decc4e912f8fd4e328" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">busyハンドラーの最初の引数は、sqlite3_busy_handler（）の3番目の引数であるvoid *ポインターのコピーです。ビジーハンドラーコールバックの2番目の引数は、ビジーハンドラーが同じロックイベントに対して以前に呼び出された回数です。ビジーコールバックが0を返した場合、データベースへのアクセスは試行されず、&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;がアプリケーションに返されます。コールバックがゼロ以外を返す場合、データベースへのアクセスが再度試行され、サイクルが繰り返されます。</target>
        </trans-unit>
        <trans-unit id="395ff21e8cf7b4d90e5bc3764e07164a7c24e72d" translate="yes" xml:space="preserve">
          <source>The first argument to the callback is just a copy of the fourth argument to &lt;b&gt;sqlite_exec&lt;/b&gt; This parameter can be used to pass arbitrary information through to the callback function from client code. The second argument is the number of columns in the query result. The third argument is an array of pointers to strings where each string is a single column of the result for that record. Note that the callback function reports a NULL value in the database as a NULL pointer, which is very different from an empty string. If the i-th parameter is an empty string, we will get:</source>
          <target state="translated">コールバックの最初の引数は、&lt;b&gt;sqlite_exec&lt;/b&gt;の4番目の引数のコピーです。このパラメーターを使用して、クライアントコードからコールバック関数に任意の情報を渡すことができます。 2番目の引数は、クエリ結果の列数です。 3番目の引数は、文字列へのポインタの配列で、各文字列はそのレコードの結果の単一の列です。コールバック関数は、データベース内のNULL値をNULLポインターとして報告することに注意してください。これは、空の文字列とは大きく異なります。 i番目のパラメーターが空の文字列の場合、次のようになります。</target>
        </trans-unit>
        <trans-unit id="19ed31ae74a9a14120db33894759ec36b8a3df0f" translate="yes" xml:space="preserve">
          <source>The first argument to the snippet function must always be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table being queried and from which the snippet is to be taken. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically generated column with the same name as the FTS table itself.</source>
          <target state="translated">スニペット関数の最初の引数は、常に、照会されているFTSテーブルの&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS非表示列&lt;/a&gt;であり、そこからスニペットが取得されます。&lt;a href=&quot;fts3#hiddencol&quot;&gt;カラムを隠されたFTSは、&lt;/a&gt; FTSテーブル自体と同じ名前を使用して自動的に生成された列です。</target>
        </trans-unit>
        <trans-unit id="a3c117d3156af5d9687ce63c9ca2baca71f1029c" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">sqlite3_bind _ *（）ルーチンへの最初の引数は常にへのポインタである&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;から返されたオブジェクト&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;またはその変種。</target>
        </trans-unit>
        <trans-unit id="e62bb2c9601439134c1919cc9d703235a3e8dcf1" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">sqlite3_bind _ *（）ルーチンへの最初の引数は常にへのポインタである&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;から返されたオブジェクト&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;またはその変種。</target>
        </trans-unit>
        <trans-unit id="4376fc02622bfe056753a887d840cb5de850cf76" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3session_config() function must be one of the SQLITE_SESSION_CONFIG_XXX constants defined below. The interpretation of the (void*) value passed as the second parameter and the effect of calling this function depends on the value of the first parameter.</source>
          <target state="translated">sqlite3session_config()関数の第1引数は、以下に定義されているSQLITE_SESSION_CONFIG_XXX定数のいずれかでなければなりません。2番目のパラメータとして渡された(void*)値の解釈と、この関数を呼び出す効果は、1番目のパラメータの値に依存します。</target>
        </trans-unit>
        <trans-unit id="46628205e32bedcd53350a6840ee825a63d42391" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">これらのインターフェースの最初の引数は、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。これらの関数は、ステートメントによって返されるN番目の結果列に関する情報を返します。Nは2番目の関数引数です。これらのルーチンの左端の列は列0です。</target>
        </trans-unit>
        <trans-unit id="0f76a71e763d5bd4fbae26e4a6f14b3c938ceb32" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">これらのインターフェースの最初の引数は、&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。これらの関数は、ステートメントによって返されるN番目の結果列に関する情報を返します。Nは2番目の関数引数です。これらのルーチンの左端の列は列0です。</target>
        </trans-unit>
        <trans-unit id="a5ff723764d00dd9ac3f381e3bed0a1f08296ed5" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">最初の引数 &quot;db&quot;は、以前に成功した&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）の&lt;/a&gt;呼び出しから取得された&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。データベース接続が閉じられていない必要があります。</target>
        </trans-unit>
        <trans-unit id="691e78895187de6910913a151c966bb350230789" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">最初の引数 &quot;db&quot;は、以前に成功した&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;または&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）の&lt;/a&gt;呼び出しから取得された&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。データベース接続が閉じられていない必要があります。</target>
        </trans-unit>
        <trans-unit id="5da926bf27ba88ce6fa226bb8489971c4b0badd1" translate="yes" xml:space="preserve">
          <source>The first attempt at closing security gaps in pointer passing was to prevent pointer values from being forged. This was accomplished by having the sender attach a subtype to each pointer using &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; and having the receiver verify that subtype using &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and reject pointers that had an incorrect subtype. Since there is no way to attach a subtype to a result using pure SQL, this prevents pointers from being forged using SQL. The only way to send a pointer is to use C code. If an attacker can set a subtype, then he is also able to forge a pointer without the help of SQLite.</source>
          <target state="translated">ポインターの受け渡しにおけるセキュリティのギャップを埋める最初の試みは、ポインターの値が偽造されるのを防ぐことでした。これは、送信者が使用して、各ポインタにサブタイプを取り付けることによって達成された&lt;a href=&quot;c3ref/result_subtype&quot;&gt;（sqlite3_result_subtypeを）&lt;/a&gt;と受信機が使用してそのサブタイプを検証有する&lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtypeを（）&lt;/a&gt;と誤っサブタイプを持っていたポインタを拒否する。純粋なSQLを使用して結果にサブタイプをアタッチする方法がないため、SQLを使用してポインターが偽造されるのを防ぎます。ポインタを送信する唯一の方法は、Cコードを使用することです。攻撃者がサブタイプを設定できる場合、攻撃者はSQLiteの助けなしにポインタを偽造することもできます。</target>
        </trans-unit>
        <trans-unit id="b3f912cc569c0361b5c2cd2202f03f7409e6b0b1" translate="yes" xml:space="preserve">
          <source>The first beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0の最初のベータリリースです。</target>
        </trans-unit>
        <trans-unit id="85577f9e39e1e56bdcef30a17afd1e7fd9d77720" translate="yes" xml:space="preserve">
          <source>The first byte of the header is a flag byte. The least significant bit of the flag byte determines whether the coordinate pairs that follow the header are stored big-endian or little-endian. A value of 0 for the least significant bit means big-endian and a value of 1 means little endian. Other bits of the first byte in the header are reserved for future expansion.</source>
          <target state="translated">ヘッダの最初のバ イ ト は フ ラ グバ イ ト です。フラグバイトの最下位ビットは、ヘッダに続く座標ペアがビッグエンディアンかリトルエンディアンかを決定する。最下位ビットの値が0であればビッグエンディアンを意味し、1であればリトルエンディアンを意味する。ヘッダの最初のバイトの他のビットは、将来の拡張のために予約されています。</target>
        </trans-unit>
        <trans-unit id="f63d26f2f4bc609cd955a5edef912da4a0a9006c" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; on the iterator moves it to point to the first change in the changeset (or to EOF, if the changeset is completely empty). sqlite3changeset_next() returns SQLITE_ROW if it moves the iterator to point to a valid entry, SQLITE_DONE if it moves the iterator to EOF, or an SQLite error code if an error occurs.</source>
          <target state="translated">イテレータで&lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;を最初に呼び出すと、変更セットの最初の変更（または変更セットが完全に空の場合はEOF）を指すように移動します。sqlite3changeset_next（）は、イテレータを有効なエントリを指すように移動するとSQLITE_ROWを返し、イテレータをEOFに移動するとSQLITE_DONEを返し、エラーが発生した場合はSQLiteエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="261c910c7fa661af930e1c363bad2fff3671bdea" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">sqlite3_backup_step（）への最初の呼び出しは、宛先ファイルの排他ロックを取得します。sqlite3_backup_finish（）が呼び出されるか、バックアップ操作が完了してsqlite3_backup_step（）が&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONEを&lt;/a&gt;返すまで、排他ロックは解放されません。sqlite3_backup_step（）を呼び出すたびに&lt;a href=&quot;lockingv3#shared_lock&quot;&gt;共有ロック&lt;/a&gt;が取得されますsqlite3_backup_step（）呼び出しの期間中続くソースデータベース。ソースデータベースはsqlite3_backup_step（）の呼び出し間でロックされないため、ソースデータベースはバックアッププロセスの途中で変更される可能性があります。ソースデータベースが外部プロセスによって、またはバックアップ操作で使用されているもの以外のデータベース接続を介して変更された場合、バックアップはsqlite3_backup_step（）への次の呼び出しによって自動的に再開されます。バックアップ操作で使用されるのと同じデータベース接続を使用してソースデータベースが変更されると、バックアップデータベースが同時に自動的に更新されます。</target>
        </trans-unit>
        <trans-unit id="57eb736cb2a536a07c53b0e0f817765662d0da0a" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">sqlite3_backup_step（）への最初の呼び出しは、宛先ファイルの排他ロックを取得します。sqlite3_backup_finish（）が呼び出されるか、バックアップ操作が完了してsqlite3_backup_step（）が&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONEを&lt;/a&gt;返すまで、排他ロックは解放されません。sqlite3_backup_step（）を呼び出すたびに&lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;共有ロック&lt;/a&gt;が取得されますsqlite3_backup_step（）呼び出しの期間中続くソースデータベース。ソースデータベースはsqlite3_backup_step（）の呼び出し間でロックされないため、ソースデータベースはバックアッププロセスの途中で変更される可能性があります。ソースデータベースが外部プロセスによって、またはバックアップ操作で使用されているもの以外のデータベース接続を介して変更された場合、バックアップはsqlite3_backup_step（）への次の呼び出しによって自動的に再開されます。バックアップ操作で使用されるのと同じデータベース接続を使用してソースデータベースが変更されると、バックアップデータベースが同時に自動的に更新されます。</target>
        </trans-unit>
        <trans-unit id="878621de1d1518fe649327da44b122a6dcc1e4c1" translate="yes" xml:space="preserve">
          <source>The first code for TH3 was laid down on 2008-09-25. An intense effort over the next 10 months resulted in TH3 achieving 100% MC/DC on 2009-07-25. The TH3 code continues to be improved and expanded.</source>
          <target state="translated">TH3 の最初のコードは 2008-09-25 に策定されました。その後10ヶ月間の努力の結果、2009年7月25日にTH3は100%MC/DCを達成しました。TH3 のコードは改良され、拡張され続けています。</target>
        </trans-unit>
        <trans-unit id="708a1cddc7d07a561f3445a868346de6a13841df" translate="yes" xml:space="preserve">
          <source>The first column is the schema name for the database that contains the tables. Examples: &quot;main&quot;, &quot;zone512&quot;.</source>
          <target state="translated">最初の列は、テーブルを含むデータベースのスキーマ名です。例としては、以下のようになります。&quot;main&quot;、&quot;zone512&quot;。</target>
        </trans-unit>
        <trans-unit id="9814feb56c887ece7381e15fd8887b6ec1a1d8c0" translate="yes" xml:space="preserve">
          <source>The first column of an SQLite R*Tree is similar to an integer primary key column of a normal SQLite table. It may only store a 64-bit signed integer value. Inserting a NULL value into this column causes SQLite to automatically generate a new unique primary key value. If an attempt is made to insert any other non-integer value into this column, the r-tree module silently converts it to an integer before writing it into the database.</source>
          <target state="translated">SQLite R*Tree の最初の列は、通常の SQLite テーブルの整数主キー列に似ています。64 ビット符号付き整数値のみを格納することができます。この列に NULL 値を挿入すると、SQLite は自動的に新しい一意の主キー値を生成します。この列に他の非整数値を挿入しようとすると、r-tree モジュールはそれをデータベースに書き込む前に静かに整数に変換します。</target>
        </trans-unit>
        <trans-unit id="840bd12d54aba66c9e7cdaff39f91dd2e3886bf1" translate="yes" xml:space="preserve">
          <source>The first condition causes all of the trunk check-ins to be displayed and the second and third cause check-ins that merge into or fork from the trunk to also be included. The three conditions are implemented by the three OR-connected EXISTS statements in the WHERE clause of the query. The slowdown that occurred with the NGQP was caused by the second and third conditions. The problem is the same in each, so we will examine just the second one. The subquery of the second condition can be rewritten (with minor and immaterial simplifications) as follows:</source>
          <target state="translated">最初の条件では、トランクのすべてのチェックインが表示され、2 番目と 3 番目では、トランクにマージしたり、トランクからフォークしたりするチェックインも含まれます。この3つの条件は、クエリのWHERE句にある3つのOR-connected EXISTS文によって実装されています。NGQPで発生したスローダウンは、2つ目と3つ目の条件が原因でした。問題はそれぞれで同じなので、2つ目の条件だけを見ていきます。2つ目の条件の副問い合わせは、以下のように書き換えることができます(軽微で重要ではない簡略化をしています)。</target>
        </trans-unit>
        <trans-unit id="d78f5e7f65436952c61eefc9d02af59c750bcb9f" translate="yes" xml:space="preserve">
          <source>The first five fields of the sqlite3_rtree_query_info structure are identical to the sqlite3_rtree_geometry structure, and have exactly the same meaning. The sqlite3_rtree_query_info structure also contains nCoord and aCoord fields which have the same meaning as the parameter of the same name in the xGeom callback.</source>
          <target state="translated">sqlite3_rtree_query_info構造体の最初の5つのフィールドはsqlite3_rtree_geometry構造体と同じで、全く同じ意味を持ちます。sqlite3_rtree_query_info構造体は、xGeomコールバックの同名のパラメータと同じ意味を持つnCoordとaCoordフィールドも含んでいます。</target>
        </trans-unit>
        <trans-unit id="8e073e98c04e5afd81b1a912e72c323c17ce2eb5" translate="yes" xml:space="preserve">
          <source>The first form (with the &quot;VALUES&quot; keyword) creates one or more new rows in an existing table. If the column-name list after table-name is omitted then the number of values inserted into each row must be the same as the number of columns in the table. In this case the result of evaluating the left-most expression from each term of the VALUES list is inserted into the left-most column of each new row, and so forth for each subsequent expression. If a column-name list is specified, then the number of values in each term of the VALUE list must match the number of specified columns. Each of the named columns of the new row is populated with the results of evaluating the corresponding VALUES expression. Table columns that do not appear in the column list are populated with the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default column value&lt;/a&gt; (specified as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement), or with NULL if no &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; is specified.</source>
          <target state="translated">最初の形式（「VALUES」キーワードを使用）では、既存のテーブルに1つ以上の新しい行を作成します。 table-nameの後のcolumn-nameリストが省略されている場合、各行に挿入される値の数は、テーブル内の列の数と同じでなければなりません。この場合、VALUESリストの各項の左端の式を評価した結果は、新しい各行の左端の列に挿入され、以降の各式で同様に続きます。列名リストを指定する場合、VALUEリストの各項の値の数は、指定した列の数と一致する必要があります。新しい行の名前付きの各列には、対応するVALUES式の評価結果が入力されます。列リストに表示されないテーブル列には、&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;デフォルトの列値&lt;/a&gt;が入力されます（&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントの一部として指定）、または&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;デフォルト値&lt;/a&gt;が指定されていない場合はNULLを使用。</target>
        </trans-unit>
        <trans-unit id="2570c22a55e27cbe9ad6c1dce2c1cff1bff0c5c4" translate="yes" xml:space="preserve">
          <source>The first form loads the edit distance coefficients from a table called 'TABLENAME'. Any prior coefficients are discarded. So when experimenting with weights and the weight table changes, simply rerun the single-argument form of editdist3() to reload revised coefficients. Note that the edit distance weights used by the editdist3() SQL function are independent from the weights used by the spellfix1 virtual table.</source>
          <target state="translated">最初のフォームは'TABLENAME'というテーブルから編集距離係数をロードします。それ以前の係数はすべて破棄されます。そのため、重みを実験していて重みテーブルが変更された場合、単純に editdist3()の単一引数フォームを再実行して、変更された係数を再ロードしてください。editdist3()SQL 関数で使用される編集距離の重みは、spellfix1 仮想テーブルで使用される重みとは独立していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7597ee6d3f1982d757a998bf7dd70b5fa125869a" translate="yes" xml:space="preserve">
          <source>The first form of the lag() function returns the result of evaluating expression</source>
          <target state="translated">lag()関数の最初の形式は,式</target>
        </trans-unit>
        <trans-unit id="99435f14d6ece88179aba89152e1459d1e98bf65" translate="yes" xml:space="preserve">
          <source>The first form of the lead() function returns the result of evaluating expression</source>
          <target state="translated">lead()関数の最初の形式は、式</target>
        </trans-unit>
        <trans-unit id="0e38dddff1d9fcb9023e44603abe1408f559a08e" translate="yes" xml:space="preserve">
          <source>The first form of this pragma queries the current journaling mode for</source>
          <target state="translated">このプラグマの最初の形式は、現在のジャーナリングモードの</target>
        </trans-unit>
        <trans-unit id="b8118a5225d858802697d63c772d9f2007991455" translate="yes" xml:space="preserve">
          <source>The first four columns a, b, c, and d of the index would be usable since those four columns form a prefix of the index and are all bound by equality constraints.</source>
          <target state="translated">インデックスの最初の4つの列a,b,c,およびdは、これら4つの列がインデックスの接頭辞を形成し、すべて等質性制約に拘束されているため、使用可能であろう。</target>
        </trans-unit>
        <trans-unit id="4ead6c16538264b763b7c6adde08cc0b22f7c9e0" translate="yes" xml:space="preserve">
          <source>The first group of queries in the log are extracting display options from the &quot;config&quot; and &quot;global_config&quot; tables of the Fossil database. Then there is a single complex query that extracts a list of all elements to be displayed on the timeline. This &quot;timeline&quot; query demonstrates that SQLite can easily process complex relational database queries involving multiple tables, subqueries, and complex WHERE clause constraints, and it can make effective use of indexes to solve the queries with minimal disk I/O.</source>
          <target state="translated">ログの最初のクエリグループは、Fossilデータベースの &quot;config &quot;と &quot;global_config &quot;テーブルから表示オプションを抽出しています。そして、タイムラインに表示されるすべての要素のリストを抽出する単一の複雑なクエリがあります。この「Timeline」クエリは、SQLiteが複数のテーブル、サブクエリ、複雑なWHERE句制約を含む複雑なリレーショナルデータベースクエリを簡単に処理でき、インデックスを効果的に利用して最小限のディスクI/Oでクエリを解決できることを示しています。</target>
        </trans-unit>
        <trans-unit id="4e52fafda10d32765550d3edce2eeda11c3b4ffd" translate="yes" xml:space="preserve">
          <source>The first host parameter has an index of 1, not 0.</source>
          <target state="translated">最初のホストパラメータのインデックスは0ではなく1です。</target>
        </trans-unit>
        <trans-unit id="178a49643c52d6ff462985df8e6c238cfb8ec5cd" translate="yes" xml:space="preserve">
          <source>The first instruction of interest is the &lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; at 2. The AggReset instruction initializes the set of buckets to be the empty set and specifies the number of memory slots available in each bucket as P2. In this example, each bucket will hold 3 memory slots. It is not obvious, but if you look closely at the rest of the program you can figure out what each of these slots is intended for.</source>
          <target state="translated">関心の最初の命令である&lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; 2でAggReset命令は空集合であるとバケットのセットを初期化し、P2、各バケット内の利用可能なメモリスロットの数を指定します。この例では、各バケットが3つのメモリスロットを保持します。それは明らかではありませんが、プログラムの残りの部分をよく見ると、これらの各スロットが何を意図しているのかを理解できます。</target>
        </trans-unit>
        <trans-unit id="11dcba86733ec3f9c57f212488f98cc390a1b479" translate="yes" xml:space="preserve">
          <source>The first integer in the P4 integer array is the length of the array and does not become part of the permutation.</source>
          <target state="translated">P4 整数配列の最初の整数は配列の長さであり、順列の一部にはなりません。</target>
        </trans-unit>
        <trans-unit id="388856185e941f1980f4fd92691075a08784c68c" translate="yes" xml:space="preserve">
          <source>The first line of the script above causes the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to read and activate the run-time loadable extension for CSV. For an application, the equivalent C-language API is &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt;. Observe that the filename extension (ex: &quot;.dll&quot; or &quot;.so&quot; or &quot;.dylib&quot;) is omitted from the extension filename. Omitting the filename extension is not required, but it helps in making the script cross-platform. SQLite will automatically append the appropriate extension.</source>
          <target state="translated">上記のスクリプトの最初の行により、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルは&lt;/a&gt;、CSVのランタイムロード可能拡張機能を読み取り、アクティブ化します。アプリケーションの場合、同等のC言語APIは&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;です。ファイル名の拡張子（例：「.dll」、「。so」、「。dylib」）が拡張子のファイル名から省略されていることを確認します。ファイル名拡張子の省略は必須ではありませんが、スクリプトをクロスプラットフォームにするのに役立ちます。 SQLiteは自動的に適切な拡張子を追加します。</target>
        </trans-unit>
        <trans-unit id="75252c48c68a826da51013f5fcc062daddeb6d8f" translate="yes" xml:space="preserve">
          <source>The first of the above that is found to exist and have the write and execute bits set is used. The final &quot;.&quot; fallback is important for some applications that use SQLite inside of chroot jails that do not have the standard temporary file locations available.</source>
          <target state="translated">上記のうち、最初に存在し、書き込みおよび実行ビットが設定されていることが判明したものが使用されます。最後の&quot;.&quot;フォールバックは、標準の一時ファイルの場所が利用できない chroot jail の中で SQLite を使用するいくつかのアプリケーションにとって重要です。</target>
        </trans-unit>
        <trans-unit id="1f9a60bfbed88db253a25c41a987f86e19f4d6aa" translate="yes" xml:space="preserve">
          <source>The first page of a cell payload overflow chain. The page number is the b-tree page that contains the cell whose content has overflowed.</source>
          <target state="translated">セルのペイロードがオーバーフローしたチェインの最初のページ。ページ番号は、コンテンツがオーバーフローしたセルを含む b-tree ページです。</target>
        </trans-unit>
        <trans-unit id="571e717de8bab6f472a3daa4d0e34a129cf9485d" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">最初のパラメーターは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。このステートメントが&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントであり、その&lt;a href=&quot;lang_select&quot;&gt;SELECTの&lt;/a&gt;返された結果セットのN番目の列が（式やサブクエリではなく）テーブル列である場合、テーブル列の宣言された型が返されます。結果セットのN番目の列が式またはサブクエリの場合、NULLポインターが返されます。返される文字列は常にUTF-8でエンコードされています。</target>
        </trans-unit>
        <trans-unit id="2d95d478fea3b8287d0a6628b14c6c99e2b30bf0" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">最初のパラメーターは、&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。このステートメントが&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントであり、その&lt;a href=&quot;../lang_select&quot;&gt;SELECTの&lt;/a&gt;返された結果セットのN番目の列が（式やサブクエリではなく）テーブル列である場合、テーブル列の宣言された型が返されます。結果セットのN番目の列が式またはサブクエリの場合、NULLポインターが返されます。返される文字列は常にUTF-8でエンコードされています。</target>
        </trans-unit>
        <trans-unit id="c8355444303911368f3db824744273405e752637" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">最初のパラメーターは、SQL関数を追加する&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。アプリケーションが複数のデータベース接続を使用する場合、アプリケーション定義のSQL関数を各データベース接続に個別に追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="2034bce444668b7bc337245a2c547e0aff9b9fd1" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">最初のパラメーターは、SQL関数を追加する&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。アプリケーションが複数のデータベース接続を使用する場合、アプリケーション定義のSQL関数を各データベース接続に個別に追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="02bbb4f6b68ff55742031c8b1808d80607aaa103" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;#sqlite3_context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">最初のパラメーターは、集約関数を実装するxStepまたはxFinalコールバックルーチンへの最初のパラメーターである&lt;a href=&quot;#sqlite3_context&quot;&gt;SQL関数コンテキストの&lt;/a&gt;コピーである必要があります。</target>
        </trans-unit>
        <trans-unit id="303b1214ac90198e86e2d6fded39de6f12728048" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">最初のパラメーターは、集約関数を実装するxStepまたはxFinalコールバックルーチンへの最初のパラメーターである&lt;a href=&quot;context&quot;&gt;SQL関数コンテキストの&lt;/a&gt;コピーである必要があります。</target>
        </trans-unit>
        <trans-unit id="51bc3b9167a1367dcb303b210930c2e99a40f80a" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">呼び出されたときにコールバック関数に渡される最初のパラメーターは、コールバックの登録時にsqlite3_wal_hook（）に渡される3番目のパラメーターのコピーです。2番目は、データベースハンドルのコピーです。3番目のパラメーターは、「メイン」または&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;されたデータベースの名前のいずれかに書き込まれたデータベースの名前です。4番目のパラメーターは、コミットされたばかりのページを含む、現在の先行書き込みログファイル内のページ数です。</target>
        </trans-unit>
        <trans-unit id="8448fcb45b7f072723f93590a80d37aef6a727c3" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">呼び出されたときにコールバック関数に渡される最初のパラメーターは、コールバックの登録時にsqlite3_wal_hook（）に渡される3番目のパラメーターのコピーです。2番目は、データベースハンドルのコピーです。3番目のパラメーターは、「メイン」または&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;されたデータベースの名前のいずれかに書き込まれたデータベースの名前です。4番目のパラメーターは、コミットされたばかりのページを含む、現在の先行書き込みログファイル内のページ数です。</target>
        </trans-unit>
        <trans-unit id="114b67e4b3a89669211882b27d3030f929c0b812" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">オーソライザーコールバックへの最初のパラメーターは、sqlite3_set_authorizer（）インターフェースへの3番目のパラメーターのコピーです。コールバックの2番目のパラメーターは、承認する特定のアクションを指定する整数の&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;アクションコード&lt;/a&gt;です。コールバックの3番目から6番目のパラメーターは、許可されるアクションに関する追加の詳細を含むNULLポインターまたはゼロで終了する文字列です。アプリケーションは常に、許可コールバックの3番目から6番目のパラメーターのいずれかでNULLポインターに遭遇するように準備する必要があります。</target>
        </trans-unit>
        <trans-unit id="031900d436ad256c6483a02e204c32e4df2ca84e" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;c_alter_table&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">オーソライザーコールバックへの最初のパラメーターは、sqlite3_set_authorizer（）インターフェースへの3番目のパラメーターのコピーです。コールバックの2番目のパラメーターは、承認する特定のアクションを指定する整数の&lt;a href=&quot;c_alter_table&quot;&gt;アクションコード&lt;/a&gt;です。コールバックの3番目から6番目のパラメーターは、許可されるアクションに関する追加の詳細を含むNULLポインターまたはゼロで終了する文字列です。アプリケーションは常に、許可コールバックの3番目から6番目のパラメーターのいずれかでNULLポインターに遭遇するように準備する必要があります。</target>
        </trans-unit>
        <trans-unit id="29c4884990e25d1601d544fb2189fcbf8e2210be" translate="yes" xml:space="preserve">
          <source>The first section introduces the concept of an SQL foreign key by example and defines the terminology used for the remainder of the document. Section 2 describes the steps an application must take in order to enable foreign key constraints in SQLite (it is disabled by default). The next section, section 3, describes the indexes that the user must create in order to use foreign key constraints, and those that should be created in order for foreign key constraints to function efficiently. Section 4 describes the advanced foreign key related features supported by SQLite and section 5 describes the way the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands are enhanced to support foreign key constraints. Finally, section 6 enumerates the missing features and limits of the current implementation.</source>
          <target state="translated">最初のセクションでは、例によってSQL外部キーの概念を紹介し、ドキュメントの残りの部分で使用される用語を定義します。セクション2では、SQLiteで外部キー制約を有効にするためにアプリケーションが実行する必要のある手順について説明します（デフォルトでは無効になっています）。次のセクションのセクション3では、外部キー制約を使用するためにユーザーが作成する必要があるインデックスと、外部キー制約を効率的に機能させるために作成する必要があるインデックスについて説明します。セクション4では、SQLiteでサポートされる拡張外部キー関連の機能について説明し、セクション5では、&lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt;および&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;コマンドを拡張して外部キー制約をサポートする方法について説明します。最後に、セクション6では、現在の実装で不足している機能と制限を列挙します。</target>
        </trans-unit>
        <trans-unit id="6abe8a139c8044b273ba74ec6b9c2e3f141ecabe" translate="yes" xml:space="preserve">
          <source>The first set of three values corresponds to the left-most column of the table (column 0) and the left-most matchable phrase in the query (phrase 0). If the table has more than one column, the second set of three values in the output array correspond to phrase 0 and column 1. Followed by phrase 0, column 2 and so on for all columns of the table. And so on for phrase 1, column 0, then phrase 1, column 1 etc. In other words, the data for occurrences of phrase</source>
          <target state="translated">3つの値の最初のセットは、テーブルの左端の列(列0)と、クエリの中で最も左に一致するフレーズ(フレーズ0)に対応します。テーブルに複数のカラムがある場合、出力配列の 2 番目の 3 つの値のセットは、フレーズ 0 とカラム 1 に対応します。続いて、テーブルのすべての列について、フレーズ 0、列 2 と続きます。そして、フレーズ 1、カラム 0、フレーズ 1、カラム 1 などと続きます。言い換えれば、フレーズ</target>
        </trans-unit>
        <trans-unit id="b88b9c17da99b9d9285ae75db888dfa7bebfc06c" translate="yes" xml:space="preserve">
          <source>The first six interfaces (_blob, _double, _int, _int64, _text, and _text16) each return the value of a result column in a specific data format. If the result column is not initially in the requested format (for example, if the query returns an integer but the sqlite3_column_text() interface is used to extract the value) then an automatic type conversion is performed.</source>
          <target state="translated">最初の6つのインタフェース(_blob,_double,_int,_int64,_text,_text16)はそれぞれ、結果カラムの値を特定のデータ形式で返します。結果カラムが最初に要求された形式ではない場合(例えば、クエリが整数を返し、値を抽出するためにsqlite3_column_text()インタフェースが使用されている場合など)、自動型変換が行われます。</target>
        </trans-unit>
        <trans-unit id="67231aa738e6314e6f80285f8fe72b39964cf222" translate="yes" xml:space="preserve">
          <source>The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the preceding timestring and modifiers. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</source>
          <target state="translated">最初の6つの修飾子（1から6）は、前のtimestringと修飾子によって指定された日時に、指定された時間を追加するだけです。修飾子名の最後の「s」文字はオプションです。 「&amp;plusmn;NNN月」は、元の日付をYYYY-MM-DD形式にレンダリングし、&amp;plusmn;NNNをMM月の値に追加して、結果を正規化することで機能することに注意してください。したがって、たとえば、「+ 1か月」で変更された2001-03-31のデータは最初は2001-04-31になりますが、4月は30日しかないため、日付は2001-05-01に正規化されます。元の日付がうるう年の2月29日で、修飾子が&amp;plusmn;N年である場合にも同様の効果が発生します。Nは4の倍数ではありません。</target>
        </trans-unit>
        <trans-unit id="de80fd15e7d30919dde63ea2e434aa9d73b98e29" translate="yes" xml:space="preserve">
          <source>The first step toward dealing with a hot journal is to obtain an exclusive lock on the database file. This prevents two or more processes from trying to rollback the same hot journal at the same time.</source>
          <target state="translated">ホットジャーナルを処理するための最初のステップは、データベースファイルの排他的なロックを取得することです。これにより、2つ以上のプロセスが同時に同じホットジャーナルをロールバックしようとすることを防ぎます。</target>
        </trans-unit>
        <trans-unit id="6d5dce142e8b6c56f2485efc4da630bd41e2b246" translate="yes" xml:space="preserve">
          <source>The first step toward reading from the database file is obtaining a shared lock on the database file. A &quot;shared&quot; lock allows two or more database connections to read from the database file at the same time. But a shared lock prevents another database connection from writing to the database file while we are reading it. This is necessary because if another database connection were writing to the database file at the same time we are reading from the database file, we might read some data before the change and other data after the change. This would make it appear as if the change made by the other process is not atomic.</source>
          <target state="translated">データベースファイルから読み取るための最初のステップは、データベースファイルの共有ロックを取得することです。共有」ロックは、2つ以上のデータベース接続が同時にデータベースファイルから読み出すことを可能にします。しかし、共有ロックは、私たちがデータベースファイルを読み込んでいる間、別のデータベース接続がデータベースファイルに書き込むことを防ぎます。これは、私たちがデータベースファイルから読み込んでいるときに別のデータベース接続がデータベースファイルに書き込んでいた場合、変更前のデータと変更後のデータを読み込んでしまう可能性があるためです。これは、他のプロセスによって行われた変更がアトミックではないかのように見えてしまうからです。</target>
        </trans-unit>
        <trans-unit id="728a2c812c40e366db04b46879d8327a7463b66e" translate="yes" xml:space="preserve">
          <source>The first string or bareword in a column declaration is the column name. It is an error to attempt to name an fts5 table column &quot;rowid&quot; or &quot;rank&quot;, or to assign the same name to a column as is used by the table itself. This is not supported.</source>
          <target state="translated">カラム宣言の最初の文字列またはベアワードはカラム名です。fts5 テーブルのカラムに &quot;rowid&quot; や &quot;rank&quot; という名前を付けようとしたり、テーブル自体が使用しているのと同じ名前をカラムに割り当てるのはエラーです。これはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="15aebb5889bf7eacd8a14d41dd89f37206fa7a06" translate="yes" xml:space="preserve">
          <source>The first subquery above is constant with respect to the outer query. The value for the first subquery can be computed once and then reused for each row of the outer SELECT. The second subquery, however, is &quot;CORRELATED&quot;. The value of the second subquery changes depending on values in the current row of the outer query. Hence, the second subquery must be run once for each output row in the outer SELECT.</source>
          <target state="translated">上記の最初の副問い合わせは、外側の問い合わせに対して一定です。最初の副問い合わせの値は、一度計算され、その後、外側のSELECTの各行に対して再利用することができます。しかし、2番目の副問い合わせは「correlated」です。2番目の副問い合わせの値は、外部クエリの現在の行の値に応じて変化します。したがって、第2の副問い合わせは、外側のSELECTの各出力行に対して1回実行されなければなりません。</target>
        </trans-unit>
        <trans-unit id="c31bdf542d6f05cfa5241d61c80e5148ec82df02" translate="yes" xml:space="preserve">
          <source>The first term stored on each node (&quot;Term 1&quot; in the figure above) is stored verbatim. Each subsequent term is prefix-compressed with respect to its predecessor. Terms are stored within a page in sorted (memcmp) order.</source>
          <target state="translated">各ノードに格納された最初のターム(上図の「ターム1」)は、逐語的に格納される。それ以降の各タームは、その前のタームに対して接頭辞圧縮されます。項は、ページ内でソートされた(memcmp)順序で格納されます。</target>
        </trans-unit>
        <trans-unit id="7a099bb22daac790c8e16aa7a285108628e1197d" translate="yes" xml:space="preserve">
          <source>The first thing that happens is that we open the table being indexed for reading. In order to construct an index for a table, we have to know what is in that table. The index has already been opened for writing using cursor 0 by instructions 3 and 4.</source>
          <target state="translated">最初に起こることは、インデックスが作成されているテーブルを開いて読み込むことです。テーブルのインデックスを構築するためには、そのテーブルに何があるかを知る必要があります。インデックスは、命令3と4によって、カーソル0を使用して書き込み用に既にオープンされています。</target>
        </trans-unit>
        <trans-unit id="5eb1752f78007fa49f66b7f76488ea011879482b" translate="yes" xml:space="preserve">
          <source>The first time that any SQLite process attempts to access the database file, it obtains a shared lock as described in &lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;section 3.2&lt;/a&gt; above. But then it notices that there is a rollback journal file present. SQLite then checks to see if the rollback journal is a &quot;hot journal&quot;. A hot journal is a rollback journal that needs to be played back in order to restore the database to a sane state. A hot journal only exists when an earlier process was in the middle of committing a transaction when it crashed or lost power.</source>
          <target state="translated">SQLiteプロセスが最初にデータベースファイルにアクセスしようとすると、&lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;セクション3.2で&lt;/a&gt;説明したように、共有ロックが取得されます。ただし、ロールバックジャーナルファイルが存在することがわかります。 SQLiteは、ロールバックジャーナルが「ホットジャーナル」であるかどうかを確認します。ホットジャーナルは、データベースを正常な状態に復元するために再生する必要のあるロールバックジャーナルです。ホットジャーナルが存在するのは、前のプロセスがトランザクションをクラッシュまたは停電したときにトランザクションをコミットしている最中だけです。</target>
        </trans-unit>
        <trans-unit id="e3a42cd86f3f8e7c9fddbcba13c3c1c638314931" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="translated">特定の集約関数に対してsqlite3_aggregate_context(C,N)ルーチンが初めて呼び出されたとき、SQLiteはN個のメモリを確保し、そのメモリをゼロアウトし、新しいメモリへのポインタを返します。同じ集約関数インスタンスに対してsqlite3_aggregate_context()を2回目以降に呼び出すと、同じバッファが返されます。Sqlite3_aggregate_context()は通常、xStepコールバックが呼び出されるたびに一度だけ呼び出され、その後xFinalコールバックが呼び出されたときに最後に一度だけ呼び出されます。集約クエリにマッチする行がない場合、集約関数実装のxStep()コールバックは呼び出されず、xFinal()は一度だけ呼び出されます。このような場合、xFinal()の中から初めてsqlite3_aggregate_context()が呼び出されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="33a73e33477151458e48dab8a4d76f2a383719c8" translate="yes" xml:space="preserve">
          <source>The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) cause sqlite3_mutex_alloc() to create a new mutex. The new mutex is recursive when SQLITE_MUTEX_RECURSIVE is used but not necessarily so when SQLITE_MUTEX_FAST is used. The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does not want to. SQLite will only request a recursive mutex in cases where it really needs one. If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST.</source>
          <target state="translated">最初の2つの定数(SQLITE_MUTEX_FASTとSQLITE_MUTEX_RECURSIVE)はsqlite3_mutex_alloc()に新しいミューテックスを生成させます。SQLITE_MUTEX_RECURSIVEが使用されている場合は新しいミューテックスは再帰的ですが、SQLITE_MUTEX_FASTが使用されている場合は必ずしもそうではありません。もし必要なければ、ミューテックスの実装はSQLITE_MUTEX_RECURSIVEとSQLITE_MUTEX_FASTを区別する必要はありません。SQLiteは本当に再帰的なミューテックスが必要な場合にのみ要求します。ホストプラットフォーム上でより高速な非再帰的ミューテックスの実装が利用可能な場合、ミューテックスサブシステムはSQLITE_MUTEX_FASTに応答してそのようなミューテックスを返すかもしれません。</target>
        </trans-unit>
        <trans-unit id="3ad84c4124333660ac2ec2d4b3b96a74793fd127" translate="yes" xml:space="preserve">
          <source>The first two elements in the list above, the associated</source>
          <target state="translated">前記リストの最初の2つの要素、関連する</target>
        </trans-unit>
        <trans-unit id="9de36623b06dcc8a12dabc9fe8d69bf46f2afdab" translate="yes" xml:space="preserve">
          <source>The first two instructions in the VDBE program for our query are concerned with setting up values for &lt;b&gt;azColumn&lt;/b&gt;. The &lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnName&lt;/a&gt; instructions tell the VDBE what values to fill in for each element of the &lt;b&gt;azColumnName[]&lt;/b&gt; array. Every query will begin with one ColumnName instruction for each column in the result, and there will be a matching Column instruction for each one later in the query.</source>
          <target state="translated">私たちのクエリのVDBEプログラムの最初の2つの命令は、の値を設定すると懸念している&lt;b&gt;azColumn&lt;/b&gt;。&lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnNameにする&lt;/a&gt;命令は、各要素のために埋めるためにどのような値VDBEを伝える&lt;b&gt;azColumnName []&lt;/b&gt;配列。すべてのクエリは、結果の列ごとに1つのColumnName命令で始まり、クエリの後半では、それぞれに対応するColumn命令があります。</target>
        </trans-unit>
        <trans-unit id="80f7eaccbd1b0c6d2fde7b56494766bcf2304eb6" translate="yes" xml:space="preserve">
          <source>The first two query examples illustrate a kind of template that every SELECT program will follow. Basically, we have:</source>
          <target state="translated">最初の2つのクエリの例は、すべてのSELECTプログラムが従うテンプレートの一種であることを示しています。基本的には</target>
        </trans-unit>
        <trans-unit id="c636087069b26e9346b965d8bb5b5d8294795344" translate="yes" xml:space="preserve">
          <source>The first value in the array of integer values corresponds to the leftmost column of the table (column 0) and the first phrase in the query (phrase 0). The values corresponding to other column/phrase combinations may be located using the following formula:</source>
          <target state="translated">整数値の配列の最初の値は、テーブルの左端の列(列0)とクエリの最初のフレーズ(フレーズ0)に対応します。他の列/フレーズの組み合わせに対応する値は、次の式を用いて配置することができる。</target>
        </trans-unit>
        <trans-unit id="61029d8449643ad48e743f1026fb94f8a1ed1222" translate="yes" xml:space="preserve">
          <source>The first, or only, integer is the blockid that corresponds to the interior node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always an interior node.</source>
          <target state="translated">最初の、または唯一の整数は、このセグメント b-木に属する最大のブロック ID を持つ内部ノードに対応するブロック ID です。または、セグメント b-tree 全体がルートノードに収まる場合は 0 です。存在する場合、このノードは常に内部ノードです。</target>
        </trans-unit>
        <trans-unit id="c0ebe13b31f8942f70d44d11a35f84a9529666cd" translate="yes" xml:space="preserve">
          <source>The fix in the 3.25.0 release for the endless-loop in the byte-code associated with the ORDER BY LIMIT optimization did not work for some queries involving window functions. An additional correction is required. Ticket &lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</source>
          <target state="translated">3.25.0リリースでの、ORDER BY LIMIT最適化に関連するバイトコードのエンドレスループの修正は、ウィンドウ関数を含む一部のクエリでは機能しませんでした。追加の修正が必要です。チケット&lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2032be06ad1313d23c4aa0f2d29e1f73447dfd8" translate="yes" xml:space="preserve">
          <source>The fix to the previous bug uncovered a deadlock which was also fixed.</source>
          <target state="translated">以前のバグの修正でデッドロックが発覚したが、それも修正された。</target>
        </trans-unit>
        <trans-unit id="8197368f601d93edb14a348de0bf212d3c1bcf51" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">xAccessにフラグ引数は（）であってもよい&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;ファイルの存在のためのテスト、またはそれに&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt;ファイルを読み書き可能であるかどうかを試験するために、または&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;ファイルは、少なくとも読み取り可能であるかどうかをテストします。 SQLITE_ACCESS_READフラグは実際には使用されず、SQLiteの組み込みVFSには実装されていません。ファイルは2番目の引数によって名前が付けられ、ディレクトリにすることができます。 xAccessメソッドは、I / Oエラーが発生した場合、または2番目の引数で指定されたファイルの名前が不正である場合、成功すると&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;を返すか、ゼロ以外のエラーコードを返します。 SQLITE_OKが返された場合、* pResOutにゼロ以外の値またはゼロが書き込まれ、ファイルにアクセスできるかどうかが示されます。</target>
        </trans-unit>
        <trans-unit id="ee0102cf2398a56ff989592f19a055847f5dc920" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">xAccessにフラグ引数は（）であってもよい&lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;ファイルの存在のためのテスト、またはそれに&lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt;ファイルを読み書き可能であるかどうかを試験するために、または&lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;ファイルは、少なくとも読み取り可能であるかどうかをテストします。 SQLITE_ACCESS_READフラグは実際には使用されず、SQLiteの組み込みVFSには実装されていません。ファイルは2番目の引数によって名前が付けられ、ディレクトリにすることができます。 xAccessメソッドは、I / Oエラーが発生した場合、または2番目の引数で指定されたファイルの名前が不正である場合、成功すると&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返すか、ゼロ以外のエラーコードを返します。 SQLITE_OKが返された場合、* pResOutにゼロ以外の値またはゼロが書き込まれ、ファイルにアクセスできるかどうかが示されます。</target>
        </trans-unit>
        <trans-unit id="d9f0c284ad1c57f7e5da616991af768f686e341f" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">XOPENにflags引数（）へのflags引数に設定されたすべてのビットを含む&lt;a href=&quot;#sqlite3_open&quot;&gt;）（sqlite3_open_v2&lt;/a&gt;。または、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;が使用されている場合、フラグには少なくとも&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; |が含まれます。&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。 xOpen（）がファイルを読み取り専用で開くと、SQLITE_OPEN_READONLYを含めるように* pOutFlagsが設定され&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;ます&lt;/a&gt;。 * pOutFlagsの他のビットが設定される場合があります。</target>
        </trans-unit>
        <trans-unit id="f5198d48ad55972f3bafe448a5f83115c01462b7" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">XOPENにflags引数（）へのflags引数に設定されたすべてのビットを含む&lt;a href=&quot;open&quot;&gt;）（sqlite3_open_v2&lt;/a&gt;。または、&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;または&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;が使用されている場合、フラグには少なくとも&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; |が含まれます。&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。 xOpen（）がファイルを読み取り専用で開くと、SQLITE_OPEN_READONLYを含めるように* pOutFlagsが設定され&lt;a href=&quot;c_open_autoproxy&quot;&gt;ます&lt;/a&gt;。 * pOutFlagsの他のビットが設定される場合があります。</target>
        </trans-unit>
        <trans-unit id="7bc004618637404d4a4bd35b24cc91bd411a3086" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">xSyncのflags引数は、&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;または&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;のいずれかです。最初の選択は通常のfsync（）です。2番目の選択肢は、Mac OS Xスタイルの完全同期です。&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLYの&lt;/a&gt;フラグは、ファイルのデータではなく、そのiノードのニーズが同期されることを示すために論理和（OR）することができます。</target>
        </trans-unit>
        <trans-unit id="99d3aea2b8c0b18767851d7c8d3921e4603f6ed1" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">xSyncのflags引数は、&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;または&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;のいずれかです。最初の選択は通常のfsync（）です。2番目の選択肢は、Mac OS Xスタイルの完全同期です。&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLYの&lt;/a&gt;フラグは、ファイルのデータではなく、そのiノードのニーズが同期されることを示すために論理和（OR）することができます。</target>
        </trans-unit>
        <trans-unit id="c377d5a3884469a39150e12bd3af49c973f2fad1" translate="yes" xml:space="preserve">
          <source>The floating-point to text conversion subfunction for the built-in printf() is limited in precision to 16 significant digits or 26 significant digits if the &quot;!&quot; alternate-form-2 flag is used. Every IEEE-754 double can be represented exactly as a decimal floating-point value, but some doubles require more than 16 or 26 significant digits.</source>
          <target state="translated">組み込みのprintf()の浮動小数点からテキストへの変換サブ関数の精度は、&quot;!&quot; alternate-form-2フラグが使用されている場合、16桁の有効数字、または26桁の有効数字に制限されています。IEEE-754のすべてのダブルは10進浮動小数点値として正確に表現することができますが、一部のダブルは16桁または26桁以上の有効数字を必要とします。</target>
        </trans-unit>
        <trans-unit id="68fce5c170ab1896511f13fd3e82f411098f2695" translate="yes" xml:space="preserve">
          <source>The folder returned by the GetTempPath() system interface.</source>
          <target state="translated">GetTempPath()システムインターフェイスが返すフォルダ。</target>
        </trans-unit>
        <trans-unit id="4f48bdf9b1dfd94aea260fd19b610d7cf9d72be5" translate="yes" xml:space="preserve">
          <source>The folder set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;または&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;グローバル変数によって設定されたフォルダー</target>
        </trans-unit>
        <trans-unit id="8f393fa7f5f393cd220ff4a7a6a7ccbac66e5676" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt; cartoon is an exaggeration, yet hits close to home:</source>
          <target state="translated">次の&lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt;漫画は誇張ですが、家の近くにヒットします。</target>
        </trans-unit>
        <trans-unit id="40de557d79eeab5be4528c0beef95dcb1a5f7ef4" translate="yes" xml:space="preserve">
          <source>The following RBU database schema may be used:</source>
          <target state="translated">以下のRBUデータベーススキーマを使用することができる。</target>
        </trans-unit>
        <trans-unit id="ae49ebf9365c52bbf37afc8c396e0cba8b2d31d3" translate="yes" xml:space="preserve">
          <source>The following SQL demonstrates how SQLite uses column affinity to do type conversions when values are inserted into a table.</source>
          <target state="translated">次の SQL は、SQLite がカラムアフィニティを使用して、テーブルに値が挿入されたときに型変換を行う方法を示しています。</target>
        </trans-unit>
        <trans-unit id="b7479fafb0c600f993e6250d871980ae79cbdf35" translate="yes" xml:space="preserve">
          <source>The following SQLite command-line session illustrates the effect of the foreign key constraint added to the</source>
          <target state="translated">次の SQLite コマンドラインセッションは、外部キー制約が</target>
        </trans-unit>
        <trans-unit id="1f8a8aec572c42d81f9a9d30dc36ba0c1a7ca331" translate="yes" xml:space="preserve">
          <source>The following additional compile-time options are recommended in order to provide a full-featured command-line shell:</source>
          <target state="translated">フル機能のコマンドラインシェルを提供するために、以下の追加のコンパイル時オプションを推奨します。</target>
        </trans-unit>
        <trans-unit id="e661fc6daecc53fc88e2038803ed3bcb13092e93" translate="yes" xml:space="preserve">
          <source>The following additional syntax restrictions apply to UPDATE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement.</source>
          <target state="translated">以下の追加の構文制限は、&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;ステートメントの本体内で発生するUPDATEステートメントに適用されます。</target>
        </trans-unit>
        <trans-unit id="0a78308c3e0962720a3b6c6b2c92b551ac030e31" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">以下は、&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（D、S、P、N、M、F）&lt;/a&gt;インターフェイスの6番目の引数（F引数）に許可される値です。</target>
        </trans-unit>
        <trans-unit id="b9076a86669fb7bce220c5cc2398686ebb071016" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">以下は、&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（D、S、P、N、M、F）&lt;/a&gt;インターフェイスの6番目の引数（F引数）に許可される値です。</target>
        </trans-unit>
        <trans-unit id="a59459d6632d0bbc1149f827b602fb3d835358c8" translate="yes" xml:space="preserve">
          <source>The following are examples of disabling the built-in protection mechanisms of SQLite:</source>
          <target state="translated">以下は、SQLite の組み込みの保護機構を無効にする例です。</target>
        </trans-unit>
        <trans-unit id="80d00e742a47603d638009e13703b23c42a0d91f" translate="yes" xml:space="preserve">
          <source>The following are other VFS implementations available in the public SQLite source tree:</source>
          <target state="translated">公開されているSQLiteのソースツリーで利用可能な他のVFS実装は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ec123026fdd8e1c2278a5f9715d6939ab0dbeb46" translate="yes" xml:space="preserve">
          <source>The following are the available OMIT options:</source>
          <target state="translated">OMITオプションは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8fa3cecc90ff41687bc039d2f339ed203679e422" translate="yes" xml:space="preserve">
          <source>The following block contains a summary of the FTS query syntax in BNF form. A detailed explanation follows.</source>
          <target state="translated">以下のブロックには、BNF 形式の FTS クエリ構文の概要が含まれています。詳細な説明は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9eacb2386777a09c397574d603b9f7b4a178b7c8" translate="yes" xml:space="preserve">
          <source>The following block contains an example of calling the fts3_tokenizer() function from C code:</source>
          <target state="translated">以下のブロックには、Cコードからfts3_tokenizer()関数を呼び出す例が含まれています。</target>
        </trans-unit>
        <trans-unit id="8a513f3e74d7cb1dc9f72503b5eb2053d246b6ad" translate="yes" xml:space="preserve">
          <source>The following block contains examples that use the offsets function.</source>
          <target state="translated">以下のブロックには、オフセット関数を使用する例が含まれています。</target>
        </trans-unit>
        <trans-unit id="5c334635414a3c37311f7280f25331d2da05c0d0" translate="yes" xml:space="preserve">
          <source>The following chart shows the substitution types supported by SQLite:</source>
          <target state="translated">次の表は、SQLite でサポートされている置換タイプを示しています。</target>
        </trans-unit>
        <trans-unit id="c06c8d896e801657db8f70d5a5bd2960e6843e64" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that doe not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="translated">SQLiteが使用するCPUサイクル数とメモリのバイト数を最小限に抑えるために、それらを使用できるアプリケーションには、次のコンパイル時オプションをお勧めします。これらのコンパイル時オプションのすべてがすべてのアプリケーションで使用できるわけではありません。たとえば、SQLITE_THREADSAFE = 0オプションは、一度に複数のスレッドからSQLiteにアクセスすることのないアプリケーションでのみ使用できます。また、SQLITE_OMIT_PROGRESS_CALLBACKオプションは、&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt;インターフェースを使用しないアプリケーションでのみ使用できます。などなど。</target>
        </trans-unit>
        <trans-unit id="1f053eef3c13d51d862b4f23cc04af6f84e75626" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">次の定数は、&lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（S、X、T、V）&lt;/a&gt;インターフェイスのTパラメータに使用できます。各定数は、sqlite3_stmt_scanstatus（）が返す異なるメトリックを指定します。</target>
        </trans-unit>
        <trans-unit id="42e5a30e943fe484b45c04468e002affa80c1a88" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">次の定数は、&lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（S、X、T、V）&lt;/a&gt;インターフェイスのTパラメータに使用できます。各定数は、sqlite3_stmt_scanstatus（）が返す異なるメトリックを指定します。</target>
        </trans-unit>
        <trans-unit id="0dd0f222abc9f123e613d4dc8f011601915507ab" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree interior (non-leaf) node.</source>
          <target state="translated">次の図は、セグメント b-tree 内側(非リーフ)ノードの形式を示しています。</target>
        </trans-unit>
        <trans-unit id="24519f5efb1b482cdcbf663c45ec684bda267ab2" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree leaf node.</source>
          <target state="translated">次の図は、セグメント b-tree リーフ・ノードの形式を示しています。</target>
        </trans-unit>
        <trans-unit id="d2d809dec5a64a655b9636ca71424601eda3c8d0" translate="yes" xml:space="preserve">
          <source>The following example code illustrates the techniques described above.</source>
          <target state="translated">以下の例示的なコードは、上述した技術を説明するものである。</target>
        </trans-unit>
        <trans-unit id="54bdf2a30ded538a716ed8a4baee084a78f8a312" translate="yes" xml:space="preserve">
          <source>The following example creates a new SQL function named &quot;hex&quot; that converts its numeric argument in to a hexadecimal encoded string:</source>
          <target state="translated">次の例では、数値引数を16進数でエンコードされた文字列に変換する、&quot;hex &quot;という名前の新しいSQL関数を作成しています。</target>
        </trans-unit>
        <trans-unit id="9d4eb7545f22068db9db1145bb2583cae1439f33" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the effect of the various forms of the EXCLUDE clause:</source>
          <target state="translated">次の例は、EXCLUDE 節のさまざまな形式の効果を示しています。</target>
        </trans-unit>
        <trans-unit id="3fb64142e08ab04e58bc3d16cc93b9564bb653f2" translate="yes" xml:space="preserve">
          <source>The following example illustrates precedence of operators using the standard query syntax:</source>
          <target state="translated">次の例は、標準のクエリ構文を使用した演算子の優先順位を示しています。</target>
        </trans-unit>
        <trans-unit id="33e08656a40dfd68bcb2d6194c63e1be80dcd4d4" translate="yes" xml:space="preserve">
          <source>The following example illustrates the above. The expressions &quot;docs&quot;, &quot;docs.docs&quot; and &quot;main.docs.docs&quot; all refer to column &quot;docs&quot;. However, the expression &quot;main.docs&quot; does not refer to any column. It could be used to refer to a table, but a table name is not allowed in the context in which it is used below.</source>
          <target state="translated">以下の例では、上記のことを説明しています。表現「docs」、「docs.docs」、「main.docs.docs」は、いずれもカラム「docs」を参照している。しかし、「main.docs」という表現は、どのカラムも参照していません。テーブルを参照するために使用することはできますが、以下のような文脈ではテーブル名を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="6318f87943b573664a21e50213cf281e74663a27" translate="yes" xml:space="preserve">
          <source>The following example illustrates the behaviour of the five ranking functions - row_number(), rank(), dense_rank(), percent_rank() and cume_dist().</source>
          <target state="translated">以下の例は、5つのランキング関数、row_number()、rank()、dense_rank()、percent_rank()、cume_dist()の挙動を示しています。</target>
        </trans-unit>
        <trans-unit id="fd2f5de221e0f758d71eb8931f8c7e719ace6200" translate="yes" xml:space="preserve">
          <source>The following example illustrates the effect of using a deferred foreign key constraint.</source>
          <target state="translated">以下の例は、遅延された外部キー制約を使用した場合の効果を示しています。</target>
        </trans-unit>
        <trans-unit id="21740a6dff76788fbc521cbbbedbec453f6795d5" translate="yes" xml:space="preserve">
          <source>The following example uses the sumint() function implemented by the above C code. For each row, the window consists of the preceding row (if any), the current row and the following row (again, if any):</source>
          <target state="translated">以下の例では、上記の C コードで実装された sumint()関数を使用しています。各行について、ウィンドウは前の行(もしあれば)、現在の行、そして次の行(もしあればまた)から構成されています。</target>
        </trans-unit>
        <trans-unit id="9b577d330901567bab085337ea84d2a43135e876" translate="yes" xml:space="preserve">
          <source>The following example will better illustrate the use of SQLITE_CONSTRAINT as a return value from xBestIndex:</source>
          <target state="translated">次の例は、xBestIndex の戻り値として SQLITE_CONSTRAINT を使用することをよりよく説明しています。</target>
        </trans-unit>
        <trans-unit id="3f5880fbaaf652f0861c35b2ed9bf834e8800e30" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">次のフラグは、4番目のパラメータを介して&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt;と&lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;に渡すことができます：</target>
        </trans-unit>
        <trans-unit id="dcb818ec6ae695589b5e698d66cbb55415f5689e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">次のフラグは、4番目のパラメータを介して&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt;と&lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;に渡すことができます：</target>
        </trans-unit>
        <trans-unit id="eaf06e6487557d77e67f76618b64eb4b39aae85e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">次のフラグは、9番目のパラメータを介して&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt;と&lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8acfd72cc7dc7df0be4ef94764fa15b5b7e0e403" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">次のフラグは、9番目のパラメータを介して&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt;と&lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="f88559c5309089b2c53eff7ab551567dc8265aad" translate="yes" xml:space="preserve">
          <source>The following functions can be used to advance and query a changeset iterator created by this function:</source>
          <target state="translated">以下の関数を使用して、この関数によって作成されたチェンジセットイテレータを進めたり、問い合わせたりすることができます。</target>
        </trans-unit>
        <trans-unit id="35f53ac017499b71e5f28f348a1b347ee5939139" translate="yes" xml:space="preserve">
          <source>The following is a log of all SQL used to generate one particular timeline (captured on 2016-09-16):</source>
          <target state="translated">以下は、ある特定のタイムラインを生成するために使用されたすべてのSQLのログです(2016-09-16にキャプチャされています)。</target>
        </trans-unit>
        <trans-unit id="8ca654574638bb42c5b323e2fbbcf528a1c97560" translate="yes" xml:space="preserve">
          <source>The following is a partial list of the kinds of messages that might appear in the error logger callback.</source>
          <target state="translated">以下に、エラー・ロガー・コールバックで表示されるメッセージの種類の一部を示します。</target>
        </trans-unit>
        <trans-unit id="91f9f5074c39cae7458cb274b5e2472dd1f18791" translate="yes" xml:space="preserve">
          <source>The following is a random assortment of techniques used by the SQLite developers to trace, examine, and understand the behavior of the core SQLite library.</source>
          <target state="translated">以下は、SQLite 開発者がコア SQLite ライブラリの動作をトレース、調査、理解するために使用したテクニックのランダムな詰め合わせです。</target>
        </trans-unit>
        <trans-unit id="172b7cc8402676bd9591f1901c350fe56e3b1a3a" translate="yes" xml:space="preserve">
          <source>The following is sqlite3_analyzer output for an example places.sqlite database used by Firefox.</source>
          <target state="translated">以下は、Firefoxで使用されている例のplace.sqliteデータベースのsqlite3_analyzerの出力です。</target>
        </trans-unit>
        <trans-unit id="3b9bb38ec5e22c57b0f7c289494707329a29a947" translate="yes" xml:space="preserve">
          <source>The following limitations apply to RBU updates:</source>
          <target state="translated">RBUのアップデートには、以下の制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="fc2fda4c09167d54864b95b318f076cb56ce31c3" translate="yes" xml:space="preserve">
          <source>The following macros specify interface linkage for certain kinds of SQLite builds. The Makefiles will normally handle setting these macros automatically. Application developers should not need to worry with these macros. The following documentation about these macros is included completeness.</source>
          <target state="translated">以下のマクロは、特定の種類の SQLite ビルドのためのインターフェイス連携を指定します。通常、Makefile はこれらのマクロを自動的に設定します。アプリケーション開発者はこれらのマクロを気にする必要はありません。これらのマクロに関する以下のドキュメントが含まれています。</target>
        </trans-unit>
        <trans-unit id="e520cf121083171350ce54bdc25d9fb94f2ae9df" translate="yes" xml:space="preserve">
          <source>The following must be true for this function to succeed. If any of the following statements are false when sqlite3_snapshot_get() is called, SQLITE_ERROR is returned. The final value of *P is undefined in this case.</source>
          <target state="translated">この関数が成功するためには、以下の記述が真でなければなりません。sqlite3_snapshot_get()が呼び出されたときに以下の文のいずれかがfalseの場合、SQLITE_ERRORが返されます。この場合、*Pの最終値は未定義です。</target>
        </trans-unit>
        <trans-unit id="13b4c313c53ce999997969a2a1da623479829206" translate="yes" xml:space="preserve">
          <source>The following options can be used to &lt;a href=&quot;footprint&quot;&gt;reduce the size of the compiled library&lt;/a&gt; by omitting unused features. This is probably only useful in embedded systems where space is especially tight, as even with all features included the SQLite library is relatively small. Don't forget to tell your compiler to optimize for binary size! (the -Os option if using GCC). Telling your compiler to optimize for size usually has a much larger impact on library footprint than employing any of these compile-time options. You should also verify that &lt;a href=&quot;#debugoptions&quot;&gt;debugging options&lt;/a&gt; are disabled.</source>
          <target state="translated">次のオプションを使用する&lt;a href=&quot;footprint&quot;&gt;と、&lt;/a&gt;未使用の機能を省略して、コンパイル済みライブラリのサイズを削減できます。SQLiteライブラリが含まれているすべての機能が比較的小さいため、これはおそらくスペースが特に狭い組み込みシステムでのみ役立ちます。バイナリサイズを最適化するようコンパイラーに指示することを忘れないでください！（GCCを使用する場合の-Osオプション）。通常、サイズを最適化するようコンパイラーに指示すると、これらのコンパイル時オプションを使用するよりも、ライブラリーのフットプリントにはるかに大きな影響があります。また、&lt;a href=&quot;#debugoptions&quot;&gt;デバッグオプション&lt;/a&gt;が無効になっていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="aa7c844b688230c89a2857560379c0f551e0b077" translate="yes" xml:space="preserve">
          <source>The following query computes an approximation of the Mandelbrot Set and outputs the result as ASCII-art:</source>
          <target state="translated">以下のクエリは、マンデルブロ集合の近似を計算し、結果をASCII-artとして出力します。</target>
        </trans-unit>
        <trans-unit id="165c7c17f77322908874e60dfb0fb76218a06202" translate="yes" xml:space="preserve">
          <source>The following query parameters are recognized by SQLite as of &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14). New query parameters might be added in the future.</source>
          <target state="translated">次のクエリパラメータは、&lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;バージョン3.15.0&lt;/a&gt;（2016-10-14）以降、SQLiteによって認識されます。将来、新しいクエリパラメータが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="482aaeeca1acb6ff828caa9e341d537cef50e256" translate="yes" xml:space="preserve">
          <source>The following query returns all integers between 1 and 1000000:</source>
          <target state="translated">以下のクエリは、1から1000000までのすべての整数を返します。</target>
        </trans-unit>
        <trans-unit id="df61dccd4718a46758145386ef91e3af7a125626" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 1 of the above procedure in more detail.</source>
          <target state="translated">以下の要件では、上記手順のステップ1をより詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="c7e0a9c1d2e39a35866f813a7b58e616f8a0dfa1" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 2 of the above procedure in more detail.</source>
          <target state="translated">以下の要件では、上記手順のステップ2をより詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="ab60a1fc45053970e49cb2236072b7574ce682f2" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 3 of the above procedure in more detail.</source>
          <target state="translated">以下の要件では、上記手順のステップ3をより詳細に説明する。</target>
        </trans-unit>
        <trans-unit id="0f5ce0f453d6b71b276dab07b31a916fac2ad143" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 4 of the above procedure in more detail.</source>
          <target state="translated">以下の要件では、上記手順のステップ4をより詳細に説明する。</target>
        </trans-unit>
        <trans-unit id="ff1604c4fd7473773943aa62c8883c18d8179ef1" translate="yes" xml:space="preserve">
          <source>The following requirements describe the steps enumerated above in more detail.</source>
          <target state="translated">以下の要件では、上記で列挙したステップをより詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="ca6589a3a75bae1a771049671e8297b9c43f424f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to DELETE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement:</source>
          <target state="translated">&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;ステートメントの本体内で発生するDELETEステートメントには、次の制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="1404887613e3d3d478c15bfa20064138fe1f758d" translate="yes" xml:space="preserve">
          <source>The following routines are used to implement user-defined collating sequences:</source>
          <target state="translated">以下のルーチンを使用して、ユーザー定義の照合シーケンスを実装します。</target>
        </trans-unit>
        <trans-unit id="9d61d2cb84c2da7119bdaa99ad1c2d7a32c4afe9" translate="yes" xml:space="preserve">
          <source>The following rules and caveats apply to the values specified as part of each INSERT statement:</source>
          <target state="translated">各INSERT文の一部として指定された値には、以下のルールと注意事項が適用されます。</target>
        </trans-unit>
        <trans-unit id="a26a29856749163d9eb4f80a667633bb87f813e9" translate="yes" xml:space="preserve">
          <source>The following rules show how each of the locks is used.</source>
          <target state="translated">以下のルールでは、それぞれのロックがどのように使用されているかを示しています。</target>
        </trans-unit>
        <trans-unit id="737ea9fa3e70c97a0a7b4c9228ebcdc9127f52cb" translate="yes" xml:space="preserve">
          <source>The following scenario illustrates how an SQLITE_BUSY_SNAPSHOT error might arise:</source>
          <target state="translated">次のシナリオは、SQLITE_BUSY_SNAPSHOT エラーがどのように発生するかを示しています。</target>
        </trans-unit>
        <trans-unit id="4840312a4c02316c9bb1b228254597da9db65628" translate="yes" xml:space="preserve">
          <source>The following script was used to gather information for the table above.</source>
          <target state="translated">上記の表の情報収集には、以下のスクリプトを使用しました。</target>
        </trans-unit>
        <trans-unit id="5f95a6062676138baa336da2cd5b1ec87382d19c" translate="yes" xml:space="preserve">
          <source>The following section describes the API offered to auxiliary function implementations in detail. Further examples may be found in the &quot;fts5_aux.c&quot; file of the source code.</source>
          <target state="translated">以下のセクションでは、補助関数の実装に提供されるAPIについて詳しく説明します。さらなる例は、ソースコードの &quot;fts5_aux.c &quot;ファイルにあります。</target>
        </trans-unit>
        <trans-unit id="c91d01efc0ba3649e7eacbf59f700342ec3a53a5" translate="yes" xml:space="preserve">
          <source>The following sections describe some low-level details of the R*Tree implementation, that might be useful for trouble-shooting or performance analysis.</source>
          <target state="translated">以下のセクションでは、トラブルシューティングやパフォーマンス解析に役立つかもしれないR*Treeの実装の低レベルの詳細について説明します。</target>
        </trans-unit>
        <trans-unit id="17e43452198f5289d975fb07abeb874782ed48a0" translate="yes" xml:space="preserve">
          <source>The following sections describe the supported parameters. Specifying an unrecognized parameter name is an error.</source>
          <target state="translated">以下のセクションでは、サポートされているパラメータについて説明します。認識できないパラメータ名を指定するとエラーとなります。</target>
        </trans-unit>
        <trans-unit id="009cc36fd7239429da331a5197a208b717cdb22a" translate="yes" xml:space="preserve">
          <source>The following sections provide additional detail on the operation of the various functions that are part of the json1 extension.</source>
          <target state="translated">以下のセクションでは、json1 拡張機能の一部である様々な関数の操作についての詳細を説明します。</target>
        </trans-unit>
        <trans-unit id="0b996a91eae66dcc3a2860511963eb7fa7efc7eb" translate="yes" xml:space="preserve">
          <source>The following syntax documentation topics are available:</source>
          <target state="translated">以下の構文ドキュメントのトピックがあります。</target>
        </trans-unit>
        <trans-unit id="0e5fa08cf1724f31556de517effc85351bb377ec" translate="yes" xml:space="preserve">
          <source>The following table shows how many common datatype names from more traditional SQL implementations are converted into affinities by the five rules of the previous section. This table shows only a small subset of the datatype names that SQLite will accept. Note that numeric arguments in parentheses that following the type name (ex: &quot;VARCHAR(255)&quot;) are ignored by SQLite - SQLite does not impose any length restrictions (other than the large global &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit) on the length of strings, BLOBs or numeric values.</source>
          <target state="translated">次の表は、前のセクションの5つのルールによって、従来のSQL実装からの一般的なデータ型名がいくつアフィニティに変換されるかを示しています。この表は、SQLiteが受け入れるデータ型名の小さなサブセットのみを示しています。型名に続く括弧内の数値引数（例： &quot;VARCHAR（255）&quot;）はSQLiteによって無視されることに注意してください&lt;a href=&quot;limits#max_length&quot;&gt;-SQLite&lt;/a&gt;は、文字列、BLOB、または長さに長さ制限（大きなグローバルSQLITE_MAX_LENGTH制限以外）を課しません。数値。</target>
        </trans-unit>
        <trans-unit id="54feeefe0d9e52f7880c035de3af5b0398710d6a" translate="yes" xml:space="preserve">
          <source>The following table shows the results of the NULL handling experiments.</source>
          <target state="translated">以下の表は、NULLハンドリングの実験結果を示しています。</target>
        </trans-unit>
        <trans-unit id="12e0a00ef75b703780c84d1074e0287b2f403501" translate="yes" xml:space="preserve">
          <source>The following table summarizes the SQLite file format changes that have occurred since version 1.0.0:</source>
          <target state="translated">以下の表は、バージョン 1.0.0 以降に発生した SQLite ファイル形式の変更点をまとめたものです。</target>
        </trans-unit>
        <trans-unit id="ea82e2bbe8fed4a7a8a0361c062cdbf2a7cb2e1f" translate="yes" xml:space="preserve">
          <source>The following two objects and eight methods comprise the essential elements of the SQLite interface:</source>
          <target state="translated">以下の 2 つのオブジェクトと 8 つのメソッドは、SQLite インターフェイスの重要な要素を構成しています。</target>
        </trans-unit>
        <trans-unit id="1b3057a8ce2692f0addf4973e487586ba5e334ab" translate="yes" xml:space="preserve">
          <source>The foregoing is all one really needs to know in order to use SQLite effectively. All the rest is optimization and detail.</source>
          <target state="translated">上記は、SQLiteを効果的に使用するために本当に必要な知識のすべてです。あとは最適化と詳細な情報だけです。</target>
        </trans-unit>
        <trans-unit id="75a22928178fbb3c0cbb048a8ad2cc0d5b3170b7" translate="yes" xml:space="preserve">
          <source>The foregoing text describes low-level aspects of the SQLite file format. The b-tree mechanism provides a powerful and efficient means of accessing a large data set. This section will describe how the low-level b-tree layer is used to implement higher-level SQL capabilities.</source>
          <target state="translated">前述のテキストでは、SQLite ファイル形式の低レベルな側面について説明しています。b-treeメカニズムは、大規模なデータセットにアクセスするための強力で効率的な手段を提供します。このセクションでは、低レベルのb-tree層がどのようにして高レベルのSQL機能を実装するために使用されるかを説明します。</target>
        </trans-unit>
        <trans-unit id="12199f4a726aab3fb6304db80ece6cf69a955319" translate="yes" xml:space="preserve">
          <source>The foreign key constraint is satisfied if for each row in the child table either one or more of the child key columns are NULL, or there exists a row in the parent table for which each parent key column contains a value equal to the value in its associated child key column.</source>
          <target state="translated">外部キー制約は、子テーブルの各行について、1つ以上の子キー列のいずれかがNULLであるか、または親テーブルの各親キー列が、関連する子キー列の値と等しい値を含む行が存在する場合に満たされます。</target>
        </trans-unit>
        <trans-unit id="7eb5b173b9130668a2a0b17e4f207640eaa017f0" translate="yes" xml:space="preserve">
          <source>The foreign key constraints created as part of tables</source>
          <target state="translated">テーブルの一部として作成された外部キー制約</target>
        </trans-unit>
        <trans-unit id="add6cc21a0d1ec9f3c982acde6cc5dc3f05465f0" translate="yes" xml:space="preserve">
          <source>The foreign_key_check pragma checks the database, or the table called &quot;</source>
          <target state="translated">foreign_key_checkプラグマはデータベース、または&quot;</target>
        </trans-unit>
        <trans-unit id="9efc16f15cca4547a2a6b1e6f0aea092764cfc35" translate="yes" xml:space="preserve">
          <source>The formalized assumptions in this section refer to</source>
          <target state="translated">このセクションでの形式化された前提条件は、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="fe9496c466bbe179ee18ac47ed69a346233c9cbd" translate="yes" xml:space="preserve">
          <source>The format for sqlite_stat2 is recorded here for legacy reference. Recent versions of SQLite no longer support sqlite_stat2 and the sqlite_stat2 table, if is exists, is simply ignored.</source>
          <target state="translated">sqlite_stat2のフォーマットは、レガシー参照のためにここに記録されています。最近のバージョンのSQLiteはもはやsqlite_stat2をサポートしておらず、もしsqlite_stat2テーブルが存在する場合は単純に無視されます。</target>
        </trans-unit>
        <trans-unit id="d2a469c667d3464f2b4b57e3f59fb88c3da53ff2" translate="yes" xml:space="preserve">
          <source>The format of a cell depends on which kind of b-tree page the cell appears on. The following table shows the elements of a cell, in order of appearance, for the various b-tree page types.</source>
          <target state="translated">セルの書式は、そのセルがどの種類の b-tree ページに表示されるかによって異なります。以下の表は、さまざまな種類の b-tree ページに対して、セルの要素を外観順に示しています。</target>
        </trans-unit>
        <trans-unit id="8f6ebed1965bbd7f7af8c4c0949451b7c054d06f" translate="yes" xml:space="preserve">
          <source>The format of the arguments to the module is very general. Each module-argument may contain keywords, string literals, identifiers, numbers, and punctuation. Each module-argument is passed as written (as text) into the &lt;a href=&quot;vtab#xcreate&quot;&gt;constructor method&lt;/a&gt; of the virtual table implementation when the virtual table is created and that constructor is responsible for parsing and interpreting the arguments. The argument syntax is sufficiently general that a virtual table implementation can, if it wants to, interpret its arguments as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in an ordinary &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The implementation could also impose some other interpretation on the arguments.</source>
          <target state="translated">モジュールへの引数の形式は非常に一般的です。各モジュール引数には、キーワード、文字列リテラル、識別子、数字、句読点を含めることができます。各モジュール引数は、仮想テーブルが作成され、引数の解析と解釈を担当するコンストラクターの場合、書き込まれたとおりに（テキストとして）仮想テーブル実装の&lt;a href=&quot;vtab#xcreate&quot;&gt;コンストラクターメソッド&lt;/a&gt;に渡されます。引数の構文は十分に一般的であり、仮想テーブルの実装では、必要に応じて、その引数を通常の&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントの&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定義&lt;/a&gt;として解釈できます。実装は、引数に他の解釈を課すこともできます。</target>
        </trans-unit>
        <trans-unit id="ce6813c51545b0e36cbda5b5ae9abe31c78f2212" translate="yes" xml:space="preserve">
          <source>The format of the main database file is as described in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The &lt;a href=&quot;fileformat2#vnums&quot;&gt;file format version numbers&lt;/a&gt; at offsets 18 and 19 into the main database must both be 2 to indicate that the database is in WAL mode. The main database may have an arbitrary name allowed by the underlying filesystem. No special file suffixes are required, though &quot;.db&quot;, &quot;.sqlite&quot;, and &quot;.sqlite3&quot; seem to be popular choices.</source>
          <target state="translated">メインデータベース&lt;a href=&quot;fileformat2&quot;&gt;ファイルの形式&lt;/a&gt;は、ファイル形式のドキュメントに記載されています。&lt;a href=&quot;fileformat2#vnums&quot;&gt;ファイル形式のバージョン番号&lt;/a&gt;オフセット18とメインデータベースに19においては、両方のデータベースはWALモードにあることを示すために2でなければなりません。メインデータベースには、基になるファイルシステムで許可されている任意の名前を付けることができます。 「.db」、「。sqlite」、「。sqlite3」が一般的な選択肢のようですが、特別なファイルサフィックスは必要ありません。</target>
        </trans-unit>
        <trans-unit id="c748249cfa33fdfdfb8560eb0a7a2d06c6a7130e" translate="yes" xml:space="preserve">
          <source>The format string for printf() is a template for the generated string. Substitutions are made whenever a &quot;%&quot; character appears in the format string. The &quot;%&quot; is followed by one or more additional characters that describe the substitution. Each substitution has the following format:</source>
          <target state="translated">printf()の書式文字列は、生成された文字列のテンプレートです。フォーマット文字列の中に&quot;%&quot;が現れるたびに、置換が行われます。この&quot;%&quot;の後には、置換を説明する1つ以上の文字が続きます。各置換は以下の形式になります。</target>
        </trans-unit>
        <trans-unit id="e5481902d614e43b8906fc140d4dc2a9c7914623" translate="yes" xml:space="preserve">
          <source>The format used by SQLite database files has been completely revised. The old version 2.1 format and the new 3.0 format are incompatible with one another. Version 2.8 of SQLite will not read a version 3.0 database files and version 3.0 of SQLite will not read a version 2.8 database file.</source>
          <target state="translated">SQLiteデータベースファイルが使用するフォーマットが全面的に見直されました。旧バージョン2.1のフォーマットと新バージョン3.0のフォーマットは互いに互換性がありません。SQLiteのバージョン2.8ではバージョン3.0のデータベースファイルは読み込まれず、SQLiteのバージョン3.0ではバージョン2.8のデータベースファイルは読み込まれません。</target>
        </trans-unit>
        <trans-unit id="a376c207dbbf638ec2db0cb626e4c46931a236b1" translate="yes" xml:space="preserve">
          <source>The fossil delta format may only be used to update BLOB values. Instead of storing the new BLOB within the data_% table, the fossil delta is stored instead. And instead of specifying an 'x' as part of the rbu_control string for the column to be updated, an 'f' character is stored. When processing an 'f' update, RBU loads the original BLOB data from disk, applies the fossil delta to it and stores the results back into the database file. The RBU databases generated by &lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt; make use of fossil deltas wherever doing so would save space in the RBU database.</source>
          <target state="translated">化石デルタ形式は、BLOB値の更新にのみ使用できます。 data_％テーブル内に新しいBLOBを保存する代わりに、化石デルタが代わりに保存されます。そして、更新される列のrbu_control文字列の一部として「x」を指定する代わりに、「f」文字が格納されます。 「f」更新を処理するとき、RBUは元のBLOBデータをディスクからロードし、化石デルタをそれに適用し、結果をデータベースファイルに保存します。&lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt;によって生成されたRBUデータベースは、RBUデータベースのスペースを節約する場合は常に、化石デルタを利用します。</target>
        </trans-unit>
        <trans-unit id="23a39933682f9054d9fbfd81554ffb9e23300f95" translate="yes" xml:space="preserve">
          <source>The founder of SQLite and all current developers have pledged to follow spirit of The Rule to the best of their ability. They view The Rule as their promise to all SQLite users of how the developers are expected to behave in community. This is a one-way promise, or covenant. In other words, the developers are saying: &quot;We will treat you this way regardless of how you treat us.&quot;</source>
          <target state="translated">SQLite の創設者と現在の開発者は、The Rule の精神にできる限り従うことを誓っています。彼らはThe Ruleを、開発者がコミュニティでどのように振る舞うことを期待されているかという、すべてのSQLiteユーザーとの約束だと考えています。これは一方通行の約束、または誓約です。言い換えれば、開発者はこう言っているのです。&quot;あなたが私たちをどう扱うかに関わらず、私たちはあなたをこのように扱います。</target>
        </trans-unit>
        <trans-unit id="fac57078ba906f356fde5d5be039fc86e66f550e" translate="yes" xml:space="preserve">
          <source>The founder of SQLite, and all of the current developers at the time when this document was composed, have pledged to govern their interactions with each other, with their clients, and with the larger SQLite user community in accordance with the &quot;instruments of good works&quot; from chapter 4 of &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;The Rule of St. Benedict&lt;/a&gt; (hereafter: &quot;The Rule&quot;). This code of ethics has proven its mettle in thousands of diverse communities for over 1,500 years, and has served as a baseline for many civil law codes since the time of Charlemagne.</source>
          <target state="translated">SQLiteの創設者、およびこのドキュメントが作成された当時のすべての現在の開発者は、「優れた作品の計器」に従って、相互の、クライアントとの、およびより大きなSQLiteユーザーコミュニティとの相互作用を管理することを誓約しています。 「&lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;聖ベネディクトの支配の&lt;/a&gt;第4章から（以下：「支配」）。この倫理規定は、1500年以上にわたって数千の多様なコミュニティでその能力を証明しており、シャルルマーニュの時代から多くの民法典のベースラインとしての役割を果たしてきました。</target>
        </trans-unit>
        <trans-unit id="555d8586503882b041c2a8a309c2f9e999580160" translate="yes" xml:space="preserve">
          <source>The four utility functions</source>
          <target state="translated">4つの効用関数</target>
        </trans-unit>
        <trans-unit id="6cfb5a37e3c4d212e2442aae712218c04b105dd5" translate="yes" xml:space="preserve">
          <source>The four-byte page number at offset 8 is the right-most pointer. This value appears in the header of interior b-tree pages only and is omitted from all other pages.</source>
          <target state="translated">オフセット 8 の 4 バイトページ番号は、右端のポインタである。この値は、内部のb-treeページのヘッダにのみ現れ、それ以外のページからは省略される。</target>
        </trans-unit>
        <trans-unit id="76f618a5029c6002ebdae975ee6043d888618d19" translate="yes" xml:space="preserve">
          <source>The fourth argument (xFilter) passed to these functions is the &quot;filter callback&quot;. If it is not NULL, then for each table affected by at least one change in the changeset, the filter callback is invoked with the table name as the second argument, and a copy of the context pointer passed as the sixth argument as the first. If the &quot;filter callback&quot; returns zero, then no attempt is made to apply any changes to the table. Otherwise, if the return value is non-zero or the xFilter argument to is NULL, all changes related to the table are attempted.</source>
          <target state="translated">これらの関数に渡される第4引数(xFilter)は、&quot;フィルタコールバック &quot;です。これがNULLでない場合、チェンジセットの少なくとも一つの変更によって影響を受ける各テーブルに対して、第二引数にテーブル名を、第六引数にコンテキストポインタのコピーを第一引数として、フィルタコールバックが呼び出されます。もし &quot;filter callback &quot;が0を返した場合、テーブルに変更を適用しようとはしません。そうでなければ、戻り値がゼロでない場合、あるいは xFilter の引数が NULL の場合は、テーブルに関連するすべての変更が試みられます。</target>
        </trans-unit>
        <trans-unit id="999f04c49ef94f8766fa9cb6bb9bbba18afe2ece" translate="yes" xml:space="preserve">
          <source>The fourth argument, pArg, is an application data pointer that is passed through as the first argument to the collating function callback.</source>
          <target state="translated">第4引数のpArgは、照合関数コールバックの第1引数として渡されるアプリケーションデータポインタです。</target>
        </trans-unit>
        <trans-unit id="c6b1934196a189db01281779b0c51a4b66faf522" translate="yes" xml:space="preserve">
          <source>The fourth column is the maximum value of any rowid in the table.</source>
          <target state="translated">第4列は、テーブル内の任意のrowidの最大値です。</target>
        </trans-unit>
        <trans-unit id="69cc3b7ae5b0c474135cb2e440fa03951919eaf0" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">4番目のパラメーターには、オプションで&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグを含めることもできます。このフラグがあると、VIEWまたはTRIGGER内から関数が呼び出されなくなります。セキュリティ上の理由から、副作用のあるアプリケーション定義のSQL関数には&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f52c4099bf56a2a098b10ec045515f7e30e89130" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">4番目のパラメーターには、オプションで&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグを含めることもできます。このフラグがあると、VIEWまたはTRIGGER内から関数が呼び出されなくなります。セキュリティ上の理由から、副作用のあるアプリケーション定義のSQL関数には&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグをお勧めします。</target>
        </trans-unit>
        <trans-unit id="649add83c8043b4bf2ea6e4b6cf49a7fdf941dff" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">4番目のパラメーターは、オプションで&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;とORして、単一のSQLステートメント内で同じ入力が与えられた場合、関数が常に同じ結果を返すことを通知できます。ほとんどのSQL関数は確定的です。組み込みの&lt;a href=&quot;lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL関数は、決定論的ではない関数の例です。 SQLiteクエリプランナーは確定的関数に対して追加の最適化を実行できるため、可能な場合は&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;フラグの使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="658cc43bdf2652e8cf4b2cffdcf6459b264f185d" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">4番目のパラメーターは、オプションで&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;とORして、単一のSQLステートメント内で同じ入力が与えられた場合、関数が常に同じ結果を返すことを通知できます。ほとんどのSQL関数は確定的です。組み込みの&lt;a href=&quot;../lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL関数は、決定論的ではない関数の例です。 SQLiteクエリプランナーは確定的関数に対して追加の最適化を実行できるため、可能な場合は&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;フラグの使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="feefd1b9ff1b8c4a1a74b3c8f0c879ca3de261f9" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">sqlite3_open_v2（）の4番目のパラメーターは、新しいデータベース接続が使用するオペレーティングシステムインターフェースを定義する&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトの名前です。 4番目のパラメーターがNULLポインターの場合、デフォルトの&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトが使用されます。</target>
        </trans-unit>
        <trans-unit id="b7bbbda582299a1f3186b36dde756d304b0fa7e6" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">sqlite3_open_v2（）の4番目のパラメーターは、新しいデータベース接続が使用するオペレーティングシステムインターフェースを定義する&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトの名前です。 4番目のパラメーターがNULLポインターの場合、デフォルトの&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトが使用されます。</target>
        </trans-unit>
        <trans-unit id="d063d165e08786a1b7ee913cfa396d1655f4a730" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;#SQLITE_ANY&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">4番目のパラメーターeTextRepは、このSQL関数がそのパラメーターとして優先する&lt;a href=&quot;#SQLITE_ANY&quot;&gt;テキストエンコードを&lt;/a&gt;指定します。アプリケーションにこのパラメータを設定する必要があり&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;機能実現呼び出すがあれば&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;（sqlite3_value_text16le）&lt;/a&gt;入力に、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;実装呼び出すがあれば&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;（sqlite3_value_text16be）&lt;/a&gt;入力に、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;場合&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16）は、（&lt;/a&gt;使用されるか、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;さもないと。同じSQL関数が、エンコーディングごとに異なる実装で、異なる優先テキストエンコーディングを使用して複数回登録される場合があります。同じ関数の複数の実装が利用可能な場合、SQLiteは、データ変換が最も少ない実装を選択します。</target>
        </trans-unit>
        <trans-unit id="57c66b621bee32c598b5cb9d09e4c1e1ae3f09dc" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;c_any&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">4番目のパラメーターeTextRepは、このSQL関数がそのパラメーターとして優先する&lt;a href=&quot;c_any&quot;&gt;テキストエンコードを&lt;/a&gt;指定します。アプリケーションにこのパラメータを設定する必要があり&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;機能実現呼び出すがあれば&lt;a href=&quot;value_blob&quot;&gt;（sqlite3_value_text16le）&lt;/a&gt;入力に、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;実装呼び出すがあれば&lt;a href=&quot;value_blob&quot;&gt;（sqlite3_value_text16be）&lt;/a&gt;入力に、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;場合&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16）は、（&lt;/a&gt;使用されるか、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;さもないと。同じSQL関数が、エンコーディングごとに異なる実装で、異なる優先テキストエンコーディングを使用して複数回登録される場合があります。同じ関数の複数の実装が利用可能な場合、SQLiteは、データ変換が最も少ない実装を選択します。</target>
        </trans-unit>
        <trans-unit id="cdeeaf74a0034cfafd692646911468eeef688545" translate="yes" xml:space="preserve">
          <source>The fragment is optional. If present, it is ignored.</source>
          <target state="translated">フラグメントはオプションです。存在する場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="36f14f55d888327ce43d396d69903a3ff7fd8e07" translate="yes" xml:space="preserve">
          <source>The frame boundary is the first row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">フレーム境界は、&lt;a href=&quot;windowfunctions#ptxn&quot;&gt;パーティションの&lt;/a&gt;最初の行です。</target>
        </trans-unit>
        <trans-unit id="3a03f5ecd3e39afb46315f6d23c888ecf09dac7b" translate="yes" xml:space="preserve">
          <source>The frame boundary is the last row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">フレーム境界は、&lt;a href=&quot;windowfunctions#ptxn&quot;&gt;パーティションの&lt;/a&gt;最後の行です。</target>
        </trans-unit>
        <trans-unit id="d8ad39ba6054748efcf881cf5f3cfd24dafacebd" translate="yes" xml:space="preserve">
          <source>The frame-spec determines which output rows are read by an aggregate window function. The frame-spec consists of four parts:</source>
          <target state="translated">フレーム仕様は、集約ウィンドウ関数によって読み込まれる出力行を決定します。フレーム仕様は4つの部分から構成されています。</target>
        </trans-unit>
        <trans-unit id="8eb0b0542bfd6ed405e2b53c332150eda864217a" translate="yes" xml:space="preserve">
          <source>The freelist is organized as a linked list of freelist trunk pages with each trunk page containing page numbers for zero or more freelist leaf pages.</source>
          <target state="translated">フリーリストは、フリーリストのトランクページのリンクされたリストとして組織されており、各トランクページにはゼロ以上のフリーリストのリーフページのページ番号が含まれています。</target>
        </trans-unit>
        <trans-unit id="4faa37aa2595b1d3bc75280cd8996cd072597ac3" translate="yes" xml:space="preserve">
          <source>The fts3tokenize virtual table can be used on any tokenizer, regardless of whether or not there exists an FTS3 or FTS4 table that actually uses that tokenizer.</source>
          <target state="translated">fts3tokenize 仮想テーブルは、実際にそのトークナイザーを使用している FTS3 や FTS4 テーブルが存在するかどうかにかかわらず、任意のトークナイザーで使用できます。</target>
        </trans-unit>
        <trans-unit id="346445abda1b7582bb76e9ab2cc48bb753bf4d95" translate="yes" xml:space="preserve">
          <source>The fts5 unicode61 tokenizer is byte-for-byte compatible with the fts3/4 unicode61 tokenizer.</source>
          <target state="translated">fts5 unicode61トークナイザーは、fts3/4 unicode61トークナイザーとバイト単位で互換性があります。</target>
        </trans-unit>
        <trans-unit id="78675caf2de7d160a88a0d764272d7a44454db10" translate="yes" xml:space="preserve">
          <source>The fts5_api structure is defined as follows. It exposes three methods, one each for registering new auxiliary functions and tokenizers, and one for retrieving existing tokenizer. The latter is intended to facilitate the implementation of &quot;tokenizer wrappers&quot; similar to the built-in porter tokenizer.</source>
          <target state="translated">fts5_api構造体は以下のように定義されています。これは3つのメソッドを公開しており、それぞれ1つは新しい補助関数とトークンサイザを登録するためのもの、もう1つは既存のトークンサイザを取得するためのものです。後者は、組み込みのPORTERトークナイザーに似た「トークナイザーラッパー」の実装を容易にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="162ffee085d8569c08bb1ab9fff2a388996d64c4" translate="yes" xml:space="preserve">
          <source>The fts5_api structure methods are described individually in the following sections.</source>
          <target state="translated">fts5_api構造体のメソッドについては、以下のセクションで個別に説明します。</target>
        </trans-unit>
        <trans-unit id="10c372ee6826e322ad4396357787688e82cce472" translate="yes" xml:space="preserve">
          <source>The fts5vocab virtual table module allows users to extract information from an FTS5 full-text index directly. The fts5vocab module is a part of FTS5 - it is available whenever FTS5 is.</source>
          <target state="translated">fts5vocab仮想テーブルモジュールは、ユーザーがFTS5のフルテキストインデックスから直接情報を抽出することを可能にします。fts5vocabモジュールはFTS5の一部です。</target>
        </trans-unit>
        <trans-unit id="7f3f12f1d0cab297fd4ff2f20d0ccb7ef0778aa5" translate="yes" xml:space="preserve">
          <source>The full pathname of the database file is now remembered even if a relative path is passed into sqlite_open(). This allows the library to continue operating correctly after a chdir().</source>
          <target state="translated">sqlite_open()に相対パスが渡された場合でも、データベースファイルのフルパス名が記憶されるようになりました。これにより、chdir()の後でもライブラリを正しく動作させることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="3b9a46ef2b67e207b1134faeedabd205f3bd8481" translate="yes" xml:space="preserve">
          <source>The full syntax for specifying foreign key constraints is available as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation. Replacing the phrase above with any of the following creates an immediate foreign key constraint.</source>
          <target state="translated">外部キー制約を指定するための完全な構文は、&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ドキュメントの一部として利用できます。上記のフレーズを次のいずれかに置き換えると、すぐに外部キー制約が作成されます。</target>
        </trans-unit>
        <trans-unit id="976d387f058fd1530001e6bc24b270372cb7f6ff" translate="yes" xml:space="preserve">
          <source>The full-text index maintained by FTS5 is stored as a series of fixed-size blobs in a database table. It is not strictly necessary for all blobs that make up a full-text index to be the same size. The pgsz option determines the size of all blobs created by subsequent index writers. The default value is 1000.</source>
          <target state="translated">FTS5によって維持されるフルテキストインデックスは、データベーステーブル内の固定サイズの一連のブロブとして格納される。フルテキストインデックスを構成するすべてのブロブが同じサイズであることは厳密には必要ではありません。pgsz オプシ ョ ンは、 後続の イ ンデ ッ ク ス作成者が作成す る すべてのブロブのサ イ ズ を決定 し ます。デフォルト値は1000です。</target>
        </trans-unit>
        <trans-unit id="7d7917f6db9701130aeed21c2478cad3cdfc0903" translate="yes" xml:space="preserve">
          <source>The function name is specified in UTF-8. A separate sqlite3_create_function16() API works the same as sqlite_create_function() except that the function name is specified in UTF-16 host byte order.</source>
          <target state="translated">関数名はUTF-8で指定されます。別のsqlite3_create_function16()APIはsqlite_create_function()と同じように動作しますが、関数名がUTF-16ホストバイト順で指定されていることが異なります。</target>
        </trans-unit>
        <trans-unit id="026205ed147556f48d88752d5a21eccbd2a64b48" translate="yes" xml:space="preserve">
          <source>The function pointer returned by this routine must be valid for the lifetime of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object given in the first parameter.</source>
          <target state="translated">このルーチンによって返される関数ポインターは、最初のパラメーターで指定された&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;オブジェクトの存続期間中有効でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d5578e17f6c531f672841ef155dfdacbfa341e5d" translate="yes" xml:space="preserve">
          <source>The function presented in the previous example copies the entire source database in one call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This requires holding a read-lock on the source database file for the duration of the operation, preventing any other database user from writing to the database. It also holds the mutex associated with database pInMemory throughout the copy, preventing any other thread from using it. The C function in this section, designed to be called by a background thread or process for creating a backup of an online database, avoids these problems using the following approach:</source>
          <target state="translated">前の例で示した関数は、&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;への1回の呼び出しでソースデータベース全体をコピーします。これには、操作中にソースデータベースファイルの読み取りロックを保持し、他のデータベースユーザーがデータベースに書き込みできないようにする必要があります。また、コピー全体にわたってデータベースpInMemoryに関連付けられたミューテックスを保持し、他のスレッドがそれを使用できないようにします。このセクションのC関数は、オンラインデータベースのバックアップを作成するためのバックグラウンドスレッドまたはプロセスによって呼び出されるように設計されており、次のアプローチを使用してこれらの問題を回避します。</target>
        </trans-unit>
        <trans-unit id="0137a1cc90b7f7f164b60d3e6a0abb13294403cf" translate="yes" xml:space="preserve">
          <source>The functionality provided by the fts4aux module is now provided by &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt;. The schema of these two tables is slightly different.</source>
          <target state="translated">fts4auxモジュールによって提供される機能は、fts5vocabによって提供されるように&lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;なりました&lt;/a&gt;。これら2つのテーブルのスキーマは少し異なります。</target>
        </trans-unit>
        <trans-unit id="82f4a608941f31ed6516bc837d2ee3e175fc4792" translate="yes" xml:space="preserve">
          <source>The functionality required of each of the above functions is described in comments in sqlite3async.c.</source>
          <target state="translated">上記の各関数に必要な機能はsqlite3async.cのコメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="a3e3ee73e4504a9b18df3710202691563a7ae8e5" translate="yes" xml:space="preserve">
          <source>The general purpose memory allocator is the most difficult memory pool to manage because it supports allocations of varying sizes. Since &lt;b&gt;n&lt;/b&gt; is a multiplier on &lt;b&gt;M&lt;/b&gt; we want to keep &lt;b&gt;n&lt;/b&gt; as small as possible. This argues for keeping the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; as large as possible. In most applications, the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is able to handle small allocations. So it is reasonable to set the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; to 2, 4 or even 8 times the maximum size of a lookaside allocation. A minimum allocation size of 512 is a reasonable setting.</source>
          <target state="translated">汎用メモリアロケータは、さまざまなサイズの割り当てをサポートするため、管理が最も難しいメモリプールです。以来&lt;b&gt;、nは&lt;/b&gt;上の乗数である&lt;b&gt;Mは、&lt;/b&gt;我々は維持したい&lt;b&gt;nは&lt;/b&gt;できるだけ小さいです。これは、&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5の&lt;/a&gt;最小割り当てサイズをできるだけ大きく保つことを主張しています。ほとんどのアプリケーションでは、&lt;a href=&quot;malloc#lookaside&quot;&gt;lookasideメモリアロケータ&lt;/a&gt;は小さな割り当てを処理できます。したがって、&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5の&lt;/a&gt;最小割り当てサイズを、lookaside割り当ての最大サイズの2、4、または8倍に設定するのが妥当です。512の最小割り当てサイズが妥当な設定です。</target>
        </trans-unit>
        <trans-unit id="30bdbd95e17bffd329d217ead465e3fe28cd023c" translate="yes" xml:space="preserve">
          <source>The general rule is that indexes are only useful if there are WHERE-clause constraints on the left-most columns of the index. However, in some cases, SQLite is able to use an index even if the first few columns of the index are omitted from the WHERE clause but later columns are included.</source>
          <target state="translated">一般的なルールとしては、インデックスの左端の列に WHERE 句の制約がある場合にのみインデックスが有用であるということです。しかし、場合によっては、インデックスの最初の数列がWHERE句から省略されていても、それ以降の列が含まれている場合でも、SQLiteはインデックスを使用することができます。</target>
        </trans-unit>
        <trans-unit id="084577b6dd782fa1eb4651ff451c238f84ef2391" translate="yes" xml:space="preserve">
          <source>The general-purpose memory allocator (&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;).</source>
          <target state="translated">汎用メモリアロケータ（&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="21a012c95267cb8d2b8d45dbbd928793f6616b70" translate="yes" xml:space="preserve">
          <source>The generate_series Table-Valued Function</source>
          <target state="translated">generate_series テーブル値関数</target>
        </trans-unit>
        <trans-unit id="476dfd7c8482f7d1208e7bd9537292c089264e39" translate="yes" xml:space="preserve">
          <source>The generate_series table can be simulated using a &lt;a href=&quot;lang_with#recursivecte&quot;&gt;recursive common table expression&lt;/a&gt;. If the three parameters are $start, $end, and $step, then the equivalent common table expression is:</source>
          <target state="translated">generate_seriesテーブルは、&lt;a href=&quot;lang_with#recursivecte&quot;&gt;再帰的な共通テーブル式&lt;/a&gt;を使用してシミュレートできます。3つのパラメーターが$ start、$ end、および$ stepの場合、同等の共通テーブル式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4e3c394ee97ca6ac89b21ae3983e2fd5668b4aa8" translate="yes" xml:space="preserve">
          <source>The generate_series(START,END,STEP) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; included in the SQLite source tree, and compiled into the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;. The generate_series() table has a single result column named &quot;value&quot; holding integer values and a number of rows determined by the parameters START, END, and STEP. The first row of the table has a value of START. Subsequent rows increase by STEP up to END.</source>
          <target state="translated">generate_series（START、END、STEP）&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;は、SQLiteソースツリーに含まれる&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張&lt;/a&gt;機能であり、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルに&lt;/a&gt;コンパイルされます。generate_series（）テーブルには、「value」という名前の単一の結果列があり、整数値と、パラメーターSTART、END、およびSTEPによって決定される行数を保持します。テーブルの最初の行の値はSTARTです。後続の行はSTEPからENDまで増加します。</target>
        </trans-unit>
        <trans-unit id="3f2ed0d414c19e451dbd160a6e3115271ef19a02" translate="yes" xml:space="preserve">
          <source>The geopoly module defines several new SQL functions that are useful for dealing with polygons. All polygon arguments to these functions can be either the GeoJSON format or the internal binary format.</source>
          <target state="translated">geopolyモジュールは、ポリゴンを扱うのに便利ないくつかの新しいSQL関数を定義しています。これらの関数へのすべてのポリゴンの引数は、GeoJSON フォーマットまたは内部バイナリフォーマットのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="8d993a3d44bf40860242bebc1265b2783cf9c63f" translate="yes" xml:space="preserve">
          <source>The geopoly module is an extension to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly uses the same underlying logic and shadow tables as the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly merely presents a different interface, and provides some extra logic to compute polygon decoding, overlap, and containment.</source>
          <target state="translated">geopolyモジュールは、&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張の拡張&lt;/a&gt;です。Geopolyは、&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張&lt;/a&gt;と同じ基本的なロジックとシャドウテーブルを使用します。Geopolyは単に異なるインターフェイスを提供し、ポリゴンのデコード、オーバーラップ、および包含を計算するためのいくつかの追加ロジックを提供します。</target>
        </trans-unit>
        <trans-unit id="acb138b945d23f00cd83af917d94b141700de307" translate="yes" xml:space="preserve">
          <source>The geopoly module is built on top of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; and uses the same underlying shadow tables and algorithms. For indexing purposes, each polygon is represented in the shadow tables as a rectangular bounding box. The underlying R-Tree implementation uses bounding boxes to limit the search space. Then the geoploy_overlap() and/or geopoly_within() routines further refine the search to the exact answer.</source>
          <target state="translated">geopolyモジュールは&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張の&lt;/a&gt;上に構築され、同じ基礎となるシャドウテーブルとアルゴリズムを使用します。インデックス作成のために、各ポリゴンはシャドウテーブルで長方形の境界ボックスとして表されます。基になるRツリー実装は、境界ボックスを使用して検索スペースを制限します。次に、geoploy_overlap（）および/またはgeopoly_within（）ルーチンが検索をさらに正確な答えに絞り込みます。</target>
        </trans-unit>
        <trans-unit id="fdb9ae6360ea866b8222993691854e31ea695989" translate="yes" xml:space="preserve">
          <source>The geopoly_ccw(J) function returns the polygon J with counter-clockwise (CCW) rotation.</source>
          <target state="translated">geopoly_ccw(J)関数は、反時計回り(CCW)回転の多角形 J を返します。</target>
        </trans-unit>
        <trans-unit id="58be5b36690d1c8a61ca619684c9087df6d3c79c" translate="yes" xml:space="preserve">
          <source>The geopoly_group_bbox(P) function is an aggregate version of geopoly_bbox(P). The geopoly_group_bbox(P) function returns the smallest rectangle that will enclose all P values seen during aggregation.</source>
          <target state="translated">geopoly_group_bbox(P)関数は、 geopoly_bbox(P)の集約版です。geopoly_group_bbox(P)関数は、 集約中に見られるすべてのPの値を囲む最小の矩形を返します。</target>
        </trans-unit>
        <trans-unit id="7aa31a665e34b0f93544b760a7bd5d5549c54d97" translate="yes" xml:space="preserve">
          <source>The geopoly_overlap(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_overlap() as a boolean function. Only the geopoly_overlap(P1,P2) and geopoly_within(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_overlap(P1,P2)関数は、 geopoly仮想テーブルがR*Treeインデックスを使用して、 WHERE句がgeopoly_overlap()をブール関数として使用するクエリを最適化する方法を知っているという点で特別です。geopoly_overlap(P1,P2)とgeopoly_within(P1,P2)関数だけがこの機能を持っています。</target>
        </trans-unit>
        <trans-unit id="4552cf5a5f2e459423714152983f2ca48f86f169" translate="yes" xml:space="preserve">
          <source>The geopoly_regular(X,Y,R,N) function returns a convex, simple, regular, equilateral, equiangular polygon with N sides, centered at X,Y, and with a circumradius of R. Or, if R is negative or if N is less than 3, the function returns NULL. The N value is capped at 1000 so that the routine will never render a polygon with more than 1000 sides even if the N value is larger than 1000.</source>
          <target state="translated">geopoly_regular(X,Y,R,N)関数は、X,Yを中心としたN辺、円周率Rを持つ、凸で単純な正三角形、正三角形、正三角形の多角形を返します。N の値は 1000 が上限で、N の値が 1000 より大きい場合でも、1000 を超える辺を持つ多角形を描画することはありません。</target>
        </trans-unit>
        <trans-unit id="01eba492c4ddd36076bba0e9fe7c2f9d9c526116" translate="yes" xml:space="preserve">
          <source>The geopoly_within(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_within() as a boolean function. Only the geopoly_within(P1,P2) and geopoly_overlap(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_within(P1,P2)関数は、geopoly仮想テーブルがR*Treeインデックスを使用して、 WHERE句がgeopoly_within()をブール関数として使用するクエリを最適化する方法を知っているという点で特別なものです。geopoly_within(P1,P2)とgeopoly_overlap(P1,P2)関数だけがこの機能を持っています。</target>
        </trans-unit>
        <trans-unit id="45313c37ef01af04ca79cf8e508d2efcd3ced709" translate="yes" xml:space="preserve">
          <source>The geopoly_xform(P,A,B,C,D,E,F) function returns a new polygon that is an affine transformation of the polygon P and where the transformation is defined by values A,B,C,D,E,F. If P is not a valid polygon, this routine returns NULL.</source>
          <target state="translated">geopoly_xform(P,A,B,C,D,E,F)関数は、多角形 P のアフィン変換であり、変換が A,B,C,D,E,F で定義されている新しい多角形を返します。P が有効な多角形でない場合、このルーチンは NULL を返します。</target>
        </trans-unit>
        <trans-unit id="8a7538a75bac0dc91c968f2f943ef8c77b915108" translate="yes" xml:space="preserve">
          <source>The glob(X,Y) function is equivalent to the expression &quot;&lt;b&gt;Y GLOB X&lt;/b&gt;&quot;. Note that the X and Y arguments are reversed in the glob() function relative to the infix &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator. Y is the string and X is the pattern. So, for example, the following expressions are equivalent:</source>
          <target state="translated">glob（X、Y）関数は、式 &quot; &lt;b&gt;Y GLOB X&lt;/b&gt; &quot; と同等です。X引数とY引数は、中置&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;演算子と比較してglob（）関数では逆になっていることに注意してください。Yは文字列、Xはパターンです。したがって、たとえば、次の式は同等です。</target>
        </trans-unit>
        <trans-unit id="57af892941202e82d82f19e609a84ccb0531eaad" translate="yes" xml:space="preserve">
          <source>The goal is to make SQLite handle NULLs in a standards-compliant way. But the descriptions in the SQL standards on how to handle NULLs seem ambiguous. It is not clear from the standards documents exactly how NULLs should be handled in all circumstances.</source>
          <target state="translated">目的は、SQLiteが標準に準拠した方法でNULLを扱えるようにすることです。しかし、SQL標準ではNULLをどのように扱うかについての記述が曖昧なようです。標準SQL文書では、あらゆる状況下でNULLをどのように扱うべきかが明確になっていません。</target>
        </trans-unit>
        <trans-unit id="2ba0147df5ada0e089bdabaebc1a5094f5e9a20f" translate="yes" xml:space="preserve">
          <source>The goal of this query is to compute some value for the five most recent entries in the table. But in the query above, the &quot;expensive_function()&quot; is invoked prior to the sort and thus is invoked on every row of the table, even rows that are ultimately omitted due to the LIMIT clause. A co-routine can be used to work around this:</source>
          <target state="translated">このクエリの目的は、テーブル内の直近の5つのエントリに対して何らかの値を計算することです。しかし、上のクエリでは、&quot;expensive_function()&quot;はソートの前に呼び出されるため、テーブルのすべての行で呼び出され、最終的にLIMIT句によって省略された行でさえも呼び出されます。これを回避するために、コ・ルーティンを使用することができます。</target>
        </trans-unit>
        <trans-unit id="27130ed911ba5b72cf5d70b6f38c66e3447f97b9" translate="yes" xml:space="preserve">
          <source>The grammar syntax is less error prone - using symbolic names for semantic values rather that the &quot;$1&quot;-style positional notation of Yacc.</source>
          <target state="translated">文法構文は、Yaccの&quot;$1 &quot;スタイルの位置表記ではなく、意味値にシンボリック名を使用しているため、エラーが発生しにくくなっています。</target>
        </trans-unit>
        <trans-unit id="8288ae8eb06e54b34a1335f8c6fbfb99327b7542" translate="yes" xml:space="preserve">
          <source>The graph below shows the number of CPU cycles used by SQLite on a standard workload, for versions of SQLite going back about 10 years. Recent versions of SQLite use about one third as many the CPU cycles compared to older versions.</source>
          <target state="translated">下のグラフは、約10年前のバージョンのSQLiteについて、標準的なワークロードでSQLiteが使用したCPUサイクル数を示しています。最近のバージョンのSQLiteは、古いバージョンに比べて約3分の1のCPUサイクルを使用しています。</target>
        </trans-unit>
        <trans-unit id="ea3dfc83e3fad7e5da84aa92171fa1f2ebb6adae" translate="yes" xml:space="preserve">
          <source>The group_concat() function returns a string which is the concatenation of all non-NULL values of</source>
          <target state="translated">関数 group_concat()は</target>
        </trans-unit>
        <trans-unit id="998c879f2d9a4a324ed589705e44b7743eed8ace" translate="yes" xml:space="preserve">
          <source>The group_concat(x,'') SQL function returns NULL instead of an empty string when all inputs are empty strings. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</source>
          <target state="translated">group_concat（x、 ''）SQL関数は、すべての入力が空の文字列の場合、空の文字列ではなくNULLを返します。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cc69e429ade6ced467dc065c3703a231254bc0f" translate="yes" xml:space="preserve">
          <source>The handling of IN and NOT IN operators that contain a NULL on their right-hand side expression is brought into compliance with the SQL standard and with other SQL database engines. This is a bug fix, but as it has the potential to break legacy applications that depend on the older buggy behavior, we mark that as a *** Potentially incompatible change ***</source>
          <target state="translated">右辺の式にNULLを含むINおよびNOT IN演算子の取り扱いが、SQL標準および他のSQLデータベースエンジンに準拠するようになりました。これはバグフィックスですが、古いバグのある動作に依存しているレガシーアプリケーションを壊す可能性があるため、***互換性のない変更***としてマークしています。</target>
        </trans-unit>
        <trans-unit id="d0efc6030fa81d141b43a701523b55c7bcf660fd" translate="yes" xml:space="preserve">
          <source>The hash tables in the shm file are designed to answer the following question quickly:</source>
          <target state="translated">shmファイルのハッシュ表は、以下の質問にすぐに答えられるようになっています。</target>
        </trans-unit>
        <trans-unit id="2856b370cad55dc7412b44b6f210c8cf053331d6" translate="yes" xml:space="preserve">
          <source>The hashes that identify check-ins and files on the Git mirror are different from the hashes in Fossil. There are many reasons for this, chief among them that Fossil uses a SHA3-256 hash whereas Git uses a SHA1 hash. During export, the original Fossil hash for each check-in is added as a footer to check-in comments. To avoid confusion, always use the original Fossil hash, not the Git hash, when referring to SQLite check-ins.</source>
          <target state="translated">Git ミラー上のチェックインやファイルを識別するハッシュは、Fossil のハッシュとは異なります。これには多くの理由がありますが、中でもFossilはSHA3-256ハッシュを使用しているのに対し、GitはSHA1ハッシュを使用していることが主な理由です。エクスポート時には、各チェックインのオリジナルのFossilハッシュがチェックインコメントのフッターとして追加されます。混乱を避けるため、SQLiteのチェックインを参照する際は、Gitのハッシュではなく、必ずオリジナルのFossilのハッシュを使用してください。</target>
        </trans-unit>
        <trans-unit id="e115da518074674c7bed9606a1f3c39c1334b0dc" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal can be overwritten with invalid header text (for example, all zeros).</source>
          <target state="translated">ロールバックジャーナルのヘッダは、無効なヘッダテキスト(例えば、すべてのゼロ)で上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="328251bbc9b91a18ef755ecd2993b4b5eb3cf221" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal is well-formed and in particular has not been zeroed out.</source>
          <target state="translated">ロールバックジャーナルのヘッダは整形されており、特にゼロアウトされていません。</target>
        </trans-unit>
        <trans-unit id="8908758df6621b583f7634e3a00bc808f16a9ffb" translate="yes" xml:space="preserve">
          <source>The header size varint and serial type varints will usually consist of a single byte. The serial type varints for large strings and BLOBs might extend to two or three byte varints, but that is the exception rather than the rule. The varint format is very efficient at coding the record header.</source>
          <target state="translated">ヘッダサイズの varint とシリアル型の varint は通常 1 バイトで構成されています。大きな文字列や BLOB のためのシリアル型の varint は 2 バイトか 3 バイトの varint に拡張されるかもしれませんが、これは規則というよりはむしろ例外です。varint 形式はレコードヘッダのコーディングにおいて非常に効率的です。</target>
        </trans-unit>
        <trans-unit id="6a561080aa600994c95f7609f8c9a76e07664cc1" translate="yes" xml:space="preserve">
          <source>The header string: &quot;SQLite format 3\000&quot;</source>
          <target state="translated">ヘッダー文字列 &quot;SQLite format 3\000&quot;</target>
        </trans-unit>
        <trans-unit id="95f9212fdc8a88cf98b4e1490976ec2f7354c6a2" translate="yes" xml:space="preserve">
          <source>The heavy wrapper employed by &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is intended for use only during testing, analysis, and debugging of SQLite. The heavy wrapper has a significant performance and memory overhead and probably should not be used in production.</source>
          <target state="translated">&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;で使用される重いラッパーは、SQLiteのテスト、分析、デバッグ中にのみ使用することを目的としています。重いラッパーはパフォーマンスとメモリのオーバーヘッドが大きいため、本番環境では使用しないでください。</target>
        </trans-unit>
        <trans-unit id="eb4610f1226d8f274f85d7debe217f5d65427f90" translate="yes" xml:space="preserve">
          <source>The heavy wrapper that is used when &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is set also makes sure each new allocation is filled with nonsense data prior to returning the allocation to the caller. And as soon as an allocation is free, it is again filled with nonsense data. These two actions help to ensure that the SQLite core does not make assumptions about the state of newly allocated memory and that memory allocations are not used after they have been freed.</source>
          <target state="translated">&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;が設定されているときに使用される重いラッパーは、割り当てを呼び出し元に返す前に、それぞれの新しい割り当てが無意味なデータで満たされるようにします。そして、割り当てが解放されるとすぐに、再び意味のないデータで満たされます。これらの2つのアクションは、SQLiteコアが新しく割り当てられたメモリの状態を想定せず、解放後にメモリ割り当てが使用されないようにするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a33b86543e89aa7fc91f1c01c079a10eabc5b26c" translate="yes" xml:space="preserve">
          <source>The hex() function interprets its argument as a BLOB and returns a string which is the upper-case hexadecimal rendering of the content of that blob.</source>
          <target state="translated">hex()関数は、その引数を BLOB として解釈し、その BLOB の内容を大文字の 16 進数で表現した文字列を返します。</target>
        </trans-unit>
        <trans-unit id="47e9ec1a2ca9f6468b5d5ea9dca27a7ef3e3db0a" translate="yes" xml:space="preserve">
          <source>The high repeatability of cachegrind allows the SQLite developers to implement and measure &quot;microoptimizations&quot;. A microoptimization is a change to the code that results in a very small performance increase. Typical micro-optimizations reduce the number of CPU cycles by 0.1% or 0.05% or even less. Such improvements are impossible to measure with real-world timings. But hundreds or thousands of microoptimizations add up, resulting in measurable real-world performance gains.</source>
          <target state="translated">cachegrind の高い再現性により、SQLite の開発者は「マイクロ最適化」を実装して測定することができます。微小最適化とは、コードの変更により、非常に小さなパフォーマンスの向上をもたらすことです。典型的なマイクロ最適化は、CPUサイクル数を0.1%もしくは0.05%もしくはそれ以下に減少させます。このような改善は、実世界のタイミングで測定することは不可能です。しかし、何百、何千ものマイクロ最適化が積み重なり、結果的に実世界で測定可能なパフォーマンスの向上をもたらします。</target>
        </trans-unit>
        <trans-unit id="8285d1c1b74bc88c5caec05770baddba5bd483b5" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for over a decade.</source>
          <target state="translated">SQLiteの高い信頼性は実際に証明されています。SQLiteは、世界中の何十億ものスマートフォン、IoTデバイス、デスクトップアプリケーションで、10年以上にわたって問題なく使用されています。</target>
        </trans-unit>
        <trans-unit id="f6fadaee687e9cfda1c93f7fa51b5ba3b3240bd6" translate="yes" xml:space="preserve">
          <source>The highlight() function returns a copy of the text from a specified column of the current row with extra markup text inserted to mark the start and end of phrase matches.</source>
          <target state="translated">highlight()関数は、現在の行の指定した列のテキストのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="e43753ce0913d39afca1c9c249ea51ebaf6b6f06" translate="yes" xml:space="preserve">
          <source>The highlight() must be invoked with exactly three arguments following the table name. To be interpreted as follows:</source>
          <target state="translated">highlight()は、テーブル名の後に正確に 3 つの引数をつけて呼び出す必要があります。次のように解釈すること。</target>
        </trans-unit>
        <trans-unit id="bb9d506afb5b0054b66298f3975841775d6d258d" translate="yes" xml:space="preserve">
          <source>The histogram data is only useful if the right-hand side of the constraint is a simple compile-time constant or &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and not an expression.</source>
          <target state="translated">ヒストグラムデータは、制約の右側が単純なコンパイル時の定数または&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;であり、式ではない場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="754b3dec45709dc037212c7449e27878498a6122" translate="yes" xml:space="preserve">
          <source>The historical behavior of SQLite is incorrect according to the SQL:1999 standard and it is inconsistent with the behavior of MySQL and PostgreSQL. Version 3.6.0 changes the behavior of the IN and NOT IN operators to conform to the standard and to give the same results as other SQL database engines.</source>
          <target state="translated">SQLiteの歴史的な挙動は、SQL:1999標準によると正しくなく、MySQLやPostgreSQLの挙動と矛盾しています。バージョン3.6.0では、標準に準拠し、他のSQLデータベースエンジンと同じ結果が得られるように、INおよびNOT IN演算子の動作が変更されました。</target>
        </trans-unit>
        <trans-unit id="3be31364c3c06e62038927597ca88135a8ca4d7a" translate="yes" xml:space="preserve">
          <source>The iCost column is the numeric cost of transforming cFrom into cTo. This value should be a non-negative integer, and should probably be less than 100. The default single-character insertion and deletion costs are 100 and the default single-character to single-character substitution cost is 150. A cost of 10000 or more is considered &quot;infinite&quot; and causes the rule to be ignored.</source>
          <target state="translated">iCost列は、cFromをcToに変換する際のコストを表す数値です。この値は非負の整数である必要があり、おそらく100未満であるべきです。デフォルトの1文字挿入・削除コストは100で、デフォルトの1文字から1文字への置換コストは150です。10000以上のコストは「無限」とみなされ、ルールは無視されます。</target>
        </trans-unit>
        <trans-unit id="d0b9d0aa5d29da45f0b93b40de44e2f95388c2e0" translate="yes" xml:space="preserve">
          <source>The iLang column is a non-negative integer that identifies a set of costs appropriate for a particular language. The editdist3 function will only use a single iLang value for any given edit-distance computation. The default value is 0. It is recommended that applications that only need to use a single language always use iLang==0 for all entries.</source>
          <target state="translated">iLang列は、特定の言語に適したコストのセットを識別する非負の整数です。editdist3関数は、与えられた編集距離の計算に単一のiLang値のみを使用します。デフォルト値は0です。 単一の言語のみを使用する必要があるアプリケーションでは、すべてのエントリに常にiLang==0を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5013f8a1a10fac4a872743ceb29c353308c4297d" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; is provided as insurance against future enhancements. The iVersion value should always be 1 for SQLite version 3.5.</source>
          <target state="translated">IVERSIONフィールド&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsは、&lt;/a&gt;将来の拡張に対する保険として提供されます。SQLiteバージョン3.5では、iVersion値は常に1である必要があります。</target>
        </trans-unit>
        <trans-unit id="8b61610ddf9130372f875adae334c360bf359102" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; should be 1 for SQLite version 3.5.0. This number may increase in future versions of SQLite if we have to modify the VFS object in some way. We hope that this never happens, but the provision is made in case it does.</source>
          <target state="translated">SQLiteバージョン3.5.0の場合、&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;のiVersionフィールドは1である必要があります。この数は、何らかの方法でVFSオブジェクトを変更する必要がある場合、SQLiteの将来のバージョンで増加する可能性があります。これが起こらないことを願っていますが、万が一の場合に備えて規定されています。</target>
        </trans-unit>
        <trans-unit id="ea830f2d673441ec5d80e9c5eb8623ea5999e87b" translate="yes" xml:space="preserve">
          <source>The idea behind a reserved lock is that it signals that a process intends to modify the database file in the near future but has not yet started to make the modifications. And because the modifications have not yet started, other processes can continue to read from the database. However, no other process should also begin trying to write to the database.</source>
          <target state="translated">予約ロックの背後にある考え方は、あるプロセスが近い将来にデータベースファイルを変更しようとしているが、まだ変更を開始していないことを示すものです。そして、まだ変更が開始されていないので、他のプロセスはデータベースからの読み込みを続けることができます。しかし、他のプロセスがデータベースへの書き込みを開始してはいけません。</target>
        </trans-unit>
        <trans-unit id="b86c36b3766e07cfb666e3625925c99f4017f8b5" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">idxNumおよびidxPtrの値が記録され、&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドに渡されます。&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;は、needToFreeIdxPtrがtrueの場合にのみidxPtrを解放するために使用されます。</target>
        </trans-unit>
        <trans-unit id="357574f6e5fd171b87a29904a513e7015690c872" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">idxNumおよびidxPtrの値が記録され、&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドに渡されます。&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;は、needToFreeIdxPtrがtrueの場合にのみidxPtrを解放するために使用されます。</target>
        </trans-unit>
        <trans-unit id="013b479832be35dd0d8a4395d938100b93b10f74" translate="yes" xml:space="preserve">
          <source>The idxStr value may be a string obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. If this is the case, then the needToFreeIdxStr flag must be set to true so that the SQLite core will know to call &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; on that string when it has finished with it, and thus avoid a memory leak. The idxStr value may also be a static constant string, in which case the needToFreeIdxStr boolean should remain false.</source>
          <target state="translated">idxStr値は、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;などのSQLiteメモリ割り当て関数から取得した文字列である場合があります。その場合は、SQLiteコアがその文字列の処理を終えたときにその文字列で&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を呼び出し、メモリリークを回避できるように、needToFreeIdxStrフラグをtrueに設定する必要があります。idxStr値は、静的定数文字列にすることもできます。その場合、needToFreeIdxStrブール値はfalseのままにする必要があります。</target>
        </trans-unit>
        <trans-unit id="4d5a7e8bc386f87dedf4ba3978aa31bcde8d6916" translate="yes" xml:space="preserve">
          <source>The ifnull() function returns a copy of its first non-NULL argument, or NULL if both arguments are NULL. Ifnull() must have exactly 2 arguments. The ifnull() function is equivalent to &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; with two arguments.</source>
          <target state="translated">ifnull（）関数は、最初の非NULL引数のコピーを返します。両方の引数がNULLの場合はNULLを返します。ifnull（）には2つの引数が必要です。ifnull（）関数は、2つの引数を持つ&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="46220a05919fd727bb5192ff33d2f0412a4a1656" translate="yes" xml:space="preserve">
          <source>The immutable query parameter is a boolean that signals to SQLite that the underlying database file is held on read-only media and cannot be modified, even by another process with elevated privileges. SQLite always opens immutable database files read-only and it skips all file locking and change detection on immutable database files. If these query parameter (or the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; bit in xDeviceCharacteristics) asserts that a database file is immutable and that file changes anyhow, then SQLite might return incorrect query results and/or &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors.</source>
          <target state="translated">不変のクエリパラメータはブール値であり、基になるデータベースファイルが読み取り専用メディアに保持され、昇格された特権を持つ別のプロセスによっても変更できないことをSQLiteに通知します。 SQLiteは常に不変データベースファイルを読み取り専用で開き、不変データベースファイルのすべてのファイルロックと変更検出をスキップします。これらのクエリパラメータ（または&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;xDeviceCharacteristicsのSQLITE_IOCAP_IMMUTABLE&lt;/a&gt;ビット）がデータベースファイルが不変であり、そのファイルが変更されていると断定した場合、SQLiteは不正なクエリ結果や&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;エラーを返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="a6b9b8cf3a7d94e9575aa22c08feee5317ab9464" translate="yes" xml:space="preserve">
          <source>The implementation for the spellfix1 virtual table is held in the SQLite source tree in the miscellaneous extensions folder and in particular in the file &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext/misc/spellfix1.c&lt;/a&gt;. The spellfix1 virtual table is not included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is not a part of any standard SQLite build. It is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">spellfix1仮想テーブルの実装は、その他の拡張機能フォルダーのSQLiteソースツリー、特に&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext / misc / spellfix1.c&lt;/a&gt;ファイルに保持されます。spellfix1仮想テーブルはSQLiteの&lt;a href=&quot;amalgamation&quot;&gt;統合&lt;/a&gt;には含まれておらず、標準のSQLiteビルドの一部ではありません。これは、ある&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eb5688bafc7d4405d9e0ef667e71e04726e76e8" translate="yes" xml:space="preserve">
          <source>The implementation is not required to provide versions of these routines that actually work. If the implementation does not provide working versions of these routines, it should at least provide stubs that always return true so that one does not get spurious assertion failures.</source>
          <target state="translated">実装は、これらのルーチンが実際に動作するバージョンを提供する必要はありません。実装がこれらのルーチンの動作するバージョンを提供していない場合は、少なくとも常に真を返すスタブを提供して、偽のアサーション失敗を起こさないようにすべきです。</target>
        </trans-unit>
        <trans-unit id="8b40a9e730bef66c422bb631b44b6863716defa7" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateFunction() method of the fts5_api object. If there is already an auxiliary function with the same name, it is replaced by the new function. If a non-NULL xDestroy parameter is passed to xCreateFunction(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the registered auxiliary function is replaced.</source>
          <target state="translated">fts5_apiオブジェクトのxCreateFunction()メソッドを呼び出すことで実装をFTS5モジュールに登録します。既に同名の補助関数が存在する場合は、新しい関数に置き換えられます。xCreateFunction()に NULL でない xDestroy パラメータが渡された場合、データベースハンドルが閉じられたとき、または登録された補助関数が置換されたときに、唯一の引数として渡された pContext ポインタのコピーを使用して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="bbe3105d33c8a4906448b08f8925bf436af3dd67" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateTokenizer() method of the fts5_api object. If there is already a tokenizer with the same name, it is replaced. If a non-NULL xDestroy parameter is passed to xCreateTokenizer(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the tokenizer is replaced.</source>
          <target state="translated">fts5_apiオブジェクトのxCreateTokenizer()メソッドを呼び出すことで、実装をFTS5モジュールに登録します。既に同名のトーケナイザーが存在する場合は、それを置き換えます。xCreateTokenizer()に NULL でない xDestroy パラメータが渡された場合、データベースハンドルが閉じられたとき、またはトークンサイザが置き換えられたときに、唯一の引数として渡された pContext ポインタのコピーを使用して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8b89a513d4c178ab8d213508b88c8e5c09e3c7a1" translate="yes" xml:space="preserve">
          <source>The implementation language for the example code is &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;, though you can easily do the same thing in another programming language. Remember that the code here is a demonstration of the technique, not a drop-in module that will automatically do everything for you. The demonstration code shown below is derived from actual code in production use. But you will need to make changes to tailor it to your application.</source>
          <target state="translated">サンプルコードの実装言語は&lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;ですが、別のプログラミング言語で同じことを簡単に行うことができます。ここのコードはテクニックのデモンストレーションであり、自動的にすべてを実行するドロップインモジュールではないことに注意してください。以下に示すデモコードは、本番環境で使用されている実際のコードから派生しています。ただし、アプリケーションに合わせて変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="1c7602fe1bd4486f649d10efe941c63ad9ebc01d" translate="yes" xml:space="preserve">
          <source>The implementation of this function could be enhanced in at least two ways:</source>
          <target state="translated">この機能の実装は、少なくとも2つの方法で強化することができます。</target>
        </trans-unit>
        <trans-unit id="fb654149d36243346cb33110dabec3f86ec0e93a" translate="yes" xml:space="preserve">
          <source>The important parts of the output (the parts that the developers pay the most attention to) are shown in red. Basically, the developers want to know the size of the compiled SQLite library and how many CPU cycles were needed to run the performance test.</source>
          <target state="translated">出力の重要な部分(開発者が最も注意を払う部分)は赤で示されています。基本的に開発者が知りたいのは、コンパイルされたSQLiteライブラリのサイズと、パフォーマンステストを実行するのに必要なCPUサイクル数です。</target>
        </trans-unit>
        <trans-unit id="98a68810edc43f0319b74cd65a4602d55569695b" translate="yes" xml:space="preserve">
          <source>The imposter table mechanism is a power analysis and debugging tool for SQLite. But as with all sharp tools, it can also be dangerous and can result in corrupt database files if misused. Do not attempt to use imposter tables in an application. Imposter tables are intended for use in the laboratory by experts.</source>
          <target state="translated">インポスターテーブルメカニズムは、SQLiteのための強力な解析およびデバッグツールです。しかし、他の鋭利なツールと同様に、誤った使い方をすると危険なこともあり、データベースファイルを破損させる結果になることもあります。アプリケーションでインポスターテーブルを使用しようとしないでください。インポスターテーブルは、専門家による研究室での使用を目的としています。</target>
        </trans-unit>
        <trans-unit id="f137c1fa92f06c6d9054e4f6699dd72be9e8aeef" translate="yes" xml:space="preserve">
          <source>The in-header database size is only considered to be valid if it is non-zero and if the 4-byte &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; at offset 24 exactly matches the 4-byte &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt; at offset 92. The in-header database size is always valid when the database is only modified using recent versions of SQLite, versions 3.7.0 (2010-07-21) and later. If a legacy version of SQLite writes to the database, it will not know to update the in-header database size and so the in-header database size could be incorrect. But legacy versions of SQLite will also leave the version-valid-for number at offset 92 unchanged so it will not match the change-counter. Hence, invalid in-header database sizes can be detected (and ignored) by observing when the change-counter does not match the version-valid-for number.</source>
          <target state="translated">ヘッダー内のデータベースサイズは、それがゼロ以外で、オフセット24 の4バイトの&lt;a href=&quot;fileformat2#chngctr&quot;&gt;変更カウンターが&lt;/a&gt;オフセット92の4バイトの&lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-forの数値&lt;/a&gt;と完全に一致する場合にのみ、有効であると見なされます。インヘッダーデータベースSQLiteの最新バージョン、バージョン3.7.0（2010-07-21）以降を使用してデータベースが変更された場合、サイズは常に有効です。 SQLiteのレガシーバージョンがデータベースに書き込む場合、ヘッダー内のデータベースサイズを更新する必要がないため、ヘッダー内のデータベースサイズが正しくない可能性があります。ただし、SQLiteのレガシーバージョンでは、オフセット92のversion-valid-for番号も変更されないため、変更カウンターと一致しません。したがって、change-counterがversion-valid-for番号と一致しない場合を観察することで、無効なヘッダー内データベースサイズを検出（および無視）できます。</target>
        </trans-unit>
        <trans-unit id="856311d50a8fd5f75cd3339835ec40132b3ad9e1" translate="yes" xml:space="preserve">
          <source>The incremental_vacuum pragma causes up to</source>
          <target state="translated">incremental_vacuumプラグマは最大でも</target>
        </trans-unit>
        <trans-unit id="2dd53e3930b5b852ae3198064e374d5480957b02" translate="yes" xml:space="preserve">
          <source>The index is not usable at all because the left-most column of the index (column &quot;a&quot;) is not constrained. Assuming there are no other indices, the query above would result in a full table scan.</source>
          <target state="translated">インデックスの左端の列(列 &quot;a&quot;)が拘束されていないため、インデックスは全く使用できません。他にインデックスがないと仮定すると、上記のクエリはテーブルのフルスキャンになります。</target>
        </trans-unit>
        <trans-unit id="af8e63da60690ffa41a028a8c03b3a46553b1974" translate="yes" xml:space="preserve">
          <source>The index is not usable because the WHERE clause terms are connected by OR instead of AND. This query would result in a full table scan. However, if three additional indices where added that contained columns b, c, and d as their left-most columns, then the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; might apply.</source>
          <target state="translated">WHERE句の用語がANDではなくORで接続されているため、インデックスは使用できません。このクエリにより、テーブル全体がスキャンされます。ただし、列b、c、およびdを左端の列として含む3つの追加のインデックスが追加された場合、&lt;a href=&quot;#or_opt&quot;&gt;OR句の最適化&lt;/a&gt;が適用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="672cc6d4ea8af33a329ad85f582fc436091b60cb" translate="yes" xml:space="preserve">
          <source>The index of the term instance within its column. Terms are numbered in order of occurrence starting from 0.</source>
          <target state="translated">その列内の用語インスタンスのインデックス。タームは、0から始まる出現順に番号が付けられます。</target>
        </trans-unit>
        <trans-unit id="9be4bc1fc0e600b05c5d496186036ea84f9ef15d" translate="yes" xml:space="preserve">
          <source>The indexed documents are not stored within the SQLite database at all (a &quot;contentless&quot; FTS4 table), or</source>
          <target state="translated">インデックス化されたドキュメントは、SQLiteデータベース内には全く格納されていない(&quot;内容のない &quot;FTS4テーブル)、または</target>
        </trans-unit>
        <trans-unit id="e1d425e949e65fa344c6b8fb0277d12b499d6fc9" translate="yes" xml:space="preserve">
          <source>The indexed documents are stored in a database table created and managed by the user (an &quot;external content&quot; FTS4 table).</source>
          <target state="translated">インデックス化された文書は、ユーザが作成して管理するデータベーステーブル(「外部コンテンツ」FTS4テーブル)に格納される。</target>
        </trans-unit>
        <trans-unit id="4aef068b1a0d56e1caa7dcf9dfa167672f1599ff" translate="yes" xml:space="preserve">
          <source>The infix LIKE operator is implemented by calling the application-defined SQL functions &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; or &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/a&gt;.</source>
          <target state="translated">中置LIKE演算子は、アプリケーション定義のSQL関数&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（&lt;i&gt;Y&lt;/i&gt;、&lt;i&gt;X&lt;/i&gt;）&lt;/a&gt;または&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（&lt;i&gt;Y&lt;/i&gt;、&lt;i&gt;X&lt;/i&gt;、&lt;i&gt;Z&lt;/i&gt;）を&lt;/a&gt;呼び出すことによって実装されます。</target>
        </trans-unit>
        <trans-unit id="88a733d117cd4f0a7921fa6f2a987e25c2eb02d1" translate="yes" xml:space="preserve">
          <source>The information above can be recast into a table format as follows:</source>
          <target state="translated">上記の情報は、以下のように表形式に再キャストすることができます。</target>
        </trans-unit>
        <trans-unit id="7c260215b8c7aaba3e0315515668088d0bdaae79" translate="yes" xml:space="preserve">
          <source>The information accessed using this API and its companion xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNext (or xInst/xInstCount). The chief advantage of this API is that it is significantly more efficient than those alternatives when used with &quot;detail=column&quot; tables.</source>
          <target state="translated">このAPIとそれに付随するxPhraseFirstColumn()を使用してアクセスされる情報は、xPhraseFirst/xPhraseNext(またはxInst/xInstCount)を使用して取得することもできます。このAPIの主な利点は、&quot;detail=column &quot;テーブルで使用する場合、これらの代替手段よりも大幅に効率的であるということです。</target>
        </trans-unit>
        <trans-unit id="e6d1054c7b3f35c96345a991890c1e40578c9e8c" translate="yes" xml:space="preserve">
          <source>The information in the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is ephemeral and may be overwritten or deallocated as soon as the xBestIndex method returns. If the xBestIndex method needs to remember any part of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure, it should make a copy. Care must be take to store the copy in a place where it will be deallocated, such as in the idxStr field with needToFreeIdxStr set to 1.</source>
          <target state="translated">&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;構造体の情報は一時的なものであり、xBestIndexメソッドが戻るとすぐに上書きまたは割り当て解除されます。 xBestIndexメソッドが&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;構造の一部を覚えておく必要がある場合は、コピーを作成する必要があります。コピーが割り当て解除される場所（needToFreeIdxStrが1に設定されているidxStrフィールドなど）に保管するように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="32cf05e222bbae76e66c5abe0ecf2fd84a3a7c70" translate="yes" xml:space="preserve">
          <source>The information in this article applies only when SQLite is operating in &quot;rollback mode&quot;, or in other words when SQLite is not using a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;. SQLite still supports atomic commit when write-ahead logging is enabled, but it accomplishes atomic commit by a different mechanism from the one described in this article. See the &lt;a href=&quot;wal&quot;&gt;write-ahead log documentation&lt;/a&gt; for additional information on how SQLite supports atomic commit in that context.</source>
          <target state="translated">この記事の情報は、SQLiteが「ロールバックモード」で動作している場合、つまりSQLiteが&lt;a href=&quot;wal&quot;&gt;先行書き込みログ&lt;/a&gt;を使用していない場合にのみ適用されます。SQLiteは、先行書き込みロギングが有効な場合でもアトミックコミットをサポートしますが、この記事で説明するメカニズムとは異なるメカニズムによってアトミックコミットを実現します。SQLiteがそのコンテキストでアトミックコミットをサポートする方法の詳細については、&lt;a href=&quot;wal&quot;&gt;先行書き込みログのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f9342562e97e372cf7348a184a4d34dd086f3cc5" translate="yes" xml:space="preserve">
          <source>The initial &quot;INSERT&quot; keyword can be replaced by &quot;REPLACE&quot; or &quot;INSERT OR</source>
          <target state="translated">最初の &quot;INSERT &quot;キーワードは、&quot;REPLACE &quot;または &quot;INSERT OR &quot;で置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="d2a90ccaf25a62976be28829cc53054a6feb5a8b" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-16 text and sqlite3_column_bytes() or sqlite3_column_text() is called. The content must be converted to UTF-8.</source>
          <target state="translated">初期内容はUTF-16テキストで、sqlite3_column_bytes()またはsqlite3_column_text()を呼び出します。内容はUTF-8に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="f5abf60cee620000168958a8b5acfa6d74016d3a" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-8 text and sqlite3_column_bytes16() or sqlite3_column_text16() is called. The content must be converted to UTF-16.</source>
          <target state="translated">初期内容はUTF-8テキストで、sqlite3_column_bytes16()またはsqlite3_column_text16()が呼び出されます。内容をUTF-16に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="16a79a9ef866be9ddb29420482c978bd29b5a111" translate="yes" xml:space="preserve">
          <source>The initial content is a BLOB and sqlite3_column_text() or sqlite3_column_text16() is called. A zero-terminator might need to be added to the string.</source>
          <target state="translated">初期内容はBLOBで、sqlite3_column_text()またはsqlite3_column_text16()が呼び出されます。文字列にゼロターミネータを追加する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e8f78c0547aa09c0045543ed5c95b2ff19b12417" translate="yes" xml:space="preserve">
          <source>The initial implementation of NGQP chooses N=1 for simple queries, N=5 for two-way joins and N=10 for all joins with three or more tables. This formula for selecting N might change in subsequent releases.</source>
          <target state="translated">NGQPの初期実装では、単純なクエリの場合はN=1、双方向結合の場合はN=5、3つ以上のテーブルを持つすべての結合の場合はN=10を選択しています。このNの選択式は、その後のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="433c6a25716e7b035366d6fcddc3266fd3d25e85" translate="yes" xml:space="preserve">
          <source>The initial portion of the payload that does not spill to overflow pages.</source>
          <target state="translated">オーバーフローページにこぼれないペイロードの初期部分。</target>
        </trans-unit>
        <trans-unit id="a60a09b4b0f1a33259942d5b4f17c8bccd4a335d" translate="yes" xml:space="preserve">
          <source>The inner SELECT statement is implemented by instructions 1 through 10. All this code does is make an entry in the temporary table for each row of the examp2 table with a non-NULL value for the &quot;three&quot; column. The key for each temporary table entry is the &quot;three&quot; column of examp2 and the data is an empty string since it is never used.</source>
          <target state="translated">内部のSELECT文は命令1から10によって実装されています。このコードが行うのは、examp2テーブルの各行の &quot;3 &quot;列にNULLでない値を指定して一時テーブルにエントリを作成することだけです。各テンポラリテーブルのエントリのキーはexamp2の &quot;three &quot;カラムであり、データは決して使用されないので空の文字列となります。</target>
        </trans-unit>
        <trans-unit id="059bc1f5d258819deb1954aaf03c0ff2e66225d4" translate="yes" xml:space="preserve">
          <source>The input data used by a simple SELECT query is a set of</source>
          <target state="translated">単純なSELECTクエリで使用される入力データは</target>
        </trans-unit>
        <trans-unit id="6894645090ea407676b9f33e59a0dad3066f4727" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;への入力は、ゼロで終了するUTF-8文字列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="4d7419b960ffd32c455a130a0e74d0adde2f9624" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;への入力は、ネイティブバイトオーダーのゼロで終了するUTF-16文字列である必要があります。</target>
        </trans-unit>
        <trans-unit id="4b672bd7f0a1d030d51edf7b207eec2b4f3ae087" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;への入力は、ゼロで終了するUTF-8文字列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="cfd5dd711daa7423070d67fd7c844d95a0e5c24f" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;への入力は、ネイティブバイトオーダーのゼロで終了するUTF-16文字列である必要があります。</target>
        </trans-unit>
        <trans-unit id="2d24c8f818c9e23a7423d1fe6a231842fef7a551" translate="yes" xml:space="preserve">
          <source>The inputs to TH3 are test modules written in C or SQL and small configuration files that determine how to initialize SQLite. The TH3 package includes 1,444 test modules and more than 47 configurations (as of 2018-05-19). New modules and configurations can be added to customize TH3 for specialized applications. Each time TH3 is run, it reads a subset of the available test modules and configuration files to generate a custom C program that performs all of the specified tests under all specified configurations. A complete test of SQLite normally involves running TH3 multiple times to generate multiple test programs covering different aspects of SQLite's operation, then linking all test programs against a common SQLite library and running them separately on the target platform.</source>
          <target state="translated">TH3への入力は、C言語またはSQLで書かれたテストモジュールと、SQLiteの初期化方法を決定する小さな設定ファイルです。TH3パッケージには、1,444個のテストモジュールと47個以上の設定ファイルが含まれています(2018-05-19現在)。新しいモジュールや構成を追加して、特殊なアプリケーション用にTH3をカスタマイズすることができます。TH3 を実行するたびに、利用可能なテストモジュールと構成ファイルのサブセットを読み込んで、すべての指定された構成の下で指定されたすべてのテストを実行するカスタム C プログラムを生成します。SQLite の完全なテストを行うには、通常、TH3 を複数回実行して、SQLite の動作の異なる側面をカバーする複数のテストプログラムを生成し、共通の SQLite ライブラリに対してすべてのテストプログラムをリンクして、ターゲットプラットフォーム上で個別に実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="bb4e6367e51d64e49b708aca20c83e616d792f73" translate="yes" xml:space="preserve">
          <source>The inspiration for this document is &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;. Among quality standards, DO-178B seems to have the highest usefulness to paperwork ratio. Even so, the amount of documentation needed for a full-up DO-178B implementation is vast. SQLite strives to be nimble and low-ceremony, and to that end, much of the required DO-178B documentation is omitted. We retain only those parts that genuinely improve quality for a open-source software project such as SQLite.</source>
          <target state="translated">このドキュメントの発想は&lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;です。品質基準のなかで、DO-178Bは、書類業務に対する有用性の比率が最も高いようです。それでも、完全なDO-178B実装に必要なドキュメントの量は膨大です。SQLiteは機敏で控えめなものになるよう努めており、そのために必要なDO-178Bドキュメントの多くは省略されています。SQLiteなどのオープンソースソフトウェアプロジェクトの品質を本当に向上させる部分のみを保持します。</target>
        </trans-unit>
        <trans-unit id="eeb6f7cf85fc1473abd39059a6c5676d36ad32d5" translate="yes" xml:space="preserve">
          <source>The instr(X,Y) function finds the first occurrence of string Y within string X and returns the number of prior characters plus 1, or 0 if Y is nowhere found within X. Or, if X and Y are both BLOBs, then instr(X,Y) returns one more than the number bytes prior to the first occurrence of Y, or 0 if Y does not occur anywhere within X. If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs then both are interpreted as strings. If either X or Y are NULL in instr(X,Y) then the result is NULL.</source>
          <target state="translated">instr(X,Y)関数は、文字列 X の中から文字列 Y の最初の出現を見つけ、その前の文字数に 1 を加えたものを返します。また、X と Y が両方とも BLOB である場合は、 instr(X,Y)は Y の最初の出現よりも前のバイト数を 1 つ多く返し、Y が X の中のどこにも出現しない場合は 0 を返します。instr(X,Y)で X または Y のどちらかが NULL の場合、結果は NULL となります。</target>
        </trans-unit>
        <trans-unit id="a78743c67ceb66f35152669e19fad52bf271ff90" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Close&quot;&gt;Close&lt;/a&gt; closes a cursor previously opened as P1 (0, the only open cursor). If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">&lt;a href=&quot;opcode#Close&quot;&gt;Close&lt;/a&gt;命令は、以前にP1として開いたカーソル（0、唯一開いているカーソル）を閉じます。P1が現在開いていない場合、この命令は何もしません。</target>
        </trans-unit>
        <trans-unit id="e8c5c65cb041570fcd5ae40ccc7306b738bb99f4" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Commit&quot;&gt;Commit&lt;/a&gt; causes all modifications to the database that have been made since the last Transaction to actually take effect. No additional modifications are allowed until another transaction is started. The Commit instruction deletes the journal file and releases the write lock on the database. A read lock continues to be held if there are still cursors open.</source>
          <target state="translated">&lt;a href=&quot;opcode#Commit&quot;&gt;コミット&lt;/a&gt;命令により、最後のトランザクション以降に行われたデータベースへのすべての変更が実際に有効になります。別のトランザクションが開始されるまで、追加の変更は許可されません。 Commit命令は、ジャーナルファイルを削除し、データベースの書き込みロックを解放します。カーソルがまだ開いている場合、読み取りロックは引き続き保持されます。</target>
        </trans-unit>
        <trans-unit id="71d724f14f1b112c6a8977fb693b84af3a6cb813" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; causes the VDBE engine to exit immediately. All open cursors, Lists, Sorts, etc are closed automatically. P1 is the result code returned by sqlite_exec(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. The operand P2 is only used when there is an error. There is an implied &quot;Halt 0 0 0&quot; instruction at the end of every program, which the VDBE appends when it prepares a program to run.</source>
          <target state="translated">命令&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;はVDBEエンジンをすぐに終了させます。開いているカーソル、リスト、ソートなどはすべて自動的に閉じられます。 P1は、sqlite_exec（）によって返される結果コードです。通常の停止の場合、これはSQLITE_OK（0）になります。エラーの場合は、他の値になる可能性があります。オペランドP2は、エラーが発生した場合にのみ使用されます。 VDBEがプログラムを実行する準備をするときにVDBEが追加する暗黙の「Halt 0 0 0 &quot;命令がすべてのプログラムの終わりにあります。</target>
        </trans-unit>
        <trans-unit id="4a2e93cc788564162251660dae046bf0362122e8" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt; at 13 pushes onto the stack the table record number from the index. The following MoveTo pops it and moves the table cursor to that row. The next 3 instructions select the column data the same way as in the non- indexed case. The Column instructions fetch the column data and the callback function is invoked. The final Next instruction advances the index cursor, not the table cursor, to the next row, and then branches back to the start of the loop if there are any index records left.</source>
          <target state="translated">13の&lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt;命令は、インデックスからテーブルレコード番号をスタックにプッシュします。次のMoveToはそれをポップし、テーブルカーソルをその行に移動します。次の3つの命令は、インデックスなしの場合と同じ方法で列データを選択します。Column命令は列データをフェッチし、コールバック関数が呼び出されます。最後のNext命令は、テーブルカーソルではなくインデックスカーソルを次の行に進め、インデックスレコードが残っている場合は、ループの先頭に戻ります。</target>
        </trans-unit>
        <trans-unit id="89a91a29199817279a977a2ce4541fd6e7fee24a" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes its P1 operand (99) onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">命令&lt;a href=&quot;opcode#Integer&quot;&gt;Integerは&lt;/a&gt;、そのP1オペランド（99）をスタックにプッシュします。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="15f722b882a29ac5b03a20e923af0ef9dcb502b1" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes the integer value P1 (0) onto the stack. Here 0 is the number of the database to use in the following OpenWrite instruction. If P3 is not NULL then it is a string representation of the same integer. Afterwards the stack looks like this:</source>
          <target state="translated">命令&lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt;は、整数値P1（0）をスタックにプッシュします。ここで0は、次のOpenWrite命令で使用するデータベースの番号です。P3がNULLでない場合、それは同じ整数の文字列表現です。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d1df5b7ac8ac4ed32e40d9d958d1c725defad872" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; pops the top P1 elements off the stack (2 in this case) and converts them into the binary format used for storing records in a database file. (See the &lt;a href=&quot;fileformat&quot;&gt;file format&lt;/a&gt; description for details.) The new record generated by the MakeRecord instruction is pushed back onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;命令は、スタックから上位のP1要素（この場合は2）をポップし、データベースファイルにレコードを格納するために使用されるバイナリ形式に変換します。（詳細については、&lt;a href=&quot;fileformat&quot;&gt;ファイル形式の&lt;/a&gt;説明を参照してください。）MakeRecord命令によって生成された新しいレコードは、スタックにプッシュバックされます。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="21bb54c4787b5b030612c3d381e1ba9b4bb1f341" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt; creates a new integer record number for the table pointed to by cursor P1. The record number is one not currently used as a key in the table. The new record number is pushed onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">&lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt;命令は、カーソルP1が指すテーブルの新しい整数レコード番号を作成します。レコード番号は、現在テーブルでキーとして使用されていない番号です。新しいレコード番号がスタックにプッシュされます。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="213073395c8927a399e8bb754b1febc0fe16eb95" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; opens a new read/write cursor with handle P1 (0 in this case) on table &quot;examp&quot;, whose root page is P2 (3, in this database file). Cursor handles can be any non-negative integer. But the VDBE allocates cursors in an array with the size of the array being one more than the largest cursor. So to conserve memory, it is best to use handles beginning with zero and working upward consecutively. Here P3 (&quot;examp&quot;) is the name of the table being opened, but this is unused, and only generated to make the code easier to read. This instruction pops the database number to use (0, the main database) from the top of the stack, so afterwards the stack is empty again.</source>
          <target state="translated">&lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;命令は、ルートページがP2（このデータベースファイルでは3）であるテーブル &quot;examp&quot;のハンドルP1（この場合は0）で新しい読み取り/書き込みカーソルを開きます。カーソルハンドルには、負でない整数を使用できます。ただし、VDBEは、配列のサイズが最大のカーソルよりも1つ大きい配列にカーソルを割り当てます。したがって、メモリを節約するために、ゼロから始まり、上に向かって連続的に処理するハンドルを使用するのが最善です。ここでP3（ &quot;examp&quot;）は開かれているテーブルの名前ですが、これは未使用であり、コードを読みやすくするためにのみ生成されます。この命令は、使用するデータベース番号（0、メインデータベース）をスタックの一番上からポップするため、その後スタックは再び空になります。</target>
        </trans-unit>
        <trans-unit id="98bb30ff1b874474319c63eb890c40ec0fb09de2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt; uses the top 2 stack entries to write an entry into the table pointed to by cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The record data is the top stack entry, and the key is the next entry down. The stack is popped twice by this instruction. Because operand P2 is 1 the row change count is incremented and the rowid is stored for subsequent return by the sqlite_last_insert_rowid() function. If P2 is 0 the row change count is unmodified. This instruction is where the insert actually occurs.</source>
          <target state="translated">&lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt;命令は、上位2つのスタックエントリを使用して、カーソルP1が指すテーブルにエントリを書き込みます。エントリが存在しない場合、または既存のエントリのデータが上書きされた場合は、新しいエントリが作成されます。レコードデータは一番上のスタックエントリで、キーは次のエントリです。この命令により、スタックが2回ポップされます。オペランドP2が1であるため、行変更カウントがインクリメントされ、ROWIDはsqlite_last_insert_rowid（）関数による後続の戻りのために格納されます。P2が0の場合、行変更カウントは変更されません。この命令は、実際に挿入が行われる場所です。</target>
        </trans-unit>
        <trans-unit id="0b320ec6225176f371f5c1f951d40976365b4443" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; pushes its P3 operand onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">命令&lt;a href=&quot;opcode#String&quot;&gt;ストリングは&lt;/a&gt;、そのP3オペランドをスタックにプッシュします。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d914ce420de942b21ca6d5eb303d1b4bdd87f483" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; begins a transaction. The transaction ends when a Commit or Rollback opcode is encountered. P1 is the index of the database file on which the transaction is started. Index 0 is the main database file. A write lock is obtained on the database file when a transaction is started. No other process can read or write the file while the transaction is underway. Starting a transaction also creates a rollback journal. A transaction must be started before any changes can be made to the database.</source>
          <target state="translated">命令&lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt;はトランザクションを開始します。トランザクションは、コミットまたはロールバックのオペコードが検出されると終了します。 P1は、トランザクションが開始されるデータベースファイルのインデックスです。インデックス0はメインデータベースファイルです。トランザクションが開始されると、データベースファイルの書き込みロックが取得されます。トランザクションの進行中は、他のプロセスがファイルを読み書きすることはできません。トランザクションを開始すると、ロールバックジャーナルも作成されます。データベースに変更を加える前に、トランザクションを開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="766fac627c726045a9f4c4dcb9828d544fcadbb2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt; checks cookie 0 (the database schema version) to make sure it is equal to P2 (the value obtained when the database schema was last read). P1 is the database number (0 for the main database). This is done to make sure the database schema hasn't been changed by another thread, in which case it has to be reread.</source>
          <target state="translated">&lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt;命令は、cookie 0（データベーススキーマのバージョン）をチェックして、それがP2（データベーススキーマが最後に読み取られたときに取得された値）と等しいことを確認します。 P1はデータベース番号です（メインデータベースの場合は0）。これは、データベーススキーマが別のスレッドによって変更されていないことを確認するために行われます。この場合、再度読み取る必要があります。</target>
        </trans-unit>
        <trans-unit id="1541b9a811a194a4f9e80a336055e479ef3f480e" translate="yes" xml:space="preserve">
          <source>The instruction at address 9 implements the branching part of the loop. Together with the Rewind at address 5 it forms the loop logic. This is a key concept that you should pay close attention to. The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction advances the cursor P1 to the next record. If the cursor advance was successful, then jump immediately to P2 (6, the beginning of the loop body). If the cursor was at the end, then fall through to the following instruction, which ends the loop.</source>
          <target state="translated">アドレス9の命令は、ループの分岐部分を実装します。アドレス5の巻き戻しとともに、ループロジックを形成します。これは、注意が必要な重要な概念です。&lt;a href=&quot;opcode#Next&quot;&gt;次&lt;/a&gt;の命令は、次のレコードにカーソルP1を進めます。カーソルの移動が成功した場合は、すぐにP2（6、ループ本体の先頭）にジャンプします。カーソルが最後にあった場合は、ループを終了する次の命令に進みます。</target>
        </trans-unit>
        <trans-unit id="14da6ae11560ca2b2c31ae75e094431766a4621e" translate="yes" xml:space="preserve">
          <source>The instruction at the address in register P1 is a &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to the P2 parameter of that &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. After the jump, register P1 becomes undefined.</source>
          <target state="translated">レジスタP1のアドレスの命令は&lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;です。その&lt;a href=&quot;opcode#Yield&quot;&gt;Yieldの&lt;/a&gt; P2パラメータに&lt;a href=&quot;opcode#Jump&quot;&gt;ジャンプ&lt;/a&gt;します。ジャンプ後、レジスタP1は不定になります。</target>
        </trans-unit>
        <trans-unit id="cd201e480371afb73e8686f10704843996fccd91" translate="yes" xml:space="preserve">
          <source>The instructions 6 through 8 form the body of the loop that will execute once for each record in the database file. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; instructions at addresses 6 and 7 each take the P2-th column from the P1-th cursor and push it onto the stack. In this example, the first Column instruction is pushing the value for the column &quot;one&quot; onto the stack and the second Column instruction is pushing the value for column &quot;two&quot;. The &lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt; instruction at address 8 invokes the callback() function. The P1 operand to Callback becomes the value for &lt;b&gt;nColumn&lt;/b&gt;. The Callback instruction pops P1 values from the stack and uses them to fill the &lt;b&gt;azData[]&lt;/b&gt; array.</source>
          <target state="translated">命令6〜8は、データベースファイルの各レコードに対して1回実行されるループの本体を形成します。アドレス6と7 の&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;命令は、それぞれP1番目のカーソルからP2番目の列を取り出し、それをスタックにプッシュします。この例では、最初の列命令が列「1」の値をスタックにプッシュし、2番目の列命令が列「2」の値をプッシュしています。アドレス8 の&lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt;命令は、callback（）関数を呼び出します。 CallbackのP1オペランドが&lt;b&gt;nColumn&lt;/b&gt;の値に&lt;b&gt;なり&lt;/b&gt;ます。コールバック命令は、スタックからP1値をポップし、それらを使用して&lt;b&gt;azData []&lt;/b&gt;配列を埋めます。</target>
        </trans-unit>
        <trans-unit id="c46964020db9e221e22ce0203153f52f7c4afbe0" translate="yes" xml:space="preserve">
          <source>The integer values returned by two invocations of &quot;PRAGMA data_version&quot; from the same connection will be different if changes were committed to the database by any other connection in the interim. The &quot;PRAGMA data_version&quot; value is unchanged for commits made on the same database connection. The behavior of &quot;PRAGMA data_version&quot; is the same for all database connections, including database connections in separate processes and &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; database connections.</source>
          <target state="translated">同じ接続から &quot;PRAGMA data_version&quot;を2回呼び出して返された整数値は、その間に他の接続によって変更がデータベースにコミットされた場合は異なります。 「PRAGMA data_version」の値は、同じデータベース接続で行われたコミットでは変更されません。 「PRAGMA data_version」の動作は、個別のプロセスでのデータベース接続や&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;データベース接続を含む、すべてのデータベース接続で同じです。</target>
        </trans-unit>
        <trans-unit id="4e05f2b57d17a355c0ea1387908101e6bd52b31e" translate="yes" xml:space="preserve">
          <source>The integer values to xLock() and xUnlock() are one of</source>
          <target state="translated">xLock()および xUnlock()への整数値は、次のいずれかの値です。</target>
        </trans-unit>
        <trans-unit id="3a9652af526f0c1e8a87ab92c4d5d7f777a76ac5" translate="yes" xml:space="preserve">
          <source>The integrity-check command is invoked by inserting the text value 'integrity-check' into the special column with the same name as the FTS5 table. For example:</source>
          <target state="translated">integrity-checkコマンドは、FTS5テーブルと同じ名前の特別な列にテキスト値'integrity-check'を挿入することで起動されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8b9cbbc162055ec87304da9b44deb92f428d9750" translate="yes" xml:space="preserve">
          <source>The intended use of this pragma is only for testing and validation of SQLite. This pragma is subject to change without notice and is not recommended for use by application programs.</source>
          <target state="translated">このプラグマの使用目的は、SQLiteのテストと検証のみです。このプラグマは予告なく変更されることがあり、アプリケーションプログラムでの使用は推奨されません。</target>
        </trans-unit>
        <trans-unit id="ff65b14ad46243e5d5f2ba9708d0bfaa67d238c4" translate="yes" xml:space="preserve">
          <source>The intent of the developers is to support SQLite through the year 2050.</source>
          <target state="translated">開発者の意図は、2050年までSQLiteをサポートすることです。</target>
        </trans-unit>
        <trans-unit id="b8c5c15fb8411770e1f2302c0a93c745cb58106c" translate="yes" xml:space="preserve">
          <source>The intent of these enhancements to the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands is to ensure that they cannot be used to create a database that contains foreign key violations, at least while foreign key constraints are enabled. There is one exception to this rule though. If a parent key is not subject to a PRIMARY KEY or UNIQUE constraint created as part of the parent table definition, but is subject to a UNIQUE constraint by virtue of an index created using the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command, then the child table may be populated without causing a &quot;foreign key mismatch&quot; error. If the UNIQUE index is dropped from the database schema, then the parent table itself is dropped, no error will be reported. However the database may be left in a state where the child table of the foreign key constraint contains rows that do not refer to any parent table row. This case can be avoided if all parent keys in the database schema are constrained by PRIMARY KEY or UNIQUE constraints added as part of the parent table definition, not by external UNIQUE indexes.</source>
          <target state="translated">&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;および&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;コマンドに対するこれらの機能強化の目的は、少なくとも外部キー制約が有効になっている間は、これらを使用して外部キー違反を含むデータベースを作成できないようにすることです。ただし、このルールには1つの例外があります。親キーが、親テーブル定義の一部として作成されたPRIMARY KEYまたはUNIQUE制約の対象ではないが、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;を使用して作成されたインデックスによってUNIQUE制約の対象である場合コマンドを実行すると、「外部キーの不一致」エラーを発生させることなく、子テーブルにデータが入力されます。UNIQUEインデックスがデータベーススキーマから削除されると、親テーブル自体も削除され、エラーは報告されません。ただし、データベースは、外部キー制約の子テーブルに、親テーブルの行を参照しない行が含まれている状態のままになる場合があります。このケースは、データベーススキーマのすべての親キーが、外部UNIQUEインデックスではなく、親テーブル定義の一部として追加されたPRIMARY KEYまたはUNIQUE制約によって制約されている場合に回避できます。</target>
        </trans-unit>
        <trans-unit id="f25fb84e751737880254b9bbae4d5bcd681d4573" translate="yes" xml:space="preserve">
          <source>The interface between the VDBE and B-Tree layer is enhanced such that the VDBE provides hints to the B-Tree layer letting the B-Tree layer know when it is safe to use hashing instead of B-Trees for transient tables.</source>
          <target state="translated">VDBE と B-Tree 層の間のインタフェースが強化され、VDBE が B-Tree 層にヒントを提供し、B-Tree 層が過渡的なテーブルに B-Tree の代わりにハッシュを使用しても安全なときを知らせるようになりました。</target>
        </trans-unit>
        <trans-unit id="8f6df7d6e95fb6e2e2d0cc834a6496c76dd46264" translate="yes" xml:space="preserve">
          <source>The interface to the B-tree subsystem and the rest of the SQLite library is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;btree.h&lt;/a&gt;.</source>
          <target state="translated">Bツリーサブシステムと残りのSQLiteライブラリへのインターフェイスは、ヘッダーファイル&lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;btree.h&lt;/a&gt;によって定義されます。</target>
        </trans-unit>
        <trans-unit id="b91796ad2d511be2d8979f83ba1c6fb0431a4019" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of single tcl command named &lt;b&gt;sqlite3&lt;/b&gt; Because there is only this one command, the interface is not placed in a separate namespace.</source>
          <target state="translated">SQLiteライブラリへのインターフェイスは、&lt;b&gt;sqlite3&lt;/b&gt;という名前の単一のtclコマンドで構成されています。このコマンドは1つしかないため、インターフェイスは別の名前空間に配置されません。</target>
        </trans-unit>
        <trans-unit id="3c849c0d323b0ad6135a0bb1621f8f7a986a9fa1" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of three core functions, one opaque data structure, and some constants used as return values. The core interface is as follows:</source>
          <target state="translated">SQLite ライブラリへのインターフェイスは、3 つのコア関数、1 つの不透明なデータ構造、戻り値として使用されるいくつかの定数で構成されています。コアとなるインターフェイスは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="da5910db62046423c913e2518dadca7a36c2bb7d" translate="yes" xml:space="preserve">
          <source>The interface used by the implementation of the aforementioned functions to retrieve the collation sequence set by this opcode is not available publicly. Only built-in functions have access to this feature.</source>
          <target state="translated">このオペコードによって設定された照合順序を取得するために前記関数の実装によって使用されるインタフェースは公開されていない。組込み関数のみがこの機能にアクセスできる。</target>
        </trans-unit>
        <trans-unit id="82c461e3315f13aa8457935ffce58f8ac7ef7cd3" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="translated">組み込みの日付/時刻関数など、入力に応じて時々決定的または非決定的である関数を構築するために必要なインターフェースは公開されていません。一般的な&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は、常に確定的であるか、常に非確定的でなければなりません。</target>
        </trans-unit>
        <trans-unit id="15015bc60e3376a39ca9d7ebc27d602beffae1d0" translate="yes" xml:space="preserve">
          <source>The internal Mem object stores the value for a single register. The abstract &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object that is exposed in the API is really just a Mem object or register.</source>
          <target state="translated">内部のMemオブジェクトは、単一のレジスタの値を格納します。APIで公開される抽象的な&lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトは、実際には単なるMemオブジェクトまたはレジスタです。</target>
        </trans-unit>
        <trans-unit id="e1059fa5a511cb460ad6acfc6dbdaaa7898a9f5d" translate="yes" xml:space="preserve">
          <source>The internal organization of the SQLite library can be viewed as the stack of modules shown to the right. The Tokenizer, Parser, and Code Generator components are used to process SQL statements and convert them into executable programs in a virtual machine language or byte code. Roughly speaking, these top three layers implement &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The byte code generated by the top three layers is a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;. The Virtual Machine module is responsible for running the SQL statement byte code. The B-Tree module organizes a database file into multiple key/value stores with ordered keys and logarithmic performance. The Pager module is responsible for loading pages of the database file into memory, for implementing and controlling transactions, and for creating and maintaining the journal files that prevent database corruption following a crash or power failure. The OS Interface is a thin abstraction that provides a common set of routines for adapting SQLite to run on different operating systems. Roughly speaking, the bottom four layers implement &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">SQLiteライブラリの内部構成は、右側に示されているモジュールのスタックと見なすことができます。 Tokenizer、Parser、およびCode Generatorコンポーネントは、SQLステートメントを処理し、それらを仮想マシン言語またはバイトコードの実行可能プログラムに変換するために使用されます。おおまかに言って、これらの上位3層は&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）を&lt;/a&gt;実装しています。上位3つの層によって生成されたバイトコードは、&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメントです。&lt;/a&gt;。仮想マシンモジュールは、SQLステートメントのバイトコードを実行します。Bツリーモジュールは、データベースファイルを複数のキー/値ストアに編成し、順序付けられたキーと対数パフォーマンスを備えています。Pagerモジュールは、データベースファイルのページのメモリへのロード、トランザクションの実装と制御、およびクラッシュや停電後のデータベースの破損を防ぐジャーナルファイルの作成と維持を担当します。OSインターフェイスは、SQLiteをさまざまなオペレーティングシステムで実行するように適合させるためのルーチンの共通セットを提供する、薄い抽象概念です。おおまかに言って、下の4つのレイヤーは&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）を&lt;/a&gt;実装しています。</target>
        </trans-unit>
        <trans-unit id="b82fe06906efdf8da65bc9a3b09aabf0c14e629e" translate="yes" xml:space="preserve">
          <source>The internet is an increasingly hostile place. These day, developers should assume that attackers will find a way to execute arbitrary SQL in an application. Applications should be designed to prevent the execution of arbitrary SQL from escalating into a more severe exploit.</source>
          <target state="translated">インターネットはますます敵対的な場所となっています。今日、開発者は、攻撃者がアプリケーションで任意の SQL を実行する方法を見つけることを想定しなければなりません。アプリケーションは、任意の SQL の実行がより深刻な悪用へとエスカレートするのを防ぐように設計されなければなりません。</target>
        </trans-unit>
        <trans-unit id="541368df6be3b3211d485998b29f10dd5bcba535" translate="yes" xml:space="preserve">
          <source>The interpretation of the final column, if it is present, is &lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">最終列が存在する場合の解釈&lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;について&lt;/a&gt;は、ここで説明します。</target>
        </trans-unit>
        <trans-unit id="ecf9411adae8ae3787bf4274e751f3717d6110f0" translate="yes" xml:space="preserve">
          <source>The ioctl on Mac OS X to control syncing to disk is F_FULLFSYNC, not F_FULLSYNC. The previous release had it wrong.</source>
          <target state="translated">Mac OS X でディスクへの同期を制御するための ioctl は F_FULLSYNC ではなく F_FULLFSYNC です。以前のリリースでは間違っていました。</target>
        </trans-unit>
        <trans-unit id="d9c0a5f06c6830c793bad013d5441e96d45f8af0" translate="yes" xml:space="preserve">
          <source>The job of the eval method is to execute the SQL statement or statements given in the second argument. For example, to create a new table in a database, you can do this:</source>
          <target state="translated">evalメソッドの仕事は、第2引数で与えられたSQL文またはステートメントを実行することです。例えば、データベースに新しいテーブルを作成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="ce55e90a07de980cc86c5f2dfac419a865729e47" translate="yes" xml:space="preserve">
          <source>The job of this method is to construct the new virtual table object (an &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object) and return a pointer to it in *ppVTab.</source>
          <target state="translated">このメソッドの仕事は、新しい仮想テーブルオブジェクト（&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;オブジェクト）を作成し、* ppVTabでそのオブジェクトへのポインターを返すことです。</target>
        </trans-unit>
        <trans-unit id="82b29f2835b0336ce594d7095e779f9ce1307885" translate="yes" xml:space="preserve">
          <source>The journal header is non-zero and well-formed, and</source>
          <target state="translated">ジャーナルヘッダはゼロではなく、整形されています。</target>
        </trans-unit>
        <trans-unit id="3978774f2c0624ee0736d9f40af64bca3b94a2e0" translate="yes" xml:space="preserve">
          <source>The journal tests are an additional double-check over and above the crash tests to make sure that SQLite transactions will be atomic across system crashes and power failures.</source>
          <target state="translated">ジャーナルテストは、システムのクラッシュや停電時に SQLite トランザクションがアトミックになることを確認するための、クラッシュテスト以上の追加のダブルチェックです。</target>
        </trans-unit>
        <trans-unit id="eadea62ca220c75cf3d8b7ee7d22ba8de7aa3934" translate="yes" xml:space="preserve">
          <source>The journal_mode pragma returns a string which is the new journal mode. On success, the pragma will return the string &quot;&lt;code&gt;wal&lt;/code&gt;&quot;. If the conversion to WAL could not be completed (for example, if the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; does not support the necessary shared-memory primitives) then the journaling mode will be unchanged and the string returned from the primitive will be the prior journaling mode (for example &quot;&lt;code&gt;delete&lt;/code&gt;&quot;).</source>
          <target state="translated">journal_modeプラグマは、新しいジャーナルモードである文字列を返します。成功すると、プラグマは文字列「 &lt;code&gt;wal&lt;/code&gt; 」を返します。WALへの変換を完了できなかった場合（たとえば、&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;が必要な共有メモリプリミティブをサポートしていない場合）、ジャーナリングモードは変更されず、プリミティブから返された文字列は以前のジャーナリングモードになります（たとえば「「」を &lt;code&gt;delete&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="cf12bc7373958f09d761ed0f9bf5075e87444a0e" translate="yes" xml:space="preserve">
          <source>The journal_size_limit pragma may be used to limit the size of rollback-journal and WAL files left in the file-system after transactions or checkpoints. Each time a transaction is committed or a WAL file resets, SQLite compares the size of the rollback journal file or WAL file left in the file-system to the size limit set by this pragma and if the journal or WAL file is larger it is truncated to the limit.</source>
          <target state="translated">journal_size_limit pragma を使用して、トランザクションやチェックポイントの後にファイルシステムに残されたロールバックジャーナルファイルや WAL ファイルのサイズを制限することができます。トランザクションがコミットされたり、WAL ファイルがリセットされたりするたびに、SQLite はファイルシステムに残っているロールバックジャーナルファイルや WAL ファイルのサイズをこのプラグマで設定されたサイズ制限値と比較し、ジャーナルファイルや WAL ファイルの方が大きければ制限値まで切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="e4ee7815366ce998637e6c73fab93997f9ad3bf9" translate="yes" xml:space="preserve">
          <source>The json(X) function verifies that its argument X is a valid JSON string and returns a minified version of that JSON string (with all unnecessary whitespace removed). If X is not a well-formed JSON string, then this routine throws an error.</source>
          <target state="translated">json(X)関数は、引数 X が有効な JSON 文字列であることを検証し、その JSON 文字列の最小化されたバージョンを返します (不要な空白はすべて削除されています)。X が整形された JSON 文字列でない場合、このルーチンはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="b38a8f8844d02f721e88e8305af9dc835b4312f1" translate="yes" xml:space="preserve">
          <source>The json1 extension (currently) stores JSON as ordinary text.</source>
          <target state="translated">json1 拡張機能(現在)は、JSON を普通のテキストとして保存します。</target>
        </trans-unit>
        <trans-unit id="600cff3bfb9b2a0fb597c7fc0f7fa3f65076ca7b" translate="yes" xml:space="preserve">
          <source>The json1 extension does not (currently) support a binary encoding of JSON. Experiments have been unable to find a binary encoding that is significantly smaller or faster than a plain text encoding. (The present implementation parses JSON text at over 1 GB/s.) All json1 functions currently throw an error if any of their arguments are BLOBs because BLOBs are reserved for a future enhancement in which BLOBs will store the binary encoding for JSON.</source>
          <target state="translated">json1 拡張モジュールは (現在のところ)JSON のバイナリエンコーディングをサポートしていません。実験では、プレインテキストのエンコーディングよりも著しく小さいか高速なバイナリエンコーディングを見つけることができませんでした。(現在の実装では、1GB/s以上の速度でJSONテキストを解析します。)すべてのjson1関数は現在、引数のいずれかがBLOBである場合にエラーをスローしますが、これはBLOBがJSONのバイナリエンコーディングを保存する将来の拡張機能のために予約されているからです。</target>
        </trans-unit>
        <trans-unit id="50447979a47d38485f569438ae4849e4fe11a47d" translate="yes" xml:space="preserve">
          <source>The json1 extension uses the &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interfaces that were introduced with SQLite version 3.9.0 (2015-10-14) The json1 extension will not work in earlier versions of SQLite.</source>
          <target state="translated">json1拡張機能は、SQLiteバージョン3.9.0（2015-10-14）で導入された&lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;および&lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;インターフェースを使用します。json1拡張機能は、以前のバージョンのSQLiteでは機能しません。</target>
        </trans-unit>
        <trans-unit id="96336d37aaa994d4a790a5daf6a1eabf939e9f47" translate="yes" xml:space="preserve">
          <source>The json1 source code is included with the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, though it is disabled by default. Add the &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; compile-time option to enable the json1 extension that is built into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The standard makefiles include -DSQLITE_ENABLE_JSON1 when building the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and some of the test utilities so this extension is normally available in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">json1ソースコードはSQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamationに&lt;/a&gt;含まれていますが、デフォルトでは無効になっています。&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt;コンパイル時オプションを追加して、&lt;a href=&quot;amalgamation&quot;&gt;統合に&lt;/a&gt;組み込まれているjson1拡張機能を有効にします。&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;と一部のテストユーティリティをビルドする場合、標準のメイクファイルには-DSQLITE_ENABLE_JSON1が含まれているため、この拡張機能は通常、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルで&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="bb08cc12ccf8da2d3e2af52ece257a447253b7e8" translate="yes" xml:space="preserve">
          <source>The json_array() SQL function accepts zero or more arguments and returns a well-formed JSON array that is composed from those arguments. If any argument to json_array() is a BLOB then an error is thrown.</source>
          <target state="translated">json_array()SQL 関数は、0 個以上の引数を受け取り、それらの引数から構成される整形された JSON 配列を返します。json_array()への引数のいずれかが BLOB である場合は、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="9521182f315a0d302eb912198a80302f20c295c7" translate="yes" xml:space="preserve">
          <source>The json_array_length(X) function returns the number of elements in the JSON array X, or 0 if X is some kind of JSON value other than an array. The json_array_length(X,P) locates the array at path P within X and returns the length of that array, or 0 if path P locates an element or X other than a JSON array, and NULL if path P does not locate any element of X. Errors are thrown if either X is not well-formed JSON or if P is not a well-formed path.</source>
          <target state="translated">json_array_length(X)関数は、JSON配列Xの要素数を返し、Xが配列以外のJSON値の場合は0を返します。json_array_length(X,P)は X の中のパス P で配列を探し、その配列の長さを返します。パス P が JSON 配列以外の要素や X を見つけた場合は 0、パス P が X の要素を見つけなかった場合は NULL を返します。</target>
        </trans-unit>
        <trans-unit id="a38155ffebbf6577ab0909bd9445bf04a40481a5" translate="yes" xml:space="preserve">
          <source>The json_each(X) and json_tree(X) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; walk the JSON value provided as their first argument and return one row for each element. The json_each(X) function only walks the immediate children of the top-level array or object or or just the top-level element itself if the top-level element is a primitive value. The json_tree(X) function recursively walks through the JSON substructure starting with the top-level element.</source>
          <target state="translated">json_each（X）およびjson_tree（X）&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;は、最初の引数として提供されたJSON値をたどり、各要素に対して1行を返します。json_each（X）関数は、最上位の配列またはオブジェクトの直接の子、または最上位の要素がプリミティブ値の場合は最上位の要素自体のみをウォークします。json_tree（X）関数は、最上位要素から始まるJSONサブ構造を再帰的にウォークスルーします。</target>
        </trans-unit>
        <trans-unit id="41fff21b05289cb2b0be52b887077b0fcae3db31" translate="yes" xml:space="preserve">
          <source>The json_each(X,P) and json_tree(X,P) functions work just like their one-argument counterparts except that they treat the element identified by path P as the top-level element.</source>
          <target state="translated">json_each(X,P)と json_tree(X,P)関数は、パス P で識別される要素をトップレベルの要素として扱うという点を除いては、1引数の場合と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="c2ff80179397d0e306699ce5e6f1d0c9aff0af74" translate="yes" xml:space="preserve">
          <source>The json_extract(X,P1,P2,...) extracts and returns one or more values from the well-formed JSON at X. If only a single path P1 is provided, then the SQL datatype of the result is NULL for a JSON null, INTEGER or REAL for a JSON numeric value, an INTEGER zero for a JSON false value, an INTEGER one for a JSON true value, the dequoted text for a JSON string value, and a text representation for JSON object and array values. If there are multiple path arguments (P1, P2, and so forth) then this routine returns SQLite text which is a well-formed JSON array holding the various values.</source>
          <target state="translated">json_extract(X,P1,P2,...)は、Xの整形されたJSONから1つ以上の値を抽出して返します。単一のパスP1のみが提供されている場合、結果のSQLデータ型は、JSON NULLの場合はNULL、JSON数値の場合はINTEGERまたはREAL、JSON偽値の場合はINTEGER 0、JSON真値の場合はINTEGER 1、JSON文字列値の場合は引用符で囲まれたテキスト、JSONオブジェクトおよび配列値の場合はテキスト表現となります。複数のパス引数(P1、P2など)がある場合、このルーチンは様々な値を保持する整形されたJSON配列であるSQLiteテキストを返します。</target>
        </trans-unit>
        <trans-unit id="0f1627c2753898c7b2ebba7d223fce4a18da0c11" translate="yes" xml:space="preserve">
          <source>The json_group_array(X) function is an &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate SQL function&lt;/a&gt; that returns a JSON array comprised of all X values in the aggregation. Similarly, the json_group_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation.</source>
          <target state="translated">json_group_array（X）関数は、&lt;a href=&quot;lang_aggfunc&quot;&gt;集計&lt;/a&gt;のすべてのX値で構成されるJSON配列を返す集計SQL関数です。同様に、json_group_object（NAME、VALUE）関数は、集計内のすべてのNAME / VALUEペアで構成されるJSONオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="08b54ec339ea85bd242a6d5ab159f649d0636c35" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace(), and json_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path.</source>
          <target state="translated">json_insert()、json_replace()、およびjson_set()関数は常に奇数の引数を取ります。最初の引数は常に編集する元のJSONです。それ以降の引数はペアになっていて、それぞれのペアの最初の要素がパスで、2番目の要素がそのパスに挿入、置換、設定する値となります。</target>
        </trans-unit>
        <trans-unit id="cc677da89c2d6a3534f49f58dca0325fe7275ac0" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace, and json_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.</source>
          <target state="translated">json_insert()、json_replace、および json_set()関数はすべて、最初の引数として単一の JSON 値を受け取り、その後に 0 個以上のパスと値のペアの引数をとり、入力 JSON をパスと値のペアで更新することで形成される新しい JSON 文字列を返します。これらの関数の違いは、新しい値を作成したり既存の値を上書きしたりする方法だけです。</target>
        </trans-unit>
        <trans-unit id="a89fe09131a222458243e59c86a47b9418f5cefc" translate="yes" xml:space="preserve">
          <source>The json_object() SQL function accepts zero or more pairs of arguments and returns a well-formed JSON object that is composed from those arguments. The first argument of each pair is the label and the second argument of each pair is the value. If any argument to json_object() is a BLOB then an error is thrown.</source>
          <target state="translated">json_object()SQL 関数は、0 個以上の引数のペアを受け取り、それらの引数から構成される整形された JSON オブジェクトを返します。各ペアの第一引数はラベルで、各ペアの第二引数は値です。json_object()への引数のいずれかが BLOB である場合は、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="2288fffe16f420052bb17e5c8958c3ccdbc841f2" translate="yes" xml:space="preserve">
          <source>The json_object() function currently allows duplicate labels without complaint, though this might change in a future enhancement.</source>
          <target state="translated">json_object()関数は現在のところ文句なしにラベルの重複を許可していますが、これは将来の拡張機能で変更されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5e496b884466eb1ac12c106e9502f3cd98163883" translate="yes" xml:space="preserve">
          <source>The json_patch(T,P) SQL function runs the &lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch algorithm to apply patch P against input T. The patched copy of T is returned.</source>
          <target state="translated">json_patch（T、P）SQL関数は&lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatchアルゴリズムを実行して、入力Tに対してパッチPを適用します。Tのパッチされたコピーが返されます。</target>
        </trans-unit>
        <trans-unit id="d843d41461d41ce71296d2cc16a75e0d0ddb050b" translate="yes" xml:space="preserve">
          <source>The json_quote(X) function converts the SQL value X (a number or a string) into its corresponding JSON representation.</source>
          <target state="translated">json_quote(X)関数は、SQL 値 X (数値または文字列)を対応する JSON 表現に変換します。</target>
        </trans-unit>
        <trans-unit id="076810db69b99bc12f8c66592e6373c496370f8e" translate="yes" xml:space="preserve">
          <source>The json_remove() function throws an error if the first argument is not well-formed JSON or if any later argument is not a well-formed path, or if any argument is a BLOB.</source>
          <target state="translated">json_remove()関数は、最初の引数が整形JSONではない場合、または後の引数が整形パスではない場合、または引数のいずれかがBLOBである場合にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="07c228732927cc33b2fd2172e7d852ff75280285" translate="yes" xml:space="preserve">
          <source>The json_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json_remove(X,P,...) function returns a new JSON value that is the X with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored.</source>
          <target state="translated">json_remove(X,P,...)関数は、最初の引数として単一の JSON 値を受け取り、その後に 0 個以上のパス引数が続きます。json_remove(X,P,...)関数は、パス引数によって識別されるすべての要素が削除された X である新しい JSON 値を返します。X で見つからない要素を選択するパスは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="dc2a43381f4cc4dcc4e70977bde02a9d9d1a46e8" translate="yes" xml:space="preserve">
          <source>The json_type() function throws an error if any of its arguments are not well-formed or is a BLOB.</source>
          <target state="translated">json_type()関数は、引数のいずれかが整形されていないか、または BLOB である場合にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="4607298214330613e115639247f1a2af460f4cfe" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is on of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="translated">json_type(X)関数はXの一番外側の要素の &quot;型 &quot;を返し、json_type(X,P)関数はパスPで選択されたXの要素の &quot;型 &quot;を返します。null'、'true'、'false'、'integer'、'real'、'text'、'array'、または'object'。json_type(X,P)のパス P が X に存在しない要素を選択した場合、この関数は NULL を返します。</target>
        </trans-unit>
        <trans-unit id="98bb00412965806c0f2fa0e24dcf65a44105fd64" translate="yes" xml:space="preserve">
          <source>The json_valid(X) function return 1 if the argument X is well-formed JSON and return 0 if the argument X is not well-formed JSON.</source>
          <target state="translated">json_valid(X)関数は、引数Xが整形JSONであれば1を返し、引数Xが整形JSONでなければ0を返します。</target>
        </trans-unit>
        <trans-unit id="b554cbe69a3700d4f56fb5609be0488decea2e7b" translate="yes" xml:space="preserve">
          <source>The key element of a</source>
          <target state="translated">の重要な要素である</target>
        </trans-unit>
        <trans-unit id="1f79347fd256f18500712ca620e7ffb89d509d9e" translate="yes" xml:space="preserve">
          <source>The key point is that SQLite is very forgiving of the type of data that you put into the database. For example, if a column has a datatype of &quot;INTEGER&quot; and the application inserts a text string into that column, SQLite will first try to convert the text string into an integer, just like every other SQL database engine. Thus, if one inserts &lt;b&gt;'1234'&lt;/b&gt; into an INTEGER column, that value is converted into an integer 1234 and stored. But, if you insert a non-numeric string like &lt;b&gt;'wxyz'&lt;/b&gt; into an INTEGER column, unlike other SQL databases, SQLite does not throw an error. Instead, SQLite stores the actual string value in the column.</source>
          <target state="translated">重要な点は、SQLiteはデータベースに入力するデータのタイプを非常に許容できるということです。たとえば、列のデータ型が「INTEGER」であり、アプリケーションがその列にテキスト文字列を挿入すると、SQLiteは他のすべてのSQLデータベースエンジンと同様に、まずテキスト文字列を整数に変換しようとします。したがって、&lt;b&gt;「1234」&lt;/b&gt;をINTEGER列に挿入すると、その値は整数1234に変換されて格納されます。ただし、他のSQLデータベースとは異なり、&lt;b&gt;'wxyz'&lt;/b&gt;など&lt;b&gt;の&lt;/b&gt;非数値文字列をINTEGER列に挿入しても、SQLiteはエラーをスローしません。代わりに、SQLiteは実際の文字列値を列に格納します。</target>
        </trans-unit>
        <trans-unit id="3e290f56c0ef256cb5bbb18b2ba0fb09ea68db61" translate="yes" xml:space="preserve">
          <source>The key point is this: Building the CLI consists of compiling together two C-language files. The &lt;b&gt;shell.c&lt;/b&gt; file contains the definition of the entry point and the user input loop and the SQLite amalgamation &lt;b&gt;sqlite3.c&lt;/b&gt; contains the complete implementation of the SQLite library.</source>
          <target state="translated">重要なポイントは次のとおりです。CLIの構築は、2つのC言語ファイルを一緒にコンパイルすることで構成されます。&lt;b&gt;shell.cの&lt;/b&gt;ファイルには、エントリポイントの定義が含まれており、ユーザの入力ループとSQLiteの合併&lt;b&gt;sqlite3.cは、&lt;/b&gt; SQLiteのライブラリの完全な実装が含まれています。</target>
        </trans-unit>
        <trans-unit id="bb2fbeab5253f75ff8183f69852d5cbb7ab2bba6" translate="yes" xml:space="preserve">
          <source>The key points of the previous example were the use of the Callback instruction to invoke the callback function, and the use of the Next instruction to implement a loop over all records of the database file. This example attempts to drive home those ideas by demonstrating a slightly more complex query that involves more columns of output, some of which are computed values, and a WHERE clause that limits which records actually make it to the callback function. Consider this query:</source>
          <target state="translated">前の例では、Callback 命令を使用してコールバック関数を呼び出し、Next 命令を使用してデータベース・ファイルのすべてのレコードをループさせることがポイントでした。この例では、出力のカラム数が増え、その中には計算値も含まれ、WHERE句によって実際にコールバック関数に到達するレコードが制限されている、少し複雑なクエリを使用して、これらのアイデアを実証します。このクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="986f899677204f1290b417dd64fe3fcaa05f7c30" translate="yes" xml:space="preserve">
          <source>The keys used by each segment b-tree are terms (words). As well as the key, each segment b-tree entry has an associated &quot;doclist&quot; (document list). A doclist consists of zero or more entries, where each entry consists of:</source>
          <target state="translated">各セグメント b-tree で使用されるキーは、用語 (単語)です。キーと同様に、各セグメント b-tree エントリには、関連する &quot;doclist&quot; (ドキュメントリスト)があります。doclist は 0 個以上のエントリで構成され、各エントリは次のように構成されます。</target>
        </trans-unit>
        <trans-unit id="a93934848f28a5d1e280c92cac942b828e6dc7e9" translate="yes" xml:space="preserve">
          <source>The keyword &quot;INSERT&quot;, &quot;UPDATE&quot;, or &quot;DELETE&quot;, as appropriate</source>
          <target state="translated">キーワード「INSERT」「UPDATE」「DELETE」のいずれかを適宜指定してください。</target>
        </trans-unit>
        <trans-unit id="799f75f9fa5e2cb1d9335f9637de442233918b1a" translate="yes" xml:space="preserve">
          <source>The kvtest program is compiled and run on Android as follows. First install the Android SDK and NDK. Then prepare a script named &quot;android-gcc&quot; that looks approximately like this:</source>
          <target state="translated">kvtestプログラムをコンパイルし、以下のようにAndroid上で実行します。まず、Android SDKとNDKをインストールします。そして、大体こんな感じの「android-gcc」というスクリプトを用意します。</target>
        </trans-unit>
        <trans-unit id="a518e69633f247201841ea47eb51e547b9e7d52f" translate="yes" xml:space="preserve">
          <source>The label to the right of an AS in the column list of a SELECT can now be used as part of an expression in the WHERE, ORDER BY, GROUP BY, and/or HAVING clauses.</source>
          <target state="translated">SELECTの列リストのASの右側にあるラベルは、WHERE句、ORDER BY句、GROUP BY句、HAVING句の式の一部として使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="5d78c31e6fd49e38e9a6929f67e573c2fcc27d5f" translate="yes" xml:space="preserve">
          <source>The language id for this entry.</source>
          <target state="translated">このエントリの言語ID。</target>
        </trans-unit>
        <trans-unit id="e80fa2a23c99c4e0919bc332ef910ec1f3215c2c" translate="yes" xml:space="preserve">
          <source>The languageid option causes the FTS4 table to have an additional hidden integer column that identifies the language of the text contained in each row. The use of the languageid option allows the same FTS4 table to hold text in multiple languages or scripts, each with different tokenizer rules, and to query each language independently of the others.</source>
          <target state="translated">languageid オプシ ョ ンは、FTS4 テーブルに、各行に含まれるテキス ト の言語を識別するための隠された整数列を追加させます。languageidオプションを使用すると、同じFTS4テーブルで複数の言語やスクリプトのテキストを保持することができ、それぞれが異なるトークン化ルールを持ち、それぞれの言語を他の言語から独立して問い合わせることができます。</target>
        </trans-unit>
        <trans-unit id="3a93c8c9ebe55117d8275a20a3a64f1279cc0414" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 2147483646. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 140 terabytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_COUNT の最大設定は 2147483646 です。これを最大ページサイズ 65536 で使用すると、SQLite データベースの最大サイズは約 140 テラバイトになります。</target>
        </trans-unit>
        <trans-unit id="d0fabb1072d1e3ea604e33e251741f22426c0f61" translate="yes" xml:space="preserve">
          <source>The last (fourth) bullet above merits additional comment. When SQLite creates a journal file on Unix, it opens the directory that contains that file and calls fsync() on the directory, in an effort to push the directory information to disk. But suppose some other process is adding or removing unrelated files to the directory that contains the database and journal at the moment of a power failure. The supposedly unrelated actions of this other process might result in the journal file being dropped from the directory and moved into &quot;lost+found&quot;. This is an unlikely scenario, but it could happen. The best defenses are to use a journaling filesystem or to keep the database and journal in a directory by themselves.</source>
          <target state="translated">上の最後の(4番目の)箇条書きは追加のコメントに値するものです。SQLite が Unix 上でジャーナルファイルを作成するとき、SQLite はそのファイルを含むディレクトリを開き、ディレクトリの情報をディスクにプッシュするためにディレクトリ上で fsync()を呼び出します。しかし、停電の瞬間に他のプロセスがデータベースとジャーナルを含むディレクトリに無関係なファイルを追加したり削除したりしていたとします。この他のプロセスの無関係と思われる動作により、ジャーナルファイルがディレクトリから削除され、&quot;lost+found &quot;に移動してしまうかもしれません。これはありそうもないシナリオですが、起こりうることです。最良の防御策は、ジャーナリングファイルシステムを使用するか、データベースとジャーナルを単独でディレクトリに保存することです。</target>
        </trans-unit>
        <trans-unit id="0d792644cd574497ddbf62ba435f6dbc99253564" translate="yes" xml:space="preserve">
          <source>The last bullet above is illustrated by the following:</source>
          <target state="translated">上の最後の箇条書きで説明すると、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6fcee6d642fa1ca93fa14337ac4410163d2a9df9" translate="yes" xml:space="preserve">
          <source>The last output mode is &quot;html&quot;. In this mode, sqlite3 writes the results of the query as an XHTML table. The beginning &amp;lt;TABLE&amp;gt; and the ending &amp;lt;/TABLE&amp;gt; are not written, but all of the intervening &amp;lt;TR&amp;gt;s, &amp;lt;TH&amp;gt;s, and &amp;lt;TD&amp;gt;s are. The html output mode is envisioned as being useful for CGI.</source>
          <target state="translated">最後の出力モードは「html」です。このモードでは、sqlite3はクエリの結果をXHTMLテーブルとして書き込みます。最初の&amp;lt;TABLE&amp;gt;と最後の&amp;lt;/ TABLE&amp;gt;は書き込まれませんが、間にあるすべての&amp;lt;TR&amp;gt;、&amp;lt;TH&amp;gt;、および&amp;lt;TD&amp;gt;は書き込まれます。html出力モードは、CGIに役立つものとして想定されています。</target>
        </trans-unit>
        <trans-unit id="a123c1f8dadbf6bb9cc227ef0871a1fb2cbe0f9d" translate="yes" xml:space="preserve">
          <source>The last parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; routines is a pointer to a procedure used to dispose of the P pointer once SQLite has finished with it. This pointer can be NULL, in which case no destructor is called.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;および&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;ルーチンへの最後のパラメーターは、SQLiteがPポインターを使い終わったら、Pポインターを破棄するために使用されるプロシージャへのポインターです。このポインタはNULLにすることができます。その場合、デストラクタは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="d52a179000f827088051359c744fec0210401d8f" translate="yes" xml:space="preserve">
          <source>The last step in the commit process is to release the exclusive lock so that other processes can once again start accessing the database file.</source>
          <target state="translated">コミットプロセスの最後のステップは、排他的なロックを解除して、他のプロセスが再びデータベースファイルへのアクセスを開始できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="56b9bbac0263da28aef9dee3010ecc1e8725f669" translate="yes" xml:space="preserve">
          <source>The last transaction started will be the first transaction committed or rolled back.</source>
          <target state="translated">最後に開始されたトランザクションは、最初にコミットされたトランザクションまたはロールバックされたトランザクションになります。</target>
        </trans-unit>
        <trans-unit id="c2015d5e4ba733546bdea54c6daefbab27ed0b3f" translate="yes" xml:space="preserve">
          <source>The last two allocations can be controlled and/or eliminated by configuring the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;, and &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; appropriately, as described above. The storage space required for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects depends to some extent on the length of the filename of the database file, but rarely exceeds 2KB on 32-bit systems. (More space is required on 64-bit systems due to the increased size of pointers.) Each parser object uses about 1.6KB of memory. Thus, elements 3 through 7 above can easily be controlled to keep the maximum memory allocation size below 2KB.</source>
          <target state="translated">最後の2つの割り当ては、&lt;a href=&quot;malloc#pagecache&quot;&gt;上記の&lt;/a&gt;ように、ページキャッシュメモリアロケータと&lt;a href=&quot;malloc#lookaside&quot;&gt;ルックアサイドメモリアロケータを&lt;/a&gt;適切に構成することにより、制御または削除できます。&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;オブジェクトに必要な記憶域は、データベースファイルのファイル名の長さにある程度依存しますが、32ビットシステムでは2KBを超えることはめったにありません。 （ポインターのサイズが大きくなるため、64ビットシステムではより多くのスペースが必要になります。）各パーサーオブジェクトは、約1.6KBのメモリを使用します。したがって、上記の要素3〜7は、最大メモリ割り当てサイズを2KB未満に保つように簡単に制御できます。</target>
        </trans-unit>
        <trans-unit id="dd770eea393f2ccabe1cb964e8f446d8577e90ba" translate="yes" xml:space="preserve">
          <source>The last two queries take the same amount of time, in our example. So which index, Idx1 or Idx2, will SQLite choose? If the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database, so that SQLite has had an opportunity to gather statistics about the available indices, then SQLite will know that the Idx1 index usually narrows the search down to a single item (our example of fruit='Orange' is the exception to this rule) whereas the Idx2 index will normally only narrow the search down to two rows. So, if all else is equal, SQLite will choose Idx1 with the hope of narrowing the search to as small a number of rows as possible. This choice is only possible because of the statistics provided by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. If &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has not been run then the choice of which index to use is arbitrary.</source>
          <target state="translated">この例では、最後の2つのクエリにかかる時間は同じです。SQLiteはIdx1またはIdx2のどちらのインデックスを選択するのでしょうか？場合&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドは、データベース上で実行されているので、SQLiteのは、利用できるインデックスに関する統計を収集する機会があったことが、その後、SQLiteのはIDX1インデックスは通常、単一の項目（果実の我々の例にダウン検索狭まることを知っているだろう=」 Orange 'はこのルールの例外です）が、Idx2インデックスは通常、検索を2行に絞り込むだけです。したがって、他のすべてが等しい場合、SQLiteはIdx1を選択して、検索を可能な限り少ない行数に絞り込みます。この選択は、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;によって提供される統計のためにのみ可能です。&lt;a href=&quot;lang_analyze&quot;&gt;分析する&lt;/a&gt;場合 実行されていない場合、使用するインデックスの選択は任意です。</target>
        </trans-unit>
        <trans-unit id="0271db818028a9ffb097a09e837d0647ab050705" translate="yes" xml:space="preserve">
          <source>The last_insert_rowid() function returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; of the last row insert from the database connection which invoked the function. The last_insert_rowid() SQL function is a wrapper around the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; C/C++ interface function.</source>
          <target state="translated">last_insert_rowid（）関数は、関数を呼び出したデータベース接続からの最後の行挿入の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を返します。last_insert_rowid（）SQL関数は、&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt; C / C ++インターフェース関数のラッパーです。</target>
        </trans-unit>
        <trans-unit id="dc54cc3b765595ad1e2bcb9ada53a0d0dfaa1af8" translate="yes" xml:space="preserve">
          <source>The latest checklists contain approximately 200 items that are individually verified for each release. Some checklist items only take a few seconds to verify and mark off. Others involve test suites that run for many hours.</source>
          <target state="translated">最新のチェックリストには、リリースごとに個別に検証した約200項目が収録されています。チェックリストの項目の中には、検証とマークオフに数秒しかかからないものもあります。また、何時間もかけて実行されるテストスイートもあります。</target>
        </trans-unit>
        <trans-unit id="972ae3a81fba75ac7b1cb927798468eb94557f5e" translate="yes" xml:space="preserve">
          <source>The latter query can not use the partial index because there might be rows in the table with b=456 and where c is NULL. But those rows would not be in the partial index.</source>
          <target state="translated">後者のクエリでは部分インデックスを使用することはできません。 なぜなら、テーブル内にb=456でcがNULLの行があるかもしれないからです。しかし、それらの行は部分インデックスには含まれません。</target>
        </trans-unit>
        <trans-unit id="5d0da56ef4fd6dfbe12fe3015e9d0a6d277654f6" translate="yes" xml:space="preserve">
          <source>The leftmost column of the &quot;%_content&quot; table is an INTEGER PRIMARY KEY field named &quot;docid&quot;. Following this is one column for each column of the FTS virtual table as declared by the user, named by prepending the column name supplied by the user with &quot;c</source>
          <target state="translated">テーブル &quot;%_content&quot; の左端の列は、&quot;docid&quot; という名前の INTEGER PRIMARY KEY フィールドです。これに続くのは、ユーザによって宣言された FTS 仮想テーブルの各列に 1 つの列で、ユーザによって提供された列名の前に &quot;c</target>
        </trans-unit>
        <trans-unit id="3fe10f10852f3ac1156d75127fc7c938a298af76" translate="yes" xml:space="preserve">
          <source>The legacy &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; compile-time option is now a no-op.</source>
          <target state="translated">従来の&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;コンパイル時オプションは何もしなくなりました。</target>
        </trans-unit>
        <trans-unit id="19d5e9050bddb7e40ed3e17c750502a0acf23cf7" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior can also be toggled on and off using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">レガシーテーブルの変更動作は、&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースの&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt;オプションを使用してオンとオフを切り替えることもできます。</target>
        </trans-unit>
        <trans-unit id="e0281c5597d6458d92c064f8c4ce4817fe25c10e" translate="yes" xml:space="preserve">
          <source>The legacy xGeom callback is invoked with four arguments. The first argument is a pointer to an sqlite3_rtree_geometry structure which provides information about how the SQL function was invoked. The second argument is the number of coordinates in each r-tree entry, and is always the same for any given R*Tree. The number of coordinates is 2 for a 1-dimensional R*Tree, 4 for a 2-dimensional R*Tree, 6 for a 3-dimensional R*Tree, and so forth. The third argument, aCoord[], is an array of nCoord coordinates that defines a bounding box to be tested. The last argument is a pointer into which the callback result should be written. The result is zero if the bounding-box defined by aCoord[] is completely outside the region defined by the xGeom callback and the result is non-zero if the bounding-box is inside or overlaps with the xGeom region. The xGeom callback should normally return SQLITE_OK. If xGeom returns anything other than SQLITE_OK, then the r-tree query will abort with an error.</source>
          <target state="translated">レガシーのxGeomコールバックは4つの引数で呼び出されます。最初の引数はsqlite3_rtree_geometry構造体へのポインタで、SQL関数がどのように呼び出されたかの情報を提供します。2番目の引数は各r-treeエントリの座標数で、与えられたR*Treeに対して常に同じです。座標数は、1次元のR*Treeの場合は2、2次元のR*Treeの場合は4、3次元のR*Treeの場合は6などです。第3引数のaCoord[]は、テスト対象のバウンディングボックスを定義するnCoord座標の配列です。最後の引数は、コールバックの結果を書き込むためのポインタです。aCoord[]によって定義された外接箱がxGeomコールバックによって定義された領域の外側にある場合、結果は0となり、外接箱がxGeom領域の内側にあるか重なっている場合は0ではありません。xGeom コールバックは通常 SQLITE_OK を返すはずです。xGeomがSQLITE_OK以外の値を返した場合、r-treeクエリはエラーで終了します。</target>
        </trans-unit>
        <trans-unit id="c26ac59b1bddfababdeff98e88ee3a4d181edb8a" translate="yes" xml:space="preserve">
          <source>The legacy_file_format pragma is initialized to OFF when an existing database in the newer file format is first opened.</source>
          <target state="translated">legacy_file_format pragmaは、新しいファイル形式の既存のデータベースを最初に開くときにOFFに初期化されます。</target>
        </trans-unit>
        <trans-unit id="5c416af28ee6cf9f448dc251869a118022ef5870" translate="yes" xml:space="preserve">
          <source>The length of a function name may not exceed 255 characters. Any attempt to create a function whose name exceeds 255 characters in length will result in an error.</source>
          <target state="translated">関数名の長さは255文字を超えてはいけません。名前の長さが 255 文字を超える関数を作成しようとすると、エラーになります。</target>
        </trans-unit>
        <trans-unit id="64a58fb27f585f3af736420c55a5c7aba354a480" translate="yes" xml:space="preserve">
          <source>The length of the argument value can be specified by one or more letters that occur just prior to the substitution type letter. In SQLite, the length only matter for integer types. The length is ignored for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; which always uses 64-bit values. The following table shows the length specifiers allowed by SQLite:</source>
          <target state="translated">引数値の長さは、置換タイプ文字の直前にある1つ以上の文字で指定できます。 SQLiteでは、長さは整数型に対してのみ重要です。常に64ビット値を使用する&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL関数&lt;/a&gt;では、長さは無視されます。次の表は、SQLiteで使用できる長さ指定子を示しています。</target>
        </trans-unit>
        <trans-unit id="835ff0a5a3c1f19c6461eba222151b4907f96047" translate="yes" xml:space="preserve">
          <source>The letter &quot;j&quot; pronounced like &quot;h&quot; in Spanish: LaJolla</source>
          <target state="translated">j」はスペイン語で「h」と発音します。ラジョラ</target>
        </trans-unit>
        <trans-unit id="ee9eb5ebb3823c5e0db14477052af2948a8b37ee" translate="yes" xml:space="preserve">
          <source>The library now assumes data is stored as UTF-8 if the --enable-utf8 option is given to configure. The default behavior is to assume iso8859-x, as it has always done. This only makes a difference for LIKE and GLOB operators and the LENGTH and SUBSTR functions.</source>
          <target state="translated">configure に --enable-utf8 オプションが与えられた場合、ライブラリはデータが UTF-8 で保存されると仮定するようになりました。デフォルトの動作は、これまでと同様に iso8859-x を想定しています。これは、LIKEとGLOB演算子とLENGTHとSUBSTR関数の違いだけを意味します。</target>
        </trans-unit>
        <trans-unit id="2b11a2ab2af2c4ff66c5a4f077ed6909c7421f85" translate="yes" xml:space="preserve">
          <source>The life-cycle of a prepared statement object usually goes like this:</source>
          <target state="translated">準備されたステートメントオブジェクトのライフサイクルは通常次のようになります。</target>
        </trans-unit>
        <trans-unit id="610e163977a4d438d498cc7745085654d18422e2" translate="yes" xml:space="preserve">
          <source>The lifecycle of an sqlite3_str object is as follows:</source>
          <target state="translated">sqlite3_strオブジェクトのライフサイクルは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e1c985dd036afafc48409f9dec76735bbf115b4e" translate="yes" xml:space="preserve">
          <source>The like() function is used to implement the &quot;&lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt;&quot; expression. If the optional ESCAPE clause is present, then the like() function is invoked with three arguments. Otherwise, it is invoked with two arguments only. Note that the X and Y parameters are reversed in the like() function relative to the infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. X is the pattern and Y is the string to match against that pattern. Hence, the following expressions are equivalent:</source>
          <target state="translated">like（）関数は、「&lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt;」式を実装するために使用されます。オプションのESCAPE句が存在する場合、like（）関数は3つの引数で呼び出されます。それ以外の場合は、2つの引数のみで呼び出されます。 XおよびYパラメータは、infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子に関連するlike（）関数では逆になっていることに注意してください。 Xはパターン、Yはそのパターンと照合する文字列です。したがって、次の式は同等です。</target>
        </trans-unit>
        <trans-unit id="1725d5bdba0b7e8833554a2371c0c343ab2395e2" translate="yes" xml:space="preserve">
          <source>The likelihood(X,Y) function returns argument X unchanged. The value Y in likelihood(X,Y) must be a floating point constant between 0.0 and 1.0, inclusive. The likelihood(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles during run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likelihood(X,Y) function is to provide a hint to the query planner that the argument X is a boolean that is true with a probability of approximately Y. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.0625). The &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.9375).</source>
          <target state="translated">尤度（X、Y）関数は引数Xを変更せずに返します。尤度（X、Y）の値Yは、0.0以上1.0以下の浮動小数点定数でなければなりません。尤度（X）関数は、コードジェネレーターが実行時に（つまり、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）の&lt;/a&gt;呼び出し中に） CPUサイクルを消費しないように最適化する何もしません。尤度（X、Y）関数の目的は、引数Xがブール値であり、ほぼYの確率で真であるというヒントをクエリプランナーに提供することです&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;。likelyly（X）&lt;/a&gt;関数は尤度（ X、0.0625）。&lt;a href=&quot;lang_corefunc#likely&quot;&gt;可能性（X）&lt;/a&gt;関数は、尤度（X、0.9375）のための短い手です。</target>
        </trans-unit>
        <trans-unit id="047f4505a74dbe546931a88238b570dcea0e5906" translate="yes" xml:space="preserve">
          <source>The likely(X) function returns the argument X unchanged. The likely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually true. The likely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X,0.9375). See also: &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt;.</source>
          <target state="translated">Like（X）関数は、引数Xを変更せずに返します。&lt;a href=&quot;c3ref/step&quot;&gt;Like&lt;/a&gt;（X）関数は、実行時に（つまり、sqlite3_step（）の呼び出し中に） CPUサイクルを消費しないようにコードジェネレーターが最適化しない操作です。 Like（X）関数の目的は、引数Xが通常は真であるブール値であるというヒントをクエリプランナーに提供することです。Like （X）関数は、&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;尤度&lt;/a&gt;（X、0.9375）と同等です。また見なさい：&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;likelyly（X）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7008986405b40055720891f4830c40ce21496380" translate="yes" xml:space="preserve">
          <source>The line &quot;.once</source>
          <target state="translated">行「.once</target>
        </trans-unit>
        <trans-unit id="d0c3acc92dc701e819ac94a0c8098f2db90a205c" translate="yes" xml:space="preserve">
          <source>The list below is not exhaustive. Other virtual table implementation exist in the SQLite source tree and elsewhere. The list below tries to capture the more interesting virtual table implementations.</source>
          <target state="translated">以下のリストは網羅的ではありません。他の仮想テーブルの実装はSQLiteのソースツリーや他の場所にも存在します。以下のリストは、より興味深い仮想テーブルの実装を捕捉しようとしています。</target>
        </trans-unit>
        <trans-unit id="d3b78caa21f35e034eafcfa346ed07394d0ca6e0" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 143 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="translated">以下のリストは、&lt;a href=&quot;compile&quot;&gt;コンパイル時オプションに&lt;/a&gt;関係なく、SQLiteのビルドで使用されるすべての可能なキーワードを示しています。最も合理的な構成では、これらのキーワードのほとんどまたはすべてを使用しますが、SQL言語機能が無効になっている場合、一部のキーワードは省略される場合があります。アプリケーションは&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count（）&lt;/a&gt;、&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check（）&lt;/a&gt;インターフェースを使用して、実行時にSQLiteによって認識されるキーワードを決定できます。コンパイル時の構成に関係なく、次の143要素リストにない識別子は、SQLiteのSQLパーサーのキーワードではありません。</target>
        </trans-unit>
        <trans-unit id="281c02e8bf5d35129f9e1be609bd2e9295d15355" translate="yes" xml:space="preserve">
          <source>The list of coordinates in the binary format contains no redundancy. The last coordinate is not a repeat of the first as it is with GeoJSON. Hence, there is always one fewer coordinate pair in the binary representation of a polygon compared to the GeoJSON representation.</source>
          <target state="translated">バイナリ形式の座標のリストには冗長性がありません。GeoJSONの場合のように、最後の座標は最初の座標の繰り返しではありません。したがって、多角形のバイナリ表現では、GeoJSON 表現と比較して、常に 1 つ少ない座標ペアが存在します。</target>
        </trans-unit>
        <trans-unit id="31509dccb06d1116de02483b9bec949662404996" translate="yes" xml:space="preserve">
          <source>The list of expressions between the SELECT and FROM keywords is known as the result expression list. If a result expression is the special expression &quot;*&quot; then all columns in the input data are substituted for that one expression. If the expression is the alias of a table or subquery in the FROM clause followed by &quot;.*&quot; then all columns from the named table or subquery are substituted for the single expression. It is an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in any context other than a result expression list. It is also an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in a simple SELECT query that does not have a FROM clause.</source>
          <target state="translated">SELECTキーワードとFROMキーワードの間にある式のリストは、結果式リストとして知られています。結果式が特殊な式 &quot;*&quot;である場合、入力データ内のすべての列がその式に置き換えられます。式がFROM句のテーブルまたは副問い合わせのエイリアスで、&quot;.*&quot;が続く場合、名前のついたテーブルまたは副問い合わせからのすべての列が単一の式に置き換えられます。結果式リスト以外のコンテキストで &quot;*&quot;または &quot;alias.*&quot;式を使用するのはエラーです。また、FROM句を持たない単純なSELECTクエリで &quot;*&quot;または &quot;alias.*&quot;式を使用することもエラーです。</target>
        </trans-unit>
        <trans-unit id="aff07670c95df2683c32cdb3b9c35bd30fecbe25" translate="yes" xml:space="preserve">
          <source>The list of integers in the stat column can optionally be followed by arguments, each of which is a sequence of non-space characters. All arguments are preceded by a single space. Unrecognized arguments are silently ignored.</source>
          <target state="translated">stat列の整数のリストの後には、オプションで引数を付けることができます。すべての引数の前にはスペースが1つ付きます。認識されない引数は静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="5c584c3300424511e57cf7c45771316447fd9008" translate="yes" xml:space="preserve">
          <source>The load_extension() function will fail if the extension attempts to modify or delete an SQL function or collating sequence. The extension can add new functions or collating sequences, but cannot modify or delete existing functions or collating sequences because those functions and/or collating sequences might be used elsewhere in the currently running SQL statement. To load an extension that changes or deletes functions or collating sequences, use the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language API.</source>
          <target state="translated">拡張機能がSQL関数または照合シーケンスを変更または削除しようとすると、load_extension（）関数は失敗します。拡張機能は、新しい関数または照合シーケンスを追加できますが、既存の関数または照合シーケンスは、現在実行中のSQLステートメントの他の場所で使用される可能性があるため、変更または削除できません。関数または照合シーケンスを変更または削除する拡張機能をロードするには、&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt; C言語APIを使用します。</target>
        </trans-unit>
        <trans-unit id="349abdc2376164ceeb049d0fdce3e4218d275600" translate="yes" xml:space="preserve">
          <source>The load_extension(X,Y) function loads &lt;a href=&quot;loadext&quot;&gt;SQLite extensions&lt;/a&gt; out of the shared library file named X using the entry point Y. The result of load_extension() is always a NULL. If Y is omitted then the default entry point name is used. The load_extension() function raises an exception if the extension fails to load or initialize correctly.</source>
          <target state="translated">load_extension（X、Y）関数は、エントリポイントYを使用して、Xという名前の共有ライブラリファイルから&lt;a href=&quot;loadext&quot;&gt;SQLite拡張&lt;/a&gt;機能をロードします。load_extension（）の結果は常にNULLです。 Yを省略すると、デフォルトのエントリポイント名が使用されます。 load_extension（）関数は、拡張機能が正しくロードまたは初期化できない場合に例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="3c476d76e8d35e3c5addfedd0889c28cfa2868c0" translate="yes" xml:space="preserve">
          <source>The local copy of the remote head</source>
          <target state="translated">リモートヘッドのローカルコピー</target>
        </trans-unit>
        <trans-unit id="9c687c8acb9d37e788292221df58e5cc9d9b9e4e" translate="yes" xml:space="preserve">
          <source>The local head</source>
          <target state="translated">現地のトップ</target>
        </trans-unit>
        <trans-unit id="ef999d9e04e59df040c534586df9501decb45621" translate="yes" xml:space="preserve">
          <source>The lock-byte page</source>
          <target state="translated">ロックバイトページ</target>
        </trans-unit>
        <trans-unit id="5c06094b5494afcc6bc0546930a2d751ec1db7b7" translate="yes" xml:space="preserve">
          <source>The lock-byte page arose from the need to support Win95 which was the predominant operating system when this file format was designed and which only supported mandatory file locking. All modern operating systems that we know of support advisory file locking, and so the lock-byte page is not really needed any more, but is retained for backwards compatibility.</source>
          <target state="translated">ロックバイトページは、このファイルフォーマットが設計された当時の主流のオペレーティング・システムであり、必須のファイルロックしかサポートしていなかったWin95をサポートする必要性から生まれました。私たちが知っている最新のオペレーティングシステムはすべて勧告的なファイルロックをサポートしているので、ロックバイトページはもう本当に必要とされていませんが、下位互換性のために保持されています。</target>
        </trans-unit>
        <trans-unit id="4bd512e93ea74564dff8bf82d8627bae1ed3c48e" translate="yes" xml:space="preserve">
          <source>The lock-byte page is set aside for use by the operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation in implementing the database file locking primitives. SQLite does not use the lock-byte page. The SQLite core will never read or write the lock-byte page, though operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations may choose to read or write bytes on the lock-byte page according to the needs and proclivities of the underlying system. The unix and win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations that come built into SQLite do not write to the lock-byte page, but third-party VFS implementations for other operating systems might.</source>
          <target state="translated">ロックバイトページは、データベースファイルロックプリミティブを実装する際に、オペレーティングシステム固有の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;実装で使用するために確保されています。 SQLiteはロックバイトページを使用しません。 SQLiteコアはロックバイトページの読み取りまたは書き込みを行いませんが、オペレーティングシステム固有の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;実装は、基盤となるシステムのニーズと傾向に応じて、ロックバイトページのバイトの読み取りまたは書き込みを選択できます。SQLiteに組み込まれたunixおよびwin32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;実装はロックバイトページに書き込みませんが、他のオペレーティングシステム用のサードパーティVFS実装は書き込む可能性があります。</target>
        </trans-unit>
        <trans-unit id="df185932a5473981e68a610e19ea95a4f593a072" translate="yes" xml:space="preserve">
          <source>The lock-byte page is the single page of the database file that contains the bytes at offsets between 1073741824 and 1073742335, inclusive. A database file that is less than or equal to 1073741824 bytes in size contains no lock-byte page. A database file larger than 1073741824 contains exactly one lock-byte page.</source>
          <target state="translated">ロック・バイト・ページとは、1073741824 から 1073742335 までのオフセットにあるバイトを含むデータベース・ファイルの単一ページのことです。サイズが 1073741824 バイト以下のデータベース・ファイルには、ロック・バイト・ページは含まれません。1073741824 バイトより大きいデータベース・ファイルには、ロック・バイト・ページが正確に 1 つ含まれています。</target>
        </trans-unit>
        <trans-unit id="dda6a9ed2d568f9a7c6dc08407b442fb82119304" translate="yes" xml:space="preserve">
          <source>The logic is summarized like this:</source>
          <target state="translated">論理をまとめるとこんな感じです。</target>
        </trans-unit>
        <trans-unit id="355578bfd3a4498b2a633a6f3c4ff7c7b09de69f" translate="yes" xml:space="preserve">
          <source>The logical database size is now stored in the database header so that bytes can be appended to the end of the database file without corrupting it and so that SQLite will work correctly on systems that lack support for ftruncate().</source>
          <target state="translated">これにより、データベースファイルを破損させることなく、データベースファイルの最後にバイトを追加することができます。</target>
        </trans-unit>
        <trans-unit id="e93186cc2b2b96f693bcff5f9715523649b95afa" translate="yes" xml:space="preserve">
          <source>The lookaside configuration can only be changed while there are no outstanding lookaside allocations for the database connection. Hence, the configuration should be set immediately after creating the database connection using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; (or equivalent) and before evaluating any SQL statements on the connection.</source>
          <target state="translated">ルックアサイド構成は、データベース接続に未処理のルックアサイド割り当てがない場合にのみ変更できます。したがって、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;（または同等のもの）を使用してデータベース接続を作成した直後で、接続のSQLステートメントを評価する前に、構成を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="98de1d7e1c308aef9eeb240a9c0c48340d7aa4c3" translate="yes" xml:space="preserve">
          <source>The lookaside memory allocator is really intended as performance optimization, not as a method for assuring breakdown-free memory allocation, so it is not unreasonable to completely disable the lookaside memory allocator for safety-critical operations.</source>
          <target state="translated">ルックサイドメモリアロケータは性能の最適化を目的としたものであり、故障のないメモリ割り当てを保証するための方法ではないので、安全上重要な操作のためにルックサイドメモリアロケータを完全に無効にすることは不合理ではない。</target>
        </trans-unit>
        <trans-unit id="02f0ada4fc69e2b3f3d2c6c843b91333faf8b563" translate="yes" xml:space="preserve">
          <source>The lookaside pool can be changed for an individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; &quot;db&quot; using this call:</source>
          <target state="translated">ルックアサイドプールは、次の呼び出しを使用して、個々の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;「db」に対して変更できます。</target>
        </trans-unit>
        <trans-unit id="31d19ac91c3d68e4ec2f5534877ee0ca68a0efec" translate="yes" xml:space="preserve">
          <source>The loop begins with the &lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt; instruction at 11 which pushes a copy of the index key back onto the stack. The instruction &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; at 12 compares the key to the key in the current index record pointed to by cursor P1. If the index key at the current cursor location is greater than the index we are looking for, then jump out of the loop.</source>
          <target state="translated">ループは、インデックスキーのコピーをスタックに戻す11 の&lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt;命令で始まります。12の&lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt;命令は、キーをカーソルP1が指す現在のインデックスレコードのキーと比較します。現在のカーソル位置のインデックスキーが、探しているインデックスよりも大きい場合は、ループを抜けます。</target>
        </trans-unit>
        <trans-unit id="9b4e40524d32f647817434932fe77ea61e285d86" translate="yes" xml:space="preserve">
          <source>The lower(X) function returns a copy of string X with all ASCII characters converted to lower case. The default built-in lower() function works for ASCII characters only. To do case conversions on non-ASCII characters, load the ICU extension.</source>
          <target state="translated">lower(X)関数は、すべての ASCII 文字を小文字に変換した文字列 X のコピーを返します。デフォルトの組み込みの lower()関数は ASCII 文字に対してのみ動作します。非 ASCII 文字の大文字小文字変換を行うには、ICU 拡張モジュールをロードしてください。</target>
        </trans-unit>
        <trans-unit id="84e26bc0d335ef0f3f91dcbee9450cd939575e9d" translate="yes" xml:space="preserve">
          <source>The ltrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the left side of X. If the Y argument is omitted, ltrim(X) removes spaces from the left side of X.</source>
          <target state="translated">ltrim(X,Y)関数は、Xの左側からYに登場する文字をすべて削除した文字列を返します。</target>
        </trans-unit>
        <trans-unit id="fdcc55ab3a12db83d0fd351a3149fb5d3844b7fd" translate="yes" xml:space="preserve">
          <source>The macros in this section do not require values. The following compilation switches all have the same effect:</source>
          <target state="translated">このセクションのマクロは値を必要としません。以下のコンパイルスイッチはすべて同じ効果を持ちます。</target>
        </trans-unit>
        <trans-unit id="9225c9e6b4935393e2d3171b186997ddaa13f218" translate="yes" xml:space="preserve">
          <source>The main database file consists of one or more pages. The size of a page is a power of two between 512 and 65536 inclusive. All pages within the same database are the same size. The page size for a database file is determined by the 2-byte integer located at an offset of 16 bytes from the beginning of the database file.</source>
          <target state="translated">メインデータベースファイルは、1つ以上のページで構成されています。ページのサイズは 512 から 65536 までの 2 の累乗です。同じデータベース内のすべてのページは同じサイズです。データベースファイルのページサイズは、データベースファイルの先頭から16バイトのオフセットに位置する2バイトの整数によって決定されます。</target>
        </trans-unit>
        <trans-unit id="7d6f37716756d458f806be1f0cab62c9c7d22175" translate="yes" xml:space="preserve">
          <source>The main database file with an arbitrary name &quot;X&quot;.</source>
          <target state="translated">任意の名前「X」のメインデータベースファイル。</target>
        </trans-unit>
        <trans-unit id="f6b3e874976f8a865414a00bc3a0b52995dae0f9" translate="yes" xml:space="preserve">
          <source>The main expression bubble diagram above shows a single syntax for all function invocations. But this is merely to simplify the expression bubble diagram. In reality, each type of function has a slightly different syntax, shown below. The function invocation syntax shown in the main expression bubble diagram is the union of the three syntaxes shown here:</source>
          <target state="translated">上の主な式バブル図は、すべての関数呼び出しに対して単一の構文を示しています。しかし、これは単に式バブル図を単純化するためのものです。実際には、以下に示すように、各タイプの関数はわずかに異なる構文を持っています。メインの式バブル図に示されている関数呼び出し構文は、ここに示されている3つの構文の合体です。</target>
        </trans-unit>
        <trans-unit id="408e5f03d044dab233873eb64f906cb6ccb49b90" translate="yes" xml:space="preserve">
          <source>The main machine in Dallas &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; is the primary server and the one that most people use. The other two are considered backups.</source>
          <target state="translated">ダラスのメインマシン&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;はプライマリサーバーであり、ほとんどの人が使用します。他の2つはバックアップと見なされます。</target>
        </trans-unit>
        <trans-unit id="1d698f91852ce738e8b0efe94402ad56dc5b35ee" translate="yes" xml:space="preserve">
          <source>The main result from &lt;b&gt;sqlite_get_table&lt;/b&gt; is an array of pointers to strings. There is one element in this array for each column of each row in the result. NULL results are represented by a NULL pointer. In addition to the regular data, there is an added row at the beginning of the array that contains the name of each column of the result.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt;の主な結果は、文字列へのポインタの配列です。この配列には、結果の各行の各列に対して1つの要素があります。NULLの結果は、NULLポインターによって表されます。通常のデータに加えて、結果の各列の名前を含む行が配列の先頭に追加されます。</target>
        </trans-unit>
        <trans-unit id="2fb1295c928ccfed10f4bea85ec6d057bdb858da" translate="yes" xml:space="preserve">
          <source>The main thing that the SQLite core is trying to communicate to the virtual table is the constraints that are available to limit the number of rows that need to be searched. The aConstraint[] array contains one entry for each constraint. There will be exactly nConstraint entries in that array.</source>
          <target state="translated">SQLite コアが仮想テーブルに伝えようとしている主なものは、検索する必要のある行の数を制限するために利用可能な制約です。aConstraint[]配列には、各制約に対して1つのエントリが含まれます。その配列には、正確には nConstraint エントリが存在します。</target>
        </trans-unit>
        <trans-unit id="c00fa1abbc4e41f8e98c7516bdb7add3970ff677" translate="yes" xml:space="preserve">
          <source>The makefiles and scripts used to generate the documentation gather text from baseline documents in the documentation source repository. Additional text is extracted from comments in the SQLite source code. Requirements coverage information is extract from special comments in the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; which is part of the source repository, and from comments in the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite which is a separate private repository.</source>
          <target state="translated">ドキュメントの生成に使用されるメイクファイルとスクリプトは、ドキュメントソースリポジトリのベースラインドキュメントからテキストを収集します。追加のテキストは、SQLiteソースコードのコメントから抽出されます。要件カバレッジ情報は、ソースリポジトリの一部である&lt;a href=&quot;testing#tcl&quot;&gt;TCLテストスイートの&lt;/a&gt;特別なコメントと、個別のプライベートリポジトリである&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;テストスイートのコメントから抽出されます。</target>
        </trans-unit>
        <trans-unit id="42a78601e6da24d033fc5c1c1ee7512e6c89f88c" translate="yes" xml:space="preserve">
          <source>The makefiles for SQLite have an &quot;sqlite3.c&quot; target for building the file we call &quot;the amalgamation&quot;. The amalgamation is a single C code file, named &quot;sqlite3.c&quot;, that contains all C code for the core SQLite library and the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. This file contains about 184K lines of code (113K if you omit blank lines and comments) and is over 6.4 megabytes in size. Though the various extensions are included in the &quot;sqlite3.c&quot; amalgamation file, they are disabled using #ifdef statements. Activate the extensions using &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; like:</source>
          <target state="translated">SQLiteのmakefileには、「アマルガム」と呼ばれるファイルを構築するための「sqlite3.c」ターゲットがあります。統合は、「sqlite3.c」という名前の単一のCコードファイルであり、コアSQLiteライブラリのすべてのCコードと、&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;、&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;、&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;、&lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;、&lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;、および&lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt;拡張機能が含まれています。このファイルには約184K行のコード（空白行とコメントを省略した場合は113K行）が含まれ、サイズは6.4Mバイトを超えます。さまざまな拡張機能が「sqlite3.c」統合ファイルに含まれていますが、＃ifdefステートメントを使用して無効になっています。次のような&lt;a href=&quot;compile&quot;&gt;コンパイル時オプション&lt;/a&gt;を使用して、拡張機能をアクティブにします。</target>
        </trans-unit>
        <trans-unit id="0980756624132b6830b479bc71ea60b90272891a" translate="yes" xml:space="preserve">
          <source>The manner in which SQLite uses temporary files is not considered part of the contract that SQLite makes with applications. The information in this document is a correct description of how SQLite operates at the time that this document was written or last updated. But there is no guarantee that future versions of SQLite will use temporary files in the same way. New kinds of temporary files might be employed and some of the current temporary file uses might be discontinued in future releases of SQLite.</source>
          <target state="translated">SQLite が一時ファイルを使用する方法は、SQLite がアプリケーションと交わす契約の一部とは考えられていません。このドキュメントに記載されている情報は、このドキュメントが作成された時点、または最終更新された時点でのSQLiteの動作についての正しい説明です。しかし、将来のバージョンのSQLiteが同じように一時ファイルを使用することを保証するものではありません。新しい種類のテンポラリファイルが採用されるかもしれませんし、現在のテンポラリファイルの使用方法の一部は将来のSQLiteのリリースで廃止されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="3c2b798d423398f0b8335bc4cb33aea4b3800944" translate="yes" xml:space="preserve">
          <source>The mapping from character to affinity is given by the SQLITE_AFF_ macros defined in sqliteInt.h.</source>
          <target state="translated">文字からアフィニティへのマッピングはsqliteInt.hで定義されているSQLITE_AFF_マクロによって与えられます。</target>
        </trans-unit>
        <trans-unit id="e5801820a892b25589a4f5acb0cdb08d7136d42b" translate="yes" xml:space="preserve">
          <source>The master journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">マスタージャーナルファイルは、少なくとも2つのデータベースが以下のすべての要件を満たしている複数のデータベースファイルが関係する&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作に対してのみ作成されます。</target>
        </trans-unit>
        <trans-unit id="31da1199925e2ef2121e09ef393e19f883001204" translate="yes" xml:space="preserve">
          <source>The master journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The master journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The master journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the master journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">マスタージャーナルファイルは、単一のトランザクションが&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメント&lt;a href=&quot;c3ref/sqlite3&quot;&gt;を&lt;/a&gt;使用して単一のデータベース接続に追加された複数のデータベースを変更するときに、アトミックコミットプロセスの一部として使用されます。マスタージャーナルファイルは常にメインデータベースファイルと同じディレクトリにあります（メインデータベースファイルは、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;を作成した元の&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、または&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;呼び出しで識別されるデータベースです））ランダムなサフィックスを付けます。マスタージャーナルファイルには、トランザクション中に変更された、接続されているさまざまな補助データベースすべての名前が含まれています。マスタージャーナルファイルが削除されると、マルチデータベーストランザクションがコミットされます。詳細については、&lt;a href=&quot;atomiccommit&quot;&gt;SQLiteのAtomic Commit&lt;/a&gt;というタイトルのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="772c6b302e1774e25495c91e9341c8308af64569" translate="yes" xml:space="preserve">
          <source>The matchinfo 'b' flag provides similar information to the &lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo 'y' flag&lt;/a&gt;, but in a more compact form. Instead of the precise number of hits, 'b' provides a single boolean flag for each phrase/column combination. If the phrase is present in the column at least once (i.e. if the corresponding integer output of 'y' would be non-zero), the corresponding flag is set. Otherwise cleared.</source>
          <target state="translated">matchinfo 'b'フラグは、&lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo 'y'フラグ&lt;/a&gt;と同様の情報を提供しますが、よりコンパクトな形式です。正確なヒット数の代わりに、「b」は各フレーズ/列の組み合わせに対して単一のブールフラグを提供します。フレーズが列に少なくとも1回存在する場合（つまり、「y」の対応する整数出力がゼロ以外になる場合）、対応するフラグが設定されます。それ以外の場合はクリアされます。</target>
        </trans-unit>
        <trans-unit id="0e92769ac2bedb9028e89c1796d219b3c41ebfd0" translate="yes" xml:space="preserve">
          <source>The matchinfo function is called with either one or two arguments. As for all auxiliary functions, the first argument must be the special &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;. The second argument, if it is specified, must be a text value comprised only of the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'. If no second argument is explicitly supplied, it defaults to &quot;pcx&quot;. The second argument is referred to as the &quot;format string&quot; below.</source>
          <target state="translated">matchinfo関数は、1つまたは2つの引数で呼び出されます。すべての補助関数と同様に、最初の引数は特別な&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS非表示列である&lt;/a&gt;必要があります。 2番目の引数を指定する場合は、「p」、「c」、「n」、「a」、「l」、「s」、「x」、「y」の文字のみで構成されるテキスト値である必要がありますおよび「b」。 2番目の引数が明示的に指定されていない場合、デフォルトで「pcx」になります。 2番目の引数は、以下の「フォーマット文字列」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="d7687da8f246deec886a3154fb495c0792554c7d" translate="yes" xml:space="preserve">
          <source>The matchinfo function is much faster than either the snippet or offsets functions. This is because the implementation of both snippet and offsets is required to retrieve the documents being analyzed from disk, whereas all data required by matchinfo is available as part of the same portions of the full-text index that are required to implement the full-text query itself. This means that of the following two queries, the first may be an order of magnitude faster than the second:</source>
          <target state="translated">matchinfo 関数は、 snippet 関数や offsets 関数よりもはるかに高速です。これは、分析対象の文書をディスクから取得するためにスニペットとオフセットの両方の実装が必要なのに対し、matchinfoで必要なデータはすべて、フルテキストクエリ自体を実装するために必要なフルテキストインデックスの同じ部分の一部として利用可能だからです。つまり、以下の2つのクエリのうち、1つ目のクエリの方が2つ目のクエリよりも桁違いに高速である可能性があるということです。</target>
        </trans-unit>
        <trans-unit id="c65df31b33c2a6ca0926acfdea9fd52aa875638d" translate="yes" xml:space="preserve">
          <source>The matchinfo function provides all the information required to calculate probabilistic &quot;bag-of-words&quot; relevancy scores such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25/BM25F&lt;/a&gt; that may be used to order results in a full-text search application. Appendix A of this document, &quot;&lt;a href=&quot;fts3#appendix_a&quot;&gt;search application tips&lt;/a&gt;&quot;, contains an example of using the matchinfo() function efficiently.</source>
          <target state="translated">matchinfo関数は、フルテキスト検索アプリケーションで結果を注文するために使用できる&lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25 / BM25F&lt;/a&gt;などの確率論的な「単語のバッグ」関連性スコアの計算に必要なすべての情報を提供します。このドキュメントの付録A「&lt;a href=&quot;fts3#appendix_a&quot;&gt;検索アプリケーションのヒント&lt;/a&gt;」には、matchinfo（）関数を効率的に使用する例が含まれています。</target>
        </trans-unit>
        <trans-unit id="e90549847387fb18f595713064d87ed6f095e05c" translate="yes" xml:space="preserve">
          <source>The matchinfo function returns a blob value. If it is used within a query that does not use the full-text index (a &quot;query by rowid&quot; or &quot;linear scan&quot;), then the blob is zero bytes in size. Otherwise, the blob consists of zero or more 32-bit unsigned integers in machine byte-order. The exact number of integers in the returned array depends on both the query and the value of the second argument (if any) passed to the matchinfo function.</source>
          <target state="translated">matchinfo 関数は、ブロブ値を返します。フルテキストインデックスを使用しないクエリ(「行番号によるクエリ」または「リニアスキャン」)の中で使用された場合、ブロブのサイズは0バイトです。そうでない場合、ブロブは、マシン・バイト順のゼロ以上の32ビット符号なし整数で構成されます。返される配列内の正確な整数数は、クエリと matchinfo 関数に渡された第 2 引数の値(もしあれば)の両方に依存します。</target>
        </trans-unit>
        <trans-unit id="5fd973e0c684054ad3dbbf4a32a2b97ce84282bb" translate="yes" xml:space="preserve">
          <source>The matchinfo option may only be set to the value &quot;fts3&quot;. Attempting to set matchinfo to anything other than &quot;fts3&quot; is an error. If this option is specified, then some of the extra information stored by FTS4 is omitted. This reduces the amount of disk space consumed by an FTS4 table until it is almost the same as the amount that would be used by the equivalent FTS3 table, but also means that the data accessed by passing the 'l' flag to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function is not available.</source>
          <target state="translated">matchinfoオプションは、値「fts3」にのみ設定できます。 matchinfoを「fts3」以外に設定しようとすると、エラーになります。このオプションが指定されている場合、FTS4によって格納される追加情報の一部が省略されます。これにより、同等のFTS3テーブルで使用される量とほぼ同じになるまで、FTS4テーブルで消費されるディスク領域の量が減少しますが、「l」フラグを&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）に&lt;/a&gt;渡してデータにアクセスすることも意味します機能は利用できません。</target>
        </trans-unit>
        <trans-unit id="30566a971375718efb83d0535cdd7975a1033a22" translate="yes" xml:space="preserve">
          <source>The matrix below shows the time needed to read BLOBs stored in separate files divided by the time needed to read BLOBs stored entirely in the database. Hence, for numbers larger than 1.0, it is faster to store the BLOBs directly in the database. For numbers smaller than 1.0, it is faster to store the BLOBs in separate files.</source>
          <target state="translated">以下の行列は、別々のファイルに保存された BLOB を読み込むのに必要な時間を、データベース全体に保存された BLOB を読み込むのに必要な時間で割ったものです。したがって、1.0よりも大きい数値では、BLOBを直接データベースに格納した方が高速です。1.0よりも小さい数については、BLOBを別のファイルに保存した方が高速です。</target>
        </trans-unit>
        <trans-unit id="4c2fbc6111561deb5f89baa2a61ac965889a611a" translate="yes" xml:space="preserve">
          <source>The max() aggregate function returns the maximum value of all values in the group. The maximum value is the value that would be returned last in an ORDER BY on the same column. Aggregate max() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">max()集約関数は、グループ内のすべての値の最大値を返します。最大値は、同じ列の ORDER BY で最後に返される値となります。集約関数 max()は、グループ内に NULL 以外の値が存在しない場合にのみ NULL を返します。</target>
        </trans-unit>
        <trans-unit id="259079b25b4ee53dd3af62dccf64b88cf7401fe7" translate="yes" xml:space="preserve">
          <source>The maximum allowed value for the 'automerge' parameter is 16. The default value is 4. Setting the 'automerge' parameter to 0 disables the automatic incremental merging of b-trees altogether.</source>
          <target state="translated">automerge' パラメータの最大値は 16 です。automerge' パラメータを 0 に設定すると、b-木の自動増分マージが完全に無効になります。</target>
        </trans-unit>
        <trans-unit id="99bed95a8c8918c9ad675486624a0ec50cca0b55" translate="yes" xml:space="preserve">
          <source>The maximum amount of general-purpose memory needed by the application is determined by such factors as how many simultaneous open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects the application uses, and on the complexity of the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. For any given application, these factors are normally fixed and can be determined experimentally using &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;. A typical application might only use about 40KB of general-purpose memory. This gives a value of &lt;b&gt;N&lt;/b&gt; of around 100KB.</source>
          <target state="translated">アプリケーションが必要とする汎用メモリの最大量は、アプリケーションが使用する同時オープン&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;オブジェクトの数、&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメントの&lt;/a&gt;複雑さなどの要因によって決まります。特定のアプリケーションでは、これらの要素は通常固定されており、&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;を使用して実験的に決定できます。一般的なアプリケーションでは、約40KBの汎用メモリしか使用しない場合があります。これにより、&lt;b&gt;N&lt;/b&gt;の値は約100KBになります。</target>
        </trans-unit>
        <trans-unit id="a9b767b87a835989935611d9f91af0a49ef22427" translate="yes" xml:space="preserve">
          <source>The maximum and minimum embedded payload fractions and the leaf payload fraction values must be 64, 32, and 32. These values were originally intended to be tunable parameters that could be used to modify the storage format of the b-tree algorithm. However, that functionality is not supported and there are no current plans to add support in the future. Hence, these three bytes are fixed at the values specified.</source>
          <target state="translated">埋め込みペイロードフラクションの最大値と最小値、およびリーフペイロードフラクションの値は、64、32、32でなければなりません。これらの値は元々、b-tree アルゴリズムの保存形式を変更するために使用できる調整可能なパラメータであることを意図していましたが、その機能はサポートされておらず、将来的にサポートを追加する予定はありません。しかし、その機能はサポートされておらず、将来的にサポートを追加する予定はありません。したがって、これら3つのバイトは指定された値に固定されています。</target>
        </trans-unit>
        <trans-unit id="3b75dd01c336dd48a91229fb4fe465cfca0656d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of an expression tree can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) interface if the SQLITE_MAX_EXPR_DEPTH is initially positive. In other words, the maximum expression depth can be lowered at run-time if there is already a compile-time limit on the expression depth. If SQLITE_MAX_EXPR_DEPTH is set to 0 at compile time (if the depth of expressions is unlimited) then the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) is a no-op.</source>
          <target state="translated">式ツリーの最大深さを使用して実行時に低下させることができる&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（DB、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt; SQLITE_MAX_EXPR_DEPTHが最初に正の場合、サイズ）インタフェースを。言い換えると、式の深さにコンパイル時の制限が既にある場合、実行時に最大の式の深さを下げることができます。SQLITE_MAX_EXPR_DEPTHがコンパイル時に0に設定されている場合（式の深さが無制限の場合）、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;、size）は何もしません。</target>
        </trans-unit>
        <trans-unit id="7601f568790af4a666771d9637268d8679fb90bb" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursion for triggers.</source>
          <target state="translated">トリガーの再帰の最大深度。</target>
        </trans-unit>
        <trans-unit id="f7ca88d6870cff0eca30922b0b5339bd065f10ca" translate="yes" xml:space="preserve">
          <source>The maximum depth of the parse tree on any expression.</source>
          <target state="translated">任意の式の解析木の最大深度を指定します。</target>
        </trans-unit>
        <trans-unit id="2e6bbb757edd69dcf67031bc6d4f260f516ed8d0" translate="yes" xml:space="preserve">
          <source>The maximum host parameter number can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,size) interface.</source>
          <target state="translated">ホストパラメータの最大数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="b3e774d908522cebf9bd7f7f3469b3fb31276410" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQLステートメント内の任意の&lt;a href=&quot;../lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;の最大インデックス番号。</target>
        </trans-unit>
        <trans-unit id="32a6d72e37d636464c2192cbf409c3425887feb6" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQLステートメント内の任意の&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;の最大インデックス番号。</target>
        </trans-unit>
        <trans-unit id="ab2a11cb65d0770d55a8b43b094028bd3c341a46" translate="yes" xml:space="preserve">
          <source>The maximum length of a LIKE or GLOB pattern can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">LIKEまたはGLOBパターンの最大長は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;、size）インターフェースを使用して、実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="d765036961e5dc86e0ba5117af47c297fab27c55" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">SQLステートメントの最大長は、実行時に&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;、size）インターフェースを使用して下げることができます。</target>
        </trans-unit>
        <trans-unit id="d303fbf5ebde80b928a0a149ac1d360f8b2d9beb" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement, in bytes.</source>
          <target state="translated">SQL 文の最大長をバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="c8feb93491c3d188a9985624d09a15796f2e0e57" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;または&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;演算子へのパターン引数の最大長。</target>
        </trans-unit>
        <trans-unit id="1ee02be23a19dec285dd5109a44c64362161f0e7" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;または&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;演算子へのパターン引数の最大長。</target>
        </trans-unit>
        <trans-unit id="b23da6f4323ba72ffe46e74c0191923768cdb864" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;../lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang_attach&quot;&gt;接続されているデータベース&lt;/a&gt;の最大数。</target>
        </trans-unit>
        <trans-unit id="b544569d59df80608bd6a41e19a745bdff4577b6" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;接続されているデータベース&lt;/a&gt;の最大数。</target>
        </trans-unit>
        <trans-unit id="471b9bc71d47534b60a1c278c46d4cee7c9664ba" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments in a function can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;,size) interface.</source>
          <target state="translated">関数の引数の最大数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="00eff3b06f801e572f28af21289c2619b46c2f08" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments on a function.</source>
          <target state="translated">関数の最大引数数。</target>
        </trans-unit>
        <trans-unit id="b6c416e24701b8851e7053c0bb7cd7dd6b331315" translate="yes" xml:space="preserve">
          <source>The maximum number of attached databases can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;,size) interface.</source>
          <target state="translated">接続されているデータベースの最大数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="0b6c3c6cf8605d1353c6caeac57deb9da3ed0c6e" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">単一の&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;が開始できる補助ワーカースレッドの最大数。</target>
        </trans-unit>
        <trans-unit id="66f8c3a081d879e272abf19945402c6cac2a7ecc" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">単一の&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;が開始できる補助ワーカースレッドの最大数。</target>
        </trans-unit>
        <trans-unit id="bbb454e2483711c9ac94945a0c80d3f47e450874" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in a string or BLOB in SQLite is defined by the preprocessor macro SQLITE_MAX_LENGTH. The default value of this macro is 1 billion (1 thousand million or 1,000,000,000). You can raise or lower this value at compile-time using a command-line option like this:</source>
          <target state="translated">SQLite の文字列または BLOB の最大バイト数は、プリプロセッサ マクロ SQLITE_MAX_LENGTH によって定義されます。このマクロの既定値は 10 億 (1,000,000,000,000 または 1,000,000,000)です。コンパイル時にこの値を上げたり下げたりするには、次のようなコマンドラインオプションを使用します。</target>
        </trans-unit>
        <trans-unit id="da1ee68dd77283238b55af162c380f02592134ee" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in the text of an SQL statement is limited to SQLITE_MAX_SQL_LENGTH which defaults to 1000000. You can redefine this limit to be as large as the smaller of SQLITE_MAX_LENGTH and 1073741824.</source>
          <target state="translated">SQL 文のテキスト内の最大バイト数は、SQLITE_MAX_SQL_LENGTH に制限されています。この制限を SQLITE_MAX_LENGTH と 1073741824 のいずれか小さい方のサイズに再定義することができます。</target>
        </trans-unit>
        <trans-unit id="6345ddabb514350f3e36f681af647ea84308cf28" translate="yes" xml:space="preserve">
          <source>The maximum number of columns can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,size) interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;、size）インターフェースを使用して、実行時に列の最大数を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="1c620a336050426a95c894972afda47b3aee66a2" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">テーブル定義または&lt;a href=&quot;../lang_select&quot;&gt;SELECTの&lt;/a&gt;結果セット内の列の最大数、またはインデックス内、またはORDER BY句またはGROUP BY句内の列の最大数。</target>
        </trans-unit>
        <trans-unit id="355eec7f9bb7446523a2374f005ae8119aa229d8" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">テーブル定義または&lt;a href=&quot;lang_select&quot;&gt;SELECTの&lt;/a&gt;結果セット内の列の最大数、またはインデックス内、またはORDER BY句またはGROUP BY句内の列の最大数。</target>
        </trans-unit>
        <trans-unit id="8374b8e68f54521ffc214c5ed7e8c2d7fd95f1b7" translate="yes" xml:space="preserve">
          <source>The maximum number of compound SELECT terms can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;,size) interface.</source>
          <target state="translated">複合SELECT用語の最大数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="63cbc7c9607d5bbb2a5e8441eb06e668604fc05c" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">SQLステートメントの実装に使用される仮想マシンプログラム内の命令の最大数。場合&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または同等の試みは、単一のプリペアドステートメントでは、この多くのオペコードより多くのスペースを割り当てるために、SQLITE_NOMEMエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="3914cdf98f328c74ff19ff41972588f848a7b49e" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">SQLステートメントの実装に使用される仮想マシンプログラム内の命令の最大数。場合&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または同等の試みは、単一のプリペアドステートメントでは、この多くのオペコードより多くのスペースを割り当てるために、SQLITE_NOMEMエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="7c57be7916f18cb9fd931235954ed49b10f67a38" translate="yes" xml:space="preserve">
          <source>The maximum number of terms in a compound SELECT statement.</source>
          <target state="translated">複合SELECT文の最大項数。</target>
        </trans-unit>
        <trans-unit id="6409e263b558e4fc8032ff274ccb7661be29c559" translate="yes" xml:space="preserve">
          <source>The maximum number of tokens in the returned text. This must be greater than zero and equal to or less than 64.</source>
          <target state="translated">返されるテキスト内のトークンの最大数。これはゼロより大きく、64以下でなければなりません。</target>
        </trans-unit>
        <trans-unit id="970d6e67d87a8bc5f32df0c8fe5b2ab66eff4335" translate="yes" xml:space="preserve">
          <source>The maximum parameter number is set at compile-time by the &lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt; macro. An individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; D can reduce its maximum parameter number below the compile-time maximum using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,...) interface.</source>
          <target state="translated">最大パラメーター数は、コンパイル時に&lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt;マクロによって設定されます。個々の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dは、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（D、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;、...）インターフェースを使用して、最大パラメーター数をコンパイル時の最大数より少なくすることができます。</target>
        </trans-unit>
        <trans-unit id="eeb9b32b1bfb4a0ced4bb9bc2aaa054c3abdfc92" translate="yes" xml:space="preserve">
          <source>The maximum size of any string or BLOB or table row, in bytes.</source>
          <target state="translated">文字列、BLOB、テーブル行の最大サイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="c7f288d6ab417ac4a35975a5356fac79645319c2" translate="yes" xml:space="preserve">
          <source>The maximum string or BLOB length can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">文字列またはBLOBの最大長は、実行時に&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;、size）インターフェイスを使用して下げることができます。</target>
        </trans-unit>
        <trans-unit id="5cc8ccfaed1025b2039c6bdfd6b0a5399eacb5ca" translate="yes" xml:space="preserve">
          <source>The meanings for all $nResCode result code values are shown below, in numeric order.</source>
          <target state="translated">すべての$nResCode結果コード値の意味は、数値順に以下に示されています。</target>
        </trans-unit>
        <trans-unit id="acfaa39aa41d2de54931d409a9de16ab158bc08a" translate="yes" xml:space="preserve">
          <source>The meanings of these various return values are as follows:</source>
          <target state="translated">これらの様々な戻り値の意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3594f845ca8155469ebf0d3a1db0993f4bb9cbd1" translate="yes" xml:space="preserve">
          <source>The measurements in this article were made during the week of 2017-06-05 using a version of SQLite in between 3.19.2 and 3.20.0. You may expect future versions of SQLite to perform even better.</source>
          <target state="translated">この記事の測定は、2017-06-05の週に、3.19.2から3.20.0の間のバージョンのSQLiteを使用して行われました。将来のバージョンの SQLite がさらに良いパフォーマンスを発揮することを期待してもいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="e788358e2ac74022367111d33deb5ddc9a976282" translate="yes" xml:space="preserve">
          <source>The memory corruption problem becomes more acute when using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt;. When all or part of the database file is mapped into the application's address space, then a stray pointer that overwrites any part of that mapped space will immediately corrupt the database file, without requiring the application to do a subsequent write() system call.</source>
          <target state="translated">メモリ&lt;a href=&quot;mmap&quot;&gt;マップI / O&lt;/a&gt;を使用すると、メモリ破損の問題がさらに深刻になります。データベースファイルのすべてまたは一部がアプリケーションのアドレススペースにマップされると、そのマップされたスペースの一部を上書きする浮遊ポインタは、アプリケーションが後続のwrite（）システムコールを実行しなくても、データベースファイルをすぐに破損します。</target>
        </trans-unit>
        <trans-unit id="1f25753cb6dacb02b829c0a340f5d35891b7f9cb" translate="yes" xml:space="preserve">
          <source>The memory footprint of the application can be dramatically reduced by only loading content that is relevant to the current display and keeping the bulk of the content on disk. The fast query capability of SQLite make this a viable alternative to keeping all content in memory at all times. And when applications use less memory, it makes the entire computer more responsive, further enhancing the user experience.</source>
          <target state="translated">現在の表示に関連するコンテンツのみをロードし、コンテンツの大部分をディスク上に保持することで、アプリケーションのメモリフットプリントを劇的に削減することができます。SQLite の高速なクエリ機能により、これはすべてのコンテンツを常にメモリに保持する代わりに実行可能な代替手段となります。また、アプリケーションのメモリ使用量が減れば、コンピュータ全体の応答性が向上し、ユーザー体験をさらに向上させることができます。</target>
        </trans-unit>
        <trans-unit id="9d3e4b06e9105ca7c88a4e1edabcb69936b1841b" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">メモリハイウォーターマークの現在の値にリセットされ&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;（）sqlite3_memory_used&lt;/a&gt;場合とにパラメータ場合のみ&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（）は&lt;/a&gt;真です。&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（1）&lt;/a&gt;によって返される値は、リセット前の最高水準点です。</target>
        </trans-unit>
        <trans-unit id="cd5593ab95a8d1e1ac6cc8d242678782f1a535e8" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">メモリハイウォーターマークの現在の値にリセットされ&lt;a href=&quot;memory_highwater&quot;&gt;（）sqlite3_memory_used&lt;/a&gt;場合とにパラメータ場合のみ&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（）は&lt;/a&gt;真です。&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（1）&lt;/a&gt;によって返される値は、リセット前の最高水準点です。</target>
        </trans-unit>
        <trans-unit id="a98788d1208d8031c1910803fa2f1051d600b111" translate="yes" xml:space="preserve">
          <source>The memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function.</source>
          <target state="translated">宣言型と照合順序のために返された文字ポインタが指すメモリは、次に任意の SQLite API 関数を呼び出すまで有効です。</target>
        </trans-unit>
        <trans-unit id="523aa17230ae599153575b20eede454c13803757" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc（）、sqlite3_realloc（）、sqlite3_malloc64（）、およびsqlite3_realloc64（）によって返されるメモリは、常に少なくとも8バイトの境界に、または&lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt;コンパイル時オプションが使用されている場合は4バイトの境界に揃えられます。</target>
        </trans-unit>
        <trans-unit id="0b4a85ec728749e1396a0209dbea3173ce995dba" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc（）、sqlite3_realloc（）、sqlite3_malloc64（）、およびsqlite3_realloc64（）によって返されるメモリは、常に少なくとも8バイトの境界に、または&lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt;コンパイル時オプションが使用されている場合は4バイトの境界に揃えられます。</target>
        </trans-unit>
        <trans-unit id="d4065cde811c203e3d250a3f54d5601da517866b" translate="yes" xml:space="preserve">
          <source>The memsys5 allocator is designed for use on embedded systems, though there is nothing to prevent its use on workstations. The szBuf is typically between a few hundred kilobytes up to a few dozen megabytes, depending on system requirements and memory budget.</source>
          <target state="translated">memsys5 アロケータは組み込みシステム用に設計されていますが、ワークステーションでの使用を妨げるものは何もありません。szBuf は、システム要件とメモリ予算に応じて、通常数百キロバイトから数十メガバイトの間です。</target>
        </trans-unit>
        <trans-unit id="15e755d3b15a2797fc8e730750dc9e96957bcf11" translate="yes" xml:space="preserve">
          <source>The min() aggregate function returns the minimum non-NULL value of all values in the group. The minimum value is the first non-NULL value that would appear in an ORDER BY of the column. Aggregate min() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">min()集約関数は、グループ内のすべての値のうち、最小の非NULL値を返します。最小値は、列の ORDER BY に現れる最初の非 NULL 値となります。集約関数 min()は、グループ内に non-NULL 値が存在しない場合にのみ NULL を返します。</target>
        </trans-unit>
        <trans-unit id="114a5a7dbd98c187abf7e68d111172546895bf6d" translate="yes" xml:space="preserve">
          <source>The min/max-value pair columns are stored as 32-bit floating point values for &quot;rtree&quot; virtual tables or as 32-bit signed integers in &quot;rtree_i32&quot; virtual tables. Unlike regular SQLite tables which can store data in a variety of datatypes and formats, the R*Tree rigidly enforce these storage types. If any other type of value is inserted into such a column, the r-tree module silently converts it to the required type before writing the new record to the database.</source>
          <target state="translated">min/max-valueペアのカラムは、&quot;rtree &quot;仮想テーブルでは32ビット浮動小数点値として、&quot;rtree_i32 &quot;仮想テーブルでは32ビット符号付き整数として格納されます。様々なデータ型や形式でデータを格納できる通常のSQLiteテーブルとは異なり、R*Treeではこれらの格納型を厳密に強制しています。他のタイプの値がそのような列に挿入された場合、r-treeモジュールは、新しいレコードをデータベースに書き込む前に、それを必要なタイプに静かに変換します。</target>
        </trans-unit>
        <trans-unit id="697dd64d2ba004e05302a199cbf94ae930397047" translate="yes" xml:space="preserve">
          <source>The minimum &quot;three+four&quot; value</source>
          <target state="translated">3+4」の最小値</target>
        </trans-unit>
        <trans-unit id="4344744cb5e4e7fe1c07e4d9e9f4f1a35db07ca5" translate="yes" xml:space="preserve">
          <source>The minimum size of an SQLite database is one page for each table and each index. With a larger page size, the size of an empty database for a given schema will grow by a factor of four, therefore. However, once the database begins to fill with content the size of the older 1024-byte page databases and the newer 4096-byte page databases will quickly converge. Due to relaxed bin-packing constraints, the 4096-byte page size might actually result in a smaller file, once substantial content is added.</source>
          <target state="translated">SQLite データベースの最小サイズは、各テーブルと各インデックスに対して 1 ページです。ページサイズが大きくなると、与えられたスキーマの空のデータベースのサイズは4倍になります。しかし、データベースがコンテンツで満たされ始めると、1024バイトの古いページデータベースと4096バイトの新しいページデータベースのサイズはすぐに収束します。ビンパッキングの制約が緩和されているため、4096バイトのページサイズは、実質的なコンテンツが追加されると、実際にはより小さなファイルになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e5d2ce57cb5bfbf79b3c98a499658be04c3e7756" translate="yes" xml:space="preserve">
          <source>The minor version number Y was historically incremented for new features and/or new interfaces that did not significantly change the structure of the code. The addition of &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; are all examples of &quot;minor&quot; changes. Again, the distinction between &quot;major&quot; and &quot;minor&quot; is subjective.</source>
          <target state="translated">マイナーバージョン番号Yは、コードの構造を大幅に変更しなかった新しい機能や新しいインターフェイス、あるいはその両方のために歴史的に増加しました。追加&lt;a href=&quot;lang_with&quot;&gt;共通テーブル式&lt;/a&gt;、&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;、および&lt;a href=&quot;expridx&quot;&gt;式のインデックスは&lt;/a&gt;「マイナー」の変更のすべての例です。繰り返しますが、「メジャー」と「マイナー」の区別は主観的です。</target>
        </trans-unit>
        <trans-unit id="daac53b800202886e5a1bc16ab5a5eb44a3f8d4d" translate="yes" xml:space="preserve">
          <source>The mirror is an incremental export of the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;canonical Fossil repository&lt;/a&gt; for SQLite. A cron-job updates the GitHub repository once an hour. This is a one-way, read-only code mirror. No pull requests or changes are accepted via GitHub. The GitHub repository merely copies the content from the Fossil repository. All changes are input via Fossil.</source>
          <target state="translated">ミラーは、SQLiteの&lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;正規化されたFossilリポジトリの&lt;/a&gt;増分エクスポートです。 cronジョブは、GitHubリポジトリを1時間に1回更新します。これは、一方向の読み取り専用コードミラーです。 GitHub経由でのプルリクエストや変更は受け付けられません。 GitHubリポジトリは、Fossilリポジトリからコンテンツをコピーするだけです。すべての変更はFossilを介して入力されます。</target>
        </trans-unit>
        <trans-unit id="8699fa6e48270c38aaec7f72b7768d7c856e3da2" translate="yes" xml:space="preserve">
          <source>The mmap_size is set separately for each database file using the &quot;&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;&quot; statement. The usual default mmap_size is zero, meaning that memory mapped I/O is disabled by default. However, the default mmap_size can be increased either at compile-time using the &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; macro or at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,...) interface.</source>
          <target state="translated">mmap_sizeは、「&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;」ステートメントを使用して、データベースファイルごとに個別に設定されます。通常のデフォルトmmap_sizeはゼロです。つまり、メモリマップI / Oはデフォルトで無効になっています。ただし、デフォルトのmmap_sizeは、コンパイル時に&lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt;マクロを使用して、または開始時に&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;、...）インターフェースを使用して増やすことができます。</target>
        </trans-unit>
        <trans-unit id="bc3aa8081ad975eaa64522ee2647fdff6a383213" translate="yes" xml:space="preserve">
          <source>The mode query parameter determines if the new database is opened read-only, read-write, read-write and created if it does not exist, or that the database is a pure in-memory database that never interacts with disk, respectively.</source>
          <target state="translated">モードクエリパラメータは、新しいデータベースがオープンされているかどうか、存在しない場合はリードオンリー、リードライト、リードライト、作成されているかどうか、あるいは、データベースがディスクとは決して相互作用しない純粋なインメモリデータベースであるかどうかをそれぞれ決定します。</target>
        </trans-unit>
        <trans-unit id="f2526ac46e681fb29c61b97dfb71933e5d3d8f00" translate="yes" xml:space="preserve">
          <source>The modifications made to each row affected by an UPDATE statement are determined by the list of assignments following the SET keyword. Each assignment specifies a column-name to the left of the equals sign and a scalar expression to the right. For each affected row, the named columns are set to the values found by evaluating the corresponding scalar expressions. If a single column-name appears more than once in the list of assignment expressions, all but the rightmost occurrence is ignored. Columns that do not appear in the list of assignments are left unmodified. The scalar expressions may refer to columns of the row being updated. In this case all scalar expressions are evaluated before any assignments are made.</source>
          <target state="translated">UPDATE 文によって影響を受ける各行に加えられる変更は、SET キーワードに続く代入のリストによって決定されます。各代入は、等号の左側に列名、右側にスカラ式を指定します。影響を受ける各行について、指定された列は、対応するスカラー式を評価して得られた値に設定されます。1つの列名が代入式のリストに複数回現れた場合、一番右端の列名以外は無視されます。代入式のリストに現れない列は変更されないままになります。スカラー式は更新される行の列を参照している場合があります。この場合、すべてのスカラー式は代入が行われる前に評価されます。</target>
        </trans-unit>
        <trans-unit id="c57c56215c73a95bddb16c7f419303a4f511dbe2" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">モジュール名は、最初のパラメーターで指定された&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続に&lt;/a&gt;登録されます。モジュールの名前は2番目のパラメーターで指定されます。 3番目のパラメータは、&lt;a href=&quot;#sqlite3_module&quot;&gt;仮想テーブルモジュールの&lt;/a&gt;実装へのポインタです。 4番目のパラメーターは、新しい仮想テーブルが作成または再初期化されるときに仮想テーブルモジュールの&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;および&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;メソッドに渡される任意のクライアントデータポインターです。</target>
        </trans-unit>
        <trans-unit id="f7d008fdf7032ca8558d613dfe5b4ba03ec8869a" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">モジュール名は、最初のパラメーターで指定された&lt;a href=&quot;sqlite3&quot;&gt;データベース接続に&lt;/a&gt;登録されます。モジュールの名前は2番目のパラメーターで指定されます。 3番目のパラメータは、&lt;a href=&quot;module&quot;&gt;仮想テーブルモジュールの&lt;/a&gt;実装へのポインタです。 4番目のパラメーターは、新しい仮想テーブルが作成または再初期化されるときに仮想テーブルモジュールの&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;および&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;メソッドに渡される任意のクライアントデータポインターです。</target>
        </trans-unit>
        <trans-unit id="c29884604bb765a8ff66e73918a8eec45479c155" translate="yes" xml:space="preserve">
          <source>The module name must be changed from &quot;fts3&quot; or &quot;fts4&quot; to &quot;fts5&quot;.</source>
          <target state="translated">モジュール名を &quot;fts3 &quot;または &quot;fts4 &quot;から &quot;fts5 &quot;に変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea30bfabecd455dc9fb80bfe26599d0bf2066398" translate="yes" xml:space="preserve">
          <source>The module structure contains methods that are invoked by SQLite to perform various actions on the virtual table such as creating new instances of a virtual table or destroying old ones, reading and writing data, searching for and deleting, updating, or inserting rows. The module structure is explained in more detail below.</source>
          <target state="translated">モジュール構造には、仮想テーブルの新規インスタンスの作成や古いインスタンスの破棄、データの読み書き、行の検索や削除、更新、挿入など、仮想テーブル上で様々なアクションを実行するためにSQLiteによって呼び出されるメソッドが含まれています。モジュールの構造については、以下で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="e7e8ce1834b0e39b1a04f1ee58c27c3761f545ea" translate="yes" xml:space="preserve">
          <source>The module structure defines all of the methods for each virtual table object. The module structure also contains the iVersion field which defines the particular edition of the module table structure. Currently, iVersion is always 3 or less, but in future releases of SQLite the module structure definition might be extended with additional methods and in that case the maximum iVersion value will be increased.</source>
          <target state="translated">モジュール構造は、各仮想テーブルオブジェクトのすべてのメソッドを定義します。モジュール構造には、モジュール・テーブル構造の特定のエディションを定義する iVersion フィールドも含まれています。現在のところ、iVersion は常に 3 以下ですが、SQLite の将来のリリースでは、モジュール構造の定義がメソッドを追加して拡張される可能性があり、その場合は iVersion の最大値が増加します。</target>
        </trans-unit>
        <trans-unit id="f82636212897757718a1a7712ed9f6ebe7472ac1" translate="yes" xml:space="preserve">
          <source>The module-name is the name of an object that implements the virtual table. The module-name must be registered with the SQLite database connection using &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; prior to issuing the CREATE VIRTUAL TABLE statement. The module takes zero or more comma-separated arguments. The arguments can be just about any text as long as it has balanced parentheses. The argument syntax is sufficiently general that the arguments can be made to appear as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in a traditional &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. SQLite passes the module arguments directly to the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the module implementation without any interpretation. It is the responsibility of the module implementation to parse and interpret its own arguments.</source>
          <target state="translated">module-nameは、仮想テーブルを実装するオブジェクトの名前です。 module-nameは、CREATE VIRTUAL TABLEステートメントを発行する前に、&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;または&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;を使用してSQLiteデータベース接続に登録する必要があります。モジュールは、0個以上のコンマ区切りの引数を取ります。引数は、括弧が釣り合っている限り、ほぼすべてのテキストにすることができます。引数の構文は十分に一般的であり、引数を従来の&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントの&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定義&lt;/a&gt;として表示することができます。 SQLiteはモジュール引数を&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;と&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnectに&lt;/a&gt;直接渡します解釈なしのモジュール実装のメソッド。独自の引数を解析および解釈するのは、モジュール実装の責任です。</target>
        </trans-unit>
        <trans-unit id="44619ca32ea56419710789f2ec6fc9766c59ac70" translate="yes" xml:space="preserve">
          <source>The most common reason an attempt to obtain a</source>
          <target state="translated">を取得しようとする試みが最も一般的な理由は</target>
        </trans-unit>
        <trans-unit id="b4677e9c54155902987749f94de50b511a297fed" translate="yes" xml:space="preserve">
          <source>The most common way to force an SQLite database to exist purely in memory is to open the database using the special filename &quot;&lt;b&gt;:memory:&lt;/b&gt;&quot;. In other words, instead of passing the name of a real disk file into one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; functions, pass in the string &quot;:memory:&quot;. For example:</source>
          <target state="translated">SQLiteデータベースをメモリ内のみに存在させる最も一般的な方法は、特別なファイル名 &quot; &lt;b&gt;：memory：&lt;/b&gt; &quot; を使用してデータベースを開くことです。つまり、実際のディスクファイルの名前を&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、または&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;関数のいずれかに渡す代わりに、文字列 &quot;：memory：&quot;を渡します。例えば：</target>
        </trans-unit>
        <trans-unit id="03a7919d9a36d839fb3e6c8676819056867ece77" translate="yes" xml:space="preserve">
          <source>The most efficient way to apply changes to a B-Tree (the data structure that SQLite uses to store each table and index on disk) is to make the changes in key order. But if an SQL table has one or more indexes, the key order for each index may be different from the main table and the other auxiliary indexes. As a result, when executing a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements it is not generally possible to order the operations so that all b-trees are updated in key order. The RBU update process works around this by applying all changes to the main table in one pass, then applying changes to each index in separate passes, ensuring each B-Tree is updated optimally. For a large database file (one that does not fit in the OS disk cache) this procedure can result in two orders of magnitude faster updates.</source>
          <target state="translated">Bツリー（SQLiteが各テーブルとインデックスをディスクに格納するために使用するデータ構造）に変更を適用する最も効率的な方法は、キーの順序で変更を加えることです。ただし、SQLテーブルに1つ以上のインデックスがある場合、各インデックスのキーの順序は、メインテーブルや他の補助インデックスとは異なる場合があります。その結果、一連の&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;および&lt;a href=&quot;lang_delete&quot;&gt;DELETEを&lt;/a&gt;実行するとステートメントでは、すべてのbツリーがキーの順序で更新されるように操作を順序付けることは一般に不可能です。 RBU更新プロセスでは、1回のパスでメインテーブルにすべての変更を適用し、次に別のパスで各インデックスに変更を適用することでこれを回避し、各Bツリーが最適に更新されるようにします。大きなデータベースファイル（OSディスクキャッシュに収まらないファイル）の場合、この手順を実行すると、更新が2桁速くなります。</target>
        </trans-unit>
        <trans-unit id="0aab584bc04ad9506143fb4e57b11f24aeb68952" translate="yes" xml:space="preserve">
          <source>The most useful</source>
          <target state="translated">最も便利な</target>
        </trans-unit>
        <trans-unit id="672a287b758e4f6545eeda0d335349088507b997" translate="yes" xml:space="preserve">
          <source>The most useful thing about FTS tables is the queries that may be performed using the built-in full-text index. Full-text queries are performed by specifying a clause of the form &quot;&amp;lt;column&amp;gt; MATCH &amp;lt;full-text query expression&amp;gt;&quot; as part of the WHERE clause of a SELECT statement that reads data from an FTS table. &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;Simple FTS queries&lt;/a&gt; that return all documents that contain a given term are described above. In that discussion the right-hand operand of the MATCH operator was assumed to be a string consisting of a single term. This section describes the more complex query types supported by FTS tables, and how they may be utilized by specifying a more complex query expression as the right-hand operand of a MATCH operator.</source>
          <target state="translated">FTSテーブルについて最も役立つのは、組み込みのフルテキストインデックスを使用して実行できるクエリです。フルテキストクエリは、FTSテーブルからデータを読み取るSELECTステートメントのWHERE句の一部として &quot;&amp;lt;column&amp;gt; MATCH &amp;lt;フルテキストクエリ式&amp;gt;&quot;という形式の句を指定することによって実行されます。特定の用語を含むすべてのドキュメントを返す&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;単純なFTSクエリ&lt;/a&gt;については、上記で説明しています。その説明では、MATCH演算子の右側のオペランドは、単一の用語で構成される文字列であると想定されていました。このセクションでは、FTSテーブルでサポートされるより複雑なクエリの種類と、より複雑なクエリ式をMATCH演算子の右側のオペランドとして指定することで、それらをどのように利用できるかについて説明します。</target>
        </trans-unit>
        <trans-unit id="b952b720a1c68c621b96fa1e29a1ec3a3e91db58" translate="yes" xml:space="preserve">
          <source>The multi-argument max() function returns the argument with the maximum value, or return NULL if any argument is NULL. The multi-argument max() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to max() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;max()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">複数引数のmax（）関数は、最大値の引数を返すか、引数がNULLの場合はNULLを返します。複数引数のmax（）関数は、引数を左から右に検索して、照合関数を定義する引数を探し、その照合関数をすべての文字列比較に使用します。 max（）の引数が照合関数を定義していない場合、BINARY照合関数が使用されます。なお、&lt;b&gt;最大（）は&lt;/b&gt;、それが2つの以上の引数を持っていますが、として動作する場合、単純な機能で&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;集計機能&lt;/a&gt;のみの単一の引数を与えた場合。</target>
        </trans-unit>
        <trans-unit id="4978bfa5c1668418de3cae9f58ae0236b3a923fa" translate="yes" xml:space="preserve">
          <source>The multi-argument min() function returns the argument with the minimum value. The multi-argument min() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to min() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;min()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">複数引数のmin（）関数は、最小値の引数を返します。複数引数のmin（）関数は、引数を左から右に検索して、照合関数を定義する引数を探し、その照合関数をすべての文字列比較に使用します。min（）の引数が照合関数を定義していない場合、BINARY照合関数が使用されます。なお、&lt;b&gt;分（）&lt;/b&gt;が2つの以上の引数を有するが、として動作する場合の単純な関数で&lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;集計機能&lt;/a&gt;のみの単一引数与えられた場合。</target>
        </trans-unit>
        <trans-unit id="78c0cf060a6f9ee3d1106d60ebe5e6c21511776f" translate="yes" xml:space="preserve">
          <source>The multiply operator now correctly detects 64-bit integer overflow and promotes to floating point in all corner-cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt;.</source>
          <target state="translated">乗算演算子が64ビット整数のオーバーフローを正しく検出し、すべてのコーナーケースで浮動小数点に昇格するようになりました。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="ee9132cb0f48417f8650cad9e27fe43d03b0618b" translate="yes" xml:space="preserve">
          <source>The mutation-test.tcl script takes care of all of the details for running a mutation test:</source>
          <target state="translated">mutation-test.tclスクリプトは、突然変異テストを実行するためのすべての詳細を処理します。</target>
        </trans-unit>
        <trans-unit id="2945579c517aa1d3b8ba9d11b0bc3f91de1e9921" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite内のmutexモジュールは、&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;をmutexオブジェクトの抽象型として定義します。SQLiteコアは&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutexの&lt;/a&gt;内部表現を見ることはありません。&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;オブジェクトへのポインタのみを扱います。</target>
        </trans-unit>
        <trans-unit id="d0e09c593f6493d406d9e4e9dcac2eadda30e574" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite内のmutexモジュールは、&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;をmutexオブジェクトの抽象型として定義します。SQLiteコアは&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutexの&lt;/a&gt;内部表現を見ることはありません。&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;オブジェクトへのポインタのみを扱います。</target>
        </trans-unit>
        <trans-unit id="2683feab4dd898006f40d9a775532ccca7b7b569" translate="yes" xml:space="preserve">
          <source>The mxFrame value is always greater than or equal to both &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; and nBackfillAttempted.</source>
          <target state="translated">mxFrameの値は、常に&lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;とnBackfillAttemptedの両方以上です。</target>
        </trans-unit>
        <trans-unit id="ab3c5c72a969cacdc78a3e4dd0229038bdf0e320" translate="yes" xml:space="preserve">
          <source>The mxPathname field is the maximum length of a file pathname that this VFS can use. SQLite sometimes has to preallocate buffers of this size, so it should be as small as reasonably possible. Some filesystems permit huge pathnames, but in practice pathnames rarely extend beyond 100 bytes or so. You do not have to put the longest pathname that the underlying filesystem can handle here. You only have to put the longest pathname that you want SQLite to be able to handle. A few hundred is a good value in most cases.</source>
          <target state="translated">mxPathname フィールドは、この VFS で使用できるファイルパス名の最大長です。SQLite はこのサイズのバッファを事前に確保しなければならないことがあるので、可能な限り小さくしなければなりません。ファイルシステムによっては巨大なパス名を許可しているものもありますが、実際にはパス名が100バイト程度を超えることはほとんどありません。ここには、基礎となるファイルシステムが扱える最長のパス名を指定する必要はありません。SQLiteが扱えるようにしたい最長のパス名を指定すればよいのです。ほとんどの場合、数百程度が良い値となります。</target>
        </trans-unit>
        <trans-unit id="cb1334872e71aa02626433d46e5f9130af9a0bfd" translate="yes" xml:space="preserve">
          <source>The nArg parameter specifies the number of arguments to the function. A value of 0 indicates that any number of arguments is allowed. The eTextRep parameter specifies what representation text values are expected to be in for arguments to this function. The value of this parameter should be one of the parameters defined above. SQLite version 3 allows multiple implementations of the same function using different text representations. The database engine chooses the function that minimization the number of text conversions required.</source>
          <target state="translated">nArgパラメータは、関数の引数の数を指定します。0の値は、任意の数の引数が許可されていることを示します。eTextRepパラメータは、この関数への引数に期待される表現テキスト値を指定します。このパラメータの値は、上記で定義したパラメータのいずれかでなければなりません。SQLite バージョン 3 では、異なるテキスト表現を使用して同じ関数を複数実装することができます。データベースエンジンは、必要なテキスト変換の数を最小化する関数を選択します。</target>
        </trans-unit>
        <trans-unit id="15067be8341cb3e5ea308646b0092b9f585804c8" translate="yes" xml:space="preserve">
          <source>The nBackfill can only be increased while holding the WAL_CKPT_LOCK. However, nBackfill is changed to zero during a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt;, and this happens while holding the WAL_WRITE_LOCK.</source>
          <target state="translated">nBackfillは、WAL_CKPT_LOCKを押している間だけ増やすことができます。ただし、nBackfillは&lt;a href=&quot;fileformat2#walreset&quot;&gt;WALリセット&lt;/a&gt;中にゼロに変更され、これはWAL_WRITE_LOCKを保持している間に発生します。</target>
        </trans-unit>
        <trans-unit id="99673f4f335d79523c7b7494142bf07ba1cd84e2" translate="yes" xml:space="preserve">
          <source>The nBackfill number is never greater than &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;. When nBackfill equals &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;, that means that the WAL content has been completely written back into the database and it is ok to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if there are no locks held on any of WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">nBackfill番号がより大きくなることはありません&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;。nBackfillが&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;と等しい場合、つまり、WALコンテンツがデータベースに完全に書き戻されており、N&amp;gt; 0のWAL_READ_LOCK（N）のいずれかでロックが保持されていない場合は&lt;a href=&quot;fileformat2#walreset&quot;&gt;、WAL&lt;/a&gt;をリセットしても問題ありません。</target>
        </trans-unit>
        <trans-unit id="58aea584e25c7551e85c617c6b8537adc3f19238" translate="yes" xml:space="preserve">
          <source>The name &quot;memsys5&quot; used for the zero-malloc memory allocator implies that there are several additional memory allocators available, and indeed there are. The default memory allocator is &quot;memsys1&quot;. The debugging memory allocator is &quot;memsys2&quot;. Those have already been covered.</source>
          <target state="translated">ゼロマロクメモリアロケータに使用される「memsys5」という名前は、利用可能なメモリアロケータがいくつか追加されていることを暗示していますが、実際にはいくつかあります。デフォルトのメモリアロケータは「memsys1」である。デバッグ用のメモリアロケータは &quot;memsys2&quot; です。これらについてはすでに説明しています。</target>
        </trans-unit>
        <trans-unit id="5db0afbba9901c1e9e8534384d38571355c85857" translate="yes" xml:space="preserve">
          <source>The name for the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; used to compare values in the index-column.</source>
          <target state="translated">インデックス列の値を比較するために使用される&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;の名前。</target>
        </trans-unit>
        <trans-unit id="d0a42cf139ce30315511c41a36a93d913d4ae81d" translate="yes" xml:space="preserve">
          <source>The name of a result column is the value of the &quot;AS&quot; clause for that column, if there is an AS clause. If there is no AS clause then the name of the column is unspecified and may change from one release of SQLite to the next.</source>
          <target state="translated">結果カラムの名前は、AS節がある場合はそのカラムの &quot;AS &quot;節の値となります。AS 句がない場合は、カラムの名前は指定されておらず、SQLite のあるリリースから次のリリースへと変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a57f858acf3d2e5077979e3afa2c8309985a2b90" translate="yes" xml:space="preserve">
          <source>The name of an SQLite database is the name of a file that will contain the database. If the file does not exist, SQLite attempts to create and initialize it. If the file is read-only (due to permission bits or because it is located on read-only media like a CD-ROM) then SQLite opens the database for reading only. The entire SQL database is stored in a single file on the disk. But additional temporary files may be created during the execution of an SQL command in order to store the database rollback journal or temporary and intermediate results of a query.</source>
          <target state="translated">SQLite データベースの名前は、データベースを格納するファイルの名前です。ファイルが存在しない場合、SQLite はファイルの作成と初期化を試みます。ファイルが読み取り専用の場合(パーミッションビットのためか、CD-ROMのような読み取り専用メディアにあるため)、SQLiteはデータベースを読み取り専用に開きます。SQL データベース全体はディスク上の単一のファイルに格納されます。しかし、データベースのロールバックジャーナルやクエリの一時的な結果や中間的な結果を保存するために、SQLコマンドの実行中に追加のテンポラリファイルが作成されることがあります。</target>
        </trans-unit>
        <trans-unit id="2e5f7637f527bcb85ea83184153ee4c57e5bbfca" translate="yes" xml:space="preserve">
          <source>The name of each column in the table.</source>
          <target state="translated">テーブルの各列の名前。</target>
        </trans-unit>
        <trans-unit id="e1e64668404efe0d041f261ba3d958b47753bba4" translate="yes" xml:space="preserve">
          <source>The name of the FTS5 table column that contains the term.</source>
          <target state="translated">用語を含むFTS5テーブル列の名前。</target>
        </trans-unit>
        <trans-unit id="fb2519166ef6466d94c575e04a046d25ae02cbef" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">照合の名前は、sqlite3_create_collat​​ion（）およびsqlite3_create_collat​​ion_v2（）のUTF-8文字列と、sqlite3_create_collat​​ion16（）のネイティブバイトオーダーのUTF-16文字列です。&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;に従って等しいと比較される照合順序名は、同じ名前と見なされます。</target>
        </trans-unit>
        <trans-unit id="7df8bfa2bb01af5c880a238a6167d3b3a1623f37" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">照合の名前は、sqlite3_create_collat​​ion（）およびsqlite3_create_collat​​ion_v2（）のUTF-8文字列と、sqlite3_create_collat​​ion16（）のネイティブバイトオーダーのUTF-16文字列です。&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;に従って等しいと比較される照合順序名は、同じ名前と見なされます。</target>
        </trans-unit>
        <trans-unit id="60f9c38a5b1707739850b72dfb67adc25dbc2069" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed, or NULL if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">インデックスを付ける列の名前、またはindex-columnがインデックスを付けるテーブルの行&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt;または&lt;a href=&quot;expridx&quot;&gt;式の&lt;/a&gt;場合はNULL 。</target>
        </trans-unit>
        <trans-unit id="a2c4a68aabf0cd9d6847a72cb797a421605fdb66" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed. This columns is NULL if the column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">インデックスを付ける列の名前。列が&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;または&lt;a href=&quot;expridx&quot;&gt;式の&lt;/a&gt;場合、この列はNULLです。</target>
        </trans-unit>
        <trans-unit id="2755fad1da17fab976d4effee601e3a0ced598c2" translate="yes" xml:space="preserve">
          <source>The name of the column that contains the term instance.</source>
          <target state="translated">用語のインスタンスを含む列の名前。</target>
        </trans-unit>
        <trans-unit id="d4c672f643ac02f7fa3683763e45ddf698d1be4b" translate="yes" xml:space="preserve">
          <source>The name of the database is usually just the name of a disk file in which the database is stored. If the name of the database is the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; then a new database is created in memory. If the name of the database is an empty string, then the database is created in an empty file that is automatically deleted when the database connection closes. &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; can be used if the &quot;&lt;b&gt;-uri yes&lt;/b&gt;&quot; option is supplied on the &lt;b&gt;sqlite3&lt;/b&gt; command.</source>
          <target state="translated">データベースの名前は通常、データベースが格納されているディスクファイルの名前です。データベースの名前が特別な名前 &quot; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &quot;の場合、新しいデータベースがメモリ内に作成されます。データベースの名前が空の文字列の場合、データベースは空のファイルに作成され、データベース接続が閉じたときに自動的に削除されます。&lt;b&gt;sqlite3&lt;/b&gt;コマンドで&quot; &lt;b&gt;-uri yes&lt;/b&gt; &quot;オプションが指定されている場合、&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;を使用できます。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="638ad72e8f8e6b978d1b5c7a5434bac446aa668c" translate="yes" xml:space="preserve">
          <source>The name of the database on which the transaction was committed</source>
          <target state="translated">トランザクションがコミットされたデータベースの名前</target>
        </trans-unit>
        <trans-unit id="b53c39aeaa16a31f4a835cb5ee0c4ef2cb1c4ca7" translate="yes" xml:space="preserve">
          <source>The name of the database table,</source>
          <target state="translated">データベーステーブルの名前です。</target>
        </trans-unit>
        <trans-unit id="1389d8d4ecdcdbedac7a4549e6a07ae7ad0ad26c" translate="yes" xml:space="preserve">
          <source>The name of the database which is being changed</source>
          <target state="translated">変更されるデータベースの名前</target>
        </trans-unit>
        <trans-unit id="fc047e5a2c9d6a845176aac031ed03d6a1b50ee2" translate="yes" xml:space="preserve">
          <source>The name of the desired tokenizer should be substituted in place of 'porter' in the example, of course. If the tokenizer requires one or more arguments, they should be separated by commas in the fts3tokenize declaration (even though they are separated by spaces in declarations of regular fts4 tables). The following creates fts4 and fts3tokenize tables that use the same tokenizer:</source>
          <target state="translated">もちろん、この例では 'PORTER' の代わりに、目的のトークナイザーの名前を代入する必要があります。トークン化器が1つ以上の引数を必要とする場合は、fts3tokenize宣言ではカンマで区切らなければなりません(通常のfts4テーブルの宣言ではスペースで区切られていますが)。以下は、同じトークナイザーを使用する fts4 と fts3tokenize テーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="9a63a9136665984fc122cf635a36ad0166ead67d" translate="yes" xml:space="preserve">
          <source>The name of the index.</source>
          <target state="translated">インデックスの名前。</target>
        </trans-unit>
        <trans-unit id="c2412b63f15e8dfde7222fa76ad9e5504c06aea1" translate="yes" xml:space="preserve">
          <source>The name of the new table.</source>
          <target state="translated">新しいテーブルの名前。</target>
        </trans-unit>
        <trans-unit id="a12d264e140fa64a7adf3172f5ec27d60bbcedb0" translate="yes" xml:space="preserve">
          <source>The name of the result column is a combination of the source table and source column name: TABLE.COLUMN</source>
          <target state="translated">結果カラムの名前は、ソーステーブルとソースカラム名を組み合わせたものです:TABLE.COLUMN</target>
        </trans-unit>
        <trans-unit id="85777de7d38bf8fc5dfa8258c31af44f8a1c7698" translate="yes" xml:space="preserve">
          <source>The name of the table contains one or more &quot;_&quot; characters.</source>
          <target state="translated">テーブル名には、1つ以上の&quot;_&quot;文字が含まれています。</target>
        </trans-unit>
        <trans-unit id="d14fb34ff4c810e0436eba6520cbeda0158f9e95" translate="yes" xml:space="preserve">
          <source>The name of the table data is read from.</source>
          <target state="translated">読み込んだテーブルデータの名前です。</target>
        </trans-unit>
        <trans-unit id="a43b536a14c1d7b3d8b50ac0e9b44a83e9c467f9" translate="yes" xml:space="preserve">
          <source>The name of the table in which the xColumnSize values are stored (unless columnsize=0 is specified) is &quot;&amp;lt;name&amp;gt;_docsize&quot;, where &amp;lt;name&amp;gt; is the name of the FTS5 table itself. The &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt; tool may be used on an existing database in order to determine how much space might be saved by recreating an FTS5 table using columnsize=0.</source>
          <target state="translated">xColumnSize値が格納されているテーブルの名前（columnsize = 0が指定されていない場合）は &quot;&amp;lt;name&amp;gt; _docsize&quot;です。ここで、&amp;lt;name&amp;gt;はFTS5テーブル自体の名前です。&lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzerの&lt;/a&gt;ツールは、ColumnSizeが= 0を使用してFTS5テーブルを再作成することによって保存される可能性がありますどのくらいのスペースを決定するために、既存のデータベースで使用することができます。</target>
        </trans-unit>
        <trans-unit id="b9dba3fb9b44494b1bade858ebafe1459aa85475" translate="yes" xml:space="preserve">
          <source>The name of the table to be modified in an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement must be an unqualified table name. In other words, one must use just &quot;</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、または&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;ステートメントで変更されるテーブルの名前は、修飾されていないテーブル名でなければなりません。つまり、「</target>
        </trans-unit>
        <trans-unit id="6e32ef9d959d1305ba25656ee3bbcec3b526eef2" translate="yes" xml:space="preserve">
          <source>The name that occurs after the AS keyword is the name of the database used internally by SQLite. The schema-names 'main' and 'temp' refer to the main database and the database used for temporary tables. The main and temp databases cannot be attached or detached.</source>
          <target state="translated">AS キーワードの後に来る名前は、SQLite が内部的に使用するデータベースの名前です。スキーマ名「main」と「temp」は、メイン・データベースと一時テーブルに使用されるデータベースを参照します。main データベースと temp データベースは、アタッチしたり、切り離したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="c7f1793be68e4540903171531d569a4a7be0fbfa" translate="yes" xml:space="preserve">
          <source>The names and numeric values for existing result codes are fixed and unchanging. However, new result codes, and especially new extended result codes, might appear in future releases of SQLite.</source>
          <target state="translated">既存の結果コードの名前と数値は固定されており、変更はありません。しかし、新しい結果コード、特に新しい拡張された結果コードは、将来のSQLiteのリリースで現れるかもしれません。</target>
        </trans-unit>
        <trans-unit id="6c186656572f2bf1670bbd5a3b99aeadd51bedda" translate="yes" xml:space="preserve">
          <source>The names of the columns are contained in first</source>
          <target state="translated">カラムの名前は、最初の</target>
        </trans-unit>
        <trans-unit id="6e42a281800acf1a1a711bf3baf9388c4ecfa00b" translate="yes" xml:space="preserve">
          <source>The names returned are the original un-aliased names of the database, table, and column.</source>
          <target state="translated">返される名前は、データベース、テーブル、およびカラムの元のエイリアスされていない名前です。</target>
        </trans-unit>
        <trans-unit id="9d972c129d1db380a40044755e84ee7d9ba4bda3" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows an application to customize the behavior of SQLite at run-time. Customizations possible using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; include the following:</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェイスにより、アプリケーションは実行時にSQLiteの動作をカスタマイズできます。&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;を使用して可能なカスタマイズは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3df658c177f1eac56b80fa5f85864ebd817426dc" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface allows an application to query the performance status of SQLite at runtime.</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status（）&lt;/a&gt;インターフェイスにより、アプリケーションは実行時にSQLiteのパフォーマンスステータスをクエリできます。</target>
        </trans-unit>
        <trans-unit id="a8d3b04d8482aa6bd5d923ab36f6fdfe7a6ac1b9" translate="yes" xml:space="preserve">
          <source>The new API for SQLite 3.0 contains routines that accept text as both UTF-8 and UTF-16 in the native byte order of the host machine. Each database file manages text as either UTF-8, UTF-16BE (big-endian), or UTF-16LE (little-endian). Internally and in the disk file, the same text representation is used everywhere. If the text representation specified by the database file (in the file header) does not match the text representation required by the interface routines, then text is converted on-the-fly. Constantly converting text from one representation to another can be computationally expensive, so it is suggested that programmers choose a single representation and stick with it throughout their application.</source>
          <target state="translated">SQLite 3.0 の新しい API には、ホストマシンのネイティブバイト順でテキストを UTF-8 と UTF-16 の両方で受け付けるルーチンが含まれています。各データベースファイルは、テキストを UTF-8、UTF-16BE(ビッグエンディアン)、UTF-16LE(リトルエンディアン)のいずれかで管理します。内部的にもディスクファイル内でも、どこでも同じテキスト表現が使用されます。データベースファイル(ファイルヘッダ内)で指定されたテキスト表現が、インターフェイスルーチンで必要とされるテキスト表現と一致しない場合、テキストはその場で変換されます。常にテキストをある表現から別の表現に変換するのは計算コストがかかりますので、プログラマーは一つの表現を選択して、アプリケーション全体を通してそれを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="30af4368149bbc60ce20946b58b7cfd9adb8ff97" translate="yes" xml:space="preserve">
          <source>The new OS interface for SQLite is built around an object named &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. The &quot;vfs&quot; stands for &quot;Virtual File System&quot;. The sqlite3_vfs object is basically a structure containing pointers to functions that implement the primitive disk I/O operations that SQLite needs to perform in order to read and write databases. In this article, we will often refer to an sqlite3_vfs objects as a &quot;VFS&quot;.</source>
          <target state="translated">SQLiteの新しいOSインターフェイスは、&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;という名前のオブジェクトを中心に構築されています。「vfs」は「仮想ファイルシステム」の略です。sqlite3_vfsオブジェクトは基本的に、データベースの読み書きのためにSQLiteが実行する必要があるプリミティブディスクI / O操作を実装する関数へのポインターを含む構造です。この記事では、sqlite3_vfsオブジェクトを「VFS」と呼ぶことがよくあります。</target>
        </trans-unit>
        <trans-unit id="6c9ac7112282c02c3ac370e4792bfc347f1711f1" translate="yes" xml:space="preserve">
          <source>The new change is ignored. This case does not occur if the new changeset was recorded immediately after the changesets already added to the changegroup.</source>
          <target state="translated">新しい変更は無視されます。このケースは、既に changegroup に追加されたチェンジセットの直後に新しいチェンジセットが記録された場合には発生しません。</target>
        </trans-unit>
        <trans-unit id="81ae31ac06c9efe8e8edfec9e13527250faad45f" translate="yes" xml:space="preserve">
          <source>The new database file format uses B+trees for tables. In a B+tree, all data is stored in the leaves of the tree instead of in both the leaves and the intermediate branch nodes. The use of B+trees for tables allows for better scalability and the storage of larger data fields without the use of overflow pages. Traditional B-trees are still used for indices.</source>
          <target state="translated">新しいデータベースファイルフォーマットでは、テーブルにB+木を使用します。B+木では、すべてのデータは、葉と中間枝ノードの両方に格納されるのではなく、木の葉に格納されます。テーブルにB+木を使用することで、スケーラビリティが向上し、オーバーフローページを使用せずに大きなデータフィールドを保存することができます。従来のB木は、インデックスには今でも使用されています。</target>
        </trans-unit>
        <trans-unit id="31e91eb6ebd1ae009dff2061b0ed5da69f5f04a8" translate="yes" xml:space="preserve">
          <source>The new file format also supports variable pages sizes between 512 and 65536 bytes. The size of a page is stored in the file header so the same library can read databases with different pages sizes, in theory, though this feature has not yet been implemented in practice.</source>
          <target state="translated">新しいファイルフォーマットでは、512バイトから65536バイトまでの可変ページサイズもサポートしています。ページのサイズはファイルヘッダに格納されるので、理論的には、この機能は実際にはまだ実装されていませんが、同じライブラリが異なるページサイズのデータベースを読むことができます。</target>
        </trans-unit>
        <trans-unit id="b7b98e36d84deeda55906998dc0425a8e896c821" translate="yes" xml:space="preserve">
          <source>The new file format omits unused fields from its disk images. For example, indices use only the key part of a B-tree record and not the data. So for indices, the field that records the length of the data is omitted. Integer values such as the length of key and data are stored using a variable-length encoding so that only one or two bytes are required to store the most common cases but up to 64-bits of information can be encoded if needed. Integer and floating point data is stored on the disk in binary rather than being converted into ASCII as in SQLite version 2.8. These changes taken together result in database files that are typically 25% to 35% smaller than the equivalent files in SQLite version 2.8.</source>
          <target state="translated">新しいファイルフォーマットでは、ディスクイメージから未使用のフィールドが省略されます。例えば、インデックスはB-treeレコードのキー部分のみを使用し、データは使用しません。そのため、インデックスの場合、データの長さを記録するフィールドは省略されます。キーの長さやデータの長さなどの整数値は可変長エンコーディングを用いて格納されるため、最も一般的なケースでは1バイトか2バイトで済みますが、必要に応じて64ビットまでの情報をエンコーディングして格納することができます。整数と浮動小数点データは、SQLite バージョン 2.8 のように ASCII に変換されるのではなく、バイナリでディスクに格納されます。これらの変更を合わせると、データベースファイルは SQLite バージョン 2.8 の同等のファイルよりも通常 25% から 35% 小さくなります。</target>
        </trans-unit>
        <trans-unit id="5a8ddfc73fc040315222214bdfe8a3558fe0da52" translate="yes" xml:space="preserve">
          <source>The new interface uses three separate functions to replace the single &lt;b&gt;sqlite_exec&lt;/b&gt; function.</source>
          <target state="translated">新しいインターフェースは、3つの別個の関数を使用して、単一の&lt;b&gt;sqlite_exec&lt;/b&gt;関数を置き換えます。</target>
        </trans-unit>
        <trans-unit id="601cb56433c850ed70120e223ec644602fc957a5" translate="yes" xml:space="preserve">
          <source>The new object is configured with the rebase buffer obtained from sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure(). If the local changeset is to be rebased against multiple remote changesets, then sqlite3rebaser_configure() should be called multiple times, in the same order that the multiple sqlite3changeset_apply_v2() calls were made.</source>
          <target state="translated">新しいオブジェクトは、sqlite3rebaser_configure()を呼び出すことで、sqlite3changeset_apply_v2()から取得したリベースバッファで設定されます。ローカルのチェンジセットが複数のリモートのチェンジセットに対してリベースされる場合、sqlite3rebaser_configure()は、複数のsqlite3changeset_apply_v2()の呼び出しが行われたのと同じ順番で、複数回呼び出されるべきです。</target>
        </trans-unit>
        <trans-unit id="a80319826820a0baa113ed82a7da25195888339a" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">新しい行は、&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）の&lt;/a&gt;場合と同じ基準を満たしている必要があります-存在している必要があり、指定された列にblobまたはテキスト値が格納されている必要があります。新しい行がテーブルに存在しない場合、またはBLOBやテキスト値が含まれていない場合、または別のエラーが発生した場合、SQLiteエラーコードが返され、BLOBハンドルは中止されたと見なされます。後続のすべての呼び出し&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;中断されたブロブハンドルには、直ちにSQLITE_ABORTを返します。中止されたblobハンドルで&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;を呼び出すと、常にゼロが返されます。</target>
        </trans-unit>
        <trans-unit id="1fc9db87ef5146974ffc63aaf19ef4d76ed16ccc" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">新しい行は、&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）の&lt;/a&gt;場合と同じ基準を満たしている必要があります-存在している必要があり、指定された列にblobまたはテキスト値が格納されている必要があります。新しい行がテーブルに存在しない場合、またはBLOBやテキスト値が含まれていない場合、または別のエラーが発生した場合、SQLiteエラーコードが返され、BLOBハンドルは中止されたと見なされます。後続のすべての呼び出し&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（） &lt;/a&gt;、&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;または&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;中断されたブロブハンドルには、直ちにSQLITE_ABORTを返します。中止されたblobハンドルで&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;を呼び出すと、常にゼロが返されます。</target>
        </trans-unit>
        <trans-unit id="477dc8c1b42a8f1f1f9e215976276669879cbe40" translate="yes" xml:space="preserve">
          <source>The new values for each modified field of the row, and</source>
          <target state="translated">行の各変更されたフィールドの新しい値と</target>
        </trans-unit>
        <trans-unit id="9ca11824ed5a21754d9f34df6fca6bca218bd35f" translate="yes" xml:space="preserve">
          <source>The new window definition must not include a PARTITION BY clause. The PARTITION BY clause, if there is one, must be supplied by the base window specification.</source>
          <target state="translated">新しいウィンドウ定義には、PARTITION BY句を含んではならない。PARTITION BY句がある場合は、基本ウィンドウ仕様で与えなければなりません。</target>
        </trans-unit>
        <trans-unit id="f3a9a1d6f9268d0f1362c9fb457875a7fb250370" translate="yes" xml:space="preserve">
          <source>The newer &quot;.eqp trace&quot; command does everything that &quot;.eqp full&quot; does and also turns on &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE tracing&lt;/a&gt;.</source>
          <target state="translated">新しい「.eqp trace」コマンドは、「。eqp full」が実行するすべてのことを実行し、また&lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBEトレース&lt;/a&gt;をオンにします。</target>
        </trans-unit>
        <trans-unit id="fd8ed5a57b50230eec8d4ec2e3e5c1e149c55cc8" translate="yes" xml:space="preserve">
          <source>The newer xQueryFunc callback receives more information from the r-tree query engine on each call, and it sends more information back to the query engine before it returns. To help keep the interface manageable, the xQueryFunc callback sends and receives information from the query engine as fields in the sqlite3_rtree_query_info structure:</source>
          <target state="translated">新しいxQueryFuncコールバックは、呼び出しごとにr-treeクエリエンジンからより多くの情報を受け取り、返す前にクエリエンジンに情報を送り返します。インターフェイスを管理しやすくするために、xQueryFuncコールバックはクエリエンジンからの情報をsqlite3_rtree_query_info構造体のフィールドとして送受信します。</target>
        </trans-unit>
        <trans-unit id="03223a32a94905afaa2e599c575bdc7c618a776e" translate="yes" xml:space="preserve">
          <source>The next &quot;.mode&quot; command will reset the &quot;.separator&quot; back to its default. So you will need repeat the &quot;.separator&quot; command whenever you change modes if you want to continue using a non-standard separator.</source>
          <target state="translated">次の &quot;.mode&quot; コマンドは &quot;.separator&quot; をデフォルトに戻します。そのため、非標準のセパレータを使い続けたい場合は、モードを変更するたびに &quot;.separator&quot; コマンドを繰り返す必要があります。</target>
        </trans-unit>
        <trans-unit id="9bff369a4e5022b3604d755cd856a8cb8591c715" translate="yes" xml:space="preserve">
          <source>The next block contains an example rank function that uses matchinfo data implemented in C. Instead of a single weight, it allows a weight to be externally assigned to each column of each document. It may be registered with SQLite like any other user function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function&lt;/a&gt;.</source>
          <target state="translated">次のブロックには、Cで実装されたmatchinfoデータを使用するサンプルのランク関数が含まれています。単一の重みの代わりに、各ドキュメントの各列に外部から重みを割り当てることができます。&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function&lt;/a&gt;を使用して、他のユーザー関数と同様にSQLiteに登録できます。</target>
        </trans-unit>
        <trans-unit id="5e308fd7498285ea1f61e243e9d3f001701f643f" translate="yes" xml:space="preserve">
          <source>The next block of SQL enhances the query with solutions to two other problems that may arise in developing search applications using FTS:</source>
          <target state="translated">SQLの次のブロックでは、FTSを使用した検索アプリケーションを開発する際に発生する可能性のある他の2つの問題を解決することで、クエリを強化しています。</target>
        </trans-unit>
        <trans-unit id="acd253e5152192f86ab636fd16bb5196034aa10b" translate="yes" xml:space="preserve">
          <source>The next chart compares SQLite database updates in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; against raw direct-to-disk overwrites of separate files on disk. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is NORMAL. All database writes are in a single transaction. The timer for the database writes is stopped after the transaction commits, but before a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run. Note that the SQLite writes, unlike the direct-to-disk writes, are &lt;a href=&quot;transactional&quot;&gt;transactional&lt;/a&gt; and &lt;a href=&quot;transactional&quot;&gt;power-safe&lt;/a&gt;, though because the synchronous setting is NORMAL instead of FULL, the transactions are not durable.</source>
          <target state="translated">次のグラフは、&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;でのSQLiteデータベースの更新と、ディスク上の個別のファイルの直接ディスクへの直接の上書きを比較しています。&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;設定はNORMALです。すべてのデータベース書き込みは、単一のトランザクションで行われます。データベース書き込みのタイマーは、トランザクションがコミットした後、&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;が実行される前に停止します。 SQLiteへの書き込みは、ディスクへの直接書き込みとは異なり、&lt;a href=&quot;transactional&quot;&gt;トランザクションに対応&lt;/a&gt;していて&lt;a href=&quot;transactional&quot;&gt;電源が安全&lt;/a&gt;ですが、同期設定がFULLではなくNORMALであるため、トランザクションは永続的ではありません。</target>
        </trans-unit>
        <trans-unit id="0aae132ea98563594c1fa5eb1b5277ade35e9e0f" translate="yes" xml:space="preserve">
          <source>The next chart shows the performance of SQLite versus direct-to-disk when transactions are disabled (&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt;) and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to OFF. These settings put SQLite on an equal footing with direct-to-disk writes, which is to say they make the data prone to corruption due to system crashes and power failures.</source>
          <target state="translated">次のグラフは、トランザクションが無効で（&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt;）、&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;がOFFに設定されている場合のSQLiteとディスクへの直接のパフォーマンスを示しています。これらの設定により、SQLiteはディスクへの直接書き込みと同等の立場に置かれます。つまり、システムクラッシュや電源障害が原因でデータが破損しやすくなります。</target>
        </trans-unit>
        <trans-unit id="a36fc6db6d371099515d1fcc0740a7c0b2437b14" translate="yes" xml:space="preserve">
          <source>The next example demonstrates lag(), lead(), first_value(), last_value() and nth_value(). The frame-spec is ignored by both lag() and lead(), but respected by first_value(), last_value() and nth_value().</source>
          <target state="translated">次の例では、 lag()・ lead()・ first_value()・ last_value()・ nth_value()の例を示しています。フレーム仕様は lag()と lead()の両方で無視されますが、 first_value()と last_value()と nth_value()では尊重されます。</target>
        </trans-unit>
        <trans-unit id="edb143346c38b864be88a8c33e46d2997195abb0" translate="yes" xml:space="preserve">
          <source>The next example uses two common table expressions in a single WITH clause. The following table records a family tree:</source>
          <target state="translated">次の例では、単一のWITH句で2つの一般的なテーブル式を使用しています。次のテーブルは家系図を記録しています。</target>
        </trans-unit>
        <trans-unit id="1e6dfc599524aaa9c044c52fd99b0a8ed104813e" translate="yes" xml:space="preserve">
          <source>The next interface routine to SQLite is a convenience function used to test whether or not a string forms a complete SQL statement. If the &lt;b&gt;sqlite_complete&lt;/b&gt; function returns true when its input is a string, then the argument forms a complete SQL statement. There are no guarantees that the syntax of that statement is correct, but we at least know the statement is complete. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then more text is required to complete the SQL statement.</source>
          <target state="translated">SQLiteへの次のインターフェースルーチンは、文字列が完全なSQLステートメントを形成するかどうかをテストするために使用される便利な関数です。場合&lt;b&gt;sqlite_complete&lt;/b&gt;その入力が文字列であるときに関数がtrueを返し、引数は、完全なSQL文を形成しています。そのステートメントの構文が正しいことを保証するものではありませんが、少なくともステートメントが完全であることはわかっています。&lt;b&gt;sqlite_complete&lt;/b&gt;がfalseを返す場合、SQLステートメントを完了するにはさらにテキストが必要です。</target>
        </trans-unit>
        <trans-unit id="c0fe3b1ebf5cdcafa2a519a22d91d50cf98645d3" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;master journal&quot; file. The name of the master journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="translated">マルチファイルコミットの次のステップは、「マスタージャーナル」ファイルの作成です。マスタージャーナルファイルの名前は、元のデータベースファイル名（&lt;a href=&quot;lang_attach&quot;&gt;アタッチされた&lt;/a&gt;補助データベースの1つではなく、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;インターフェイスを使用して開かれたデータベース）と同じ名前で、テキスト &quot; &lt;b&gt;-mj&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3da089b39e9e2681938268cb3d32b250cde300bb" translate="yes" xml:space="preserve">
          <source>The next step is to delete the master journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="translated">次のステップは、マスタージャーナルファイルを削除することです。これは、マルチファイルトランザクションがコミットするポイントです。このステップは、ロールバックジャーナルが削除される単一ファイルコミットシナリオの&lt;a href=&quot;#section_3_11&quot;&gt;ステップ3.11&lt;/a&gt;に対応します。</target>
        </trans-unit>
        <trans-unit id="0f8a36a95656f30638f07c12cb9da14410f8f263" translate="yes" xml:space="preserve">
          <source>The next step is to flush the content of the rollback journal file to nonvolatile storage. As we will see later, this is a critical step in insuring that the database can survive an unexpected power loss. This step also takes a lot of time, since writing to nonvolatile storage is normally a slow operation.</source>
          <target state="translated">次のステップは、ロールバック・ジャーナル・ファイルの内容を不揮発性ストレージにフラッシュすることです。後述するように、これはデータベースが予期せぬ停電にも耐えられるようにするための重要なステップです。不揮発性ストレージへの書き込みは通常は遅い操作なので、このステップにも多くの時間がかかります。</target>
        </trans-unit>
        <trans-unit id="2d76b37ca4cb1c2c8f635e9aaada12e5312b553c" translate="yes" xml:space="preserve">
          <source>The next step is to move the changes in the public branch over into the private branch. In other words, we want to create circle (5) in the diagram above. Begin by changing to the private branch using &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot;. Then type this command:</source>
          <target state="translated">次のステップは、パブリックブランチの変更をプライベートブランチに移動することです。つまり、上の図で円（5）を作成します。「 &lt;code&gt;fossil update private&lt;/code&gt; 」を使用してプライベートブランチに変更することから始めます。次に、次のコマンドを入力します。</target>
        </trans-unit>
        <trans-unit id="7e4259fddae0dc878cdf5dde573b08c0dee99991" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the master journal file in the header of every rollback journal. Space to hold the master journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="translated">次のステップは、各ロールバックジャーナルのヘッダにマスタージャーナルファイルのフルパス名を記録することです。マスタージャーナルファイル名を保持するスペースは、ロールバックジャーナルの作成時に各ロールバックジャーナルの先頭に確保しました。</target>
        </trans-unit>
        <trans-unit id="10799d0f2a52185a80b7f98059fdd7fef8ba0412" translate="yes" xml:space="preserve">
          <source>The next three bytes in the header record the number of vertexes in the polygon as a big-endian integer. Thus there is an upper bound of about 16 million vertexes per polygon.</source>
          <target state="translated">ヘッダの次の3バイトは、ポリゴン内の頂点数をビッグエンディアン整数として記録します。したがって、ポリゴンあたりの頂点数の上限は約1600万個です。</target>
        </trans-unit>
        <trans-unit id="a4532dd188d90322b7de7cb35c04fd5fcf2e6593" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction for P1 will refer to the first entry in the database table or index. If the table or index is empty, jump immediately to P2. If the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">&lt;a href=&quot;opcode#Next&quot;&gt;次に&lt;/a&gt; P1 の&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;または&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;またはNext命令を使用すると、データベーステーブルまたはインデックスの最初のエントリが参照されます。テーブルまたはインデックスが空の場合は、すぐにP2にジャンプします。テーブルまたはインデックスが空でない場合は、次の手順に進んでください。</target>
        </trans-unit>
        <trans-unit id="db275badbcaa5bbb5c1ecd5830883705763b811b" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; instruction for P1 will refer to the last entry in the database table or index. If the table or index is empty and P2&amp;gt;0, then jump immediately to P2. If P2 is 0 or if the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">次にP1 の&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;、&lt;a href=&quot;opcode#Column&quot;&gt;Column、&lt;/a&gt;または&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;命令を使用すると、データベーステーブルまたはインデックスの最後のエントリが参照されます。テーブルまたはインデックスが空で、P2&amp;gt; 0の場合、すぐにP2にジャンプします。 P2が0の場合、またはテーブルまたはインデックスが空でない場合は、次の手順に進んでください。</target>
        </trans-unit>
        <trans-unit id="971bdad47f863dca0857c6853816fdb36613779f" translate="yes" xml:space="preserve">
          <source>The no-op memory allocator is not useful by itself. It exists only as a placeholder so that SQLite has a memory allocator to link against on systems that may not have malloc(), free(), or realloc() in their standard library. An application that is compiled with &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; will need to use &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; together with &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; to specify a new alternative memory allocator before beginning to use SQLite.</source>
          <target state="translated">no-opメモリアロケータは、それ自体では役に立ちません。 SQLiteが標準ライブラリにmalloc（）、free（）、またはrealloc（）を持たないシステムでリンクするためのメモリアロケータを持つように、それはプレースホルダーとしてのみ存在します。&lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt;でコンパイルされたアプリケーションは、SQLiteの使用を開始する前に、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;または&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;と共に&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;を使用して、新しい代替メモリアロケータを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fa03e3271f78c25f5482177efc3b575ee4cb93ab" translate="yes" xml:space="preserve">
          <source>The nolock query parameter is a boolean that disables all calls to the xLock, xUnlock, and xCheckReservedLock methods of the VFS when true. The nolock query parameter might be used, for example, when trying to access a file on a filesystem that does not support file locking. Caution: If two or more &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; try to interact with the same SQLite database and one or more of those connections has enabled &quot;nolock&quot;, then database corruption can result. The &quot;nolock&quot; query parameter should only be used if the application can guarantee that writes to the database are serialized.</source>
          <target state="translated">nolockクエリパラメータは、trueの場合、VFSのxLock、xUnlock、およびxCheckReservedLockメソッドへのすべての呼び出しを無効にするブール値です。nolockクエリパラメータは、たとえば、ファイルロックをサポートしていないファイルシステム上のファイルにアクセスする場合に使用されます。注意：2つ以上の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が同じSQLiteデータベースと対話しようとし、それらの接続の1つ以上で「nolock」が有効になっている場合、データベースが破損する可能性があります。&quot;nolock&quot;クエリパラメータは、アプリケーションがデータベースへの書き込みのシリアル化を保証できる場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="b327cb7b48d6db3fd953f98055ad0798aba25bf9" translate="yes" xml:space="preserve">
          <source>The normal ROWID selection algorithm described above will generate monotonically increasing unique ROWIDs as long as you never use the maximum ROWID value and you never delete the entry in the table with the largest ROWID. If you ever delete rows or if you ever create a row with the maximum possible ROWID, then ROWIDs from previously deleted rows might be reused when creating new rows and newly created ROWIDs might not be in strictly ascending order.</source>
          <target state="translated">上で説明した通常のROWID選択アルゴリズムは、ROWIDの最大値を使用せず、最大のROWIDを持つテーブル内のエントリを削除しない限り、単調に増加する一意のROWIDを生成します。行を削除したり、可能な限り最大のROWIDを持つ行を作成したりすると、新しい行を作成する際に以前に削除された行のROWIDが再利用され、新たに作成されたROWIDは厳密には昇順ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="dd6fdcceb1d1ed51baa294f01d457a9007d5dbff" translate="yes" xml:space="preserve">
          <source>The notindexed= option is not available. Adding &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt; to the column definition is equivalent.</source>
          <target state="translated">notindexed =オプションは使用できません。&lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt;を列定義に追加することは同等です。</target>
        </trans-unit>
        <trans-unit id="e15aca005b3d3fc4e0be53d1a5e363f5a459da35" translate="yes" xml:space="preserve">
          <source>The nullif(X,Y) function returns its first argument if the arguments are different and NULL if the arguments are the same. The nullif(X,Y) function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If neither argument to nullif() defines a collating function then the BINARY is used.</source>
          <target state="translated">nullif(X,Y)関数は、引数が異なる場合は第1引数を返し、引数が同じ場合はNULLを返します。nullif(X,Y)関数は、照合関数を定義している引数を左から右へ検索し、すべての文字列比較にその照合関数を使用します。nullif()のどちらの引数も照合関数を定義していない場合は BINARY が使用されます。</target>
        </trans-unit>
        <trans-unit id="0d33dbf967cc9fffb2bcf5f7dd0e676a56e0fe27" translate="yes" xml:space="preserve">
          <source>The number of arguments to a function is sometimes stored in a signed character. So there is a hard upper bound on SQLITE_MAX_FUNCTION_ARG of 127.</source>
          <target state="translated">関数の引数の数は符号付きの文字で格納されることがあります。そのため、SQLITE_MAX_FUNCTION_ARGには127のハードな上限があります。</target>
        </trans-unit>
        <trans-unit id="22855456991124f9a63a13f70b4de30a07b1a44f" translate="yes" xml:space="preserve">
          <source>The number of characters in cFrom and cTo do not need to be the same. The rule above says that &quot;ss&quot; on user input will match &quot;&amp;szlig;&quot; with a penalty of 8.</source>
          <target state="translated">cFromとcToの文字数は同じである必要はありません。上記のルールは、ユーザー入力の「ss」は「&amp;szlig;」とペナルティ8で一致することを示しています。</target>
        </trans-unit>
        <trans-unit id="1dc8b6de1e412ad3d4600fff75a5432b18cfae89" translate="yes" xml:space="preserve">
          <source>The number of columns in a table</source>
          <target state="translated">テーブルの列数</target>
        </trans-unit>
        <trans-unit id="c449227bed7d73e21c9772a435303abb6080e61e" translate="yes" xml:space="preserve">
          <source>The number of columns in a table is limited by the &lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt; compile-time parameter. A single row of a table cannot store more than &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; bytes of data. Both of these limits can be lowered at runtime using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">テーブルの列の数は、&lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt;コンパイル時パラメーターによって制限されます。テーブルの単一行は、&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;バイトを超えるデータを格納できません。これらの制限はどちらも、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt; C / C ++インターフェイスを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="8a6392262a1b2aadeab5c7954067326f2acb3a1d" translate="yes" xml:space="preserve">
          <source>The number of columns in a view</source>
          <target state="translated">ビューのカラム数</target>
        </trans-unit>
        <trans-unit id="7da1c90b5d954b64a1a4a566749d8c554741462e" translate="yes" xml:space="preserve">
          <source>The number of columns in an index</source>
          <target state="translated">インデックスの列数</target>
        </trans-unit>
        <trans-unit id="155a4bbdc3161555e0a5db3b049b1a9960793a80" translate="yes" xml:space="preserve">
          <source>The number of columns in each row returned by the SELECT statement (if any) and the specific values returned have no effect on the results of the EXISTS operator. In particular, rows containing NULL values are not handled any differently from rows without NULL values.</source>
          <target state="translated">SELECT文によって返された各行のカラム数(もしあれば)と、返された特定の値は、EXISTS演算子の結果に影響を与えません。特に、NULL 値を含む行は、NULL 値を持たない行と何ら変わりなく扱われます。</target>
        </trans-unit>
        <trans-unit id="b33773d9bb8fcd548b7aa9142e9dd252802d3ebf" translate="yes" xml:space="preserve">
          <source>The number of columns in the result set of a SELECT statement</source>
          <target state="translated">SELECT文の結果セットのカラム数</target>
        </trans-unit>
        <trans-unit id="5962dbc1c4fa716686ee3f9c370159a83fff2488" translate="yes" xml:space="preserve">
          <source>The number of columns in the rows returned by a simple SELECT statement is equal to the number of expressions in the result expression list after substitution of * and alias.* expressions. Each result row is calculated by evaluating the expressions in the result expression list with respect to a single row of input data or, for aggregate queries, with respect to a group of rows.</source>
          <target state="translated">単純なSELECT文によって返される行の列の数は、*式とalias.*式を置換した後の結果式リストの式の数に等しい。各結果行は、結果式リスト内の式を入力データの1行、または集約クエリの場合は行のグループを基準にして評価することで計算されます。</target>
        </trans-unit>
        <trans-unit id="efcaef0127aaba4759abf4c43138ceabba69a62b" translate="yes" xml:space="preserve">
          <source>The number of columns in the table, and</source>
          <target state="translated">テーブルのカラム数と</target>
        </trans-unit>
        <trans-unit id="ec4b9441464f8df5d1135d79fc696ff2d27c10ef" translate="yes" xml:space="preserve">
          <source>The number of columns the table has, and</source>
          <target state="translated">テーブルが持つカラムの数と</target>
        </trans-unit>
        <trans-unit id="f71fcd9bd24f5e705202e8ea9d15f75d827b7073" translate="yes" xml:space="preserve">
          <source>The number of entries in the write-ahead log (WAL) file for that database</source>
          <target state="translated">そのデータベースのWAL(write-ahead log)ファイルのエントリ数。</target>
        </trans-unit>
        <trans-unit id="146718a82c006ef871da6bc05817a225f7435b26" translate="yes" xml:space="preserve">
          <source>The number of fields in this row.</source>
          <target state="translated">この行のフィールド数。</target>
        </trans-unit>
        <trans-unit id="049187119aa733be135d042e46c0767e81dbbd57" translate="yes" xml:space="preserve">
          <source>The number of freelist pages is stored as a 4-byte big-endian integer in the database header at an offset of 36 from the beginning of the file. The database header also stores the page number of the first freelist trunk page as a 4-byte big-endian integer at an offset of 32 from the beginning of the file.</source>
          <target state="translated">フリーリストのページ数は、ファイルの先頭から36のオフセットで4バイトのビッグエンディアン整数としてデータベースヘッダーに格納される。また、データベース・ヘッダには、最初のフリーリスト・トランク・ページのページ番号が、ファイルの先頭から32のオフセットで4バイトのビッグエンディアン整数として格納されます。</target>
        </trans-unit>
        <trans-unit id="297412af9b640397abb6b05573031f719033bedb" translate="yes" xml:space="preserve">
          <source>The number of matchable phrases in the query.</source>
          <target state="translated">クエリ内の一致するフレーズの数。</target>
        </trans-unit>
        <trans-unit id="96242742547a237955f6f616dd7a1536e46de1dc" translate="yes" xml:space="preserve">
          <source>The number of open read-transactions on the shared-cache drops to zero.</source>
          <target state="translated">共有キャッシュ上のオープンリードトランザクションの数がゼロになります。</target>
        </trans-unit>
        <trans-unit id="140866849ab31e765e1dcf46dadf93357615ced1" translate="yes" xml:space="preserve">
          <source>The number of registers in a single prepared statement is fixed at compile-time. The content of all registers is cleared when a prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</source>
          <target state="translated">単一の準備済みステートメント内のレジスターの数は、コンパイル時に固定されます。すべてのレジスタの内容は、準備されたステートメントが&lt;a href=&quot;c3ref/reset&quot;&gt;リセット&lt;/a&gt;または&lt;a href=&quot;c3ref/finalize&quot;&gt;ファイナライズ&lt;/a&gt;されるとクリアされます。</target>
        </trans-unit>
        <trans-unit id="4967dccc017338cead0491dfe60a2adb347e1af4" translate="yes" xml:space="preserve">
          <source>The number of rows in a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; is no longer limited by &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_select#values&quot;&gt;VALUES句&lt;/a&gt;の行数は&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;によって制限されなくなりました。</target>
        </trans-unit>
        <trans-unit id="36747c7623716448e27a5f87c9f1a06587b9fa71" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS4 table. This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">FTS4 テーブルの行数。この値は、FTS3ではなく、FTS4テーブルにクエリを実行する場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="e61b9ea13ff6553c9d51a6610c8145f4cf2adbcc" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS5 table for which column $col contains at least one instance of the term.</source>
          <target state="translated">FTS5 テーブル内で、列 $col に用語のインスタンスが少なくとも 1 つ含まれている行の数。</target>
        </trans-unit>
        <trans-unit id="05c84b067bb80eadabe7075383b96e16df1c5aad" translate="yes" xml:space="preserve">
          <source>The number of rows that contain at least one instance of the term.</source>
          <target state="translated">用語の少なくとも1つのインスタンスを含む行の数。</target>
        </trans-unit>
        <trans-unit id="32422ea0ce2f612eaf439b2072fddd2d97242e6b" translate="yes" xml:space="preserve">
          <source>The number of system calls for filesystem operations is reduced, possibly resulting in a small performance increase.</source>
          <target state="translated">ファイルシステム操作のためのシステムコールの数が減るため、パフォーマンスが若干向上する可能性があります。</target>
        </trans-unit>
        <trans-unit id="e6551507f016b4d4b5fee98e7304b5666b04c04e" translate="yes" xml:space="preserve">
          <source>The number of terms in a GROUP BY or ORDER BY clause</source>
          <target state="translated">GROUP BYまたはORDER BY句の項数。</target>
        </trans-unit>
        <trans-unit id="1c91b565cbe9942030a8129bf45c560b0a7de90f" translate="yes" xml:space="preserve">
          <source>The number of terms in the SET clause of an UPDATE statement</source>
          <target state="translated">UPDATE文のSET句の項数。</target>
        </trans-unit>
        <trans-unit id="70c8732a507183c03eb179514303045a0317c738" translate="yes" xml:space="preserve">
          <source>The number of the current row's peer group within its partition - the rank of the current row without gaps. Partitions are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">パーティション内の現在の行のピアグループの数-現在の行のギャップのないランク。パーティションは、ウィンドウ定義の ORDER BY 節で定義された順番で 1 から順に番号が付けられます。ORDER BY 句がない場合は、すべての行がピアとみなされ、この関数は常に 1 を返します。</target>
        </trans-unit>
        <trans-unit id="19450a48e3be402fdbd06d100d558662cd52a063" translate="yes" xml:space="preserve">
          <source>The number of the row within the current partition. Rows are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition, or in arbitrary order otherwise.</source>
          <target state="translated">現在のパーティション内の行の番号。行の番号は、ウィンドウ定義の ORDER BY 節で定義された順番で 1 から始まり、それ以外の場合は任意の順番になります。</target>
        </trans-unit>
        <trans-unit id="4dd0d77e2a923847446dbf60b3f48736890bd6ba" translate="yes" xml:space="preserve">
          <source>The number of user defined columns in the FTS table (i.e. not including the docid or the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;).</source>
          <target state="translated">FTSテーブル内のユーザー定義の列の数（つまり、docidまたは&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS非表示列&lt;/a&gt;を含まない）。</target>
        </trans-unit>
        <trans-unit id="ec04163c2280ea8f1f3a4d1db55ac34599bd6c09" translate="yes" xml:space="preserve">
          <source>The number of values in an INSERT statement</source>
          <target state="translated">INSERT文の値の数</target>
        </trans-unit>
        <trans-unit id="0c5896381d0db64fdbbf15f25aac8c07347171d8" translate="yes" xml:space="preserve">
          <source>The numbered list above notes that the data for the first page of the database file, if it exists and is not already loaded into the</source>
          <target state="translated">上記の番号付きリストは、データベースファイルの最初のページのデータが存在していて、それがすでに</target>
        </trans-unit>
        <trans-unit id="57671fab77edd8c578d7c9204ffe057965cc804a" translate="yes" xml:space="preserve">
          <source>The numbers here have become meaningless. This page has been retained only as an historical artifact.</source>
          <target state="translated">ここでの数字は無意味になってしまいました。このページは歴史的遺物としてのみ保存されています。</target>
        </trans-unit>
        <trans-unit id="dde5b38271f3bab6f5848df944b4001a9705e033" translate="yes" xml:space="preserve">
          <source>The numbers on the left are the CPU cycle counts for that line of code, of course.</source>
          <target state="translated">左側の数字は、もちろんその行のCPUサイクル数です。</target>
        </trans-unit>
        <trans-unit id="a08476269382d9cd02770e2cab87ae0ab5a527b0" translate="yes" xml:space="preserve">
          <source>The object is deleted using a call to sqlite3changegroup_delete().</source>
          <target state="translated">オブジェクトはsqlite3changegroup_delete()を呼び出して削除されます。</target>
        </trans-unit>
        <trans-unit id="5ae7075075a940fc9e83c06d49e89ed478d0bf99" translate="yes" xml:space="preserve">
          <source>The one-byte flag at offset 0 indicating the b-tree page type.</source>
          <target state="translated">b-tree ページタイプを示すオフセット 0 の半角フラグ。</target>
        </trans-unit>
        <trans-unit id="8ef8e17609c1f629f28fe60dfd6c0e8997843e40" translate="yes" xml:space="preserve">
          <source>The one-byte integer at offset 7 gives the number of fragmented free bytes within the cell content area.</source>
          <target state="translated">オフセット7の半角整数は、セルコンテンツ領域内の断片化されたフリーバイト数を与える。</target>
        </trans-unit>
        <trans-unit id="729502a2e01c1766734981063a90830e318512ca" translate="yes" xml:space="preserve">
          <source>The online backup API is &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;documented here&lt;/a&gt;. The remainder of this page contains two C language examples illustrating common uses of the API and discussions thereof. Reading these examples is no substitute for reading the API documentation!</source>
          <target state="translated">オンラインバックアップAPIについては、&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;こちらをご覧ください&lt;/a&gt;。このページの残りの部分には、APIの一般的な使用法とその説明を示す2つのC言語の例が含まれています。これらの例を読むことは、APIドキュメントを読むことに代わるものではありません。</target>
        </trans-unit>
        <trans-unit id="0ca3b9f46f696e6082e6b7a829be81ef745b8e77" translate="yes" xml:space="preserve">
          <source>The only SQLite compile-time option used was &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;. The optional &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator is used for performance testing because it gives results that are more repeatable than the library-supplied malloc()/free() on Ubuntu.</source>
          <target state="translated">使用された唯一のSQLiteコンパイル時オプションは&lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5でした&lt;/a&gt;。オプションの&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;メモリアロケータは、Ubuntuでライブラリが提供するmalloc（）/ free（）よりも再現性の高い結果を提供するため、パフォーマンステストに使用されます。</target>
        </trans-unit>
        <trans-unit id="89c13a55d3d11964427a1a5b2d10d0b78ec66565" translate="yes" xml:space="preserve">
          <source>The only compression algorithm supported is &lt;a href=&quot;https://zlib.net&quot;&gt;&quot;deflate&quot;&lt;/a&gt;.</source>
          <target state="translated">サポートされている唯一の圧縮アルゴリズムは&lt;a href=&quot;https://zlib.net&quot;&gt;&quot;deflate&quot;&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ecb1124fca00e2a69914563c0d3a9baa08011926" translate="yes" xml:space="preserve">
          <source>The only difference between the following two CASE expressions is that the</source>
          <target state="translated">次の2つのcase表現の違いは</target>
        </trans-unit>
        <trans-unit id="f71f4a9db1fb88c54de0203ce462454fe4edc774" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case, the results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="translated">唯一の違いは、上で列挙したpublic sqlite3_XXX関数が有効なミューテックスハンドルの代わりにNULLポインタを渡す呼び出しを黙って無視することです。この構造体で定義されたメソッドの実装はこのケースを処理する必要はなく、有効なミューテックスハンドルの代わりにNULLポインタを渡した結果は未定義です(つまり、NULLポインタを渡した場合にセグフェイルする実装を提供しても構いません)。</target>
        </trans-unit>
        <trans-unit id="b216563d4489c23da5dd8ef7bbce7ce15447a023" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. There are several virtual table implementations in the SQLite source tree (for testing purposes). You might use one of those as a guide. Locate these test virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="translated">本当に難しいのはステップ1だけです。既存の仮想テーブルの実装から始めて、必要に応じて変更するのが良いでしょう。SQLiteのソースツリーには(テスト用に)いくつかの仮想テーブルの実装があります。それらのうちの1つをガイドとして使用するとよいでしょう。sqlite3_create_module &quot;を検索して、これらのテスト用仮想テーブル実装を見つけてください。</target>
        </trans-unit>
        <trans-unit id="6a54b4d13a6de9bd96883cd76ca40e5bd7dd1a4b" translate="yes" xml:space="preserve">
          <source>The only reasons for providing functions other than strftime() is for convenience and for efficiency.</source>
          <target state="translated">strftime()以外の関数を提供する理由は、利便性と効率化のためだけです。</target>
        </trans-unit>
        <trans-unit id="c64051b826835db581e8535aa4a8fb802f2e8d26" translate="yes" xml:space="preserve">
          <source>The only schema altering commands directly supported by SQLite are the &quot;&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;rename table&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;rename column&lt;/a&gt;&quot;, and &quot;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;add column&lt;/a&gt;&quot; commands shown above. However, applications can make other arbitrary changes to the format of a table using a simple sequence of operations. The steps to make arbitrary changes to the schema design of some table X are as follows:</source>
          <target state="translated">SQLiteが直接サポートする唯一のスキーマ変更コマンドは、上記の「&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;テーブルの名前変更&lt;/a&gt;」、「&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;列の名前変更&lt;/a&gt;」、および「&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;列の追加&lt;/a&gt;」コマンドです。ただし、アプリケーションは、単純な一連の操作を使用して、テーブルの形式に他の任意の変更を加えることができます。一部のテーブルXのスキーマ設計に任意の変更を加える手順は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a93c45a553bd489c541613e587314033dbb5442e" translate="yes" xml:space="preserve">
          <source>The only significant design decision that developers need to make is whether to use -Os (optimize for size) or -O6 (optimize for speed). The -O6 setting makes binaries that run about 2% or 3% faster, but which are also 66% larger. The performance here is measured by counting CPU cycles using cachegrind. I-cache misses are not considered in the analysis. If I-cache misses are considered, builds with -O6 might not be any faster than builds with -Os.</source>
          <target state="translated">開発者が行う必要がある唯一の重要な設計上の決定は、-Os (サイズの最適化)と -O6 (速度の最適化)のどちらを使用するかということです。O6 の設定では、バイナリの実行速度は約 2%、3% 速くなりますが、バイナリのサイズは 66% 大きくなります。ここでのパフォーマンスは、cachegrind を使って CPU サイクルをカウントすることで測定されます。I-キャッシュミスは解析では考慮されません。I-cache miss を考慮した場合、-O6 を使用したビルドは -Os を使用したビルドよりも速くならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="67fcf151555c1f1738044349d853d4cc0820a67f" translate="yes" xml:space="preserve">
          <source>The only thing that is really new about the current example is the WHERE clause which is implemented by instructions at addresses 7 through 10. Instructions at address 7 and 8 push onto the stack the value of the &quot;one&quot; column from the table and the literal string &quot;H%&quot;. The &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; instruction at address 9 pops these two values from the stack and pushes the result of the LIKE() function back onto the stack. The &lt;a href=&quot;opcode#IfNot&quot;&gt;IfNot&lt;/a&gt; instruction pops the top stack value and causes an immediate jump forward to the Next instruction if the top value was false (&lt;em&gt;not&lt;/em&gt; not like the literal string &quot;H%&quot;). Taking this jump effectively skips the callback, which is the whole point of the WHERE clause. If the result of the comparison is true, the jump is not taken and control falls through to the Callback instruction below.</source>
          <target state="translated">現在の例で本当に新しいのは、アドレス7〜10の命令によって実装されるWHERE句だけです。アドレス7および8の命令は、テーブルとリテラルから「1」列の値をスタックにプッシュします。文字列「H％」。アドレス9 の&lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;命令は、これらの2つの値をスタックからポップし、LIKE（）関数の結果をスタックにプッシュします。&lt;a href=&quot;opcode#IfNot&quot;&gt;IFNOTの&lt;/a&gt;命令は、トップスタックの値をポップし、トップ値は（偽だった場合は、次の命令を楽しみにすぐにジャンプしません&lt;em&gt;&lt;/em&gt;リテラル文字列「H％」とは異なります）。このジャンプを行うと、コールバックがスキップされます。これは、WHERE句の要点です。比較の結果が真の場合、ジャンプは行われず、制御は以下のコールバック命令に移ります。</target>
        </trans-unit>
        <trans-unit id="7db0a106b3cc6051a669fd3768b87982a2f1bf0d" translate="yes" xml:space="preserve">
          <source>The only time this would ever be an issue is when you have a program using version 2.8.0 or later that crashes with an incomplete transaction, then you try to examine the database using version 2.7.6 or earlier. The 2.7.6 code will not be able to read the journal file and thus will not be able to rollback the incomplete transaction to restore the database.</source>
          <target state="translated">これが問題になるのは、バージョン2.8.0以降を使用しているプログラムが不完全なトランザクションでクラッシュした後、バージョン2.7.6以前を使用してデータベースを調べようとした場合だけです。2.7.6のコードはジャーナルファイルを読むことができないので、データベースを復元するために不完全なトランザクションをロールバックすることができません。</target>
        </trans-unit>
        <trans-unit id="3427e2677eb5693de36c8d23ded03f405a1417be" translate="yes" xml:space="preserve">
          <source>The only way that SQLite can know that the left-most columns of an index have many duplicate is if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database. Without the results of ANALYZE, SQLite has to guess at the &quot;shape&quot; of the data in the table, and the default guess is that there are an average of 10 duplicates for every value in the left-most column of the index. But skip-scan only becomes profitable (it only gets to be faster than a full table scan) when the number of duplicates is about 18 or more. Hence, a skip-scan is never used on a database that has not been analyzed.</source>
          <target state="translated">SQLiteがインデックスの左端の列に多くの重複があることを知る唯一の方法は、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドがデータベースで実行されている場合です。ANALYZEの結果がない場合、SQLiteはテーブル内のデータの「形状」を推測する必要があり、デフォルトの推測では、インデックスの左端の列のすべての値に対して平均10の重複があります。しかし、スキップスキャンは、重複の数が約18以上の場合にのみ有益になります（全テーブルスキャンよりも速くなるだけです）。したがって、スキップスキャンは、分析されていないデータベースでは使用されません。</target>
        </trans-unit>
        <trans-unit id="4470bf44a4ab413995e0a4a3db8d3df4a465f540" translate="yes" xml:space="preserve">
          <source>The opening and/or creating of the database file is deferred until the file is actually needed. This allows options and parameters, such as the native text representation and default page size, to be set using PRAGMA statements.</source>
          <target state="translated">データベースファイルのオープンや作成は、ファイルが実際に必要になるまで延期されます。これにより、ネイティブテキスト表現やデフォルトページサイズなどのオプションやパラメータをPRAGMA文を使って設定することができます。</target>
        </trans-unit>
        <trans-unit id="0fff8fde33861bc909ec1bcff7cb77c490217d5b" translate="yes" xml:space="preserve">
          <source>The operating system interface layer understands and tracks all five locking states described above. The pager module only tracks four of the five locking states. A PENDING lock is always just a temporary stepping stone on the path to an EXCLUSIVE lock and so the pager module does not track PENDING locks.</source>
          <target state="translated">オペレーティング・システム・インターフェース層は、上述の5つのロック状態をすべて理解し、追跡します。ポケベルモジュールは、5 つのロック状態のうち 4 つだけを追跡します。PENDING ロックは常に、EXCLUSIVE ロックへのパス上の一時的な飛び石に過ぎないので、ページャーモジュールは PENDING ロックを追跡しません。</target>
        </trans-unit>
        <trans-unit id="6f69f5f3efa82abf10e6a8b25aaa02ea47607f29" translate="yes" xml:space="preserve">
          <source>The operating system must have a unified buffer cache in order for the memory-mapped I/O extension to work correctly, especially in situations where two processes are accessing the same database file and one process is using memory-mapped I/O while the other is not. Not all operating systems have a unified buffer cache. In some operating systems that claim to have a unified buffer cache, the implementation is buggy and can lead to corrupt databases.</source>
          <target state="translated">特に、2つのプロセスが同じデータベースファイルにアクセスしていて、1つのプロセスがメモリマップドI/Oを使用していて、もう1つのプロセスが使用していないような状況では、メモリマップドI/O拡張機能を正しく動作させるためには、オペレーティングシステムが統一されたバッファキャッシュを持っている必要があります。すべてのオペレーティングシステムが統一されたバッファキャッシュを持っているわけではありません。統合されたバッファキャッシュを持っていると主張するオペレーティングシステムの中には、実装がバグだらけで、データベースを破損させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2fef3a1777aac58cd8a21d6d8b1475aa38c4964a" translate="yes" xml:space="preserve">
          <source>The operations above can potentially cause vast changes the raw database file, and hence cause very different SHA1 hashes at the file level. But since the content represented in the database file is unchanged by these operations, the hash computed by dbhash is also unchanged.</source>
          <target state="translated">上記の操作は、生のデータベースファイルに大きな変更を与える可能性があり、ファイルレベルでは非常に異なるSHA1ハッシュを発生させる可能性があります。しかし、データベースファイルで表現されている内容はこれらの操作によって変更されないので、dbhashによって計算されたハッシュも変更されません。</target>
        </trans-unit>
        <trans-unit id="fa365bc2db1bf185a92f2d5ef6ff8250e55de644" translate="yes" xml:space="preserve">
          <source>The optimization that uses an index to quickly compute an aggregate min() or max() is extended to work with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">インデックスを使用して集計min（）またはmax（）をすばやく計算する最適化は、式のインデックスを操作するように拡張されてい&lt;a href=&quot;expridx&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0ff09fb1c0cc730867c7410dca6d8522dc6581b" translate="yes" xml:space="preserve">
          <source>The optimizer automatically inverts terms of the form &quot;expr OP column&quot; and makes other simplifications to the WHERE clause in an attempt to get as many WHERE clause terms into the form shown above as possible. The aConstraint[] array only reports WHERE clause terms that are relevant to the particular virtual table being queried.</source>
          <target state="translated">オプティマイザは、&quot;expr OP column&quot; という形式の用語を自動的に反転させ、可能な限り多くの WHERE 句を上記の形式にするために、WHERE 句にその他の簡略化を行います。aConstraint[]配列は、問い合わせ先の特定の仮想テーブルに関連する WHERE 句のみをレポートします。</target>
        </trans-unit>
        <trans-unit id="3a8fb11a2c37159ec0832c94b1217f4e3525fc9f" translate="yes" xml:space="preserve">
          <source>The optimizer has more freedom to reorder tables in the FROM clause even in there are LEFT joins.</source>
          <target state="translated">オプティマイザは、LEFT結合があってもFROM句でテーブルを並べ替える自由度が高くなりました。</target>
        </trans-unit>
        <trans-unit id="ed82314b13b2ea2beac78e23a61e927cbc2a784b" translate="yes" xml:space="preserve">
          <source>The optimizer will now scan tables in the reverse if doing so will satisfy an ORDER BY ... DESC clause.</source>
          <target state="translated">オプティマイザは、ORDER BY ...DESC句を満たす場合、テーブルを逆にスキャンするようになりました。DESC句を満たしていれば、オプティマイザはテーブルを逆スキャンするようになります。</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">オプション</target>
        </trans-unit>
        <trans-unit id="a17a0a84a2d535101cac8aa7214d0ca78303a13a" translate="yes" xml:space="preserve">
          <source>The option causes SQLite to omit its built-in operating system interfaces for Unix, Windows, and OS/2. The resulting library will have no default &lt;a href=&quot;c3ref/vfs&quot;&gt;operating system interface&lt;/a&gt;. Applications must use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to register an appropriate interface before using SQLite. Applications must also supply implementations for the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt; interfaces. The usual practice is for the supplied &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; to invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. SQLite will automatically invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; when it initializes.</source>
          <target state="translated">このオプションにより、SQLiteは、Unix、Windows、およびOS / 2の組み込みオペレーティングシステムインターフェイスを省略します。結果のライブラリには、デフォルトの&lt;a href=&quot;c3ref/vfs&quot;&gt;オペレーティングシステムインターフェース&lt;/a&gt;がありません。アプリケーションは、SQLiteを使用する前に、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;を使用して適切なインターフェースを登録する必要があります。アプリケーションは、&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;および&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end（）&lt;/a&gt;インターフェースの実装も提供する必要があります。通常の練習は、供給されるためである&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;呼び出すことが&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（） &lt;/a&gt;。SQLiteは、初期化時に自動的に&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）を&lt;/a&gt;呼び出します。</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">オプションの</target>
        </trans-unit>
        <trans-unit id="e154860c714282a196150a8b230c6746d885f55b" translate="yes" xml:space="preserve">
          <source>The optional &quot;</source>
          <target state="translated">オプションの&quot;</target>
        </trans-unit>
        <trans-unit id="44528aeaa99ba557a8ba7b80ef11d6c589ba4953" translate="yes" xml:space="preserve">
          <source>The optional &quot;AS alias&quot; phrase provides an alternative name for the table into which content is being inserted. The alias name can be used within WHERE and SET clauses of the &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;. If there is no &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;, then the alias is pointless, but also harmless.</source>
          <target state="translated">オプションの「ASエイリアス」句は、コンテンツが挿入されるテーブルの代替名を提供します。エイリアス名は、&lt;a href=&quot;lang_upsert&quot;&gt;UPSERTの&lt;/a&gt; WHEREおよびSET句内で使用できます。&lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;がない場合、エイリアスは無意味ですが無害でもあります。</target>
        </trans-unit>
        <trans-unit id="af3a99778493ef21555e9c9fa86a7e91b06e70d3" translate="yes" xml:space="preserve">
          <source>The optional &quot;OR</source>
          <target state="translated">オプションの「OR</target>
        </trans-unit>
        <trans-unit id="20d5db3386f7bebafe75fa5cbd335d930edd4888" translate="yes" xml:space="preserve">
          <source>The optional EXCLUDE clause may take any of the following four forms:</source>
          <target state="translated">オプションのEXCLUDE句は、以下の4つの形式のいずれかを取ることができます。</target>
        </trans-unit>
        <trans-unit id="f5dad0eb12cbe81d01819ac36d3268610ba8edac" translate="yes" xml:space="preserve">
          <source>The optional IF EXISTS clause suppresses the error that would normally result if the table does not exist.</source>
          <target state="translated">オプションのIF EXISTS句は、テーブルが存在しない場合に通常発生するエラーを抑制します。</target>
        </trans-unit>
        <trans-unit id="5cb5d652a77ff38b54b62cd30fd9ed282bedd94d" translate="yes" xml:space="preserve">
          <source>The optional MASK argument is a bitmask of optimizations to perform:</source>
          <target state="translated">オプションのMASK引数は、実行する最適化のビットマスクです。</target>
        </trans-unit>
        <trans-unit id="6a52a350b8227e3f2c9ade5a4eb34242d4d7eced" translate="yes" xml:space="preserve">
          <source>The optional argument is the name of the schema or database to be serialized. The default value is &quot;main&quot;.</source>
          <target state="translated">オプションの引数には、シリアライズするスキーマまたはデータベースの名前を指定します。デフォルト値は &quot;main &quot;です。</target>
        </trans-unit>
        <trans-unit id="38da3cf28a52f4f6d620faa6e6cb2361f1cf4901" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two basic forms of the CASE expression: those with a base expression and those without.</source>
          <target state="translated">CASE キーワードと最初の WHEN キーワードの間に発生するオプション式は、「ベース」式と呼ばれます。CASE 式には、ベース式を持つものと持たないものの 2 つの基本的な形式があります。</target>
        </trans-unit>
        <trans-unit id="b46109c9ae9c950c43fe7007d16547e58baf09ab" translate="yes" xml:space="preserve">
          <source>The optional shared cache and memory management features that were introduced in version 3.3.0 can now be used across multiple threads within the same process. Formerly, these extensions only applied to database connections operating within a single thread.</source>
          <target state="translated">バージョン3.3.0で導入されたオプションの共有キャッシュとメモリ管理機能は、同じプロセス内の複数のスレッドで使用できるようになりました。以前は、これらの拡張機能は単一のスレッド内で動作するデータベース接続にのみ適用されていました。</target>
        </trans-unit>
        <trans-unit id="095e758e6c75bd1010500f9c5cbf1c0112ebeaf1" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments.</source>
          <target state="translated">関数の引数の評価順序。</target>
        </trans-unit>
        <trans-unit id="671d3f63e428cbeb09358473179412be4940924b" translate="yes" xml:space="preserve">
          <source>The order of keys in an index b-tree is determined by the sort order of the records that the keys represent. Record comparison progresses column by column. Columns of a record are examined from left to right. The first pair of columns that are not equal determines the relative order of the two records. The sort order of individual columns is as follows:</source>
          <target state="translated">インデックス b-tree のキーの順序は、キーが表すレコードのソート順によって決定されます。レコードの比較は、カラムごとに進行する。レコードの列は、左から右へと検査されます。等しくない列の最初のペアが、2 つのレコードの相対的な順序を決定します。個々のカラムのソート順は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2b489797ae43740676c30370f9b2ea776aa65877" translate="yes" xml:space="preserve">
          <source>The order of tables in a join is adjusted automatically to make better use of indices</source>
          <target state="translated">結合のテーブルの順序は、インデックスをよりよく利用するために自動的に調整されます。</target>
        </trans-unit>
        <trans-unit id="140f29de259bdc1e34708f12946df0112e292cdd" translate="yes" xml:space="preserve">
          <source>The order of the buffer pointer and buffer size parameters in the built-in snprintf() implementation is reversed from the order used in standard-library implementations.</source>
          <target state="translated">組み込みの snprintf()の実装におけるバッファポインタとバッファサイズパラメータの順序は、標準ライブラリの実装で使用されている順序とは逆になります。</target>
        </trans-unit>
        <trans-unit id="5e9268cc64b3aabab9ece14a89f94084ddd4b3cc" translate="yes" xml:space="preserve">
          <source>The order of the columns in the data_% table does not matter.</source>
          <target state="translated">data_%テーブルのカラムの順番は関係ありません。</target>
        </trans-unit>
        <trans-unit id="b1b615b19c9501777b15d4388be1e80320f4db76" translate="yes" xml:space="preserve">
          <source>The order of the entries indicates the nesting order. In this case, the scan of table t1 using index i2 is the outer loop (since it appears first) and the full-table scan of table t2 is the inner loop (since it appears last). In the following example, the positions of t1 and t2 in the FROM clause of the SELECT are reversed. The query strategy remains the same. The output from EXPLAIN QUERY PLAN shows how the query is actually evaluated, not how it is specified in the SQL statement.</source>
          <target state="translated">エントリの順序は入れ子の順序を示す。この場合、インデックスi2を使用したテーブルt1のスキャンは外側のループ(最初に現れるので)であり、テーブルt2のフルテーブルスキャンは内側のループ(最後に現れるので)です。次の例では、SELECTのFROM句のt1とt2の位置が逆になっています。クエリ戦略は変わりません。EXPLAIN QUERY PLANからの出力は、SQL文で指定された方法ではなく、実際にクエリがどのように評価されるかを示しています。</target>
        </trans-unit>
        <trans-unit id="70ac1e5ab36762649806ee198f0345318ef8e4bd" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">orderByConsumedは、&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt;からの出力がORDER BY句を満たすために正しい順序で発生するため、個別のソート手順が不要であることを意味します。</target>
        </trans-unit>
        <trans-unit id="a4ee366293d58487c3c181ee97d4fddeec053e83" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">orderByConsumedは、&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;からの出力がORDER BY句を満たすために正しい順序で発生するため、個別のソート手順が不要であることを意味します。</target>
        </trans-unit>
        <trans-unit id="361a689885e1ba1224dc1550da95ae3bd8151f01" translate="yes" xml:space="preserve">
          <source>The original UTF8 text of the vocabulary word</source>
          <target state="translated">単語の元のUTF8テキスト</target>
        </trans-unit>
        <trans-unit id="8f218b03066661856e3cf8a761cc5ae4bbd68ed0" translate="yes" xml:space="preserve">
          <source>The original document we put here was more of a &lt;a href=&quot;codeofethics&quot;&gt;Code of Ethics of the Project Founder&lt;/a&gt;. While we stand by those principles, they are not in line with the modern technical meaning of a Code of Conduct and have hence been renamed.</source>
          <target state="translated">ここに置いた元の文書は&lt;a href=&quot;codeofethics&quot;&gt;、プロジェクト創設者の倫理規定&lt;/a&gt;に近いものでした。私たちはそれらの原則を支持していますが、それらは行動規範の現代の技術的な意味と一致していないため、名前が変更されました。</target>
        </trans-unit>
        <trans-unit id="c32bb1620d101b8c498092185971e74a9cc27eb4" translate="yes" xml:space="preserve">
          <source>The original implementation of SQLite sought to follow &lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel's Law&lt;/a&gt; which states in part &quot;Be liberal in what you accept&quot;. This used to be considered good design - that a system would accept dodgy inputs and try to do the best it could without complaining too much. But lately, people have come to realize that it is sometimes better to be strict in what you accept, so as to more easily find errors in the input.</source>
          <target state="translated">SQLiteの最初の実装は、「受け入れるものを自由にする」ことを部分的に述べている&lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;ポステルの法則&lt;/a&gt;に従うことを目指していました。これは以前は優れた設計と見なされていました。システムは危険な入力を受け入れ、あまり文句を言わずに最善を尽くそうとするものでした。しかし、最近では、入力のエラーをより簡単に見つけるために、受け入れる内容を厳密にするほうがよい場合があることに気づくようになりました。</target>
        </trans-unit>
        <trans-unit id="faed9cec852456e57ebf990afb4cf1cac2f27e57" translate="yes" xml:space="preserve">
          <source>The original values for each modified field of the row.</source>
          <target state="translated">行の各変更されたフィールドの元の値。</target>
        </trans-unit>
        <trans-unit id="2a41f1df0018eecb7b908d40c9986e3b87989e32" translate="yes" xml:space="preserve">
          <source>The original values of any modified fields are omitted from UPDATE records.</source>
          <target state="translated">変更されたフィールドの元の値は、UPDATEレコードからは省略されます。</target>
        </trans-unit>
        <trans-unit id="f1449473437f390f79738378e7abd93ce9be7fe0" translate="yes" xml:space="preserve">
          <source>The other advantage to using SQLite in place of ZIP is that the document can now be updated incrementally, without risk of corrupting the document if a power loss or other crash occurs in the middle of the update. (Remember that writes to &lt;a href=&quot;atomiccommit&quot;&gt;SQLite databases are atomic&lt;/a&gt;.) True, all the content is still kept in a single big XML file (&quot;content.xml&quot;) which must be completely rewritten if so much as a single character changes. But with SQLite, only that one file needs to change. The other 77 files in the repository can remain unaltered. They do not all have to be rewritten, which in turn makes &quot;File/Save&quot; run much faster and saves wear on SSDs.</source>
          <target state="translated">ZIPの代わりにSQLiteを使用するもう1つの利点は、更新中に電源喪失やその他のクラッシュが発生した場合にドキュメントを破損するリスクなしに、ドキュメントを段階的に更新できることです。 （&lt;a href=&quot;atomiccommit&quot;&gt;SQLiteデータベース&lt;/a&gt;への書き込みはアトミックであることに注意してください。）確かに、すべてのコンテンツは単一の大きなXMLファイル（ &quot;content.xml&quot;）に保持され、単一の文字が変更された場合は完全に書き換える必要があります。しかし、SQLiteでは、その1つのファイルのみを変更する必要があります。リポジトリ内の他の77ファイルは変更されないままでかまいません。それらをすべて書き換える必要はありません。これにより、「ファイル/保存」の実行速度が大幅に向上し、SSDの消耗が抑えられます。</target>
        </trans-unit>
        <trans-unit id="ff8ed48a831b734ff6e1604276150ac99b9ac0e1" translate="yes" xml:space="preserve">
          <source>The other allowed parameters to sqlite3_mutex_alloc() (anything other than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each return a pointer to a static preexisting mutex. Nine static mutexes are used by the current version of SQLite. Future versions of SQLite may add additional static mutexes. Static mutexes are for internal use by SQLite only. Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE.</source>
          <target state="translated">sqlite3_mutex_alloc()に許可されている他のパラメータ(SQLITE_MUTEX_FASTとSQLITE_MUTEX_RECURSIVE以外のもの)は、それぞれ既存の静的なミューテックスへのポインタを返します。現在のバージョンの SQLite では 9 個の静的なミューテックスが使用されています。将来のバージョンの SQLite では、さらに静的ミューテックスが追加される可能性があります。静的ミューテックスはSQLiteの内部でのみ使用されます。SQLite のミューテックスを使用するアプリケーションは、SQLITE_MUTEX_FAST または SQLITE_MUTEX_RECURSIVE で返される動的ミューテックスのみを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e68942fbbde7b9568017891360f3a9246030e2a2" translate="yes" xml:space="preserve">
          <source>The other file, &quot;fts5.h&quot;, is not required to compile the FTS5 extension. It is used by applications that implement &lt;a href=&quot;fts5#extending_fts5&quot;&gt;custom FTS5 tokenizers or auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">他のファイル「fts5.h」は、FTS5拡張機能をコンパイルするために必要ではありません。これは、&lt;a href=&quot;fts5#extending_fts5&quot;&gt;カスタムFTS5トークナイザーまたは補助関数&lt;/a&gt;を実装するアプリケーションによって使用されます。</target>
        </trans-unit>
        <trans-unit id="f74c4fa3b3502ec3d363778205dc40519edfac8e" translate="yes" xml:space="preserve">
          <source>The other information required to create a changeset or patchset is read from the database file when &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called. Specifically,</source>
          <target state="translated">変更セットまたはパッチセットの作成に必要なその他の情報は、&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;または&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;が呼び出されたときにデータベースファイルから読み取られます。具体的には</target>
        </trans-unit>
        <trans-unit id="4ceb7a7a69cfd1205ea5e7612f272fc9e42d8423" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 11 through 25. In particular, the WHERE clause containing the IN operator is implemented by instructions at 16, 17, and 20. Instruction 16 pushes the value of the &quot;two&quot; column for the current row onto the stack and instruction 17 checks to see that it is non-NULL. If this is successful, execution jumps to 20, where it tests to see if top of the stack matches any key in the temporary table. The rest of the code is the same as what has been shown before.</source>
          <target state="translated">外側のSELECTは、命令11〜25によって実装される。特に、IN演算子を含むWHERE句は、命令16、17、および20によって実装される。命令16は現在の行の「2」列の値をスタックにプッシュし、命令17はそれがNULLでないことを確認します。これが成功した場合、実行は 20 にジャンプし、スタックの先頭が一時テーブルのキーと一致するかどうかをテストします。残りのコードは以前に示したものと同じです。</target>
        </trans-unit>
        <trans-unit id="636166e4ba0668356d630c0a9cb37eba4fcc8c00" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 14 through 25. In particular, the WHERE clause that contains the nested select is implemented by instructions 19 through 21. You can see that the result of the inner select is loaded onto the stack by instruction 20 and used by the conditional jump at 21.</source>
          <target state="translated">外側のSELECTは、命令14〜25によって実装される。特に、入れ子になったSELECTを含むWHERE句は、命令19から21までによって実装されています。内側のSELECTの結果は、命令20によってスタックにロードされ、21での条件ジャンプによって使用されることがわかります。</target>
        </trans-unit>
        <trans-unit id="fcdaf6e60b18b913fe64114ea32692d007183ab8" translate="yes" xml:space="preserve">
          <source>The outer loop over table examp is implement by instructions 7 through 23. The inner loop is instructions 13 through 22. Notice that the &quot;two&amp;lt;50&quot; term of the WHERE expression involves only columns from the first table and can be factored out of the inner loop. SQLite does this and implements the &quot;two&amp;lt;50&quot; test in instructions 10 through 12. The &quot;four==two&quot; test is implement by instructions 14 through 16 in the inner loop.</source>
          <target state="translated">テーブル試験の外側のループは、命令7〜23によって実装されます。内側のループは、命令13〜22です。WHERE式の「two &amp;lt;50」項には、最初のテーブルの列のみが含まれ、内部ループ。 SQLiteはこれを行い、命令10から12で「two &amp;lt;50」テストを実装します。「four == two」テストは、内部ループの命令14から16で実装されます。</target>
        </trans-unit>
        <trans-unit id="0e7b99d6dfc2b5d85e34f55e3ea4da579b189034" translate="yes" xml:space="preserve">
          <source>The output begins with a report of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; (cross-checked again &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;) for the SQLite under test and the compile-time options used as reported by &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt;. The output concludes with a summary of the test results and a repeat of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;. If any errors are detected, additional lines detail the problem. The error reporting lines always begin with a single space character so that they can be quickly extracted from large output files using:</source>
          <target state="translated">出力のレポートから始まる&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;（クロスチェック再び&lt;a href=&quot;c3ref/libversion&quot;&gt;（sqlite3_sourceid）&lt;/a&gt;試験下SQLiteのための）によって報告されたように使用されるコンパイル時オプション&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（） &lt;/a&gt;。出力は、テスト結果の要約と&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_IDの&lt;/a&gt;繰り返しで終わります。エラーが検出された場合、追加の行に問題の詳細が示されます。エラー報告行は常に単一の空白文字で始まるため、次のコマンドを使用して大きな出力ファイルからすばやく抽出できます。</target>
        </trans-unit>
        <trans-unit id="b2295d00e027ddb605dbb2cc9b7646825272b788" translate="yes" xml:space="preserve">
          <source>The output from EXPLAIN and EXPLAIN QUERY PLAN is intended for interactive analysis and troubleshooting only. The details of the output format are subject to change from one release of SQLite to the next. Applications should not use EXPLAIN or EXPLAIN QUERY PLAN since their exact behavior is variable and only partially documented.</source>
          <target state="translated">EXPLAINおよびEXPLAIN QUERY PLANからの出力は、対話的な分析およびトラブルシューティングのみを目的としています。出力形式の詳細は、SQLiteのあるリリースから次のリリースへと変更される可能性があります。アプリケーションは、EXPLAINやEXPLAIN QUERY PLANの正確な動作は可変であり、部分的にしか文書化されていないため、EXPLAINやEXPLAIN QUERY PLANを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="235163a8fba9aa1445cd051f01c741ea66911c96" translate="yes" xml:space="preserve">
          <source>The output from the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; script shows the number of CPU cycles spent on each line of code. The report is approximately 80,000 lines long. The following is a brief snippet taken from the middle of the report to show what it looks like:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt;スクリプトからの出力は、コードの各行で費やされたCPUサイクルの数を示しています。レポートの長さは約80,000行です。以下は、レポートの中央から抜粋した短いスニペットです。</target>
        </trans-unit>
        <trans-unit id="4c55fd24704ccac9a200bb25fe01e36a7bd6347b" translate="yes" xml:space="preserve">
          <source>The output from the mkth3.tcl script is a C program that contains everything needed to run the tests - everything that is except for the SQLite library itself. The generated test program contains implementations for all of the support interfaces used by the test modules and it contains the &lt;code&gt;main()&lt;/code&gt; routine that drives the tests. To convert the test program into a working executable, simply compile it against SQLite:</source>
          <target state="translated">mkth3.tclスクリプトからの出力は、テストの実行に必要なすべてのもの（SQLiteライブラリ自体を除くすべて）を含むCプログラムです。生成されたテストプログラムには、テストモジュールで使用されるすべてのサポートインターフェイスの実装が含まれ、テストを実行する &lt;code&gt;main()&lt;/code&gt; ルーチンが含まれます。テストプログラムを実行可能な実行可能ファイルに変換するには、SQLiteに対してコンパイルするだけです。</target>
        </trans-unit>
        <trans-unit id="abe6a29295e5add598505fe98eb212b9e3e6e910" translate="yes" xml:space="preserve">
          <source>The output is a human-readable ASCII text report that provides information on the space utilization of the database file. The report is intended to be self-explanatory, though there is some &lt;a href=&quot;sqlanalyze#defs&quot;&gt;additional explanation&lt;/a&gt; of the various parameters reported toward the end of the report.</source>
          <target state="translated">出力は、データベースファイルのスペース使用率に関する情報を提供する、人間が読めるASCIIテキストレポートです。レポートは、&lt;a href=&quot;sqlanalyze#defs&quot;&gt;説明&lt;/a&gt;の終わりに向けて報告されたさまざまなパラメーターのいくつかの追加の説明がありますが、自明です。</target>
        </trans-unit>
        <trans-unit id="89607a5138078e5c86fca97ee25682b106679c11" translate="yes" xml:space="preserve">
          <source>The output is also valid SQL. Most of the report text is contained within a header comment, with various SQL statements that create and initialize a database at the &lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;end of the report&lt;/a&gt;. The constructed database contains the raw data from which the report was extracted. Hence the original report can be read into an instance of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and then the raw data can be queried to dig deeper into the space utilization of a particular database file.</source>
          <target state="translated">出力も有効なSQLです。ほとんどのレポートテキストは、レポートの&lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;最後に&lt;/a&gt;データベースを作成および初期化するさまざまなSQLステートメントとともに、ヘッダーコメント内に含まれています。構築されたデータベースには、レポートが抽出された元のデータが含まれています。したがって、元のレポートを&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;インスタンスに読み込んでから、生データをクエリして、特定のデータベースファイルのスペース使用率をさらに詳しく調べることができます。</target>
        </trans-unit>
        <trans-unit id="bcfd95781cb98e2851bb0886cd3f1a588c682428" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; now shows each individual SQL statement run within a trigger.</source>
          <target state="translated">&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;の出力に、トリガー内で実行された個々のSQLステートメントが表示されるようになりました。</target>
        </trans-unit>
        <trans-unit id="2d09f331aa1d428bbd3337e80bd418ed5659e816" translate="yes" xml:space="preserve">
          <source>The output of this revised query is:</source>
          <target state="translated">この修正されたクエリの出力は</target>
        </trans-unit>
        <trans-unit id="e3541aa5b140ee88f1e6bb5e89e08e8618d880af" translate="yes" xml:space="preserve">
          <source>The outputs s0 and s1 are both weighted checksums using Fibonacci weights in reverse order. (The largest Fibonacci weight occurs on the first element of the sequence being summed.) The s1 value spans all 32-bit integer terms of the sequence whereas s0 omits the final term.</source>
          <target state="translated">出力 s0 と s1 は、逆順にフィボナッチ重みを使用した重み付きチェックサムです。(最大のフィボナッチ重みは、合計されるシーケンスの最初の要素で発生します)。s1の値はシーケンスのすべての32ビット整数項に及びますが、s0は最終項を省略しています。</target>
        </trans-unit>
        <trans-unit id="2d1abc65d901f9a5d25ea3d57ab5dd49e8f85287" translate="yes" xml:space="preserve">
          <source>The overflow thresholds are designed to give a minimum fanout of 4 for index b-trees and to make sure enough of the payload is on the b-tree page that the record header can usually be accessed without consulting an overflow page. In hindsight, the designer of the SQLite b-tree logic realized that these thresholds could have been made much simpler. However, the computations cannot be changed without resulting in an incompatible file format. And the current computations work well, even if they are a little complex.</source>
          <target state="translated">オーバーフローしきい値は、インデックス b-tree の最小ファンアウトが 4 になるように設計されており、ペイロードが b-tree ページに十分にあることを確認して、通常はオーバーフローページを参照せずにレコードヘッダーにアクセスできるようになっています。今にして思えば、SQLite の b-tree ロジックの設計者は、これらのしきい値をもっとシンプルにできたかもしれないことに気づきました。しかし、互換性のないファイル形式になることなく計算を変更することはできません。そして、現在の計算は、多少複雑であってもうまく機能しています。</target>
        </trans-unit>
        <trans-unit id="ac70d959175f460608260178c8989bd26b78e65e" translate="yes" xml:space="preserve">
          <source>The pAppData pointer is unused by the SQLite core. The pointer is available to store auxiliary information that a VFS information might want to carry around.</source>
          <target state="translated">pAppData ポインタは SQLite コアでは使用されません。このポインタは、VFS 情報が持ち歩きたいと思うような補助情報を格納するために使用できます。</target>
        </trans-unit>
        <trans-unit id="18730b00ae23b4c106f1118f96d5a509058fa368" translate="yes" xml:space="preserve">
          <source>The pBuf parameter is a pointer to a contiguous range of bytes that SQLite will use for page-cache memory allocations. The buffer must be at least sz*N bytes in size. The &quot;sz&quot; parameter is the size of each page-cache allocation. N is the maximum number of available allocations.</source>
          <target state="translated">pBuf パラメータは、SQLite がページキャッシュメモリの割り当てに使用する連続したバイト数の範囲へのポインタです。バッファのサイズは最低でも sz*N バイトでなければなりません。sz&quot; パラメータは、各ページキャッシュの割り当てのサイズです。N は利用可能な割り当ての最大数です。</target>
        </trans-unit>
        <trans-unit id="ac154834d9f47915a3416a80860f0b58cefd5585" translate="yes" xml:space="preserve">
          <source>The pContext member of the sqlite3_rtree_geometry structure is always set to a copy of the pContext argument passed to sqlite3_rtree_geometry_callback() when the callback is registered. The aParam[] array (size nParam) contains the parameter values passed to the SQL function on the right-hand side of the MATCH operator. In the example &quot;circle&quot; query above, nParam would be set to 3 and the aParam[] array would contain the three values 45.3, 22.9 and 5.0.</source>
          <target state="translated">sqlite3_rtree_geometry構造体のpContextメンバには、コールバックが登録されているときは常にsqlite3_rtree_geometry_callback()に渡されたpContext引数のコピーが設定されています。aParam[]配列(サイズnParam)には、MATCH演算子の右側にあるSQL関数に渡されたパラメータ値が含まれています。上の例の &quot;circle &quot;クエリでは、nParamは3に設定され、aParam[]配列には45.3、22.9、5.0の3つの値が含まれています。</target>
        </trans-unit>
        <trans-unit id="e127dc3dcbbc20bee3b0cdc450a4bea7c1e6776f" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されたイテレータ、または&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されたイテレータのいずれかです。後者の場合、&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;最後のsqlite3changeset_next（）の&lt;/a&gt;呼び出しでSQLITE_ROWが返されている&lt;a href=&quot;rescode#row&quot;&gt;はず&lt;/a&gt;です。そうでない場合、この関数は&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="135aebf5a9dd2b851dadacfebf43a14b9409aa81" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されるイテレータ、または&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されるイテレータのいずれかです。後者の場合、&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;への最後の呼び出しでSQLITE_ROWが返されている必要があります。さらに、イテレータが現在ポイントしている変更のタイプが&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;または&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかである場合にのみ呼び出されます。それ以外の場合、この関数は&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;を返し、* ppValueをNULLに設定します。</target>
        </trans-unit>
        <trans-unit id="47ae6763d58288a12e6ca470cf923677f0731f46" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されるイテレータ、または&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されるイテレータのいずれかです。後者の場合、&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;への最後の呼び出しでSQLITE_ROWが返されている必要があります。さらに、イテレータが現在指している変更のタイプが&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;または&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERTの&lt;/a&gt;いずれかである場合にのみ呼び出されます。それ以外の場合、この関数は&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;を返し、* ppValueをNULLに設定します。</target>
        </trans-unit>
        <trans-unit id="5f4815a3e637ae9700d2b5b8cf01f7df97a164dc" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されたイテレータ、または&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されたイテレータのいずれかです。後者の場合、&lt;a href=&quot;sqlite3changeset_next&quot;&gt;最後のsqlite3changeset_next（）の&lt;/a&gt;呼び出しでSQLITE_ROWが返されている&lt;a href=&quot;../rescode#row&quot;&gt;はず&lt;/a&gt;です。そうでない場合、この関数は&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="5cb49779aa9657ac4af96a2c62fd60bce7011cad" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されるイテレータ、または&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されるイテレータのいずれかです。後者の場合、&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;への最後の呼び出しでSQLITE_ROWが返されている必要があります。さらに、イテレータが現在ポイントしている変更のタイプが&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;または&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかである場合にのみ呼び出されます。それ以外の場合、この関数は&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;を返し、* ppValueをNULLに設定します。</target>
        </trans-unit>
        <trans-unit id="836812d109e0eaaadd1e45a40c1311bde5cb7d98" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されるイテレータ、または&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されるイテレータのいずれかです。後者の場合、&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;への最後の呼び出しでSQLITE_ROWが返されている必要があります。さらに、イテレータが現在指している変更のタイプが&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;または&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERTの&lt;/a&gt;いずれかである場合にのみ呼び出されます。それ以外の場合、この関数は&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;を返し、* ppValueをNULLに設定します。</target>
        </trans-unit>
        <trans-unit id="87ffccb080e4ff9265c31827b97ddd2621e463bc" translate="yes" xml:space="preserve">
          <source>The pNext field is the only field in the sqlite3_vfs structure that SQLite will ever modify. SQLite will only access or modify this field while holding a particular static mutex. The application should never modify anything within the sqlite3_vfs object once the object has been registered.</source>
          <target state="translated">pNextフィールドはsqlite3_vfs構造体の中でSQLiteが変更する唯一のフィールドです。SQLiteは特定の静的ミューテックスを保持している間だけこのフィールドにアクセスしたり、変更したりします。オブジェクトが登録された後は、アプリケーションはsqlite3_vfsオブジェクト内の何かを変更してはいけません。</target>
        </trans-unit>
        <trans-unit id="754388a17b97b997745df633f79a8efeaffaaacb" translate="yes" xml:space="preserve">
          <source>The pNext field is used internally by SQLite. Specifically, SQLite uses this field to form a linked list of registered VFSes.</source>
          <target state="translated">pNext フィールドは、SQLite によって内部的に使用されます。具体的には、SQLite はこのフィールドを使用して、登録された VFS のリンクされたリストを形成します。</target>
        </trans-unit>
        <trans-unit id="ed269faa072ea0bc301321c2683b96864943c28b" translate="yes" xml:space="preserve">
          <source>The pUser and xDelUser members of the sqlite3_rtree_geometry structure are initially set to NULL. The pUser variable may be set by the callback implementation to any arbitrary value that may be useful to subsequent invocations of the callback within the same query (for example, a pointer to a complicated data structure used to test for region intersection). If the xDelUser variable is set to a non-NULL value, then after the query has finished running SQLite automatically invokes it with the value of the pUser variable as the only argument. In other words, xDelUser may be set to a destructor function for the pUser value.</source>
          <target state="translated">sqlite3_rtree_geometry構造体のpUserとxDelUserメンバは初期状態ではNULLに設定されます。pUser変数は、コールバックの実装によって任意の値に設定することができ、同じクエリ内でコールバックを呼び出す際に役立ちます(例えば、領域の交差をテストするために使用される複雑なデータ構造へのポインタなど)。xDelUser変数にNULLではない値が設定されている場合、クエリの実行が終了すると、SQLiteは自動的にpUser変数の値を唯一の引数としてコールバックを呼び出します。言い換えれば、xDelUser は pUser の値に対してデストラクタ関数に設定されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="17b3e72d28371d5d2ffa9ec67e0ffe035454e59f" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">ページキャッシュは、ヒープからではなく、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;、...）によって提供される独自のメモリプールから割り当てます。</target>
        </trans-unit>
        <trans-unit id="c49923490f20015de5b3c1344ee709093d18e9ac" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">ページキャッシュは、ヒープからではなく、&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;、...）によって提供される独自のメモリプールから割り当てます。</target>
        </trans-unit>
        <trans-unit id="a302370f325aa6580998e916c1cd813d2e0b53c6" translate="yes" xml:space="preserve">
          <source>The page number in the database file</source>
          <target state="translated">データベースファイルのページ番号</target>
        </trans-unit>
        <trans-unit id="cb3defd1f8ac1da0588e9ad79d27848df6931c39" translate="yes" xml:space="preserve">
          <source>The page number of the database page associated with this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2ed89da4b6a6d4a6521b481ff6c43d5bdf9213" translate="yes" xml:space="preserve">
          <source>The page number of the largest root b-tree page when in auto-vacuum or incremental-vacuum modes, or zero otherwise.</source>
          <target state="translated">自動バキュームモードまたはインクリメンタルバキュームモードの場合は最大のルートb-treeページのページ番号、そうでない場合は0です。</target>
        </trans-unit>
        <trans-unit id="9a28509eee63401403c2ae3763725cac2ca99893" translate="yes" xml:space="preserve">
          <source>The page number of the page on which this row was found.</source>
          <target state="translated">この行が発見されたページのページ番号です。</target>
        </trans-unit>
        <trans-unit id="41b015c66ddae0dbc3440c640484bd01738dbaf6" translate="yes" xml:space="preserve">
          <source>The page size and cache size can also be set or changed at run-time using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;, respectively.</source>
          <target state="translated">ページサイズとキャッシュサイズは、それぞれ&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_sizeプラグマ&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_sizeプラグマ&lt;/a&gt;を使用して、実行時に設定または変更することもできます。</target>
        </trans-unit>
        <trans-unit id="0105846f7fbf6f81d53292a1128d1e82d5804983" translate="yes" xml:space="preserve">
          <source>The page to be fetched is determined by the key. The minimum key value is 1. After it has been retrieved using xFetch, the page is considered to be &quot;pinned&quot;.</source>
          <target state="translated">フェッチされるページは、キーによって決定されます。キーの最小値は1で、xFetchで取得された後、そのページは &quot;ピン留めされている &quot;とみなされます。</target>
        </trans-unit>
        <trans-unit id="ae6ce89a0e7b046f1218400c05d873074d2788d0" translate="yes" xml:space="preserve">
          <source>The page-cache memory allocator is disabled by default. An application can enable it at start-time as follows:</source>
          <target state="translated">ページキャッシュメモリアロケータはデフォルトでは無効になっています。アプリケーションは、以下のように起動時に有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="79944cfbe90583fe884c628acc92c56b549b69ab" translate="yes" xml:space="preserve">
          <source>The pager and btree subsystems added back. They are now the only available backend.</source>
          <target state="translated">ページャーとbtreeサブシステムが追加されました。これらは現在、唯一の利用可能なバックエンドとなっています。</target>
        </trans-unit>
        <trans-unit id="177ac3877a5c726efa0192a81b9a621bfc8aa28e" translate="yes" xml:space="preserve">
          <source>The pager is unconcerned with the details of B-Trees, text encodings, indices, and so forth. From the point of view of the pager the database consists of a single file of uniform-sized blocks. Each block is called a &quot;page&quot; and is usually 1024 bytes in size. The pages are numbered beginning with 1. So the first 1024 bytes of the database are called &quot;page 1&quot; and the second 1024 bytes are call &quot;page 2&quot; and so forth. All other encoding details are handled by higher layers of the library. The pager communicates with the operating system using one of several modules (Examples: &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt; os_unix.c&lt;/a&gt;, &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt; os_win.c&lt;/a&gt;) that provides a uniform abstraction for operating system services.</source>
          <target state="translated">ページャーは、Bツリー、テキストエンコーディング、インデックスなどの詳細に関心がありません。ページャーの観点から見ると、データベースは均一サイズのブロックの単一ファイルで構成されています。各ブロックは「ページ」と呼ばれ、サイズは通常1024バイトです。ページには1から始まる番号が付けられています。したがって、データベースの最初の1024バイトは「ページ1」と呼ばれ、2番目の1024バイトは「ページ2」と呼ばれます。他のすべてのエンコーディングの詳細は、ライブラリの上位層で処理されます。ページャーは、オペレーティングシステムサービスに統一された抽象化を提供するいくつかのモジュール（例：&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;、&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt;os_win.c&lt;/a&gt;）の1つを使用して、オペレーティングシステムと通信します。</target>
        </trans-unit>
        <trans-unit id="5acaa405b470e4fb9ef36344daf0f015a3d5bf69" translate="yes" xml:space="preserve">
          <source>The pager module effectively controls access for separate threads, or separate processes, or both. Throughout this document whenever the word &quot;process&quot; is written you may substitute the word &quot;thread&quot; without changing the truth of the statement.</source>
          <target state="translated">ページャーモジュールは、別々のスレッド、あるいは別々のプロセス、あるいはその両方へのアクセスを効果的に制御します。この文書中では、&quot;process&quot; という単語が書かれているときはいつでも、文の真偽を変えることなく &quot;thread&quot; という単語で代用することができます。</target>
        </trans-unit>
        <trans-unit id="3fbaa9934c130eb17f7eada7403c9132c86bbc58" translate="yes" xml:space="preserve">
          <source>The pager module is very robust but it can be subverted. This section attempts to identify and explain the risks. (See also the &lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;Things That Can Go Wrong&lt;/a&gt; section of the article on &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt;.</source>
          <target state="translated">ページャーモジュールは非常に堅牢ですが、破壊される可能性があります。このセクションでは、リスクの特定と説明を試みます。（&lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt;に関する記事の&lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;間違っている可能性のある&lt;/a&gt;セクションも参照してください。</target>
        </trans-unit>
        <trans-unit id="0f15cdebe573fd03148e855390c11255190632e7" translate="yes" xml:space="preserve">
          <source>The paragraph above notes that a MATCH operator with a simple term as the right-hand operand evaluates to true for all documents that contain the specified term. In this context, the &quot;document&quot; may refer to either the data stored in a single column of a row of an FTS table, or to the contents of all columns in a single row, depending on the identifier used as the left-hand operand to the MATCH operator. If the identifier specified as the left-hand operand of the MATCH operator is an FTS table column name, then the document that the search term must be contained in is the value stored in the specified column. However, if the identifier is the name of the FTS</source>
          <target state="translated">上の段落では、右手のオペランドとして単純な用語を持つMATCH演算子は、指定された用語を含むすべての文書に対して真として評価されることに注意してください。この文脈では、「文書」は、MATCH演算子への左手オペランドとして使用される識別子に応じて、FTSテーブルの行の単一の列に格納されたデータ、または単一の行のすべての列の内容のいずれかを参照することができる。MATCH演算子の左側のオペランドとして指定された識別子がFTSテーブルの列名である場合、検索語が含まれなければならない文書は、指定された列に格納されている値である。ただし、識別子がFTS</target>
        </trans-unit>
        <trans-unit id="15582287ef68bc76059b207ebd8e45ad35a9f199" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;../opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">パラメーターPは、コールバック関数Xへの唯一のパラメーターとして渡されます。パラメーターNは、コールバックXの連続した呼び出し間で評価される&lt;a href=&quot;../opcode&quot;&gt;仮想マシン命令の&lt;/a&gt;おおよその数です。Nが1未満の場合、進行ハンドラーは無効になります。</target>
        </trans-unit>
        <trans-unit id="de8aa7c163a7cfc0e81022005dde253ed27f9cea" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">パラメーターPは、コールバック関数Xへの唯一のパラメーターとして渡されます。パラメーターNは、コールバックXの連続した呼び出し間で評価される&lt;a href=&quot;opcode&quot;&gt;仮想マシン命令の&lt;/a&gt;おおよその数です。Nが1未満の場合、進行ハンドラーは無効になります。</target>
        </trans-unit>
        <trans-unit id="b6a1b97180e82088f349d801a8feb225d5ea8536" translate="yes" xml:space="preserve">
          <source>The parameters to the callback are the pArg value, the amount of memory currently in use, and the size of the allocation that provoked the callback. The callback will presumably invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; to free up memory space. The callback may invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; but if it does, no additional callbacks will be invoked by the recursive calls.</source>
          <target state="translated">コールバックのパラメーターは、pArg値、現在使用中のメモリの量、およびコールバックを引き起こした割り当てのサイズです。コールバックはおそらく&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を呼び出してメモリ空間を解放します。コールバックは&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（）を&lt;/a&gt;呼び出すことができますが、呼び出す場合、再帰呼び出しによって追加のコールバックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="a0635b4b828516772af2e4a5c5f8f7c2b0b83854" translate="yes" xml:space="preserve">
          <source>The parent and sub-query may contain WHERE clauses. Subject to rules (11), (12) and (13), they may also contain ORDER BY, LIMIT and OFFSET clauses.</source>
          <target state="translated">親問い合わせおよび副問い合わせはWHERE句を含むことができます。規則(11)、(12)および(13)に従って、それらはORDER BY、LIMITおよびOFFSET句を含むことができます。</target>
        </trans-unit>
        <trans-unit id="6d5030cd0c93ffa44cd5f784ea6b109c2ce36ffc" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint are not the primary key of the parent table and are not subject to a unique constraint using collating sequence specified in the CREATE TABLE, or</source>
          <target state="translated">外部キー制約で指定された親キー列は、親テーブルの主キーではなく、CREATE TABLEで指定された照合順序を使用した一意の制約の対象ではない、または</target>
        </trans-unit>
        <trans-unit id="0feae637448fae26652f631fd44b61bcd440968a" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint do not exist, or</source>
          <target state="translated">外部キー制約で指定された親キー・カラムが存在しないか、または</target>
        </trans-unit>
        <trans-unit id="ba132dacfac52109e850c048192c0d768817957a" translate="yes" xml:space="preserve">
          <source>The parent table does not exist, or</source>
          <target state="translated">親テーブルが存在しないか</target>
        </trans-unit>
        <trans-unit id="cfb0e652f64b7c831f470e25c9ae00145b03ba52" translate="yes" xml:space="preserve">
          <source>The parser assigns meaning to tokens based on their context. The parser for SQLite is generated using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;. Lemon does the same job as YACC/BISON, but it uses a different input syntax which is less error-prone. Lemon also generates a parser which is reentrant and thread-safe. And Lemon defines the concept of a non-terminal destructor so that it does not leak memory when syntax errors are encountered. The grammar file that drives Lemon and that defines the SQL language that SQLite understands is found in &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;.</source>
          <target state="translated">パーサーは、コンテキストに基づいてトークンに意味を割り当てます。 SQLiteのパーサーは、&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーター&lt;/a&gt;を使用して生成されます。レモンはYACC / BISONと同じ働きをしますが、エラーが発生しにくい異なる入力構文を使用します。 Lemonは、再入可能でスレッドセーフなパーサーも生成します。また、Lemonは非構文のデストラクタの概念を定義しているため、構文エラーが発生したときにメモリをリークしません。レモンを駆動し、SQLiteが理解するSQL言語を定義する文法ファイルは、&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.yにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="bba39e24b4502de9e348487cd65024dc8a8b4825" translate="yes" xml:space="preserve">
          <source>The parser now insists on seeing a semicolon or the end of input before executing a statement. This avoids an accidental disaster if the WHERE keyword is misspelled in an UPDATE or DELETE statement.</source>
          <target state="translated">パーサは、文を実行する前にセミコロンまたは入力の末尾を確認するようになりました。これにより、UPDATE 文や DELETE 文で WHERE キーワードのスペルが間違っていた場合の偶発的な災害を回避することができます。</target>
        </trans-unit>
        <trans-unit id="276468011b3fce8fd043bc0ac6f52f8e374eb1fe" translate="yes" xml:space="preserve">
          <source>The parser used by SQLite is forgiving. It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity. For example, the statement &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot; is accepted by SQLite, and creates a new table named &quot;BEGIN&quot; with three columns named &quot;REPLACE&quot;, &quot;PRAGMA&quot;, and &quot;END&quot;. Nevertheless, best practice is to avoid using keywords as identifiers. Common techniques used to avoid keyword name collisions include:</source>
          <target state="translated">SQLite が使用するパーサは寛容です。キーワードを識別子として使用することは、そのような使用が解析の曖昧さをもたらさない限り、しばしば可能です。例えば、&quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot;という文はSQLiteに受け入れられ、&quot;REPLACE&quot;、&quot;PRAGMA&quot;、&quot;END &quot;という3つのカラムを持つ &quot;BEGIN &quot;という名前の新しいテーブルを作成します。それにもかかわらず、識別子としてキーワードを使用しないようにするのが最善の方法です。キーワード名の衝突を避けるために使用される一般的なテクニックには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="cf399069b7a65af0b661c7a78ceab3a98b1156db" translate="yes" xml:space="preserve">
          <source>The parser's stack was overflowing on a very long UPDATE statement. This is now fixed.</source>
          <target state="translated">非常に長いUPDATE文でパーサのスタックがオーバーフローしていました。これは修正されました。</target>
        </trans-unit>
        <trans-unit id="a5c83958bfdec6a8c2fd0d74498090055bde1a94" translate="yes" xml:space="preserve">
          <source>The parsing of SQL statements is a significant consumer of CPU cycles in any SQL database engine. On-going efforts to optimize SQLite have caused the developers to spend a lot of time tweaking Lemon to generate faster parsers. These efforts have benefited all users of the Lemon parser generator, not just SQLite. But if Lemon had been a separately maintained tool, it would have been more difficulty to make coordinated changes to both SQLite and Lemon, and as a result not as much optimization would have been accomplished. Hence, the fact that the parser generator tool is included in the source tree for SQLite has turned out to be a net benefit for both the tool itself and for SQLite.</source>
          <target state="translated">SQL文の解析は、どのSQLデータベースエンジンにおいてもCPUサイクルの重要な消費者です。SQLiteを最適化するための継続的な努力により、開発者は、より高速なパーサを生成するためにLemonを調整することに多くの時間を費やしてきました。これらの努力は、SQLiteだけでなく、Lemonパーサジェネレータのすべてのユーザに利益をもたらしました。しかし、もし Lemon が個別にメンテナンスされたツールであったならば、SQLite と Lemon の両方に調整された変更を行うのはより困難であり、その結果、多くの最適化が達成されなかったでしょう。したがって、パーサジェネレータツールがSQLiteのソースツリーに含まれているという事実は、ツール自体とSQLiteの両方に純利益をもたらすことが判明しました。</target>
        </trans-unit>
        <trans-unit id="7d2ca17144abc28a05044c4d5d55dce18e17a921" translate="yes" xml:space="preserve">
          <source>The part of the name prior to the last &quot;_&quot; exactly matches the name of a virtual table that was created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;. (Shadow tables are not recognized for &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt; and &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.)</source>
          <target state="translated">名前の最後の「_」より前の部分は、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;を使用して作成された仮想テーブルの名前と完全に一致します。 （シャドウテーブルは、&lt;a href=&quot;vtab#epovtab&quot;&gt;代名詞の仮想テーブル&lt;/a&gt;および&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数で&lt;/a&gt;は認識されません。）</target>
        </trans-unit>
        <trans-unit id="042a9e73444095c51cd83e16473e75bf7e45a5e4" translate="yes" xml:space="preserve">
          <source>The patch level Z was historically only used for bug-fix releases that changed only a small number of code lines.</source>
          <target state="translated">パッチレベルZは歴史的にバグフィックスリリースにのみ使用されていたもので、コード行数の少ないものしか変更されていませんでした。</target>
        </trans-unit>
        <trans-unit id="274dfc20017243c18164f876bdd5c3980ade92fe" translate="yes" xml:space="preserve">
          <source>The path component of the URI specifies the disk file that is the SQLite database to be opened. If the path component is omitted, then the database is stored in a temporary file that will be automatically deleted when the database connection closes. If the authority section is present, then the path is always an absolute pathname. If the authority section is omitted, then the path is an absolute pathname if it begins with the &quot;/&quot; character (ASCII code 0x2f) and is a relative pathname otherwise. On windows, if the absolute path begins with &quot;&lt;b&gt;/&lt;i&gt;X&lt;/i&gt;:/&lt;/b&gt;&quot; where &lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt; is any single ASCII alphabetic character (&quot;a&quot; through &quot;z&quot; or &quot;A&quot; through &quot;Z&quot;) then the &quot;&lt;b&gt;&lt;i&gt;X:&lt;/i&gt;&lt;/b&gt;&quot; is understood to be the drive letter of the volume containing the file, not the toplevel directory.</source>
          <target state="translated">URIのパスコンポーネントは、開かれるSQLiteデータベースであるディスクファイルを指定します。パスコンポーネントを省略した場合、データベースは一時ファイルに保存され、データベース接続が閉じたときに自動的に削除されます。権限セクションが存在する場合、パスは常に絶対パス名です。権限セクションが省略されている場合、パスは、「/」文字（ASCIIコード0x2f）で始まる場合は絶対パス名で、それ以外の場合は相対パス名です。 Windowsでは、絶対パスが &quot; &lt;b&gt;/ &lt;i&gt;X&lt;/i&gt;：/&lt;/b&gt; &quot;で始まる場合、&lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt;は任意の単一のASCIIアルファベット文字（ &quot;a&quot;から &quot;z&quot;または &quot;A&quot;から &quot;Z&quot;）であり、 &quot; &lt;b&gt;&lt;i&gt;X：&lt;/i&gt;&lt;/b&gt;&quot;は、トップレベルディレクトリではなく、ファイルを含むボリュームのドライブ文字であると理解されます。</target>
        </trans-unit>
        <trans-unit id="f3532ac83d22ad95431b31438dce70e426b9f355" translate="yes" xml:space="preserve">
          <source>The path is optional if the authority is present. If the authority is omitted then the path is required.</source>
          <target state="translated">権限があればパスは任意です。権限が省略された場合はパスが必須となります。</target>
        </trans-unit>
        <trans-unit id="5dd0cabb7668cbee80844078c73a695152a285b7" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;amp;sup2) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="translated">デフォルトの&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;および&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOBで&lt;/a&gt;使用されるパターンマッチングアルゴリズムSQLiteの実装は、特定の病的ケースに対してO（N＆sup2）パフォーマンス（Nはパターン内の文字数）を発揮できます。独自のLIKEまたはGLOBパターンを指定できる悪意のあるユーザーによるサービス拒否攻撃を回避するために、LIKEまたはGLOBパターンの長さはSQLITE_MAX_LIKE_PATTERN_LENGTHバイトに制限されています。この制限のデフォルト値は50000です。最近のワークステーションは、50000バイトの病理学的なLIKEまたはGLOBパターンでも比較的迅速に評価できます。サービス拒否の問題は、パターンの長さが数百万バイトに達したときにのみ発生します。それにもかかわらず、最も有用なLIKEまたはGLOBパターンは最大で数十バイトの長さなので、偏執狂的なアプリケーション開発者は、外部ユーザーが任意のパターンを生成できることを知っている場合、このパラメーターを数百の範囲に減らすことができます。</target>
        </trans-unit>
        <trans-unit id="202855d0443faeb5dfa8c360619529b04d6a4b20" translate="yes" xml:space="preserve">
          <source>The people table has one entry for each person in a large organization. Each person is either a &quot;student&quot; or a &quot;teacher&quot;, as determined by the &quot;role&quot; field. And we record the height in centimeters of each person. The role and height are indexed. Notice that the left-most column of the index is not very selective - it only contains two possible values.</source>
          <target state="translated">人物表には、大きな組織内の各人物のために1つのエントリがあります。各人は「役割」の欄で決められた「生徒」か「教師」のどちらかです。そして、各人の身長をセンチメートル単位で記録します。役割と身長がインデックス化されています。インデックスの左端の列はあまり選択性が高くないことに注意してください-2つの可能な値しか含まれていません。</target>
        </trans-unit>
        <trans-unit id="92b29d0fa9a5e447b11571a63811cd4169611d21" translate="yes" xml:space="preserve">
          <source>The per-connection statistics do not use global variables and hence do not require mutexes to update or access. Consequently the per-connection statistics continue to function even if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is turned off.</source>
          <target state="translated">接続ごとの統計はグローバル変数を使用しないため、更新またはアクセスするためにミューテックスを必要としません。その結果、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;がオフになっていても、接続ごとの統計は機能し続けます。</target>
        </trans-unit>
        <trans-unit id="50dbff919de02c3f0e66d4c1de101521648ed2d5" translate="yes" xml:space="preserve">
          <source>The performance can be improved slightly by bypassing the SQL layer and reading the blob content directly using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface, as shown in the next chart:</source>
          <target state="translated">次のグラフに示すように、SQLレイヤーをバイパスし、&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;インターフェースを使用してblobコンテンツを直接読み取ることで、パフォーマンスをわずかに改善できます。</target>
        </trans-unit>
        <trans-unit id="095c3d78e34e00649d5524d5d46327c65695f40f" translate="yes" xml:space="preserve">
          <source>The performance difference arises (we believe) because when working from an SQLite database, the open() and close() system calls are invoked only once, whereas open() and close() are invoked once for each blob when using blobs stored in individual files. It appears that the overhead of calling open() and close() is greater than the overhead of using the database. The size reduction arises from the fact that individual files are padded out to the next multiple of the filesystem block size, whereas the blobs are packed more tightly into an SQLite database.</source>
          <target state="translated">このパフォーマンスの違いは、SQLite データベースから作業を行う場合、open()と close()のシステムコールは一度だけ呼び出されるのに対し、個々のファイルに格納された blob を使用する場合は、各 blob に対して open()と close()が一度だけ呼び出されるために生じると考えられます (私たちは考えています)。open()とclose()を呼び出すオーバーヘッドは、データベースを使用するオーバーヘッドよりも大きいようです。サイズが小さくなるのは、個々のファイルがファイルシステムのブロックサイズの次の倍数までパディングされるのに対し、ブロブはSQLiteデータベースの中によりタイトに詰め込まれているためです。</target>
        </trans-unit>
        <trans-unit id="2a5a29c317c697ba64096b7f2c68033b4565ac42" translate="yes" xml:space="preserve">
          <source>The permutation is only valid until the next &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; that has the OPFLAG_PERMUTE bit set in P5. Typically the &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; should occur immediately prior to the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="translated">順列は、P5でOPFLAG_PERMUTEビットが設定されている次の&lt;a href=&quot;opcode#Compare&quot;&gt;比較&lt;/a&gt;までのみ有効です。通常、&lt;a href=&quot;opcode#Permutation&quot;&gt;置換&lt;/a&gt;は&lt;a href=&quot;opcode#Compare&quot;&gt;比較の&lt;/a&gt;直前に発生します。</target>
        </trans-unit>
        <trans-unit id="645402751e5b5ab0dd0504759786ac3f99e9f97b" translate="yes" xml:space="preserve">
          <source>The persistence of WAL mode means that applications can be converted to using SQLite in WAL mode without making any changes to the application itself. One has merely to run &quot;&lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt;&quot; on the database file(s) using the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; or other utility, then restart the application.</source>
          <target state="translated">WALモードの永続性は、アプリケーション自体に変更を加えることなく、アプリケーションをWALモードでSQLiteを使用して変換できることを意味します。&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;またはその他のユーティリティを使用してデータベースファイルで「 &lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt; 」を実行し、アプリケーションを再起動するだけです。</target>
        </trans-unit>
        <trans-unit id="37f0ea5f181b03035443f3a918ec838d5bf0f5c4" translate="yes" xml:space="preserve">
          <source>The phrase &quot;VALUES(</source>
          <target state="translated">VALUES(</target>
        </trans-unit>
        <trans-unit id="afda55d9895c016a5496f6b600205dbf8fbc7d06" translate="yes" xml:space="preserve">
          <source>The planner avoids query plans that use indexes with unknown collating functions.</source>
          <target state="translated">プランナは、未知の照合関数を持つインデックスを使用するクエリプランを回避します。</target>
        </trans-unit>
        <trans-unit id="926646f3fb08c1ad8acc73155c7f0bcd303e689e" translate="yes" xml:space="preserve">
          <source>The planner omits unused LEFT JOINs even if they are not the right-most joins of a query.</source>
          <target state="translated">プランナは、未使用のLEFT JOINがクエリの右端の結合でなくても、省略します。</target>
        </trans-unit>
        <trans-unit id="5852e8af03eff264841e6547e952b8e08ad085dc" translate="yes" xml:space="preserve">
          <source>The platform used for these tests is a 1.6GHz Athlon with 1GB or memory and an IDE disk drive. The operating system is RedHat Linux 7.2 with a stock kernel.</source>
          <target state="translated">これらのテストに使用したプラットフォームは、1.6GHzのAthlonで、1GB以上のメモリを搭載し、IDEディスクドライブを搭載しています。オペレーティングシステムはRedHat Linux 7.2で、純正カーネルを使用しています。</target>
        </trans-unit>
        <trans-unit id="e614d538ab4445c07af270ecdc6677ad39ccfb17" translate="yes" xml:space="preserve">
          <source>The point is this: an SQL database schema almost always does a far better job of defining and organizing the tables and data structures and their relationships. And having clear, concise, and well-defined representation almost always results in an application that performs better, has fewer problems, and is easier to develop and maintain.</source>
          <target state="translated">重要なのは、SQLデータベースのスキーマは、ほとんどの場合、テーブルとデータ構造、およびそれらの関係を定義し、整理するのにはるかに優れた仕事をしているということです。そして、明確で簡潔、かつ明確に定義された表現を持つことで、ほとんどの場合、アプリケーションのパフォーマンスが向上し、問題が少なく、開発と保守が容易になるという結果が得られます。</target>
        </trans-unit>
        <trans-unit id="1249a327a44d56131079defe491a7680b8885a62" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;へのポインター引数は、NULL、またはまだ解放されていない&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）の&lt;/a&gt;以前の呼び出しから取得したポインターでなければなりません。</target>
        </trans-unit>
        <trans-unit id="70d5983c94ca6fdbfd5d05e2d8f25d536fa0e2f9" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;および&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;へのポインター引数は、NULL、またはまだ解放されていない&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）の&lt;/a&gt;以前の呼び出しから取得したポインターでなければなりません。</target>
        </trans-unit>
        <trans-unit id="19e21383ec674e61332285628bf7a07277fe3452" translate="yes" xml:space="preserve">
          <source>The pointer type is not intended to be flexible and dynamic. The pointer type is intended to be a design-time constant. Applications should not synthesize pointer type strings at run-time. Providing support for dynamic pointer type strings would lead developers to misuse the pointer-passing interfaces by creating run-time synthesized pointer type strings. Requiring the pointer type strings to be static encourages developers to do the right thing by choosing fixed pointer type names at design-time and encoding those names as constant strings.</source>
          <target state="translated">ポインタ型は柔軟で動的なものを意図したものではありません。ポインタ型は設計時の定数として意図されている。アプリケーションは実行時にポインタ型文字列を合成してはならない。動的なポインタ型文字列のサポートを提供すると、開発者がランタイム合成されたポインタ型文字列を作成することでポインタ通過インタフェースを誤用することになる。ポインタ型文字列が静的であることを要求することは、設計時に固定ポインタ型名を選択し、それらの名前を定数文字列としてエンコードすることで正しいことをするよう開発者に促す。</target>
        </trans-unit>
        <trans-unit id="0a50e253ab7c267f33ad3d5a3deec486738946df" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">返されるポインタは、上記のように型変換が行われるまで、または&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;が呼び出されるまで有効です。文字列とBLOBを保持するために使用されるメモリ空間は、自動的に解放されます。返されたポインタ渡してはいけません&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blobを（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;の中になど、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3551cf33afa7b1894cdea20e6326c2bf8dcf19de" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">返されるポインタは、上記のように型変換が行われるまで、または&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;または&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;または&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;が呼び出されるまで有効です。文字列とBLOBを保持するために使用されるメモリ空間は、自動的に解放されます。返されたポインタ渡してはいけません&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blobを（） &lt;/a&gt;、&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;の中になど、&lt;a href=&quot;free&quot;&gt;sqlite3_free（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9edff31b2dc071eb66ab4aa44d22adfef6b1aa3c" translate="yes" xml:space="preserve">
          <source>The pointers that piggy-back on SQL NULL values using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; interface are transient and ephemeral. The pointers are never written into the database. The pointers will not survive sorting. The latter fact is why there is no sqlite3_column_pointer() interface, since it is impossible to predict whether or not the query planner will insert a sort operation prior to returning a value from a query, so it would be impossible to know if a pointer value inserted into a query by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; would survive through to the result set.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;、&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;インターフェースを使用してSQL NULL値に便乗するポインターは、一時的で一時的なものです。ポインターがデータベースに書き込まれることはありません。ポインタは並べ替え後も存続しません。後者の事実は、sqlite3_column_pointer（）インターフェースがない理由です。クエリから値を返す前にクエリプランナーがソート操作を挿入するかどうかを予測することは不可能であるため、ポインター値かどうかを知ることは不可能です。&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;または&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;によってクエリに挿入されると、結果セットまで存続します。</target>
        </trans-unit>
        <trans-unit id="41025b56b1d99416ab106417d2e02a42b25af90e" translate="yes" xml:space="preserve">
          <source>The porter tokenizer is a wrapper tokenizer. It takes the output of some other tokenizer and applies the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt; to each token before it returns it to FTS5. This allows search terms like &quot;correction&quot; to match similar words such as &quot;corrected&quot; or &quot;correcting&quot;. The porter stemmer algorithm is designed for use with English language terms only - using it with other languages may or may not improve search utility.</source>
          <target state="translated">ポータートークナイザーはラッパートークナイザーです。他のトークナイザーの出力を受け取り、&lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;ポーターステミングアルゴリズム&lt;/a&gt;を各トークンに適用してから、トークンをFTS5に返します。これにより、「correction」などの検索語句を「corrected」や「correcting」などの類似した単語と一致させることができます。ポーターステマーアルゴリズムは、英語の用語でのみ使用するように設計されています。他の言語で使用すると、検索ユーティリティが改善される場合と改善されない場合があります。</target>
        </trans-unit>
        <trans-unit id="8db274801095c26d088720201acb1bad2d40d917" translate="yes" xml:space="preserve">
          <source>The power of an SQLite database could, in theory, be achieved using a custom file format. But any custom file format that is as expressive as a relational database would likely require an enormous design specification and many tens or hundreds of thousands of lines of code to implement. And the end result would be an &quot;opaque blob&quot; that is inaccessible without specialized tools.</source>
          <target state="translated">SQLiteデータベースのパワーは、理論的には、カスタムファイルフォーマットを使用して実現することができます。しかし、リレーショナルデータベースのような表現力を持つカスタムファイルフォーマットは、膨大な設計仕様と、実装するための何万、何十万行ものコードを必要とする可能性があります。そして最終的には、専門的なツールがないとアクセスできない「不透明なブロブ」になってしまいます。</target>
        </trans-unit>
        <trans-unit id="4938c1fbe50ea261772ee32f2ec000b4cb6af37b" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property for individual databases can be specified as the database is opened using the &quot;psow&quot; query parameter with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For example, to always assume powersafe overwrite for a file (perhaps to ensure maximum write performance), open it as</source>
          <target state="translated">個々のデータベースのpowersafe overwriteプロパティは、&lt;a href=&quot;uri&quot;&gt;URI filenameを&lt;/a&gt;指定した「psow」クエリパラメータを使用してデータベースを開くときに指定できます。たとえば、ファイルのパワーセーフ上書きを常に想定するには（おそらく、最大の書き込みパフォーマンスを保証するため）、次のように開きます。</target>
        </trans-unit>
        <trans-unit id="67790abdb6b576eda27fab78ba503267f5a114fa" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property says nothing about the state of the bytes that were written. Those bytes might contain their old values, their new values, random values, or some combination of these. The powersafe overwrite property merely states that writes cannot change bytes outside of the range of bytes written.</source>
          <target state="translated">powersafe overwrite プロパティは、書き込まれたバイトの状態については何も言わない。これらのバイトには、古い値、新しい値、ランダムな値、またはこれらの組み合わせが含まれているかもしれません。powersafe overwrite プロパティは、書き込みが書き込まれたバイトの範囲外のバイトを変更できないことを示すだけです。</target>
        </trans-unit>
        <trans-unit id="1389e8d5f9998cc48b0c99ae215e31d8f358ccd0" translate="yes" xml:space="preserve">
          <source>The pragma command is specific to SQLite and is not compatible with any other SQL database engine.</source>
          <target state="translated">pragmaコマンドはSQLiteに特化したもので、他のSQLデータベースエンジンとは互換性がありません。</target>
        </trans-unit>
        <trans-unit id="5b9cdfdccce2f8d840c93537988a1d96c50df274" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run much faster than integrity_check. Otherwise the two pragmas are the same.</source>
          <target state="translated">プラグマは、UNIQUE制約を検証せず、インデックスの内容がテーブルの内容と一致することを検証しないことを除いて、&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_checkに&lt;/a&gt;似ています。UNIQUEおよびインデックスの整合性チェックをスキップすることにより、quick_checkは、integrity_checkよりもはるかに高速に実行できます。それ以外の場合、2つのプラグマは同じです。</target>
        </trans-unit>
        <trans-unit id="da60401a603e537afbb64f9be897b6e57271b0ee" translate="yes" xml:space="preserve">
          <source>The pre-update hook</source>
          <target state="translated">更新前のフック</target>
        </trans-unit>
        <trans-unit id="77a94c0ef3120048af1c78a5031b2bc8f51341cf" translate="yes" xml:space="preserve">
          <source>The pre-update hook.</source>
          <target state="translated">アップデート前のフック。</target>
        </trans-unit>
        <trans-unit id="464d49040a7350ab38dd3a440629e97d8425be1c" translate="yes" xml:space="preserve">
          <source>The precautions above are not required in order to use SQLite safely with potentially hostile inputs. However, they do provide an extra layer of defense against zero-day exploits and are encouraged for applications that pass data from untrusted sources into SQLite.</source>
          <target state="translated">上記の注意事項は、潜在的に敵対的な入力に対して安全に SQLite を使用するために必要なものではありません。しかし、ゼロデイエクスプロイトに対する防御のための余分な層を提供し、信頼されていないソースからSQLiteにデータを渡すアプリケーションには推奨されています。</target>
        </trans-unit>
        <trans-unit id="05bf811875969018cb62c264a6781abc17b442f0" translate="yes" xml:space="preserve">
          <source>The precedence order for ON CONFLICT clauses was changed so that ON CONFLICT clauses on BEGIN statements have a higher precedence than ON CONFLICT clauses on constraints.</source>
          <target state="translated">ON CONFLICT句の優先順位が変更され、BEGIN文のON CONFLICT句の方が制約のON CONFLICT句よりも優先されるようになりました。</target>
        </trans-unit>
        <trans-unit id="122c8023ebc9769b59f3a1882e33d76b3169c9fd" translate="yes" xml:space="preserve">
          <source>The preceding paragraphs contain a lot of information. To ease the task of constructing a new VFS for SQLite we offer the following implementation checklist:</source>
          <target state="translated">前の段落には多くの情報が含まれています。SQLite 用の新しい VFS を構築する作業を容易にするために、以下の実装チェックリストを提供します。</target>
        </trans-unit>
        <trans-unit id="661723ea54e783ccd80036c290bfdccff5b43478" translate="yes" xml:space="preserve">
          <source>The precision field, if it is present, must follow the width separated by a single &quot;.&quot; character. If there is no width, then the &quot;.&quot; that introduces the precision immediately follows either the flags (if there are any) or the initial &quot;%&quot;.</source>
          <target state="translated">精度フィールドが存在する場合は、1つの「.」文字で区切られた幅の後に続けなければならない。幅がない場合、精度を導入する&quot;.&quot;は、フラグ(あれば)か最初の&quot;%&quot;のいずれかの直後に続きます。</target>
        </trans-unit>
        <trans-unit id="274c336721e63c209854a5c06e41f1f163132ddd" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">使用する推奨ルーチンは&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;です。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;インターフェースは、レガシーあり、避けるべきです。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）に&lt;/a&gt;は、特別な目的で使用される追加の「prepFlags」オプションがあります。</target>
        </trans-unit>
        <trans-unit id="2a1d33401c2095551ef53ebdb2c936c2ab4e7f75" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">使用する推奨ルーチンは&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;です。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;インターフェースは、レガシーあり、避けるべきです。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）に&lt;/a&gt;は、特別な目的で使用される追加の「prepFlags」オプションがあります。</target>
        </trans-unit>
        <trans-unit id="e5802699120466acd022e1fa07d198c436289856" translate="yes" xml:space="preserve">
          <source>The prefix on temporary filenames on Windows is changed from &quot;sqlite&quot; to &quot;etilqs&quot;.</source>
          <target state="translated">Windowsのテンポラリファイル名のプレフィックスを &quot;sqlite &quot;から &quot;etilqs &quot;に変更した。</target>
        </trans-unit>
        <trans-unit id="f3230410aa1ec23cdd51b1c85ef3e6e8a5bf6364" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">ビジーハンドラーの存在は、ロックの競合があるときに呼び出されることを保証するものではありません。 SQLiteは、ビジーハンドラーを呼び出すとデッドロックが発生する可能性があると判断した場合、ビジーハンドラーを呼び出す代わりに&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;をアプリケーションに返します。 1つのプロセスが予約ロックに昇格しようとしている読み取りロックを保持しており、2番目のプロセスが排他ロックに昇格しようとしている予約ロックを保持しているシナリオを考えてみます。最初のプロセスは2番目のプロセスによってブロックされているため続行できません。2番目のプロセスは最初のプロセスによってブロックされているため続行できません。両方のプロセスがビジーハンドラーを呼び出す場合、どちらも進行しません。したがって、SQLiteは&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSYを&lt;/a&gt;返します最初のプロセスでは、これにより最初のプロセスが読み取りロックを解放し、2番目のプロセスを続行できるようになることを期待しています。</target>
        </trans-unit>
        <trans-unit id="f52f9d0c779543db7a531d457708b0c4e1e3b230" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">ビジーハンドラーの存在は、ロックの競合があるときに呼び出されることを保証するものではありません。 SQLiteは、ビジーハンドラーを呼び出すとデッドロックが発生する可能性があると判断した場合、ビジーハンドラーを呼び出す代わりに&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;をアプリケーションに返します。 1つのプロセスが予約ロックに昇格しようとしている読み取りロックを保持しており、2番目のプロセスが排他ロックに昇格しようとしている予約ロックを保持しているシナリオを考えてみます。最初のプロセスは2番目のプロセスによってブロックされているため続行できません。2番目のプロセスは最初のプロセスによってブロックされているため続行できません。両方のプロセスがビジーハンドラーを呼び出す場合、どちらも進行しません。したがって、SQLiteは&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSYを&lt;/a&gt;返します最初のプロセスでは、これにより最初のプロセスが読み取りロックを解放し、2番目のプロセスを続行できるようになることを期待しています。</target>
        </trans-unit>
        <trans-unit id="b2efda84ef1340b69a62f5b61118269d4141c529" translate="yes" xml:space="preserve">
          <source>The presence of a hot journal is our indication that a previous process was trying to commit a transaction but it aborted for some reason prior to the completion of the commit. A hot journal means that the database file is in an inconsistent state and needs to be repaired (by rollback) prior to being used.</source>
          <target state="translated">ホットジャーナルの存在は、前のプロセスがトランザクションをコミットしようとしていたが、コミットが完了する前に何らかの理由で中断したことを示しています。ホットジャーナルは、データベースファイルが矛盾した状態にあり、使用する前に(ロールバックによって)修復する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="53e2bd6dac9cbbc9b06c74e123d964800e4d3352" translate="yes" xml:space="preserve">
          <source>The presence of the &quot;noskipscan&quot; token on the sqlite_stat1.stat field of an index prevents that index from being used with the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">インデックスのsqlite_stat1.statフィールドに &quot;noskipscan&quot;トークンが存在すると、そのインデックスが&lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan最適化&lt;/a&gt;で使用されなくなります。</target>
        </trans-unit>
        <trans-unit id="a01f573624c54e96d01f0d23d0ba8b3593807a0a" translate="yes" xml:space="preserve">
          <source>The presentation of the query planner problem above is a simplification. The costs are estimates. We cannot know what the true cost of running a loop is until we actually run the loop. SQLite makes guesses for the cost of running a loop based on the availability of indexes and constraints found in the WHERE clause. These guesses are usually pretty good, but they can sometimes be off. Using the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect additional statistical information about the database can sometimes enable SQLite to make better guesses about the cost.</source>
          <target state="translated">上記のクエリプランナー問題の提示は単純化です。費用は概算です。実際にループを実行するまでは、ループを実行することの本当のコストを知ることはできません。SQLiteは、WHERE句で見つかったインデックスと制約の可用性に基づいて、ループの実行コストを推測します。これらの推測は通常かなり良いですが、時々オフになることがあります。&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドを使用してデータベースに関する追加の統計情報を収集すると、SQLiteがコストをより正確に推測できる場合があります。</target>
        </trans-unit>
        <trans-unit id="1c32ea8c1623df88595d5e28c3a4322ef70e185f" translate="yes" xml:space="preserve">
          <source>The preupdate hook interfaces were originally added to support the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension.</source>
          <target state="translated">preupdateフックインターフェイスは、&lt;a href=&quot;sessionintro&quot;&gt;セッション&lt;/a&gt;拡張をサポートするために最初に追加されました。</target>
        </trans-unit>
        <trans-unit id="54aaab8c82da084a0f8a9658f2bc76535e494e38" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">preupdateフックは、実際のデータベーステーブルへの変更に対してのみ起動します。&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;またはsqlite_masterやsqlite_stat1などのシステムテーブルへの変更に対しては、preupdateフックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="f619ca19c48dc2cd5df5d0de6abefa9c15ce6509" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">preupdateフックは、実際のデータベーステーブルへの変更に対してのみ起動します。&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;またはsqlite_masterやsqlite_stat1などのシステムテーブルへの変更に対しては、preupdateフックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="548d335209dbce4d25a40d42ac27b0b5a00affc4" translate="yes" xml:space="preserve">
          <source>The previous discussion has treated searching and sorting as separate topics. But in practice, it is often the case that one wants to search and sort at the same time. Fortunately, it is possible to do this using a single index.</source>
          <target state="translated">これまでの議論では、検索とソートを別の話題として扱ってきました。しかし、実際には、検索とソートを同時に行いたい場合がよくあります。幸いなことに、単一のインデックスを使ってこれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="5a894252915223aa28176cd8caebb845eabbbe5b" translate="yes" xml:space="preserve">
          <source>The previous example is a specific case of a more general problem: The state of an SQLite database is controlled by both the database file and the journal file. In a quiescent state, the journal file does not exist and only the database file matters. But if the journal file does exist, it must be kept together with the database to avoid corruption. The following actions are all likely to lead to corruption:</source>
          <target state="translated">SQLiteデータベースの状態は、データベースファイルとジャーナルファイルの両方によって制御されています。静止状態では、ジャーナルファイルは存在せず、データベースファイルだけが問題となります。しかし、ジャーナルファイルが存在する場合は、破損を避けるためにデータベースと一緒に保管しなければなりません。以下のアクションはすべて破損につながる可能性が高い。</target>
        </trans-unit>
        <trans-unit id="96495b049cd011fd87b80d69ae6b3a8f79a60e9a" translate="yes" xml:space="preserve">
          <source>The previous example will return every row for which the _shape overlaps the polygon in the $query_polygon parameter. The geopoly_within() function works similarly, but only returns rows for which the _shape is completely contained within $query_polygon.</source>
          <target state="translated">前の例では、_shapeが$query_polygonパラメータのポリゴンと重なっているすべての行を返します。geopoly_within()関数も同様に動作しますが、_shapeが完全に$query_polygon内に含まれている行のみを返します。</target>
        </trans-unit>
        <trans-unit id="493e14ba39e9f9ab43ab64d3b6be4b87292ba69a" translate="yes" xml:space="preserve">
          <source>The previous example, SQLite uses index &quot;i1&quot; to optimize a WHERE clause term of the form (a=?) - in this case &quot;a=1&quot;. The previous example could not use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt;, but the following example can, and that fact is reflected in the output:</source>
          <target state="translated">前の例では、SQLiteはインデックス &quot;i1&quot;を使用して、フォーム（a =？）のWHERE句の用語を最適化します。前の例では&lt;a href=&quot;queryplanner#covidx&quot;&gt;カバリングインデックスを&lt;/a&gt;使用できませんでしたが、次の例では使用でき、その事実は出力に反映されています。</target>
        </trans-unit>
        <trans-unit id="69c7b95e4071269d47577736bbe07ea0a083b117" translate="yes" xml:space="preserve">
          <source>The previous fix was not quite right. This one seems to work better.</source>
          <target state="translated">以前の修正ではうまくいきませんでした。こちらの方がうまくいくようです。</target>
        </trans-unit>
        <trans-unit id="fdab229cc2f18edd4b33bcf4f2dc07383013038b" translate="yes" xml:space="preserve">
          <source>The previous paragraph describes what happens when the synchronous pragma setting is &quot;full&quot;.</source>
          <target state="translated">前の段落では、同期プラグマの設定が「フル」の場合に何が起こるかを説明しています。</target>
        </trans-unit>
        <trans-unit id="af577bd70a120b3a01a3ee4e9c639a65b514f294" translate="yes" xml:space="preserve">
          <source>The previous paragraph is also true (separate database connections are isolated from one another) in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; as long as the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; remains turned off. The &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is off by default and so if the application does nothing to turn it on, it will remain off. Hence, unless the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is used to change the default behavior, changes made by one database connection are invisible to readers on a different database connection sharing the same cache until the writer commits its transaction.</source>
          <target state="translated">前の段落は、&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommittedプラグマ&lt;/a&gt;がオフのままである限り、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;でも当てはまります（個別のデータベース接続は互いに分離されています）。&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;READ_UNCOMMITTEDプラグマは&lt;/a&gt;、デフォルトではオフになっていると、アプリケーションがそれをオンにする何もしないのであれば、それはオフのままになります。したがって、&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommittedプラグマ&lt;/a&gt;を使用してデフォルトの動作を変更しない限り、あるデータベース接続によって行われた変更は、ライターがトランザクションをコミットするまで、同じキャッシュを共有する別のデータベース接続上のリーダーには見えません。</target>
        </trans-unit>
        <trans-unit id="4443bdbe2499eab3d6d488e897e8d552fc707661" translate="yes" xml:space="preserve">
          <source>The previous paragraph states that SQLite does not assume that sector writes are atomic. This is true by default. But as of SQLite version 3.5.0, there is a new interface called the Virtual File System (&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;) interface. The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is the only means by which SQLite communicates to the underlying filesystem. The code comes with default VFS implementations for Unix and Windows and there is a mechanism for creating new custom VFS implementations at runtime. In this new VFS interface there is a method called xDeviceCharacteristics. This method interrogates the underlying filesystem to discover various properties and behaviors that the filesystem may or may not exhibit. The xDeviceCharacteristics method might indicate that sector writes are atomic, and if it does so indicate, SQLite will try to take advantage of that fact. But the default xDeviceCharacteristics method for both Unix and Windows does not indicate atomic sector writes and so these optimizations are normally omitted.</source>
          <target state="translated">前の段落では、SQLiteはセクター書き込みがアトミックであるとは想定していないと述べています。これはデフォルトで当てはまります。ただし、SQLiteバージョン3.5.0以降、仮想ファイルシステム（&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;）インターフェースと呼ばれる新しいインターフェースがあります。&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;SQLiteが基礎となるファイルシステムと通信する唯一の手段です。コードには、UnixおよびWindowsのデフォルトのVFS実装が付属しており、実行時に新しいカスタムVFS実装を作成するためのメカニズムがあります。この新しいVFSインターフェイスには、xDeviceCharacteristicsと呼ばれるメソッドがあります。このメソッドは、基礎となるファイルシステムに問い合わせて、ファイルシステムが示す場合と示さない場合があるさまざまなプロパティと動作を検出します。 xDeviceCharacteristicsメソッドは、セクターの書き込みがアトミックであることを示す場合があり、その場合、SQLiteはその事実を利用しようとします。ただし、UnixとWindowsの両方のデフォルトのxDeviceCharacteristicsメソッドは、アトミックセクターの書き込みを示さないため、これらの最適化は通常省略されます。</target>
        </trans-unit>
        <trans-unit id="342bf4dfcd7ddbf3e5538a244e6458410341ab97" translate="yes" xml:space="preserve">
          <source>The previous paragraphs describe the behavior of temporary databases under the default SQLite configuration. An application can use the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; and the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter to force temporary databases to behave as pure in-memory databases, if desired.</source>
          <target state="translated">前の段落では、デフォルトのSQLite構成での一時データベースの動作について説明しました。アプリケーションは、&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_storeプラグマ&lt;/a&gt;と&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーターを使用して、必要に応じて一時データベースを強制的に純粋なメモリ内データベースとして動作させることができます。</target>
        </trans-unit>
        <trans-unit id="6e1f293bab97b2b5f7895a766acf571a1f59dca9" translate="yes" xml:space="preserve">
          <source>The previous query is equivalent to the following:</source>
          <target state="translated">前のクエリは次のように等価です。</target>
        </trans-unit>
        <trans-unit id="2a8f5ff04cf0666d4b31c9cd45d0419954ccab05" translate="yes" xml:space="preserve">
          <source>The previous step created circle (1) in the diagram above. This step will create circle (2). Run the following command:</source>
          <target state="translated">前のステップでは、上図の円(1)を作成しました。このステップでは、円(2)を作成します。以下のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="73d4cf9a53d1a814d3d61247ac59a2dcf02d4a89" translate="yes" xml:space="preserve">
          <source>The primary page cache implementation is in the &lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt; file. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; logic is in the separate &lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c&lt;/a&gt;. In-memory caching is implemented by the &lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt; files. The interface between page cache subsystem and the rest of SQLite is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h&lt;/a&gt;.</source>
          <target state="translated">プライマリページキャッシュの実装は、&lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt;ファイルにあります。&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt;ロジックは別の&lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.cにあり&lt;/a&gt;ます。インメモリキャッシングは、&lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt;および&lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt;ファイルによって実装されます。ページキャッシュサブシステムと残りのSQLiteの間のインターフェイスは、ヘッダーファイル&lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h&lt;/a&gt;によって定義されます。</target>
        </trans-unit>
        <trans-unit id="01bd1fccd0eb574f8649d147f7495318ef2ed3aa" translate="yes" xml:space="preserve">
          <source>The primary use of Lemon is to create the SQL language parser. A grammar file (&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;) is compiled by Lemon into parse.c and parse.h. The parse.c file is incorporated into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; without further modification.</source>
          <target state="translated">レモンの主な用途は、SQL言語パーサーを作成することです。文法ファイル（&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;）は、レモンによってparse.cとparse.hにコンパイルされます。parse.cファイルは、さらに変更することなく、&lt;a href=&quot;amalgamation&quot;&gt;統合に&lt;/a&gt;組み込まれます。</target>
        </trans-unit>
        <trans-unit id="c694d6e20cc8030ef2cf2b05c8cbbbe628062074" translate="yes" xml:space="preserve">
          <source>The principal task of an SQL database engine is to evaluate SQL statements of SQL. To accomplish this, the developer needs two objects:</source>
          <target state="translated">SQLデータベースエンジンの主なタスクは、SQLのSQL文を評価することです。これを達成するために、開発者は2つのオブジェクトを必要とします。</target>
        </trans-unit>
        <trans-unit id="cfcb012162b1a505da1f19d8786ad1f42bcacc75" translate="yes" xml:space="preserve">
          <source>The principle difference between FTS3/4 and FTS5 is that in FTS3/4, each instance-list is stored as a single large database record, whereas in FTS5 large instance-lists are divided between multiple database records. This has the following implications for dealing with large databases that contain large lists:</source>
          <target state="translated">FTS3/4とFTS5の原理的な違いは、FTS3/4では各インスタンスリストが1つの大規模データベースレコードとして格納されるのに対し、FTS5では大規模インスタンスリストが複数のデータベースレコードの間で分割されて格納されることです。このことは、大規模なリストを含む大規模なデータベースを扱う上で、次のような意味合いを持ちます。</target>
        </trans-unit>
        <trans-unit id="d7231b054e5abc6f0cfc5cc85f7e3279373f74d4" translate="yes" xml:space="preserve">
          <source>The printf() in SQLite supports new non-standard substitution types (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;) that are useful both internally to SQLite and to applications using SQLite. Standard library printf()s cannot normally be extended in this way.</source>
          <target state="translated">SQLiteのprintf（）は、SQLite とSQLiteを使用するアプリケーションの両方で内部的に役立つ新しい非標準の置換タイプ（&lt;a href=&quot;printf#percentq&quot;&gt;％q&lt;/a&gt;、&lt;a href=&quot;printf#percentq&quot;&gt;％Q&lt;/a&gt;、&lt;a href=&quot;printf#percentw&quot;&gt;％w&lt;/a&gt;、および&lt;a href=&quot;printf#percentz&quot;&gt;％z&lt;/a&gt;）をサポートします。標準ライブラリのprintf（）は通常、この方法で拡張できません。</target>
        </trans-unit>
        <trans-unit id="0592c94ffabf868a1145cae373098959875b4ffd" translate="yes" xml:space="preserve">
          <source>The printf(FORMAT,...) SQL function works like the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; C-language function and the printf() function from the standard C library. The first argument is a format string that specifies how to construct the output string using values taken from subsequent arguments. If the FORMAT argument is missing or NULL then the result is NULL. The %n format is silently ignored and does not consume an argument. The %p format is an alias for %X. The %z format is interchangeable with %s. If there are too few arguments in the argument list, missing arguments are assumed to have a NULL value, which is translated into 0 or 0.0 for numeric formats or an empty string for %s. See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">printf（FORMAT、...）SQL関数は、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt; C言語関数および標準Cライブラリのprintf（）関数と同様に機能します。最初の引数は、後続の引数から取得した値を使用して出力文字列を作成する方法を指定するフォーマット文字列です。 FORMAT引数がないかNULLの場合、結果はNULLになります。 ％n形式は通知なく無視され、引数を消費しません。 ％p形式は％Xのエイリアスです。 ％z形式は％sと交換可能です。引数リストの引数が少なすぎる場合、欠落している引数はNULL値であると見なされ、数値形式の場合は0または0.0に変換され、％sの場合は空の文字列に変換されます。追加情報については、&lt;a href=&quot;printf&quot;&gt;組み込みのprintf（）&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f7aa000e854fa1e51d2a8e3276f08d834816bb0a" translate="yes" xml:space="preserve">
          <source>The private memory cell is initialized to NULL by the first two instructions. Instructions 2 through 13 implement the inner SELECT statement against the examp2 table. Notice that instead of sending the result to a callback or storing the result on a sorter, the result of the query is pushed into the memory cell by instruction 10 and the loop is abandoned by the jump at instruction 11. The jump at instruction at 11 is vestigial and never executes.</source>
          <target state="translated">プライベート・メモリ・セルは、最初の2つの命令でNULLに初期化されます。命令2から13はexamp2テーブルに対する内部SELECT文を実装します。結果をコールバックに送信したり、結果をソータに格納したりする代わりに、問い合わせの結果は命令10によってメモリセルにプッシュされ、命令11でのジャンプによってループが放棄されることに注意してください。命令11でのジャンプは実行されることはありません。</target>
        </trans-unit>
        <trans-unit id="576c1ad7241fb816002c325b35c536b5acba643f" translate="yes" xml:space="preserve">
          <source>The problem is that the indexes are not of equal quality. A check-in is likely to only have one child. So the first field of PLINK_I1 will usually narrow down the search to just a single row. But there are thousands and thousands check-ins tagged with &quot;trunk&quot;, so the first field of TAGXREF_I1 will be of little help in narrowing down the search.</source>
          <target state="translated">問題は、インデックスの質が同じではないことです。チェックインは1つの子だけの可能性が高い。そのため、PLINK_I1の最初のフィールドは、通常は1行だけに絞り込んで検索します。しかし、&quot;trunk &quot;でタグ付けされたチェックインは何千、何千もあるので、tagxref_i1の最初のフィールドは、検索を絞り込む上でほとんど役に立たないでしょう。</target>
        </trans-unit>
        <trans-unit id="4910b74e848d7f84054aa8b42c2da7951eb8cf1a" translate="yes" xml:space="preserve">
          <source>The problem of dynamic memory allocation, and specifically the problem of a memory allocator breakdown, has been studied by J. M. Robson and the results published as:</source>
          <target state="translated">動的メモリ割り当ての問題、具体的にはメモリアロケータの故障の問題は、J.M.Robsonによって研究され、その結果が公開されています。</target>
        </trans-unit>
        <trans-unit id="c0e48a1c7e6fc766c0233c83a22616959f0ed84b" translate="yes" xml:space="preserve">
          <source>The problem of finding the best query plan is equivalent to finding a minimum-cost path through the graph that visits each node exactly once.</source>
          <target state="translated">最良の問い合わせプランを見つける問題は、グラフを通る最小コストのパスを見つけることと同等であり、各ノードを正確に一度だけ訪れることができます。</target>
        </trans-unit>
        <trans-unit id="0f52798620170b176ff3d3af06fd50b65930b59c" translate="yes" xml:space="preserve">
          <source>The problem was fixed on 2011-02-20. The fix first appears in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12).</source>
          <target state="translated">この問題は2011-02-20に修正されました。この修正は、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;バージョン3.7.6&lt;/a&gt;（2011-04-12）で最初に表示されます。</target>
        </trans-unit>
        <trans-unit id="0a9231ded77785fbf75b111ccef695ba60c384a1" translate="yes" xml:space="preserve">
          <source>The problem with looking up information by rowid is that you probably do not care what the price of &quot;item 4&quot; is - you want to know the price of peaches. And so a rowid lookup is not helpful.</source>
          <target state="translated">rowidで情報を調べる場合の問題点は、おそらく「アイテム4」の価格は気にしないということでしょう-あなたは桃の価格を知りたいのです。そのため、rowidによる検索は役に立ちません。</target>
        </trans-unit>
        <trans-unit id="5ca928318271d59121bcae8c1e00c91157b277dc" translate="yes" xml:space="preserve">
          <source>The problem with this latter query is that it must apply the contained_in() function to millions of entries in the demo_data table. The use of the R*Tree in the penultimate query reduces the number of calls to contained_in() function to a small subset of the entire table. The R*Tree index did not find the exact answer itself, it merely limited the search space.</source>
          <target state="translated">後者のクエリの問題点は,demo_dataテーブル内の何百万ものエントリに対して contained_in()関数を適用しなければならないことです.最後のクエリでR*Treeを使用することで、 contained_in()関数の呼び出し回数をテーブル全体の小さなサブセットに減らすことができます。R*Treeインデックスは、正確な答えそのものを見つけるのではなく、単に検索スペースを制限しただけです。</target>
        </trans-unit>
        <trans-unit id="4d80ba47d569d0e4a2a3e8f3108543e7f76afec3" translate="yes" xml:space="preserve">
          <source>The procedure used to detect a</source>
          <target state="translated">を検出するために使用される手順は</target>
        </trans-unit>
        <trans-unit id="7c5ac2fd9c78337a35d0c9980fe79b8e26f93a08" translate="yes" xml:space="preserve">
          <source>The process is explained at &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;.</source>
          <target state="translated">プロセスは&lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;で説明されています。</target>
        </trans-unit>
        <trans-unit id="6eeaa105f7c556f91bf9c6156b767ca4d840a8c0" translate="yes" xml:space="preserve">
          <source>The progress callback can be used to display the status of a lengthy query or to process GUI events during a lengthy query.</source>
          <target state="translated">プログレスコールバックは、長いクエリのステータスを表示したり、長いクエリ中にGUIイベントを処理したりするために使用できます。</target>
        </trans-unit>
        <trans-unit id="c69ceeecbdd66434afc39e336822e8ab81198858" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">進捗ハンドラーコールバックは、進捗ハンドラーを呼び出したデータベース接続を変更するようなことをしてはなりません。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）は&lt;/a&gt;どちらも、この段落の「変更」の意味でデータベース接続を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="cfdeee9bdc15af91672d8ad9f38656051ea8a13d" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">進捗ハンドラーコールバックは、進捗ハンドラーを呼び出したデータベース接続を変更するようなことをしてはなりません。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;step&quot;&gt;sqlite3_step（）は&lt;/a&gt;どちらも、この段落の「変更」の意味でデータベース接続を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="d0b8dc8c8f3e20ba03797e52e7e128023b09d0a3" translate="yes" xml:space="preserve">
          <source>The properties of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; and &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; commands described above only apply if foreign keys are enabled. If the user considers them undesirable, then the workaround is to use &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; to disable foreign key constraints before executing the DROP or ALTER TABLE command. Of course, while foreign key constraints are disabled, there is nothing to stop the user from violating foreign key constraints and thus creating an internally inconsistent database.</source>
          <target state="translated">上記の&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;コマンドと&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;コマンドのプロパティは、外部キーが有効な場合にのみ適用されます。ユーザーがそれらを望ましくないと考えた場合の回避策は、&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;DRAG&lt;/a&gt;またはALTER TABLEコマンドを実行する前に、PRAGMA foreign_keysを使用して外部キー制約を無効にすることです。もちろん、外部キー制約は無効になっていますが、ユーザーが外部キー制約に違反して内部的に一貫性のないデータベースを作成するのを阻止するものは何もありません。</target>
        </trans-unit>
        <trans-unit id="12341c72ae5851f82e7e9d06ed859f6acb79d027" translate="yes" xml:space="preserve">
          <source>The prover that determines whether any column of the right-hand table of a LEFT JOIN must be non-NULL in the WHERE clause is imperfect. It sometimes returns a false negative. In other words, it sometimes fails to reduce the strength of a LEFT JOIN when doing so was in fact possible. For example, the prover does not know the &lt;a href=&quot;lang_datefunc&quot;&gt;datetime() SQL function&lt;/a&gt; will always return NULL if its first argument is NULL, and so it will not recognize that the LEFT JOIN in the following query could be strength-reduced:</source>
          <target state="translated">WHERE句でLEFT JOINの右側のテーブルの列をNULL以外にする必要があるかどうかを決定する証明者は不完全です。それは時々偽陰性を返します。つまり、実際には可能であったとしても、LEFT JOINの強度を下げることができない場合があります。たとえば、証明者は、最初の引数がNULLの場合、&lt;a href=&quot;lang_datefunc&quot;&gt;datetime（）SQL関数&lt;/a&gt;が常にNULLを返すことを認識していないため、次のクエリのLEFT JOINが強度削減される可能性があることを認識しません。</target>
        </trans-unit>
        <trans-unit id="48a058bacf71fa48c37c493961b3f8857c5bcde0" translate="yes" xml:space="preserve">
          <source>The psow query parameter overrides the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property of the database file being opened. The psow query parameter works with the default windows and unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; but might be a no-op for other proprietary or non-standard VFSes.</source>
          <target state="translated">psowクエリパラメータは、開かれているデータベースファイルの&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;プロパティを上書きします。psowクエリパラメータは、デフォルトのウィンドウとUNIX &lt;a href=&quot;vfs&quot;&gt;VFSで&lt;/a&gt;機能しますが、他の独自仕様または非標準のVFSでは何もしない場合があります。</target>
        </trans-unit>
        <trans-unit id="ffe108cd06e0c16c268bec90ba5007639fcc32ef" translate="yes" xml:space="preserve">
          <source>The pthreads interface provides the pthread_cond_wait() function. This function allows the caller to simultaneously release a mutex and start waiting for an asynchronous signal. Using this function, a &quot;fired&quot; flag and a mutex, the race-condition described above may be eliminated as follows:</source>
          <target state="translated">pthreads インターフェースは pthread_cond_wait()関数を提供します。この関数を使用すると、呼び出し元はミューテックスを解放すると同時に非同期信号の待ちを開始することができます。この関数、&quot;fired &quot;フラグ、ミューテックスを使用すると、以下のように上述の競合状態を解消することができます。</target>
        </trans-unit>
        <trans-unit id="5730c4be2fce644af4a3a0b4f7bf8a21afa9d144" translate="yes" xml:space="preserve">
          <source>The pthreads library is needed to make SQLite threadsafe. But since the CLI is single threaded, we could instruct SQLite to build in a non-threadsafe mode and thereby omit the pthreads library:</source>
          <target state="translated">pthreads ライブラリは、SQLite をスレッドセーフにするために必要です。しかし、CLIはシングルスレッドなので、SQLiteにスレッドセーフではないモードでビルドするように指示し、それによってpthreadsライブラリを省略することができます。</target>
        </trans-unit>
        <trans-unit id="ead084e5ac51c3a25e7e77f7295b3ad410aff0a2" translate="yes" xml:space="preserve">
          <source>The purpose of the master journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the master journal is omitted, as an optimization.</source>
          <target state="translated">マスタージャーナルの目的は、停電時にマルチファイルトランザクションがアトミックであることを保証することです。ただし、データベースファイルに停電時の整合性を損なうその他の設定（&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期= OFF&lt;/a&gt;または&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORYなど&lt;/a&gt;）がある場合、最適化のためにマスタージャーナルの作成は省略されます。</target>
        </trans-unit>
        <trans-unit id="80a4c796df15be02f28a9491edc718e0a6ad327d" translate="yes" xml:space="preserve">
          <source>The purpose of the other files and folders is presently unknown to the author but is probably not difficult to figure out.</source>
          <target state="translated">その他のファイルやフォルダの目的は、現在のところ作者には不明ですが、おそらく把握するのは難しいことではないでしょう。</target>
        </trans-unit>
        <trans-unit id="6ad934bb2af516663297a114c16808bb7efaf019" translate="yes" xml:space="preserve">
          <source>The purpose of the wal-index is to answer this question quickly:</source>
          <target state="translated">ウォルインデックスの目的は、この質問に素早く答えることです。</target>
        </trans-unit>
        <trans-unit id="138e57468a79af5c77be9bf617137e42c028e084" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to argue in favor of a fourth new category of application file format: An SQLite database file.</source>
          <target state="translated">この文書の目的は、4つ目の新しいカテゴリのアプリケーションファイル形式を支持することを主張することである。SQLite データベースファイルです。</target>
        </trans-unit>
        <trans-unit id="a73682c963786c3512a8e2606835fb2fa3f30921" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to brief the reader on how SQLite development team functions on a daily basis, as they continuously enhance the SQLite software and work to improve its already high reliability. The document achieves its purpose if a competent developer can be assimilated into the development team quickly after perusing this document.</source>
          <target state="translated">この文書の目的は、SQLite開発チームがSQLiteソフトウェアを継続的に改良し、すでに高い信頼性を実現しているSQLite開発チームが日常的にどのように機能しているのかを読者に説明することにあります。この文書を熟読した後、有能な開発者が開発チームに速やかに溶け込むことができれば、この文書はその目的を達成することができます。</target>
        </trans-unit>
        <trans-unit id="634e9e567d1f1f2dd99eda8c5536d500fa1e6e07" translate="yes" xml:space="preserve">
          <source>The push-down optimization cannot always be used. For example, if the subquery contains a LIMIT, then pushing down any part of the WHERE clause from the outer query could change the result of the inner query. There are other restrictions, explained in a comment in the source code on the pushDownWhereTerms() routine that implements this optimization.</source>
          <target state="translated">プッシュダウン最適化は常に使用できるわけではありません。例えば、副問い合わせに LIMIT が含まれている場合、外側の問い合わせから WHERE 句の任意の部分をプッシュダウンすると、内側の問い合わせの結果が変更される可能性があります。他にも制限事項がありますが、この最適化を実装する pushDownWhereTerms()ルーチンのソース・コードのコメントで説明されています。</target>
        </trans-unit>
        <trans-unit id="95403298754cba937ffb2896cd7e77d09dc82fdd" translate="yes" xml:space="preserve">
          <source>The quality management plan was originally composed by going through the description of outputs in section 11 of DO-178B (pages 48 through 56) and writing down those elements that seemed relevant to SQLite. The text will be subsequent revised to track enhancements to the SQLite quality process.</source>
          <target state="translated">品質管理計画は当初、DO-178Bの第11節(48~56ページ)のアウトプットの記述に目を通し、SQLiteに関連すると思われる要素を書き留めることで構成されていました。このテキストは、SQLite品質プロセスの強化を追跡するために、その後改訂されます。</target>
        </trans-unit>
        <trans-unit id="06064891cfb2016593d8db9b131661701e81d4c1" translate="yes" xml:space="preserve">
          <source>The query above could be made to run faster by using the FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt; function to determine the number of query term instances that appear in each result. The matchinfo function is much more efficient than the offsets function. Furthermore, the matchinfo function provides extra information regarding the overall number of occurrences of each query term in the entire document set (not just the current row) and the number of documents in which each query term appears. This may be used (for example) to attach a higher weight to less common terms which may increase the overall computed relevancy of those results the user considers more interesting.</source>
          <target state="translated">上記のクエリは、FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt;関数を使用して各結果に表示されるクエリ用語インスタンスの数を決定することにより、より高速に実行することができます。 matchinfo関数は、offsets関数よりもはるかに効率的です。さらに、matchinfo関数は、ドキュメントセット全体（現在の行だけでなく）での各クエリ用語の出現回数と、各クエリ用語が出現するドキュメントの数に関する追加情報を提供します。これは、たとえば、あまり一般的でない用語に高い重みを付けるために使用され、ユーザーがより興味深いと考える結果の全体的な計算された関連性を高める可能性があります。</target>
        </trans-unit>
        <trans-unit id="418f38a31900c8102303fe91cea3cb03a0bfc91a" translate="yes" xml:space="preserve">
          <source>The query above could be rewritten as a join and without the use of row values:</source>
          <target state="translated">上記のクエリは、行の値を使わずに結合として書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="8505932c272eacf13a6ac016c3034294904230a0" translate="yes" xml:space="preserve">
          <source>The query above will return suggestions for the whole input word that begins with $prefix. The $wholeline parameter is all text from the beginning of the line up to the insertion point. The $wholeline parameter is used for context.</source>
          <target state="translated">上のクエリは、$prefixで始まる入力単語全体の候補を返します。wholeline パラメータは、行頭から挿入ポイントまでのすべてのテキストです。wholeline パラメータは、コンテキストのために使用されます。</target>
        </trans-unit>
        <trans-unit id="f9921b4f3858e29c8d8f50be7ccdabc32d452e7c" translate="yes" xml:space="preserve">
          <source>The query above will use the po_parent index to help find the answer, since the po_parent index contains entries for all rows of interest. Note that since po_parent is smaller than a full index, the query will likely run faster too.</source>
          <target state="translated">上のクエリは、答えを見つけるためにpo_parentインデックスを使用します。po_parentは完全なインデックスよりも小さいので、クエリの実行速度も速くなることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0190a12968e1ccf51186372beeb26ae3012cb0b9" translate="yes" xml:space="preserve">
          <source>The query above would very quickly locate the id of 1 even if the R*Tree contained millions of entries. The previous is an example of a &quot;contained-within&quot; query. The R*Tree also supports &quot;overlapping&quot; queries. For example, to find all bounding boxes that overlap the Charlotte area:</source>
          <target state="translated">上のクエリは、R*Treeに何百万ものエントリが含まれていたとしても、1のidを素早く見つけることができます。上の例は、&quot;included-within &quot;クエリの例です。R*Treeは「重複」クエリもサポートしています。例えば、シャーロット地域に重なるすべてのバウンディングボックスを見つけるには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="94364d8100096142da610b0a18f63efa10ad070a" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URIのクエリコンポーネントには、SQLite自体または&lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;カスタムVFS実装&lt;/a&gt;によって解釈されるパラメーターが含まれる場合があります。SQLiteとその組み込み&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;は、次のクエリパラメータを解釈します。</target>
        </trans-unit>
        <trans-unit id="86e91a7c9e388f3708828edd53ce0492e58dcf0d" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URIのクエリコンポーネントには、SQLite自体または&lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;カスタムVFS実装&lt;/a&gt;によって解釈されるパラメーターが含まれる場合があります。SQLiteとその組み込み&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;は、次のクエリパラメータを解釈します。</target>
        </trans-unit>
        <trans-unit id="f6f2f3df836d46d9540098c193cbe7de6978b27d" translate="yes" xml:space="preserve">
          <source>The query contains both a search restriction in the WHERE clause and a sort order in the ORDER BY clause. Both the search and the sort can be accomplished at the same time using the two-column index Idx3.</source>
          <target state="translated">クエリには、WHERE句での検索制限とORDER BY句でのソート順の両方が含まれています。検索とソートは、2カラムインデックスIdx3を使用して同時に行うことができます。</target>
        </trans-unit>
        <trans-unit id="bb441cf385ae38b5e50765b319372e3b2d5a50b2" translate="yes" xml:space="preserve">
          <source>The query does a binary search on the index to find the subset of rows that have fruit='Orange'. (Because the fruit column is the left-most column of the index and the rows of the index are in sorted order, all such rows will be adjacent.) Then it scans the matching index rows from top to bottom to get the rowids for the original table, and for each rowid does a binary search on the original table to find the price.</source>
          <target state="translated">このクエリは、fruit='Orange'を持つ行のサブセットを見つけるためにインデックスのバイナリ検索を行います。(フルーツの列はインデックスの左端の列であり、インデックスの行はソート順になっているため、そのような行はすべて隣接しています)。次に、一致するインデックスの行を上から下へスキャンして元のテーブルの行IDを取得し、各行IDについて元のテーブルのバイナリ検索を行い、価格を見つけます。</target>
        </trans-unit>
        <trans-unit id="0da70d4a5a91c3bdacf749b9198a4a57a477e008" translate="yes" xml:space="preserve">
          <source>The query is not an aggregate</source>
          <target state="translated">クエリは集約ではありません。</target>
        </trans-unit>
        <trans-unit id="d5463ef5a6e2ace12b54dcf259b0837fe48d0c3a" translate="yes" xml:space="preserve">
          <source>The query loop is built from instructions 5 through 13. Instructions 6 through 8 build a record that contains the azData[] values for a single invocation of the callback. A sort key is generated by instructions 9 through 11. Instruction 12 combines the invocation record and the sort key into a single entry and puts that entry on the sort list.</source>
          <target state="translated">クエリループは、命令 5 から 13 で構築されます。命令6から命令8は、コールバックの1回の呼び出しのためのazData[]の値を含むレコードを構築します。ソートキーは命令9から11によって生成されます。命令12は、呼び出しレコードとソートキーを1つのエントリに結合し、そのエントリをソートリストに配置します。</target>
        </trans-unit>
        <trans-unit id="b89b1eb2c0211443a7be50a77507c951f5a3834f" translate="yes" xml:space="preserve">
          <source>The query loop is implemented by instructions 8 through 22. The aggregate key specified by the GROUP BY clause is computed by instructions 9 and 10. Instruction 11 causes the appropriate bucket to come into focus. If a bucket with the given key does not already exists, a new bucket is created and control falls through to instructions 12 and 13 which initialize the bucket. If the bucket does already exist, then a jump is made to instruction 14. The values of aggregate functions are updated by the instructions between 11 and 21. Instructions 14 through 18 update memory slot 1 to hold the next value &quot;min(three+four)&quot;. Then the sum of the &quot;four&quot; column is updated by instructions 19 through 21.</source>
          <target state="translated">クエリ・ループは命令8から22によって実装されます。GROUP BY句で指定された集約キーは、命令9と10によって計算されます。命令11は、適切なバケットに注目させます。与えられたキーを持つバケットがまだ存在しない場合、新しいバケットが作成され、制御はバケットを初期化する命令12と13に委ねられます。バケットが既に存在する場合は、命令14にジャンプします。集約関数の値は、11から21までの命令によって更新されます。命令14〜18は、次の値「min(3+4)」を保持するようにメモリスロット1を更新する。その後、命令19〜21により、「4」列の合計値が更新される。</target>
        </trans-unit>
        <trans-unit id="a6ac9b746a0ebf6db3c5dac60c7fc4d3c527912f" translate="yes" xml:space="preserve">
          <source>The query optimizer might translate this into three separate constraints:</source>
          <target state="translated">クエリ・オプティマイザは、これを3つの別々の制約に変換することができます。</target>
        </trans-unit>
        <trans-unit id="ca7f72fc82a7c6f8223569dbd345a23847f45a71" translate="yes" xml:space="preserve">
          <source>The query optimizer now attempts to implement the ORDER BY clause using an index. Sorting is still used if not suitable index is available.</source>
          <target state="translated">クエリオプティマイザは、インデックスを使用してORDER BY句を実装しようとするようになりました。適切なインデックスが利用できない場合でも、ソートが使用されます。</target>
        </trans-unit>
        <trans-unit id="074dd395e411c2a7564e05c9a803ff7d91501e5c" translate="yes" xml:space="preserve">
          <source>The query planner considers the LIMIT clause when estimating the cost of ORDER BY.</source>
          <target state="translated">クエリプランナは、ORDER BYのコストを見積もる際にLIMIT句を考慮します。</target>
        </trans-unit>
        <trans-unit id="efb22d31da7b95dc237d9b06fed089e63b961bd2" translate="yes" xml:space="preserve">
          <source>The query planner examines the values of bound parameters to help determine if a partial index is usable.</source>
          <target state="translated">クエリプランナはバインドパラメータの値を調べて、部分インデックスが使用可能かどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="e51e3ffe015829441eac83092590224609d07ba7" translate="yes" xml:space="preserve">
          <source>The query planner in SQLite normally does a terrific job of selecting fast algorithms for running your SQL statements. This is true of the legacy query planner and even more true of the new NGQP. There may be an occasional situation where, due to incomplete information, the query planner selects a suboptimal plan. This will happen less often with the NGQP than with the legacy query planner, but it might still happen. Only in those rare cases do application developers need to get involved and help the query planner to do the right thing. In the common case, the NGQP is just a new enhancement to SQLite that makes the application run a little faster and which requires no new developer thought or action.</source>
          <target state="translated">SQLite のクエリプランナは通常、SQL 文を実行するための高速なアルゴリズムを選択するという素晴らしい仕事をしています。これは従来のクエリプランナにも当てはまりますが、新しいNGQPではさらに当てはまります。不完全な情報のために、クエリプランナーが最適ではないプランを選択してしまうという状況が時々発生するかもしれません。NGQPでは、従来のクエリプランナーよりも頻度は低くなりますが、それでも起こる可能性はあります。アプリケーション開発者が関与し、クエリプランナが正しいことを行うように支援する必要があるのは、このようなごくまれなケースだけです。一般的なケースでは、NGQPはアプリケーションの実行を少し速くするSQLiteの新しい機能強化に過ぎず、開発者が新たに考えたり、行動したりする必要はありません。</target>
        </trans-unit>
        <trans-unit id="7056feb20ef72b761795635d81c08e5ed2af62a2" translate="yes" xml:space="preserve">
          <source>The query planner in future versions of SQLite might grow smart enough to make transformations such as the above automatically, in both directions. That is to say, future versions of SQLite might transform queries of the first form into the second, or queries written the second way into the first. As of SQLite version 3.22.0 (2018-01-22), the query planner will flatten the subquery if the outer query does not make use of any user-defined functions or subqueries in its result set. For the examples shown above, however, SQLite implements each of the queries as written.</source>
          <target state="translated">将来のバージョンのSQLiteのクエリプランナは、上記のような変換を双方向で自動的に行うことができるように賢くなるかもしれません。つまり、将来のバージョンのSQLiteでは、第1の形式のクエリを第2の形式に変換したり、第2の方法で書かれたクエリを第1の形式に変換したりするかもしれません。SQLite バージョン 3.22.0 (2018-01-22)の時点では、クエリプランナは、外側のクエリが結果セットの中でユーザー定義の関数やサブクエリを利用していない場合、サブクエリを平坦化します。ただし、上記の例では、SQLite はそれぞれのクエリを記述された通りに実装しています。</target>
        </trans-unit>
        <trans-unit id="f9ae7f14e38f472239e8cbf47519f9f962bf6c41" translate="yes" xml:space="preserve">
          <source>The query planner is able to optimize IN operators on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method does not set the sqlite3_index_constraint_usage.omit flag of the virtual table column to the left of the IN operator.</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;メソッドが仮想テーブル列のsqlite3_index_constraint_usage.omitフラグをIN演算子の左側に設定しない場合でも、クエリプランナーは&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt; IN演算子を最適化できます。</target>
        </trans-unit>
        <trans-unit id="4b67d5103aec179badd00d13df4b687ed31a2fd8" translate="yes" xml:space="preserve">
          <source>The query planner is more aggressive about using &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; for views and subqueries for which it is not possible to create a persistent index.</source>
          <target state="translated">クエリプランナーは、永続的なインデックスを作成できないビューとサブクエリに&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス&lt;/a&gt;を使用することについてより積極的です。</target>
        </trans-unit>
        <trans-unit id="0ff80f93923c8ea0ed391da80428d773af3f58c7" translate="yes" xml:space="preserve">
          <source>The query planner is now able to use &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; that contain AND-connected terms in the WHERE clause.</source>
          <target state="translated">クエリプランナーは、WHERE句でAND接続された用語を含む&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;を使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="f1bf26dc5394aa893fb29edbb88f7b0f3c1a3bf4" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_master&lt;/b&gt;.</source>
          <target state="translated">クエリプランナーは、スキーマの読み取り時に統計テーブルの内容をメモリに読み込みます。したがって、アプリケーションが統計テーブルを直接変更しても、SQLiteはその変更にすぐには気づきません。アプリケーションは&lt;b&gt;ANALYZE sqlite_masterを&lt;/b&gt;実行することにより、クエリプランナーに統計テーブルを強制的に再読み込みさせることができます。</target>
        </trans-unit>
        <trans-unit id="764ebb928a21a2403e7ad4384e4177e72689b2ef" translate="yes" xml:space="preserve">
          <source>The query planner must decide between many possible implementations of this query, but two plans in particular are of note:</source>
          <target state="translated">クエリプランナは、このクエリの多くの可能性のある実装の中から決定しなければなりませんが、特に2つのプランに注目してください。</target>
        </trans-unit>
        <trans-unit id="35937457496b4c465e761e374d83f1c328cfb649" translate="yes" xml:space="preserve">
          <source>The query planner now does a better job of optimizing &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; accesses in a 3-way or higher join where constraints on the virtual table are split across two or more other tables of the join.</source>
          <target state="translated">クエリプランナーは、&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;制約が結合の他の2つ以上のテーブルに分割されている3ウェイ以上の結合で、仮想テーブルアクセスを最適化するという優れた機能を実行するようになりました。</target>
        </trans-unit>
        <trans-unit id="ecefb9cd6e1de2d9ed81b2814e874ca9b432f553" translate="yes" xml:space="preserve">
          <source>The query planner now prefers to implement FROM-clause subqueries using &lt;a href=&quot;optoverview#coroutines&quot;&gt;co-routines&lt;/a&gt; rather using the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; optimization. Support for the use of co-routines for subqueries may no longer be disabled.</source>
          <target state="translated">問い合わせプランナは現在、使用してFROM句のサブクエリを実装することを好む&lt;a href=&quot;optoverview#coroutines&quot;&gt;コルーチン&lt;/a&gt;ではなく使用して&lt;a href=&quot;optoverview#flattening&quot;&gt;、クエリの分割・統合&lt;/a&gt;の最適化を。サブクエリ用のコルーチンの使用のサポートは無効化されなくなった可能性があります。</target>
        </trans-unit>
        <trans-unit id="39ca8ebd42e9f170c8e29a8cb05c453c4287996d" translate="yes" xml:space="preserve">
          <source>The query planner now recognizes that any column in the right-hand table of a LEFT JOIN can be NULL, even if that column has a NOT NULL constraint. Avoid trying to optimize out NULL tests in those cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">クエリプランナーは、その列にNOT NULL制約がある場合でも、LEFT JOINの右側のテーブルの任意の列がNULLになる可能性があることを認識します。このような場合は、NULLテストを最適化しないでください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7edの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="ec8769590db8f2b5c877d645663be729be900155" translate="yes" xml:space="preserve">
          <source>The query planner now uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information (created by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;) to help determine if the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; is appropriate.</source>
          <target state="translated">クエリプランナーは、&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;情報（&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;によって作成された）を使用して、&lt;a href=&quot;optoverview#skipscan&quot;&gt;スキップスキャン最適化&lt;/a&gt;が適切かどうかを判断するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c31a7ce3fe100e3f0ec40a06c5c355aa9ab9699f" translate="yes" xml:space="preserve">
          <source>The query planner used &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;-style statistics for one or more indexes of the table at some point during the lifetime of the current connection.</source>
          <target state="translated">クエリプランナーは、現在の接続の存続期間中のある時点で、テーブルの1つ以上のインデックスに対して&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;スタイルの統計を使用しました。</target>
        </trans-unit>
        <trans-unit id="a97e7a7c05ace47af23f942a5bb054692500ea21" translate="yes" xml:space="preserve">
          <source>The query planner uses a full scan of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; instead of a full scan of the main table, in cases where that makes sense.</source>
          <target state="translated">クエリプランナーは、メインテーブルのフルスキャンではなく、&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt;フルスキャンを使用します。</target>
        </trans-unit>
        <trans-unit id="5c0c2991e6f563d6716af52b8b617039da1f2fdd" translate="yes" xml:space="preserve">
          <source>The query starts by doing a binary search on the Idx1 index for entries that have fruit='Peach'. SQLite can do this binary search on the Idx1 index but not on the original FruitsForSale table because the rows in Idx1 are sorted by the &quot;fruit&quot; column. Having found a row in the Idx1 index that has fruit='Peach', the database engine can extract the rowid for that row. Then the database engines does a second binary search on the original FruitsForSale table to find the original row that contains fruit='Peach'. From the row in the FruitsForSale table, SQLite can then extract the value of the price column. This procedure is illustrated by &lt;a href=&quot;#fig5&quot;&gt;figure 5&lt;/a&gt;.</source>
          <target state="translated">クエリは、frx = 'Peach'を持つエントリのIdx1インデックスでバイナリ検索を実行することから始まります。 SQLiteは、Idx1の行が「fruit」列でソートされているため、Idx1インデックスでこのバイナリ検索を実行できますが、元のFruitsForSaleテーブルでは実行できません。 Fruit = 'Peach'を持つIdx1インデックス内の行を検出すると、データベースエンジンはその行のROWIDを抽出できます。次に、データベースエンジンは、元のFruitsForSaleテーブルで2番目のバイナリ検索を実行して、fruit = 'Peach'を含む元の行を見つけます。 SQLiteは、FruitsForSaleテーブルの行から、price列の値を抽出できます。この手順を&lt;a href=&quot;#fig5&quot;&gt;図5に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="7d2f0fdfeb4c2c835aff8667a9df0a76c56f4c48" translate="yes" xml:space="preserve">
          <source>The query string is optional. If the query string is present, then all query parameters are passed through into the xOpen method of the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">クエリ文字列はオプションです。クエリ文字列が存在する場合、すべてのクエリパラメータが基になる&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt; xOpenメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="85170b302d04cae08fe65e554bbdfb1393e9fe62" translate="yes" xml:space="preserve">
          <source>The query syntax has been revised where necessary to remove ambiguities and to make it possible to escape special characters in query terms.</source>
          <target state="translated">クエリ構文は、曖昧さを取り除き、クエリ用語の中の特殊文字をエスケープできるようにするために、必要に応じて改訂されました。</target>
        </trans-unit>
        <trans-unit id="6a08992b107064a2b4d32992f6db718c41160975" translate="yes" xml:space="preserve">
          <source>The query_only pragma prevents all changes to database files when enabled.</source>
          <target state="translated">query_only pragmaが有効な場合、データベースファイルへのすべての変更を防止します。</target>
        </trans-unit>
        <trans-unit id="c227c47e0d2b0279a9dff3f8b02f840ecf77eb68" translate="yes" xml:space="preserve">
          <source>The quote(X) function returns the text of an SQL literal which is the value of its argument suitable for inclusion into an SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOBs are encoded as hexadecimal literals. Strings with embedded NUL characters cannot be represented as string literals in SQL and hence the returned string literal is truncated prior to the first NUL.</source>
          <target state="translated">quote(X)関数は、SQL文に含めるのに適したSQLリテラルのテキストを返します。文字列はシングルクォートで囲まれ、必要に応じて内部引用符にはエスケープが入ります。BLOBは16進リテラルとしてエンコードされます。NUL文字が埋め込まれた文字列はSQLでは文字列リテラルとして表現できないため、返される文字列リテラルは最初のNUL文字より前に切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="9f63b25a5004d971fa73a7b89854797c36e88a71" translate="yes" xml:space="preserve">
          <source>The random() function provides 64 bits of randomness instead of only 32 bits.</source>
          <target state="translated">random()関数は、32 ビットだけではなく 64 ビットのランダム性を提供します。</target>
        </trans-unit>
        <trans-unit id="db5db9919e511217ef7da4b79216c59c757f004b" translate="yes" xml:space="preserve">
          <source>The random() function returns a pseudo-random integer between -9223372036854775808 and +9223372036854775807.</source>
          <target state="translated">random()関数は、-9223372036854775808から+9223372036854775807の間の擬似乱数を返します。</target>
        </trans-unit>
        <trans-unit id="dc66046ce33b1a2430fa7d3f10cb359cc80fae20" translate="yes" xml:space="preserve">
          <source>The randomblob(N) function return an N-byte blob containing pseudo-random bytes. If N is less than 1 then a 1-byte random blob is returned.</source>
          <target state="translated">randlob(N)関数は疑似ランダムバイトを含む N バイトの blob を返します。N が 1 より小さい場合は、1 バイトのランダムブロブが返されます。</target>
        </trans-unit>
        <trans-unit id="c291d5ba33f13d62c916974b77fcaf954ce3ff7e" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most. Key columns come before auxiliary columns.)</source>
          <target state="translated">インデックス内の列のランク。(0は左端を意味し、キーカラムは補助カラムの前に来る)。</target>
        </trans-unit>
        <trans-unit id="0b2bd6ab8a45c757d36fc0179def745c6a1bbb66" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most.)</source>
          <target state="translated">インデックス内のカラムのランク。(0は左端を意味する)</target>
        </trans-unit>
        <trans-unit id="463c4210effd7ad2a8dada3187acf9269beea08a" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed, or -1 if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed and -2 if the &lt;a href=&quot;expridx&quot;&gt;index is on an expression&lt;/a&gt;.</source>
          <target state="translated">インデックスが作成されるテーブル内の列のランク&lt;a href=&quot;lang_createtable#rowid&quot;&gt;。index&lt;/a&gt; -columnがインデックスが作成されるテーブルのROWIDの場合は-1 、&lt;a href=&quot;expridx&quot;&gt;インデックスが式にある&lt;/a&gt;場合は-2 。</target>
        </trans-unit>
        <trans-unit id="84413b7d19914c0bede4000ce3b0ffb8491410c6" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed. A value of -1 means &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; and a value of -2 means that an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt; is being used.</source>
          <target state="translated">インデックスが作成されるテーブル内の列のランク。値-1は&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を意味し、値-2は&lt;a href=&quot;expridx&quot;&gt;式&lt;/a&gt;が使用されていることを意味します。</target>
        </trans-unit>
        <trans-unit id="8754b3bec73ba7fde29d928b708ca495c5b77ae4" translate="yes" xml:space="preserve">
          <source>The rank of word.</source>
          <target state="translated">言葉のランク。</target>
        </trans-unit>
        <trans-unit id="2dd609ed9718452c7fad1b16788c833004253127" translate="yes" xml:space="preserve">
          <source>The rank option is used to change the default auxiliary function mapping for the rank column. The option should be set to a text value in the same format as described for &lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&quot;rank MATCH ?&quot;&lt;/a&gt; terms above. For example:</source>
          <target state="translated">ランクオプションは、ランク列のデフォルトの補助関数マッピングを変更するために使用されます。このオプションは、&lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;「ランクマッチ？」で&lt;/a&gt;説明したのと同じ形式のテキスト値に設定する必要があります。上記の条件。例えば：</target>
        </trans-unit>
        <trans-unit id="3e012920d09c510ffee894f9967688d5537ade9a" translate="yes" xml:space="preserve">
          <source>The rate of enhancement for SQLite over the previous five years (2010-2015) is approximately 6 increments of Y per year. The numbering format used by for &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; and &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; allows versions up to 3.999.999, which is more than enough for the planned end-of-support date for SQLite in 2050. However, the current tarball naming conventions only reserve two digits for the Y and so the naming format for downloads will need to be revised in about 2030.</source>
          <target state="translated">SQLiteの過去5年間（2010〜2015年）の機能強化率は、年間で約6増分です。が&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;および&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）に&lt;/a&gt;使用する番号付け形式では、最大3.999.999のバージョンを使用できます。これは、2050年のSQLiteのサポート終了予定日には十分な数です。ただし、現在のtarball命名規則では、 Yなど、ダウンロードの命名形式は2030年頃に修正する必要があります。</target>
        </trans-unit>
        <trans-unit id="e8a5095befc118ca6a6fec21354c920d6bd315d2" translate="yes" xml:space="preserve">
          <source>The reader algorithm in the previous paragraphs works correctly, but because frames for page P can appear anywhere within the WAL, the reader has to scan the entire WAL looking for page P frames. If the WAL is large (multiple megabytes is typical) that scan can be slow, and read performance suffers. To overcome this problem, a separate data structure called the wal-index is maintained to expedite the search for frames of a particular page.</source>
          <target state="translated">前の段落のリーダーアルゴリズムは正しく動作しますが、ページPのフレームはWAL内のどこにでも現れる可能性があるため、リーダーはページPのフレームを探してWAL全体をスキャンしなければなりません。WALが大きい場合(数メガバイトが一般的です)、スキャンに時間がかかり、読み取り性能が低下します。この問題を克服するために、特定のページのフレームの検索を迅速化するために、wal-indexと呼ばれる別個のデータ構造が維持されています。</target>
        </trans-unit>
        <trans-unit id="3e2fc6a74baa30b6fadb3fd43bce3110d90f198d" translate="yes" xml:space="preserve">
          <source>The readfile(X) SQL function reads the entire content of the file named X and returns that content as a BLOB. This can be used to load content into a table. For example:</source>
          <target state="translated">readfile(X)SQL 関数は、X という名前のファイルの内容全体を読み込み、その内容を BLOB として返します。これは、テーブルにコンテンツをロードするために使用することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f5d4c0c9266d8eca05dca08f98a5cbf6d922d36a" translate="yes" xml:space="preserve">
          <source>The realization that an aggregate query is really two consecutive loops makes it much easier to understand the difference between a WHERE clause and a HAVING clause in SQL query statement. The WHERE clause is a restriction on the first loop and the HAVING clause is a restriction on the second loop. You can see this by adding both a WHERE and a HAVING clause to our example query:</source>
          <target state="translated">集計クエリは実際には2つの連続したループであるということを理解することで、SQLクエリ文のWHERE句とHAVING句の違いを理解するのが非常に簡単になります。WHERE 句は最初のループに対する制限であり、HAVING 句は 2 番目のループに対する制限です。この例のクエリに WHERE 句と HAVING 句の両方を追加すると、このことがわかります。</target>
        </trans-unit>
        <trans-unit id="4a5758542d7b569e5728a8a94a0c5f527ec1ddfe" translate="yes" xml:space="preserve">
          <source>The reallocarray() interface is a recent innovation (circa 2014) from the OpenBSD community that grow out of efforts to prevent the next &lt;a href=&quot;http://heartbleed.com&quot;&gt;&quot;heartbleed&quot; bug&lt;/a&gt; by avoiding 32-bit integer arithmetic overflow on memory allocation size computations. The reallocarray() function has both unit-size and count parameters. To allocate memory sufficient to hold an array of N elements each X-bytes in size, one calls &quot;reallocarray(0,X,N)&quot;. This is preferred over the traditional technique of invoking &quot;malloc(X*N)&quot; as reallocarray() eliminates the risk that the X*N multiplication will overflow and cause malloc() to return a buffer that is a different size from what the application expected.</source>
          <target state="translated">reallocarray（）インターフェースはOpenBSDコミュニティによる最近のイノベーション（2014年頃）であり、メモリ割り当てサイズの計算で32ビット整数の算術オーバーフローを回避することにより、次の&lt;a href=&quot;http://heartbleed.com&quot;&gt;「ハートブリード」バグ&lt;/a&gt;を防止するための努力から生まれました。 reallocarray（）関数には、ユニットサイズとカウントの両方のパラメーターがあります。サイズがそれぞれXバイトのN要素の配列を保持するのに十分なメモリを割り当てるには、「reallocarray（0、X、N）」を呼び出します。 reallocarray（）はX * N乗算がオーバーフローし、malloc（）がアプリケーションとは異なるサイズのバッファーを返すリスクを排除するため、これは「malloc（X * N）」を呼び出す従来の手法よりも推奨されます。期待された。</target>
        </trans-unit>
        <trans-unit id="a25a89f7da0624003a3e075ec1d5437a5611f942" translate="yes" xml:space="preserve">
          <source>The reason for attempting to read the</source>
          <target state="translated">を読もうとした理由は</target>
        </trans-unit>
        <trans-unit id="61ed3e5eacc7786aa96400e0606560d6b0c2919c" translate="yes" xml:space="preserve">
          <source>The reason for this is easy to understand: When a document is inserted into the FTS5 table, an entry is added to the full-text index to record the position of each token within the new document. When a document is removed, the original data is required in order to determine the set of entries that need to be removed from the full-text index. So if the data supplied to FTS5 when a row is deleted using this command is different from that used to determine the set of token instances when it was inserted, some full-text index entries may not be correctly deleted, or FTS5 may try to remove index entries that do not exist. This can leave the full-text index in an unpredictable state, making future query results unreliable.</source>
          <target state="translated">その理由は簡単に理解できます。文書がFTS5テーブルに挿入されると、新しい文書内の各トークンの位置を記録するためのエントリが全文インデックスに追加される。文書が削除されると、全文インデックスから削除する必要のあるエントリのセットを決定するために、元のデータが必要となります。そのため、このコマンドを使用して行が削除されたときに FTS5 に供給されたデータが、それが挿入されたときのトークンインスタンスのセットを決定するために使用されたものと異なる場合、一部のフルテキストインデックスエントリが正しく削除されなかったり、FTS5 が存在しないインデックスエントリを削除しようとしたりする可能性があります。これにより、全文インデックスが予測不可能な状態になってしまい、将来の問い合わせ結果が信頼できなくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="aaf49440241f0d03e40af262860c9b5798f65bc8" translate="yes" xml:space="preserve">
          <source>The reason that the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; has its buffer pointer and buffer size arguments reversed from what is found in the standard library snprintf() routine is because there was no snprintf() routine in the standard C library when Hipp was first implementing his version, and he chose a different order than the designers of the standard C library.</source>
          <target state="translated">その理由という&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintfは、（） &lt;/a&gt;（）ヒップが最初に彼のバージョンを実装した標準Cライブラリにはのsnprintf（）ルーチンがなかったので、ルーチンはそのバッファポインタを持っており、標準ライブラリのsnprintfで発見されたものとは逆のサイズ引数をバッファリングし、そして彼は、標準Cライブラリの設計者とは異なる順序を選択しました。</target>
        </trans-unit>
        <trans-unit id="791eaa4dd6fb2ae12ed4b869340107d40b780f17" translate="yes" xml:space="preserve">
          <source>The reasons why C is the best language to implement SQLite include:</source>
          <target state="translated">SQLiteを実装するのにC言語が最適な理由には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="570c3cd1b218e89b5e9796c1a0c8bf3041d5fcd8" translate="yes" xml:space="preserve">
          <source>The recommended fix for this problem is to select a different filesystem. These days, there is a huge selection of high-performance, reliable, patent-free filesystems that support long filenames. Where possible, it is recommended that embedded devices use one of these other filesystems. This will avoid compatibility issues and the danger of &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="translated">この問題に対して推奨される修正は、別のファイルシステムを選択することです。最近では、長いファイル名をサポートする、高性能で信頼性が高く、特許のないファイルシステムが数多く選択されています。可能な場合は、組み込みデバイスでこれらの他のファイルシステムのいずれかを使用することをお勧めします。これにより、互換性の問題と、&lt;a href=&quot;shortnames#db83corrupt&quot;&gt;8 + 3のファイル名の一貫性のない使用によって引き起こされるデータベースの破損&lt;/a&gt;の危険が回避されます。</target>
        </trans-unit>
        <trans-unit id="25181bcaf1df8e046a1c955d3b9df90abb750621" translate="yes" xml:space="preserve">
          <source>The recommended setting is 0, meaning that double-quoted strings are disallowed in all contexts. However, the default setting is 3 for maximum compatibility with legacy applications.</source>
          <target state="translated">推奨される設定は 0 で、すべてのコンテキストで二重引用符で囲まれた文字列は禁止されています。しかし、レガシーアプリケーションとの互換性を最大化するために、デフォルトの設定は3です。</target>
        </trans-unit>
        <trans-unit id="f9e4e6885559253d0ddfdbd8cf19b8d22821af1f" translate="yes" xml:space="preserve">
          <source>The recommended way of creating, updating, listing, and extracting an SQLite Archive is to use the &lt;a href=&quot;cli&quot;&gt;sqlite3.exe command-line shell&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02) or later. This CLI supports the -A command-line option that allows easy management of SQLite Archives. The CLI for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22) has the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; for managing SQLite Archives, but that requires interacting with the shell.</source>
          <target state="translated">SQLiteアーカイブの作成、更新、一覧表示、および抽出の推奨される方法は、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;バージョン3.23.0&lt;/a&gt;（2018-04-02）以降の場合は&lt;a href=&quot;cli&quot;&gt;sqlite3.exeコマンドラインシェル&lt;/a&gt;を使用することです。このCLIは、SQLiteアーカイブの管理を容易にする-Aコマンドラインオプションをサポートしています。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;バージョン3.22.0&lt;/a&gt;（2018-01-22）のCLIには、SQLiteアーカイブを管理するための&lt;a href=&quot;cli#sqlar&quot;&gt;.archiveコマンド&lt;/a&gt;がありますが、これにはシェルとの対話が必要です。</target>
        </trans-unit>
        <trans-unit id="4601afd19c62f4d6f4dd6a59905680482f9f3f16" translate="yes" xml:space="preserve">
          <source>The record format makes extensive use of the &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt; or &lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt; representation of 64-bit signed integers defined above.</source>
          <target state="translated">レコード形式は、上記で定義された64ビット符号付き整数の&lt;a href=&quot;fileformat2#varint&quot;&gt;可変長整数&lt;/a&gt;または&lt;a href=&quot;fileformat2#varint&quot;&gt;可変長&lt;/a&gt;表現を広範囲に使用します。</target>
        </trans-unit>
        <trans-unit id="6f45dfeab7c8fdea2c19dfb3263b7e954261008d" translate="yes" xml:space="preserve">
          <source>The register P3 contains one less than the maximum number of allowed errors. At most reg(P3) errors will be reported. In other words, the analysis stops as soon as reg(P1) errors are seen. Reg(P1) is updated with the number of errors remaining.</source>
          <target state="translated">レジスタP3には、許容される最大エラー数よりも1つ少ないエラーが含まれています。最大でもreg(P3)エラーが報告されます。つまり、reg(P1)エラーが見られるとすぐに解析が停止します。reg(P1)は、残りのエラー数で更新される。</target>
        </trans-unit>
        <trans-unit id="b0a0f881a2de041dc76deecadc2825d6252c40fe" translate="yes" xml:space="preserve">
          <source>The registers P1 through P1+P2-1 contain a single row of results. This opcode causes the sqlite3_step() call to terminate with an SQLITE_ROW return code and it sets up the sqlite3_stmt structure to provide access to the r(P1)..r(P1+P2-1) values as the result row.</source>
          <target state="translated">レジスタP1からP1+P2-1は結果の1行を含んでいます。このオペコードはsqlite3_step()呼び出しをSQLITE_ROWリターンコードで終了させ、結果行としてr(P1)...r(P1+P2-1)値へのアクセスを提供するためにsqlite3_stmt構造体をセットアップします。</target>
        </trans-unit>
        <trans-unit id="3ad008f7525662f6767cf59c0a5ffbf397455036" translate="yes" xml:space="preserve">
          <source>The relative precedence of the set operations is different. In particular, using the standard query syntax the &quot;OR&quot; operator has a higher precedence than &quot;AND&quot;. The precedence of operators when using the standard query syntax is:</source>
          <target state="translated">集合演算の相対的な優先順位は異なります。特に、標準的なクエリ構文では、&quot;OR &quot;演算子の方が &quot;AND &quot;演算子よりも優先順位が高くなります。標準のクエリ構文を使用した場合の演算子の優先順位は</target>
        </trans-unit>
        <trans-unit id="4055a7e54aa1eb8dd8ef4889c3d207a5659a2b35" translate="yes" xml:space="preserve">
          <source>The release build is used to validate the generated machine code.</source>
          <target state="translated">リリースビルドは、生成されたマシンコードを検証するために使用されます。</target>
        </trans-unit>
        <trans-unit id="4fe1d3a13dd63ed4836e434d893dc270763cfe84" translate="yes" xml:space="preserve">
          <source>The release checklist is continuously evolving. As new problems or potential problems are discovered, new checklist items are added to make sure those problems do not appear in subsequent releases. The release checklist has proven to be an invaluable tool in helping to ensure that nothing is overlooked during the release process.</source>
          <target state="translated">リリースチェックリストは継続的に進化しています。新しい問題や潜在的な問題が発見されるたびに、新しいチェックリスト項目が追加され、後続のリリースでそれらの問題が発生しないようになっています。リリースチェックリストは、リリースプロセス中に見落とされることがないようにするための貴重なツールであることが証明されています。</target>
        </trans-unit>
        <trans-unit id="54fb9bcb3273ff541df78c3b4ae7a5c1d95caf43" translate="yes" xml:space="preserve">
          <source>The release checklist is not automated: developers run each item on the checklist manually. We find that it is important to keep a human in the loop. Sometimes problems are found while running a checklist item even though the test itself passed. It is important to have a human reviewing the test output at the highest level, and constantly asking &quot;Is this really right?&quot;</source>
          <target state="translated">リリースチェックリストは自動化されていません:開発者はチェックリストの各項目を手動で実行します。人間をループの中に入れておくことが重要であることがわかります。テスト自体は合格しているのに、チェックリストの項目を実行している間に問題が見つかることがあります。人間がテスト出力を最高レベルでレビューし、常に &quot;これは本当に正しいのか?&quot;と質問することが重要です。</target>
        </trans-unit>
        <trans-unit id="2c9d643524e4e559789769fa0d9c05fd5ba6364a" translate="yes" xml:space="preserve">
          <source>The relevancy of a document may depend on something other than just the data available in the return value of matchinfo. For example each document in the database may be assigned a static weight based on factors unrelated to its content (origin, author, age, number of references etc.). These values can be stored by the application in a separate table that can be joined against the documents table in the sub-query so that the rank function may access them.</source>
          <target state="translated">文書の関連性は、 matchinfo の戻り値で得られるデータ以外にも依存する場合があります。例えば、データベース内の各ドキュメントは、その内容とは無関係な要素(出典、著者、年齢、参照数など)に基づいて静的な重みを割り当てることができます。これらの値はアプリケーションによって別のテーブルに格納され、副問い合わせのdocumentsテーブルに対して結合され、ランク関数がアクセスできるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="d03714ee4fa95f4e8679f472e2f3c59cc9a47883" translate="yes" xml:space="preserve">
          <source>The reliability and robustness of SQLite is achieved in part by thorough and careful testing.</source>
          <target state="translated">SQLiteの信頼性と堅牢性は、徹底した慎重なテストによって部分的に達成されています。</target>
        </trans-unit>
        <trans-unit id="7a3157bd64ab9a637ba9a36bada2711bd2147294" translate="yes" xml:space="preserve">
          <source>The remainder of this document will guide the reader through the steps needed to maintain a private branch. The general idea is the same as outlined above. This section merely provides more detail.</source>
          <target state="translated">ここでは、個人経営の支店を維持するために必要な手順を説明します。一般的な考え方は、上記で説明した通りです。このセクションでは、より詳細な説明をしています。</target>
        </trans-unit>
        <trans-unit id="30a538553e382aa8cfb9498b6fd827480cf2d80b" translate="yes" xml:space="preserve">
          <source>The remaining fields of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object all store pointers to functions that implement primitive operations. We call these &quot;methods&quot;. The first method, xOpen, is used to open files on the underlying storage media. The result is an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. There are additional methods, defined by the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object itself that are used to read and write and close the file. The additional methods are detailed below. The filename is in UTF-8. SQLite will guarantee that the zFilename string passed to xOpen() is a full pathname as generated by xFullPathname() and that the string will be valid and unchanged until xClose() is called. So the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; can store a pointer to the filename if it needs to remember the filename for some reason. The flags argument to xOpen() is a copy of the flags argument to sqlite3_open_v2(). If sqlite3_open() or sqlite3_open16() is used, then flags is &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set. SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトの残りのフィールドはすべて、プリミティブ操作を実装する関数へのポインターを格納します。これらを「方法」と呼びます。最初の方法であるxOpenは、基になるストレージメディア上のファイルを開くために使用されます。結果は&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトです。&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクト自体によって定義される追加のメソッドがあり、ファイルの読み取りと書き込み、およびファイルのクローズに使用されます。追加の方法は以下に詳述されています。ファイル名はUTF-8です。 SQLiteは、xOpen（）に渡されるzFilename文字列がxFullPathname（）によって生成された絶対パス名であること、およびxClose（）が呼び出されるまで文字列が有効で変更されないことを保証します。したがって、&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;何らかの理由でファイル名を記憶する必要がある場合は、ファイル名へのポインタを保存できます。 xOpen（）のflags引数は、sqlite3_open_v2（）のflags引数のコピーです。 sqlite3_open（）またはsqlite3_open16（）を使用する場合、フラグは&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | です。&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。 xOpen（）がファイルを読み取り専用で開くと、SQLITE_OPEN_READONLYを含めるように* pOutFlagsが設定され&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;ます&lt;/a&gt;。 * pOutFlagsの他のビットが設定される場合があります。 SQLiteは、開かれているオブジェクトに応じて、次のフラグのいずれかをxOpen（）呼び出しに追加します。</target>
        </trans-unit>
        <trans-unit id="75ee3ed9cd8aa1cdca7e660d366395ab9cdd104b" translate="yes" xml:space="preserve">
          <source>The remaining seven methods defined by this structure (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and xMutexNotheld) implement the following interfaces (respectively):</source>
          <target state="translated">この構造体によって定義された残りの7つのメソッド(xMutexAlloc、xMutexFree、xMutexEnter、xMutexTry、xMutexLeave、xMutexHeld、およびxMutexNotheld)は、それぞれ以下のインタフェースを実装しています(それぞれ)。</target>
        </trans-unit>
        <trans-unit id="01d5ccb02fb58f9483b8bb4a6c89788e5e99328d" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option is not supported.</source>
          <target state="translated">remove_diacritics オプションはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="5dc3bfc4e2330eb1c8eb7d47b9e9b34b4b7effb1" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option may be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">remove_diacriticsオプションは、&quot;0&quot;、&quot;1&quot;、または &quot;2 &quot;を設定することができます。デフォルト値は &quot;1 &quot;です。1&quot; または &quot;2&quot; に設定されている場合、上述したように、ラテンスクリプトの文字の中からダイアクリティックが削除されます。しかし、&quot;1 &quot;に設定されている場合は、単一のユニコードコードのコードポイントを使用して複数のダイアクリティックを持つ文字を表現するというかなり珍しいケースでは、ダイアクリティックは削除されません。例えば、コードポイント 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;)の場合、ダイアクリティカルは削除されません。これは技術的にはバグですが、下位互換性の問題を生まずに修正することはできません。このオプションが &quot;2&quot; に設定されている場合、すべてのラテン文字からダイアクリティカルが正しく削除されます。</target>
        </trans-unit>
        <trans-unit id="e878b1555960f1149f69c44e721edf9e3c3726dd" translate="yes" xml:space="preserve">
          <source>The replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing.</source>
          <target state="translated">replace（X、Y、Z）関数は、文字列Xで文字列Yが出現するたびに文字列Zで置き換えられた文字列を返します。比較には&lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;照合シーケンスが使用されます。Yが空の文字列の場合、Xを変更せずに返します。Zが最初に文字列でない場合、処理の前にUTF-8文字列にキャストされます。</target>
        </trans-unit>
        <trans-unit id="7d84cb3d97dd720ff83b043f47169f048a42ed9d" translate="yes" xml:space="preserve">
          <source>The repository created in the previous step is initially empty. The next step is to load the baseline SQLite release - circle (1) in the diagram above.</source>
          <target state="translated">前のステップで作成したリポジトリは初期状態では空です。次のステップでは、ベースラインのSQLiteリリースをロードします-上図の○印(1)を付けます。</target>
        </trans-unit>
        <trans-unit id="10c2d611bbd1154503c3d2f589b7893620f36217" translate="yes" xml:space="preserve">
          <source>The reserved region is an area of unused space at the end of every page (except the locking page) that extensions can use to hold per-page information. The size of the reserved region is determined by the one-byte unsigned integer found at an offset of 20 into the database file header. The size of the reserved region is usually zero.</source>
          <target state="translated">予約領域は、拡張機能がページごとの情報を保持するために使用できる、すべてのページ(ロックページを除く)の最後にある未使用の領域です。予約領域のサイズは、データベース ファイル ヘッダーの 20 のオフセットにある 1 バイト符号なし整数によって決定されます。予約領域のサイズは通常ゼロです。</target>
        </trans-unit>
        <trans-unit id="5406b5dfde9f00d0738ba2c75a1507fa33caf617" translate="yes" xml:space="preserve">
          <source>The reserved region.</source>
          <target state="translated">予約地域です。</target>
        </trans-unit>
        <trans-unit id="aad9068a01cab0c1ed6f0408e5a3ca43105c9476" translate="yes" xml:space="preserve">
          <source>The response of SQLite to out-of-memory (OOM) errors is tested using a specialized memory allocator overlay that can simulate memory failures. The overlay is a layer that is inserted in between the memory allocator and the rest of SQLite. The overlay passes most memory allocation requests straight through to the underlying allocator and passes the results back up to the requester. But the overlay can be set to cause the Nth memory allocation to fail. To run an OOM test, the overlay is first set to fail on the first allocation attempt. Then some test script is run and verification that the allocation was correctly caught and handled is made. Then the overlay is set to fail on the second allocation and the test repeats. The failure point continues to advance one allocation at a time until the entire test procedure runs to completion without hitting a memory allocation error. This whole test sequence run twice. On the first pass, the overlay is set to fail only the Nth allocation. On the second pass, the overlay is set to fail the Nth and all subsequent allocations.</source>
          <target state="translated">メモリ不足(OOM)エラーに対する SQLite の応答は、メモリ障害をシミュレートできる特殊なメモリ・アロケータ・オーバーレイを使用してテストされています。オーバーレイは、メモリアロケータとSQLiteの残りの部分の間に挿入されるレイヤーです。オーバーレイは、ほとんどのメモリ割り当て要求を直接基礎となるアロケータに渡し、その結果を要求元に戻します。しかし、オーバーレイは N 番目のメモリ割り当てに失敗するように設定することができます。OOM テストを実行するには、まず最初のアロケーションの試行で失敗するようにオーバーレイを設定します。その後、テストスクリプトが実行され、アロケーションが正しくキャッチされて処理されたかどうかが検証されます。その後、2 回目のアロケーションでオーバーレイが失敗するように設定され、テストが繰り返されます。失敗ポイントは、テスト手順全体がメモリアロケーションエラーにヒットせずに完了するまで、一度に1つのアロケーションを進め続けます。このテストシーケンスは2回実行されます。最初のパスでは、オーバーレイはN番目のアロケーションのみ失敗するように設定されています。2回目の実行では、N番目のアロケーションとそれ以降のすべてのアロケーションで失敗するように設定されています。</target>
        </trans-unit>
        <trans-unit id="12691a5bbec67aa65e24fe31d2477402bd3c4199" translate="yes" xml:space="preserve">
          <source>The rest of the module structure consists of methods used to implement various features of the virtual table. Details on what each of these methods do are provided in the sequel.</source>
          <target state="translated">モジュール構造の残りの部分は、仮想テーブルの様々な機能を実装するために使用されるメソッドで構成されています。これらのメソッドが何をするのかについての詳細は、 続編で説明します。</target>
        </trans-unit>
        <trans-unit id="4c062c28bf53cd1153a7f659fc941fb25e4394ee" translate="yes" xml:space="preserve">
          <source>The result column names generated for compound subqueries have been simplified to show only the name of the column of the original table and omit the table name. This makes SQLite operate more like other SQL database engines.</source>
          <target state="translated">複合副問い合わせで生成される結果カラム名は、元のテーブルのカラム名のみを表示し、テーブル名を省略するように簡略化されました。これにより、SQLite は他の SQL データベースエンジンと同様に動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="8fba3a08c8f1c5c3b4c188d84f260675274f7bae" translate="yes" xml:space="preserve">
          <source>The result of &quot;(1,2,3)=(1,NULL,3)&quot; is NULL because the result might be true if we replaced NULL&amp;rarr;2 or false if we replaced NULL&amp;rarr;9. The result of &quot;(1,2,3)=(1,NULL,4)&quot; is not NULL because there is no substitutions of the constituent NULL that will make the expression true, since 3 will never equal 4 in the third column.</source>
          <target state="translated">&quot;（1,2,3）=（1、NULL、3）&quot;の結果はNULLです。これは、NULL&amp;rarr;2を置き換えた場合はtrue、NULL&amp;rarr;9を置き換えた場合はfalseになる可能性があるためです。「（1,2,3）=（1、NULL、4）」の結果はNULLではありません。これは、3番目の列で3が4に等しくなることはないため、式を真にする構成NULLの置換がないためです。</target>
        </trans-unit>
        <trans-unit id="8f8beef2187bafe894f67b36f4b351c6bf0083c2" translate="yes" xml:space="preserve">
          <source>The result of an IN or NOT IN operator is determined by the following matrix:</source>
          <target state="translated">INまたはNOT IN演算子の結果は、以下の行列で決定されます。</target>
        </trans-unit>
        <trans-unit id="61365ffa3c163a280c658c5edf1eb2a5c12ca346" translate="yes" xml:space="preserve">
          <source>The result of any binary operator is either a numeric value or NULL, except for the</source>
          <target state="translated">を除いて、任意のバイナリ演算子の結果は数値か NULL のいずれかです。</target>
        </trans-unit>
        <trans-unit id="efe84f22635d66f10495dd8d63c09814ab5f5a9a" translate="yes" xml:space="preserve">
          <source>The result of combining all input changesets together is obtained by the application via a call to sqlite3changegroup_output().</source>
          <target state="translated">すべての入力チェンジセットを結合した結果は、アプリケーションがsqlite3changegroup_output()を呼び出すことで得られます。</target>
        </trans-unit>
        <trans-unit id="bf374835b6b23f4254068862fbe80fd36859e25a" translate="yes" xml:space="preserve">
          <source>The result of opening a file is an instance of an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is an abstract base class defined as follows:</source>
          <target state="translated">ファイルを開いた結果は、&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトのインスタンスです。&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_fileを&lt;/a&gt;次のようにオブジェクトが定義された抽象基底クラスです。</target>
        </trans-unit>
        <trans-unit id="8384d1099fcb8eaa40cfc52c9ccfbf281fc795df" translate="yes" xml:space="preserve">
          <source>The result of the compound select is sent to the callback routine by the loop at instructions 22 through 25. There is nothing new or remarkable about this loop, except for the fact that the Column instruction at 23 will be extracting a column out of the record key rather than the record data.</source>
          <target state="translated">複合セレクトの結果は、命令22から25のループによってコールバック・ルーチンに送られます。このループについては、23番のColumn命令がレコードデータではなくレコードキーからカラムを抽出するという事実を除けば、何も目新しいことも注目すべきこともありません。</target>
        </trans-unit>
        <trans-unit id="a2285b0635d880f7a2485fe902caef319bce2b4f" translate="yes" xml:space="preserve">
          <source>The result of this last example should be every unique value of the &quot;two&quot; column in the examp table, except any value that is in the &quot;four&quot; column of examp2 is removed. The code to implement this query is as follows:</source>
          <target state="translated">この最後の例の結果は、examp2の &quot;4 &quot;列にある値を除いて、exampテーブルの &quot;2 &quot;列にあるすべての一意の値が削除されているはずです。このクエリを実装するコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ccf7a73ae578c847fadf3966512c178de5c0acda" translate="yes" xml:space="preserve">
          <source>The result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.</source>
          <target state="translated">total()の結果は常に浮動小数点値です。sum()の結果は、NULL 以外の入力がすべて整数の場合は整数値となります。sum()への入力が整数でも NULL でもない場合は、 sum()は浮動小数点値を返します。</target>
        </trans-unit>
        <trans-unit id="0a6fa042949920d8ab9a65592e82f3922c405d35" translate="yes" xml:space="preserve">
          <source>The resulting &quot;sqlite3.c&quot; amalgamation code file (and its associated header file &quot;sqlite3.h&quot;) can then be moved to a non-unix platform for final compilation using a native compiler.</source>
          <target state="translated">結果として得られた &quot;sqlite3.c &quot;アマルガムコードファイル(とそれに関連するヘッダファイル &quot;sqlite3.h&quot;)は、ネイティブコンパイラを使って最終的にコンパイルするためにunix以外のプラットフォームに移動することができます。</target>
        </trans-unit>
        <trans-unit id="e2d2e1926aa6ddaac2f60d9749f53fb11268ec2a" translate="yes" xml:space="preserve">
          <source>The results of a comparison depend on the storage classes of the operands, according to the following rules:</source>
          <target state="translated">比較の結果は、以下のルールに従って、オペランドのストレージ・クラスに依存します。</target>
        </trans-unit>
        <trans-unit id="32d9d0342a63956078e67d37802198109f0decfd" translate="yes" xml:space="preserve">
          <source>The results presented here come with the following caveats:</source>
          <target state="translated">ここで提示された結果には、以下のような注意点があります。</target>
        </trans-unit>
        <trans-unit id="a9310ef8309cce9fab8d7528f6f21efe5cbb34c7" translate="yes" xml:space="preserve">
          <source>The return value from sqlite3_soft_heap_limit64() is the size of the soft heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the soft heap limit. Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64() with a negative argument.</source>
          <target state="translated">sqlite3_soft_heap_limit64()の戻り値は、コール前のソフトヒープ制限のサイズ、エラーの場合は負の値です。引数Nが負の場合、ソフトヒープ制限は変更されません。したがって、現在のソフトヒープ制限のサイズは負の引数でsqlite3_soft_heap_limit64()を呼び出すことで決定することができます。</target>
        </trans-unit>
        <trans-unit id="b9ca53c6554299d5eae8ef584802645a6046ae33" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the indirect flag: 0 if it is clear, or 1 if it is set.</source>
          <target state="translated">戻り値は、間接フラグの最終的な状態を示します。</target>
        </trans-unit>
        <trans-unit id="7ce2179f1a4d84a59cb420b693cc86ea07338afc" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the session object: 0 if the session is disabled, or 1 if it is enabled.</source>
          <target state="translated">戻り値は、セッションオブジェクトの最終的な状態を示します。</target>
        </trans-unit>
        <trans-unit id="cae4bd57ed056db33a88f07df4b39cc7f3ccb51d" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface is determined by the compile-time threading mode selection. If single-thread mode is selected at compile-time, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns false. If either the multi-thread or serialized modes are selected, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns true. The &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface predates the multi-thread mode and start-time and run-time mode selection and so is unable to distinguish between multi-thread and serialized mode nor is it able to report start-time or run-time mode changes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;インターフェースの戻り値は、コンパイル時のスレッド化モードの選択によって決まります。コンパイル時にシングルスレッドモードが選択されている場合、&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;はfalseを返します。マルチスレッドモードまたはシリアル化モードのいずれかが選択されている場合、&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;はtrueを返します。&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;インターフェースは、起動時または実行時モードの変更を報告することができるマルチスレッドモードに先行し、開始時間および実行時モードの選択をので、マルチスレッドおよびシリアライズモードも区別することができません。</target>
        </trans-unit>
        <trans-unit id="39d80cd93bcac1fdb374e9a2b5c0dd95b400a1d6" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;b&gt;sqlite_open&lt;/b&gt; function is a pointer to an opaque &lt;b&gt;sqlite&lt;/b&gt; structure. This pointer will be the first argument to all subsequent SQLite function calls that deal with the same database. NULL is returned if the open fails for any reason.</source>
          <target state="translated">&lt;b&gt;sqlite_open&lt;/b&gt;関数の戻り値は、不透明な&lt;b&gt;sqlite&lt;/b&gt;構造体へのポインターです。このポインタは、同じデータベースを処理する後続のすべてのSQLite関数呼び出しの最初の引数になります。何らかの理由でオープンが失敗した場合は、NULLが返されます。</target>
        </trans-unit>
        <trans-unit id="6ab6c5924ac478fb10f4cbca37723d1a21ffdbb3" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">返された文字列ポインタは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;によって破棄されるまで、または特定の実行のために&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;への最初の呼び出しによってステートメントが自動的に再準備されるまで、またはsqlite3_column_name（）またはsqlite3_column_name16（）の次の呼び出しまで有効です同じ列。</target>
        </trans-unit>
        <trans-unit id="b378f46326a64f9ce7b892670372ed936b24e5cc" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">返された文字列ポインタは、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;によって破棄されるまで、または特定の実行のために&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;への最初の呼び出しによってステートメントが自動的に再準備されるまで、またはsqlite3_column_name（）またはsqlite3_column_name16（）の次の呼び出しまで有効です同じ列。</target>
        </trans-unit>
        <trans-unit id="bee83cce7953088554432a61ef6e85ee98f1b384" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. But the essence of the implementation is captured by the statement above: Separate indices are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="translated">上記の書き換えられた式は概念的なものです。ORを含むWHERE句は、実際にはこのように書き換えられません。OR句の実際の実装では、より効率的で、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルまたは「ROWID」にアクセスできないテーブルでも機能するメカニズムを使用します。ただし、実装の本質は上記のステートメントによって捕捉されます。各OR句の用語から候補の結果行を見つけるために個別のインデックスが使用され、最終結果はそれらの行の結合です。</target>
        </trans-unit>
        <trans-unit id="1bd2a272126ae7fe0bcc8e6d37c8017e55bcc2f1" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for *IN* operators. Note that</source>
          <target state="translated">その後、書き換えられた項は、*IN*演算子のための通常の規則を使用してインデックスを制約するために進むかもしれません。以下のことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d0930df338a07de9990756603662657ba4f08d89" translate="yes" xml:space="preserve">
          <source>The right-hand operand of an IN or NOT IN operator has no affinity if the operand is a list and has the same affinity as the affinity of the result set expression if the operand is a SELECT.</source>
          <target state="translated">INまたはNOT IN演算子の右辺のオペランドは、オペランドがリストの場合は親和性がなく、オペランドがSELECTの場合は結果集合式の親和性と同じ親和性を持っています。</target>
        </trans-unit>
        <trans-unit id="066626c86d12ae463e5bc63db194f29a635a8420" translate="yes" xml:space="preserve">
          <source>The right-hand side of the IN operator can now be a list of expressions instead of just a list of constants</source>
          <target state="translated">IN 演算子の右辺が、単なる定数のリストではなく式のリストになるようになりました。</target>
        </trans-unit>
        <trans-unit id="5c40f29b907e12e70ce95f7046453c736453580d" translate="yes" xml:space="preserve">
          <source>The right-hand side of the LIKE or GLOB must be either a string literal or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; bound to a string literal that does not begin with a wildcard character.</source>
          <target state="translated">LIKEまたはGLOBの右側は、文字列リテラルか、ワイルドカード文字で始まらない文字列リテラルにバインドされた&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターで&lt;/a&gt;なければなりません。</target>
        </trans-unit>
        <trans-unit id="b4246dd614eb68d70df4434b2497d819d23353bb" translate="yes" xml:space="preserve">
          <source>The right-hand table of the LEFT JOIN is not be used anywhere in the query outside of its own USING or ON clause.</source>
          <target state="translated">LEFT JOINの右辺のテーブルは、それ自身のUSING句またはON句以外では、クエリのどこにも使用されません。</target>
        </trans-unit>
        <trans-unit id="fc3dd2572b5bfa090299b30f5d81e58803cff0cb" translate="yes" xml:space="preserve">
          <source>The right-hand-side of the MATCH or = operator must be a constant expression that evaluates to a string consisting of the auxiliary function to invoke, followed by zero or more comma separated arguments within parenthesis. Arguments must be SQL literals. For example:</source>
          <target state="translated">MATCH または=演算子の右側には、呼び出す補助関数からなる文字列を評価する定数式と、括弧内のゼロ個以上のカンマ区切りの引数を指定する必要があります。引数はSQLリテラルでなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="60bf6a0aa9c141c91d3c15f81e63af1fbe6058ec" translate="yes" xml:space="preserve">
          <source>The right-most SELECT of the compound select must not make use of &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt; or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">複合選択の右端のSELECTでは、&lt;a href=&quot;lang_aggfunc&quot;&gt;集計&lt;/a&gt;&lt;a href=&quot;windowfunctions&quot;&gt;関数&lt;/a&gt;やウィンドウ関数を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="7b1ae3c5986255800fb2859410b2b4acb04d2122" translate="yes" xml:space="preserve">
          <source>The rollback journal contains a small header (shown in green in the diagram) that records the original size of the database file. So if a change causes the database file to grow, we will still know the original size of the database. The page number is stored together with each database page that is written into the rollback journal.</source>
          <target state="translated">ロールバックジャーナルには、データベースファイルの元のサイズを記録する小さなヘッダ(図では緑で示しています)が含まれています。そのため、変更によってデータベースファイルが大きくなっても、データベースの元のサイズを知ることができます。ページ番号は、ロールバックジャーナルに書き込まれた各データベースページと一緒に保存されます。</target>
        </trans-unit>
        <trans-unit id="1c053ab6c700ac534ac79f62078cfd2e255f73f2" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a master journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a master journal, then that master journal file exists.</source>
          <target state="translated">ロールバックジャーナルにマスタージャーナルファイルの名前が含まれていない（&lt;a href=&quot;#section_5_5&quot;&gt;セクション5.5を&lt;/a&gt;参照）か、マスタージャーナルの名前が含まれている場合は、そのマスタージャーナルファイルが存在します。</target>
        </trans-unit>
        <trans-unit id="6e312e9592f38c1d0abcf1823ca656ae6dc24729" translate="yes" xml:space="preserve">
          <source>The rollback journal exists.</source>
          <target state="translated">ロールバックジャーナルが存在します。</target>
        </trans-unit>
        <trans-unit id="a6a9ff12c8273f443fb56b2bd7d0ab6853333cef" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be deleted,</source>
          <target state="translated">ロールバックジャーナルファイルを削除することができます。</target>
        </trans-unit>
        <trans-unit id="841baedc01f54f9ab6f694a5b23bcc695e5f21f1" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be truncated to zero length, or</source>
          <target state="translated">ロールバック・ジャーナル・ファイルの長さをゼロに切り詰めることができます。</target>
        </trans-unit>
        <trans-unit id="31415ebe9f384149b021a50dd2fb2ee645763262" translate="yes" xml:space="preserve">
          <source>The rollback journal is</source>
          <target state="translated">ロールバックジャーナルは</target>
        </trans-unit>
        <trans-unit id="08afad671df0d2c575466e5f9fe1a518b69a6c6b" translate="yes" xml:space="preserve">
          <source>The rollback journal is a file associated with each SQLite database file that holds information used to restore the database file to its initial state during the course of a transaction. The rollback journal file is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-journal&lt;/code&gt;&quot; appended. There can only be a single rollback journal associated with a give database and hence there can only be one write transaction open against a single database at one time.</source>
          <target state="translated">ロールバックジャーナルは、トランザクションの過程でデータベースファイルを初期状態に復元するために使用される情報を保持する、各SQLiteデータベースファイルに関連付けられたファイルです。ロールバックジャーナルファイルは常にデータベースファイルと同じディレクトリにあり、データベースファイルと同じ名前ですが、文字列 &quot; &lt;code&gt;-journal&lt;/code&gt; &quot;が追加されています。特定のデータベースに関連付けられているロールバックジャーナルは1つだけなので、一度に1つのデータベースに対して開いている書き込みトランザクションは1つだけです。</target>
        </trans-unit>
        <trans-unit id="8a29cd2d15ece2c4c624bfe95a88741dea324ccf" translate="yes" xml:space="preserve">
          <source>The rollback journal is complete and intact on disk when the power is restored. This is a key point. The reason for the flush operation in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; is to make absolutely sure that all of the rollback journal is safely on nonvolatile storage prior to making any changes to the database file itself.</source>
          <target state="translated">電源が回復したとき、ロールバックジャーナルは完全であり、ディスク上にそのまま残ります。これがポイントです。&lt;a href=&quot;#section_3_7&quot;&gt;ステップ3.7で&lt;/a&gt;フラッシュ操作を行う理由は、データベースファイル自体に変更を加える前に、すべてのロールバックジャーナルが不揮発性ストレージに安全にあることを確実に確認するためです。</target>
        </trans-unit>
        <trans-unit id="5d1b7832cc643f77f52a69083206bb3b5fc3e74c" translate="yes" xml:space="preserve">
          <source>The rollback journal is not an empty file.</source>
          <target state="translated">ロールバックジャーナルは空のファイルではありません。</target>
        </trans-unit>
        <trans-unit id="194c559058723739212e12d7c3749019f8df5f55" translate="yes" xml:space="preserve">
          <source>The root page numbers of all tables in the database are integers stored in P4_INTARRAY argument.</source>
          <target state="translated">データベース内のすべてのテーブルのルートページ番号は、引数P4_INTARRAYに格納されている整数です。</target>
        </trans-unit>
        <trans-unit id="a973ad8403210b9b222fd26c2aef5b8f2808389c" translate="yes" xml:space="preserve">
          <source>The round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted, it is assumed to be 0.</source>
          <target state="translated">round(X,Y)関数は、浮動小数点の値Xを小数点以下のY桁に丸めて返します。Y引数を省略した場合は0とします。</target>
        </trans-unit>
        <trans-unit id="5fa12ab6f93c055083bc1a95b917e71f9cff725b" translate="yes" xml:space="preserve">
          <source>The routines &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; accept an SQL statement list (sql-stmt-list) which is a semicolon-separated list of statements.</source>
          <target state="translated">ルーチン&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;、&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;、&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;は、セミコロンで区切られたSQLステートメントリスト（sql-stmt-list）を受け入れます。</target>
        </trans-unit>
        <trans-unit id="94230b7f00353328063595629d48ef7be9fce389" translate="yes" xml:space="preserve">
          <source>The row-value notation is useful for updating two or more columns of a table from the result of a single query. An example of this is in the full-text search feature of the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;.</source>
          <target state="translated">行と値の表記は、単一のクエリの結果からテーブルの2つ以上の列を更新するのに役立ちます。この例は、&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossilバージョン管理システムの&lt;/a&gt;全文検索機能です。</target>
        </trans-unit>
        <trans-unit id="12b6af8126e4e3b962d71bf35b72e9a66ab6fcba" translate="yes" xml:space="preserve">
          <source>The row_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">各グループの最初のピアの row_number()-ギャップのある現在の行のランク。ORDER BY 節がない場合は、すべての行がピアとみなされ、この関数は常に 1 を返します。</target>
        </trans-unit>
        <trans-unit id="d3978e13ae998834400769bcf87213e9a57acdbe" translate="yes" xml:space="preserve">
          <source>The row_number() window function assigns consecutive integers to each row in order of the &quot;ORDER BY&quot; clause within the window-defn (in this case &quot;ORDER BY y&quot;). Note that this does not affect the order in which results are returned from the overall query. The order of the final output is still governed by the ORDER BY clause attached to the SELECT statement (in this case &quot;ORDER BY x&quot;).</source>
          <target state="translated">row_number()ウィンドウ関数は、ウィンドウ-defn 内の &quot;ORDER BY&quot; 節 (この場合は &quot;ORDER BY y&quot;)の順に各行に連続した整数を代入します。これは、クエリ全体から返される結果の順番には影響しないことに注意してください。最終的な出力の順序は、SELECT文に付随するORDER BY句(この場合は &quot;ORDER BY x&quot;)によって支配されます。</target>
        </trans-unit>
        <trans-unit id="97fcd9de22c4efb0eb648cf609eba1ee3fdf411d" translate="yes" xml:space="preserve">
          <source>The rowid (and &quot;oid&quot; and &quot;_rowid_&quot;) is omitted in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. WITHOUT ROWID tables are only available in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06) and later. A table that lacks the WITHOUT ROWID clause is called a &quot;rowid table&quot;.</source>
          <target state="translated">ROWID（および「oid」と「_rowid_」）は、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルでは省略されます。WITHOUT ROWIDテーブルは、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;バージョン3.8.2&lt;/a&gt;（2013-12-06）以降でのみ使用できます。WITHOUT ROWID句がないテーブルは、「ROWIDテーブル」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="a4a453c67097537d0d10c4b81190fd5d03a4b9dd" translate="yes" xml:space="preserve">
          <source>The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).</source>
          <target state="translated">rowid列は、without rowid仮想テーブルではアクセスできません(当然ですが)。</target>
        </trans-unit>
        <trans-unit id="101d05f0746854eb07065f446e80313cdc7692a7" translate="yes" xml:space="preserve">
          <source>The rowid of the document that contains the term instance.</source>
          <target state="translated">用語のインスタンスを含むドキュメントの rowid。</target>
        </trans-unit>
        <trans-unit id="21037157130833680d029f7ec56534a7a85bda67" translate="yes" xml:space="preserve">
          <source>The rowid of the row in the table being changed</source>
          <target state="translated">変更されるテーブルの行の rowid</target>
        </trans-unit>
        <trans-unit id="4967842a66478a8da76fb91a725d0ca4385c40a8" translate="yes" xml:space="preserve">
          <source>The rtreecheck() function performs the following checks:</source>
          <target state="translated">rtreecheck()関数は、以下のチェックを行います。</target>
        </trans-unit>
        <trans-unit id="93e10cfe1c883491ee9016750849300312683ba1" translate="yes" xml:space="preserve">
          <source>The rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X.</source>
          <target state="translated">rtrim(X,Y)関数は、Xの右辺からYに出現するすべての文字を削除した文字列を返します。 Yの引数が省略された場合、rtrim(X)はXの右辺からスペースを削除します。</target>
        </trans-unit>
        <trans-unit id="46ff031bad92aa35bcef2484317fc2661aa2d589" translate="yes" xml:space="preserve">
          <source>The rule above says that the letter &quot;a&quot; in user input can be matched against the letter &quot;&amp;auml;&quot; in the dictionary with a penalty of 5.</source>
          <target state="translated">上記のルールは、ユーザー入力の文字「a」はディクショナリの文字「&amp;auml;」とペナルティ5で一致する可能性があることを示しています。</target>
        </trans-unit>
        <trans-unit id="ed3a2c883d263a1e9abd7d6661fda464d09422b3" translate="yes" xml:space="preserve">
          <source>The rules for determining which collating function to use for a binary comparison operator (=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, !=, IS, and IS NOT) are as follows:</source>
          <target state="translated">バイナリ比較演算子（=、&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt; =、！=、IS、およびIS NOT）に使用する照合関数を決定するための規則は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="27705c6545cd7b92f01b98bd6ebfb1aa891406e9" translate="yes" xml:space="preserve">
          <source>The rules for when tables are analyzed are likely to change in future releases.</source>
          <target state="translated">テーブルが分析された場合のルールは、今後のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="819c15849a2758e415f2520702095eeff7ea13a5" translate="yes" xml:space="preserve">
          <source>The safest and easiest to remember policy is this: assume that any result from</source>
          <target state="translated">最も安全で覚えやすいポリシーはこれです。</target>
        </trans-unit>
        <trans-unit id="9bfc94ce3f6dbf06df6c899612d318253dda6014" translate="yes" xml:space="preserve">
          <source>The safest policy is to invoke these routines in one of the following ways:</source>
          <target state="translated">最も安全なポリシーは、以下のいずれかの方法でこれらのルーチンを呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="376b573ee029dd7d9463b27b130e605260069a93" translate="yes" xml:space="preserve">
          <source>The salt-1 and salt-2 values in the frame-header match salt values in the wal-header</source>
          <target state="translated">フレームヘッダの salt-1 と salt-2 の値は、ウォールヘッダの salt の値と一致します。</target>
        </trans-unit>
        <trans-unit id="b0647dc001e4e971c816ce4a73a18b5c698aa62d" translate="yes" xml:space="preserve">
          <source>The same SQL statement will fail on every other SQL implementation that we know of due to the use of keywords &quot;union&quot;, &quot;true&quot;, and &quot;with&quot; as identifiers.</source>
          <target state="translated">同じSQL文は、&quot;union&quot;、&quot;true&quot;、&quot;with &quot;というキーワードを識別子として使用しているため、私たちが知っている他のすべてのSQL実装で失敗します。</target>
        </trans-unit>
        <trans-unit id="67d39480596a16c7c11f0309e84be58f71d89746" translate="yes" xml:space="preserve">
          <source>The same basic B-Tree format is used but the details of the index keys were changed in order to provide better query optimization opportunities. Some of the headers were also changed in order to increase the maximum size of a row from 64KB to 24MB.</source>
          <target state="translated">基本的なB-Treeフォーマットは同じですが、クエリの最適化の機会を提供するためにインデックスキーの詳細が変更されました。また、行の最大サイズを64KBから24MBに増やすために、ヘッダの一部も変更されました。</target>
        </trans-unit>
        <trans-unit id="8827fbb3b64d8c27595464e7777bbb4e772df118" translate="yes" xml:space="preserve">
          <source>The same basic algorithm is followed, except this time the matching rows of the index are scanned from bottom to top instead of from top to bottom, so that the states will appear in descending order.</source>
          <target state="translated">基本的なアルゴリズムは同じですが、今回はインデックスの一致する行が上から下ではなく下から上にスキャンされるので、状態が降順に表示されます。</target>
        </trans-unit>
        <trans-unit id="8ef4bb6f50ee96f372f99fa9088d7b9c16950c07" translate="yes" xml:space="preserve">
          <source>The same core string formatter is also used internally by SQLite.</source>
          <target state="translated">同じコア文字列フォーマッタが SQLite の内部でも使用されています。</target>
        </trans-unit>
        <trans-unit id="c76359de67616f16a26e96d68504c135072ade53" translate="yes" xml:space="preserve">
          <source>The same database connection may now be used simultaneously by separate threads.</source>
          <target state="translated">同じデータベース接続を別々のスレッドで同時に使用することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="3bfa6cdc7cb80687d83044e6ab3337ab8d5595b5" translate="yes" xml:space="preserve">
          <source>The same indices are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="translated">両方の実装オプションでは、すべてのループを高速化するために同じインデックスが使用されます。これら2つのクエリプランの唯一の違いは、ループが入れ子になっている順序です。</target>
        </trans-unit>
        <trans-unit id="d1cd4608c87b02b3bc5ed6c81e7bb9ae9c4b8e13" translate="yes" xml:space="preserve">
          <source>The same technique ensures that an SQLite database file cannot be corrupted by a system failure that occurs at an inopportune moment. If a system failure does occur before SQLite has had a chance to execute sufficient</source>
          <target state="translated">同じ手法により、SQLite データベースファイルが不都合なタイミングで発生したシステム障害によって破損することはありません。SQLite が十分に</target>
        </trans-unit>
        <trans-unit id="40cbe38c06ce85b1c49ad0c8414f8f89ac5525ac" translate="yes" xml:space="preserve">
          <source>The same thing can be done with an enterprise client/server database, of course. The advantage of SQLite is that it is easier to install and use and the resulting database is a single file that can be written to a USB memory stick or emailed to a colleague.</source>
          <target state="translated">もちろん、エンタープライズ・クライアント/サーバー・データベースでも同じことができます。SQLiteの利点は、インストールと使用が簡単で、結果として得られるデータベースは1つのファイルで、USBメモリに書き込んだり、同僚に電子メールで送ったりすることができます。</target>
        </trans-unit>
        <trans-unit id="d9e7d4c0bf312ba2ed4d788d1d81806125454441" translate="yes" xml:space="preserve">
          <source>The scalar SQL function rtreecheck(R) or rtreecheck(S,R) runs an integrity check on the rtree table named R contained within database S. The function returns a human-language description of any problems found, or the string 'ok' if everything is ok. Running rtreecheck() on an R*Tree virtual table is similar to running &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on a database.</source>
          <target state="translated">スカラーSQL関数rtreecheck（R）またはrtreecheck（S、R）は、データベースSに含まれているRという名前のrtreeテーブルに対して整合性チェックを実行します。この関数は、見つかった問題の人間言語の説明を返します。全て大丈夫。 R * Tree仮想テーブルでrtreecheck（）を実行する&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;こと&lt;/a&gt;は、データベースでPRAGMA integer_checkを実行することに似ています。</target>
        </trans-unit>
        <trans-unit id="181bcf0e796a132dd22a68144a4e494726dfbf32" translate="yes" xml:space="preserve">
          <source>The scenario above sounds far-fetched. But the SQLite developers are aware of at least one commercial product that was released with exactly this bug. The vendor came to the SQLite developers seeking help in tracking down some infrequent database corruption issues they were seeing on Linux and Mac. The problem was eventually traced to the fact that the application was linking against two separate copies of SQLite. The solution was to change the application build procedures to link against just one copy of SQLite instead of two.</source>
          <target state="translated">上記のシナリオは、あまりにも現実離れしたものに聞こえます。しかし、SQLite の開発者は、少なくとも一つの商用製品がまさにこのバグを持ってリリースされたことを知っています。そのベンダーはSQLiteの開発者に、LinuxやMacで頻繁に見られるデータベース破損の問題を解決するために助けを求めてきました。この問題は最終的に、アプリケーションがSQLiteの2つの別々のコピーに対してリンクしているという事実にたどり着きました。解決策は、アプリケーションのビルドプロシージャを変更して、SQLiteのコピーを2つではなく1つだけにリンクするようにしました。</target>
        </trans-unit>
        <trans-unit id="7cf33abd12fd2e97d31a441b54d245ec800fc490" translate="yes" xml:space="preserve">
          <source>The schema above defines a directed graph with the ability to store a name at each node. Now consider a query against this schema:</source>
          <target state="translated">上のスキーマは、各ノードに名前を格納する機能を持つ有向グラフを定義しています。では、このスキーマに対するクエリを考えてみましょう。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
