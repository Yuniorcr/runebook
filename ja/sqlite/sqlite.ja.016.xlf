<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="d37b6e6570fc572ab09d9f50bc38138c9b41b0ec" translate="yes" xml:space="preserve">
          <source>The schema cookie is a 4-byte big-endian integer at offset 40 that is incremented whenever the database schema changes. A prepared statement is compiled against a specific version of the database schema. When the database schema changes, the statement must be reprepared. When a prepared statement runs, it first checks the schema cookie to ensure the value is the same as when the statement was prepared and if the schema cookie has changed, the statement either automatically reprepares and reruns or it aborts with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">スキーマCookieはオフセット40の4バイトのビッグエンディアン整数で、データベーススキーマが変更されるたびに増分されます。準備されたステートメントは、データベーススキーマの特定のバージョンに対してコンパイルされます。データベーススキーマが変更されると、ステートメントを再準備する必要があります。準備されたステートメントが実行されると、最初にスキーマCookieをチェックして、値がステートメントが準備されたときと同じであることを確認します。スキーマCookieが変更された場合、ステートメントは自動的に再準備および再実行されるか、&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;エラーで中止されます。</target>
        </trans-unit>
        <trans-unit id="1ab0e540f94c93f90585f3869aa649d5881cec37" translate="yes" xml:space="preserve">
          <source>The schema cookie.</source>
          <target state="translated">スキーマクッキー。</target>
        </trans-unit>
        <trans-unit id="4488aa59b7580b3c4da5952eb56f99b2cde228a2" translate="yes" xml:space="preserve">
          <source>The schema depicted above is not designed to store the full-text index directly. Instead, it is used to store one or more b-tree structures. There is one b-tree for each row in the %_segdir table. The %_segdir table row contains the root node and various meta-data associated with the b-tree structure, and the %_segments table contains all other (non-root) b-tree nodes. Each b-tree is referred to as a &quot;segment&quot;. Once it has been created, a segment b-tree is never updated (although it may be deleted altogether).</source>
          <target state="translated">上に描かれているスキーマは、全文インデックスを直接格納するようには設計されていません。代わりに、1 つ以上の b-tree 構造を格納するために使用されます。segdir テーブルの各行には 1 つの b-tree があります。segdir テーブルの行には、ルート・ノードと b-tree 構造に関連付けられたさまざまなメタデータが格納され、%_segments テーブルには、他の (ルートではない)すべての b-tree ノードが格納されます。各 b-tree は &quot;セグメント&quot; と呼ばれます。一度作成されたセグメント b-tree は更新されません (完全に削除されることはありますが)。</target>
        </trans-unit>
        <trans-unit id="0fd02dc53052cb07a4282595789654910705302c" translate="yes" xml:space="preserve">
          <source>The schema for the dbstat virtual table is this:</source>
          <target state="translated">dbstat仮想テーブルのスキーマは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2252a25e95423355b1edc92e550e314acf60ad89" translate="yes" xml:space="preserve">
          <source>The schema for the table returned by json_each() and json_tree() is as follows:</source>
          <target state="translated">json_each()とjson_tree()が返すテーブルのスキーマは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7f20e4cd592c03cab97adad3d2182916294f862d" translate="yes" xml:space="preserve">
          <source>The schema format number for a new database can be set at runtime using the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; command.</source>
          <target state="translated">新しいデータベースのスキーマ形式番号は、&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt;コマンドを使用して実行時に設定できます。</target>
        </trans-unit>
        <trans-unit id="933a80ece41d7c4fe3169e373964e2826ef1d8f7" translate="yes" xml:space="preserve">
          <source>The schema format number is a 4-byte big-endian integer at offset 44. The schema format number is similar to the file format read and write version numbers at offsets 18 and 19 except that the schema format number refers to the high-level SQL formatting rather than the low-level b-tree formatting. Four schema format numbers are currently defined:</source>
          <target state="translated">スキーマフォーマット番号はオフセット44の4バイトのビッグエンディアン整数です。スキーマフォーマット番号は、スキーマフォーマット番号が低レベルのb-treeフォーマットではなく、高レベルのSQLフォーマットを参照することを除いては、オフセット18と19のファイルフォーマットの読み書きバージョン番号と似ています。現在、4つのスキーマフォーマット番号が定義されています。</target>
        </trans-unit>
        <trans-unit id="62a7a887a20a821d1b69e9b449caf90b4200d958" translate="yes" xml:space="preserve">
          <source>The schema format number. Supported schema formats are 1, 2, 3, and 4.</source>
          <target state="translated">スキーマフォーマット番号。サポートされるスキーマフォーマットは 1、2、3、および 4 です。</target>
        </trans-unit>
        <trans-unit id="c07d56a869023707575ade10738a217ecfcee4af" translate="yes" xml:space="preserve">
          <source>The schema of an SQL database is able to represent information more directly and succinctly than a key/value database such as a ZIP archive. This makes the document content more accessible to third-party applications and scripts and facilitates advanced features such as built-in document versioning, and incremental saving of work in progress for recovery after a crash.</source>
          <target state="translated">SQL データベースのスキーマは、ZIP アーカイブのようなキー/値データベースよりも、情報をより直接的かつ簡潔に表現することができます。これにより、サードパーティ製のアプリケーションやスクリプトからドキュメントの内容にアクセスしやすくなり、ビルトインドキュメントのバージョン管理や、クラッシュ後のリカバリのための進行中の作業の増分保存などの高度な機能が容易になります。</target>
        </trans-unit>
        <trans-unit id="87cc88d5b4a5e95bb023c0790cc28378b9e2bd05" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will to get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">schema_versionプラグマは、&lt;a href=&quot;fileformat2#database_header&quot;&gt;データベースヘッダーの&lt;/a&gt;オフセット40にあるschema-version整数の値を取得または設定します。</target>
        </trans-unit>
        <trans-unit id="077341a10c528ac1588a1408b9034c9f8021b705" translate="yes" xml:space="preserve">
          <source>The scheme of the URI must be &quot;&lt;code&gt;file:&lt;/code&gt;&quot;. Any other scheme results in the input being treated as an ordinary filename.</source>
          <target state="translated">URIのスキームは &quot; &lt;code&gt;file:&lt;/code&gt; &quot;でなければなりません。他のスキームでは、入力は通常のファイル名として扱われます。</target>
        </trans-unit>
        <trans-unit id="08d91918dffee8fc87a94df6946790f6caab8817" translate="yes" xml:space="preserve">
          <source>The score is a combination of rank and distance. The idea is that a lower score is better. The virtual table attempts to find words with the lowest score and by default (unless overridden by ORDER BY) returns results in order of increasing score.</source>
          <target state="translated">スコアはランクと距離の組み合わせです。スコアが低いほど良いという考え方です。仮想テーブルは、スコアが最も低い単語を見つけようとし、デフォルトでは (ORDER BY で上書きされない限り)スコアの高い順に結果を返します。</target>
        </trans-unit>
        <trans-unit id="61fd3b441b127465c680d5c3514e6d464720698f" translate="yes" xml:space="preserve">
          <source>The script compiles the TH3 test harness into machine code (&quot;th3.o&quot;) if necessary.</source>
          <target state="translated">スクリプトは必要に応じてTH3テストハーネスをマシンコード(&quot;th3.o&quot;)にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="9f405708716b43bff0ad67cd4c7d9fb92e6afc28" translate="yes" xml:space="preserve">
          <source>The script compiles the sqlite3.c source file into assembly language (&quot;sqlite3.s&quot;) if necessary.</source>
          <target state="translated">スクリプトは必要に応じてsqlite3.cのソースファイルをアセンブリ言語(&quot;sqlite3.s&quot;)にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="9bf1fc92f793f60b433b7ebac87847be7a48eb60" translate="yes" xml:space="preserve">
          <source>The script loops through instructions in the assembly language file to locate branch operations.</source>
          <target state="translated">スクリプトは、アセンブリ言語ファイル内の命令をループして分岐操作を見つけます。</target>
        </trans-unit>
        <trans-unit id="576c62795ba33247bec0c331da3dd87f14e7a748" translate="yes" xml:space="preserve">
          <source>The script makes a copy of the original sqlite3.s file.</source>
          <target state="translated">スクリプトは元のsqlite3.sファイルのコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="fbefc60f4848710280b3f195980be93ae6fb0731" translate="yes" xml:space="preserve">
          <source>The script shows progress for each cycle of the previous step then displays a summary of &quot;survivors&quot; at the end. A &quot;survivor&quot; is a mutation that was not detected by TH3.</source>
          <target state="translated">スクリプトは前のステップの各サイクルの進行状況を表示し、最後に「生存者」のサマリーを表示します。サバイバー」とは、TH3で検出されなかった突然変異のことです。</target>
        </trans-unit>
        <trans-unit id="4a731425cd1bb86844c78ad068a724419eca7459" translate="yes" xml:space="preserve">
          <source>The search for these strings in the type declaration is case insensitive, of course. If any of the above strings occur anywhere in the type declaration, then the datatype of the column is text. Notice that the type &quot;VARCHAR&quot; contains &quot;CHAR&quot; as a substring so it is considered text.</source>
          <target state="translated">型宣言におけるこれらの文字列の検索は、もちろん大文字小文字を区別しません。もし上記の文字列が型宣言のどこかにあった場合、そのカラムのデータ型はtextとなります。VARCHAR &quot;型には部分文字列として &quot;CHAR &quot;が含まれているので、テキストとみなされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="201735a6137bd8c721345300624cc86e3645ba64" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; instruction begins a transaction and starts a rollback journal for database 1, the database used for temporary tables.</source>
          <target state="translated">2番目の&lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt;命令はトランザクションを開始し、一時テーブルに使用されるデータベース1のロールバックジャーナルを開始します。</target>
        </trans-unit>
        <trans-unit id="541464126fdf47682a89498dd2c1f59037e5c50b" translate="yes" xml:space="preserve">
          <source>The second SELECT is implemented by instructions 14 through 19. Instruction 14 initializes the loop by rewinding its cursor. A new result row is created from the &quot;four&quot; column of table &quot;examp2&quot; by instructions 15 and 16. But instead of using PutStrKey to write this new row into the temporary table, we instead call Delete to remove it from the temporary table if it exists.</source>
          <target state="translated">第2のSELECTは、命令14〜19によって実装される。命令14は、カーソルを巻き戻すことによりループを初期化する。命令15と16によって、テーブル &quot;examp2 &quot;の &quot;4 &quot;列から新しい結果行が作成される。しかし、この新しい行を一時テーブルに書き込むためにPutStrKeyを使用する代わりに、一時テーブルが存在する場合にはDeleteを呼び出して一時テーブルから削除します。</target>
        </trans-unit>
        <trans-unit id="b382925f3a88c50c566963d5ae8b2f2a69bce488" translate="yes" xml:space="preserve">
          <source>The second advantage the SQLite printf routines have over &lt;b&gt;sprintf&lt;/b&gt; are two new formatting options specifically designed to support string literals in SQL. Within the format string, the %q formatting option works very much like %s in that it reads a null-terminated string from the argument list and inserts it into the result. But %q translates the inserted string by making two copies of every single-quote (') character in the substituted string. This has the effect of escaping the end-of-string meaning of single-quote within a string literal. The %Q formatting option works similar; it translates the single-quotes like %q and additionally encloses the resulting string in single-quotes. If the argument for the %Q formatting options is a NULL pointer, the resulting string is NULL without single quotes.</source>
          <target state="translated">SQLiteのprintfルーチンが&lt;b&gt;sprintfより&lt;/b&gt;も優れている2番目の利点は、SQLで文字列リテラルをサポートするように特別に設計された2つの新しいフォーマットオプションです。フォーマット文字列内で、％qフォーマットオプションは、引数リストからnullで終了する文字列を読み取り、結果に挿入するという点で、％sと非常によく似ています。ただし、％qは、置換された文字列内のすべての単一引用符（ '）文字の2つのコピーを作成することにより、挿入された文字列を変換します。これは、文字列リテラル内の単一引用符の文字列の終わりの意味をエスケープする効果があります。 ％Qフォーマットオプションは同様に機能します。 ％qのように単一引用符を変換し、さらに結果の文字列を単一引用符で囲みます。 ％Q書式設定オプションの引数がNULLポインターの場合、結果の文字列は単一引用符なしのNULLです。</target>
        </trans-unit>
        <trans-unit id="24bd2add8c4054117cbe09f659537f282404edb5" translate="yes" xml:space="preserve">
          <source>The second and all subsequent 32768-byte units of the shm file are like this:</source>
          <target state="translated">shmファイルの2つ目以降の32768バイト単位はこのようになります。</target>
        </trans-unit>
        <trans-unit id="2f88dda8423c5371c7ad74eb85809481a6d1addf" translate="yes" xml:space="preserve">
          <source>The second and third forms return the computed edit distance between strings 'string1' and &quot;string2'. In the second form, a language id of 0 is used. The language id is specified in the third form.</source>
          <target state="translated">2番目と3番目の形式は、文字列'string1'と'string2'の間の計算された編集距離を返します。2番目の形式では、0の言語IDが使用される。第3の形式では言語IDが指定される。</target>
        </trans-unit>
        <trans-unit id="a3a47f0193da66fdda72484a51d350d2076b5681" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes is not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">2 番目の引数 (xFilter)は、&quot;フィルタのコールバック&quot; です。Session オブジェクトにアタッチされていないテーブルの行への変更に対して、テーブルの行への変更を追跡すべきかどうかを決定するためにフィルタが呼び出されます。xFilter が 0 を返した場合、変更は追跡されません。一度テーブルがアタッチされると、xFilter は二度と呼ばれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="718f90fed591046439ad14f60ea06810377e7e83" translate="yes" xml:space="preserve">
          <source>The second argument indicates the reason that FTS5 is requesting tokenization of the supplied text. This is always one of the following four values:</source>
          <target state="translated">第2引数は、FTS5が供給されたテキストのトークン化を要求している理由を示す。これは常に以下の4つの値のうちの1つです。</target>
        </trans-unit>
        <trans-unit id="1b37e9b1846948d626696aade4d54493fddd03d8" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">2番目の引数は、ROWIDテーブルで行が更新、挿入、または削除されたときに呼び出す関数へのポインターです。コールバックの最初の引数は、sqlite3_update_hook（）の3番目の引数のコピーです。 2番目のコールバック引数は、コールバックが呼び出される原因となった操作に応じて、&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかです。コールバックの3番目と4番目の引数には、影響を受ける行を含むデータベースとテーブル名へのポインターが含まれます。最後のコールバックパラメータは、行の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。更新の場合、これは更新が行われた後の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f6eef977cb1db09c38e32ceda39f74ec952be8d2" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">2番目の引数は、ROWIDテーブルで行が更新、挿入、または削除されたときに呼び出す関数へのポインターです。コールバックの最初の引数は、sqlite3_update_hook（）の3番目の引数のコピーです。 2番目のコールバック引数は、コールバックが呼び出される原因となった操作に応じて、&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;、または&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかです。コールバックの3番目と4番目の引数には、影響を受ける行を含むデータベースとテーブル名へのポインターが含まれます。最後のコールバックパラメータは、行の&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。更新の場合、これは更新が行われた後の&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d4e308f3aa98b17590b5e994747b662ab58b2433" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">2番目の引数は、設定するSQLパラメータのインデックスです。左端のSQLパラメーターのインデックスは1です。同じ名前のSQLパラメーターが2回以上使用される場合、2番目以降のオカレンスには最初のオカレンスと同じインデックスが付けられます。名前付きパラメーターのインデックスは、必要に応じて&lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API を使用して検索できます。 「？NNN」パラメーターのインデックスは、NNNの値です。 NNN値は、1と&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;パラメータ&lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBERの&lt;/a&gt;間でなければなりません（デフォルト値：999）。</target>
        </trans-unit>
        <trans-unit id="a3f014790ea15d84ae5efd1a40e8d6440e64de4e" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">2番目の引数は、設定するSQLパラメータのインデックスです。左端のSQLパラメーターのインデックスは1です。同じ名前のSQLパラメーターが2回以上使用される場合、2番目以降のオカレンスには最初のオカレンスと同じインデックスが付けられます。名前付きパラメーターのインデックスは、必要に応じて&lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API を使用して検索できます。 「？NNN」パラメーターのインデックスは、NNNの値です。 NNN値は、1と&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;パラメータ&lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBERの&lt;/a&gt;間でなければなりません（デフォルト値：999）。</target>
        </trans-unit>
        <trans-unit id="2fb1bff691f79072fe4cf1aa2d31d1bd3832725a" translate="yes" xml:space="preserve">
          <source>The second argument passed to the xToken() callback (&quot;tflags&quot;) should normally be set to 0. The exception is if the tokenizer supports synonyms. In this case see the discussion below for details.</source>
          <target state="translated">xToken()コールバックに渡される第二引数 (&quot;tflags&quot;)には通常 0 を設定しなければなりません。 トークン化ツールが同義語をサポートしている場合は例外となります。この場合の詳細は以下の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca943db57529952ad5f76d4c9a47b52221a6d6e3" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config（D、V、...）の2番目の引数は、&lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;構成動詞です&lt;/a&gt; - &lt;a href=&quot;#sqlite3&quot;&gt;データベース接続の&lt;/a&gt;どの側面が構成されているかを示す整数コードです。後続の引数は、構成動詞によって異なります。</target>
        </trans-unit>
        <trans-unit id="a7845e3bb7f88361055af36d05adde4b952592f9" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config（D、V、...）の2番目の引数は、&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;構成動詞です&lt;/a&gt; - &lt;a href=&quot;sqlite3&quot;&gt;データベース接続の&lt;/a&gt;どの側面が構成されているかを示す整数コードです。後続の引数は、構成動詞によって異なります。</target>
        </trans-unit>
        <trans-unit id="7ca88f23336b34513d2d790b7c87ef9c5d8d0e67" translate="yes" xml:space="preserve">
          <source>The second argument to the error logger callback is an integer &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;. The third argument to the error logger is the text of the error message. The error message text is stored in a fixed-length stack buffer in the calling function and so will only be valid for the duration of the error logger callback function. The error logger should make a copy of this message into persistent storage if retention of the message is needed.</source>
          <target state="translated">エラーロガーコールバックの2番目の引数は、整数の&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;です。エラーロガーの3番目の引数は、エラーメッセージのテキストです。エラーメッセージテキストは、呼び出し元の関数の固定長スタックバッファーに格納されるため、エラーロガーコールバック関数の実行中のみ有効です。メッセージの保持が必要な場合、エラーロガーはこのメッセージのコピーを永続ストレージに作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="a2a47b21d6064e4d10a2f6d6161c0f1dce1664a1" translate="yes" xml:space="preserve">
          <source>The second argument, &quot;zSql&quot;, is the statement to be compiled, encoded as either UTF-8 or UTF-16. The sqlite3_prepare(), sqlite3_prepare_v2(), and sqlite3_prepare_v3() interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() use UTF-16.</source>
          <target state="translated">2番目の引数である &quot;zSql &quot;は、コンパイルされる文で、UTF-8またはUTF-16でエンコードされています。sqlite3_prepare()、sqlite3_prepare_v2()、およびsqlite3_prepare_v3()インタフェースはUTF-8を使用し、sqlite3_prepare16()、sqlite3_prepare16_v2()、およびsqlite3_prepare16_v3()インタフェースはUTF-16を使用します。</target>
        </trans-unit>
        <trans-unit id="f2e250c2ef383dec7dc31067a07b23d0da95c91b" translate="yes" xml:space="preserve">
          <source>The second beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0の第2回目のベータリリース。</target>
        </trans-unit>
        <trans-unit id="771287a1de97a728b2134cd9c420c1c39a0f52c6" translate="yes" xml:space="preserve">
          <source>The second column is the name of the table.</source>
          <target state="translated">2列目はテーブルの名前です。</target>
        </trans-unit>
        <trans-unit id="68511a08109abd7af5a81fce815eeb4f023584c9" translate="yes" xml:space="preserve">
          <source>The second form changes the journaling mode for &quot;</source>
          <target state="translated">第2のフォームでは、&quot;の仕訳モードを変更します。</target>
        </trans-unit>
        <trans-unit id="2f272c30ebac8ce92b2f903964b40a07bad463d7" translate="yes" xml:space="preserve">
          <source>The second form of the INSERT statement contains a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement instead of a VALUES clause. A new entry is inserted into the table for each row of data returned by executing the SELECT statement. If a column-list is specified, the number of columns in the result of the SELECT must be the same as the number of items in the column-list. Otherwise, if no column-list is specified, the number of columns in the result of the SELECT must be the same as the number of columns in the table. Any SELECT statement, including &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECTs&lt;/a&gt; and SELECT statements with &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and/or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses, may be used in an INSERT statement of this form.</source>
          <target state="translated">INSERTステートメントの2番目の形式には、VALUES句の代わりに&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントが含まれています。 SELECTステートメントを実行して返されたデータの各行について、新しいエントリがテーブルに挿入されます。 column-listが指定されている場合、SELECTの結果の列の数は、column-listの項目の数と同じでなければなりません。それ以外の場合、column-listが指定されていなければ、SELECTの結果の列の数は、テーブルの列の数と同じでなければなりません。この形式のINSERTステートメントでは、&lt;a href=&quot;lang_select#compound&quot;&gt;複合SELECT&lt;/a&gt;および&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;句や&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;句（あるいはその両方）を含むSELECTステートメントを含む、すべてのSELECTステートメントを使用できます。</target>
        </trans-unit>
        <trans-unit id="ec9aa9593798c759bbdf9a6cf2b73541eab87efe" translate="yes" xml:space="preserve">
          <source>The second form of the command is this:</source>
          <target state="translated">コマンドの第二形態はこれです。</target>
        </trans-unit>
        <trans-unit id="fa9b557c755fe5c619c7e5fc0af0adff81ce48ad" translate="yes" xml:space="preserve">
          <source>The second form of the pragma listed above is used to set a new limit in bytes for the specified database. A negative number implies no limit. To always truncate rollback journals and WAL files to their minimum size, set the journal_size_limit to zero. Both the first and second forms of the pragma listed above return a single result row containing a single integer column - the value of the journal size limit in bytes. The default journal size limit is -1 (no limit). The &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; preprocessor macro can be used to change the default journal size limit at compile-time.</source>
          <target state="translated">上記のプラグマの2番目の形式は、指定されたデータベースの新しい制限をバイト単位で設定するために使用されます。負の数は制限がないことを意味します。ロールバックジャーナルとWALファイルを常に最小サイズに切り捨てるには、journal_size_limitをゼロに設定します。上記のプラグマの最初の形式と2番目の形式の両方で、単一の整数列（バイト単位のジャーナルサイズ制限の値）を含む単一の結果行が返されます。デフォルトのジャーナルサイズ制限は-1（制限なし）です。&lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMITの&lt;/a&gt;プリプロセッサマクロはコンパイル時にデフォルトのジャーナルのサイズ制限を変更するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="4008980ca9a9274111928748bc06de4b907efa68" translate="yes" xml:space="preserve">
          <source>The second integer, if it is present, is the aggregate size of all data stored on leaf pages in bytes. If the value is negative, then the segment is the output of an unfinished incremental-merge operation, and the absolute value is current size in bytes.</source>
          <target state="translated">2 番目の整数が存在する場合は、リーフページに格納されているすべてのデータの総和サイズをバイト単位で表します。値が負の場合、そのセグメントは未完了のインクリメンタルマージ操作の出力であり、絶対値は現在のサイズをバイト単位で表します。</target>
        </trans-unit>
        <trans-unit id="211c21970b7cdeb91101e574bc29708c2cdfae64" translate="yes" xml:space="preserve">
          <source>The second line above creates a virtual table named &quot;t1&quot; that reads the content of the file named in the argument. The number and names of the columns is determined automatically by reading the first line of content. Other options to the CSV virtual table provide the ability to take the CSV content from a string rather than a separate file, and give the programmer more control over the number and names of the columns. The options are detailed below. The CSV virtual table is usually created as a TEMP table so that it exists only for the current database connection and does not become a permanent part of the database schema. Note that there is no &quot;CREATE TEMP VIRTUAL TABLE&quot; command in SQLite. Instead, prepend the &quot;temp.&quot; schema prefix to the name of the virtual table.</source>
          <target state="translated">上の2行目では、引数で指定したファイルの内容を読み込む「t1」という名前の仮想テーブルを作成しています。列の数と名前は、1行目の内容を読み込むことで自動的に決定されます。CSV仮想テーブルの他のオプションでは、CSVの内容を別のファイルではなく文字列から読み込むことができ、列の数と名前をより制御できるようになります。オプションの詳細は以下の通りです。CSV仮想テーブルは通常TEMPテーブルとして作成され、現在のデータベース接続のためだけに存在し、データベーススキーマの恒久的な部分にはなりません。SQLiteには「CREATE TEMP VIRTUAL TABLE」コマンドはないことに注意してください。代わりに、仮想テーブルの名前の前に &quot;temp.&quot; スキーマ接頭辞を付加します。</target>
        </trans-unit>
        <trans-unit id="c3933495d9788c26f88ba69fbabb317f1e83064e" translate="yes" xml:space="preserve">
          <source>The second line of the file contains 211792 characters of impenetrable XML. Yes, 211792 characters all on one line. This file is a good stress-test for a text editor. Thankfully, the file is not some obscure binary format, but in terms of accessibility, it might as well be written in Klingon.</source>
          <target state="translated">ファイルの2行目には211792文字の不可解なXMLが含まれています。そう、1行に211792文字が全部入っているのです。このファイルはテキストエディタのストレステストに最適です。ありがたいことに、このファイルは曖昧なバイナリ形式ではありませんが、アクセシビリティの観点からは、クリンゴン語で書かれているのと同じかもしれません。</target>
        </trans-unit>
        <trans-unit id="5c1d27adf7a874de9fb599be39fb1d27d63c3092" translate="yes" xml:space="preserve">
          <source>The second number Y is incremented for any change that breaks forward compatibility by adding new features. Most future SQLite releases are expected to increment the second number Y. The Z is reset to zero whenever Y is increased.</source>
          <target state="translated">2 番目の数字 Y は、新しい機能を追加することで前方互換性を壊すような変更があった場合にインクリメントされます。ほとんどの将来の SQLite リリースでは、2 番目の数字 Y がインクリメントされることが予想されます。</target>
        </trans-unit>
        <trans-unit id="50b9dd44fd65466aa651f4fce7056da00ed7e13a" translate="yes" xml:space="preserve">
          <source>The second parameter (argc) and the fourth parameter (columnNames) are still valid and can be used to determine the number and names of the result columns if there had been a result. The default behavior is not to invoke the callback at all if the result set is empty.</source>
          <target state="translated">2 番目のパラメータ (argc)と 4 番目のパラメータ (columnNames)はまだ有効で、結果があった場合に結果のカラムの数と名前を決定するために使用できます。デフォルトでは、結果セットが空の場合はコールバックを呼び出さないようになっています。</target>
        </trans-unit>
        <trans-unit id="682054ab4ce2cb4dfe2528dcad7556d5d406ca5f" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">2番目のパラメーターは、作成または再定義するSQL関数の名前です。名前の長さは、ゼロ終端文字を除いて、UTF-8表現で255バイトに制限されています。名前の長さの制限はUTF-8バイトであり、文字やUTF-16バイトではないことに注意してください。これより長い名前の関数を作成しようとすると、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="266b83f6439ab5e88dcd3928741ef542cdbb6626" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">2番目のパラメーターは、作成または再定義するSQL関数の名前です。名前の長さは、ゼロ終端文字を除いて、UTF-8表現で255バイトに制限されています。名前の長さの制限はUTF-8バイトであり、文字やUTF-16バイトではないことに注意してください。これより長い名前の関数を作成しようとすると、&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="560b989b803d6b51bde79f3db2c1500c44cc5751" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">preupdateコールバックの2番目のパラメーターは、preupdateフックを登録した&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;へのポインターです。 preupdateコールバックの3番目のパラメーターは、発生する更新操作の種類を識別するための定数&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかです。 preupdateコールバックの4番目のパラメーターは、変更中のデータベース接続内のデータベースの名前です。これは、メインデータベースの場合は「main」、TEMPテーブルの場合は「temp」、または接続されたデータベースの&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントのASキーワードの後に​​指定された名前になります。 preupdateコールバックの5番目のパラメーターは、変更されるテーブルの名前です。</target>
        </trans-unit>
        <trans-unit id="097d5db1a651bbf810ec3be53362ed0414cfc3f9" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">preupdateコールバックの2番目のパラメーターは、preupdateフックを登録した&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;へのポインターです。 preupdateコールバックの3番目のパラメーターは、発生する更新操作の種類を識別するための定数&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;、または&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかです。 preupdateコールバックの4番目のパラメーターは、変更中のデータベース接続内のデータベースの名前です。これは、メインデータベースの場合は「main」、TEMPテーブルの場合は「temp」、または接続されたデータベースの&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントのASキーワードの後に​​指定された名前になります。 preupdateコールバックの5番目のパラメーターは、変更されるテーブルの名前です。</target>
        </trans-unit>
        <trans-unit id="f5ad56c8e6b709d2294efc15c0b9ac27fea8d776" translate="yes" xml:space="preserve">
          <source>The second step finds the four shortest paths to visit two nodes beginning with one of the four paths from the previous step. In the case where two or more paths are equivalent (they have the same set of visited nodes, though possibly in a different order) only the first and lowest-cost path is retained. We have:</source>
          <target state="translated">第2ステップでは,前のステップで得られた4つのパスのうちの1つから始まる2つのノードを訪問するための4つの最短パスを見つけます.2つ以上のパスが同等の場合(訪問するノードのセットが同じであるが,順序は異なる可能性がある),最初のパスと最もコストの低いパスのみが保持されます.以下のようになります。</target>
        </trans-unit>
        <trans-unit id="73fbb8fcf9b3b6fa8277785714e82cfa142507c2" translate="yes" xml:space="preserve">
          <source>The second through fifth forms of this pragma set the encoding that the main database will be created with if it is created by this session. The string 'UTF-16' is interpreted as &quot;UTF-16 encoding using native machine byte-ordering&quot;. It is not possible to change the text encoding of a database after it has been created and any attempt to do so will be silently ignored.</source>
          <target state="translated">このプラグマの2番目から5番目の形式は、このセッションによってメインデータベースが作成された場合に、メインデータベースが作成されるエンコーディングを設定します。文字列 'UTF-16' は「ネイティブマシンのバイトオーダーを使用した UTF-16 エンコーディング」と解釈されます。データベースが作成された後で、データベースのテキストエンコーディングを変更することはできません。</target>
        </trans-unit>
        <trans-unit id="5882943850506b5e4c2358f26a0aca06e4d009ac" translate="yes" xml:space="preserve">
          <source>The secure_delete setting causes deleted content to be overwritten with zeros. There is a small performance penalty since additional I/O must occur. On the other hand, secure_delete can prevent fragments of sensitive information from lingering in unused parts of the database file after it has been deleted. See the documentation on the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; for additional information.</source>
          <target state="translated">secure_delete設定により、削除されたコンテンツはゼロで上書きされます。追加のI / Oが発生する必要があるため、パフォーマンスが多少低下します。一方、secure_deleteを使用すると、削除されたデータベースファイルの未使用部分に機密情報の断片が残るのを防ぐことができます。詳細については、&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_deleteプラグマの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5b04afcfc3f7fd09080833015b31410c518c0339" translate="yes" xml:space="preserve">
          <source>The separate &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; description provides details on the structure of a database file and of the write-head log file used in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. But details of the locking protocol and of the format of the WAL-index are deliberately omitted since those details are left to discretion of individual &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations. This document fills in those missing details for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">個別の&lt;a href=&quot;fileformat2&quot;&gt;ファイル形式の&lt;/a&gt;説明では、データベースファイルと、&lt;a href=&quot;wal&quot;&gt;WALモードで&lt;/a&gt;使用される書き込みヘッドログファイルの構造について詳しく説明しています。ただし、ロックプロトコルとWALインデックスの形式の詳細は、個々の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;実装の裁量に委ねられているため、意図的に省略されています。このドキュメントでは、UNIXとWindowsの&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;に関する欠落している詳細について説明します。</target>
        </trans-unit>
        <trans-unit id="92103d1dd017d8e08e89604f71cfaaa913bec164" translate="yes" xml:space="preserve">
          <source>The session extension facilitates this by recording all changes to both Alice's and Bob's databases and writing those changes into changeset or patchset files. At the end of the day, Alice can send her changeset to Bob and Bob can &quot;apply&quot; it to his database. The result (assuming there are no conflicts) is that Bob's database then contains both his changes and Alice's changes. Likewise, Bob can send a changeset of his work over to Alice and she can apply his changes to her database.</source>
          <target state="translated">セッション拡張機能は、アリスとボブの両方のデータベースへのすべての変更を記録し、それらの変更をチェンジセットファイルやパッチセットファイルに書き出すことで、これを容易にします。一日の終わりに、Aliceは自分のチェンジセットをBobに送り、Bobはそれを自分のデータベースに「適用」することができます。その結果(競合がないと仮定して)、Bobのデータベースには彼の変更とAliceの変更の両方が含まれることになります。同様に、ボブは自分の仕事のチェンジセットをアリスに送ることができ、アリスは彼の変更を自分のデータベースに適用することができます。</target>
        </trans-unit>
        <trans-unit id="1c8659fbbef014d7697d1ea170e739bed552acd5" translate="yes" xml:space="preserve">
          <source>The session extension only works with tables that have a declared PRIMARY KEY. The PRIMARY KEY of a table may be an INTEGER PRIMARY KEY (rowid alias) or an external PRIMARY KEY.</source>
          <target state="translated">セッション拡張機能は、宣言されたPRIMARY KEYを持つテーブルでのみ動作します。テーブルの PRIMARY KEY は INTEGER PRIMARY KEY (rowid のエイリアス)あるいは外部 PRIMARY KEY となります。</target>
        </trans-unit>
        <trans-unit id="8619b8eb0bb510e39b3c8622337b2bb7b6549aba" translate="yes" xml:space="preserve">
          <source>The session extension provide a mechanism for recording changes to some or all of the &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; in an SQLite database, and packaging those changes into a &quot;changeset&quot; or &quot;patchset&quot; file that can later be used to apply the same set of changes to another database with the same schema and compatible starting data. A &quot;changeset&quot; may also be inverted and used to &quot;undo&quot; a session.</source>
          <target state="translated">セッション拡張機能は、SQLiteデータベース内の一部またはすべての&lt;a href=&quot;rowidtable&quot;&gt;ROWIDテーブル&lt;/a&gt;への変更を記録し、それらの変更を「変更セット」または「パッチセット」ファイルにパッケージ化して、後で同じ変更セットを別のセットに適用するために使用できるメカニズムを提供します同じスキーマと互換性のある開始データを持つデータベース。「チェンジセット」を逆にして、セッションを「元に戻す」ために使用することもできます。</target>
        </trans-unit>
        <trans-unit id="0b97f5ba300285bc33992abb7779519b897b7aa7" translate="yes" xml:space="preserve">
          <source>The session object &quot;indirect&quot; flag is set when the change is made, or</source>
          <target state="translated">セッションオブジェクトの「間接」フラグは、変更が行われたときに設定されるか</target>
        </trans-unit>
        <trans-unit id="ffcb76dee8dc3b4cb20fe29908bbbe2ff2230909" translate="yes" xml:space="preserve">
          <source>The session object is configured with a set of tables to monitor changes on.</source>
          <target state="translated">セッションオブジェクトは、変更を監視するテーブルのセットで構成されています。</target>
        </trans-unit>
        <trans-unit id="0c67ff7ccfd533851dea34da8187939bbeae8841" translate="yes" xml:space="preserve">
          <source>The session object is deleted using a call to the &lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; API function.</source>
          <target state="translated">セッションオブジェクトは、&lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete（）&lt;/a&gt; API関数の呼び出しを使用して削除されます。</target>
        </trans-unit>
        <trans-unit id="b41c2d1dd25f0b9daf0304c7870c3eb7ae78b919" translate="yes" xml:space="preserve">
          <source>The session object therefore accumulates two types of records - those that consist of primary key values only (created when the user inserts a new record) and those that consist of the primary key values and the original values of other table columns (created when the users deletes or updates a record).</source>
          <target state="translated">したがって、セッション・オブジェクトは、主キー値のみで構成されるレコード(ユーザーが新しいレコードを挿入したときに作成される)と、主キー値と他のテーブル・カラムの元の値で構成されるレコード(ユーザーがレコードを削除または更新したときに作成される)の2つのタイプのレコードを蓄積します。</target>
        </trans-unit>
        <trans-unit id="67b4d05a6aa852ba851b95d39158470c33cead0c" translate="yes" xml:space="preserve">
          <source>The session object will be used to create changesets for tables in database zDb, where zDb is either &quot;main&quot;, or &quot;temp&quot;, or the name of an attached database. It is not an error if database zDb is not attached to the database when the session object is created.</source>
          <target state="translated">セッションオブジェクトは、データベースzDbのテーブルの変更セットを作成するために使用され、ここでzDbは &quot;main&quot;、&quot;temp&quot;、またはアタッチされたデータベースの名前です。セッションオブジェクトが作成されたときに、データベースzDbがデータベースにアタッチされていなくてもエラーにはなりません。</target>
        </trans-unit>
        <trans-unit id="45a8679117c7936fefc29c4e8b252b099d09917b" translate="yes" xml:space="preserve">
          <source>The sessions module never invokes an xOutput callback with the third parameter set to a value less than or equal to zero. Other than this, no guarantees are made as to the size of the chunks of data returned.</source>
          <target state="translated">sessionsモジュールは、3番目のパラメータにゼロ以下の値を設定してxOutputコールバックを呼び出すことはありません。これ以外にも、返されるデータのチャンクのサイズは保証されていません。</target>
        </trans-unit>
        <trans-unit id="a218d47a709906affb4f3ae717da9de3077b519d" translate="yes" xml:space="preserve">
          <source>The sessions module revolves around creating and manipulating changesets. A changeset is a blob of data that encodes a series of changes to a database. Each change in a changeset is one of the following:</source>
          <target state="translated">セッションモジュールは、チェンジセットの作成と操作を中心に展開します。チェンジセットは、データベースへの一連の変更をコード化したデータの塊です。チェンジセットの各変更は、以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="d639d6bbcd88a2f2cd5339240f5d5c5de8f80432" translate="yes" xml:space="preserve">
          <source>The set X contains the index in aPgno of every entry in the current 32768-byte unit of the shm file that might possible be a solution to the FindFrame(P,M) function. Each of these entries must be checked separately to ensure that the aPgno value is P and that the frame number does not exceed M. The largest frame number that passes those two tests is the answer.</source>
          <target state="translated">セットXには、shmファイルの現在の32768バイト単位の各エントリのaPgnoのインデックスが含まれており、FindFrame(P,M)関数の解答となる可能性があります。これらの各エントリは、aPgnoの値がPであり、フレーム番号がMを超えないことを確認するために、個別にチェックされなければなりません。</target>
        </trans-unit>
        <trans-unit id="daeab809359987c0f17f57c78f38704f62041f7b" translate="yes" xml:space="preserve">
          <source>The set of</source>
          <target state="translated">のセットです。</target>
        </trans-unit>
        <trans-unit id="df619f50e7143055665ccf4d69e938c1340f4737" translate="yes" xml:space="preserve">
          <source>The set of built-in auxiliary functions provided by FTS5 may be improved upon in the future.</source>
          <target state="translated">FTS5が提供する内蔵補助機能のセットは、将来的に改良される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a49341beec33b485301f8bafe6ae6c61c6f39915" translate="yes" xml:space="preserve">
          <source>The set of checklist items for release checklist is potentially updated for each release. The content and complete history of each release checklist are retained for the historical record.</source>
          <target state="translated">リリースチェックリストのチェックリスト項目のセットは、リリースごとに潜在的に更新されます。各リリースチェックリストの内容と完全な履歴は、履歴記録のために保持されます。</target>
        </trans-unit>
        <trans-unit id="0f5a66644e1d1f4b0f41c960d4f2f7a794b20868" translate="yes" xml:space="preserve">
          <source>The set of static mutexes may change from one SQLite release to the next. Applications that override the built-in mutex logic must be prepared to accommodate additional static mutexes.</source>
          <target state="translated">静的ミューテックスのセットは、SQLite のリリースごとに変更される可能性があります。組み込みのミューテックスロジックをオーバーライドするアプリケーションは、追加の静的ミューテックスに対応できるように準備しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="9b60f1982b5c4164ca917a617479f0aacfe46294" translate="yes" xml:space="preserve">
          <source>The shadow tables are ordinary SQLite data tables. You can query them directly if you like, though this unlikely to reveal anything particularly useful. And you can &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or even &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; the shadow tables, though doing so will corrupt your R*Tree index. So it is best to simply ignore the shadow tables. Recognize that they hold your R*Tree index information and let it go as that.</source>
          <target state="translated">シャドウテーブルは、通常のSQLiteデータテーブルです。必要に応じて直接クエリすることもできますが、これが特に有用なものを明らかにすることはほとんどありません。また、シャドウテーブルを&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、&lt;a href=&quot;lang_insert&quot;&gt;INSERT、&lt;/a&gt;または&lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt;することもできますが、そうするとR * Treeインデックスが破損します。したがって、シャドウテーブルは単に無視するのが最善です。それらがR * Treeインデックス情報を保持していることを認識し、それをそのままにします。</target>
        </trans-unit>
        <trans-unit id="7b89e4e1261efca1d668789aecafeceb06cf0045" translate="yes" xml:space="preserve">
          <source>The shared library filename passed to &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; may omit the filename suffix, and an appropriate architecture-dependent suffix (&quot;.so&quot;, &quot;.dylib&quot;, or &quot;.dll&quot;) will be added automatically.</source>
          <target state="translated">&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）に&lt;/a&gt;渡される共有ライブラリのファイル名では、ファイル名のサフィックスが省略される場合があり、適切なアーキテクチャ依存のサフィックス（ &quot;.so&quot;、 &quot;。dylib&quot;、または &quot;.dll&quot;）が自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="683712ddb2de169a205df89a5ffe29d5c006c2b5" translate="yes" xml:space="preserve">
          <source>The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode&lt;/a&gt; is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created.</source>
          <target state="translated">共有メモリファイルには永続的なコンテンツが含まれていません。共有メモリ・ファイルの唯一の目的は、すべてのWALモードで同じデータベースにアクセスする複数のプロセスによる使用のために共有メモリのブロックを提供することです。場合&lt;a href=&quot;vfs&quot;&gt;VFSは、&lt;/a&gt;共有メモリにアクセスするための代替方法を提供することができる、その別の方法ではなく、共有メモリのファイルよりも使用される可能性があります。たとえば、&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA Locking_mode&lt;/a&gt;がEXCLUSIVEに設定されている場合（1つのプロセスのみがデータベースファイルにアクセスできることを意味します）、共有メモリは共有メモリファイルからではなくヒープから割り当てられ、共有メモリファイルは作成されることはありません。</target>
        </trans-unit>
        <trans-unit id="d84d71db4e9c7a1a18a467e4bbe2be0320c053f2" translate="yes" xml:space="preserve">
          <source>The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered.</source>
          <target state="translated">共有メモリファイルは、関連するWALファイルと同じ有効期間を持ちます。共有メモリファイルは、WALファイルが作成されたときに作成され、WALファイルが削除されたときに削除されます。WALファイルの復元中に、共有メモリファイルは、復元されるWALファイルの内容に基づいてゼロから再作成されます。</target>
        </trans-unit>
        <trans-unit id="c6175d074e784d9fffd662056186d3e1dc1f4cc9" translate="yes" xml:space="preserve">
          <source>The shm does not contain any database content and is not required to recover the database following a crash. For that reason, the first client to connect to a quiescent database will normally truncate the shm file if it exists. Since the content of the shm file does not need to be preserved across a crash, the shm file is never fsync()-ed to disk. In fact, if there were a mechanism by which SQLite could tell the operating system to never persist the shm file to disk but always hold it in cache memory, SQLite would use that mechanism to avoid any unnecessary disk I/O associated with the shm file. However, no such mechanism exists in standard posix.</source>
          <target state="translated">shmにはデータベースの内容は含まれておらず、クラッシュ後にデータベースを復旧するために必要なものではありません。そのため、静止状態のデータベースに最初に接続したクライアントは、通常、shmファイルが存在する場合には、shmファイルを切り捨てます。shmファイルの内容はクラッシュしても保存される必要がないので、shmファイルは決してfsync()してディスクに保存されません。実際、もし SQLite が shm ファイルをディスクに永続化せず、常にキャッシュメモリに保持するように OS に指示できるメカニズムがあれば、SQLite は shm ファイルに関連した不要なディスク I/O を避けるためにそのメカニズムを使用するでしょう。しかし、標準の posix にはそのようなメカニズムは存在しません。</target>
        </trans-unit>
        <trans-unit id="2ce5842569cd9ae6cb873fe122d925e98dfd9e57" translate="yes" xml:space="preserve">
          <source>The shm file consists of one or more hash tables, where each hash table is 32768 bytes in size. Except, a 136-byte header is carved out of the front of the very first hash table, so the first hash table is only 32632 bytes in size. The total size of the shm file is always a multiple of 32768. In most cases, the total size of the shm file is exactly 32768 bytes. The shm file only needs to grow beyond a single hash table if when the wal file grows very large (more than 4079 frames). Since the default &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;automatic checkpoint threshold&lt;/a&gt; is 1000, WAL files rare reach the 4079 threshold needed to make the shm file grow.</source>
          <target state="translated">shmファイルは1つ以上のハッシュテーブルで構成され、各ハッシュテーブルのサイズは32768バイトです。ただし、136バイトのヘッダーは最初のハッシュテーブルの前面から切り出されるため、最初のハッシュテーブルのサイズは32632バイトにすぎません。 shmファイルの合計サイズは常に32768の倍数です。ほとんどの場合、shmファイルの合計サイズはちょうど32768バイトです。 wmファイルが非常に大きくなる（4079フレームを超える）場合、shmファイルは単一のハッシュテーブルを超えて大きくする必要があります。デフォルトの&lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;自動チェックポイントしきい値&lt;/a&gt;は1000であるため、WALファイルがshmファイルを拡張するために必要な4079しきい値に達することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="0d8774149ef596e36906cd1fe56afff10a697841" translate="yes" xml:space="preserve">
          <source>The signature of the xAccess method has been modified to return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and to store its output into an integer pointed to by a parameter, rather than returning the output directly. This change allows the xAccess() method to report failures. In association with this signature change, a new extended error code &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; has been added.</source>
          <target state="translated">xAccessメソッドのシグネチャが変更され、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;を返し、その出力を、直接出力を返すのではなく、パラメーターが指す整数に格納するようになりました。この変更により、xAccess（）メソッドは失敗を報告できます。このシグネチャの変更に関連して、新しい拡張エラーコード&lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt;が追加されました。</target>
        </trans-unit>
        <trans-unit id="73da15d1378e7e4cecf6c05a9921a5f1b3117f3b" translate="yes" xml:space="preserve">
          <source>The signature of the xCheckReservedLock method on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; has been modified so that it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and stores its boolean result into an integer pointed to by a parameter. In association with this change, a new extended error code &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; has been added.</source>
          <target state="translated">上xCheckReservedLockメソッドのシグネチャ&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsは、&lt;/a&gt;それが返すように修正された&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;整数にし、そのブール結果を記憶するパラメータによって指されます。この変更に関連して、新しい拡張エラーコード&lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt;が追加されました。</target>
        </trans-unit>
        <trans-unit id="23da313c5318bbaf1e11638c6787139e74ceff62" translate="yes" xml:space="preserve">
          <source>The simple, modular design of SQLite makes it a good platform for prototyping new, experimental database language features or ideas.</source>
          <target state="translated">シンプルなモジュール設計のSQLiteは、新しい実験的なデータベース言語の機能やアイデアをプロトタイピングするのに適したプラットフォームとなっています。</target>
        </trans-unit>
        <trans-unit id="2d0de7ad7a0838db1beb185b37e3f4659d20a947" translate="yes" xml:space="preserve">
          <source>The single row of result-set data created by evaluating the aggregate and non-aggregate expressions in the result-set forms the result of an aggregate query without a GROUP BY clause. An aggregate query without a GROUP BY clause always returns exactly one row of data, even if there are zero rows of input data.</source>
          <target state="translated">結果セット内の集約式と非集約式を評価して作成された結果セットデータの1行は、GROUP BY句を使用しない集約クエリの結果となります。GROUP BY句のない集約クエリは、入力データの行が0行であっても、常に正確に1行のデータを返します。</target>
        </trans-unit>
        <trans-unit id="fee8fe6df1809775fcd62fdf9f110bcf759d94a6" translate="yes" xml:space="preserve">
          <source>The six streaming API xxx_strm() functions serve similar purposes to the corresponding non-streaming API functions:</source>
          <target state="translated">6 つのストリーミング API xxx_strm()関数は、対応する非ストリーミング API 関数と同様の目的を果たします。</target>
        </trans-unit>
        <trans-unit id="af903c0dcc364c9d11abbe191c3960a1c5d014f5" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64（）の6番目の引数は、3番目のパラメーターでテキストのエンコードを指定するために、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LEの&lt;/a&gt;いずれかでなければなりません。 sqlite3_bind_text64（）の6番目の引数が上記の許容値の1つでない場合、またはテキストエンコーディングが6番目のパラメータで指定されたエンコーディングと異なる場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="3a920902ff183846916ffe84129516653c512659" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64（）の6番目の引数は、3番目のパラメーターでテキストのエンコードを指定するために、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LEの&lt;/a&gt;いずれかでなければなりません。 sqlite3_bind_text64（）の6番目の引数が上記の許容値の1つでない場合、またはテキストエンコーディングが6番目のパラメータで指定されたエンコーディングと異なる場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="e8b06ccbdc8c379a9a470f7c185a0247a80f8e2b" translate="yes" xml:space="preserve">
          <source>The sixth, seventh and eighth parameters passed to the three &quot;sqlite3_create_function*&quot; functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate. A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters. An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc. To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.</source>
          <target state="translated">3つの &quot;sqlite3_create_function*&quot;関数xFunc、xStep、xFinalに渡される6番目、7番目、8番目のパラメータは、SQL関数や集約を実装するC言語関数へのポインタです。スカラーSQL関数はxFuncコールバックの実装のみを必要とします。集約SQL関数はxStepとxFinalの実装を必要とし、xFuncにはNULLポインタを渡さなければなりません。既存のSQL関数や集合体を削除するには、3つの関数のコールバックすべてにNULLポインタを渡します。</target>
        </trans-unit>
        <trans-unit id="5a1e0ca7d22b49ccdf57dfbe9e13e610f7e7488a" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_window_functionに渡される6番目、7番目、8番目、9番目のパラメーター（xStep、xFinal、xValue、xInverse）は、新しい関数を実装するC言語のコールバックへのポインターです。 xStepとxFinalはどちらも非NULLでなければなりません。 xValueとxInverseはどちらもNULLである場合があります（その場合は通常の集計関数が作成されます）、または両方が非NULLである必要があります。その場合、新しい関数は集計関数または集計ウィンドウ関数として使用できます。集約ウィンドウ関数の実装に関する詳細は、&lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;こちらから入手できます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f70d86715eabcca8a7d61d2f6e68b2fc4d6a57e" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_window_functionに渡される6番目、7番目、8番目、9番目のパラメーター（xStep、xFinal、xValue、xInverse）は、新しい関数を実装するC言語のコールバックへのポインターです。 xStepとxFinalはどちらも非NULLでなければなりません。 xValueとxInverseはどちらもNULLである場合があります（その場合は通常の集計関数が作成されます）、または両方が非NULLである必要があります。その場合、新しい関数は集計関数または集計ウィンドウ関数として使用できます。集約ウィンドウ関数の実装に関する詳細は、&lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;こちらから入手できます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="650196bb22cf5bf05d1563df9b31bf781c3e9a6d" translate="yes" xml:space="preserve">
          <source>The size of the blobs in the test data affects performance. The filesystem will generally be faster for larger blobs, since the overhead of open() and close() is amortized over more bytes of I/O, whereas the database will be more efficient in both speed and space as the average blob size decreases.</source>
          <target state="translated">テストデータのブロブのサイズはパフォーマンスに影響します。open()とclose()のオーバーヘッドはより多くのバイト数のI/Oで償却されるため、ファイルシステムは一般的にブロブが大きいほど高速になります。</target>
        </trans-unit>
        <trans-unit id="71ba6b5b378d657456a5945d2ff20a780b1b14d4" translate="yes" xml:space="preserve">
          <source>The size of the lookaside memory pool has a global default value but can also be configured on a connection-by-connection basis. To change the default size of the lookaside memory pool at compile-time, use the &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/a&gt; option. To change the default size of the lookaside memory pool at start-time, use the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface:</source>
          <target state="translated">ルックアサイドメモリプールのサイズにはグローバルなデフォルト値がありますが、接続ごとに構成することもできます。コンパイル時にルックアサイドメモリプールのデフォルトサイズを変更するには、&lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE = &lt;i&gt;SZ、N&lt;/i&gt;&lt;/a&gt;オプションを使用します。開始時にルックアサイドメモリプールのデフォルトサイズを変更するには、&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェイスを使用します。</target>
        </trans-unit>
        <trans-unit id="7032e0044fe8cbf0ccd0392512f38ee2b17ffc25" translate="yes" xml:space="preserve">
          <source>The size of the matching term in bytes.</source>
          <target state="translated">マッチング項のサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="481f99d28cac0daa50062e9ad3a05601840366c0" translate="yes" xml:space="preserve">
          <source>The size of the memory-mapped I/O region cannot be changed while the memory-mapped I/O region is in active use, to avoid unmapping memory out from under running SQL statements. For this reason, the mmap_size pragma may be a no-op if the prior mmap_size is non-zero and there are other SQL statements running concurrently on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">メモリマップI / O領域のサイズは、メモリマップI / O領域がアクティブに使用されている間は変更できません。これにより、実行中のSQLステートメントからメモリがアンマップされないようにします。このため、前のmmap_sizeがゼロ以外で、同じ&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;上で同時に実行されている他のSQLステートメントがある場合、mmap_sizeプラグマは何もしない場合があります。</target>
        </trans-unit>
        <trans-unit id="19c67c781984d7843a725bf421c45281605af01e" translate="yes" xml:space="preserve">
          <source>The snippet function first attempts to find a fragment of text consisting of</source>
          <target state="translated">スニペット関数は、まず、以下の要素からなるテキストの断片を見つけようとします。</target>
        </trans-unit>
        <trans-unit id="54b3f9fdd628ef57cd97424e1a01116d0ba15ccd" translate="yes" xml:space="preserve">
          <source>The snippet function is used to create formatted fragments of document text for display as part of a full-text query results report. The snippet function may be passed between one and six arguments, as follows:</source>
          <target state="translated">snippet関数は、フルテキストのクエリ結果レポートの一部として表示するために、 フォーマットされたドキュメントテキストの断片を作成するために使用されます。スニペット関数には、以下のように 1 つから 6 つの引数を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="25ab90403f978d997e2573cced370b12d71d602c" translate="yes" xml:space="preserve">
          <source>The snippet() function is similar to highlight(), except that instead of returning entire column values, it automatically selects and extracts a short fragment of document text to process and return. The snippet() function must be passed five parameters following the table name argument:</source>
          <target state="translated">snippet()関数は highlight()に似ていますが、列全体の値を返すのではなく、 ドキュメントテキストの短い断片を自動的に選択・抽出して処理して返す点が異なります。snippet()関数には、テーブル名の引数の後に 5 つのパラメータを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="650db23255aac8aa4103c6f6d9992ba8c2854051" translate="yes" xml:space="preserve">
          <source>The soft heap limit is &quot;soft&quot; in this sense: If SQLite is not able to free up enough auxiliary memory to stay below the limit, it goes ahead and allocates the extra memory and exceeds its limit. This occurs under the theory that it is better to use additional memory than to fail outright.</source>
          <target state="translated">ソフトヒープ制限はこの意味で「ソフト」です。これは、完全に失敗するよりも追加のメモリを使用した方が良いという理論の下で発生します。</target>
        </trans-unit>
        <trans-unit id="f259c7b18142819d8b2454c94e82cad365d3cfbd" translate="yes" xml:space="preserve">
          <source>The soft heap limit is not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="translated">現在の実装では、以下の条件のうち1つ以上が真の場合、ソフトヒープ制限は適用されません。</target>
        </trans-unit>
        <trans-unit id="62f643dbe59889b37bb6ee27203ce861b75e4df1" translate="yes" xml:space="preserve">
          <source>The soft heap limit is set to zero.</source>
          <target state="translated">ソフトヒープの制限はゼロに設定されています。</target>
        </trans-unit>
        <trans-unit id="84963983acb45095ae249428915953ba1875b5f1" translate="yes" xml:space="preserve">
          <source>The solution was computed in less than 300 milliseconds on a modern workstation.</source>
          <target state="translated">この解は、最新のワークステーションで300ミリ秒以内に計算されました。</target>
        </trans-unit>
        <trans-unit id="d8fc439428a4b57b8a635dfdc3bc6c9e9458a598" translate="yes" xml:space="preserve">
          <source>The solver works by adding new entries to the &quot;x&quot; recursive table. Given prior entries, the recursive-select tries to fill in a single new position with all values between 1 and 9 that actually work in that position. The complicated &quot;NOT EXISTS&quot; subquery is the magic that figures out whether or not each candidate &quot;s&quot; string is a valid sudoku puzzle or not.</source>
          <target state="translated">ソルバーは、&quot;x &quot;再帰テーブルに新しいエントリを追加することで動作する。前のエントリが与えられると、再帰的選択は、1から9の間のすべての値がその位置で実際に動作するように、1つの新しい位置を埋めようとする。複雑な &quot;NOT EXISTS &quot;副問い合わせは、各候補の &quot;s &quot;文字列が有効な数独パズルであるかどうかを判断する魔法のようなものです。</target>
        </trans-unit>
        <trans-unit id="a81e5007b5735cbaaaf41fe92b085a6bb28859ca" translate="yes" xml:space="preserve">
          <source>The sorter can use auxiliary helper threads to increase real-time response. This feature is off by default and may be enabled using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command or the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option.</source>
          <target state="translated">ソーターは、補助ヘルパースレッドを使用して、リアルタイムの応答を向上させることができます。この機能はデフォルトでオフになっており、&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMAスレッド&lt;/a&gt;コマンドまたは&lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt;コンパイル時オプションを使用して有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="f3082f533e58c712999cbf940673f567d8a29017" translate="yes" xml:space="preserve">
          <source>The soundex(X) function returns a string that is the soundex encoding of the string X. The string &quot;?000&quot; is returned if the argument is NULL or contains no ASCII alphabetic characters. This function is omitted from SQLite by default. It is only available if the &lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt; compile-time option is used when SQLite is built.</source>
          <target state="translated">soundex（X）関数は、文字列Xのsoundexエンコーディングである文字列を返します。引数がNULLであるか、ASCIIアルファベット文字が含まれていない場合、文字列 &quot;？000&quot;が返されます。この関数は、デフォルトでSQLiteから省略されています。SQLiteのビルド時に&lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt;コンパイル時オプションが使用されている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="9611e60fec986c004f40bb3986af444fd02497aa" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">ソース&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、バックアップ操作の実行中または初期化中に、アプリケーションによって他の目的で使用される場合があります。SQLiteがコンパイルされ、スレッドセーフデータベース接続をサポートするように構成されている場合、ソースデータベース接続は他のスレッド内から同時に使用できます。</target>
        </trans-unit>
        <trans-unit id="d46770cf519d64fb4869e93bb4ebad2a0d214ebb" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">ソース&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、バックアップ操作の実行中または初期化中に、アプリケーションによって他の目的で使用される場合があります。SQLiteがコンパイルされ、スレッドセーフデータベース接続をサポートするように構成されている場合、ソースデータベース接続は他のスレッド内から同時に使用できます。</target>
        </trans-unit>
        <trans-unit id="cb98bce78cf336a453aacfd68f1f2a70ccf1bb9e" translate="yes" xml:space="preserve">
          <source>The source code files for other SQL database engines typically begin with a comment describing your legal rights to view and copy that file. The SQLite source code contains no license since it is not governed by copyright. Instead of a license, the SQLite source code offers a blessing:</source>
          <target state="translated">他の SQL データベースエンジンのソースコードファイルは、通常、そのファイルを表示したりコピーしたりするための法的権利を記述したコメントで始まります。SQLite のソースコードは著作権によって管理されていないため、ライセンスが含まれていません。ライセンスの代わりに、SQLite のソースコードは祝福を提供します。</target>
        </trans-unit>
        <trans-unit id="b230daf41ab11e7921fa2a959263c09c6fe7e609" translate="yes" xml:space="preserve">
          <source>The source code for Geopoly is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is not included in the library unless the &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Geopolyのソースコードが含まれている&lt;a href=&quot;amalgamation&quot;&gt;合併&lt;/a&gt;ますがない限り、ライブラリに含まれていません&lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt;コンパイル時のオプションが使用されています。</target>
        </trans-unit>
        <trans-unit id="9ce563d47e369284dcc9eb90d209f5fe50c9d87d" translate="yes" xml:space="preserve">
          <source>The source code for SQLite is in the public domain. No claim of copyright is made on any part of the core source code. (The documentation and test code is a different matter - some sections of documentation and test logic are governed by open-source licenses.) All contributors to the SQLite core software have signed affidavits specifically disavowing any copyright interest in the code. This means that anybody is able to legally do anything they want with the SQLite source code.</source>
          <target state="translated">SQLiteのソースコードはパブリックドメインです。コアとなるソースコードのいかなる部分にも著作権は主張されていません。(ドキュメントとテストコードは別問題です-ドキュメントとテストロジックのいくつかのセクションはオープンソースのライセンスで管理されています)。SQLiteコアソフトウェアへの貢献者は全員、そのコードの著作権に関する一切の利害関係を否定する宣誓供述書に署名しています。これは、誰もがSQLiteのソースコードを合法的に何でもできるということを意味します。</target>
        </trans-unit>
        <trans-unit id="1cfec4458134c689073b56a3f124a05cfee319a4" translate="yes" xml:space="preserve">
          <source>The source code in public SQLite releases uses unix line endings (ASCII code 10: &quot;newline&quot; only, NL) and spaces instead of tabs. If you will be changing the line ending to windows-style line endings (ASCII codes 13, 10: &quot;carriage-return&quot; and &quot;newline&quot;; CR-NL) or if you will be changing space indents into tab indents, &lt;b&gt;make that change now&lt;/b&gt; before you check in the baseline. The merging process will only work well if the differences between the public and the private branches are minimal. If every single line of the source file is changed in the private branch because you changed from NL to CR-NL line endings, then the merge steps will not work correctly.</source>
          <target state="translated">パブリックSQLiteリリースのソースコードでは、タブの代わりにUNIXの行末（ASCIIコード10：「改行」のみ、NL）とスペースを使用しています。行末をWindowsスタイルの行末に変更する場合（ASCIIコード13、10：「復帰」と「改行」、CR-NL）、またはスペースインデントをタブインデントに変更する場合は、&lt;b&gt;その変更を行います。今、&lt;/b&gt;あなたは、ベースラインをチェックインする前に。マージプロセスは、パブリックブランチとプライベートブランチの違いが最小限の場合にのみうまく機能します。 NLからCR-NLの行末に変更したためにソースファイルのすべての1行がプライベートブランチで変更された場合、マージ手順は正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="c71fe30151d8d1ffe822e83fe610e421f8822069" translate="yes" xml:space="preserve">
          <source>The source code module that implements the spellfix1 virtual table also implements several SQL functions that might be useful to applications that employ spellfix1 or for testing or diagnostic work while developing applications that use spellfix1. The following auxiliary functions are available:</source>
          <target state="translated">spellfix1 仮想テーブルを実装したソースコードモジュールには、spellfix1 を使用したアプリケーションや、spellfix1 を使用したアプリケーションを開発する際のテストや診断作業に役立つと思われる SQL 関数もいくつか実装されています。以下の補助関数が利用可能です。</target>
        </trans-unit>
        <trans-unit id="06e0d7a5506cbf178b35ec85914ad01a3f38017c" translate="yes" xml:space="preserve">
          <source>The source code to SQLite is designed to be readable and accessible to the average programmer. All procedures and data structures and many automatic variables are carefully commented with useful information about what they do. Boilerplate commenting is omitted.</source>
          <target state="translated">SQLite のソースコードは、一般的なプログラマーが読みやすく、アクセスしやすいように設計されています。すべてのプロシージャとデータ構造、および多くの自動変数は、それらが何をするのかについての有用な情報とともに慎重にコメントされています。ボイラープレートのコメントは省略されています。</target>
        </trans-unit>
        <trans-unit id="042c70a1cba19758906aae3ec84cad7dc8c53383" translate="yes" xml:space="preserve">
          <source>The source code to the SQLite R*Tree module is included as part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is disabled by default. To enable the R*Tree module, simply compile with the &lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C-preprocessor macro defined. With many compilers, this is accomplished by adding the option &quot;-DSQLITE_ENABLE_RTREE=1&quot; to the compiler command-line.</source>
          <target state="translated">SQLite R * Treeモジュールのソースコードは、&lt;a href=&quot;amalgamation&quot;&gt;統合の&lt;/a&gt;一部として含まれていますが、デフォルトでは無効になっています。R * Treeモジュールを有効にするには、&lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; Cプリプロセッサマクロを定義してコンパイルするだけです。多くのコンパイラでは、これはオプション「-DSQLITE_ENABLE_RTREE = 1」をコンパイラのコマンドラインに追加することで実現されます。</target>
        </trans-unit>
        <trans-unit id="a40cbeb8ac52569bca99e948856ab4db846ed02b" translate="yes" xml:space="preserve">
          <source>The source code to the bytecode engine is in the &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; source file. The &lt;a href=&quot;opcode#codes&quot;&gt;opcode definitions&lt;/a&gt; in this document are derived from comments in that source file. The source code comments are the canonical source of information about the bytecode engine. When in doubt, refer to the source code.</source>
          <target state="translated">バイトコードエンジンのソースコードは、&lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;ソースファイルにあります。このドキュメントの&lt;a href=&quot;opcode#codes&quot;&gt;オペコード定義&lt;/a&gt;は、そのソースファイルのコメントから派生しています。ソースコードのコメントは、バイトコードエンジンに関する正規の情報源です。疑問がある場合は、ソースコードを参照してください。</target>
        </trans-unit>
        <trans-unit id="013177e363c21284dd8426d7c41bb413bf325a0a" translate="yes" xml:space="preserve">
          <source>The source code to the software that runs the checklists is stored in its own Fossil repository at &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt;.</source>
          <target state="translated">チェックリストを実行するソフトウェアのソースコードは、&lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https：//www.sqlite.org/checklistappにある&lt;/a&gt;独自のFossilリポジトリに格納されています。</target>
        </trans-unit>
        <trans-unit id="79b8e8d26e2fd4c36bb8b15bd366cedd02031771" translate="yes" xml:space="preserve">
          <source>The source code to the sqlite3 command line interface is in a single file named &quot;shell.c&quot;. The shell.c source file is generated from other sources, but most of the code for shell.c can be found in &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c.in&lt;/a&gt;. (Regenerate shell.c by typing &quot;make shell.c&quot; from the canonical source tree.) &lt;a href=&quot;howtocompile&quot;&gt;Compile&lt;/a&gt; the shell.c file (together with the &lt;a href=&quot;amalgamation&quot;&gt;sqlite3 library source code&lt;/a&gt;) to generate the executable. For example:</source>
          <target state="translated">sqlite3コマンドラインインターフェースのソースコードは、「shell.c」という名前の単一ファイルにあります。shell.cソースファイルは他のソースから生成されますが、shell.cのコードのほとんどは&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c.inにあり&lt;/a&gt;ます。（正規のソースツリーから「make shell.c」と入力してshell.cを再生成します。）shell.cファイルを（&lt;a href=&quot;amalgamation&quot;&gt;sqlite3ライブラリのソースコード&lt;/a&gt;と共に）&lt;a href=&quot;howtocompile&quot;&gt;コンパイルし&lt;/a&gt;て、実行可能ファイルを生成します。例えば：</target>
        </trans-unit>
        <trans-unit id="3baebed042eebfba10dcbc501e7f4785bd1f6d07" translate="yes" xml:space="preserve">
          <source>The source file and entry point are named for &quot;unionvtab&quot; instead of &quot;swarmvtab&quot;. Unionvtab is a &lt;a href=&quot;unionvtab&quot;&gt;separately documented&lt;/a&gt; virtual table that is bundled with swarmvtab.</source>
          <target state="translated">ソースファイルとエントリポイントは、「swarmvtab」ではなく「unionvtab」という名前が付けられています。Unionvtabは、&lt;a href=&quot;unionvtab&quot;&gt;個別にドキュメント化された&lt;/a&gt;仮想テーブルであり、swarmvtabにバンドルされています。</target>
        </trans-unit>
        <trans-unit id="f3fba365763538ecbddb6c57bd7009fd058f9084" translate="yes" xml:space="preserve">
          <source>The special &quot;:memory:&quot; filename also works when using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;. For example:</source>
          <target state="translated">特別な &quot;：memory：&quot;ファイル名は、&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;を使用するときにも機能します。例えば：</target>
        </trans-unit>
        <trans-unit id="e94ff833d41c9d30c15767ac9e7aeb85daf442aa" translate="yes" xml:space="preserve">
          <source>The special UPSERT processing happens only for uniqueness constraint on the table that is receiving the INSERT. A &quot;uniqueness constraint&quot; is an explicit UNIQUE or PRIMARY KEY constraint within the CREATE TABLE statement, or a &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt;. UPSERT does not intervene for failed NOT NULL or foreign key constraints or for constraints that are implemented using triggers.</source>
          <target state="translated">特別なUPSERT処理は、INSERTを受け取っているテーブルの一意性制約に対してのみ発生します。「一意性制約」は、CREATE TABLEステートメント内の明示的なUNIQUEまたはPRIMARY KEY制約、または&lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;一意のインデックス&lt;/a&gt;です。UPSERTは、失敗したNOT NULL制約、外部キー制約、またはトリガーを使用して実装された制約には介入しません。</target>
        </trans-unit>
        <trans-unit id="2e94e3f68bdf7fc07fc0dcd878c089797a3fe9a2" translate="yes" xml:space="preserve">
          <source>The special filename &quot;:memory:&quot; can be used anywhere that a database filename is permitted. For example, it can be used as the</source>
          <target state="translated">特別なファイル名 &quot;:memory:&quot; は、データベースのファイル名が許可されている場所であればどこでも使うことができます。例えば、これは</target>
        </trans-unit>
        <trans-unit id="29bca994e11cb6f841a93aac5cdb8471376e38df" translate="yes" xml:space="preserve">
          <source>The specified column of row iRow contains a value that is not a TEXT or BLOB value,</source>
          <target state="translated">行 iRow の指定された列には、TEXT 値または BLOB 値以外の値が含まれています。</target>
        </trans-unit>
        <trans-unit id="06e48e6df6f51c35512fa45acc8a0e8a634c95f8" translate="yes" xml:space="preserve">
          <source>The speedtest1.c program is updated from time to time as the SQLite developers' understanding of what constitutes &quot;typical&quot; usage evolves.</source>
          <target state="translated">speedtest1.cプログラムは、SQLite開発者の「典型的な」使用法の理解が進むにつれて随時更新されます。</target>
        </trans-unit>
        <trans-unit id="5446f248e6916745d646dc3f5e88e893b3ad00cc" translate="yes" xml:space="preserve">
          <source>The speedtest1.c workload that is being measured tries to be representative of a wide range of typical uses of SQLite. But every application is different. The speedtest1.c workload might not be a good proxy for the kinds of activities performed by some applications. The SQLite developers are constantly working to improve the speedtest1.c program, to make it a better proxy for actual SQLite usage. Community feedback is welcomed.</source>
          <target state="translated">測定されている speedtest1.c のワークロードは、SQLite の典型的な使用法の広い範囲を代表するものにしようとしています。しかし、すべてのアプリケーションは異なります。speedtest1.cのワークロードは、アプリケーションによっては実行されるアクティビティの種類を表す良いプロキシではないかもしれません。SQLiteの開発者は、実際のSQLiteの使用状況をより良く表すために、speedtest1.cプログラムの改善に常に取り組んでいます。コミュニティからのフィードバックを歓迎します。</target>
        </trans-unit>
        <trans-unit id="92167de554e681259504f6e2f3edf942b7026bd6" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table creates a single shadow table named &quot;%_vocab&quot; (where the % is replaced by the name of the virtual table; Ex: &quot;demo_vocab&quot; for the &quot;demo&quot; virtual table). the shadow table contains the following columns:</source>
          <target state="translated">spellfix1 仮想テーブルは &quot;%_vocab&quot; という名前のシャドウテーブルを作成します (ここでは % は仮想テーブル名に置き換えられます。例:&quot;demo&quot; 仮想テーブルの場合は &quot;demo_vocab&quot; となります)。</target>
        </trans-unit>
        <trans-unit id="f9097157fe13f14b48b89617ee87aed62da83c73" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table uses editdist3 if the &quot;edit_cost_table=TABLE&quot; option is specified as an argument when the spellfix1 virtual table is created. But editdist3 can also be tested directly using the built-in &quot;editdist3()&quot; SQL function. The editdist3() SQL function has 3 forms:</source>
          <target state="translated">spellfix1の仮想テーブルを作成する際に、&quot;edit_cost_table=TABLE &quot;オプションを引数に指定すると、spellfix1の仮想テーブルはeditdist3を使用します。しかし、組み込みの SQL 関数 &quot;editdist3()&quot; を使って editdist3 を直接テストすることもできます。editdist3()SQL関数には3つの形式があります。</target>
        </trans-unit>
        <trans-unit id="e416e23f51996e4d87d84d45407db4bd482280e4" translate="yes" xml:space="preserve">
          <source>The sqlar_compress(X) function attempts to compress a copy of the string or blob X using the &lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt; algorithm and returns the result as a blob. If the input X is incompressible, then a copy of X is returned. This routine is used when inserting content into an SQLite Archive.</source>
          <target state="translated">sqlar_compress（X）関数は、&lt;a href=&quot;https://zlib.net/&quot;&gt;デフォルト&lt;/a&gt;アルゴリズムを使用して文字列またはblob Xのコピーを圧縮しようとし、結果をblobとして返します。入力Xが圧縮できない場合、Xのコピーが返されます。このルーチンは、SQLiteアーカイブにコンテンツを挿入するときに使用されます。</target>
        </trans-unit>
        <trans-unit id="0c132e268d7082089985d58b1716bee78c9b6c72" translate="yes" xml:space="preserve">
          <source>The sqlar_uncompress(Y,SZ) function will undo the compression accomplished by sqlar_compress(X). The Y parameter is the compressed content (the output from a prior call to sqlar_compress()) and SZ is the original uncompressed size of the input X that generated Y. If SZ is less than or equal to the size of Y, that indicates that no compression occurred, and so sqlar_uncompress(Y,SZ) returns a copy of Y. Otherwise, sqlar_uncompress(Y,SZ) runs the Inflate algorithm on Y to uncompress it and restore it to its original form and returns the uncompressed content. This routine is used when extracting content from an SQLite Archive.</source>
          <target state="translated">sqlar_uncompress(Y,SZ)関数は sqlar_compress(X)で行った圧縮を元に戻します。Y パラメータは圧縮された内容 (sqlar_compress()を呼び出す前の出力)であり、SZ は Y を生成した入力 X の元の圧縮されていないサイズです。 SZ が Y のサイズ以下の場合は圧縮が行われていないことを示しているので、sqlar_uncompress(Y,SZ)は Y のコピーを返します。このルーチンは、SQLite アーカイブからコンテンツを抽出する際に使用します。</target>
        </trans-unit>
        <trans-unit id="9894bd2027e1ec7fe1defc073eb794af8cfcddba" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility does not (currently) display differences in &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGERs&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt;.</source>
          <target state="translated">sqldiff.exeユーティリティは、（現在のところ）&lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGER&lt;/a&gt;または&lt;a href=&quot;lang_createview&quot;&gt;VIEWの&lt;/a&gt;違いを表示しません。</target>
        </trans-unit>
        <trans-unit id="1eec35831f2ddb18882fbe495fb78b6e88f27f70" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility is unable to compute differences for rowid tables for which the rowid is inaccessible. An example of a table with an inaccessible rowid is:</source>
          <target state="translated">sqldiff.exeユーティリティーは、行番号がアクセスできない行番号テーブルの差分を計算できませんでした。rowidにアクセスできないテーブルの例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="199f0fae6d132ab01eeef495a83df7f5456338b1" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility works by finding rows in the source and destination that are logical &quot;pairs&quot;. The default behavior is to treat two rows as pairs if they are in tables with the same name and they have the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, or in the case of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table if they have the same &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. Any differences in the content of paired rows are output as UPDATEs. Rows in the source database that could not be paired are output as DELETEs. Rows in the destination database that could not be paired are output as INSERTs.</source>
          <target state="translated">sqldiff.exeユーティリティは、ソースと宛先で論理的な「ペア」である行を見つけることによって機能します。デフォルトの動作では、2つの行が同じ名前のテーブルにあり、それらの行&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt;が同じ場合は2つの行をペアとして扱い、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの場合は同じ&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;を持つ場合を扱います。ペアになった行の内容の違いは、UPDATEとして出力されます。ペアにできなかったソースデータベースの行は、DELETEとして出力されます。ペアリングできなかった宛先データベースの行は、INSERTとして出力されます。</target>
        </trans-unit>
        <trans-unit id="8a33930cce71afaf2bac4391a7d92f2102fe6799" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in eight different formats: &quot;csv&quot;, &quot;column&quot;, &quot;html&quot;, &quot;insert&quot;, &quot;line&quot;, &quot;list&quot;, &quot;quote&quot;, &quot;tabs&quot;, and &quot;tcl&quot;. You can use the &quot;.mode&quot; dot command to switch between these output formats.</source>
          <target state="translated">sqlite3プログラムは、クエリの結果を8つの異なるフォーマットで表示することができます。&quot;csv&quot;、&quot;column&quot;、&quot;html&quot;、&quot;insert&quot;、&quot;line&quot;、&quot;list&quot;、&quot;quote&quot;、&quot;tabs&quot;、&quot;tcl &quot;です。これらの出力形式を切り替えるには、&quot;.mode&quot; ドットコマンドを使用することができます。</target>
        </trans-unit>
        <trans-unit id="c934dde95758c5fad9d43c84ef7f4c41bf3fe114" translate="yes" xml:space="preserve">
          <source>The sqlite3 program provides several convenience commands that are useful for looking at the schema of the database. There is nothing that these commands do that cannot be done by some other means. These commands are provided purely as a shortcut.</source>
          <target state="translated">sqlite3プログラムはデータベースのスキーマを見るのに便利なコマンドをいくつか提供しています。これらのコマンドは他の手段でできないことは何もありません。これらのコマンドは純粋にショートカットとして提供されています。</target>
        </trans-unit>
        <trans-unit id="d730ebfc68ed44661fe9aaa4784f842bff23a6ec" translate="yes" xml:space="preserve">
          <source>The sqlite3_aggregate_context(C,N) routine returns a NULL pointer when first called if N is less than or equal to zero or if a memory allocate error occurs.</source>
          <target state="translated">sqlite3_aggregate_context(C,N)ルーチンは、Nが0以下の場合やメモリ割り当てエラーが発生した場合に最初に呼び出されたときにNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="a781b80076608933fb39f35323ee417edf53e9fb" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer utility program is updated to provide better descriptions and to compute a more accurate estimate for &quot;Non-sequential pages&quot;</source>
          <target state="translated">sqlite3_analyzerユーティリティプログラムが更新され、より良い説明が提供され、&quot;連続しないページ &quot;のより正確な推定値が計算されるようになりました。</target>
        </trans-unit>
        <trans-unit id="cea6cec9b3cecf3cdb8b21b8c439ffacaf7e4757" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe Utility Program</source>
          <target state="translated">sqlite3_analyzer.exe ユーティリティプログラム</target>
        </trans-unit>
        <trans-unit id="08064e181ad262ed7b2155684ee88c71ec311b40" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe utility is updated to report the depth of each btree and to show the average fanout for indexes and WITHOUT ROWID tables.</source>
          <target state="translated">sqlite3_analyzer.exeユーティリティが更新され、各btreeの深さをレポートし、インデックスとWITHOUT ROWIDテーブルの平均ファンアウトを表示するようになりました。</target>
        </trans-unit>
        <trans-unit id="69ea749b99043a4585c42b36d581974b4510bba7" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backupオブジェクトは、進行中のオンラインバックアップ操作に関する状態情報を記録します。sqlite3_backupオブジェクトは、呼び出しによって作成され&lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;との呼び出しによって破壊される&lt;a href=&quot;#sqlite3backupfinish&quot;&gt;）sqlite3_backup_finish（ &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff5c92c4105199925092609d2d9f802d1fa55672" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backupオブジェクトは、進行中のオンラインバックアップ操作に関する状態情報を記録します。sqlite3_backupオブジェクトは、呼び出しによって作成され&lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;との呼び出しによって破壊される&lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;）sqlite3_backup_finish（ &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db586a6cde9f4397b1aba32074e60460ba79310a" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs report values stored by the previous call to sqlite3_backup_step(), they do not actually inspect the source database file. This means that if the source database is written to by another thread or process after the call to sqlite3_backup_step() returns but before the values returned by sqlite3_backup_remaining() and sqlite3_backup_pagecount() are used, the values may be technically incorrect. This is not usually a problem.</source>
          <target state="translated">sqlite3_backup_remaining()とsqlite3_backup_pagecount()APIは前のsqlite3_backup_step()の呼び出しで格納された値を報告しますが、実際にはソースデータベースファイルを検査しません。つまり、sqlite3_backup_step()の呼び出しが返された後、sqlite3_backup_remaining()とsqlite3_backup_pagecount()によって返された値が使用される前に、別のスレッドやプロセスによってソースデータベースが書き込まれた場合、その値は技術的に間違っている可能性があります。これは通常は問題ではありません。</target>
        </trans-unit>
        <trans-unit id="ab13e83a5eec05a800456f808bd2ed14f96ad7d8" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() routine returns the number of pages still to be backed up at the conclusion of the most recent sqlite3_backup_step(). The sqlite3_backup_pagecount() routine returns the total number of pages in the source database at the conclusion of the most recent sqlite3_backup_step(). The values returned by these functions are only updated by sqlite3_backup_step(). If the source database is modified in a way that changes the size of the source database or the number of pages remaining, those changes are not reflected in the output of sqlite3_backup_pagecount() and sqlite3_backup_remaining() until after the next sqlite3_backup_step().</source>
          <target state="translated">sqlite3_backup_remaining()ルーチンは、直近のsqlite3_backup_step()の終了時に、まだバックアップされるページ数を返します。sqlite3_backup_pagecount()ルーチンは、最新のsqlite3_backup_step()の終了時にソース・データベース内のページの総数を返します。これらの関数によって返される値は、sqlite3_backup_step()によってのみ更新されます。ソースデータベースのサイズや残りページ数を変更するような方法でソースデータベースが変更された場合、その変更は次のsqlite3_backup_step()の後までsqlite3_backup_pagecount()とsqlite3_backup_remaining()の出力には反映されません。</target>
        </trans-unit>
        <trans-unit id="027c7809f8a158ea3a080d548eaba037441f7cc5" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">sqlite3_backup_step（）は、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLYを返す&lt;/a&gt;場合があります。</target>
        </trans-unit>
        <trans-unit id="44bfd22dba6c2a0335c1b72cfe8865a0ed15325c" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">sqlite3_backup_step（）は、&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLYを返す&lt;/a&gt;場合があります。</target>
        </trans-unit>
        <trans-unit id="a2f8db9336dd78e8265a2d46cc59a9e446011dc7" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ *ルーチンは、成功すると&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;を返し、何か問題が&lt;a href=&quot;rescode&quot;&gt;発生した&lt;/a&gt;場合はエラーコードを返します。文字列またはBLOBのサイズが&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）または&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;によって課された制限を超える場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;が返されることがあります。パラメータインデックスが範囲外の場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt;が返されます。&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;は、malloc（）が失敗した場合に返されます。</target>
        </trans-unit>
        <trans-unit id="eb0da7fe06be85118ba3dab99ff46185b6777bbe" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ *ルーチンは、成功すると&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返し、何か問題が&lt;a href=&quot;../rescode&quot;&gt;発生した&lt;/a&gt;場合はエラーコードを返します。文字列またはBLOBのサイズが&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）または&lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;によって課された制限を超える場合、&lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;が返されることがあります。パラメータインデックスが範囲外の場合、&lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt;が返されます。&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;は、malloc（）が失敗した場合に返されます。</target>
        </trans-unit>
        <trans-unit id="6f71713542739e9593b1adb467245384ef671786" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name（P、N）インタフェースはN番目の名前を返す&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQLパラメータを&lt;/a&gt;して&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備された文&lt;/a&gt;「？NNN」の形のP. SQLパラメータまたは「：AAA」または「@AAA」または「$ AAAは」持っています文字列 &quot;？NNN&quot;または &quot;：AAA&quot;または &quot;@AAA&quot;または &quot;$ AAA&quot;である名前。つまり、最初の「：」または「$」または「@」または「？」名前の一部として含まれています。 「？」形式のパラメータ次の整数がない場合は名前がなく、「無名」または「匿名パラメーター」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="8f7478b82c93544aa582bd52cdb8be854dddfaed" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name（P、N）インタフェースはN番目の名前を返す&lt;a href=&quot;bind_blob&quot;&gt;SQLパラメータを&lt;/a&gt;して&lt;a href=&quot;stmt&quot;&gt;準備された文&lt;/a&gt;「？NNN」の形のP. SQLパラメータまたは「：AAA」または「@AAA」または「$ AAAは」持っています文字列 &quot;？NNN&quot;または &quot;：AAA&quot;または &quot;@AAA&quot;または &quot;$ AAA&quot;である名前。つまり、最初の「：」または「$」または「@」または「？」名前の一部として含まれています。 「？」形式のパラメータ次の整数がない場合は名前がなく、「無名」または「匿名パラメーター」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="2f7ba9ace88be98840180479bfcb11ff0ebe16ce" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer（S、I、P、T、D）ルーチンは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt; S のI番目のパラメーターのSQL値をNULLにしますが、T型のポインターPにも関連付けます。DはNULL Pのデストラクタ関数へのポインタまたはポインタ。SQLiteは、Pの使用が終了すると、単一の引数PでデストラクタDを呼び出します。Tパラメータは、静的文字列、できれば文字列リテラルである必要があります。 sqlite3_bind_pointer（）ルーチンは、SQLite 3.20.0に追加された&lt;a href=&quot;bindptr&quot;&gt;ポインター受け渡しインターフェースの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="658c91c6c69fa0e297b2600c0a7ae1e8d41b306a" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer（S、I、P、T、D）ルーチンは、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt; S のI番目のパラメーターのSQL値をNULLにしますが、T型のポインターPにも関連付けます。DはNULL Pのデストラクタ関数へのポインタまたはポインタ。SQLiteは、Pの使用が終了すると、単一の引数PでデストラクタDを呼び出します。Tパラメータは、静的文字列、できれば文字列リテラルである必要があります。 sqlite3_bind_pointer（）ルーチンは、SQLite 3.20.0に追加された&lt;a href=&quot;../bindptr&quot;&gt;ポインター受け渡しインターフェースの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="6397a7b2569f0831356316d22abee5d260da2f56" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob（）ルーチンは、ゼロで埋められた長さNのBLOBをバインドします。zeroblobは、処理中に一定量のメモリ（サイズを保持するための整数）を使用します。Zeroblobsは、後で&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;インクリメンタルBLOB I / O&lt;/a&gt;ルーチンを使用してコンテンツが書き込まれるBLOBのプレースホルダーとして機能することを目的としています。zeroblobの負の値は、長さがゼロのBLOBになります。</target>
        </trans-unit>
        <trans-unit id="c43ef2df76e0304e4b4beb3c8e7c5dbefc82b96b" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob（）ルーチンは、ゼロで埋められた長さNのBLOBをバインドします。zeroblobは、処理中に一定量のメモリ（サイズを保持するための整数）を使用します。Zeroblobsは、後で&lt;a href=&quot;blob_open&quot;&gt;インクリメンタルBLOB I / O&lt;/a&gt;ルーチンを使用してコンテンツが書き込まれるBLOBのプレースホルダーとして機能することを目的としています。zeroblobの負の値は、長さがゼロのBLOBになります。</target>
        </trans-unit>
        <trans-unit id="3d2cce49ac08682bc109d88559efafcb5bc906c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler（D、X、P）ルーチンは、別のスレッドまたはプロセスでテーブルがロックされているときに、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dに関連付けられているデータベーステーブルにアクセスしようとすると、引数Pで呼び出されるコールバック関数Xを設定します。sqlite3_busy_handler（）インターフェースは&lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;を実装するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d3363e5f93709d191e40f4d06f477acdab0e375e" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler（D、X、P）ルーチンは、別のスレッドまたはプロセスでテーブルがロックされているときに、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dに関連付けられているデータベーステーブルにアクセスしようとすると、引数Pで呼び出されるコールバック関数Xを設定します。sqlite3_busy_handler（）インターフェースは&lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;と&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;を実装するために使用されます。</target>
        </trans-unit>
        <trans-unit id="e8d93853c1f8ff5d06942fd5a08d82650ba96772" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close（）とsqlite3_close_v2（）ルーチンは、&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクトのデストラクタです。 sqlite3_closeの呼び出し（）およびsqlite3_close_v2（）の戻り&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;場合は&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3の&lt;/a&gt;オブジェクトが正常に破壊され、関連するすべてのリソースの割り当てが解除されています。</target>
        </trans-unit>
        <trans-unit id="c3b661e4a47ed928f3b7e88dd929f7831fe5385b" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close（）とsqlite3_close_v2（）ルーチンは、&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクトのデストラクタです。 sqlite3_closeの呼び出し（）およびsqlite3_close_v2（）の戻り&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;場合は&lt;a href=&quot;sqlite3&quot;&gt;sqlite3の&lt;/a&gt;オブジェクトが正常に破壊され、関連するすべてのリソースの割り当てが解除されています。</target>
        </trans-unit>
        <trans-unit id="2e35c3e04c8fe7269b95a0494cefdd5cde7acf02" translate="yes" xml:space="preserve">
          <source>The sqlite3_collation_needed() routine registers a callback which the database engine will invoke if it encounters an unknown collating sequence. The callback can lookup an appropriate comparison function and invoke sqlite_3_create_collation() as needed. The fourth parameter to the callback is the name of the collating sequence in UTF-8. For sqlite3_collation_need16() the callback sends the collating sequence name in UTF-16 host byte order.</source>
          <target state="translated">sqlite3_collation_needed()ルーチンは、未知の照合順序に遭遇した場合にデータベースエンジンが呼び出すコールバックを登録します。コールバックは適切な比較関数を検索し、必要に応じてsqlite_3_create_collation()を呼び出すことができます。コールバックの4番目のパラメータはUTF-8での照合シーケンスの名前です。sqlite3_collation_need16()では、コールバックは照合シーケンス名をUTF-16ホストバイト順で送信します。</target>
        </trans-unit>
        <trans-unit id="289668a545984e8fa7c4b426fa20f850363028a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_decltype() routine returns text which is the declared type of the column in the CREATE TABLE statement. For an expression, the return type is an empty string. sqlite3_column_name() returns the name of the Nth column. sqlite3_column_bytes() returns the number of bytes in a column that has type BLOB or the number of bytes in a TEXT string with UTF-8 encoding. sqlite3_column_bytes16() returns the same value for BLOBs but for TEXT strings returns the number of bytes in a UTF-16 encoding. sqlite3_column_blob() return BLOB data. sqlite3_column_text() return TEXT data as UTF-8. sqlite3_column_text16() return TEXT data as UTF-16. sqlite3_column_int() return INTEGER data in the host machines native integer format. sqlite3_column_int64() returns 64-bit INTEGER data. Finally, sqlite3_column_double() return floating point data.</source>
          <target state="translated">sqlite3_column_decltype()ルーチンはCREATE TABLE文で宣言されたカラムの型であるテキストを返します。sqlite3_column_bytes()はBLOB型のカラムのバイト数、またはUTF-8エンコーディングのTEXT文字列のバイト数を返します。 sqlite3_column_bytes16()はBLOBに対しては同じ値を返しますが、TEXT文字列に対してはUTF-16エンコーディングのバイト数を返します。sqlite3_column_blob()BLOBデータを返します。 sqlite3_column_text()TEXTデータをUTF-8で返します。 sqlite3_column_text16()TEXTデータをUTF-16で返します。 sqlite3_column_int()INTEGERデータをホストマシンのネイティブ整数形式で返します。最後に、sqlite3_column_double()は浮動小数点データを返します。</target>
        </trans-unit>
        <trans-unit id="a9b38d21f857b4d104b01ccf828564edcab9302b" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type（）ルーチンは、結果列の初期データ型のデータ型&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;コード&lt;/a&gt;を返します。戻り値は、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULLの&lt;/a&gt;いずれかです。 sqlite3_column_type（）の戻り値を使用して、最初の6つのインターフェースのどれを使用して列の値を抽出するかを決定できます。 sqlite3_column_type（）によって返される値は、問題の値の自動型変換が発生していない場合にのみ意味があります。型変換後のsqlite3_column_type（）の呼び出し結果は、害はありませんが未定義です。 SQLiteの将来のバージョンでは、型変換後にsqlite3_column_type（）の動作が変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="d87c623fe2ec1f08f5218d69ec07d1b6f1fe406e" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type（）ルーチンは、結果列の初期データ型のデータ型&lt;a href=&quot;c_blob&quot;&gt;コード&lt;/a&gt;を返します。戻り値は、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;、または&lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULLの&lt;/a&gt;いずれかです。 sqlite3_column_type（）の戻り値を使用して、最初の6つのインターフェースのどれを使用して列の値を抽出するかを決定できます。 sqlite3_column_type（）によって返される値は、問題の値の自動型変換が発生していない場合にのみ意味があります。型変換後のsqlite3_column_type（）の呼び出し結果は、害はありませんが未定義です。 SQLiteの将来のバージョンでは、型変換後にsqlite3_column_type（）の動作が変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="80c9429e83e0f6600057106ffc072b05d6e8df14" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook（）インターフェースは、トランザクションが&lt;a href=&quot;../lang_transaction&quot;&gt;コミット&lt;/a&gt;されるたびに呼び出されるコールバック関数を登録します。同じデータベース接続に対するsqlite3_commit_hook（）への以前の呼び出しによって設定されたコールバックはすべてオーバーライドされます。 sqlite3_rollback_hook（）インターフェースは、トランザクションが&lt;a href=&quot;../lang_transaction&quot;&gt;ロールバック&lt;/a&gt;されるたびに呼び出されるコールバック関数を登録します。同じデータベース接続のsqlite3_rollback_hook（）への以前の呼び出しによって設定されたコールバックは上書きされます。 pArg引数はコールバックに渡されます。コミットフック関数のコールバックがゼロ以外を返す場合、コミットはロールバックに変換されます。</target>
        </trans-unit>
        <trans-unit id="c831f98581f1e28276e947cc54e55e8093cff2bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook（）インターフェースは、トランザクションが&lt;a href=&quot;lang_transaction&quot;&gt;コミット&lt;/a&gt;されるたびに呼び出されるコールバック関数を登録します。同じデータベース接続に対するsqlite3_commit_hook（）への以前の呼び出しによって設定されたコールバックはすべてオーバーライドされます。 sqlite3_rollback_hook（）インターフェースは、トランザクションが&lt;a href=&quot;lang_transaction&quot;&gt;ロールバック&lt;/a&gt;されるたびに呼び出されるコールバック関数を登録します。同じデータベース接続のsqlite3_rollback_hook（）への以前の呼び出しによって設定されたコールバックは上書きされます。 pArg引数はコールバックに渡されます。コミットフック関数のコールバックがゼロ以外を返す場合、コミットはロールバックに変換されます。</target>
        </trans-unit>
        <trans-unit id="8ed0ff1b29d3e198ebfc7c54c6d04128fb45e5b9" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook（D、C、P）およびsqlite3_rollback_hook（D、C、P）関数は、同じ&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; D での同じ関数の前の呼び出しからのP引数、またはDの各関数の最初の呼び出しではNULLを返します。</target>
        </trans-unit>
        <trans-unit id="5c814d040fa0b2376c6a44e987d8d06f8d405641" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook（D、C、P）およびsqlite3_rollback_hook（D、C、P）関数は、同じ&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; D での同じ関数の前の呼び出しからのP引数、またはDの各関数の最初の呼び出しではNULLを返します。</target>
        </trans-unit>
        <trans-unit id="a783ef29506da5187d0b6a8b529c5db8a199c982" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_get() function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string. If N is out of range, sqlite3_compileoption_get() returns a NULL pointer. The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get().</source>
          <target state="translated">sqlite3_compileoption_get()関数は、N番目のコンパイル時オプション文字列を返すことで、コンパイル時に定義されたオプションのリストを反復処理することができます。Nが範囲外の場合、sqlite3_compileoption_get()はNULLポインタを返します。sqlite3_compileoption_get()が返す文字列からはSQLITE_接頭辞は省略されます。</target>
        </trans-unit>
        <trans-unit id="39c27e864f7c32b9ceed46ceee3feba79ed9e6fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_used() function returns 0 or 1 indicating whether the specified option was defined at compile time. The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used().</source>
          <target state="translated">sqlite3_compileoption_used()関数は、指定されたオプションがコンパイル時に定義されていたかどうかを示す0または1を返します。sqlite3_compileoption_used()に渡されるオプション名には、SQLITE_接頭辞を省略することができます。</target>
        </trans-unit>
        <trans-unit id="c2f7b71d769d28cabe75800e2f0fc786a0e3ca05" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application. The default configuration is recommended for most applications and so this routine is usually not necessary. It is provided to support rare applications with unusual needs.</source>
          <target state="translated">sqlite3_config()インターフェイスは、アプリケーションの特定のニーズに合わせてSQLiteを調整するために、SQLiteのグローバルな設定を変更するために使用されます。ほとんどのアプリケーションではデフォルトの設定が推奨されているので、このルーチンは通常必要ありません。これは、特別なニーズを持つ稀なアプリケーションをサポートするために提供されています。</target>
        </trans-unit>
        <trans-unit id="2a43551c13014713b84ff3176d603e20a0bb2d0e" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config（）インターフェースは、&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;を使用したライブラリの初期化前、または&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によるシャットダウン後にのみ呼び出すことができます。sqlite3_config（）の後に呼び出された場合&lt;a href=&quot;#sqlite3_initialize&quot;&gt;（sqlite3_initialize）&lt;/a&gt;と前&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（） &lt;/a&gt;、それはSQLITE_MISUSEを返します。ただし、sqlite3_config（）は、アプリケーション定義の&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init（）の&lt;/a&gt;実装の一部として呼び出すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="950f596cd61399b38213d68d8e3371f1294cd97c" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config（）インターフェースは、&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;を使用したライブラリの初期化前、または&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によるシャットダウン後にのみ呼び出すことができます。sqlite3_config（）の後に呼び出された場合&lt;a href=&quot;initialize&quot;&gt;（sqlite3_initialize）&lt;/a&gt;と前&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（） &lt;/a&gt;、それはSQLITE_MISUSEを返します。ただし、sqlite3_config（）は、アプリケーション定義の&lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init（）の&lt;/a&gt;実装の一部として呼び出すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f36e7397009cd60c7259be5a8cbdeb80264ff811" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle（）インターフェースは、最初にアプリケーションで定義された関数を登録した&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;ルーチンの&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;（1番目のパラメーター）へのポインターのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="04b3afa93b5033ef2c02acd3a1ef18374b3a066e" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle（）インターフェースは、最初にアプリケーションで定義された関数を登録した&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;と&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;ルーチンの&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;（1番目のパラメーター）へのポインターのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="0b0f49ec423453d8567eeff6ab2f843591a04245" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function honors the SQLITE_UTF16_ALIGNED flag.</source>
          <target state="translated">sqlite3_create_collation()関数はSQLITE_UTF16_ALIGNEDフラグを保持します。</target>
        </trans-unit>
        <trans-unit id="0e46987511170cbb4e8e90d14cfd9fe052087146" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function specifies a collating sequence name and a comparison function to implement that collating sequence. The comparison function is only used for comparing text values. The eTextRep parameter is one of SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, or SQLITE_ANY to specify which text representation the comparison function works with. Separate comparison functions can exist for the same collating sequence for each of the UTF-8, UTF-16LE and UTF-16BE text representations. The sqlite3_create_collation16() works like sqlite3_create_collation() except that the collation name is specified in UTF-16 host byte order instead of in UTF-8.</source>
          <target state="translated">sqlite3_create_collation()関数は照合順序名と、その照合順序を実装するための比較関数を指定します。比較関数はテキスト値の比較にのみ使用されます。eTextRepパラメータはSQLITE_UTF8、SQLITE_UTF16LE、SQLITE_UTF16BE、またはSQLITE_ANYのいずれかで、比較関数がどのテキスト表現で動作するかを指定します。UTF-8、UTF-16LE、UTF-16BEの各テキスト表現に対して、同じ照合順序に対して別々の比較関数が存在することができます。sqlite3_create_collation16()はsqlite3_create_collation()と同じように動作しますが、照合名がUTF-8ではなくUTF-16ホストバイト順で指定されます。</target>
        </trans-unit>
        <trans-unit id="3bb1bc030c0ecaf171e6e7837d4fc5ad509b9304" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）はsqlite3_create_collat​​ion（）と同様に機能し、照合機能が削除されたときにxDestroyコールバックがpArgで呼び出される点が異なります。照合関数は、後で照合作成関数の呼び出しによってオーバーライドされたとき、または&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;を使用して&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;が閉じられたときに削除されます。</target>
        </trans-unit>
        <trans-unit id="cce8a06023084f98541458166466b478b68c97fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）はsqlite3_create_collat​​ion（）と同様に機能し、照合機能が削除されたときにxDestroyコールバックがpArgで呼び出される点が異なります。照合関数は、後で照合作成関数の呼び出しによってオーバーライドされたとき、または&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;を使用して&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;が閉じられたときに削除されます。</target>
        </trans-unit>
        <trans-unit id="2321a78d45e7f791f5be9bd5eeeecdd73b61cbff" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_module_v2() interface has a fifth parameter which is a pointer to a destructor for the pClientData. SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the pClientData pointer. The destructor will also be invoked if the call to sqlite3_create_module_v2() fails. The sqlite3_create_module() interface is equivalent to sqlite3_create_module_v2() with a NULL destructor.</source>
          <target state="translated">sqlite3_create_module_v2()インタフェースには5番目のパラメータがあり、これはpClientDataのデストラクタへのポインタです。SQLiteは、SQLiteがpClientDataポインタを必要としなくなったときに、(NULLでなければ)デストラクタ関数を呼び出します。デストラクタは、sqlite3_create_module_v2()の呼び出しが失敗した場合にも呼び出されます。sqlite3_create_module()インターフェースは sqlite3_create_module_v2()と同じで、デストラクタは NULL です。</target>
        </trans-unit>
        <trans-unit id="b23578428cca6b0b7cc9f351266849d54d3f4ac7" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）インターフェイスは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt; Pの結果セットの現在の行の列数を返します。準備されたステートメントPが返す準備ができていない場合&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;（&lt;/a&gt;インターフェイスのsqlite3_column _ *（）を呼び出して）、sqlite3_data_count（ P）は0を返します。sqlite3_data_count（P）ルーチンは、PがNULLポインターの場合も0を返します。 sqlite3_data_count（P）リターン0の前の呼び出し場合&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）が返さ&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONEを&lt;/a&gt;。&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuumの&lt;/a&gt;場合を除いて、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）への以前の呼び出しがSQLITE_ROWを返した場合、sqlite3_data_count（P）は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;ゼロ&lt;/a&gt;以外を返します。このマルチステッププラグマの各ステップは0列のデータを返すため、常にゼロを返します。</target>
        </trans-unit>
        <trans-unit id="0331c5159620074031eabe2d2fffeb3879925815" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）インターフェイスは、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt; Pの結果セットの現在の行の列数を返します。準備されたステートメントPが返す準備ができていない場合&lt;a href=&quot;column_blob&quot;&gt;（&lt;/a&gt;インターフェイスのsqlite3_column _ *（）を呼び出して）、sqlite3_data_count（ P）は0を返します。sqlite3_data_count（P）ルーチンは、PがNULLポインターの場合も0を返します。 sqlite3_data_count（P）リターン0の前の呼び出し場合&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）が返さ&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONEを&lt;/a&gt;。&lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuumの&lt;/a&gt;場合を除いて、&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）への以前の呼び出しがSQLITE_ROWを返した場合、sqlite3_data_count（P）は&lt;a href=&quot;../rescode#row&quot;&gt;ゼロ&lt;/a&gt;以外を返します。このマルチステッププラグマの各ステップは0列のデータを返すため、常にゼロを返します。</target>
        </trans-unit>
        <trans-unit id="043836a9d52018cfd95036ef1de8601c0dd65b27" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config（）インターフェースは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続の&lt;/a&gt;構成を変更するために使用されます。インターフェイスは&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）に&lt;/a&gt;似ていますが、変更が単一の&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;（最初の引数で指定）に適用される点が異なります。</target>
        </trans-unit>
        <trans-unit id="cb382b8043f6bd41fb4e955562ae2dd8de8821a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config（）インターフェースは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続の&lt;/a&gt;構成を変更するために使用されます。インターフェイスは&lt;a href=&quot;config&quot;&gt;sqlite3_config（）に&lt;/a&gt;似ていますが、変更が単一の&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;（最初の引数で指定）に適用される点が異なります。</target>
        </trans-unit>
        <trans-unit id="d9890e9099b39efa9f23ed1209f98fc2abd695d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to a filename associated with database N of connection D. The main database file has the name &quot;main&quot;. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">sqlite3_db_filename(D,N)インタフェースは、接続DのデータベースNに関連付けられたファイル名へのポインタを返します。データベース接続DにアタッチされたデータベースNが存在しない場合、またはデータベースNが一時データベースまたはインメモリデータベースである場合、この関数はNULLポインタか空文字列を返します。</target>
        </trans-unit>
        <trans-unit id="7a0142f7765d452e556a6d1ade538189bbf023a1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handleインターフェースは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメントが&lt;/a&gt;属する&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルを返します。&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; sqlite3_db_handleで返さは同じである&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;の最初の引数た&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;最初の場所でのステートメントを作成するために使用されたコール（またはその変種）。</target>
        </trans-unit>
        <trans-unit id="0ed4944069eec7d7c0e7904b6909ffc71d6a37af" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handleインターフェースは、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメントが&lt;/a&gt;属する&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルを返します。&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; sqlite3_db_handleで返さは同じである&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;の最初の引数た&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;最初の場所でのステートメントを作成するために使用されたコール（またはその変種）。</target>
        </trans-unit>
        <trans-unit id="f13e3d008759351c9d014a67b0c7d66c909c38ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_readonly(D,N) interface returns 1 if the database N of connection D is read-only, 0 if it is read/write, or -1 if N is not the name of a database on connection D.</source>
          <target state="translated">sqlite3_db_readonly(D,N)インタフェースは、接続DのデータベースNが読み取り専用であれば1を、読み取り/書き込みであれば0を、Nが接続Dのデータベース名でなければ-1を返します。</target>
        </trans-unit>
        <trans-unit id="7c54e0312a49676acc8e0fa5a98fa6c3ca389049" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory（D）インターフェイスは、データベース接続Dから可能な限り多くのヒープメモリを解放しようとします&lt;a href=&quot;#sqlite3_release_memory&quot;&gt;。sqlite3_release_memory（）&lt;/a&gt;インターフェイスとは異なり、このインターフェイスは、&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;コンパイル時オプションが省略されている場合でも有効です。</target>
        </trans-unit>
        <trans-unit id="a4505b330dae36966abd878a7a5251bb10a809a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory（D）インターフェイスは、データベース接続Dから可能な限り多くのヒープメモリを解放しようとします&lt;a href=&quot;release_memory&quot;&gt;。sqlite3_release_memory（）&lt;/a&gt;インターフェイスとは異なり、このインターフェイスは、&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;コンパイル時オプションが省略されている場合でも有効です。</target>
        </trans-unit>
        <trans-unit id="83634ce6a2d174966fca0f07d2eb6e5e52439e9f" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status（）ルーチンは、成功するとSQLITE_OKを返し、失敗するとゼロ以外の&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="7babdc84886f95b16b07a064461180aa8e231247" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status（）ルーチンは、成功するとSQLITE_OKを返し、失敗するとゼロ以外の&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="18d47ae58f8b29dbac7701bb014dc19e22eadf62" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize() interface will fail with SQLITE_BUSY if the database is currently in a read transaction or is involved in a backup operation.</source>
          <target state="translated">sqlite3_deserialize()インターフェイスは、データベースが現在リードトランザクションにあるか、バックアップ操作に関与している場合、SQLITE_BUSYで失敗します。</target>
        </trans-unit>
        <trans-unit id="12340c8333dc6a82eca44a1f4c8bbf0434fac375" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize（D、S、P、N、M、F）インターフェイスは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; DをデータベースSから切断し、Pに含まれるシリアル化に基づいてSをメモリ内データベースとして再度開きます。シリアル化されたデータベースPはNサイズのバイト。MはバッファPのサイズで、Nより大きくなる可能性があります。MがNより大きく、SQLITE_DESERIALIZE_READONLYビットがFに設定されていない場合、SQLiteは、メモリ内データベースにコンテンツを追加できます。合計サイズはMバイトを超えません。</target>
        </trans-unit>
        <trans-unit id="afac5ec67e0561a540471ae51b94788f3734ed79" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize（D、S、P、N、M、F）インターフェイスは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; DをデータベースSから切断し、Pに含まれるシリアル化に基づいてSをメモリ内データベースとして再度開きます。シリアル化されたデータベースPはNサイズのバイト。MはバッファPのサイズで、Nより大きくなる可能性があります。MがNより大きく、SQLITE_DESERIALIZE_READONLYビットがFに設定されていない場合、SQLiteは、メモリ内データベースにコンテンツを追加できます。合計サイズはMバイトを超えません。</target>
        </trans-unit>
        <trans-unit id="6ae05681a8b59259daa468a1d8590729337a135a" translate="yes" xml:space="preserve">
          <source>The sqlite3_drop_modules(D,L) interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer. If the L parameter is NULL, then all virtual table modules are removed.</source>
          <target state="translated">sqlite3_drop_modules(D,L)インタフェースは、リストLで指定されたものを除く全ての仮想テーブルモジュールをデータベース接続Dから削除します。 LパラメータはNULLか文字列へのポインタの配列へのポインタでなければなりません。L パラメータが NULL の場合、すべての仮想テーブルモジュールが削除されます。</target>
        </trans-unit>
        <trans-unit id="cb17fe8b042f1bd6f76a39ed23dd1524edfc2345" translate="yes" xml:space="preserve">
          <source>The sqlite3_errcode() routine returns a result code for the most recent major API call. sqlite3_errmsg() returns an English-language text error message for the most recent error. The error message is represented in UTF-8 and will be ephemeral - it could disappear on the next call to any SQLite API function. sqlite3_errmsg16() works like sqlite3_errmsg() except that it returns the error message represented as UTF-16 in host native byte order.</source>
          <target state="translated">sqlite3_errrcode()ルーチンは、直近のメジャーAPIコールの結果コードを返します。 sqlite3_errmsg()は、直近のエラーに対する英語のテキストエラーメッセージを返します。sqlite3_errmsg16()はsqlite3_errmsg()と同じように動作しますが、ホストのネイティブバイト順でUTF-16で表現されたエラーメッセージを返します。</target>
        </trans-unit>
        <trans-unit id="5e0d9cf7c1277961ee0db98705525eacc5bb425f" translate="yes" xml:space="preserve">
          <source>The sqlite3_errmsg() and sqlite3_errmsg16() return English-language text that describes the error, as either UTF-8 or UTF-16 respectively. Memory to hold the error message string is managed internally. The application does not need to worry about freeing the result. However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.</source>
          <target state="translated">sqlite3_errmsg()とsqlite3_errmsg16()は、エラーを記述する英語のテキストを、それぞれUTF-8またはUTF-16で返します。エラーメッセージ文字列を保持するメモリは内部で管理されます。アプリケーションは結果の解放を気にする必要はありません。ただし、エラー文字列は、後続の他の SQLite インターフェース関数の呼び出しによって上書きされたり、解放されたりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="a3b2d05546afbeecb20b8fe87e3f3189bfedb642" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr（）インターフェースは、&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;を説明する英語のテキストをUTF-8として返します。エラーメッセージ文字列を保持するメモリは内部で管理されており、アプリケーションで解放してはなりません。</target>
        </trans-unit>
        <trans-unit id="3185f0fefecbff2d0db8b69bac9298083b70809e" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr（）インターフェースは、&lt;a href=&quot;rescode&quot;&gt;結果コード&lt;/a&gt;を説明する英語のテキストをUTF-8として返します。エラーメッセージ文字列を保持するメモリは内部で管理されており、アプリケーションで解放してはなりません。</target>
        </trans-unit>
        <trans-unit id="eec19de3d00e4cd6319cb02ddf72d5b612e30300" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec（）インターフェースは約コンビニエンスラッパーである&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（） &lt;/a&gt;、及び&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt; Cコードの多くを使用することなく、SQLの複数のステートメントを実行するアプリケーションを可能にします、。</target>
        </trans-unit>
        <trans-unit id="9a4e88bd32574fff7b2361feb6cf37710d7194a2" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec（）インターフェースは約コンビニエンスラッパーである&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（） &lt;/a&gt;、&lt;a href=&quot;step&quot;&gt;sqlite3_step（） &lt;/a&gt;、及び&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt; Cコードの多くを使用することなく、SQLの複数のステートメントを実行するアプリケーションを可能にします、。</target>
        </trans-unit>
        <trans-unit id="5f6ecb5327784e2b3ab3076a060e42400e8e6e49" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec（）インターフェースは、1番目の引数として渡された&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続の&lt;/a&gt;コンテキストで、2番目の引数に渡されたゼロ以上のUTF-8エンコードのセミコロン区切りのSQLステートメントを実行します。sqlite3_exec（）の3番目の引数のコールバック関数がNULLでない場合、評価されたSQLステートメントからの結果行ごとに呼び出されます。sqlite3_exec（）の4番目の引数は、各コールバック呼び出しの1番目の引数に中継されます。sqlite3_exec（）へのコールバックポインターがNULLの場合、コールバックは呼び出されず、結果行は無視されます。</target>
        </trans-unit>
        <trans-unit id="7f2bf987e70ab4f6565417a4f7295b79e8706b9e" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec（）インターフェースは、1番目の引数として渡された&lt;a href=&quot;sqlite3&quot;&gt;データベース接続の&lt;/a&gt;コンテキストで、2番目の引数に渡されたゼロ以上のUTF-8エンコードのセミコロン区切りのSQLステートメントを実行します。sqlite3_exec（）の3番目の引数のコールバック関数がNULLでない場合、評価されたSQLステートメントからの結果行ごとに呼び出されます。sqlite3_exec（）の4番目の引数は、各コールバック呼び出しの1番目の引数に中継されます。sqlite3_exec（）へのコールバックポインターがNULLの場合、コールバックは呼び出されず、結果行は無視されます。</target>
        </trans-unit>
        <trans-unit id="fdc80de144729ab29ec768dc45f521935b24167a" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">結果を保持するのに十分なメモリがない場合、または結果が&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;によって決定される最大文字列長を超える場合、sqlite3_expanded_sql（）インターフェースはNULLを返します。</target>
        </trans-unit>
        <trans-unit id="253eafa1da6e36def799917e15566e8c664899fe" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">結果を保持するのに十分なメモリがない場合、または結果が&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;によって決定される最大文字列長を超える場合、sqlite3_expanded_sql（）インターフェースはNULLを返します。</target>
        </trans-unit>
        <trans-unit id="1d1fd4c0ad3995d89a0ef41f1f46affc2269eba4" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes（）ルーチンは、SQLiteの&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;機能を有効または無効にします。履歴互換性のために、拡張結果コードはデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="904ab00e0ae19fa09117889888e1162471d32017" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes（）ルーチンは、SQLiteの&lt;a href=&quot;rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;機能を有効または無効にします。履歴互換性のために、拡張結果コードはデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="5daeea1eac71cd621bf8b80af259a724f2e831b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_finalize（）関数は、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;を削除するために呼び出されます。ステートメントの最新の評価でエラーが発生しなかった場合、またはステートメントが評価されなかった場合、sqlite3_finalize（）はSQLITE_OKを返します。ステートメントSの最新の評価が失敗した場合、sqlite3_finalize（S）は適切な&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="74837217c620c1e41ee1e321a9ad17968e0d6486" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_finalize（）関数は、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;を削除するために呼び出されます。ステートメントの最新の評価でエラーが発生しなかった場合、またはステートメントが評価されなかった場合、sqlite3_finalize（）はSQLITE_OKを返します。ステートメントSの最新の評価が失敗した場合、sqlite3_finalize（S）は適切な&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="cfdc64000a1f68dd938d60f9bb70e02c947748fd" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize（S）ルーチンはのライフサイクル中の任意の時点で呼び出すことができ&lt;a href=&quot;#sqlite3_stmt&quot;&gt;、準備されたステートメントの&lt;/a&gt; S：文Sは、これまでに1回以上呼び出した後、評価される前に&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（） &lt;/a&gt;、またはのいずれかの呼び出し後&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;に関係なく、かどうかのステートメントは実行を完了していません。</target>
        </trans-unit>
        <trans-unit id="1dec5478469a2333006cfdfd3bbed8c6613161e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize（S）ルーチンはのライフサイクル中の任意の時点で呼び出すことができ&lt;a href=&quot;stmt&quot;&gt;、準備されたステートメントの&lt;/a&gt; S：文Sは、これまでに1回以上呼び出した後、評価される前に&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（） &lt;/a&gt;、またはのいずれかの呼び出し後&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;に関係なく、かどうかのステートメントは実行を完了していません。</target>
        </trans-unit>
        <trans-unit id="0a8a4dfedb4d5de550dae28093210eb5e1165c50" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_autocommit（）インターフェイスは、指定されたデータベース接続が自動コミットモードであるかどうかに関係なく、それぞれゼロ以外またはゼロを返します。自動コミットモードはデフォルトでオンになっています。自動コミットモードは、&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;ステートメントによって無効になります。自動コミットモードは、&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;または&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;によって再び有効になります。</target>
        </trans-unit>
        <trans-unit id="c6407bbe024eecae19905f3987328770ebef955e" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_autocommit（）インターフェイスは、指定されたデータベース接続が自動コミットモードであるかどうかに関係なく、それぞれゼロ以外またはゼロを返します。自動コミットモードはデフォルトでオンになっています。自動コミットモードは、&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;ステートメントによって無効になります。自動コミットモードは、&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;または&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;によって再び有効になります。</target>
        </trans-unit>
        <trans-unit id="c54753db8fb054877250927a699aaaed04734d2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument value to the application-defined function. N is zero for the left-most function argument. If there is no metadata associated with the function argument, the sqlite3_get_auxdata(C,N) interface returns a NULL pointer.</source>
          <target state="translated">sqlite3_get_auxdata(C,N)インタフェースは、アプリケーション定義関数のN番目の引数の値を持つsqlite3_set_auxdata(C,N,P,X)関数によって関連付けられたメタデータへのポインタを返します。Nは左端の関数の引数の値は0です。関数の引数に関連付けられたメタデータがない場合、sqlite3_get_auxdata(C,N)インタフェースはNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="35597daf57a6a6a4650eb220c2a29fa2c91a59d0" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() function evaluates one or more semicolon-separated SQL statements in the zero-terminated UTF-8 string of its 2nd parameter and returns a result table to the pointer given in its 3rd parameter.</source>
          <target state="translated">sqlite3_get_table()関数は、2番目のパラメータのゼロ終端のUTF-8文字列で1つ以上のセミコロンで区切られたSQL文を評価し、3番目のパラメータで与えられたポインタに結果テーブルを返します。</target>
        </trans-unit>
        <trans-unit id="acdf7ebaf34cc7cf8bdf020e8dc45c52df0d628c" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table（）インターフェースをラッパーとして実装されて&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（） &lt;/a&gt;。sqlite3_get_table（）ルーチンは、SQLiteの内部データ構造にアクセスできません。ここで定義されたパブリックインターフェイスのみを使用します。結果として、内部&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;呼び出しの外側のラッパーレイヤーで発生したエラーは、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;への後続の呼び出しには反映されません。</target>
        </trans-unit>
        <trans-unit id="566ec671a5bf78f09b92642b451438dd26c86350" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table（）インターフェースをラッパーとして実装されて&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（） &lt;/a&gt;。sqlite3_get_table（）ルーチンは、SQLiteの内部データ構造にアクセスできません。ここで定義されたパブリックインターフェイスのみを使用します。結果として、内部&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;呼び出しの外側のラッパーレイヤーで発生したエラーは、&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;または&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;への後続の呼び出しには反映されません。</target>
        </trans-unit>
        <trans-unit id="5a1053b2bb267ced2e3415b8b71b02dc7bb0d976" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info構造とそのサブ構造は、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;インターフェイスの一部として使用され、&lt;a href=&quot;module&quot;&gt;仮想テーブルモジュールの&lt;/a&gt;&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;メソッドに情報を渡したり、xBestIndexメソッドからの応答を受け取ったりします。**入力**の下のフィールドはxBestIndexへの入力であり、読み取り専用です。xBestIndexはその結果を**出力**フィールドに挿入します。</target>
        </trans-unit>
        <trans-unit id="779db7516101e2733ab83d988869d6422e837e26" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info構造とそのサブ構造は、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;インターフェイスの一部として使用され、&lt;a href=&quot;#sqlite3_module&quot;&gt;仮想テーブルモジュールの&lt;/a&gt;&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;メソッドに情報を渡したり、xBestIndexメソッドからの応答を受け取ったりします。**入力**の下のフィールドはxBestIndexへの入力であり、読み取り専用です。xBestIndexはその結果を**出力**フィールドに挿入します。</target>
        </trans-unit>
        <trans-unit id="f7b3a693ac538b125172c62d75cc7d377f31b955" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize（）インターフェースはスレッドセーフですが、sqlite3_shutdown（）はそうではありません。sqlite3_shutdown（）インターフェースは、単一のスレッドからのみ呼び出す必要があります。sqlite3_shutdown（）を呼び出す前に、開いているすべての&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続を&lt;/a&gt;閉じ、他のすべてのSQLiteリソースの割り当てを解除する必要があります。</target>
        </trans-unit>
        <trans-unit id="88e442978d61726b76c4c6bd7b1f8a87808c119b" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize（）インターフェースはスレッドセーフですが、sqlite3_shutdown（）はそうではありません。sqlite3_shutdown（）インターフェースは、単一のスレッドからのみ呼び出す必要があります。sqlite3_shutdown（）を呼び出す前に、開いているすべての&lt;a href=&quot;sqlite3&quot;&gt;データベース接続を&lt;/a&gt;閉じ、他のすべてのSQLiteリソースの割り当てを解除する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e2957684efb0782443d87103a368a9305c21dfe" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine initializes the SQLite library. The sqlite3_shutdown() routine deallocates any resources that were allocated by sqlite3_initialize(). These routines are designed to aid in process initialization and shutdown on embedded systems. Workstation applications using SQLite normally do not need to invoke either of these routines.</source>
          <target state="translated">sqlite3_initialize()ルーチンはSQLiteライブラリを初期化します。sqlite3_shutdown()ルーチンは、sqlite3_initialize()によって割り当てられたリソースを解放します。これらのルーチンは、組み込みシステムでのプロセスの初期化とシャットダウンを支援するように設計されています。SQLiteを使用するワークステーション・アプリケーションは通常、これらのルーチンを呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="6344d658101e62a854952f62047632e568cb77e6" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize（）ルーチンは、アプリケーションが通常sqlite3_initialize（）を直接呼び出す必要がないように、他の多くのSQLiteインターフェースによって内部的に呼び出されます。たとえば、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;はsqlite3_initialize（）を呼び出すため、まだ初期化されていない場合、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;が呼び出されるとSQLiteライブラリが自動的に初期化されます。ただし、SQLiteが&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINITで&lt;/a&gt;コンパイルされている場合コンパイル時オプションでは、sqlite3_initialize（）への自動呼び出しは省略され、アプリケーションは他のSQLiteインターフェイスを使用する前に直接sqlite3_initialize（）を呼び出す必要があります。移植性を最大にするために、他のSQLiteインターフェースを使用する前に、アプリケーションが常にsqlite3_initialize（）を直接呼び出すことをお勧めします。 SQLiteの将来のリリースでは、これが必要になる可能性があります。言い換えると、SQLiteが&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;でコンパイルされたときに示される動作は、SQLiteの将来のリリースではデフォルトの動作になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="fcebb10283d6873f839e3d670ae393ff5c1368df" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize（）ルーチンは、アプリケーションが通常sqlite3_initialize（）を直接呼び出す必要がないように、他の多くのSQLiteインターフェースによって内部的に呼び出されます。たとえば、&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;はsqlite3_initialize（）を呼び出すため、まだ初期化されていない場合、&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;が呼び出されるとSQLiteライブラリが自動的に初期化されます。ただし、SQLiteが&lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINITで&lt;/a&gt;コンパイルされている場合コンパイル時オプションでは、sqlite3_initialize（）への自動呼び出しは省略され、アプリケーションは他のSQLiteインターフェイスを使用する前に直接sqlite3_initialize（）を呼び出す必要があります。移植性を最大にするために、他のSQLiteインターフェースを使用する前に、アプリケーションが常にsqlite3_initialize（）を直接呼び出すことをお勧めします。 SQLiteの将来のリリースでは、これが必要になる可能性があります。言い換えると、SQLiteが&lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;でコンパイルされたときに示される動作は、SQLiteの将来のリリースではデフォルトの動作になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ce2e2f5e58c3c92f466c0d1a9cbb3782ccb3ca7e" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize（）ルーチンは成功すると&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;を返します。何らかの理由でsqlite3_initialize（）がライブラリを初期化できない場合（おそらく、ミューテックスなどの必要なリソースを割り当てることができない場合）は、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;以外の&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="7cfd6fb2b2f9b6bef5dc2729044b616aa2e46340" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize（）ルーチンは成功すると&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返します。何らかの理由でsqlite3_initialize（）がライブラリを初期化できない場合（おそらく、ミューテックスなどの必要なリソースを割り当てることができない場合）は、&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;以外の&lt;a href=&quot;../rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="004164880e4716eb9f6522ffa56490d8e1026730" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions. The sqlite_int64 and sqlite_uint64 types are supported for backwards compatibility only.</source>
          <target state="translated">sqlite3_int64とsqlite3_uint64は好ましい型定義です。sqlite_int64とsqlite_uint64型は下位互換性のためだけにサポートされています。</target>
        </trans-unit>
        <trans-unit id="7d87f3d7209e128d2babe00e667401d22d9cc8a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite_int64 types can store integer values between -9223372036854775808 and +9223372036854775807 inclusive. The sqlite3_uint64 and sqlite_uint64 types can store integer values between 0 and +18446744073709551615 inclusive.</source>
          <target state="translated">sqlite3_int64およびsqlite_int64型は、-9223372036854775808から+9223372036854775807までの整数値を格納できます。sqlite3_uint64とsqlite_uint64型は0から+18446744073709551615までの整数値を格納できます。</target>
        </trans-unit>
        <trans-unit id="7eba8c8e6f99b81a907173174c705f9ed98298ab" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）呼び出しは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dで現在実行中のすべてのSQLステートメントが完了するまで有効です。 sqlite3_interrupt（）呼び出しの後、実行中のステートメントがゼロに達する前に開始された新しいSQLステートメントは、sqlite3_interrupt（）呼び出しの前に実行されたかのように中断されます。実行中のステートメントの数がゼロに達した後に開始される新しいSQLステートメントは、sqlite3_interrupt（）の影響を受けません。実行中のSQLステートメントがない場合に発生するsqlite3_interrupt（D）への呼び出しはノーオペレーションであり、sqlite3_interrupt（）呼び出しが戻った後に開始されるSQLステートメントには影響を与えません。</target>
        </trans-unit>
        <trans-unit id="a6b86af3fa8ce3c883af892e74e82bdad0554e41" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）呼び出しは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dで現在実行中のすべてのSQLステートメントが完了するまで有効です。 sqlite3_interrupt（）呼び出しの後、実行中のステートメントがゼロに達する前に開始された新しいSQLステートメントは、sqlite3_interrupt（）呼び出しの前に実行されたかのように中断されます。実行中のステートメントの数がゼロに達した後に開始される新しいSQLステートメントは、sqlite3_interrupt（）の影響を受けません。実行中のSQLステートメントがない場合に発生するsqlite3_interrupt（D）への呼び出しはノーオペレーションであり、sqlite3_interrupt（）呼び出しが戻った後に開始されるSQLステートメントには影響を与えません。</target>
        </trans-unit>
        <trans-unit id="3bfe2e62ea9486a964b648fd6403e7edfa3b65f8" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_check(Z,L) interface checks to see whether or not the L-byte UTF8 identifier that Z points to is a keyword, returning non-zero if it is and zero if not.</source>
          <target state="translated">sqlite3_keyword_check(Z,L)インタフェースは、Zが指すLバイトUTF8識別子がキーワードであるかどうかをチェックし、キーワードであれば0以外の値を、キーワードでなければ0を返します。</target>
        </trans-unit>
        <trans-unit id="d4d8092bdf6d249db5e6e39b2ccbee0c913272c1" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_count() interface returns the number of distinct keywords understood by SQLite.</source>
          <target state="translated">sqlite3_keyword_count()インターフェイスは、SQLite で理解できる明確なキーワードの数を返します。</target>
        </trans-unit>
        <trans-unit id="dc0acf41ffb529d44b2ebca13529ac325b17bad2" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_name(N,Z,L) interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L. The string that *Z points to is not zero-terminated. The sqlite3_keyword_name(N,Z,L) routine returns SQLITE_OK if N is within bounds and SQLITE_ERROR if not. If either Z or L are NULL or invalid pointers then calls to sqlite3_keyword_name(N,Z,L) result in undefined behavior.</source>
          <target state="translated">sqlite3_keyword_name(N,Z,L)インタフェースは、N番目のキーワードを見つけ、UTF8で表現されたキーワードを*Zが指すようにし、キーワードのバイト数を*Lに書き込みます。Zが指す文字列はゼロ終端ではありません。sqlite3_keyword_name(N,Z,L)ルーチンは、Nが範囲内ならばSQLITE_OKを、範囲外ならばSQLITE_ERRORを返します。ZまたはLがNULLまたは無効なポインタの場合、sqlite3_keyword_name(N,Z,L)の呼び出しは未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="0a1d77fc76c131dee5ee5dd030d6d5133cee00d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">sqlite3_last_insert_rowid（D）インターフェースは、通常返し&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;最新の成功の&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;行IDテーブルまたはに&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;にデータベース接続D.インサート上を&lt;a href=&quot;../withoutrowid&quot;&gt;ROWIDをなし&lt;/a&gt;テーブルが記録されません。ROWIDテーブルへの正常な&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;がデータベース接続Dで発生したことがない場合、sqlite3_last_insert_rowid（D）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="96cc17a506c60ac9000086a1e0105e51d535d45e" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">sqlite3_last_insert_rowid（D）インターフェースは、通常返し&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;最新の成功の&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;行IDテーブルまたはに&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;にデータベース接続D.インサート上を&lt;a href=&quot;withoutrowid&quot;&gt;ROWIDをなし&lt;/a&gt;テーブルが記録されません。ROWIDテーブルへの正常な&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;がデータベース接続Dで発生したことがない場合、sqlite3_last_insert_rowid（D）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="97d28d93a8572fd39455b44f97795fb1531500e9" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension（）インターフェースは、ファイルzFileに含まれる&lt;a href=&quot;../loadext&quot;&gt;SQLite拡張&lt;/a&gt;ライブラリをロードしようとします。ファイルを直接ロードできない場合は、オペレーティングシステム固有のさまざまな拡張機能を追加してロードが試行されます。たとえば、「samplelib」をロードできない場合、「samplelib.so」、「samplelib.dylib」、「samplelib.dll」などの名前も試される可能性があります。</target>
        </trans-unit>
        <trans-unit id="29a1d12e678745f57cc139b953c6116a8408aff6" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension（）インターフェースは、ファイルzFileに含まれる&lt;a href=&quot;loadext&quot;&gt;SQLite拡張&lt;/a&gt;ライブラリをロードしようとします。ファイルを直接ロードできない場合は、オペレーティングシステム固有のさまざまな拡張機能を追加してロードが試行されます。たとえば、「samplelib」をロードできない場合、「samplelib.so」、「samplelib.dylib」、「samplelib.dll」などの名前も試される可能性があります。</target>
        </trans-unit>
        <trans-unit id="653b87892cb27376af041bf3731e3304fd208799" translate="yes" xml:space="preserve">
          <source>The sqlite3_log() interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions. While there is nothing to prevent an application from calling sqlite3_log(), doing so is considered bad form.</source>
          <target state="translated">sqlite3_log()インタフェースは、仮想テーブル、照合関数、SQL関数などの拡張機能での使用を意図しています。アプリケーションがsqlite3_log()を呼び出すことを妨げるものは何もありませんが、そうすることは悪いことだと考えられています。</target>
        </trans-unit>
        <trans-unit id="c4ad2aeb0d9be1f2327ef6d534ab004f6a2b8dc6" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc() routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter. If sqlite3_malloc() is unable to obtain sufficient free memory, it returns a NULL pointer. If the parameter N to sqlite3_malloc() is zero or negative then sqlite3_malloc() returns a NULL pointer.</source>
          <target state="translated">sqlite3_malloc()ルーチンはNバイト以上のメモリブロックへのポインタを返します。sqlite3_malloc()が十分な空きメモリを取得できなかった場合、NULLポインタを返します。sqlite3_malloc()へのパラメータNが0か負の場合、sqlite3_malloc()はNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="a4e65f99f4accbf5db989c9154cb81e75b9ee8ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc64(N) routine works just like sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead of a signed 32-bit integer.</source>
          <target state="translated">sqlite3_malloc64(N)ルーチンはsqlite3_malloc(N)と同じように動作しますが、Nが符号付き32ビット整数ではなく符号なし64ビット整数であることを除きます。</target>
        </trans-unit>
        <trans-unit id="6aa420d40670b164a1cce9b427bd49e7d1c5fd88" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf（）およびsqlite3_vmprintf（）ルーチンは、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;から取得したメモリに結果を書き込みます。これら2つのルーチンによって返される文字列は、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;によって解放される必要があります。&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;が結果の文字列を保持するのに十分なメモリを割り当てることができない場合、両方のルーチンはNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="aeca10a8c44ac57eac0c9c7f71ba952063b68cc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf（）およびsqlite3_vmprintf（）ルーチンは、&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;から取得したメモリに結果を書き込みます。これら2つのルーチンによって返される文字列は、&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;によって解放される必要があります。&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;が結果の文字列を保持するのに十分なメモリを割り当てることができない場合、両方のルーチンはNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="f0bcf6e7726b974822789eb5eaa08500974adb52" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_alloc() routine allocates a new mutex and returns a pointer to it. The sqlite3_mutex_alloc() routine returns NULL if it is unable to allocate the requested mutex. The argument to sqlite3_mutex_alloc() must one of these integer constants:</source>
          <target state="translated">sqlite3_mutex_alloc()ルーチンは新しいミューテックスを確保し、そのポインタを返します。sqlite3_mutex_alloc()ルーチンは要求されたミューテックスを確保できなかった場合はNULLを返します。sqlite3_mutex_alloc()の引数はこれらの整数定数のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="2d81df454ad810426381d8f39e8b57e0d9de3e46" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter（）とsqlite3_mutex_try（）ルーチンは、ミューテックスに入ろうとします。別のスレッドがすでにミューテックス内にある場合、sqlite3_mutex_enter（）はブロックし、sqlite3_mutex_try（）はSQLITE_BUSYを返します。 sqlite3_mutex_try（）インターフェースは、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;エントリ&lt;/a&gt;が成功するとSQLITE_OKを返します。 SQLITE_MUTEX_RECURSIVEを使用して作成されたミューテックスは、同じスレッドで複数回入力できます。このような場合、別のスレッドが入る前に、ミューテックスは同じ回数終了する必要があります。同じスレッドがSQLITE_MUTEX_RECURSIVE以外のmutexに2回以上入ろうとした場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="3b45ebc24527ab0f89738f7016be66d43d5251ac" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter（）とsqlite3_mutex_try（）ルーチンは、ミューテックスに入ろうとします。別のスレッドがすでにミューテックス内にある場合、sqlite3_mutex_enter（）はブロックし、sqlite3_mutex_try（）はSQLITE_BUSYを返します。 sqlite3_mutex_try（）インターフェースは、&lt;a href=&quot;../rescode#ok&quot;&gt;エントリ&lt;/a&gt;が成功するとSQLITE_OKを返します。 SQLITE_MUTEX_RECURSIVEを使用して作成されたミューテックスは、同じスレッドで複数回入力できます。このような場合、別のスレッドが入る前に、ミューテックスは同じ回数終了する必要があります。同じスレッドがSQLITE_MUTEX_RECURSIVE以外のmutexに2回以上入ろうとした場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="a9c3683cf3483b6e604960673d2e4ca248bc41dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_free() routine deallocates a previously allocated dynamic mutex. Attempting to deallocate a static mutex results in undefined behavior.</source>
          <target state="translated">sqlite3_mutex_free()ルーチンは以前に割り当てられた動的ミューテックスを解放します。静的ミューテックスを解放しようとすると、未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="c54fa9a704452135b01172d66edadf344257a173" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines are intended for use inside assert() statements. The SQLite core never uses these routines except inside an assert() and applications are advised to follow the lead of the core. The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag. External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.</source>
          <target state="translated">sqlite3_mutex_held()とsqlite3_mutex_notheld()ルーチンはassert()文の中で使用することを意図しています。SQLiteコアはこれらのルーチンをassert()の中以外で使用することはなく、アプリケーションはコアの指示に従うことをお勧めします。SQLite コアがこれらのルーチンの実装を提供するのは、SQLITE_DEBUG フラグを付けてコンパイルされた場合のみです。外部のミューテックス実装は、SQLITE_DEBUGが定義されていてNDEBUGが定義されていない場合にのみ、これらのルーチンを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="93534cd54fb671abd29d988fdeee0858c44767d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_leave() routine exits a mutex that was previously entered by the same thread. The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.</source>
          <target state="translated">sqlite3_mutex_leave()ルーチンは、以前に同じスレッドによって入力されたミューテックスを終了します。呼び出し元のスレッドが現在ミューテックスを入力していないか、または現在割り当てられていない場合の動作は定義されていません。</target>
        </trans-unit>
        <trans-unit id="fb745ae4bf7930e6464af0ad23559d80e7f2b3bc" translate="yes" xml:space="preserve">
          <source>The sqlite3_open() routine returns an integer error code rather than a pointer to the sqlite3 structure as the version 2 interface did. The difference between sqlite3_open() and sqlite3_open16() is that sqlite3_open16() takes UTF-16 (in host native byte order) for the name of the database file. If a new database file needs to be created, then sqlite3_open16() sets the internal text representation to UTF-16 whereas sqlite3_open() sets the text representation to UTF-8.</source>
          <target state="translated">sqlite3_open()ルーチンは、バージョン2インタフェースのようにsqlite3構造体へのポインタではなく、整数のエラーコードを返します。sqlite3_open()とsqlite3_open16()の違いは、sqlite3_open16()がデータベースファイルの名前にUTF-16(ホストネイティブのバイトオーダー)を取ることです。新しいデータベースファイルを作成する必要がある場合、sqlite3_open16()は内部のテキスト表現をUTF-16に設定し、sqlite3_open()はテキスト表現をUTF-8に設定します。</target>
        </trans-unit>
        <trans-unit id="49cca3441049c31bbff034c5494130978bd29358" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2（）インターフェースはsqlite3_open（）と同様に機能しますが、新しいデータベース接続をさらに制御するために2つの追加パラメーターを受け入れる点が異なります。 sqlite3_open_v2（）へのフラグパラメータは、次の3つの値のいずれかを取り、オプションで&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;、&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;、&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;、&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;フラグと組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="e598ece82e5f2beb42f8604c9b91c3f1054b0c31" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2（）インターフェースはsqlite3_open（）と同様に機能しますが、新しいデータベース接続をさらに制御するために2つの追加パラメーターを受け入れる点が異なります。 sqlite3_open_v2（）へのフラグパラメータは、次の3つの値のいずれかを取り、オプションで&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;、&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;、&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;、&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;、または&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;フラグと組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="6e55b10d2fb69bf6bea01941ab944f29f8bde45c" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init（）ルーチンは、SQLiteライブラリのオペレーティングシステム固有の初期化を行います。sqlite3_os_end（）ルーチンは、sqlite3_os_init（）の効果を取り消します。これらのルーチンによって実行される典型的なタスクには、静的リソースの割り当てまたは割り当て解除、グローバル変数の初期化、デフォルトの&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;モジュールのセットアップ、または&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;を使用したデフォルト構成のセットアップが含まれます。</target>
        </trans-unit>
        <trans-unit id="ea78da5df45c282e78d4b89a318af0ce437587df" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init（）ルーチンは、SQLiteライブラリのオペレーティングシステム固有の初期化を行います。sqlite3_os_end（）ルーチンは、sqlite3_os_init（）の効果を取り消します。これらのルーチンによって実行される典型的なタスクには、静的リソースの割り当てまたは割り当て解除、グローバル変数の初期化、デフォルトの&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;モジュールのセットアップ、または&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;を使用したデフォルト構成のセットアップが含まれます。</target>
        </trans-unit>
        <trans-unit id="3bd4022600e005736b49c1c51ead1422ec8da9c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache type is opaque. It is implemented by the pluggable module. The SQLite core has no knowledge of its size or internal structure and never deals with the sqlite3_pcache object except by holding and passing pointers to the object.</source>
          <target state="translated">sqlite3_pcache型は不透明です。pluggableモジュールによって実装されています。SQLiteコアはそのサイズや内部構造を知らず、オブジェクトへのポインタを保持したり渡したりする以外、sqlite3_pcacheオブジェクトを扱うことはありません。</target>
        </trans-unit>
        <trans-unit id="07293c189451b8c181f77d9379a0238420ee3f47" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_methods structure and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; configuration parameters are deprecated. They are replaced by a new &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; structure and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; configuration parameters.</source>
          <target state="translated">sqlite3_pcache_methods構造体、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt;および&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt;構成パラメーターは非推奨になりました。これらは、新しい&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;構造と、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;および&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt;構成パラメーターに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="445aa02fd749c19bfbd930e14dfefb0c0e11a4d3" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_page object represents a single page in the page cache. The page cache will allocate instances of this object. Various methods of the page cache use pointers to instances of this object as parameters or as their return value.</source>
          <target state="translated">sqlite3_pcache_pageオブジェクトは、ページキャッシュ内の1つのページを表します。ページキャッシュはこのオブジェクトのインスタンスを割り当てます。ページキャッシュの様々なメソッドはパラメータや戻り値としてこのオブジェクトのインスタンスへのポインタを使用します。</target>
        </trans-unit>
        <trans-unit id="7bf15591143e8308e465ab8ab773665acb5da577" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare interface compiles a single SQL statement into byte code for later execution. This interface is now the preferred way of accessing the database.</source>
          <target state="translated">sqlite3_prepareインタフェースは、後で実行するために単一のSQL文をバイトコードにコンパイルします。このインターフェイスは、現在ではデータベースにアクセスするための好ましい方法となっています。</target>
        </trans-unit>
        <trans-unit id="63425e76fcf41641f3bb3043a50f94b90abaff47" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">sqlite3_prepare_v2（）、sqlite3_prepare_v3（）、sqlite3_prepare16_v2（）、およびsqlite3_prepare16_v3（）インターフェイスは、すべての新しいプログラムに推奨されます。古いインターフェース（sqlite3_prepare（）およびsqlite3_prepare16（））は、下位互換性のために保持されていますが、それらの使用はお勧めしません。 「vX」インターフェースでは、返される準備済みステートメント（&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;オブジェクト）に元のSQLテキストのコピーが含まれています。これにより、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;インターフェースの動作が3つ異なります。</target>
        </trans-unit>
        <trans-unit id="31c4a31d37db839c6c488798a5abc3fd1e42192d" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">sqlite3_prepare_v2（）、sqlite3_prepare_v3（）、sqlite3_prepare16_v2（）、およびsqlite3_prepare16_v3（）インターフェイスは、すべての新しいプログラムに推奨されます。古いインターフェース（sqlite3_prepare（）およびsqlite3_prepare16（））は、下位互換性のために保持されていますが、それらの使用はお勧めしません。 「vX」インターフェースでは、返される準備済みステートメント（&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;オブジェクト）に元のSQLテキストのコピーが含まれています。これにより、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;インターフェースの動作が3つ異なります。</target>
        </trans-unit>
        <trans-unit id="1133258b4a9a31b0c0513ddc50dd402acde6047e" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler（D、N、X、P）インターフェースコールバック関数Xが長いへの呼び出しを実行中に定期的に起動させる&lt;a href=&quot;#sqlite3_exec&quot;&gt;）（sqlite3_exec&lt;/a&gt;、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;このインタフェースのデータベース接続D.アンの使用例であるため大規模なクエリ中にGUIを更新し続けます。</target>
        </trans-unit>
        <trans-unit id="6ede9775015331a2dade498d028dbb0b1a89b661" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler（D、N、X、P）インターフェースコールバック関数Xが長いへの呼び出しを実行中に定期的に起動させる&lt;a href=&quot;exec&quot;&gt;）（sqlite3_exec&lt;/a&gt;、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;と&lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;このインタフェースのデータベース接続D.アンの使用例であるため大規模なクエリ中にGUIを更新し続けます。</target>
        </trans-unit>
        <trans-unit id="92b3414b60e6ff01e63206d0ac8d5d46b8bec0e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc(X,N) interface attempts to resize a prior memory allocation X to be at least N bytes. If the X parameter to sqlite3_realloc(X,N) is a NULL pointer then its behavior is identical to calling sqlite3_malloc(N). If the N parameter to sqlite3_realloc(X,N) is zero or negative then the behavior is exactly the same as calling sqlite3_free(X). sqlite3_realloc(X,N) returns a pointer to a memory allocation of at least N bytes in size or NULL if insufficient memory is available. If M is the size of the prior allocation, then min(N,M) bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc(X,N) and the prior allocation is freed. If sqlite3_realloc(X,N) returns NULL and N is positive, then the prior allocation is not freed.</source>
          <target state="translated">sqlite3_realloc(X,N)インタフェースは前のメモリ割り当てXを少なくともNバイトにリサイズしようとします。sqlite3_realloc(X,N)のXパラメータがNULLポインタの場合、その動作はsqlite3_malloc(N)の呼び出しと同じです。sqlite3_realloc(X,N)のNパラメータが0か負の場合はsqlite3_free(X)を呼び出すのと全く同じです。 sqlite3_realloc(X,N)は少なくともNバイトのメモリ割り当てへのポインタを返します。Mが前のアロケーションのサイズならば、前のアロケーションのmin(N,M)バイトがsqlite3_realloc(X,N)によって返されたバッファの先頭にコピーされ、前のアロケーションは解放されます。sqlite3_realloc(X,N)がNULLを返し、Nが正の場合、先行アロケーションは解放されません。</target>
        </trans-unit>
        <trans-unit id="e95adede07a7a66375653b101c394b5d26a89fcd" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc64(X,N) interfaces works the same as sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead of a 32-bit signed integer.</source>
          <target state="translated">sqlite3_realloc64(X,N)インタフェースはsqlite3_realloc(X,N)と同じように動作しますが、Nが32ビット符号付き整数ではなく64ビット符号なし整数であることを除いては、sqlite3_realloc(X,N)と同じです。</target>
        </trans-unit>
        <trans-unit id="c45df4cf90bd7042631d9142c52fed7adb90361e" translate="yes" xml:space="preserve">
          <source>The sqlite3_rebaser object is deleted by calling sqlite3rebaser_delete().</source>
          <target state="translated">sqlite3_rebaserオブジェクトはsqlite3rebaser_delete()を呼び出すことで削除されます。</target>
        </trans-unit>
        <trans-unit id="4a286ff8214a968ca30b48466d6f539d2ffd723c" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory（）インターフェイスは、データベースライブラリが保持している非必須メモリ割り当ての割り当てを解除することにより、Nバイトのヒープメモリを解放しようとします。パフォーマンスを向上させるためにデータベースページをキャッシュするために使用されるメモリは、非必須メモリの例です。 sqlite3_release_memory（）は、実際に解放されたバイト数を返します。これは、要求された量より多い場合も少ない場合もあります。 SQLiteが&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENTで&lt;/a&gt;コンパイルされていない場合、sqlite3_release_memory（）ルーチンは何もしないでゼロを返します。</target>
        </trans-unit>
        <trans-unit id="e641eb92f089a94b694e1eb10428491e684eab1f" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory（）インターフェイスは、データベースライブラリが保持している非必須メモリ割り当ての割り当てを解除することにより、Nバイトのヒープメモリを解放しようとします。パフォーマンスを向上させるためにデータベースページをキャッシュするために使用されるメモリは、非必須メモリの例です。 sqlite3_release_memory（）は、実際に解放されたバイト数を返します。これは、要求された量より多い場合も少ない場合もあります。 SQLiteが&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENTで&lt;/a&gt;コンパイルされていない場合、sqlite3_release_memory（）ルーチンは何もしないでゼロを返します。</target>
        </trans-unit>
        <trans-unit id="54ae89d5ac2183e89297de25b936056b80fa288f" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">sqlite3_reset（）関数が呼び出され、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトが初期状態にリセットされ、再実行できるようになります。&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind _ *（）API&lt;/a&gt;を使用して値がバインドされたSQLステートメント変数は、その値を保持します。&lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings（）&lt;/a&gt;を使用してバインディングをリセットします。</target>
        </trans-unit>
        <trans-unit id="55cabea2592a4db5b69eb055b74aa3254a909a13" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">sqlite3_reset（）関数が呼び出され、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトが初期状態にリセットされ、再実行できるようになります。&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind _ *（）API&lt;/a&gt;を使用して値がバインドされたSQLステートメント変数は、その値を保持します。&lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings（）&lt;/a&gt;を使用してバインディングをリセットします。</target>
        </trans-unit>
        <trans-unit id="ee8a502aaf09ac296b4bb201f29d8a4e68054a04" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_blob() interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter.</source>
          <target state="translated">sqlite3_result_blob()インタフェースは、アプリケーション定義関数の結果を、2番目のパラメータで指定された内容がNバイト長で、Nが3番目のパラメータであるBLOBに設定します。</target>
        </trans-unit>
        <trans-unit id="b7904572bea3279794f2bcc9179991e08e12d408" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_double() interface sets the result from an application-defined function to be a floating point value specified by its 2nd argument.</source>
          <target state="translated">sqlite3_result_double()インタフェースは、アプリケーション定義関数の結果を第2引数で指定された浮動小数点値に設定します。</target>
        </trans-unit>
        <trans-unit id="ea6209b4564a5f3773fd6febf3293c65522a4bc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 in native byte order. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error()関数とsqlite3_result_error16()関数は実装されたSQL関数に例外を発生させます。SQLiteは、sqlite3_result_error()またはsqlite3_result_error16()の2番目のパラメータが指す文字列をエラーメッセージのテキストとして使用します。SQLiteはsqlite3_result_error()からのエラーメッセージ文字列をUTF-8として解釈します。SQLiteはsqlite3_result_error16()からの文字列をネイティブバイト順でUTF-16として解釈します。sqlite3_result_error()またはsqlite3_result_error16()の3番目のパラメータが負の場合、SQLiteは最初の0文字までの全てのテキストをエラーメッセージとして受け取ります。sqlite3_result_error()またはsqlite3_result_error16()の3番目のパラメータが負でない場合、SQLiteは2番目のパラメータのバイト数(文字ではなく)をエラーメッセージとして受け取ります。sqlite3_result_error()とsqlite3_result_error16()ルーチンは返す前にエラーメッセージテキストのプライベートコピーを作成します。したがって、呼び出した関数は、それらが戻ってきた後でも害を与えることなくテキストを解放したり変更したりすることができます。sqlite3_result_error_code()関数は、関数内のエラーの結果としてSQLiteが返すエラーコードを変更します。デフォルトでは、エラーコードはSQLITE_ERRORです。sqlite3_result_error()またはsqlite3_result_error16()を呼び出すと、エラーコードはSQLITE_ERRORにリセットされます。</target>
        </trans-unit>
        <trans-unit id="9161e1bf262f2df329446fa1f6bc65f20e7794e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_nomem() interface causes SQLite to throw an error indicating that a memory allocation failed.</source>
          <target state="translated">sqlite3_result_error_nomem()インターフェイスは、メモリ割り当てに失敗したことを示すエラーを SQLite にスローさせます。</target>
        </trans-unit>
        <trans-unit id="9e5d46d0dedea736182a8b4b5fc9e97d872ed801" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_toobig() interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent.</source>
          <target state="translated">sqlite3_result_error_toobig()インターフェースは、文字列やBLOBが長すぎて表現できないことを示すエラーをSQLiteにスローさせます。</target>
        </trans-unit>
        <trans-unit id="f6cfb870f85ac1c6d72052f09d1c9de9769820e3" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_int() interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2nd argument. The sqlite3_result_int64() interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2nd argument.</source>
          <target state="translated">sqlite3_result_int()インタフェースは、アプリケーション定義関数の戻り値を第2引数で与えられた32ビット符号付き整数値に設定します。sqlite3_result_int64()インタフェースは、アプリケーション定義関数の戻り値を第2引数で与えられた64ビット符号付き整数値に設定します。</target>
        </trans-unit>
        <trans-unit id="6279fe7ee925bdc0e3f640e0b50cfa7f6bf20e52" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_null() interface sets the return value of the application-defined function to be NULL.</source>
          <target state="translated">sqlite3_result_null()インタフェースは、アプリケーション定義関数の戻り値をNULLに設定します。</target>
        </trans-unit>
        <trans-unit id="16d6bb7320a3240a335aa7ac5ed9b9a1d6945bef" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C、P、T、D）インターフェースは&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null（C）&lt;/a&gt;と同様に結果をSQL NULL値に設定しますが、ホスト言語のポインターPまたはタイプTをそのNULL値に関連付け、そのポインターが&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;を使用して、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;内で取得できます。 DパラメータがNULLでない場合、それはPパラメータのデストラクタへのポインタです。 SQLiteは、SQLiteがPで終了したときに、唯一の引数としてPを使用してDを呼び出します。Tパラメータは静的文字列であり、文字列リテラルであることが望ましいです。 sqlite3_result_pointer（）ルーチンは、SQLite 3.20.0に追加された&lt;a href=&quot;bindptr&quot;&gt;ポインター受け渡しインターフェイスの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="870667722e41d2c1c37c185e96c88c88778eea77" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C、P、T、D）インターフェースは&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null（C）&lt;/a&gt;と同様に結果をSQL NULL値に設定しますが、ホスト言語のポインターPまたはタイプTをそのNULL値に関連付け、そのポインターが&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;を使用して、&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;内で取得できます。 DパラメータがNULLでない場合、それはPパラメータのデストラクタへのポインタです。 SQLiteは、SQLiteがPで終了したときに、唯一の引数としてPを使用してDを呼び出します。Tパラメータは静的文字列であり、文字列リテラルであることが望ましいです。 sqlite3_result_pointer（）ルーチンは、SQLite 3.20.0に追加された&lt;a href=&quot;../bindptr&quot;&gt;ポインター受け渡しインターフェイスの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="a4e926904c44e1c10338c3ed629ffd93dee056e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C、T）関数は、&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; Cを持つ&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;からの結果のサブタイプを値Tにします。SQLiteの現在のバージョンでは、サブタイプTの下位8ビットのみが保持されます。上位ビットは破棄されます。 SQLiteによって保持されるサブタイプのバイト数は、SQLiteの将来のリリースで増加する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d462f96f6d4a97e8d351d18ac7f1c494815765c7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C、T）関数は、&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; Cを持つ&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;からの結果のサブタイプを値Tにします。SQLiteの現在のバージョンでは、サブタイプTの下位8ビットのみが保持されます。上位ビットは破棄されます。 SQLiteによって保持されるサブタイプのバイト数は、SQLiteの将来のリリースで増加する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8fc6882e24d42f347f5ab25fb2f2b1c639f2f020" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text（）、sqlite3_result_text16（）、sqlite3_result_text16le（）、およびsqlite3_result_text16be（）インターフェースは、アプリケーション定義関数の戻り値を、UTF-8、UTF-16ネイティブバイトオーダー、UTF-として表されるテキスト文字列に設定しますそれぞれ16リトルエンディアン、またはUTF-16ビッグエンディアン。 sqlite3_result_text64（）インターフェースは、アプリケーション定義関数の戻り値を、5番目（および最後）のパラメーターで指定されたエンコードのテキスト文字列に設定します。これは、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LEの&lt;/a&gt;いずれかである必要があります。 SQLiteはアプリケーションからのテキスト結果をsqlite3_result_text *インターフェースの2番目のパラメーターから取得します。 sqlite3_result_text *インターフェースの3番目のパラメーターが負の場合、SQLiteは2番目のパラメーターから最初のゼロ文字までの結果テキストを取得します。 sqlite3_result_text *インターフェースの3番目のパラメーターが負でない場合、2番目のパラメーターが指すテキストのバイト数（文字数ではない）がアプリケーション定義の関数の結果と見なされます。 3番目のパラメーターが負でない場合は、NULが終了した文字列がNULターミネーターで表示される文字列へのバイトオフセットでなければなりません。文字列の3番目のパラメータの値よりも小さいバイトオフセットでNUL文字が発生する場合、結果の文字列には埋め込みNULが含まれ、NULが埋め込まれた文字列を操作する式の結果は未定義です。 sqlite3_result_text *インターフェースまたはsqlite3_result_blobの4番目のパラメーターがNULL以外のポインターである場合、SQLiteは、その結果の使用を終了したときに、テキストまたはBLOB結果のデストラクタとしてその関数を呼び出します。 sqlite3_result_text *インターフェースまたはsqlite3_result_blobへの4番目のパラメーターが特別な定数SQLITE_STATICである場合、SQLiteはテキストまたはBLOBの結果が定数スペースにあると想定し、パラメーターのコンテンツをコピーせず、コンテンツのデストラクターを呼び出しませんその結果を使用して終了しました。sqlite3_result_text *インターフェースまたはsqlite3_result_blobの4番目のパラメーターが特別な定数SQLITE_TRANSIENTである場合、SQLiteは結果のコピーを&lt;a href=&quot;#sqlite3_free&quot;&gt;&lt;/a&gt;戻る前のsqlite3_malloc（）。</target>
        </trans-unit>
        <trans-unit id="ffc0515c64350de79930cdbbfae27bfbd23133bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text（）、sqlite3_result_text16（）、sqlite3_result_text16le（）、およびsqlite3_result_text16be（）インターフェースは、アプリケーション定義関数の戻り値を、UTF-8、UTF-16ネイティブバイトオーダー、UTF-として表されるテキスト文字列に設定しますそれぞれ16リトルエンディアン、またはUTF-16ビッグエンディアン。 sqlite3_result_text64（）インターフェースは、アプリケーション定義関数の戻り値を、5番目（および最後）のパラメーターで指定されたエンコードのテキスト文字列に設定します。これは、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LEの&lt;/a&gt;いずれかである必要があります。 SQLiteはアプリケーションからのテキスト結果をsqlite3_result_text *インターフェースの2番目のパラメーターから取得します。 sqlite3_result_text *インターフェースの3番目のパラメーターが負の場合、SQLiteは2番目のパラメーターから最初のゼロ文字までの結果テキストを取得します。 sqlite3_result_text *インターフェースの3番目のパラメーターが負でない場合、2番目のパラメーターが指すテキストのバイト数（文字数ではない）がアプリケーション定義の関数の結果と見なされます。 3番目のパラメーターが負でない場合は、NULが終了した文字列がNULターミネーターで表示される文字列へのバイトオフセットでなければなりません。文字列の3番目のパラメータの値よりも小さいバイトオフセットでNUL文字が発生する場合、結果の文字列には埋め込みNULが含まれ、NULが埋め込まれた文字列を操作する式の結果は未定義です。 sqlite3_result_text *インターフェースまたはsqlite3_result_blobの4番目のパラメーターがNULL以外のポインターである場合、SQLiteは、その結果の使用を終了したときに、テキストまたはBLOB結果のデストラクタとしてその関数を呼び出します。 sqlite3_result_text *インターフェースまたはsqlite3_result_blobへの4番目のパラメーターが特別な定数SQLITE_STATICである場合、SQLiteはテキストまたはBLOBの結果が定数スペースにあると想定し、パラメーターのコンテンツをコピーせず、コンテンツのデストラクターを呼び出しませんその結果を使用して終了しました。sqlite3_result_text *インターフェースまたはsqlite3_result_blobの4番目のパラメーターが特別な定数SQLITE_TRANSIENTである場合、SQLiteは結果のコピーを&lt;a href=&quot;free&quot;&gt;&lt;/a&gt;戻る前のsqlite3_malloc（）。</target>
        </trans-unit>
        <trans-unit id="66d19148a84e04f07a639f83744f212454fd9d54" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value（）インターフェースは、アプリケーション定義関数の結果を、2番目のパラメーターで指定された&lt;a href=&quot;#sqlite3_value&quot;&gt;保護&lt;/a&gt;されていないsqlite3_valueオブジェクトのコピーに設定します。sqlite3_result_value（）インターフェースは&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_valueの&lt;/a&gt;コピーを作成するので、パラメーターで指定された&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;は、sqlite3_result_value（）が問題なく復帰した後に変更または割り当て解除できます。&lt;a href=&quot;#sqlite3_value&quot;&gt;保護sqlite3_value&lt;/a&gt;オブジェクトは、常にここで使用することができる&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されていないsqlite3_value&lt;/a&gt;オブジェクトが要求されるので、いずれかの種類の&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;物体このインタフェースと共に使用することができます。</target>
        </trans-unit>
        <trans-unit id="9c611bb0b94d5204b93fd73ea02598841b3b449f" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value（）インターフェースは、アプリケーション定義関数の結果を、2番目のパラメーターで指定された&lt;a href=&quot;value&quot;&gt;保護&lt;/a&gt;されていないsqlite3_valueオブジェクトのコピーに設定します。sqlite3_result_value（）インターフェースは&lt;a href=&quot;value&quot;&gt;sqlite3_valueの&lt;/a&gt;コピーを作成するので、パラメーターで指定された&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;は、sqlite3_result_value（）が問題なく復帰した後に変更または割り当て解除できます。&lt;a href=&quot;value&quot;&gt;保護sqlite3_value&lt;/a&gt;オブジェクトは、常にここで使用することができる&lt;a href=&quot;value&quot;&gt;保護されていないsqlite3_value&lt;/a&gt;オブジェクトが要求されるので、いずれかの種類の&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;物体このインタフェースと共に使用することができます。</target>
        </trans-unit>
        <trans-unit id="3b2bde2ed5663531d681bf21defe3755de5aa926" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N) interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and N bytes in size.</source>
          <target state="translated">sqlite3_result_zeroblob(C,N)とsqlite3_result_zeroblob64(C,N)インタフェースは、アプリケーション定義関数の結果を、すべてのゼロバイトとNバイトのサイズを含むBLOBに設定します。</target>
        </trans-unit>
        <trans-unit id="38bbbf7ab9a0945b32615ce5c77fecc3dda2b8bb" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_geometry structure that the first argument to the xGeom callback points to has a structure shown below. The exact same sqlite3_rtree_geometry structure is used for every callback for same MATCH operator in the same query. The contents of the sqlite3_rtree_geometry structure are initialized by SQLite but are not subsequently modified. The callback is free to make changes to the pUser and xDelUser elements of the structure if desired.</source>
          <target state="translated">xGeomコールバックの第一引数が指すsqlite3_rtree_geometry構造体は以下のような構造体です。全く同じsqlite3_rtree_geometry構造体が、同じクエリ内の同じMATCH演算子のコールバックで使用されます。sqlite3_rtree_geometry構造体の内容はSQLiteによって初期化されますが、その後変更されることはありません。コールバックは、必要に応じて構造体のpUserとxDelUser要素を自由に変更することができます。</target>
        </trans-unit>
        <trans-unit id="23ca7c4bc54ebb3192ebcd695698caa11c607135" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_query_callback() became available with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;version 3.8.5&lt;/a&gt; (2014-06-04) and is the preferred interface. The sqlite3_rtree_geometry_callback() is an older and less flexible interface that is supported for backwards compatibility.</source>
          <target state="translated">sqlite3_rtree_query_callback（）はSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;バージョン3.8.5&lt;/a&gt;（2014-06-04）で使用可能になり、推奨されるインターフェースです。sqlite3_rtree_geometry_callback（）は、下位互換性のためにサポートされている古くて柔軟性の低いインターフェースです。</target>
        </trans-unit>
        <trans-unit id="a4141688a761802a4dde7063e989412b5ba08576" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize（D、S、P、F）インターフェイスは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; D 上のSデータベースのシリアル化であるメモリへのポインターを返します。PがNULLポインターでない場合、データベースのサイズ（バイト単位）が*に書き込まれます。 P</target>
        </trans-unit>
        <trans-unit id="fd8828a508df0b7bef3d1d62a2ae33a5520d58f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize（D、S、P、F）インターフェイスは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; D 上のSデータベースのシリアル化であるメモリへのポインターを返します。PがNULLポインターでない場合、データベースのサイズ（バイト単位）が*に書き込まれます。 P</target>
        </trans-unit>
        <trans-unit id="d9311ad5ed8e88f0e0e396fbe1a059c5d4e870f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th argument of the application-defined function. Subsequent calls to sqlite3_get_auxdata(C,N) return P from the most recent sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or NULL if the metadata has been discarded. After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded. SQLite is free to discard the metadata at any time, including:</source>
          <target state="translated">sqlite3_set_auxdata(C,N,P,X)インタフェースは、アプリケーション定義関数のN番目の引数のメタデータとしてPを保存します。sqlite3_get_auxdata(C,N)のそれ以降の呼び出しは、メタデータがまだ有効な場合は最新のsqlite3_set_auxdata(C,N,P,X)呼び出しのPを返し、メタデータが破棄された場合はNULLを返します。XがNULLではない場合はsqlite3_set_auxdata(C,N,P,X)を呼び出すたびに、メタデータが破棄されると、SQLiteはパラメータPを持つデストラクタ関数Xを一度だけ呼び出します。SQLiteはメタデータをいつでも自由に破棄することができます。</target>
        </trans-unit>
        <trans-unit id="ce7e4094de25df6c5d0672255fe4f34354822777" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid(D) to R without inserting a row into the database.</source>
          <target state="translated">sqlite3_set_last_insert_rowid(D,R)メソッドは、アプリケーションがsqlite3_last_insert_rowid(D)を呼び出して返された値をデータベースに行を挿入せずにRに設定することを可能にします。</target>
        </trans-unit>
        <trans-unit id="e1bb92256471e00d9337dbe91acedaceec62010e" translate="yes" xml:space="preserve">
          <source>The sqlite3_sleep() function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.</source>
          <target state="translated">sqlite3_sleep()関数は、現在のスレッドに、そのパラメータで指定されたミリ秒数以上の間、実行を中断させます。</target>
        </trans-unit>
        <trans-unit id="932dc970d1649bf3cbe1cd6e521c5a774af59735" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot object records state information about an historical version of the database file so that it is possible to later open a new read transaction that sees that historical version of the database rather than the most recent version.</source>
          <target state="translated">sqlite3_snapshotオブジェクトはデータベースファイルの履歴バージョンの状態情報を記録します。これにより、後で最新バージョンではなく履歴バージョンのデータベースを見る新しい読み込みトランザクションを開くことができます。</target>
        </trans-unit>
        <trans-unit id="242ec5992913a3f34748a4cb2f4099b50b723004" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.</source>
          <target state="translated">sqlite3_snapshot_cmp(P1,P2)インターフェースは、2つの有効なスナップショットハンドルの年齢を比較するために使用されます。</target>
        </trans-unit>
        <trans-unit id="01e7a2ddf509d560437f8041b7f083cd66113cd5" translate="yes" xml:space="preserve">
          <source>The sqlite3_snprintf() routine is similar to &quot;snprintf()&quot; from the standard C library. The result is written into the buffer supplied as the second parameter whose size is given by the first parameter. Note that the order of the first two parameters is reversed from snprintf(). This is an historical accident that cannot be fixed without breaking backwards compatibility. Note also that sqlite3_snprintf() returns a pointer to its buffer instead of the number of characters actually written into the buffer. We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf() now without breaking compatibility.</source>
          <target state="translated">sqlite3_snprintf()ルーチンは標準Cライブラリのsnprintf()に似ています。結果は2番目のパラメータとして与えられたバッファに書き込まれ、そのバッファのサイズは1番目のパラメータで与えられます。最初の 2 つのパラメータの順序が snprintf()とは逆になっていることに注意してください。これは歴史的な事故であり、下位互換性を壊さずに修正することはできません。また、sqlite3_snprintf()は実際にバッファに書き込まれた文字数ではなく、バッファへのポインタを返すことにも注意してください。書き込まれた文字数の方がより有用な戻り値であることは認めますが、互換性を壊さずにsqlite3_snprintf()の実装を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="a1e7c63d0192b11455ed615eabf6f8b339d7c44c" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64（）インターフェースは、SQLiteによって割り当てられる可能性のあるヒープメモリ量のソフト制限を設定または照会します。 SQLiteは、ヒープメモリの使用量が制限に近づくと、ページキャッシュに保持されるページ数を減らすことにより、ヒープメモリの使用率をソフトヒープ制限未満に保つよう努めます。ソフトヒープ制限は「ソフト」です。なぜなら、SQLiteが制限を下回らないように努めても、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;エラーを生成するのではなく、制限を超えてしまうからです。言い換えると、ソフトヒープ制限は推奨のみです。</target>
        </trans-unit>
        <trans-unit id="d5aefe7f58cf6098f950ef6aaad46d0524e32f68" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64（）インターフェースは、SQLiteによって割り当てられる可能性のあるヒープメモリ量のソフト制限を設定または照会します。 SQLiteは、ヒープメモリの使用量が制限に近づくと、ページキャッシュに保持されるページ数を減らすことにより、ヒープメモリの使用率をソフトヒープ制限未満に保つよう努めます。ソフトヒープ制限は「ソフト」です。なぜなら、SQLiteが制限を下回らないように努めても、&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;エラーを生成するのではなく、制限を超えてしまうからです。言い換えると、ソフトヒープ制限は推奨のみです。</target>
        </trans-unit>
        <trans-unit id="b94ad72c9e1e61f387a8b9571668f6ee1d93f6d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">Pが&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;によって作成された場合、sqlite3_sql（P）インターフェイスは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt; Pの作成に使用されるUTF-8 SQLテキストのコピーへのポインターを返します。 sqlite3_expanded_sql（P）インターフェースは、&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメーターが&lt;/a&gt;展開された準備済みステートメントPのSQLテキストを含むUTF-8文字列へのポインターを返します。 sqlite3_normalized_sql（P）インターフェースは、準備されたステートメントPの正規化されたSQLテキストを含むUTF-8文字列へのポインターを返します。SQLステートメントの正規化に使用されるセマンティクスは指定されておらず、変更される可能性があります。少なくとも、リテラル値は適切なプレースホルダーに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="45ba0cce80e217739aee37fc8f257b9f4497c286" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">Pが&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;、または&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;によって作成された場合、sqlite3_sql（P）インターフェイスは、&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt; Pの作成に使用されるUTF-8 SQLテキストのコピーへのポインターを返します。 sqlite3_expanded_sql（P）インターフェースは、&lt;a href=&quot;../lang_expr#varparam&quot;&gt;バインドされたパラメーターが&lt;/a&gt;展開された準備済みステートメントPのSQLテキストを含むUTF-8文字列へのポインターを返します。 sqlite3_normalized_sql（P）インターフェースは、準備されたステートメントPの正規化されたSQLテキストを含むUTF-8文字列へのポインターを返します。SQLステートメントの正規化に使用されるセマンティクスは指定されておらず、変更される可能性があります。少なくとも、リテラル値は適切なプレースホルダーに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="e775091a2d75ef8eec628ca58240bb3a4c44f41a" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status（）とsqlite3_status64（）ルーチンは、成功するとSQLITE_OKを返し、失敗するとゼロ以外の&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="08017cba5dea56fb38bd261f36812b68e5da595b" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status（）とsqlite3_status64（）ルーチンは、成功するとSQLITE_OKを返し、失敗するとゼロ以外の&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="8844a5c0b1eb32242054752c1e25f36f36feae1a" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() interface returns SQLITE_BUSY if it is unable to commit a change because of a lock</source>
          <target state="translated">sqlite3_step()インタフェースは、ロックのために変更をコミットできない場合、SQLITE_BUSYを返します。</target>
        </trans-unit>
        <trans-unit id="aadfbac7c6cbfe9d27468ec7c9a622af76c3660e" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() routine return SQLITE_ROW if it is returning a single row of the result set, or SQLITE_DONE if execution has completed, either normally or due to an error. It might also return SQLITE_BUSY if it is unable to open the database file. If the return value is SQLITE_ROW, then the following routines can be used to extract information about that row of the result set:</source>
          <target state="translated">sqlite3_step()ルーチンは、結果セットの1行を返している場合はSQLITE_ROWを、実行が正常かエラーのために完了した場合はSQLITE_DONEを返します。また、データベースファイルを開くことができない場合は SQLITE_BUSY を返すかもしれません。返り値がSQLITE_ROWの場合、以下のルーチンを使用して結果セットのその行に関する情報を抽出することができます。</target>
        </trans-unit>
        <trans-unit id="68ecf4c95ec171ac99c79d0f7b7218a0a2a7996e" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">（非ゼロ）sqlite3_stmt_busy（S）インタフェースを返すtrueの場合&lt;a href=&quot;#sqlite3_stmt&quot;&gt;、準備されたステートメント&lt;/a&gt; Sは、少なくとも使用して一度強化された&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）の&lt;/a&gt;が、完了するまでもないラン（返されてい&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;から&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）を&lt;/a&gt;使用してリセット）もあった&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_resetを（ S）&lt;/a&gt;。SがNULLポインターの場合、sqlite3_stmt_busy（S）インターフェイスはfalseを返します。SがNULLポインターではなく、有効な&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;オブジェクトへのポインターでない場合、動作は未定義であり、おそらく望ましくありません。</target>
        </trans-unit>
        <trans-unit id="30e9a2351b8f1f389c8c1f5ed3bb5643292d6719" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">（非ゼロ）sqlite3_stmt_busy（S）インタフェースを返すtrueの場合&lt;a href=&quot;stmt&quot;&gt;、準備されたステートメント&lt;/a&gt; Sは、少なくとも使用して一度強化された&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）の&lt;/a&gt;が、完了するまでもないラン（返されてい&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;から&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）を&lt;/a&gt;使用してリセット）もあった&lt;a href=&quot;reset&quot;&gt;sqlite3_resetを（ S）&lt;/a&gt;。SがNULLポインターの場合、sqlite3_stmt_busy（S）インターフェイスはfalseを返します。SがNULLポインターではなく、有効な&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;オブジェクトへのポインターでない場合、動作は未定義であり、おそらく望ましくありません。</target>
        </trans-unit>
        <trans-unit id="90793b88a180a777be3c4f2d53caba9bba6af112" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_isexplain(S) interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN. The sqlite3_stmt_isexplain(S) interface returns 0 if S is an ordinary statement or a NULL pointer.</source>
          <target state="translated">sqlite3_stmt_isexplain(S)インタフェースは、準備された文SがEXPLAIN文であれば1を返し、文SがEXPLAIN QUERY PLANであれば2を返します。sqlite3_stmt_isexplain(S)インタフェースは、Sが通常の文かNULLポインタであれば0を返します。</target>
        </trans-unit>
        <trans-unit id="959c0941832b79e09f96d36c140b66399c0579af" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">sqlite3_stmt_readonly（X）インターフェイスは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt; Xがデータベースファイルの内容を直接変更しない場合にのみ、true（ゼロ以外）を返します。</target>
        </trans-unit>
        <trans-unit id="ac5964bf97c9886f6e336072767ae1979506a3cb" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">sqlite3_stmt_readonly（X）インターフェイスは、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt; Xがデータベースファイルの内容を直接変更しない場合にのみ、true（ゼロ以外）を返します。</target>
        </trans-unit>
        <trans-unit id="46d5fb0793437180a07e66953d44f2fda8b50c88" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_strオブジェクトは&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="58bd138876e3ab72759402d62d6773f8d1b76c11" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_strオブジェクトは&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="709d2526ae98679c1dec5db36348e5bd59a7a2cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_strオブジェクトは破棄され、作成された文字列は&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;インターフェースを使用して返されます。</target>
        </trans-unit>
        <trans-unit id="17671bb4cfc45e29421b502c0583cd6458abaa8b" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_strオブジェクトは破棄され、作成された文字列は&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;インターフェースを使用して返されます。</target>
        </trans-unit>
        <trans-unit id="9c1806bb938001e1be73835ffc5a99f71985fc2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X、D、T、C、....）ルーチンは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; XのデータベースDにあるテーブルTの列Cに関する情報を返します。sqlite3_table_column_metadata（）インターフェースはSQLITE_OKを返し、非NULLポインターを指定された列が存在する場合、適切な値を持つ最後の5つの引数。 sqlite3_table_column_metadata（）インターフェースはSQLITE_ERRORを返し、指定された列が存在しない場合に返ります。 sqlite3_table_column_metadata（）のcolumn-nameパラメータがNULLポインタの場合、このルーチンはテーブルの存在を確認し、テーブルが存在する場合はSQLITE_OKを、存在しない場合はSQLITE_ERRORを返します。 sqlite3_table_column_metadata（X、D、T、C、...）への呼び出しのテーブル名パラメーターTがNULLの場合、結果は未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="14811f3f6309b7a46fb7b07e8c86e4e522dd9f2d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X、D、T、C、....）ルーチンは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; XのデータベースDにあるテーブルTの列Cに関する情報を返します。sqlite3_table_column_metadata（）インターフェースはSQLITE_OKを返し、非NULLポインターを指定された列が存在する場合、適切な値を持つ最後の5つの引数。 sqlite3_table_column_metadata（）インターフェースはSQLITE_ERRORを返し、指定された列が存在しない場合に返ります。 sqlite3_table_column_metadata（）のcolumn-nameパラメータがNULLポインタの場合、このルーチンはテーブルの存在を確認し、テーブルが存在する場合はSQLITE_OKを、存在しない場合はSQLITE_ERRORを返します。 sqlite3_table_column_metadata（X、D、T、C、...）への呼び出しのテーブル名パラメーターTがNULLの場合、結果は未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="b6f71c56bc991c72ab07825bab1be2b2926a3b41" translate="yes" xml:space="preserve">
          <source>The sqlite3_test_control() interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes. The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.</source>
          <target state="translated">sqlite3_test_control()インターフェイスは、SQLiteの内部状態を読み出し、テスト目的でSQLiteにフォルトを注入するために使用されます。最初のパラメータは操作コードで、それ以降のすべてのパラメータの数、意味、操作を決定します。</target>
        </trans-unit>
        <trans-unit id="5082c0760e0921243970779b3672c52191342376" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">sqlite3_threadsafe（）関数は、&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;コンパイル時オプションが0に設定されているためにSQLiteがミューテックスコードを省略してコンパイルされた場合にのみ、ゼロを返します。</target>
        </trans-unit>
        <trans-unit id="a21f6ed50c99e2696e83c890474c76bf238b4d0d" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">sqlite3_threadsafe（）関数は、&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;コンパイル時オプションが0に設定されているためにSQLiteがミューテックスコードを省略してコンパイルされた場合にのみ、ゼロを返します。</target>
        </trans-unit>
        <trans-unit id="bda43267162a3774849f8ead3ae62d9dfab76a35" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace() callbacks occur before each statement is executed, not when the statement is compiled.</source>
          <target state="translated">sqlite3_trace()のコールバックは、各ステートメントが実行される前に発生し、ステートメントがコンパイルされたときに発生するのではありません。</target>
        </trans-unit>
        <trans-unit id="1ffc76f2d02a8dff2313298df0260161ca209b9b" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2（）インターフェースは、古いインターフェース&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;を置き換えることを目的としています。どちらも非推奨です。</target>
        </trans-unit>
        <trans-unit id="377ad2a0a4bd528d9de5514af64376270faee9cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2（）インターフェースは、古いインターフェース&lt;a href=&quot;profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;と&lt;a href=&quot;profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;を置き換えることを目的としています。どちらも非推奨です。</target>
        </trans-unit>
        <trans-unit id="423d6e23fa8d1a2ce23d8999f3685bde80941a45" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2（D、M、X、P）インターフェイスは、プロパティマスクMとコンテキストポインターPを使用して、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; D に対してトレースコールバック関数Xを登録します。XコールバックがNULLの場合、またはMマスクがゼロの場合、トレースは無効になります。 。M引数は、ゼロ以上の&lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt;定数のビット単位のOR結合された組み合わせである必要があります。</target>
        </trans-unit>
        <trans-unit id="c43af05001b13bd414732905f7825bbbb97dce0a" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2（D、M、X、P）インターフェイスは、プロパティマスクMとコンテキストポインターPを使用して、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; D に対してトレースコールバック関数Xを登録します。XコールバックがNULLの場合、またはMマスクがゼロの場合、トレースは無効になります。 。M引数は、ゼロ以上の&lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt;定数のビット単位のOR結合された組み合わせである必要があります。</target>
        </trans-unit>
        <trans-unit id="99807c4e04d2f72ca0bf7cd79e0b0ccb8d1cdec6" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook（）インターフェースは、&lt;a href=&quot;rowidtable&quot;&gt;ROWIDテーブル&lt;/a&gt;で行が更新、挿入、または削除されるたびに呼び出される最初の引数で識別される&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続に&lt;/a&gt;コールバック関数を登録します。同じデータベース接続に対するこの関数への以前の呼び出しによって設定されたコールバックは上書きされます。</target>
        </trans-unit>
        <trans-unit id="f13c4b8c3d5b462597549f85fa26ca8898f02c2a" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook（）インターフェースは、&lt;a href=&quot;../rowidtable&quot;&gt;ROWIDテーブル&lt;/a&gt;で行が更新、挿入、または削除されるたびに呼び出される最初の引数で識別される&lt;a href=&quot;sqlite3&quot;&gt;データベース接続に&lt;/a&gt;コールバック関数を登録します。同じデータベース接続に対するこの関数への以前の呼び出しによって設定されたコールバックは上書きされます。</target>
        </trans-unit>
        <trans-unit id="299c5d8dbf8312233913ebdfb7abe735c08c4d12" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook（D、C、P）関数は、同じ&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dでの前の呼び出しからのP引数、またはDでの最初の呼び出しではNULLを返します。</target>
        </trans-unit>
        <trans-unit id="b7813b4170b9b916299f8d86a0cb2ffbf096aaa5" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook（D、C、P）関数は、同じ&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dでの前の呼び出しからのP引数、またはDでの最初の呼び出しではNULLを返します。</target>
        </trans-unit>
        <trans-unit id="07d5885fa75b35071ed61bef7a0d72dc8a43c3b7" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P is does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean(F,P,B)ルーチンは、Pがブール値のパラメータであると仮定し、Pの値に応じて真(1)または偽(0)を返します。sqlite3_uri_boolean(F,P,B)ルーチンは、問い合わせパラメータPの値が &quot;no&quot;、&quot;false&quot;、&quot;off &quot;のいずれかである場合、または値がゼロから始まる数値である場合、false(0)を返します。PがFのクエリパラメータではない場合、またはPの値が上記のいずれにも一致しない場合、sqlite3_uri_boolean(F,P,B)は(B!=0)を返します。</target>
        </trans-unit>
        <trans-unit id="d8465d3a607ae26cbee19418630adba78c7f16b3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_int64(F,P,D) routine converts the value of P into a 64-bit signed integer and returns that integer, or D if P does not exist. If the value of P is something other than an integer, then zero is returned.</source>
          <target state="translated">sqlite3_uri_int64(F,P,D)ルーチンはPの値を64ビット符号付き整数に変換し、その整数を返します。Pの値が整数以外の場合、0が返されます。</target>
        </trans-unit>
        <trans-unit id="4924027328fd6dc74b1360ec20381b3f6724812a" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data（）インターフェイスは、アプリケーション定義関数を最初に登録した&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;ルーチンのpUserDataパラメーター（5番目のパラメーター）であったポインターのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="bf548778e52386bbdaeeb7ac3a4e8320cb6164f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data（）インターフェイスは、アプリケーション定義関数を最初に登録した&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;および&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;ルーチンのpUserDataパラメーター（5番目のパラメーター）であったポインターのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="ea63e7ca04dfc54c7a9a4dfd28964eb4fb6446f1" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数の&lt;/a&gt;実装にパラメーターとして渡されるsqlite3_valueオブジェクトは保護されています。&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;によって返されるsqlite3_valueオブジェクトは保護されていません。保護されていないsqlite3_valueオブジェクトは、&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;、および&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;への引数としてのみ使用できます。&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;インターフェースのファミリーはsqlite3_valueオブジェクト保護を必要とします。</target>
        </trans-unit>
        <trans-unit id="d38041b5ccb2d09a369551e816f131ddba2abad9" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数の&lt;/a&gt;実装にパラメーターとして渡されるsqlite3_valueオブジェクトは保護されています。&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;によって返されるsqlite3_valueオブジェクトは保護されていません。保護されていないsqlite3_valueオブジェクトは、&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;、&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;、および&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;への引数としてのみ使用できます。&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;インターフェースのファミリーはsqlite3_valueオブジェクト保護を必要とします。</target>
        </trans-unit>
        <trans-unit id="a0129b60c59e08fad26659c0f3fdb0270cff463d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup（V）インターフェースは&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトDのコピーを作成し、そのコピーへのポインターを返します。&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;返さは、&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;入力がない場合でも、オブジェクト。sqlite3_value_dup（V）インターフェイスは、VがNULLの場合、またはメモリ割り当てが失敗した場合にNULLを返します。</target>
        </trans-unit>
        <trans-unit id="0aa98b18c314b7d86c75837f6de77eb6d3e0637d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup（V）インターフェースは&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトDのコピーを作成し、そのコピーへのポインターを返します。&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;返さは、&lt;a href=&quot;value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;入力がない場合でも、オブジェクト。sqlite3_value_dup（V）インターフェイスは、VがNULLの場合、またはメモリ割り当てが失敗した場合にNULLを返します。</target>
        </trans-unit>
        <trans-unit id="e0414ddee749e340e753046c8b57c08bdec5a9dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free（V）インターフェースは、以前に&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;から取得した&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトを解放します。VがNULLポインターの場合、sqlite3_value_free（V）は無害な何もしません。</target>
        </trans-unit>
        <trans-unit id="e1cbff52a059b27e36ab50ec612e0a1c2d7433c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free（V）インターフェースは、以前に&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;から取得した&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトを解放します。VがNULLポインターの場合、sqlite3_value_free（V）は無害な何もしません。</target>
        </trans-unit>
        <trans-unit id="7d48e35fde2b5031a0a61511df13116d92432d3c" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">値Xが&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;インターフェイスの1つから発生した場合、sqlite3_value_frombind（X）インターフェイスはゼロ以外を返します。XがSQLリテラル値、またはテーブルの列と式に由来する場合、sqlite3_value_frombind（X）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="4099e909bffc50f671788cefdd0e00a496608c5a" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">値Xが&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;インターフェイスの1つから発生した場合、sqlite3_value_frombind（X）インターフェイスはゼロ以外を返します。XがSQLリテラル値、またはテーブルの列と式に由来する場合、sqlite3_value_frombind（X）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="e4ba714b8f0c8b8a0a85eade6cc85a5f85674f5b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type（）インターフェースは、数値に類似性を値に適用しようとします。つまり、値を整数または浮動小数点に変換する試みが行われます。情報を失うことなくそのような変換が可能な場合（つまり、値が数値のように見える文字列である場合）、変換が実行されます。それ以外の場合、変換は行われません。変換後の&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;データ型&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="d57e13a61eeb32fc6ccab4def9ab890b09fb83b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;c_blob&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type（）インターフェースは、数値に類似性を値に適用しようとします。つまり、値を整数または浮動小数点に変換する試みが行われます。情報を失うことなくそのような変換が可能な場合（つまり、値が数値のように見える文字列である場合）、変換が実行されます。それ以外の場合、変換は行われません。変換後の&lt;a href=&quot;c_blob&quot;&gt;データ型&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="4ec72e1543814b021a25a90d5cb860b5227da9f5" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）関数は、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;引数Vのサブタイプを返します。サブタイプ情報を使用して、あるSQL関数から別のSQL関数に限られた量のコンテキストを渡すことができます。&lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;ルーチンを使用して、SQL関数の戻り値のサブタイプを設定します。</target>
        </trans-unit>
        <trans-unit id="ff11a55e63d67f21f428483b7880706f081aadf2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）関数は、&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;引数Vのサブタイプを返します。サブタイプ情報を使用して、あるSQL関数から別のSQL関数に限られた量のコンテキストを渡すことができます。&lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;ルーチンを使用して、SQL関数の戻り値のサブタイプを設定します。</target>
        </trans-unit>
        <trans-unit id="b0e636524c92f0e1651fb00be6db5e8d57af0255" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_text16() interface extracts a UTF-16 string in the native byte-order of the host machine. The sqlite3_value_text16be() and sqlite3_value_text16le() interfaces extract UTF-16 strings as big-endian and little-endian respectively.</source>
          <target state="translated">sqlite3_value_text16()インタフェースは、ホストマシンのネイティブバイト順でUTF-16文字列を抽出します。sqlite3_value_text16be()とsqlite3_value_text16le()は、UTF-16文字列をそれぞれビッグエンディアンとリトルエンディアンで抽出します。</target>
        </trans-unit>
        <trans-unit id="abd8dcf49d86f46dedd1a279c57c33b107030fa7" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type（V）インターフェイスは、&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトVの初期データ&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;型のデータ型コード&lt;/a&gt;を返します。戻り値は、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULLの&lt;/a&gt;いずれかです。他のインターフェースはsqlite3_valueオブジェクトのデータ型を変更するかもしれません。たとえば、データ型が最初にSQLITE_INTEGERであり、sqlite3_value_text（V）がその整数のテキスト値を抽出するために呼び出された場合、sqlite3_value_type（V）への後続の呼び出しはSQLITE_TEXTを返す可能性があります。永続的な内部データ型変換が発生するかどうかは定義されておらず、SQLiteのリリースごとに変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9cdf3c345651dd059fa86a01b992ffdfc67b3546" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type（V）インターフェイスは、&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトVの初期データ&lt;a href=&quot;c_blob&quot;&gt;型のデータ型コード&lt;/a&gt;を返します。戻り値は、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;、または&lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULLの&lt;/a&gt;いずれかです。他のインターフェースはsqlite3_valueオブジェクトのデータ型を変更するかもしれません。たとえば、データ型が最初にSQLITE_INTEGERであり、sqlite3_value_text（V）がその整数のテキスト値を抽出するために呼び出された場合、sqlite3_value_type（V）への後続の呼び出しはSQLITE_TEXTを返す可能性があります。永続的な内部データ型変換が発生するかどうかは定義されておらず、SQLiteのリリースごとに変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9fd8993db96d6be0a53b95ff8fe5c5a06191a2c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version []文字列定数には、&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;マクロのテキストが含まれています。 sqlite3_libversion（）関数は、sqlite3_version []文字列定数へのポインターを返します。 DLLユーザーは通常、DLL内の文字列定数に直接アクセスできないため、sqlite3_libversion（）関数はDLLで使用するために提供されています。 sqlite3_libversion_number（）関数は&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBERに&lt;/a&gt;等しい整数を返します。 sqlite3_sourceid（）関数は、&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; Cプリプロセッサマクロと同じ値を持つ文字列定数へのポインタを返します。&lt;a href=&quot;amalgamation&quot;&gt;統合の&lt;/a&gt;編集されたコピーを使用してSQLiteが構築されている場合を除き、ハッシュの最後の4文字は&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;と異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="a807d081504ff9864c4a0f322dee10127ba34ee0" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;../amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version []文字列定数には、&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;マクロのテキストが含まれています。 sqlite3_libversion（）関数は、sqlite3_version []文字列定数へのポインターを返します。 DLLユーザーは通常、DLL内の文字列定数に直接アクセスできないため、sqlite3_libversion（）関数はDLLで使用するために提供されています。 sqlite3_libversion_number（）関数は&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBERに&lt;/a&gt;等しい整数を返します。 sqlite3_sourceid（）関数は、&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; Cプリプロセッサマクロと同じ値を持つ文字列定数へのポインタを返します。&lt;a href=&quot;../amalgamation&quot;&gt;統合の&lt;/a&gt;編集されたコピーを使用してSQLiteが構築されている場合を除き、ハッシュの最後の4文字は&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;と異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="b7f0635e95ae6f97edbc2a13b7ebfc89ee7bf9a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_vfs_find() interface returns a pointer to a VFS given its name. Names are case sensitive. Names are zero-terminated UTF-8 strings. If there is no match, a NULL pointer is returned. If zVfsName is NULL then the default VFS is returned.</source>
          <target state="translated">sqlite3_vfs_find()インタフェースは、名前が与えられたVFSへのポインタを返します。名前は大文字小文字を区別します。名前はゼロ終端のUTF-8文字列です。一致するものがない場合は NULL ポインタが返されます。zVfsName が NULL の場合は、 デフォル ト の VFS が返されます。</target>
        </trans-unit>
        <trans-unit id="88892501427d74185f6b1bff1e11e202173ae158" translate="yes" xml:space="preserve">
          <source>The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().</source>
          <target state="translated">sqlite3_vsnprintf()ルーチンは sqlite3_snprintf()の varargs 版です。</target>
        </trans-unit>
        <trans-unit id="bfe11fb394a04090848d426f27d7f821bd426298" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint（D、X）は&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;（D、X、&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;、0,0）と同等です。</target>
        </trans-unit>
        <trans-unit id="a5b2980a50de42ca24a7d3c803dbeadfa7a488ca" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint（D、X）は&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;（D、X、&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;、0,0）と同等です。</target>
        </trans-unit>
        <trans-unit id="7f281b26d80df2d4297decb3bb5684de63641309" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2（D、X、M、L、C）インターフェイスは、モードMの&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; DのデータベースXでチェックポイント操作を実行します。ステータス情報は、LおよびCが指す整数に書き戻されます。Mパラメータは有効である必要があります&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;チェックポイントモード&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4f16d84b1dffbf24b61871d0a39f458136f5ce78" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;c_checkpoint_full&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2（D、X、M、L、C）インターフェイスは、モードMの&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; DのデータベースXでチェックポイント操作を実行します。ステータス情報は、LおよびCが指す整数に書き戻されます。Mパラメータは有効である必要があります&lt;a href=&quot;c_checkpoint_full&quot;&gt;チェックポイントモード&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="121e4ad510585a0237e3a007626cc2d427159cf6" translate="yes" xml:space="preserve">
          <source>The sqlite3changeset_apply() function automatically converts the zero-length blob back to a NULL value when updating the sqlite_stat1 table. However, if the application calls sqlite3changeset_new(), sqlite3changeset_old() or sqlite3changeset_conflict on a changeset iterator directly (including on a changeset iterator passed to a conflict-handler callback) then the X'' value is returned. The application must translate X'' to NULL itself if required.</source>
          <target state="translated">sqlite3changeset_apply()関数は、sqlite_stat1テーブルを更新する際に、長さ0のブロブを自動的にNULL値に変換します。しかし、アプリケーションが直接(コンフリクトハンドラコールバックに渡されたチェンジセットイテレータを含む)チェンジセットイテレータ上でsqlite3changeset_new()、sqlite3changeset_old()、sqlite3changeset_conflictを呼び出した場合、X''値が返されます。必要であれば、アプリケーションはX''を自身でNULLに変換しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ab7530db4d4c9fc320d8eb6c02294cea75207425" translate="yes" xml:space="preserve">
          <source>The sqlite3rbu_open(T,A,S) function returns a pointer to an &quot;sqlite3rbu&quot; object, which is then passed into the subsequent interfaces.</source>
          <target state="translated">sqlite3rbu_open(T,A,S)関数は &quot;sqlite3rbu &quot;オブジェクトへのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="bcc8971708ade277f3f9ba38012f5db2060092ea" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is not threadsafe. If it is invoked while any other thread is inside any other sessions method then the results are undefined. Furthermore, if it is invoked after any sessions related objects have been created, the results are also undefined.</source>
          <target state="translated">sqlite3session_config()インタフェースはスレッドセーフではありません。他のスレッドが他のsessionメソッド内にある間に呼び出された場合、結果は未定義です。さらに、セッションに関連するオブジェクトが作成された後に呼び出された場合も、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="ed3502dd7610ba7f06fbfad0a9a6bcb2eec2c983" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is used to make global configuration changes to the sessions module in order to tune it to the specific needs of the application.</source>
          <target state="translated">sqlite3session_config()インターフェースは、アプリケーションの特定のニーズに合わせて調整するために、セッションモジュールにグローバルな設定変更を行うために使用されます。</target>
        </trans-unit>
        <trans-unit id="517ed7f5443765d182eb47f3b8b955f48af65e6e" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_get() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">sqlite_compileoption_get（）SQL関数は、&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt; C / C ++関数のラッパーです。このルーチンは、SQLiteのビルドに使用されるN番目のコンパイル時オプションを返すか、Nが範囲外の場合はNULLを返します。&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_optionsプラグマ&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="62942f05e5a1956f6b33c8235e025eeea5e49332" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_used() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; C/C++ function. When the argument X to sqlite_compileoption_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build.</source>
          <target state="translated">sqlite_compileoption_used（）SQL関数は、&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used（）&lt;/a&gt; C / C ++関数のラッパーです。sqlite_compileoption_used（X）の引数Xがコンパイル時オプションの名前である文字列である場合、このルーチンは、ビルド中にそのオプションが使用されたかどうかに応じて、true（1）またはfalse（0）を返します。</target>
        </trans-unit>
        <trans-unit id="029c047f81979126902e66d7c2206be9ceebe6ff" translate="yes" xml:space="preserve">
          <source>The sqlite_master table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_master table itself. The sqlite_master table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_masterテーブル自体のエントリがない場合を除き、sqlite_masterテーブルには、データベーススキーマのテーブル、インデックス、ビュー、トリガー（まとめて「オブジェクト」）ごとに1つの行が含まれます。sqlite_masterテーブルには、アプリケーション定義およびプログラマー定義のオブジェクトに加えて、&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部スキーマオブジェクトの&lt;/a&gt;エントリが含まれています。</target>
        </trans-unit>
        <trans-unit id="9e701356a8021b4fb9727300fa9f7200eddb250b" translate="yes" xml:space="preserve">
          <source>The sqlite_master.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_master entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_master entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_master.nameカラムはオブジェクトの名前を保持します。テーブルの&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;および&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;制約により、SQLite は &quot;sqlite_autoindex_TABLE_N&quot;という形式の名前で&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部インデックス&lt;/a&gt;を作成します。ここで、TABLEは制約を含むテーブルの名前に置き換えられ、Nは1で始まり、各制約で1ずつ増える整数です。テーブル定義に表示されます。では&lt;a href=&quot;withoutrowid&quot;&gt;ROWID WITHOUT&lt;/a&gt;テーブル、PRIMARY KEYにはsqlite_masterエントリが存在しませんが、sqlite_masterエントリが存在しなかったかのように「sqlite_autoindex_TABLE_N」名前はPRIMARY KEYのために確保されています。これは、後続のUNIQUE制約の番号付けに影響します。 「sqlite_autoindex_TABLE_N」&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEYに名前が割り当てられることはありません&lt;/a&gt;、ROWID表またはWITHOUT ROWID表のいずれか。</target>
        </trans-unit>
        <trans-unit id="3bae42f70521e9e8cd4db2168d1d1babca7ff5fa" translate="yes" xml:space="preserve">
          <source>The sqlite_master.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_master.rootpageカラムは、テーブルとインデックスのルートb-treeページのページ番号を格納します。ビュー、トリガ、仮想テーブルを定義する行の場合、rootpageカラムは0またはNULLです。</target>
        </trans-unit>
        <trans-unit id="ccb922e59255362de7628494ea2946015486eb28" translate="yes" xml:space="preserve">
          <source>The sqlite_master.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_master.sql列には、オブジェクトを説明するSQLテキストが格納されます。このSQLテキストは&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;、&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;、または&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;ステートメントであり、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続の&lt;/a&gt;メインデータベースであるときにデータベースファイルに対して評価されると、オブジェクトが再作成されます。テキストは通常​​、オブジェクトの作成に使用された元のステートメントのコピーですが、テキストが次の規則に準拠するように正規化が適用されています。</target>
        </trans-unit>
        <trans-unit id="8ef76cce54ac5ead8c9ecfb2e98b71a272278d61" translate="yes" xml:space="preserve">
          <source>The sqlite_master.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_master.tbl_nameカラムは、オブジェクトが関連付けられているテーブルやビューの名前を保持します。テーブルやビューの場合、tbl_nameカラムはnameカラムのコピーです。インデックスの場合、tbl_nameはインデックス化されたテーブルの名前です。トリガの場合、tbl_name カラムは、トリガを発生させるテーブルまたはビューの名前を格納します。</target>
        </trans-unit>
        <trans-unit id="1161ce8b03e8867e67c57e405c9c72a8e7f39824" translate="yes" xml:space="preserve">
          <source>The sqlite_master.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_master.typeカラムは、定義されたオブジェクトのタイプに応じて、「テーブル」、「インデックス」、「ビュー」、または「トリガー」のいずれかのテキスト文字列になります。'table'文字列は、通常の&lt;a href=&quot;vtab&quot;&gt;テーブル&lt;/a&gt;と仮想テーブルの両方に使用されます。</target>
        </trans-unit>
        <trans-unit id="8a4ecb6a492d4b0952a80c0d2b263ba43418de02" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) SQL function is only available if SQLite is built using the &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; compile-time option.</source>
          <target state="translated">sqlite_offset（X）SQL関数は、SQLiteが&lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;コンパイル時オプションを使用してビルドされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="f36120db3cfab77bf49cfde55bfe4a03928e953b" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite_offset(X) returns NULL. The value returned by sqlite_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite_offset(X) returns the offset to the table record.</source>
          <target state="translated">sqlite_offset(X)関数は、値が読み込まれるレコードの先頭のデータベースファイル内のバイトオフセットを返します。Xが通常のテーブルのカラムでない場合、sqlite_offset(X)はNULLを返します。sqlite_offset(X)が返す値は、クエリに応じて、元のテーブルかインデックスを参照します。値Xが通常インデックスから抽出される場合、sqlite_offset(X)は対応するインデックスレコードへのオフセットを返します。値Xが元のテーブルから抽出される場合、sqlite_offset(X)はテーブルレコードへのオフセットを返します。</target>
        </trans-unit>
        <trans-unit id="4f99e581aad3bfe8af33ed6ae438c6f190e18bdd" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_master table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequenceテーブルは、&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENTの&lt;/a&gt;実装に役立つ内部テーブルです。sqlite_sequenceテーブルは、AUTOINCREMENT整数の主キーを持つ通常のテーブルが作成されるたびに自動的に作成されます。作成されると、sqlite_sequenceテーブルはsqlite_masterテーブルに永久に存在します。落とすことはできません。sqlite_sequenceテーブルのスキーマは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e2336dfb15c81a1bc2e023f4a5ddff1cb80eb4aa" translate="yes" xml:space="preserve">
          <source>The sqlite_source_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite_source_id() is the date and time that the source code was checked in followed by the SHA1 hash for that check-in. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C interface.</source>
          <target state="translated">sqlite_source_id（）関数は、SQLiteライブラリの構築に使用されたソースコードの特定のバージョンを識別する文字列を返します。sqlite_source_id（）によって返される文字列は、ソースコードがチェックインされた日時であり、その後にそのチェックインのSHA1ハッシュが続きます。この関数は、&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt; CインターフェイスのSQLラッパーです。</target>
        </trans-unit>
        <trans-unit id="7f3f3c25482d0c81576dfc7ce696a273cc1dcba3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat1 is an internal table created by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used to hold supplemental information about tables and indexes that the query planner can use to help it find better ways of performing queries. Applications can update, delete from, insert into or drop the sqlite_stat1 table, but may not create or alter the sqlite_stat1 table. The schema of the sqlite_stat1 table is as follows:</source>
          <target state="translated">sqlite_stat1は、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドによって作成された内部テーブルであり、クエリプランナーがクエリを実行するためのより良い方法を見つけるために使用できるテーブルとインデックスに関する補足情報を保持するために使用されます。アプリケーションは、sqlite_stat1テーブルを更新、削除、挿入、または削除できますが、sqlite_stat1テーブルを作成または変更することはできません。sqlite_stat1テーブルのスキーマは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="eac5f10d8bfa6fc7cd030e9acfc883c862434c99" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 entries for an index that have sqlite_stat2.sampleno between 0 and 9 inclusive are samples of the left-most key value in the index taken at evenly spaced points along the index. Let C be the number of rows in the index. Then the sampled rows are given by</source>
          <target state="translated">sqlite_stat2.samplenoが0から9の間にあるインデックスのsqlite_stat2項目は、インデックスに沿って等間隔で取得されたインデックスの左端のキー値のサンプルです。Cをインデックスの行数とします。サンプリングされた行は次式で与えられます。</target>
        </trans-unit>
        <trans-unit id="db07f0500ccc51725e75c485f7f2868bee244cc2" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 is only created and is only used if SQLite is compiled with SQLITE_ENABLE_STAT2 and if the SQLite version number is between 3.6.18 (2009-09-11) and 3.7.8 (2011-09-19). The sqlite_stat2 table is neither read nor written by any version of SQLite before 3.6.18 nor after 3.7.8. The sqlite_stat2 table contains additional information about the distribution of keys within an index. The schema of the sqlite_stat2 table is as follows:</source>
          <target state="translated">sqlite_stat2は、SQLiteがSQLITE_ENABLE_STAT2でコンパイルされ、SQLiteのバージョン番号が3.6.18(2009-09-11)から3.7.8(2011-09-19)の間にある場合にのみ作成され、使用されます。sqlite_stat2テーブルは、3.6.18以前のバージョンのSQLiteでも3.7.8以降のバージョンのSQLiteでも読み書きされません。sqlite_stat2テーブルはインデックス内のキーの分布に関する追加情報を含んでいます。sqlite_stat2テーブルのスキーマは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5e0f4c3583a4ba1380f140be5cb19d805481ba5e" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2.idx column and the sqlite_stat2.tbl column in each row of the sqlite_stat2 table identify an index described by that row. There are usually 10 rows in the sqlite_stat2 table for each index.</source>
          <target state="translated">sqlite_stat2テーブルの各行のsqlite_stat2.idx列とsqlite_stat2.tbl列は、その行で記述されたインデックスを識別します。各インデックスに対してsqlite_stat2テーブルには通常10行あります。</target>
        </trans-unit>
        <trans-unit id="2f0561169a2bdda1f406d666ccb3f34136d53934" translate="yes" xml:space="preserve">
          <source>The sqlite_stat3 is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.7.9 (2011-11-01) or greater. The sqlite_stat3 table is neither read nor written by any version of SQLite before 3.7.9. If the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is used and the SQLite version number is 3.8.1 (2013-10-17) or greater, then sqlite_stat3 might be read but not written. The sqlite_stat3 table contains additional information about the distribution of keys within an index, information that the query planner can use to devise better and faster query algorithms. The schema of the sqlite_stat3 table is as follows:</source>
          <target state="translated">sqlite_stat3は、SQLiteが&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;または&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4で&lt;/a&gt;コンパイルされ、SQLiteのバージョン番号が3.7.9（2011-11-01）以降の場合にのみ使用されます。 sqlite_stat3テーブルは、3.7.9より前のどのバージョンのSQLiteでも読み取りも書き込みもされません。場合&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;コンパイル時のオプションを使用してSQLiteバージョン番号は3.8.1（2013年10月17日）以上であるされ、その後、sqlite_stat3読みますが書き込まれていない可能性があります。 sqlite_stat3テーブルには、インデックス内のキーの分布に関する追加情報が含まれています。この情報は、クエリプランナーがより適切で高速なクエリアルゴリズムを考案するために使用できます。 sqlite_stat3テーブルのスキーマは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="00890c07b6c2c2c2cdb8874e2a1b39eb7801c048" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is a generalization of the sqlite_stat3 table. The sqlite_stat3 table provides information about the left-most column of an index whereas the sqlite_stat4 table provides information about all columns of the index.</source>
          <target state="translated">sqlite_stat4はsqlite_stat3テーブルの一般化です。sqlite_stat3テーブルはインデックスの左端の列に関する情報を提供しますが、sqlite_stat4テーブルはインデックスのすべての列に関する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="17be4a34aae6ba200b1b6b315d0554ec130a710a" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is only created and is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.8.1 (2013-10-17) or greater. The sqlite_stat4 table is neither read nor written by any version of SQLite before 3.8.1. The sqlite_stat4 table contains additional information about the distribution of keys within an index or the distribution of keys in the primary key of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The query planner can sometimes use the additional information in the sqlite_stat4 table to devise better and faster query algorithms. The schema of the sqlite_stat4 table is as follows:</source>
          <target state="translated">sqlite_stat4は、SQLiteが&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;でコンパイルされ、SQLiteのバージョン番号が3.8.1（2013-10-17）以降の場合にのみ作成され、使用されます。 sqlite_stat4テーブルは、3.8.1より前のどのバージョンのSQLiteでも読み取りも書き込みもされません。 sqlite_stat4テーブルには、インデックス内のキーの分散、または&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの主キーのキーの分散に関する追加情報が含まれています。クエリプランナーは、sqlite_stat4テーブルの追加情報を使用して、より高速で高速なクエリアルゴリズムを考案できる場合があります。 sqlite_stat4テーブルのスキーマは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="dc1ec4b833f86cdac2f0f4646210820d900eb53f" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.idx column holds name of the index that the row describes, or in the case of an sqlite_stat4 entry for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, the name of the table itself.</source>
          <target state="translated">sqlite_stat4.idx列が行に記載されているインデックスの名前を保持し、又は用sqlite_stat4エントリの場合に&lt;a href=&quot;withoutrowid&quot;&gt;ROWIDのWITHOUT&lt;/a&gt;テーブル、テーブル自体の名前。</target>
        </trans-unit>
        <trans-unit id="1916f53e908a81ccd0bcf17da67632c5df8295de" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nDLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index that are distinct in the first K columns and where the left-most K columns are collectively less than the left-most K columns of the sample.</source>
          <target state="translated">sqlite_stat4.nDLt列は、K番目の整数が最初のK列で区別され、左端のK列がサンプルの左端のK列よりも集合的に小さいインデックス内のエントリのおおよその数であるN個の整数のリストを保持します。</target>
        </trans-unit>
        <trans-unit id="dc87c0d99b695b0cfc2da2e070670a4e3020def1" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nEq column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose left-most K columns exactly match the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nEq列はN個の整数のリストを保持します。ここで、K番目の整数は、左端のK列がサンプルの左端のK列と正確に一致するインデックスのエントリのおおよその数です。</target>
        </trans-unit>
        <trans-unit id="9c81743d3d82af763c76e0a7b4201b09b9bf99f3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose K left-most columns are collectively less than the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nLt列はN個の整数のリストを保持します。ここで、K番目の整数は、K個の左端の列がサンプルのK個の左端の列よりも小さいインデックスのエントリのおおよその数です。</target>
        </trans-unit>
        <trans-unit id="d2e1c17126c7777e5bb111d59ea8156e8e7627c8" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.sample column holds a BLOB in the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; that encodes the indexed columns followed by the rowid for a rowid table or by the columns of the primary key for a WITHOUT ROWID table. The sqlite_stat4.sample BLOB for the WITHOUT ROWID table itself contains just the columns of the primary key. Let the number of columns encoded by the sqlite_stat4.sample blob be N. For indexes on an ordinary rowid table, N will be one more than the number of columns indexed. For indexes on WITHOUT ROWID tables, N will be the number of columns indexed plus the number of columns in the primary key. For a WITHOUT ROWID table, N will be the number of columns in the primary key.</source>
          <target state="translated">sqlite_stat4.sample列は、インデックス付き列をエンコードした&lt;a href=&quot;fileformat2#record_format&quot;&gt;レコード形式&lt;/a&gt;でBLOBを保持し、その後にROWIDテーブルのROWID、またはWITHOUT ROWIDテーブルの主キーの列が続きます。 WITHOUT ROWIDテーブル自体のsqlite_stat4.sample BLOBには、主キーの列のみが含まれます。 sqlite_stat4.sample blobによってエンコードされた列の数をNとします。通常のROWIDテーブルのインデックスの場合、Nはインデックス付けされた列の数より1つ多くなります。 WITHOUT ROWIDテーブルのインデックスの場合、Nはインデックス付けされた列の数と主キーの列の数の和になります。 WITHOUT ROWIDテーブルの場合、Nは主キーの列の数になります。</target>
        </trans-unit>
        <trans-unit id="d3368a66552678e4208326d2b99cb82cd670c435" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.tbl column holds name of the table that owns the index that the row describes</source>
          <target state="translated">sqlite_stat4.tbl列は、行が記述したインデックスを所有するテーブルの名前を保持します。</target>
        </trans-unit>
        <trans-unit id="b005c74909d1b6008d9a724163e0fb64f6a832fd" translate="yes" xml:space="preserve">
          <source>The sqlite_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt; C-interface.</source>
          <target state="translated">sqlite_version（）関数は、実行中のSQLiteライブラリのバージョン文字列を返します。この関数は、&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion（）&lt;/a&gt; CインターフェイスのSQLラッパーです。</target>
        </trans-unit>
        <trans-unit id="eeb9bf4120a8b3a5d3dfa457114e73704c247a52" translate="yes" xml:space="preserve">
          <source>The stability of the SQLite database file format and the fact that the file format is cross-platform combine to make SQLite database files an excellent choice as an &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt;. The US Library Of Congress acknowledges this by listing SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term preservation of digital content.</source>
          <target state="translated">SQLiteデータベースファイル形式の安定性とファイル形式がクロスプラットフォームであることにより、SQLiteデータベースファイルは&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイル形式&lt;/a&gt;として優れた選択肢になります。米国議会図書館は、SQLite をデジタルコンテンツの長期保存用の&lt;a href=&quot;locrsf&quot;&gt;推奨ストレージフォーマット&lt;/a&gt;としてリストすることでこれを認めています。</target>
        </trans-unit>
        <trans-unit id="edcbc0ddf3b476ae82b56edb901d58f590378e61" translate="yes" xml:space="preserve">
          <source>The standard SQLite source tree contains built-in VFSes for unix and windows. Alternative VFSes can be added at start-time or run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">標準SQLiteソースツリーには、UNIXおよびWindows用の組み込みVFSが含まれています。&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;インターフェイスを使用して、起動時または実行時に代替VFSを追加できます。</target>
        </trans-unit>
        <trans-unit id="3afa9cfa18cab2a00e2e2667b20527102ceccaa0" translate="yes" xml:space="preserve">
          <source>The state of the computer when a database connection is first opened is shown conceptually by the diagram at the right. The area of the diagram on the extreme right (labeled &quot;Disk&quot;) represents information stored on the mass storage device. Each rectangle is a sector. The blue color represents that the sectors contain original data. The middle area is the operating systems disk cache. At the onset of our example, the cache is cold and this is represented by leaving the rectangles of the disk cache empty. The left area of the diagram shows the content of memory for the process that is using SQLite. The database connection has just been opened and no information has been read yet, so the user space is empty.</source>
          <target state="translated">データベース接続が最初に開かれたときのコンピュータの状態を概念的に示すのが右図である。図の右端の領域(「ディスク」と表示されている)は、大容量記憶装置に格納されている情報を表しています。各矩形はセクタを表しています。青色は、セクタに元のデータが含まれていることを表しています。真ん中の領域はオペレーティングシステムのディスクキャッシュです。この例の開始時には、キャッシュは冷たくなっており、これはディスクキャッシュの長方形を空にすることで表現されています。図の左側の領域は、SQLiteを使用しているプロセスのメモリの内容を示しています。データベース接続がオープンされたばかりで、まだ情報が読み込まれていないので、ユーザースペースは空です。</target>
        </trans-unit>
        <trans-unit id="c2357c705a667a06ce3b401fc40060cc2044167c" translate="yes" xml:space="preserve">
          <source>The statement above creates a new geopoly table named &quot;newtab&quot;. Every geopoly table contains a built-in integer &quot;rowid&quot; column and a &quot;_shape&quot; column that contains the polygon associated with that row of the table. The example above also defines three auxiliary data columns named &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; that can store whatever additional information the application needs to associate with each polygon. If there is no need to store auxiliary information, the list of auxiliary columns can be omitted.</source>
          <target state="translated">上記のステートメントは、&quot;newtab &quot;という名前の新しいジオポリテーブルを作成します。すべてのジオポリ・テーブルは、テーブルのその行に関連付けられたポリゴンを含むビルトイン整数の &quot;rowid &quot;カラムと&quot;_shape &quot;カラムを含んでいます。上の例では、&quot;a&quot;,&quot;b&quot;,&quot;c &quot;という名前の3つの補助データ列も定義しています。補助情報を格納する必要がない場合は、補助列のリストを省略することができます。</target>
        </trans-unit>
        <trans-unit id="5ab1aefcd821f7c6a31149043d5432c19acbdf4f" translate="yes" xml:space="preserve">
          <source>The statement above may appear syntactically incorrect to some. Refer to the section describing the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple fts queries&lt;/a&gt; for an explanation.</source>
          <target state="translated">上記の文は、一部の人にとって構文的に正しくないように見えるかもしれません。説明については、&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;単純なftsクエリ&lt;/a&gt;を説明するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="ecd0da773db50485ad79c3fe0dd58ba001f98f02" translate="yes" xml:space="preserve">
          <source>The statement journal is given a randomized name, not necessarily in the same directory as the main database, and is automatically deleted at the conclusion of the transaction. The size of the statement journal is proportional to the size of the change implemented by the UPDATE or INSERT statement that caused the statement journal to be created.</source>
          <target state="translated">ステートメント・ジャーナルにはランダムな名前が付けられ、必ずしもメイン・データベースと同じディレクトリにあるとは限らず、トランザクションの終了時に自動的に削除されます。ステートメント・ジャーナルのサイズは、ステートメント・ジャーナルを作成する原因となったUPDATE文またはINSERT文によって実装された変更のサイズに比例します。</target>
        </trans-unit>
        <trans-unit id="abce2a89006a756ad8f25f400ff4bbb7de7fef61" translate="yes" xml:space="preserve">
          <source>The status method is basically a wrapper on the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C-language interface.</source>
          <target state="translated">statusメソッドは基本的に&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt; C言語インターフェースのラッパーです。</target>
        </trans-unit>
        <trans-unit id="2957b92cef7bca913b9349499bded01bd701447b" translate="yes" xml:space="preserve">
          <source>The strategy is to compile a single SQL statement using &lt;b&gt;sqlite_compile&lt;/b&gt; then invoke &lt;b&gt;sqlite_step&lt;/b&gt; multiple times, once for each row of output, and finally call &lt;b&gt;sqlite_finalize&lt;/b&gt; to clean up after the SQL has finished execution.</source>
          <target state="translated">戦略は、&lt;b&gt;sqlite_compile&lt;/b&gt;を使用して単一のSQLステートメントをコンパイルしてから、&lt;b&gt;sqlite_stepを&lt;/b&gt;複数回（出力の行ごとに1回）呼び出し、最後に&lt;b&gt;sqlite_finalize&lt;/b&gt;を呼び出して、SQLの実行が終了した後にクリーンアップします。</target>
        </trans-unit>
        <trans-unit id="7809402bc982c32307d88a8090b6d47f604ca513" translate="yes" xml:space="preserve">
          <source>The string value P4 of length P1 (bytes) is stored in register P2.</source>
          <target state="translated">レジスタP2には、長さP1(バイト)の文字列値P4が格納されている。</target>
        </trans-unit>
        <trans-unit id="995f4878031e82187c641f145afc9d059e07a6dd" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql（P）とsqlite3_normalized_sql（P）によって返される文字列はSQLiteによって管理され、準備されたステートメントが終了すると自動的に解放されます。sqlite3_expanded_sql（P）によって返される文字列は、一方から得られる&lt;a href=&quot;#sqlite3_free&quot;&gt;（sqlite3_malloc）&lt;/a&gt;とに渡すことにより、アプリケーションによって自由でなければならない&lt;a href=&quot;#sqlite3_free&quot;&gt;）sqlite3_free（ &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6988de3a51ce0d23769efda8a1dd27ed60344374" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql（P）とsqlite3_normalized_sql（P）によって返される文字列はSQLiteによって管理され、準備されたステートメントが終了すると自動的に解放されます。sqlite3_expanded_sql（P）によって返される文字列は、一方から得られる&lt;a href=&quot;free&quot;&gt;（sqlite3_malloc）&lt;/a&gt;とに渡すことにより、アプリケーションによって自由でなければならない&lt;a href=&quot;free&quot;&gt;）sqlite3_free（ &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3deeab5872c796defa91ce886ebd57387fbb18a8" translate="yes" xml:space="preserve">
          <source>The subquery and outer query do not both use LIMIT.</source>
          <target state="translated">副問い合わせと外部問い合わせの両方でLIMITを使用していません。</target>
        </trans-unit>
        <trans-unit id="77e0e5365d2489d6a42fa705340d96f457af3864" translate="yes" xml:space="preserve">
          <source>The subquery and the outer query do not both have ORDER BY clauses.</source>
          <target state="translated">副問い合わせと外部問い合わせの両方にORDER BY句がありません。</target>
        </trans-unit>
        <trans-unit id="c18b6359aac0e334ed733af3b59f97a0357158e6" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query does not use aggregates.</source>
          <target state="translated">副問い合わせがLIMITを使用しないか、外部問い合わせが集約を使用しない。</target>
        </trans-unit>
        <trans-unit id="b5bd1b6abc2be3885b869265a72b70231dcb2d09" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query is not a join.</source>
          <target state="translated">副問い合わせがLIMITを使用していないか、外側の問い合わせが結合ではありません。</target>
        </trans-unit>
        <trans-unit id="9a0c8ea79566123f0e4ecc1c9a70135357fff910" translate="yes" xml:space="preserve">
          <source>The subquery does not use OFFSET.</source>
          <target state="translated">副問い合わせはOFFSETを使用しません。</target>
        </trans-unit>
        <trans-unit id="8e09a48cd0d988ee9dac8cadad6cdbfcea3b74f2" translate="yes" xml:space="preserve">
          <source>The subquery has a FROM clause.</source>
          <target state="translated">副問い合わせにはFROM句があります。</target>
        </trans-unit>
        <trans-unit id="14960c81162a6f569b4caa226a699f43010d4c7e" translate="yes" xml:space="preserve">
          <source>The subquery is not DISTINCT.</source>
          <target state="translated">副問い合わせはDISTINCTではありません。</target>
        </trans-unit>
        <trans-unit id="560b14fd5f0c196e23d6c05b79eac72d5d601e25" translate="yes" xml:space="preserve">
          <source>The subquery may not be a recursive CTE.</source>
          <target state="translated">副問い合わせは再帰的なCTEではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="7577bd701d8770ad9fc4050124549876822aa978" translate="yes" xml:space="preserve">
          <source>The substitute character (unicode codepoint 26).</source>
          <target state="translated">置換文字(ユニコードコードコードポイント26)。</target>
        </trans-unit>
        <trans-unit id="1b25cfaa2f051cde5a374dd5fbd3d25bcae8f82b" translate="yes" xml:space="preserve">
          <source>The substr() function in the SQL view above returns the text of the rbu_control argument with the first character (the one corresponding to column &quot;i&quot;, which is not required by the FTS table) removed.</source>
          <target state="translated">上の SQL ビューの substr()関数は、最初の文字 (FTS テーブルでは不要なカラム &quot;i&quot; に対応するもの)を削除した rbu_control 引数のテキストを返します。</target>
        </trans-unit>
        <trans-unit id="1eb749257ff54f4f9f61b55605ad1eef34135ccf" translate="yes" xml:space="preserve">
          <source>The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.</source>
          <target state="translated">substr(X,Y,Z)関数は、入力文字列 X の Y 番目の文字から始まり、Z 文字の長さの部分文字列を返します。Z が省略された場合、 substr(X,Y)は Y 番目の文字から始まる文字列 X の末尾までのすべての文字を返します。X の左端の文字は番号 1 です。Yが負の場合、部分文字列の最初の文字は左からではなく右から数えて見つけます。Zが負の場合、Y番目の文字の前にあるabs(Z)文字が返される。Xが文字列の場合、文字インデックスは実際のUTF-8文字を参照します。XがBLOBの場合、インデックスはバイトを参照する。</target>
        </trans-unit>
        <trans-unit id="8f8f72577e48839e2c6e724a5bcfafdf7566b512" translate="yes" xml:space="preserve">
          <source>The sum of all &quot;four&quot; values. This is used to compute &quot;avg(four)&quot;.</source>
          <target state="translated">すべての &quot;4つ &quot;の値の合計。これは &quot;avg(four)&quot;を計算するために使用されます。</target>
        </trans-unit>
        <trans-unit id="4a5f1cfa6e3d0c304a8016c9b0a8f3f6f7afd998" translate="yes" xml:space="preserve">
          <source>The sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.</source>
          <target state="translated">sum()および total()集約関数は、グループ内のすべての非NULL値の合計を返します。NULL 以外の入力行がない場合は sum()は NULL を返しますが、 total()は 0.0 を返します。NULL は通常、行が存在しない場合の合計の結果としては役に立ちませんが、 SQL 標準ではこれを要求しており、他のほとんどの SQL データベースエンジンでは sum()をこのように実装しているので、互換性を保つために SQLite でも同じように実装しています。標準ではない total()関数は、この設計上の問題を SQL 言語で回避する便利な方法として提供されています。</target>
        </trans-unit>
        <trans-unit id="b11b2e43da7a9faed114feb7f008a51dec0a5a77" translate="yes" xml:space="preserve">
          <source>The suppression of redundant columns in the key suffix of an index entry only occurs in WITHOUT ROWID tables. In an ordinary rowid table, the index entry always ends with the rowid even if the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column is one of the columns being indexed.</source>
          <target state="translated">インデックスエントリのキーサフィックスの冗長列の抑制は、WITHOUT ROWIDテーブルでのみ発生します。通常のROWIDテーブルでは、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列が索引付けされている列の1つであっても、索引エントリは常にROWIDで終わります。</target>
        </trans-unit>
        <trans-unit id="2572ed867faedb74714d50c5898bcb75f0754e78" translate="yes" xml:space="preserve">
          <source>The swarmvtab implementation may open or close databases at any point. By default, it attempts to limit the maximum number of simultaneously open database files to nine. This is not a hard limit - it is possible to construct a scenario that will cause swarmvtab to exceed it.</source>
          <target state="translated">swarmvtab の実装は、いつでもデータベースを開いたり閉じたりすることができます。デフォルトでは、同時に開くデータベースファイルの最大数を9個に制限しようとします。これは難しい制限ではありません-swarmvtabがこの制限を超えるようなシナリオを構築することが可能です。</target>
        </trans-unit>
        <trans-unit id="9f9e99aa51f888cdf6630598d938ef39ae15f9a3" translate="yes" xml:space="preserve">
          <source>The sync operations that SQLite performs to help ensure integrity can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt;. By setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite seem to run faster, but it also allows the operating system to freely reorder writes, which could result in database corruption if a power failure or hard reset occurs prior to all content reaching persistent storage.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;同期プラグマ&lt;/a&gt;を使用して実行時に整合性を無効にできるようにするために実行する同期操作。 PRAGMA Synchronization = OFFを設定すると、すべての同期操作が省略されます。これにより、SQLiteはより高速に実行されているように見えますが、オペレーティングシステムが書き込みを自由に並べ替えることもできるため、すべてのコンテンツが永続ストレージに到達する前に電源障害またはハードリセットが発生すると、データベースが破損する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8ed0f1cf6ef82d0d97320ed63cceee25b526aa88" translate="yes" xml:space="preserve">
          <source>The synchronous version of SQLite is the slowest of the group in this test, but the asynchronous version is the fastest. The difference is the extra time needed to execute fsync().</source>
          <target state="translated">SQLite の同期版はこのテストではグループの中で最も遅くなりましたが、非同期版が最も速くなりました。違いは fsync()の実行に必要な余分な時間です。</target>
        </trans-unit>
        <trans-unit id="88535ccaca4588c188d3dec59b74e5b6c648c437" translate="yes" xml:space="preserve">
          <source>The syntax for a window function is like this:</source>
          <target state="translated">ウィンドウ関数の構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e97f2e6030323368e9626fb51e9e8ff6dc7c7f0a" translate="yes" xml:space="preserve">
          <source>The syntax for integer and floating point literals (collectively &quot;numeric literals&quot;) is shown by the following diagram:</source>
          <target state="translated">整数リテラルと浮動小数点リテラル(総称して「数値リテラル」)の構文を次の図に示します。</target>
        </trans-unit>
        <trans-unit id="c1140f24a0825da092ba683013464dc50c75b952" translate="yes" xml:space="preserve">
          <source>The syntax for row values and the circumstances in which row values can be used are illustrated in examples below.</source>
          <target state="translated">行値の構文と、行値が使用できる状況を以下に例示します。</target>
        </trans-unit>
        <trans-unit id="0601104dedcf396efbb0c30203a6d31fd40a4a67" translate="yes" xml:space="preserve">
          <source>The syntax for the ON CONFLICT clause is as shown above for the CREATE TABLE command. For the INSERT and UPDATE commands, the keywords &quot;ON CONFLICT&quot; are replaced by &quot;OR&quot; so that the syntax reads more naturally. For example, instead of &quot;INSERT ON CONFLICT IGNORE&quot; we have &quot;INSERT OR IGNORE&quot;. The keywords change but the meaning of the clause is the same either way.</source>
          <target state="translated">ON CONFLICT句の構文は、CREATE TABLEコマンドの上記のようになります。INSERTとUPDATEコマンドでは、構文がより自然に読めるように、キーワード &quot;ON CONFLICT &quot;は &quot;OR &quot;に置き換えられています。例えば、&quot;INSERT ON CONFLICT IGNORE &quot;の代わりに &quot;INSERT OR IGNORE &quot;となります。キーワードは変わりますが、句の意味はどちらにしても同じです。</target>
        </trans-unit>
        <trans-unit id="f067d61a53dcb338fdf63bf3df528ef6a0487e73" translate="yes" xml:space="preserve">
          <source>The syntax looks like this:</source>
          <target state="translated">構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="a61a22c417283e11aa14f2ba9ecd8cd0c90ce62d" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;, &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;, &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;, &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and many other commands all permit the user to specify a database object either by its name alone, or by a combination of its name and the name of its database. If no database is specified as part of the object reference, then SQLite searches the main, temp and all attached databases for an object with a matching name. The temp database is searched first, followed by the main database, followed all attached databases in the order that they were attached. The reference resolves to the first match found. For example:</source>
          <target state="translated">構文&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;、&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;、&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;、&lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;、&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;、&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;および他の多くのコマンドは、すべて一人で、その名前によって、またはその名の組み合わせとの名前のいずれかによって、データベース・オブジェクトを指定することを許可しますそのデータベース。オブジェクト参照の一部としてデータベースが指定されていない場合、SQLiteはメイン、一時、および接続されているすべてのデータベースで、一致する名前のオブジェクトを検索します。 tempデータベースが最初に検索され、次にメインデータベース、次に接続されているすべてのデータベースが接続された順に検索されます。参照は、最初に見つかった一致に解決されます。例えば：</target>
        </trans-unit>
        <trans-unit id="070a4a12a4cd8479f973f088343e30dee884b914" translate="yes" xml:space="preserve">
          <source>The syntax that occurs in between the &quot;ON CONFLICT&quot; and &quot;DO&quot; keywords is called the &quot;conflict target&quot;. The conflict target specifies a specific uniqueness constraint that will trigger the upsert. The conflict target is required for DO UPDATE upserts, but is optional for DO NOTHING. When the conflict target is omitted, the upsert behavior is triggered by a violation of any uniqueness constraint on the table of the INSERT.</source>
          <target state="translated">ON CONFLICT」と「DO」キーワードの間に発生する構文は、「コンフリクトターゲット」と呼ばれます。競合ターゲットは、アップサートをトリガする特定の一意性制約を指定します。競合ターゲットは、DO UPDATEアップサートでは必須ですが、DO NOTHINGではオプションです。コンフリクト・ターゲットが省略されている場合、アップサート動作は、INSERTのテーブル上の任意の一意性制約の違反によってトリガされます。</target>
        </trans-unit>
        <trans-unit id="6578fb33b7ba1ef0fa58c80688a069c9340aa258" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size in bytes of the structure that defines an open file: the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. This object will be described more fully below. The point here is that each VFS implementation can define its own &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object containing whatever information the VFS implementation needs to store about an open file. SQLite needs to know how big this object is, however, in order to preallocate enough space to hold it.</source>
          <target state="translated">szOsFileフィールドは、開いているファイルを定義する構造体（&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクト）のバイト単位のサイズです。このオブジェクトについては、後で詳しく説明します。ここでのポイントは、各VFS実装が、VFS実装が開いているファイルについて格納する必要がある情報を含む独自の&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトを定義できることです。SQLiteは、オブジェクトを保持するのに十分なスペースを事前に割り当てるために、このオブジェクトの大きさを知る必要があります。</target>
        </trans-unit>
        <trans-unit id="4160b3968588675d955230ce2bf92a9066be0932" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFileフィールドは、このVFSによって使用されるサブクラス化された&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;構造のサイズです。mxPathnameは、このVFS内のパス名の最大長です。</target>
        </trans-unit>
        <trans-unit id="0c08ad2486a604361da59adedd8095e01f05af8a" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFileフィールドは、このVFSによって使用されるサブクラス化された&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;構造のサイズです。mxPathnameは、このVFS内のパス名の最大長です。</target>
        </trans-unit>
        <trans-unit id="34b2e05f8be89f8919f89034a92c2255013098b0" translate="yes" xml:space="preserve">
          <source>The t2 table is completely unused in the query above, and so the query planner is able to implement the query as if it were written:</source>
          <target state="translated">上記のクエリではt2テーブルは全く使用されていないので、クエリプランナはクエリが書かれているかのように実装することができます。</target>
        </trans-unit>
        <trans-unit id="69666453d6f0a7ffe136a772a15ed97e78f29762" translate="yes" xml:space="preserve">
          <source>The table being clear is in the main database file if P2==0. If P2==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">P2==0の場合、クリアされるテーブルはメインデータベースファイルにあります。 P2==1の場合、クリアされるテーブルはCREATE TEMPORARY TABLEで作成されたテーブルを格納するために使用される補助データベースファイルにあります。</target>
        </trans-unit>
        <trans-unit id="b84cc68d91e3409f1edcdf58fc339f372294c1e2" translate="yes" xml:space="preserve">
          <source>The table being destroyed is in the main database file if P3==0. If P3==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">P3==0の場合、破棄されるテーブルはメインデータベースファイルにあります。 P3==1の場合、クリアされるテーブルはCREATE TEMPORARY TABLEで作成されたテーブルを格納するために使用される補助データベースファイルにあります。</target>
        </trans-unit>
        <trans-unit id="41f345ab868d88acd8992e4784839c2d5c1e8639" translate="yes" xml:space="preserve">
          <source>The table below lists a few of the virtual tables implementations available for SQLite. Developers can deploy these virtual tables in their own applications, or use the implementations shown below as templates for writing their own virtual tables.</source>
          <target state="translated">以下の表は、SQLite で利用可能な仮想テーブルの実装のいくつかを示しています。開発者は、これらの仮想テーブルを独自のアプリケーションに展開したり、以下の実装をテンプレートとして使用して独自の仮想テーブルを作成したりすることができます。</target>
        </trans-unit>
        <trans-unit id="0d5035ee89279b64afd0eeb8d11272d1a3924472" translate="yes" xml:space="preserve">
          <source>The table conceptually has a number of rows and columns. But these numbers are not part of the result table itself. These numbers are obtained separately. Let N be the number of rows and M be the number of columns.</source>
          <target state="translated">テーブルは概念的には行と列の数を持っています。しかし、これらの数字は結果テーブル自体の一部ではありません。これらの数は別々に得られます。Nを行の数、Mを列の数とする。</target>
        </trans-unit>
        <trans-unit id="dcf57858fad384bb52da74fd124071a651012ac9" translate="yes" xml:space="preserve">
          <source>The table has at least as many columns as recorded in the changeset, and</source>
          <target state="translated">テーブルには、チェンジセットに記録されているカラムの数と少なくとも同じ数のカラムがあり</target>
        </trans-unit>
        <trans-unit id="c59c86844961ecda887187879536aa8941add7f6" translate="yes" xml:space="preserve">
          <source>The table has primary key columns in the same position as recorded in the changeset.</source>
          <target state="translated">テーブルには、チェンジセットに記録されているのと同じ位置に主キーカラムがあります。</target>
        </trans-unit>
        <trans-unit id="80f1ee5eb53df523cde7e4859fa53a41bb0e9f57" translate="yes" xml:space="preserve">
          <source>The table has the same name as the name recorded in the changeset, and</source>
          <target state="translated">テーブルは、チェンジセットに記録された名前と同じ名前を持ち</target>
        </trans-unit>
        <trans-unit id="7d27b581c3631a8cd2d37de114b2996daa06d034" translate="yes" xml:space="preserve">
          <source>The table named in the table_info pragma can also be a view.</source>
          <target state="translated">table_infoプラグマで指定されたテーブルはビューにもなります。</target>
        </trans-unit>
        <trans-unit id="79bd6ebb5ebe8eca1811d6164c483996ae2dbb59" translate="yes" xml:space="preserve">
          <source>The table named on the left-hand side of the AS keyword must appear exactly once in the FROM clause of the right-most SELECT statement of the compound select, and nowhere else.</source>
          <target state="translated">AS キーワードの左側に指定されたテーブルは、複合セレクトの右端の SELECT 文の FROM 節に 1 回だけ出現する必要があり、それ以外の場所には出現しません。</target>
        </trans-unit>
        <trans-unit id="747fb24ebf8caf800f314099b86fad330ec2bb21" translate="yes" xml:space="preserve">
          <source>The table that is being changed</source>
          <target state="translated">変更されるテーブル</target>
        </trans-unit>
        <trans-unit id="e089550b926c62bbc2dcb5b20ca60a982f76e723" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of a DELETE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">トリガボディ内のDELETE文の一部として指定されたテーブル名は、修飾されていないものでなければなりません。言い換えれば</target>
        </trans-unit>
        <trans-unit id="f34e54cb0abeaba37df0e01490317583d5a035fb" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of an UPDATE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">トリガ本体内のUPDATE文の一部として指定されたテーブル名は、修飾されていないものでなければなりません。言い換えれば</target>
        </trans-unit>
        <trans-unit id="234e68825ade4fb4c6a3d0e2fe2ac2487e1f2eea" translate="yes" xml:space="preserve">
          <source>The table-valued function returns one row for each record (file, directory or symbolic link) in the zip archive. Each row has the following columns:</source>
          <target state="translated">table-valued 関数は、zip アーカイブ内の各レコード (ファイル、ディレクトリ、シンボリックリンク)について 1 行を返します。各行には以下の列があります。</target>
        </trans-unit>
        <trans-unit id="d7dc1f7c6b1a5d93554b66158b8eab41e9fa0f02" translate="yes" xml:space="preserve">
          <source>The table-valued function syntax may also be used to specify an alternative ranking function. In this case the text describing the ranking function should be specified as the second table-valued function argument. The following three queries are equivalent:</source>
          <target state="translated">テーブル値関数構文は、代替のランキング関数を指定するために使用することもできます。この場合、順位付け関数を記述するテキストを第2のテーブル値関数の引数として指定する必要があります。以下の3つのクエリは同等です。</target>
        </trans-unit>
        <trans-unit id="194c5b8001842ee44aaaa2c4539d9e178d7c37bd" translate="yes" xml:space="preserve">
          <source>The table-valued functions for PRAGMA feature was added in SQLite version 3.16.0 (2017-01-02). Prior versions of SQLite cannot use this feature.</source>
          <target state="translated">SQLite バージョン 3.16.0 (2017-01-02)で PRAGMA 機能のテーブル値関数が追加されました。それ以前のバージョンのSQLiteでは、この機能を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="1296ca23d366e0c8b6ad53b34a86a007a9e6fcba" translate="yes" xml:space="preserve">
          <source>The tables necessary to do full and proper unicode case folding are larger than the whole SQLite library.</source>
          <target state="translated">完全かつ適切なユニコード大文字小文字の折り返しを行うために必要なテーブルは、SQLiteライブラリ全体よりも大きくなります。</target>
        </trans-unit>
        <trans-unit id="1fa68f636ed5379e184e8d386d825c36877f4a63" translate="yes" xml:space="preserve">
          <source>The tables that participate in a union-vtab can be in the same database file, or they can be in separate databases files that are &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to the same database connection.</source>
          <target state="translated">union-vtabに参加しているテーブルは、同じデータベースファイルに存在することも、同じデータベース接続に&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;された別個のデータベースファイルに存在することもできます。</target>
        </trans-unit>
        <trans-unit id="30590c6f42ddca035bfcfa04a6fd54a5c5428cad" translate="yes" xml:space="preserve">
          <source>The target database may already contain a row with the same PRIMARY KEY values as specified by the INSERT change.</source>
          <target state="translated">ターゲット・データベースには、INSERT変更で指定されたものと同じPRIMARY KEY値を持つ行がすでに含まれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="ddffb3a24b55dea30b114ff8f89840fe90c8c752" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the current values of the fields that will be modified by the change may not match the original values stored within the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">ターゲットデータベースには、指定された PRIMARY KEY 値を持つ行が含まれているかもしれませんが、変更によって変更されるフィールドの現在の値は、チェンジセット内に格納されている元の値と一致しないかもしれません。このタイプの競合は、パッチセットを使用している場合には検出されません。</target>
        </trans-unit>
        <trans-unit id="9637f3da3aa12d5bcfe7a6adc7e68c320df396f3" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the other fields may contain values that do not match those stored as part of the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">ターゲットデータベースには指定された PRIMARY KEY 値を持つ行が含まれているかもしれませんが、他のフィールドにはチェンジセットの一部として保存されている値と一致しない値が含まれているかもしれません。このタイプの競合は、パッチセットを使用しているときには検出されません。</target>
        </trans-unit>
        <trans-unit id="11c37f0367cfc6691a61d3fba7a936ab62a7d348" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to delete.</source>
          <target state="translated">削除対象のデータベースには、指定されたPRIMARY KEY値を持つ行が含まれていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="e2b06a833985a4c35aa0208799ae843a7b65a575" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to modify.</source>
          <target state="translated">対象のデータベースには、指定されたPRIMARY KEY値を変更する行が含まれていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="6f87cac991eff302d9976172f7bdf73e926bb9c2" translate="yes" xml:space="preserve">
          <source>The target database may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">ターゲットデータベースが&lt;a href=&quot;wal&quot;&gt;WALモードで&lt;/a&gt;ない可能性があります。</target>
        </trans-unit>
        <trans-unit id="711e958f26b3fdef5ca444454f4ee0f963fc86d6" translate="yes" xml:space="preserve">
          <source>The task of the &quot;query planner&quot; is to figure out the best algorithm or &quot;query plan&quot; to accomplish an SQL statement. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), the query planner component has been rewritten so that it runs faster and generates better plans. The rewrite is called the &quot;next generation query planner&quot; or &quot;NGQP&quot;.</source>
          <target state="translated">「クエリプランナー」のタスクは、SQLステートメントを実行するための最適なアルゴリズムまたは「クエリプラン」を見つけることです。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;バージョン3.8.0&lt;/a&gt;（2013-08-26）以降、クエリプランナーコンポーネントが書き直され、より高速に実行され、より優れたプランを生成します。この書き換えは、「次世代クエリプランナー」または「NGQP」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="42a7ae31a25e761d6c699099d742c17f30af41a6" translate="yes" xml:space="preserve">
          <source>The team_id field cannot be unique because there usually multiple people on the same team. One cannot make the combination of team_id and is_team_leader unique since there are usually multiple non-leaders on each team. The solution to enforcing one leader per team is to create a unique index on team_id but restricted to those entries for which is_team_leader is true:</source>
          <target state="translated">通常、同じチームには複数の人がいるので、 team_idフィールドを一意にすることはできません。各チームには通常複数の非リーダーがいるので、 team_id と is_team_leader の組み合わせを一意にすることはできません。チームごとに1人のリーダーを強制する解決策は、チームIDにユニークなインデックスを作成することですが、is_team_leaderが真であるエントリに限定することです。</target>
        </trans-unit>
        <trans-unit id="0785e2dbbfabdba0d3916b209d305b3e5683f44f" translate="yes" xml:space="preserve">
          <source>The technique of having xFindFunction() return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; was initially used in the implementation of the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;. The xFindFunction() method of that module returns SQLITE_INDEX_CONSTRAINT_FUNCTION for the &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap()&lt;/a&gt; SQL function and it returns SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within()&lt;/a&gt; SQL function. This permits search optimizations for queries such as:</source>
          <target state="translated">xFindFunctionを有するの技術は、（）の戻り値&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTIONは&lt;/a&gt;、最初の実装で使用された&lt;a href=&quot;geopoly&quot;&gt;Geopolyモジュール&lt;/a&gt;。 xFindFunction（）のためにそのモジュールを返すSQLITE_INDEX_CONSTRAINT_FUNCTION方法&lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap（）&lt;/a&gt; SQL関数とそれがためSQLITE_INDEX_CONSTRAINT_FUNCTION + 1を返し&lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within（）&lt;/a&gt; SQL関数。これにより、次のようなクエリの検索を最適化できます。</target>
        </trans-unit>
        <trans-unit id="2710792de033b547bac6e441ea1f9b9d8e9fc431" translate="yes" xml:space="preserve">
          <source>The temp.sqlite_parameters table only provides values for parameters in the command-line shell. The temp.sqlite_parameter table has no effect on queries that are run directly using the SQLite C-language API. Individual applications are expected to implement their own parameter binding. You can search for &quot;sqlite_parameters&quot; in the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;command-line shell source code&lt;/a&gt; to see how the command-line shell does parameter binding, and use that as a hint for how to implement it yourself.</source>
          <target state="translated">temp.sqlite_parametersテーブルは、コマンドラインシェルのパラメーターの値のみを提供します。temp.sqlite_parameterテーブルは、SQLite C言語APIを使用して直接実行されるクエリには影響しません。個々のアプリケーションは、独自のパラメーターバインディングを実装する必要があります。&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;コマンドラインシェルのソースコード&lt;/a&gt;で「sqlite_parameters」を検索して、コマンドラインシェルがパラメータバインディングを実行する方法を確認し、それを自分で実装する方法のヒントとして使用できます。</target>
        </trans-unit>
        <trans-unit id="e0243e43a9e092811e1870e88e873ed47024b50d" translate="yes" xml:space="preserve">
          <source>The temporary file created by the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command exists only for the duration of the command itself. The size of the temporary file will be no larger than the original database.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドによって作成された一時ファイルは、コマンド自体の期間だけ存在します。一時ファイルのサイズは、元のデータベースのサイズ以下になります。</target>
        </trans-unit>
        <trans-unit id="2f2df5fab6b729ca7d2c3e78798e53760ca0b74f" translate="yes" xml:space="preserve">
          <source>The temporary files associated with the TEMP database and its rollback journal are only created if the application makes use of the &quot;CREATE TEMP TABLE&quot; statement.</source>
          <target state="translated">TEMPデータベースとそのロールバックジャーナルに関連付けられた一時ファイルは、アプリケーションが &quot;CREATE TEMP TABLE &quot;ステートメントを使用した場合にのみ作成されます。</target>
        </trans-unit>
        <trans-unit id="f07c39bdad21f0453b3d046fa930925221ebb2c1" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, master journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, master, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">トランザクション制御に関連する一時ファイル、つまりロールバックジャーナル、マスタージャーナル、先読みログ（WAL）ファイル、および共有メモリファイルは、常にディスクに書き込まれます。ただし、他の種類の一時ファイルはメモリにのみ保存され、ディスクに書き込まれることはありません。ロールバック、マスター、ステートメントジャーナル以外の一時ファイルがディスクに書き込まれるか、メモリにのみ保存されるかは、&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーター、&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_storeプラグマ&lt;/a&gt;、および一時ファイルのサイズによって異なります。</target>
        </trans-unit>
        <trans-unit id="42ee5d948678f086d276ab61d7dad5de2797f6e5" translate="yes" xml:space="preserve">
          <source>The term number of the matching term within the full-text query expression. Terms within a query expression are numbered starting from 0 in the order that they occur.</source>
          <target state="translated">フルテキストのクエリ式内の一致する用語の用語番号。クエリ式内の用語には、出現した順に 0 から始まる番号が付けられます。</target>
        </trans-unit>
        <trans-unit id="2146ad4958dfdca7b01896ef7e97e3c556f6bfc0" translate="yes" xml:space="preserve">
          <source>The term, as stored in the FTS5 index.</source>
          <target state="translated">FTS5インデックスに格納されている用語。</target>
        </trans-unit>
        <trans-unit id="efaf8ed4fd273fae5234c31a87ca20e1f921ce05" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">「保護されている」および「保護されていない」という用語は、ミューテックスが保持されているかどうかを示します。保護されたsqlite3_valueオブジェクトの内部ミューテックスは保持されますが、保護されていないsqlite3_valueオブジェクトのミューテックスは保持されません。 SQLiteがシングルスレッド（&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;および&lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe（）が&lt;/a&gt; 0を返す）でコンパイルされている場合、またはSQLiteが縮小ミューテックスモード&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;または&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREADの&lt;/a&gt;いずれかで実行されている場合、保護されているsqlite3_valueオブジェクトと保護されていないsqlite3_valueオブジェクトは区別されず、互換的に使用されます。ただし、コードの移植性を最大限に高めるために、厳密に必要でない場合でも、アプリケーションで保護されたsqlite3_valueオブジェクトと保護されていないsqlite3_valueオブジェクトを区別することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9b59119835d0c98638847083b9be8651dcfed7b3" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">「保護されている」および「保護されていない」という用語は、ミューテックスが保持されているかどうかを示します。保護されたsqlite3_valueオブジェクトの内部ミューテックスは保持されますが、保護されていないsqlite3_valueオブジェクトのミューテックスは保持されません。 SQLiteがシングルスレッド（&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;および&lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe（）が&lt;/a&gt; 0を返す）でコンパイルされている場合、またはSQLiteが縮小ミューテックスモード&lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;または&lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREADの&lt;/a&gt;いずれかで実行されている場合、保護されているsqlite3_valueオブジェクトと保護されていないsqlite3_valueオブジェクトは区別されず、互換的に使用されます。ただし、コードの移植性を最大限に高めるために、厳密に必要でない場合でも、アプリケーションで保護されたsqlite3_valueオブジェクトと保護されていないsqlite3_valueオブジェクトを区別することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d0d8bb329a3e29ad5aa4a494be22dcdfc57447c5" translate="yes" xml:space="preserve">
          <source>The terms in W and X must match exactly. SQLite does not do algebra to try to get them to look the same. The term &quot;b=6&quot; does not match &quot;b=3+3&quot; or &quot;b-6=0&quot; or &quot;b BETWEEN 6 AND 6&quot;. &quot;b=6&quot; will match to &quot;6=b&quot; as long as &quot;b=6&quot; is on the index and &quot;6=b&quot; is in the query. If a term of the form &quot;6=b&quot; appears in the index, it will never match anything.</source>
          <target state="translated">WとXの項は正確に一致しなければなりません。SQLite は、それらを同じように見えるようにするために代数学を行いません。&quot;b=6 &quot;という用語は、&quot;b=3+3 &quot;や &quot;b-6=0 &quot;や &quot;b BETWEEN 6 AND 6 &quot;とは一致しません。&quot;b=6 &quot;がインデックスにあり、&quot;6=b &quot;がクエリにある限り、&quot;b=6 &quot;は &quot;6=b &quot;にマッチします。&quot;6=b &quot;という形式の項がインデックスに現れた場合、それは何にもマッチしない。</target>
        </trans-unit>
        <trans-unit id="1a91aabb1ee8a98e3573519dc568a9cdcf09f371" translate="yes" xml:space="preserve">
          <source>The test infrastructure verifies that SQLite does not misuse dynamically allocated memory by using a specially instrumented memory allocator. The instrumented memory allocator is enabled at compile-time using the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; option. The instrumented memory allocator is much slower than the default memory allocator and so its use is not recommended in production. But when enabled during testing, the instrumented memory allocator performs the following checks:</source>
          <target state="translated">テストインフラストラクチャは、SQLiteが特別に装備されたメモリアロケーターを使用して、動的に割り当てられたメモリを誤用しないことを確認します。インストルメントされたメモリアロケータは、コンパイル時に&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;オプションを使用して有効になります。インストルメントされたメモリアロケータは、デフォルトのメモリアロケータよりもはるかに遅いため、本番環境での使用はお勧めしません。ただし、テスト中に有効にすると、インストルメント化されたメモリアロケータは次のチェックを実行します。</target>
        </trans-unit>
        <trans-unit id="23d89111adcbe2ab0ff1f685425a6f5892695526" translate="yes" xml:space="preserve">
          <source>The test suite is designed to be run three times, once for each of the ALWAYS() and NEVER() definitions shown above. All three test runs should yield exactly the same result. There is a run-time test using the &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;, ...) interface that can be used to verify that the macros are correctly set to the first form (the pass-through form) for deployment.</source>
          <target state="translated">テストスイートは、上記のALWAYS（）およびNEVER（）の定義ごとに1回ずつ、3回実行するように設計されています。3つのテストを実行しても、まったく同じ結果が得られます。&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;、...）インターフェースを使用したランタイムテストがあり、展開用にマクロが最初のフォーム（パススルーフォーム）に正しく設定されていることを確認するために使用できます。</target>
        </trans-unit>
        <trans-unit id="77fbf4494f9eeac6c3dd3e8030fecebddc25654d" translate="yes" xml:space="preserve">
          <source>The test suites for SQLite also explore the result of stacking multiple failures. For example, tests are run to ensure correct behavior when an I/O error or OOM fault occurs while trying to recover from a prior crash.</source>
          <target state="translated">SQLite 用のテストスイートでは、複数の障害を積み重ねた結果についても調査しています。例えば、I/O エラーや OOM フォールトが発生したときに、以前のクラッシュから回復しようとしている間に正しい動作を確認するためにテストが実行されます。</target>
        </trans-unit>
        <trans-unit id="a7eb514323fac72f4df40162cf2fb7ca6826d6f1" translate="yes" xml:space="preserve">
          <source>The test1.dir directory will contain 100,000 files with names like &quot;000000&quot;, &quot;000001&quot;, &quot;000002&quot; and so forth but the test1.tree directory will contain the same files in subdirectories like &quot;00/00/00&quot;, &quot;00/00/01&quot;, and so on. The test1.dir and test1.test directories take up approximately the same amount of space, though test1.test is very slightly larger due to the extra directory entries.</source>
          <target state="translated">test1.dirディレクトリには、&quot;000000&quot;、&quot;000001&quot;、&quot;000002 &quot;などの名前を持つ100,000個のファイルが含まれますが、test1.treeディレクトリには、&quot;00/00/00/00&quot;、&quot;00/00/01 &quot;などのサブディレクトリに同じファイルが含まれます。test1.dirとtest1.testディレクトリは、test1.testが余分なディレクトリエントリのために非常にわずかに大きくなっていますが、スペースのほぼ同じ量を占めています。</target>
        </trans-unit>
        <trans-unit id="833841004a13aff638c7a47f3f35a8f25f41ac0a" translate="yes" xml:space="preserve">
          <source>The test_async.c drive now does full file locking and works correctly when used simultaneously by multiple processes on the same database.</source>
          <target state="translated">test_async.c ドライブが完全なファイルロックを行い、同じデータベース上で複数のプロセスが同時に使用された場合に正しく動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="eb420a5e9808216cc66d2c072d0472129ab690a9" translate="yes" xml:space="preserve">
          <source>The testcase() macro is often used to verify that boundary cases of an inequality comparison are checked. For example, at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt;. These kind of checks help to prevent off-by-one errors.</source>
          <target state="translated">testcase（）マクロは、不等比較の境界ケースがチェックされていることを確認するためによく使用されます。たとえば、&lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https：//sqlite.org/src/artifact/18a53540aa3？ln = 5766にあります&lt;/a&gt;。これらの種類のチェックは、オフバイワンエラーの防止に役立ちます。</target>
        </trans-unit>
        <trans-unit id="bfd50a8b5d17dc1d197a2f0aeffde22600cc3d5e" translate="yes" xml:space="preserve">
          <source>The testcase(X) macro is normally a no-op, but for a coverage test build it does generate a small amount of extra code that includes at least one branch, in order to verify that test cases exist for which X is both true and false.</source>
          <target state="translated">testcase(X)マクロは通常は実行しませんが、カバレッジテストのビルドでは、X が true と false の両方のテストケースが存在することを検証するために、少なくとも 1 つのブランチを含む少量の余分なコードを生成します。</target>
        </trans-unit>
        <trans-unit id="198025ed4b90dd540b423fcfb30efac73a9076a6" translate="yes" xml:space="preserve">
          <source>The testing process for SQLite is described in the &lt;a href=&quot;testing&quot;&gt;testing&lt;/a&gt; document. Testing objectives include:</source>
          <target state="translated">SQLiteのテストプロセスは、&lt;a href=&quot;testing&quot;&gt;テスト&lt;/a&gt;ドキュメントに記載されています。テストの目的は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7f341b9da6892f9f513eb1e23029aaad7d1945bb" translate="yes" xml:space="preserve">
          <source>The testing process is controlled by the &lt;a href=&quot;testing#cklist&quot;&gt;release testing checklists&lt;/a&gt;. The checklists succinctly summary all steps necessary to fully validate SQLite, and they record when and by whom each validation step was performed.</source>
          <target state="translated">テストプロセスは、&lt;a href=&quot;testing#cklist&quot;&gt;リリーステストチェックリスト&lt;/a&gt;によって制御されます。チェックリストは、SQLiteを完全に検証するために必要なすべてのステップを簡潔に要約し、各検証ステップがいつ誰によって実行されたかを記録します。</target>
        </trans-unit>
        <trans-unit id="b10a0b7612e25fb69c97ba29101b2f64b4a7581b" translate="yes" xml:space="preserve">
          <source>The text format is pure SQL so you can also use the .dump command to export an SQLite database into other popular SQL database engines. Like this:</source>
          <target state="translated">テキスト形式は純粋なSQLなので、.dumpコマンドを使用してSQLiteデータベースを他の一般的なSQLデータベースエンジンにエクスポートすることもできます。このような感じです。</target>
        </trans-unit>
        <trans-unit id="002ca6dfea0de9e1d73a68077f123004fa9755de" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_master.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_master.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">sqlite_master.sql列のテキストは、オブジェクトを作成した元のCREATEステートメントのテキストのコピーです。ただし、上記のように正規化され、後続の&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;ステートメントによって変更される場合を除きます。&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;または&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;制約によって自動的に作成される&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部インデックスの&lt;/a&gt;場合、sqlite_master.sqlはNULLです。</target>
        </trans-unit>
        <trans-unit id="3362b59e42a116b494bb787cf561f00b28111a39" translate="yes" xml:space="preserve">
          <source>The text of query parameters is appended to the filename argument of the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Any %HH escape sequences in the query parameters are resolved prior to being appended to the xOpen filename. A single zero-byte separates the xOpen filename argument from the key of the first query parameters, each key and value, and each subsequent key from the prior value. The list of query parameters appended to the xOpen filename is terminated by a single zero-length key. Note that the value of a query parameter can be an empty string.</source>
          <target state="translated">クエリパラメータのテキストは、&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt; xOpenメソッドのファイル名引数に追加されます。クエリパラメータ内の％HHエスケープシーケンスは、xOpenファイル名に追加される前に解決されます。 1つのゼロバイトは、xOpenファイル名引数を最初のクエリパラメータのキー、各キーと値、および後続の各キーを前の値から分離します。 xOpenファイル名に追加されたクエリパラメータのリストは、単一の長さゼロのキーで終了します。クエリパラメータの値は空の文字列でもかまいません。</target>
        </trans-unit>
        <trans-unit id="f010a4aeda05a6fff949d6b23c4d99edd507a5b9" translate="yes" xml:space="preserve">
          <source>The text of the word that matches the pattern. Both word and pattern can contain unicode characters and can be mixed case.</source>
          <target state="translated">パターンに一致する単語のテキスト。単語とパターンの両方ともユニコード文字を含むことができ、大文字と小文字を混在させることができます。</target>
        </trans-unit>
        <trans-unit id="34ac3915c6fa697bff1880701cc84fcf41ef0614" translate="yes" xml:space="preserve">
          <source>The text to add to the start or end of the selected text to indicate that the returned text does not occur at the start or end of its column, respectively.</source>
          <target state="translated">返されたテキストがその列の先頭または末尾に存在しないことを示すために、選択されたテキストの先頭または末尾にそれぞれ追加するテキスト。</target>
        </trans-unit>
        <trans-unit id="5d227441e585adc9dccb7fd5119a447b09eeb780" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match within the returned text.</source>
          <target state="translated">返されたテキスト内の各フレーズマッチの後に挿入するテキスト。</target>
        </trans-unit>
        <trans-unit id="c372789c27ae2ac063bb79f99aab7639b81bdf47" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match.</source>
          <target state="translated">フレーズマッチの後に挿入するテキスト。</target>
        </trans-unit>
        <trans-unit id="98deed99ebb119a4eabb19891d9d80c8f6d99766" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match within the returned text.</source>
          <target state="translated">返されたテキスト内の各フレーズマッチの前に挿入するテキスト。</target>
        </trans-unit>
        <trans-unit id="011020fd80da1d64051ffd57ff7d4f9db6949595" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match.</source>
          <target state="translated">各フレーズマッチの前に挿入するテキスト。</target>
        </trans-unit>
        <trans-unit id="41db7390257d3e1c83cfe7262fbe75efa4098374" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 140 terabytes will be reached first. A 140 terabytes database can hold no more than approximately 1e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">テーブルの行の理論上の最大数は2 &lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt;（18446744073709551616または約1.8e + 19）です。最初に140テラバイトの最大データベースサイズに到達するため、この制限に到達することはできません。140テラバイトのデータベースが保持できるのは約1e + 13行以下であり、インデックスがなく、各行に含まれるデータが非常に少ない場合のみです。</target>
        </trans-unit>
        <trans-unit id="8e681320a770693ff8880c2fe787c3d46c58d6fe" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">これらのルーチンは、結果のデータ型を変換しようとする場合があります。たとえば、内部表現がFLOATであり、テキスト結果が要求された場合、&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;が内部で使用され、変換が自動的に実行されます。次の表に、適用される変換の詳細を示します。</target>
        </trans-unit>
        <trans-unit id="d45ababe332de0d6a9b7d204a8229a091726f141" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">これらのルーチンは、結果のデータ型を変換しようとする場合があります。たとえば、内部表現がFLOATであり、テキスト結果が要求された場合、&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;が内部で使用され、変換が自動的に実行されます。次の表に、適用される変換の詳細を示します。</target>
        </trans-unit>
        <trans-unit id="f29b8fd84fbcfd59fccde21c2067cc383b5612cf" translate="yes" xml:space="preserve">
          <source>The third and fourth parameters to this function are the table and column name of the desired column, respectively.</source>
          <target state="translated">この関数の3番目と4番目のパラメータは、それぞれ目的のカラムのテーブル名とカラム名です。</target>
        </trans-unit>
        <trans-unit id="5dad7ccfb7adf02e60a4718cd1bfaf6cc7ad8094" translate="yes" xml:space="preserve">
          <source>The third argument (eTextRep) must be one of the constants:</source>
          <target state="translated">第3引数(eTextRep)は定数のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="a12fbbce4ea7f98c6f3257e48e8cfdd9d6a7f402" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null().</source>
          <target state="translated">第3引数はパラメータにバインドする値です。sqlite3_bind_text()、sqlite3_bind_text16()、sqlite3_bind_blob()の3番目のパラメータがNULLポインタの場合、4番目のパラメータは無視され、最終的な結果はsqlite3_bind_null()と同じです。</target>
        </trans-unit>
        <trans-unit id="8896799f29c2adcd495a7004a3dfd8ef2c595b55" translate="yes" xml:space="preserve">
          <source>The third argument to the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;,...) interface (the &quot;pData&quot; argument in the example above) is a pointer to arbitrary data. SQLite passes this pointer through to the first argument of the error logger callback. The pointer can be used to pass application-specific setup or state information, if desired. Or it can simply be a NULL pointer which is ignored by the callback.</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;、...）インターフェースの3番目の引数（上記の例では &quot;pData&quot;引数）は、任意のデータへのポインターです。 SQLiteは、このポインターをエラーロガーコールバックの最初の引数に渡します。必要に応じて、ポインターを使用して、アプリケーション固有のセットアップまたは状態情報を渡すことができます。または、コールバックによって無視されるNULLポインタにすることもできます。</target>
        </trans-unit>
        <trans-unit id="8e80d3a19f53ad5c94b48f6b4deace1bd8cd6a01" translate="yes" xml:space="preserve">
          <source>The third chart shows that reading blob content out of SQLite can be twice as fast as reading from individual files on disk for Mac and Android, and an amazing ten times faster for Windows.</source>
          <target state="translated">3 番目のグラフは、SQLite から blob コンテンツを読み出す場合、Mac と Android ではディスク上の個別ファイルから読み出す場合の 2 倍の速さで、Windows では驚くほど 10 倍の速さで読み出すことができることを示しています。</target>
        </trans-unit>
        <trans-unit id="ce81cfaf801aa960a0d4e258e6f72c47aaf642db" translate="yes" xml:space="preserve">
          <source>The third column is the minimum value for any rowid in the table.</source>
          <target state="translated">3 番目の列は、テーブル内の任意の rowid の最小値です。</target>
        </trans-unit>
        <trans-unit id="66b245a2c0333e9c6e002eaadabc21caae3f20aa" translate="yes" xml:space="preserve">
          <source>The third form of an INSERT statement is with DEFAULT VALUES. The INSERT ... DEFAULT VALUES statement inserts a single new row into the named table. Each column of the new row is populated with its &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt;, or with a NULL if no default value is specified as part of the column definition in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is not supported after DEFAULT VALUES.</source>
          <target state="translated">INSERTステートメントの3番目の形式は、DEFAULT VALUESを使用するものです。 INSERT ... DEFAULT VALUESステートメントは、単一の新しい行を名前付きテーブルに挿入します。新しい行の各列には、その&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;デフォルト値&lt;/a&gt;が入力されます&lt;a href=&quot;lang_createtable&quot;&gt;。CREATETABLE&lt;/a&gt;ステートメントの列定義の一部としてデフォルト値が指定されていない場合は、NULLが入力されます。&lt;a href=&quot;syntax/upsert-clause&quot;&gt;アップサート-句は&lt;/a&gt;、デフォルト値の後にサポートされていません。</target>
        </trans-unit>
        <trans-unit id="80211bcbcab262c368d4da63de6e8f61d55d7f66" translate="yes" xml:space="preserve">
          <source>The third line of the example shows the virtual table being used, to read all content of the CSV file. This is perhaps the simplest possible use of the virtual table. The CSV virtual table can be used anywhere an ordinary virtual table can be used. One can use the CSV virtual table inside subqueries, or &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; or add WHERE, GROUP BY, HAVING, ORDER BY, and LIMIT clauses as required.</source>
          <target state="translated">例の3行目は、CSVファイルのすべてのコンテンツを読み取るために使用されている仮想テーブルを示しています。これは、おそらく仮想テーブルの最も単純な使用法です。CSV仮想テーブルは、通常の仮想テーブルを使用できる場所であればどこでも使用できます。サブクエリ内のCSV仮想テーブル、または&lt;a href=&quot;lang_with&quot;&gt;共通テーブル式を&lt;/a&gt;使用するか、必要に応じてWHERE、GROUP BY、HAVING、ORDER BY、およびLIMIT句を追加できます。</target>
        </trans-unit>
        <trans-unit id="37d0f732f75ffbc9298be10c6e109dfc37fa5d4b" translate="yes" xml:space="preserve">
          <source>The third number Z is incremented for releases consisting of only small changes that implement performance enhancements and/or bug fixes.</source>
          <target state="translated">3番目のZ数は、パフォーマンスの向上および/またはバグ修正を実施する小さな変更のみで構成されたリリースに対して増分されています。</target>
        </trans-unit>
        <trans-unit id="d43fa02ec7a69fa0b5cb4656ab69a4413a6918c8" translate="yes" xml:space="preserve">
          <source>The third optimization, zeroing the journal file header rather than deleting the rollback journal file, does not depend on holding an exclusive lock at all times. This optimization can be set independently of exclusive lock mode using the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; as described in &lt;a href=&quot;#section_7_6&quot;&gt;section 7.6&lt;/a&gt; below.</source>
          <target state="translated">3番目の最適化、ロールバックジャーナルファイルを削除するのではなくジャーナルファイルヘッダーをゼロにすることは、常に排他ロックを保持することに依存しません。この最適化は、以下の&lt;a href=&quot;#section_7_6&quot;&gt;セクション7.6で&lt;/a&gt;説明するように、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_modeプラグマ&lt;/a&gt;を使用して、排他ロックモードとは無関係に設定できます。</target>
        </trans-unit>
        <trans-unit id="226219f131eebb1bb82e3a9e80c20160ef9e49d4" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">3番目のパラメーター（nArg）は、SQL関数または集約が取る引数の数です。このパラメーターが-1の場合、SQL関数または集約は、0と&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;）によって設定された制限の間の任意の数の引数を取ることができます。 3番目のパラメーターが-1未満または127より大きい場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="11f56952c8e04a9269627afb8274637d6b360ea2" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">3番目のパラメーター（nArg）は、SQL関数または集約が取る引数の数です。このパラメーターが-1の場合、SQL関数または集約は、0と&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;）によって設定された制限の間の任意の数の引数を取ることができます。 3番目のパラメーターが-1未満または127より大きい場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="7effa7c199d796ec9c7957d5b06f69295ac44ef2" translate="yes" xml:space="preserve">
          <source>The third step starts with the four shortest two-node paths and finds the four shortest three-node paths:</source>
          <target state="translated">第3ステップは、最短2ノードの4つのパスから始まり、最短3ノードの4つのパスを見つけます。</target>
        </trans-unit>
        <trans-unit id="97390ca779620e87876318d53cdbb5c0eb4c1782" translate="yes" xml:space="preserve">
          <source>The threading mode can be selected at compile-time (when the SQLite library is being compiled from source code) or at start-time (when the application that intends to use SQLite is initializing) or at run-time (when a new SQLite database connection is being created). Generally speaking, run-time overrides start-time and start-time overrides compile-time. Except, single-thread mode cannot be overridden once selected.</source>
          <target state="translated">スレッディングモードは、コンパイル時(ソースコードからSQLiteライブラリをコンパイルしているとき)、スタート時(SQLiteを使用しようとするアプリケーションが初期化しているとき)、またはランタイム(新しいSQLiteデータベース接続が作成されているとき)に選択することができます。一般的に言えば、ランタイムはスタートタイムよりも優先され、スタートタイムはコンパイルタイムよりも優先されます。ただし、シングルスレッドモードは一度選択すると上書きできません。</target>
        </trans-unit>
        <trans-unit id="7a0e198fd0423256115863d78eac9cac1343e176" translate="yes" xml:space="preserve">
          <source>The threading mode for an individual database connection is determined by flags given as the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag causes the database connection to be in the multi-thread mode and the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag causes the connection to be in serialized mode. If neither flag is specified or if &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; are used instead of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, then the default mode determined by the compile-time and start-time settings is used.</source>
          <target state="translated">個々のデータベース接続のスレッドモードは、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）の&lt;/a&gt; 3番目の引数として指定されたフラグによって決定されます。&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEXの&lt;/a&gt;フラグは、データベース接続がマルチスレッド・モードであることが原因と&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEXの&lt;/a&gt;フラグがシリアライズモードにする接続を引き起こします。どちらのフラグが指定場合、またはされている場合&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;または&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;の代わりに使用されている&lt;a href=&quot;c3ref/open&quot;&gt;（sqlite3_open_v2） &lt;/a&gt;、デフォルトのモードは、コンパイル時と開始時間を設定することによって決定に使用されます。</target>
        </trans-unit>
        <trans-unit id="a70f1f8b6fb5520108a2b27f649a3322d3c256dc" translate="yes" xml:space="preserve">
          <source>The three auxiliary functions are only useful within a SELECT statement that uses the FTS table's full-text index. If used within a SELECT that uses the &quot;query by rowid&quot; or &quot;linear scan&quot; strategies, then the snippet and offsets both return an empty string, and the matchinfo function returns a blob value zero bytes in size.</source>
          <target state="translated">3つの補助関数は、FTSテーブルのフルテキストインデックスを使用するSELECT文内でのみ有用です。query by rowid &quot;または &quot;linear scan &quot;ストラテジーを使用するSELECT内で使用された場合、スニペットとオフセットはどちらも空の文字列を返し、matchinfo関数はサイズ0バイトのブロブ値を返します。</target>
        </trans-unit>
        <trans-unit id="6eb0a1f7b89a823f8bdbde0d13568a18262e614a" translate="yes" xml:space="preserve">
          <source>The three basic query types described above may be used to query the full-text index for the set of documents that match the specified criteria. Using the FTS query expression language it is possible to perform various set operations on the results of basic queries. There are currently three supported operations:</source>
          <target state="translated">上で説明した3つの基本的な問い合わせタイプは、指定された条件に一致する文書の集合に対して全文インデックスを問い合わせるために使用することができる。FTS クエリ表現言語を用いて、基本的なクエリの結果に対して様々な集合操作を行うことができます。現在サポートされている操作は3つです。</target>
        </trans-unit>
        <trans-unit id="7097964beca5dc252968954049e7c0946f78e4a9" translate="yes" xml:space="preserve">
          <source>The three leftmost columns of a zipfile virtual table, &quot;name&quot;, &quot;mode&quot; and &quot;mtime&quot;, may each be set to any value that may be inserted into the same column (see above). If either &quot;mode&quot; or &quot;mtime&quot; is set to NULL, the final value is determined as described for an INSERT of a NULL value - the current time for &quot;mtime&quot; and either 33188 or 16877 for &quot;mode&quot;, depending on whether or not the values specified for the next four columns of the zipfile table indicate that the entry is a directory or a file.</source>
          <target state="translated">zipfile仮想テーブルの左端の3つの列、&quot;name&quot;、&quot;mode&quot;、&quot;mtime &quot;は、それぞれ同じ列に挿入することができる任意の値を設定することができます(上記参照)。mode&quot; または &quot;mtime&quot; のいずれかが NULL に設定されている場合、最終的な値は NULL 値の INSERT で説明したように決定されます。</target>
        </trans-unit>
        <trans-unit id="3411dedba6408ea6c13a17f75aea9b87b7d91fad" translate="yes" xml:space="preserve">
          <source>The time string can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.</source>
          <target state="translated">時間文字列の後には、日付や時間を変更する0個以上の修飾子を付けることができます。各修飾子は、その左側の時間値に適用される変換です。修飾子は左から右に適用されます。利用可能な修飾子は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="30024a74e5aefa6cc166b0948a8f34eea1be4641" translate="yes" xml:space="preserve">
          <source>The time taken to execute each virtual machine operation can vary based on many factors. A typical value for a 1 GHz PC is between half and three million per second but may be much higher or lower, depending on the query. As such it is difficult to schedule background operations based on virtual machine operations. Instead, it is recommended that a callback be scheduled relatively frequently (say every 1000 instructions) and external timer routines used to determine whether or not background jobs need to be run.</source>
          <target state="translated">各仮想マシン操作の実行にかかる時間は、多くの要因に基づいて変化します。1GHzのPCの典型的な値は50万~300万/秒ですが、クエリによってはもっと高くなったり低くなったりします。そのため、仮想マシン操作に基づいてバックグラウンド操作をスケジューリングすることは困難です。その代わり、コールバックを比較的頻繁に(例えば1000命令ごとに)スケジュールし、バックグラウンドジョブを実行する必要があるかどうかを判断するために外部タイマールーチンを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d31d23c9c6ce92ba1161f4e9fe89ef4c4bc1cceb" translate="yes" xml:space="preserve">
          <source>The times reported on all tests represent wall-clock time in seconds. Two separate time values are reported for SQLite. The first value is for SQLite in its default configuration with full disk synchronization turned on. With synchronization turned on, SQLite executes an &lt;b&gt;fsync()&lt;/b&gt; system call (or the equivalent) at key points to make certain that critical data has actually been written to the disk drive surface. Synchronization is necessary to guarantee the integrity of the database if the operating system crashes or the computer powers down unexpectedly in the middle of a database update. The second time reported for SQLite is when synchronization is turned off. With synchronization off, SQLite is sometimes much faster, but there is a risk that an operating system crash or an unexpected power failure could damage the database. Generally speaking, the synchronous SQLite times are for comparison against PostgreSQL (which is also synchronous) and the asynchronous SQLite times are for comparison against the asynchronous MySQL engine.</source>
          <target state="translated">すべてのテストで報告される時間は、秒単位の実時間を表します。 SQLiteでは、2つの異なる時間値が報告されます。最初の値は、フルディスク同期がオンになっているデフォルト構成のSQLiteの値です。同期をオンにすると、SQLiteは&lt;b&gt;fsync（）を&lt;/b&gt;実行します&lt;b&gt;&lt;/b&gt;重要なポイントでシステムコール（または同等のもの）を使用して、重要なデータが実際にディスクドライブの表面に書き込まれたことを確認します。データベースの更新中にオペレーティングシステムがクラッシュしたり、コンピュータの電源が予期せずオフになった場合にデータベースの整合性を保証するには、同期が必要です。 SQLiteについて2回目に報告されるのは、同期がオフになっているときです。同期をオフにすると、SQLiteの方がはるかに高速になる場合がありますが、オペレーティングシステムのクラッシュや予期しない電源障害によってデータベースが損傷する可能性があります。一般的に言って、同期SQLite時間はPostgreSQL（これも同期です）との比較用であり、非同期SQLite時間は非同期MySQLエンジンとの比較用です。</target>
        </trans-unit>
        <trans-unit id="0fc05e4c39e5e71215073020483f372e45a3d893" translate="yes" xml:space="preserve">
          <source>The total amount of free space on a b-tree page consists of the size of the unallocated region plus the total size of all freeblocks plus the number of fragmented free bytes. SQLite may from time to time reorganize a b-tree page so that there are no freeblocks or fragment bytes, all unused bytes are contained in the unallocated space region, and all cells are packed tightly at the end of the page. This is called &quot;defragmenting&quot; the b-tree page.</source>
          <target state="translated">b-tree ページの空き領域の総量は、未割り当て領域のサイズと、すべてのフリーブロックのサイズの合計と、断片化されたフリーバイトの数で構成されています。SQLite は時々 b-tree ページを再編成して、フリーブロックや断片化されたバイトがなく、未使用のバイトがすべて未割り当て領域に含まれ、すべてのセルがページの最後にしっかりと詰め込まれるようにすることがあります。これを b-tree ページの「デフラグ」と呼びます。</target>
        </trans-unit>
        <trans-unit id="460e85c11483674a3089f1a062d5d6ad1f387294" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term in the entire FTS5 table.</source>
          <target state="translated">FTS5テーブル全体の用語のインスタンス数の合計。</target>
        </trans-unit>
        <trans-unit id="8456fd817ff013feb889e3e84d49e1da8d0b8117" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term that appear in column $col of the FTS5 table (considering all rows).</source>
          <target state="translated">FTS5テーブルの$col列に表示される用語のインスタンスの合計数(すべての行を考慮)。</target>
        </trans-unit>
        <trans-unit id="6e6d24f273b69a04a7a37a510d51811f2500b867" translate="yes" xml:space="preserve">
          <source>The total number of rows in the FTS table for which the column contains at least one instance of the phrase.</source>
          <target state="translated">その列にフレーズのインスタンスが少なくとも1つ含まれているFTSテーブルの行の総数。</target>
        </trans-unit>
        <trans-unit id="36827e0806ceb5dc326cee16a98d2a59022e566e" translate="yes" xml:space="preserve">
          <source>The total number of times the phrase appears in the column in all rows in the FTS table.</source>
          <target state="translated">FTS テーブルの全行の列にそのフレーズが出現した回数の合計。</target>
        </trans-unit>
        <trans-unit id="cf5b068f292efb4fb2def2e783aac8fbf8f0464d" translate="yes" xml:space="preserve">
          <source>The total_changes() function returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database connection was opened. This function is a wrapper around the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">total_changes（）関数は、現在のデータベース接続が開かれてから、INSERT、UPDATE、またはDELETEステートメントによって発生した行変更の数を返します。この関数は、&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt; C / C ++インターフェースのラッパーです。</target>
        </trans-unit>
        <trans-unit id="e56b60d01d475c54e2abcd03a315a64862d2471f" translate="yes" xml:space="preserve">
          <source>The traditional rollback journal works by writing a copy of the original unchanged database content into a separate rollback journal file and then writing changes directly into the database file. In the event of a crash or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, the original content contained in the rollback journal is played back into the database file to revert the database file to its original state. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when the rollback journal is deleted.</source>
          <target state="translated">従来のロールバックジャーナルは、元の変更されていないデータベースコンテンツのコピーを別のロールバックジャーナルファイルに書き込み、変更をデータベースファイルに直接書き込むことで機能します。クラッシュまたは&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;が発生した場合、ロールバックジャーナルに含まれる元のコンテンツがデータベースファイルに再生され、データベースファイルが元の状態に戻ります。&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;ロールバック・ジャーナルが削除されたときに発生します。</target>
        </trans-unit>
        <trans-unit id="fa45945065730186850cef64d952ee165c9cc090" translate="yes" xml:space="preserve">
          <source>The traditional way of communicating this information was to transform a C-language pointer into a BLOB or a 64-bit integer, then move that BLOB or integer through SQLite using the usual interfaces like &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt; or the integer equivalents.</source>
          <target state="translated">この情報を伝達する従来の方法は、C言語のポインターをBLOBまたは64ビット整数に変換し、&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob（）&lt;/a&gt;、&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob（）&lt;/a&gt;、&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob（）&lt;/a&gt;または対応する整数。</target>
        </trans-unit>
        <trans-unit id="c2d0f49e1ec0a4672583f25736f97bcbd3e6ba07" translate="yes" xml:space="preserve">
          <source>The transaction command can be used to group together several SQLite commands in a safe way. You can always start transactions manually using BEGIN, of course. But if an error occurs so that the COMMIT or ROLLBACK are never run, then the database will remain locked indefinitely. Also, BEGIN does not nest, so you have to make sure no other transactions are active before starting a new one. The &quot;transaction&quot; method takes care of all of these details automatically.</source>
          <target state="translated">トランザクションコマンドを使用すると、いくつかのSQLiteコマンドを安全な方法でグループ化することができます。もちろん、BEGINを使っていつでも手動でトランザクションを開始することができます。しかし、エラーが発生してCOMMITやROLLBACKが実行されないようになってしまうと、データベースは無期限にロックされたままになってしまいます。また、BEGINはネストしないので、新しいトランザクションを開始する前に、他のトランザクションがアクティブになっていないことを確認しなければなりません。transaction &quot;メソッドはこれらの詳細を自動的に処理します。</target>
        </trans-unit>
        <trans-unit id="66431b524eb3e3d97e40f460537f3aa544382bf9" translate="yes" xml:space="preserve">
          <source>The transaction has already committed at this point so timing is not critical in the deletion of the rollback journals. The current implementation deletes a single rollback journal then unlocks the corresponding database file before proceeding to the next rollback journal. But in the future we might change this so that all rollback journals are deleted before any database files are unlocked. As long as the rollback journal is deleted before its corresponding database file is unlocked it does not matter in what order the rollback journals are deleted or the database files are unlocked.</source>
          <target state="translated">この時点ですでにトランザクションはコミットされているので、ロールバックジャーナルの削除にタイミングは重要ではありません。現在の実装では、1つのロールバックジャーナルを削除した後、対応するデータベースファイルのロックを解除してから次のロールバックジャーナルに進みます。しかし、将来的には、データベースファイルのロックが解除される前にすべてのロールバックジャーナルを削除するように変更するかもしれません。対応するデータベースファイルのロックが解除される前にロールバックジャーナルが削除されている限り、ロールバックジャーナルの削除やデータベースファイルのロック解除の順序は関係ありません。</target>
        </trans-unit>
        <trans-unit id="439b3c25010ac483338852bbf167e17f82acaecb" translate="yes" xml:space="preserve">
          <source>The transformation converts each vertex of the polygon according to the following formula:</source>
          <target state="translated">変換は、次の式に従って多角形の各頂点を変換します。</target>
        </trans-unit>
        <trans-unit id="970a22ffd83744a201d5b074bf5b2eed9b68c352" translate="yes" xml:space="preserve">
          <source>The transient table in which the result is built is created by instruction 0. Three loops then follow. The loop at instructions 5 through 10 implements the first SELECT statement. The second SELECT statement is implemented by the loop at instructions 14 through 19. Finally, a loop at instructions 22 through 25 reads the transient table and invokes the callback once for each row in the result.</source>
          <target state="translated">結果が構築される過渡的なテーブルは命令0によって作成されます。 その後、3つのループが続きます。命令5から10までのループは、最初のSELECT文を実装します。2 番目の SELECT 文は、命令 14 から 19 のループによって実装されます。最後に、命令 22 から 25 までのループがトランジェント・テーブルを読み込み、結果の各行についてコールバックを 1 回呼び出します。</target>
        </trans-unit>
        <trans-unit id="952fc2249e617c46359543a66e348109d3087d3d" translate="yes" xml:space="preserve">
          <source>The transient table in which the results of the inner SELECT are stored is created by the &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; instruction at 0. This opcode is used for tables that exist for the duration of a single SQL statement only. The transient cursor is always opened read/write even if the main database is read-only. The transient table is deleted automatically when the cursor is closed. The P2 value of 1 means the cursor points to a BTree index, which has no data but can have an arbitrary key.</source>
          <target state="translated">内部SELECTの結果が格納される一時テーブルは、0 の&lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt;命令によって作成されます。このオペコードは、単一のSQLステートメントの実行中にのみ存在するテーブルに使用されます。一時カーソルは、メインデータベースが読み取り専用であっても、常に読み取り/書き込みで開かれます。カーソルを閉じると、一時テーブルは自動的に削除されます。 P2値1は、カーソルがBTreeインデックスを指していることを意味します。BTreeインデックスにはデータはありませんが、任意のキーを持つことができます。</target>
        </trans-unit>
        <trans-unit id="592350be0cb11625e2bd092767c6171c56d03c65" translate="yes" xml:space="preserve">
          <source>The transition from SQLite version 3.4.2 to 3.5.0 is a major change. Every source code file in the SQLite core had to be modified, some extensively. And the change introduced some minor incompatibilities in the C interface. But we feel that the benefits of the transition from 3.4.2 to 3.5.0 far outweigh the pain of porting. The new VFS layer is now well-defined and stable and should simplify future customizations. The VFS layer, and the separable memory allocator and mutex subsystems allow a standard SQLite source code amalgamation to be used in an embedded project without change, greatly simplifying configuration management. And the resulting system is much more tolerant of highly threaded designs.</source>
          <target state="translated">SQLite バージョン 3.4.2 から 3.5.0 への移行は大きな変更です。SQLite コアのすべてのソースコードファイルを変更しなければならず、いくつかは広範囲に渡って変更されました。また、この変更に伴い、C インターフェースにいくつかのマイナーな非互換性が導入されました。しかし、3.4.2 から 3.5.0 への移行のメリットは、移植の痛みをはるかに上回ると感じています。新しい VFS レイヤーは十分に定義されており、安定しているので、将来のカスタマイズが簡単になるはずです。VFS 層と分離可能なメモリアロケータとミューテックスのサブシステムにより、標準的な SQLite ソースコードのアマルガムを変更することなく組み込みプロジェクトで使用できるようになり、設定管理が大幅に簡素化されました。また、結果として得られるシステムは、高度にスレッド化された設計に対してより寛容なものとなります。</target>
        </trans-unit>
        <trans-unit id="b0ecdf62ac64721b60f0c811bc6ae15d2a3d1b27" translate="yes" xml:space="preserve">
          <source>The trick here is the -DTCLSH=1 option. The TCL interface module for SQLite includes a &lt;b&gt;main()&lt;/b&gt; procedure that initializes a TCL interpreter and enters a command-line loop when it is compiled with -DTCLSH=1. The command above works on both Linux and Mac OS X, though one may need to adjust the library options depending on the platform and which version of TCL one is linking against.</source>
          <target state="translated">ここでの秘訣は-DTCLSH = 1オプションです。SQLiteのTCLインターフェイスモジュールには、TCLインタープリターを初期化し、-DTCLSH = 1でコンパイルするとコマンドラインループに入る&lt;b&gt;main（）&lt;/b&gt;プロシージャが含まれています。上記のコマンドはLinuxとMac OS Xの両方で機能しますが、プラットフォームやリンクしているTCLのバージョンに応じて、ライブラリオプションを調整する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="3b9b7cf0a7967eed621bbbad3863190e29c44d61" translate="yes" xml:space="preserve">
          <source>The trim(X,Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.</source>
          <target state="translated">trim(X,Y)関数は、Xの両端からYに登場するすべての文字を削除した文字列を返します。Y引数が省略された場合、trim(X)はXの両端からスペースを削除します。</target>
        </trans-unit>
        <trans-unit id="02041028dd7a37adeacbb35b1200b0b1a6b27a53" translate="yes" xml:space="preserve">
          <source>The true primary key for a rowid table (the value that is used as the key to look up rows in the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine) is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">ROWIDテーブルの真の主キー（基になる&lt;a href=&quot;fileformat2#btree&quot;&gt;Bツリー&lt;/a&gt;ストレージエンジンで行を検索するためのキーとして使用される値）は、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="3f9dae6c570b0f408d716bb105a5e25850cccf9f" translate="yes" xml:space="preserve">
          <source>The truncate optimization can also be disabled at runtime using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface. If an authorizer callback returns &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; for an &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; action code, then the DELETE operation will proceed but the truncate optimization will be bypassed and rows will be deleted one by one.</source>
          <target state="translated">トランケート最適化は、&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;インターフェースを使用して実行時に無効にすることもできます。承認者のコールバック返す場合&lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;用&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETEの&lt;/a&gt;アクションコード、そしてDELETE操作は続行されますが、切り捨て最適化がバイパスされ、行を1つずつ削除されます。</target>
        </trans-unit>
        <trans-unit id="7489f83785acf46d79dbedce76141d020e3a30b4" translate="yes" xml:space="preserve">
          <source>The truncate optimization can be permanently disabled for all queries by recompiling SQLite with the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time switch.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt;コンパイル時スイッチを使用してSQLiteを再コンパイルすることにより、すべてのクエリに対して切り捨て最適化を永続的に無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="e242c8734781e20213900394ec30db10b58ee560" translate="yes" xml:space="preserve">
          <source>The two &quot;0&quot; parameters do server a purpose in some contexts, but for using these routine to print a parse tree as ASCII-art on the terminal, they should both be &quot;0&quot;.</source>
          <target state="translated">2つの &quot;0 &quot;パラメータは、いくつかの文脈で目的を果たしますが、これらのルーチンを使用して端末にASCIIアートとしてパースツリーを印刷するためには、両方とも &quot;0 &quot;でなければなりません。</target>
        </trans-unit>
        <trans-unit id="46623d6b4b79b06cc3078e791041446a91edf407" translate="yes" xml:space="preserve">
          <source>The two 4-byte big-endian integers at offsets 52 and 64 are used to manage the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes. If the integer at offset 52 is zero then pointer-map (ptrmap) pages are omitted from the database file and neither auto_vacuum nor incremental_vacuum are supported. If the integer at offset 52 is non-zero then it is the page number of the largest root page in the database file, the database file will contain ptrmap pages, and the mode must be either auto_vacuum or incremental_vacuum. In this latter case, the integer at offset 64 is true for incremental_vacuum and false for auto_vacuum. If the integer at offset 52 is zero then the integer at offset 64 must also be zero.</source>
          <target state="translated">オフセット52と64の2つの4バイトビッグエンディアン整数は、&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;および&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt;モードを管理するために使用されます。オフセット52の整数がゼロの場合、データベースファイルからポインターマップ（ptrmap）ページが省略され、auto_vacuumもincremental_vacuumもサポートされません。オフセット52の整数がゼロ以外の場合、それはデータベースファイル内の最大のルートページのページ番号であり、データベースファイルにはptrmapページが含まれ、モードはauto_vacuumまたはincremental_vacuumでなければなりません。この後者の場合、オフセット64の整数は、incremental_vacuumの場合はtrue、auto_vacuumの場合はfalseです。オフセット52の整数がゼロの場合、オフセット64の整数もゼロでなければなりません。</target>
        </trans-unit>
        <trans-unit id="5d5cec8b4b21ae2b9d4802acdeb66477068dae88" translate="yes" xml:space="preserve">
          <source>The two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; are:</source>
          <target state="translated">2つの&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="60d1d8fda3bbd4cfca022cc996f0d5a823d5b6ed" translate="yes" xml:space="preserve">
          <source>The two exceptions are:</source>
          <target state="translated">2つの例外があります。</target>
        </trans-unit>
        <trans-unit id="e1f0bf58781420b540ac606f0e7579a8a2be4378" translate="yes" xml:space="preserve">
          <source>The two fragments of SQL below are similar, but not entirely equivalent, as the latter will fail if the definition of window &quot;win&quot; contains a frame specification.</source>
          <target state="translated">以下の2つのSQLの断片は似ていますが、完全には等価ではないので、後者はウィンドウ &quot;win &quot;の定義にフレーム指定が含まれている場合に失敗します。</target>
        </trans-unit>
        <trans-unit id="f9a92735a6c1a485477340ad1399f41bdfef6983" translate="yes" xml:space="preserve">
          <source>The two remaining tables, %_segments and %_segdir, are used to store the full-text index. Conceptually, this index is a lookup table that maps each term (word) to the set of docid values corresponding to records in the %_content table that contain one or more occurrences of the term. To retrieve all documents that contain a specified term, the FTS module queries this index to determine the set of docid values for records that contain the term, then retrieves the required documents from the %_content table. Regardless of the schema of the FTS virtual table, the %_segments and %_segdir tables are always created as follows:</source>
          <target state="translated">残りの 2 つのテーブル、%_segments と %_segdir は、フルテキスト・インデックスを格納するために使用されます。概念的には、このインデックスは、各用語 (単語)を、その用語を 1 つ以上含む %_content テーブル内のレコードに対応する docid 値のセットにマップするルックアップ・テーブルです。指定された用語を含むすべてのドキュメントを取得するには、FTS モジュールはこのインデックスをクエリして、用語を含むレコードの docid 値のセットを決定し、%_content テーブルから必要なドキュメントを取得します。FTS 仮想テーブルのスキーマに関係なく、%_segments テーブルと %_segdir テーブルは常に以下のように作成されます。</target>
        </trans-unit>
        <trans-unit id="57eb59a7de5c1f2eacd1a8c2e2793991396d4104" translate="yes" xml:space="preserve">
          <source>The two salt value copied from the WAL file header. These values are in the byte-order of the WAL file, which might be different from the native byte-order of the machine.</source>
          <target state="translated">WALファイルのヘッダからコピーした2つのソルト値です。これらの値はWALファイルのバイト順であり、マシンのネイティブバイト順とは異なる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ccc9e431ebc7fabfa6726082e51ef8838fff247f" translate="yes" xml:space="preserve">
          <source>The two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; accepts a pointer to the tokenizer method object even without the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting if the second argument is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;</source>
          <target state="translated">2引数バージョンの&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;は、2番目の引数が&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメーター&lt;/a&gt;である場合、&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;）設定なしでも、トークナイザーメソッドオブジェクトへのポインターを受け入れます</target>
        </trans-unit>
        <trans-unit id="6b8d35e3a824a79bc7ce101b6a6ae7997418f4f7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 1 gives the start of the first freeblock on the page, or is zero if there are no freeblocks.</source>
          <target state="translated">オフセット 1 の 2 バ イ ト 整数は、 ページ上の最初のフ リーブ ロ ッ ク の開始を与え ます。</target>
        </trans-unit>
        <trans-unit id="c4473928239ae1bda74a9fb4bb8276860fc5ffb5" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 3 gives the number of cells on the page.</source>
          <target state="translated">オフセット3の2バイト整数は、ページ上のセルの数を与えます。</target>
        </trans-unit>
        <trans-unit id="a06521372b9101f2c70d6a3c29239fdaf5cbc5a7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 5 designates the start of the cell content area. A zero value for this integer is interpreted as 65536.</source>
          <target state="translated">オフセット 5 の 2 バイト整数は、セル内容領域の開始を指定します。この整数の値がゼロの場合は 65536 と解釈されます。</target>
        </trans-unit>
        <trans-unit id="85da2eb104aa5ac23b3d2218d186677a6dbc8b7e" translate="yes" xml:space="preserve">
          <source>The two-byte value beginning at offset 16 determines the page size of the database. For SQLite versions 3.7.0.1 (2010-08-04) and earlier, this value is interpreted as a big-endian integer and must be a power of two between 512 and 32768, inclusive. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;version 3.7.1&lt;/a&gt; (2010-08-23), a page size of 65536 bytes is supported. The value 65536 will not fit in a two-byte integer, so to specify a 65536-byte page size, the value at offset 16 is 0x00 0x01. This value can be interpreted as a big-endian 1 and thought of as a magic number to represent the 65536 page size. Or one can view the two-byte field as a little endian number and say that it represents the page size divided by 256. These two interpretations of the page-size field are equivalent.</source>
          <target state="translated">オフセット16で始まる2バイトの値によって、データベースのページサイズが決まります。 SQLiteバージョン3.7.0.1（2010-08-04）以前の場合、この値はビッグエンディアン整数として解釈され、512〜32768の2のべき乗でなければなりません。 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;バージョン3.7.1&lt;/a&gt;（2010-08-23）から、65536バイトのページサイズがサポートされています。値65536は2バイト整数に収まらないため、65536バイトのページサイズを指定するには、オフセット16の値は0x00 0x01です。この値はビッグエンディアン1として解釈でき、65536ページサイズを表すマジックナンバーと考えることができます。または、2バイトのフィールドをリトルエンディアンの数値として表示して、ページサイズを256で割ったものと表現することもできます。これら2つのページサイズフィールドの解釈は同等です。</target>
        </trans-unit>
        <trans-unit id="d620a0d4c1327669927184e30780adb142926606" translate="yes" xml:space="preserve">
          <source>The typedef is necessary to work around problems in certain C++ compilers.</source>
          <target state="translated">型定義は、特定のC++コンパイラの問題を回避するために必要です。</target>
        </trans-unit>
        <trans-unit id="2acee6be58c92d0d4d1c18a3c705f7ce6eca583d" translate="yes" xml:space="preserve">
          <source>The typeof(X) function returns a string that indicates the &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; of the expression X: &quot;null&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;text&quot;, or &quot;blob&quot;.</source>
          <target state="translated">typeof（X）関数は、式Xの&lt;a href=&quot;datatype3&quot;&gt;データ型&lt;/a&gt;を示す文字列を返します：「null」、「integer」、「real」、「text」、または「blob」。</target>
        </trans-unit>
        <trans-unit id="7de0eb427df1bd72e4d6981f084f01d2fd7b104b" translate="yes" xml:space="preserve">
          <source>The types and default collation sequences attached to each column must be the same for all component tables.</source>
          <target state="translated">各列に添付されているタイプとデフォルトの照合順序は、すべてのコンポーネントテーブルで同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="7a193d6baad5e9eae89c634a076cd20d9e39a2d0" translate="yes" xml:space="preserve">
          <source>The unary operator</source>
          <target state="translated">単項演算子</target>
        </trans-unit>
        <trans-unit id="5de3e6de824f9a3c28afdefed054e3e170c8e0d8" translate="yes" xml:space="preserve">
          <source>The uncompress function should uncompress data previously compressed by the compress function. In other words, for all SQLite values X, it should be true that uncompress(compress(X)) equals X. When data that has been compressed by the compress function is read from the database by FTS4, it is passed to the uncompress function before it is used.</source>
          <target state="translated">uncompress関数は、圧縮関数によって以前に圧縮されたデータの圧縮を解除しなければならない。言い換えれば、すべてのSQLite値Xに対して、uncompress(compress(X))がXに等しいことが真でなければなりません。compress関数によって圧縮されたデータがFTS4によってデータベースから読み込まれるとき、それが使用される前にuncompress関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="04cb6e28b7a92f43a8ce66195a1ea7614bfeaae5" translate="yes" xml:space="preserve">
          <source>The underlying implementation can support some subset of these locking levels as long as it meets the other requirements of this paragraph. The locking level is specified as the second argument to both xLock and xUnlock. The xLock method increases the locking level to the specified locking level or higher. The xUnlock method decreases the locking level to no lower than the level specified. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; means that the file is unlocked. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; gives permission to read the file. Multiple database connections can hold &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; at the same time. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; is like &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; in that it is permission to read the file. But only a single connection can hold a reserved lock at any point in time. The &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; is also permission to read the file. Other connections can continue to read the file as well, but no other connection is allowed to escalate a lock from none to shared. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; is permission to write on the file. Only a single connection can hold an exclusive lock and no other connection can hold any lock (other than &quot;none&quot;) while one connection holds an exclusive lock. The xLock returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if it is unable to obtain the lock, or &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK&lt;/a&gt; if something else goes wrong. The xUnlock method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; for problems.</source>
          <target state="translated">基礎となる実装は、この段落の他の要件を満たしている限り、これらのロックレベルのサブセットをサポートできます。ロックレベルは、xLockとxUnlockの両方の2番目の引数として指定されます。 xLockメソッドは、ロックレベルを指定されたロックレベル以上に上げます。 xUnlockメソッドは、ロックレベルを指定されたレベル以上に下げます。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;は、ファイルがロック解除されていることを意味します。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;は、ファイルの読み取りを許可します。複数のデータベース接続が&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;を同時に保持できます。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;はSQLITE_LOCK_SHAREDに似てい&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;ます&lt;/a&gt;そのファイルを読み取る許可です。ただし、いつでも1つの接続だけが予約済みロックを保持できます。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDINGは&lt;/a&gt;また、ファイルの読み取り権限です。他の接続も引き続きファイルを読み取ることができますが、ロックをなしから共有にエスカレーションすることはできません。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;は、ファイルへの書き込み権限です。 1つの接続のみが排他ロックを保持でき、1つの接続が排他ロックを保持している間は、他のどの接続もロック（ &quot;none&quot;以外）を保持できません。 XLOCKを返し&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;、成功に&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;ロック、または取得できない場合&lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCKを&lt;/a&gt;他の何かがうまくいかない場合。 xUnlockメソッドは&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功との&lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt;問題について。</target>
        </trans-unit>
        <trans-unit id="0269000c82eb39065f294879a620aecf2c6e833d" translate="yes" xml:space="preserve">
          <source>The underscore character (unicode codepoint 96).</source>
          <target state="translated">アンダースコア文字(ユニコードコードコードポイント96)。</target>
        </trans-unit>
        <trans-unit id="94b1d236b1b1bdea969b9f218085fccfc7fb6de3" translate="yes" xml:space="preserve">
          <source>The undo::activate command creates temporary triggers in the database that record all changes made to the tables named in the arguments.</source>
          <target state="translated">undo::activate コマンドは、引数で指定されたテーブルに加えられたすべての変更を記録する一時的なトリガーをデータベースに作成します。</target>
        </trans-unit>
        <trans-unit id="9d719f9a44e55c933ab5b5fa11156ee426d1545d" translate="yes" xml:space="preserve">
          <source>The undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface has been removed.</source>
          <target state="translated">文書化されていない&lt;b&gt;sqlite3_os_switch（）&lt;/b&gt;インターフェースは削除されました。</target>
        </trans-unit>
        <trans-unit id="93cdbdaae25242141056e83b2feecd9f656881a8" translate="yes" xml:space="preserve">
          <source>The unicode tokenizer classifies all unicode characters as either &quot;separator&quot; or &quot;token&quot; characters. By default all space and punctuation characters, as defined by Unicode 6.1, are considered separators, and all other characters as token characters. More specifically, all unicode characters assigned to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt; general category&lt;/a&gt; beginning with &quot;L&quot; or &quot;N&quot; (letters and numbers, specifically) or to category &quot;Co&quot; (&quot;other, private use&quot;) are considered tokens. All other characters are separators.</source>
          <target state="translated">ユニコードトークナイザは、すべてのユニコード文字を「セパレータ」または「トークン」文字のいずれかに分類します。デフォルトでは、Unicode 6.1で定義されているすべてのスペースと句読点は区切り文字と見なされ、その他のすべての文字はトークン文字と見なされます。より具体的には、「L」または「N」で始まる&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt;一般的なカテゴリ&lt;/a&gt;（具体的には文字と数字）またはカテゴリ「Co」（「その他、私的使用」）に割り当てられたすべてのUnicode文字はトークンと見なされます。他のすべての文字はセパレータです。</target>
        </trans-unit>
        <trans-unit id="8359d1281537e2db390ccb27a011cf0c1e07387b" translate="yes" xml:space="preserve">
          <source>The unicode(X) function returns the numeric unicode code point corresponding to the first character of the string X. If the argument to unicode(X) is not a string then the result is undefined.</source>
          <target state="translated">unicode(X)関数は、文字列Xの最初の文字に対応する数値のunicodeコードポイントを返します。</target>
        </trans-unit>
        <trans-unit id="b06912261f5bb2d984a2ea7d12c5ea40ed3062a1" translate="yes" xml:space="preserve">
          <source>The union-vtab is not built into SQLite. Union-vtab is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. The source code for union-vtab is contained in a single file located at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext/misc/unionvtab.c&lt;/a&gt; in the SQLite source tree.</source>
          <target state="translated">union-vtabはSQLiteに組み込まれていません。Union-vtabは&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能&lt;/a&gt;です。union-vtabのソースコードは、SQLiteソースツリーの&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext / misc / unionvtab.c&lt;/a&gt;にある単一のファイルに含まれています。</target>
        </trans-unit>
        <trans-unit id="70f606d5ad9373cd7360030770268b87dc04b4a8" translate="yes" xml:space="preserve">
          <source>The union-vtab is read-only. Support for writing may be added at a later time, but writing is not a part of the initial implementation.</source>
          <target state="translated">union-vtabは読み取り専用です。書き込みのサポートは後から追加されるかもしれませんが、書き込みは初期実装の一部ではありません。</target>
        </trans-unit>
        <trans-unit id="217c127b8d7dc9166357c6c852e4edb92e8bd2cc" translate="yes" xml:space="preserve">
          <source>The union-vtab shall optimize access to the underlying real tables when the constraints on the query are among forms shown below. Other kinds of constraints may be optimized in the future, but only these constraints are optimized in the initial implementation.</source>
          <target state="translated">union-vtabは、問い合わせに対する制約が以下に示す形式の中にある場合、基礎となる実テーブルへのアクセスを最適化しなければならない。将来的には他の種類の制約も最適化される可能性があるが,初期実装ではこれらの制約のみが最適化される。</target>
        </trans-unit>
        <trans-unit id="5ad25f83f6534911bf90077b4a8c2d24284bf894" translate="yes" xml:space="preserve">
          <source>The unique id (INTEGER PRIMARY KEY)</source>
          <target state="translated">固有の ID (INTEGER PRIMARY KEY)</target>
        </trans-unit>
        <trans-unit id="37c73afc15f55751239631e696091c5fb7a86756" translate="yes" xml:space="preserve">
          <source>The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will never use a file descriptor less than</source>
          <target state="translated">UNIX &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;は、以下のファイル記述子を決して使用しません</target>
        </trans-unit>
        <trans-unit id="ae8287e8b161fa1549dd3442fa8607f53d8dfe62" translate="yes" xml:space="preserve">
          <source>The unlikely(X) function returns the argument X unchanged. The unlikely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the unlikely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually not true. The unlikely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X, 0.0625).</source>
          <target state="translated">likely（X）関数は、引数Xを変更せずに返します。likelyly（X）関数は、実行時（つまり、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）の&lt;/a&gt;呼び出し中）に CPUサイクルを消費しないようにコードジェネレーターが最適化しない操作です。likelyly（X）関数の目的は、引数Xが通常は真ではないブール値であるというヒントをクエリプランナーに提供することです。likely（X）関数は、&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;尤度&lt;/a&gt;（X、0.0625）と同等です。</target>
        </trans-unit>
        <trans-unit id="f74bf3865d4b8d380ed09cdf9682ebd8ba365f80" translate="yes" xml:space="preserve">
          <source>The unlock-notify callback is not reentrant. If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.</source>
          <target state="translated">unlock-notifyコールバックはリエントラントではありません。アプリケーションがunlock-notifyコールバック内からsqlite3_xxx API関数を呼び出すと、クラッシュやデッドロックが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9f10c2e623337226e56371f152fe9704c596a75e" translate="yes" xml:space="preserve">
          <source>The unlock_notify method is used access the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface to the SQLite core library for testing purposes. The use of this method by applications is discouraged.</source>
          <target state="translated">unlock_notifyメソッドは、テスト目的でSQLiteコアライブラリへの&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;インターフェースにアクセスするために使用されます。アプリケーションでこのメソッドを使用することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="c0db7fcedecb648c350c1b6f11ba954f23165737" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">更新フックの実装は、更新フックを呼び出したデータベース接続を変更するようなことをしてはなりません。データベース接続を変更するアクションは、更新フックをトリガーした&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しが完了するまで延期する必要があります。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）は&lt;/a&gt;どちらも、この段落の「変更」の意味でデータベース接続を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="09532968164962481e11046837aaa8bacbe59ea0" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">更新フックの実装は、更新フックを呼び出したデータベース接続を変更するようなことをしてはなりません。データベース接続を変更するアクションは、更新フックをトリガーした&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しが完了するまで延期する必要があります。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;step&quot;&gt;sqlite3_step（）は&lt;/a&gt;どちらも、この段落の「変更」の意味でデータベース接続を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="f188e349260d6d862bd1151de1aa0b41c96135c8" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">内部システムテーブルが変更された場合（つまり、sqlite_masterおよびsqlite_sequence）、更新フックは呼び出されません。&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルが変更された場合、更新フックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="d4c3b215f10d00c42f1094ebb70e270136be0ef6" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">内部システムテーブルが変更された場合（つまり、sqlite_masterおよびsqlite_sequence）、更新フックは呼び出されません。&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルが変更された場合、更新フックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="7b3d709a5bf6d8d9c48b677160252ac4da74295a" translate="yes" xml:space="preserve">
          <source>The upper bound on the database &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache size&lt;/a&gt; has traditionally defaulted to 2000 pages. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; also changes this default setting to be &quot;-2000&quot; which means 2000*1024 bytes, regardless of page size. So, the upper bound on the amount of memory used for the page cache is unchanged.</source>
          <target state="translated">データベース&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;キャッシュサイズ&lt;/a&gt;の上限は、伝統的にデフォルトで2000ページに設定されています。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;バージョン3.12.0&lt;/a&gt;もこのデフォルト設定を「-2000」に変更します。これは、ページサイズに関係なく、2000 * 1024バイトを意味します。したがって、ページキャッシュに使用されるメモリ量の上限は変更されません。</target>
        </trans-unit>
        <trans-unit id="55e210be964a43ed3f79f81acfb0252d2ec508a2" translate="yes" xml:space="preserve">
          <source>The upper(X) function returns a copy of input string X in which all lower-case ASCII characters are converted to their upper-case equivalent.</source>
          <target state="translated">upper(X)関数は、入力文字列 X のコピーを返し、小文字の ASCII 文字はすべて大文字に変換されます。</target>
        </trans-unit>
        <trans-unit id="2ff3bb49a7df2e57465c506adbfbac36859c676c" translate="yes" xml:space="preserve">
          <source>The upsert above inserts the new vocabulary word &quot;jovial&quot; if that word is not already in the dictionary, or if it is already in the dictionary, it increments the counter. The &quot;count+1&quot; expression could also be written as &quot;vocabulary.count&quot;. PostgreSQL requires the second form, but SQLite accepts either.</source>
          <target state="translated">上のアップサートは、その単語がすでに辞書にない場合は新しい語彙「jovial」を挿入し、辞書にある場合はカウンターをインクリメントします。また、&quot;count+1 &quot;式は &quot;vocabulary.count &quot;と書くこともできます。PostgreSQLでは2番目の形式が必要ですが、SQLiteではどちらでも受け付けています。</target>
        </trans-unit>
        <trans-unit id="f98914d65daf1eee948f9cf4215d1bc155ef41fa" translate="yes" xml:space="preserve">
          <source>The usage of pagecache memory is somewhat harder to control in SQLite version 3.6.1, though mechanisms are planned for subsequent releases that will make controlling pagecache memory much easier. Prior to the introduction of these new mechanisms, the only way to control pagecache memory is using the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">SQLiteバージョン3.6.1では、ページキャッシュメモリの使用を制御するのがやや難しくなりますが、後続のリリースでは、ページキャッシュメモリの制御をより簡単にするメカニズムが計画されています。これらの新しいメカニズムが導入される前は、ページキャッシュメモリを制御する唯一の方法は、&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_sizeプラグマ&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="83c37f6e9e518d22e126d6f49713b321c1f31d9b" translate="yes" xml:space="preserve">
          <source>The use of &quot;:&quot; instead of &quot;$&quot; before the name of a variable can sometimes be useful if the SQL text is enclosed in double-quotes &quot;...&quot; instead of curly-braces {...}. When the SQL is contained within double-quotes &quot;...&quot; then TCL will do the substitution of $-variables, which can lead to SQL injection if extreme care is not used. But TCL will never substitute a :-variable regardless of whether double-quotes &quot;...&quot; or curly-braces {...} are used to enclose the SQL, so the use of :-variables adds an extra measure of defense against SQL injection.</source>
          <target state="translated">変数名の前に&quot;$&quot;の代わりに&quot;:&quot;を使用することは、SQLテキストが中括弧{...}の代わりにダブルクォート&quot;...で囲まれている場合に便利な場合があります。SQLがダブルクォート「...」で囲まれている場合、TCLは$-変数の置換を行います。しかし、TCLはダブルクォート「...」や中括弧{...}がSQLを囲むために使用されているかどうかに関わらず、:-variableを代入することはありません。</target>
        </trans-unit>
        <trans-unit id="53ba0fe6640d81c27b2028a34ac03622ddcd61d3" translate="yes" xml:space="preserve">
          <source>The use of a ZIP archive to encapsulate XML files plus resources is an elegant approach to an application file format. It is clearly superior to a custom binary file format. But using an SQLite database as the container, instead of ZIP, would be more elegant still.</source>
          <target state="translated">XMLファイルとリソースをカプセル化するためのZIPアーカイブの使用は、アプリケーションファイル形式へのエレガントなアプローチです。それは明らかにカスタムバイナリファイルフォーマットよりも優れています。しかし、ZIP の代わりに SQLite データベースをコンテナとして使用することは、よりエレガントな方法です。</target>
        </trans-unit>
        <trans-unit id="62a1d7ca77be3f3b5567800401dc0bf052c2aaae" translate="yes" xml:space="preserve">
          <source>The use of a virtual machine in SQLite has been a great benefit to the library's development. The virtual machine provides a crisp, well-defined junction between the front-end of SQLite (the part that parses SQL statements and generates virtual machine code) and the back-end (the part that executes the virtual machine code and computes a result.) The virtual machine allows the developers to see clearly and in an easily readable form what SQLite is trying to do with each statement it compiles, which is a tremendous help in debugging. Depending on how it is compiled, SQLite also has the capability of tracing the execution of the virtual machine - printing each virtual machine instruction and its result as it executes.</source>
          <target state="translated">SQLite で仮想マシンを使用することは、ライブラリの開発に大きなメリットをもたらしました。仮想マシンは、SQLiteのフロントエンド(SQL文を解析して仮想マシンコードを生成する部分)とバックエンド(仮想マシンコードを実行して結果を計算する部分)の間に、明確に定義された分岐点を提供します。コンパイル方法にもよりますが、SQLite は仮想マシンの実行をトレースする機能も持っています。</target>
        </trans-unit>
        <trans-unit id="9d27ce1c6f5449fceeec41db3a7baef374e89122" translate="yes" xml:space="preserve">
          <source>The use of each of these methods will be explained in the sequel, though not in the order shown above.</source>
          <target state="translated">それぞれの使用方法については、上記の順番ではありませんが、続編で説明します。</target>
        </trans-unit>
        <trans-unit id="ac3e9e4d3a0d1a6a51dbf276370664c84cd0bc3c" translate="yes" xml:space="preserve">
          <source>The use of persistent journal mode provides a noticeable performance improvement on many systems. Of course, the drawback is that the journal files remain on the disk, using disk space and cluttering directories, long after the transaction commits. The only safe way to delete a persistent journal file is to commit a transaction with journaling mode set to DELETE:</source>
          <target state="translated">永続ジャーナルモードを使用すると、多くのシステムで顕著なパフォーマンスの向上が見られます。もちろん、欠点は、トランザクションがコミットされた後も、ジャーナルファイルがディスク上に残り、ディスクスペースを使用し、ディレクトリを乱雑にしてしまうことです。永続的ジャーナルファイルを削除する唯一の安全な方法は、ジャーナリングモードをDELETEに設定してトランザクションをコミットすることです。</target>
        </trans-unit>
        <trans-unit id="ac2e1cc15280219a058aa01cbdd9d14acc3c174c" translate="yes" xml:space="preserve">
          <source>The use of pointer-passing is an advanced technique that should be used infrequently and cautiously. Pointer-passing should not be used haphazardly or carelessly. Pointer-passing is a sharp tool that can leave deep scars if misused.</source>
          <target state="translated">ポインタパッシングの使用は高度な技術であり、使用頻度は低く、慎重に行う必要があります。ポインターパッシングは、行き当たりばったりや不注意に使用するべきではありません。ポインターパッシングは、誤って使用すると深い傷跡を残すことができる鋭いツールです。</target>
        </trans-unit>
        <trans-unit id="716439e76a7ceab1c8c91b09a2f76c73c53bf8c1" translate="yes" xml:space="preserve">
          <source>The use of subtypes on pointers prevented pointer forgery using pure SQL. But subtypes do nothing to prevent an attacker from reading the values of pointers. In other words, subtypes on pointer values prevent attacks using SQL statements like this:</source>
          <target state="translated">ポインタにサブタイプを使用することで、純粋な SQL を使用したポインタフォージェリを防ぐことができました。しかし、攻撃者がポインタの値を読み取ることを防ぐには、サブタイプは何の役にも立ちません。言い換えれば、ポインタの値に対するサブタイプは、このようなSQL文を使った攻撃を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="d8ed607375ddfb8582a61f0a5132f51fb52c53b0" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is recommended for all applications.</source>
          <target state="translated">&lt;a href=&quot;amalgamation&quot;&gt;融合&lt;/a&gt;の使用は、すべてのアプリケーションに推奨されます。</target>
        </trans-unit>
        <trans-unit id="789c46abbb3fc4976d476150773395da4c1e0a98" translate="yes" xml:space="preserve">
          <source>The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8. The UTF-16 interfaces are provided as a convenience. The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.</source>
          <target state="translated">現在 SQLite は UTF-8 を使用してすべてのパースを行っているため、UTF-8 インターフェイスの使用を推奨します。UTF-16インターフェイスは利便性のために提供されています。UTF-16 インターフェイスは、入力テキストを UTF-8 に変換してから、対応する UTF-8 インターフェイスを呼び出すことで動作します。</target>
        </trans-unit>
        <trans-unit id="7ed5c8c8570cfb3a0d0049b76c3fa5c381dc896c" translate="yes" xml:space="preserve">
          <source>The use of the error logger callback is highly recommended. The debugging information that the error logger provides has proven very useful in tracking down obscure problems that occurs with applications after they get into the field. The error logger callback has also proven useful in catching errors occasional errors that the application misses because of inconsistent checking of API return codes. Developers are encouraged to implement an error logger callback early in the development cycle in order to spot unexpected behavior quickly, and to leave the error logger callback turned on through deployment. If the error logger never finds a problem, then no harm is done. But failure to set up an appropriate error logger might compromise diagnostic capabilities later on.</source>
          <target state="translated">エラー ロガー コールバックの使用を強くお勧めします。エラーロガーが提供するデバッグ情報は、フィールドに入った後にアプリケーションで発生する不明瞭な問題を追跡するのに非常に有用であることが証明されています。また、エラーロガーコールバックは、API リターンコードの一貫性のないチェックのためにアプリケーションが見逃してしまうようなエラーをキャッチするのにも役立ちます。開発者は、開発サイクルの早い段階でエラーロガーコールバックを実装して、予期せぬ動作を素早く発見し、デプロイ時までエラーロガーコールバックをオンにしておくことをお勧めします。エラーロガーが問題を発見しなければ、何の問題もありません。しかし、適切なエラー ロガーをセットアップしないと、後で診断機能が損なわれる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a848d528e6bb7ea17daf03362baa03e736e192f7" translate="yes" xml:space="preserve">
          <source>The use of the standardized speedtest1.c workload and cachegrind has enabled significant performance improvement. However, it is important to recognize the limitations of this approach:</source>
          <target state="translated">標準化された speedtest1.c ワークロードと cachegrind を使用することで、大幅なパフォーマンスの向上が可能になりました。しかし、このアプローチの限界を認識することが重要です。</target>
        </trans-unit>
        <trans-unit id="fbf470196dd9e32d7a6c5961b17698cfadfdbb60" translate="yes" xml:space="preserve">
          <source>The use of variable-length records by SQLite has a number of advantages. It results in smaller database files, obviously. It also makes the database run faster, since there is less information to move to and from disk. And, the use of variable-length records makes it possible for SQLite to employ manifest typing instead of static typing.</source>
          <target state="translated">SQLite で可変長レコードを使用することには多くの利点があります。その結果、データベースファイルが小さくなります。また、ディスクとの間で移動する情報が少なくて済むので、データベースの実行速度も速くなります。また、可変長レコードを使用することで、SQLiteでは静的型付けの代わりにマニフェスト型付けを使用することが可能になります。</target>
        </trans-unit>
        <trans-unit id="f495ec4a4bf3743c12d1f50425c742888001cad3" translate="yes" xml:space="preserve">
          <source>The user_version pragma will to get or set the value of the user-version integer at offset 60 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. The user-version is an integer that is available to applications to use however they want. SQLite makes no use of the user-version itself.</source>
          <target state="translated">user_versionプラグマは、&lt;a href=&quot;fileformat2#database_header&quot;&gt;データベースヘッダーの&lt;/a&gt;オフセット60にあるユーザーバージョン整数の値を取得または設定します。user-versionは整数であり、アプリケーションが必要に応じて使用できます。SQLiteはユーザーバージョン自体を使用しません。</target>
        </trans-unit>
        <trans-unit id="81fbf2e7b21c5d201e92f96deae7ccf53bbeeddc" translate="yes" xml:space="preserve">
          <source>The usermerge option is similar to the automerge and crisismerge options. It is the minimum number of b-tree segments that will be merged together by a 'merge' command with a positive parameter. For example:</source>
          <target state="translated">usermerge オプションは automerge および crisismerge オプションに似ています。これは、正のパラメータを指定した 'merge' コマンドによってマージされる b-tree セグメントの最小数です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7380a4170d0b89318a355604d7dab9b3376f5f00" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; commands work on an R*Tree index just like on regular tables. So to insert some data into our sample R*Tree index, we can do something like this:</source>
          <target state="translated">通常の&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;コマンドは、通常のテーブルと同じようにR * Treeインデックスで機能します。したがって、サンプルのR * Treeインデックスにデータを挿入するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="7245ad2ccb3652b74420857f1f81436b120932a2" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">通常の場合、sqlite3_serialize（）はデータベースのシリアル化を&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;から取得したメモリにコピーし、そのメモリへのポインタを返します。呼び出し元は、メモリリークを回避するために戻り値を解放する責任があります。ただし、F引数にSQLITE_SERIALIZE_NOCOPYビットが含まれている場合、メモリの割り当ては行われず、sqlite3_serialize（）関数は、SQLiteが現在そのデータベースに使用しているデータベースの連続メモリ表現へのポインタを返します。このようなデータベースの連続したメモリ表現が存在します。データベースの連続したメモリ表現は、通常、&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（D、S、...）&lt;/a&gt;への以前の呼び出しがあった場合にのみ存在します。SQLITE_SERIALIZE_NOCOPYビットが設定されていてもデータベースの連続したコピーが存在しない場合でも、データベースのサイズは* Pに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="69659aa2e08fcc19f80f4fa144bcabaf8c7b3ed8" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">通常の場合、sqlite3_serialize（）はデータベースのシリアル化を&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;から取得したメモリにコピーし、そのメモリへのポインタを返します。呼び出し元は、メモリリークを回避するために戻り値を解放する責任があります。ただし、F引数にSQLITE_SERIALIZE_NOCOPYビットが含まれている場合、メモリの割り当ては行われず、sqlite3_serialize（）関数は、SQLiteが現在そのデータベースに使用しているデータベースの連続メモリ表現へのポインタを返します。このようなデータベースの連続したメモリ表現が存在します。データベースの連続したメモリ表現は、通常、&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（D、S、...）&lt;/a&gt;への以前の呼び出しがあった場合にのみ存在します。SQLITE_SERIALIZE_NOCOPYビットが設定されていてもデータベースの連続したコピーが存在しない場合でも、データベースのサイズは* Pに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="0fc6512389ff21ec6ba0d889f8647d34fa1771be" translate="yes" xml:space="preserve">
          <source>The usual output is an SQL script that will transform database1.sqlite (the &quot;source&quot; database) into database2.sqlite (the &quot;destination&quot; database). This behavior can be altered using command-line switches:</source>
          <target state="translated">通常の出力は、database1.sqlite(&quot;ソース &quot;データベース)をdatabase2.sqlite(&quot;デスティネーション &quot;データベース)に変換するSQLスクリプトです。この動作はコマンドラインのスイッチを使って変更することができます。</target>
        </trans-unit>
        <trans-unit id="ebe7d136ea02a608354f8bf5123226386a80e2bf" translate="yes" xml:space="preserve">
          <source>The usual usage pattern for an sqlite3_changegroup object is as follows:</source>
          <target state="translated">sqlite3_changegroupオブジェクトの通常の使用パターンは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f006b61943f366c81b0414ad0d7a764b14620096" translate="yes" xml:space="preserve">
          <source>The usual way of storing a date in a database table is as a single field, as either a unix timestamp, a julian day number, or an ISO-8601 dates string. But some application store dates as three separate fields for the year, month, and day.</source>
          <target state="translated">データベースのテーブルに日付を格納する通常の方法は、単一のフィールドとして、Unixタイムスタンプ、ジュリアンデイ番号、ISO-8601日付文字列のいずれかを使用します。しかし、アプリケーションによっては、年、月、日の3つの独立したフィールドとして日付を保存するものもあります。</target>
        </trans-unit>
        <trans-unit id="e446494ebae458b5aea2681dfd535005a9fb5001" translate="yes" xml:space="preserve">
          <source>The value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1493e5c49d89b37715d26870b14178bb98eff899" translate="yes" xml:space="preserve">
          <source>The value extracted is stored in register P3.</source>
          <target state="translated">抽出された値はレジスタP3に格納される。</target>
        </trans-unit>
        <trans-unit id="b67d4fe7f5972a61b5da20c2ef9a98c84328f043" translate="yes" xml:space="preserve">
          <source>The value of NEW.rowid is undefined in a BEFORE INSERT trigger in which the rowid is not explicitly set to an integer.</source>
          <target state="translated">NEW.rowidの値は、rowidが明示的に整数に設定されていないBEFORE INSERTトリガでは未定義です。</target>
        </trans-unit>
        <trans-unit id="6ccbeb6aa89a69300ffd6eb190f7535f8bc566cf" translate="yes" xml:space="preserve">
          <source>The value of SQLITE_THREADSAFE can be determined at run-time using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_THREADSAFEの値は、&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;インターフェイスを使用して実行時に決定できます。</target>
        </trans-unit>
        <trans-unit id="d5ab5daf4c7771df3bc76b4527132dffd8bea934" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column must always be a non-NULL integer. The PRIMARY KEY columns of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table are also required to be non-NULL.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列の値は、常にNULL以外の整数でなければなりません。&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルのPRIMARY KEY列も非NULLである必要があります。</target>
        </trans-unit>
        <trans-unit id="94d5eebfcf21e24cf605bf00db4a0642798783cd" translate="yes" xml:space="preserve">
          <source>The value of the N parameter to these interfaces should be non-negative. Future enhancements may make use of negative N values to define new kinds of function caching behavior.</source>
          <target state="translated">これらのインタフェースに対する N パラメータの値は負ではありません。将来の拡張では、新しい種類の関数キャッシュ動作を定義するために、負の N 値を使用することができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="cc7bdc3b5bd50bd43536e1eeee3d4c188a48e335" translate="yes" xml:space="preserve">
          <source>The value of the change counter is copied to the database handle change counter (returned by subsequent calls to sqlite3_changes()). Then the VMs internal change counter resets to 0. This is used by trigger programs.</source>
          <target state="translated">変更カウンタの値は、データベース・ハンドルの変更カウンタにコピーされます(後続のsqlite3_changes()の呼び出しによって返されます)。これはトリガプログラムで使用されます。</target>
        </trans-unit>
        <trans-unit id="4a5b194cd44f85aade16e1c37ccac8a115177304" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup_step（）が完了したかどうかに関係なく、sqlite3_backup_step（）エラーが発生しなかった場合、sqlite3_backup_finishが&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;返す&lt;/a&gt;値はSQLITE_OKです。同じ&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトに対する以前のsqlite3_backup_step（）呼び出し中にメモリ不足状態またはIOエラーが発生した場合、sqlite3_backup_finish（）は対応する&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="a8b2a631496d509ee2b275504f995fbe8e4ff87c" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup_step（）が完了したかどうかに関係なく、sqlite3_backup_step（）エラーが発生しなかった場合、sqlite3_backup_finishが&lt;a href=&quot;../rescode#ok&quot;&gt;返す&lt;/a&gt;値はSQLITE_OKです。同じ&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトに対する以前のsqlite3_backup_step（）呼び出し中にメモリ不足状態またはIOエラーが発生した場合、sqlite3_backup_finish（）は対応する&lt;a href=&quot;../rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="bc51fa501b0d744e2b8200daac75839a3f391d4e" translate="yes" xml:space="preserve">
          <source>The values &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are properties of the application. If an application is constructed in such a way that both &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are known, or at least have known upper bounds, and if the application uses the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator and is provided with &lt;b&gt;N&lt;/b&gt; bytes of available memory space using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; then Robson proves that no memory allocation request will ever fail within the application. To put this another way, the application developer can select a value for &lt;b&gt;N&lt;/b&gt; that will guarantee that no call to any SQLite interface will ever return &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;. The memory pool will never become so fragmented that a new memory allocation request cannot be satisfied. This is an important property for applications where a software fault could cause injury, physical harm, or loss of irreplaceable data.</source>
          <target state="translated">値&lt;b&gt;M&lt;/b&gt;と&lt;b&gt;n&lt;/b&gt;はアプリケーションのプロパティです。アプリケーションが&lt;b&gt;M&lt;/b&gt;と&lt;b&gt;nの&lt;/b&gt;両方が既知であるか、または少なくとも既知の上限があるように構築されており、アプリケーションが&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5メモリア&lt;/a&gt;ロケーターを使用し、SQLITE_CONFIG_HEAPを使用して&lt;b&gt;N&lt;/b&gt;バイトの利用可能なメモリスペースが提供されている&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;場合&lt;/a&gt;、Robsonは次のことを証明します。アプリケーション内でメモリ割り当て要求が失敗することはありません。&lt;a href=&quot;rescode#nomem&quot;&gt;言い換える&lt;/a&gt;と、アプリケーション開発者は&lt;b&gt;Nの&lt;/b&gt;値を選択して、SQLiteインターフェイスへの呼び出しがSQLITE_NOMEMを返さないことを保証できます。。メモリプールは、新しいメモリ割り当て要求を満たすことができないほど断片化されることはありません。これは、ソフトウェアの障害により、怪我、身体的危害、またはかけがえのないデータの損失が発生する可能性があるアプリケーションにとって重要な特性です。</target>
        </trans-unit>
        <trans-unit id="22f534f2da25c6b7c05e8783b8e5bfbbc59c87e8" translate="yes" xml:space="preserve">
          <source>The values for each column in the record immediately follow the header. For serial types 0, 8, 9, 12, and 13, the value is zero bytes in length. If all columns are of these types then the body section of the record is empty.</source>
          <target state="translated">レコード内の各列の値は、ヘッダの直後に続きます。シリアルタイプ 0,8,9,12,13 の場合、値の長さはゼロバイトです。すべての列がこれらのタイプの場合、レコードのボディセクションは空です。</target>
        </trans-unit>
        <trans-unit id="d128efd1de498da70d20d12d2513201d5001c97a" translate="yes" xml:space="preserve">
          <source>The values for each column of the row are stored in these columns. The &quot;.recover&quot; command creates the lost_and_found table with as many columns as required by the longest orphaned row.</source>
          <target state="translated">これらの列には、その行の各列の値が格納される。.recover&quot; コマンドは、孤児となった最長の行が必要とする数だけの列を持つ lost_and_found テーブルを作成する。</target>
        </trans-unit>
        <trans-unit id="61332fb4ed04580474ae395b4c8e0cfc53138b43" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">返される値&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16（）は&lt;/a&gt;、文字列の末尾にゼロターミネータを含んでいません。わかりやすくするために、&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;によって返される値は、文字数ではなく、文字列のバイト数です。</target>
        </trans-unit>
        <trans-unit id="56d75a71d4310cb50689d453693c130f5e211175" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">返される値&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;と&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16（）は&lt;/a&gt;、文字列の末尾にゼロターミネータを含んでいません。わかりやすくするために、&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;および&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;によって返される値は、文字数ではなく、文字列のバイト数です。</target>
        </trans-unit>
        <trans-unit id="9a34a413d802292386ca8ed35bad50613a2e40f9" translate="yes" xml:space="preserve">
          <source>The values returned by sqlite3_errcode() and/or sqlite3_extended_errcode() might change with each API call. Except, there are some interfaces that are guaranteed to never change the value of the error code. The error-code preserving interfaces are:</source>
          <target state="translated">sqlite3_errcode()やsqlite3_extended_errcode()によって返される値はAPIコールごとに変わるかもしれません。ただし、エラーコードの値を変更しないことが保証されているインタフェースがいくつかあります。エラーコードを保持するインターフェースは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="af0883b91a2c32edd6bb6e8adf9674294de318ba" translate="yes" xml:space="preserve">
          <source>The variable &lt;b&gt;$x&lt;/b&gt; is set by the above code to</source>
          <target state="translated">変数&lt;b&gt;$ x&lt;/b&gt;は、上記のコードによって次のように設定されます</target>
        </trans-unit>
        <trans-unit id="e81b821adc588b80803661eb9435ef7daf5e77e6" translate="yes" xml:space="preserve">
          <source>The variable i in the previous expression varies between 0 and 9. Conceptually, the index space is divided into 10 uniform buckets and the samples are the middle row from each bucket.</source>
          <target state="translated">前の式の変数iは0から9の間で変化する。概念的には、インデックス空間を10個の均一なバケットに分割し、各バケットから中段の行をサンプルとしています。</target>
        </trans-unit>
        <trans-unit id="e46969b4d5144ef5a3ecc1c7c5e86080c0dd5e34" translate="yes" xml:space="preserve">
          <source>The various &lt;b&gt;sqlite_stat&lt;/b&gt;</source>
          <target state="translated">さまざまな&lt;b&gt;sqlite_stat&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ea0a2ad541e7dfd246d5e09a98161b66d983211" translate="yes" xml:space="preserve">
          <source>The various SQLite Archive Archive commands are implemented using SQL statements. Application developers can easily add SQLite Archive Archive reading and writing support to their own projects by running the appropriate SQL.</source>
          <target state="translated">様々な SQLite Archive コマンドは SQL 文を使用して実装されています。アプリケーション開発者は、適切な SQL を実行することで、SQLite Archive の読み書きサポートを自分のプロジェクトに簡単に追加することができます。</target>
        </trans-unit>
        <trans-unit id="22f8ca9c7ec1168dbb45b57fd3ebfbf3e9d60926" translate="yes" xml:space="preserve">
          <source>The various assert()-like macros behave differently according to how SQLite is built.</source>
          <target state="translated">assert()のような様々なマクロは、SQLite の構築方法によって挙動が異なります。</target>
        </trans-unit>
        <trans-unit id="8789a3da4f75d5b0392ef189d216e2c9312d1546" translate="yes" xml:space="preserve">
          <source>The various unix VFSes differ only in the way they handle file locking - they share most of their implementation in common with one another and are all located in the same SQLite source file: &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;. Note that except for &quot;unix&quot; and &quot;unix-excl&quot;, the various unix VFSes all use incompatible locking implementations. If two processes are accessing the same SQLite database using different unix VFSes, they may not see each others locks and may end up interfering with one another, resulting in database corruption. The &quot;unix-none&quot; VFS in particular does no locking at all and will easily result in database corruption if used by two or more database connections at the same time. Programmers are encouraged to use only &quot;unix&quot; or &quot;unix-excl&quot; unless there is a compelling reason to do otherwise.</source>
          <target state="translated">さまざまなUNIX VFSは、ファイルロックの処理方法のみが異なります。これらは、実装のほとんどを互いに共有しており、すべて同じSQLiteソースファイル&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.cにあり&lt;/a&gt;ます。 「unix」と「unix-excl」を除いて、さまざまなUNIX VFSはすべて互換性のないロック実装を使用しています。 2つのプロセスが異なるUNIX VFSを使用して同じSQLiteデータベースにアクセスしている場合、お互いのロックが認識されず、相互に干渉してデータベースが破損する可能性があります。特に「unix-none」VFSはロックをまったく行わないため、2つ以上のデータベース接続で同時に使用すると、データベースが破損しやすくなります。プログラマーは「unix」または「unix-excl」のみを使用することをお勧めしますそうでなければやむを得ない理由がない限り。</target>
        </trans-unit>
        <trans-unit id="c5ffe5eea46cbcd5a1594ce73f72bf62a68d39e3" translate="yes" xml:space="preserve">
          <source>The versions of SQLite that come preinstalled on Apple Mac OS X computers contain a version of SQLite that has been extended to use alternative locking strategies that work on all network filesystems that Apple supports. These extensions used by Apple work great as long as all processes are accessing the database file in the same way. Unfortunately, the locking mechanisms do not exclude one another, so if one process is accessing a file using (for example) AFP locking and another process (perhaps on a different machine) is using dot-file locks, the two processes might collide because AFP locks do not exclude dot-file locks or vice versa.</source>
          <target state="translated">Apple Mac OS XコンピュータにプリインストールされているSQLiteのバージョンには、Appleがサポートしているすべてのネットワークファイルシステムで動作する代替ロック戦略を使用するように拡張されたSQLiteのバージョンが含まれています。Appleが使用しているこれらの拡張機能は、すべてのプロセスが同じ方法でデータベースファイルにアクセスしている限り、非常に有効に機能します。不幸なことに、ロック機構は互いに除外されないので、あるプロセスが(例えば)AFPロックを使用してファイルにアクセスしていて、別のプロセス(おそらく別のマシン上で)がドットファイルロックを使用している場合、AFPロックはドットファイルロックを除外しないので、2つのプロセスが衝突する可能性がありますし、逆もまた然りです。</target>
        </trans-unit>
        <trans-unit id="27a68965a58736f6647ab050fea465e20bf8ddef" translate="yes" xml:space="preserve">
          <source>The versions of the SQLite amalgamation that are supplied on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; are normally adequate for most users. However, some projects may want or need to build their own amalgamations. A common reason for building a custom amalgamation is in order to use certain &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; to customize the SQLite library. Recall that the SQLite amalgamation contains a lot of C-code that is generated by auxiliary programs and scripts. Many of the compile-time options effect this generated code and must be supplied to the code generators before the amalgamation is assembled. The set of compile-time options that must be passed into the code generators can vary from one release of SQLite to the next, but at the time of this writing (circa SQLite 3.6.20, 2009-11-04) the set of options that must be known by the code generators includes:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;ダウンロードページで&lt;/a&gt;提供されるSQLiteアマルガムのバージョンは、通常、ほとんどのユーザーに適しています。ただし、一部のプロジェクトでは、独自の統合を構築する必要がある場合があります。カスタム統合を構築する一般的な理由は、特定の&lt;a href=&quot;compile&quot;&gt;コンパイル時オプション&lt;/a&gt;を使用するためですSQLiteライブラリをカスタマイズします。SQLiteの統合には、補助プログラムとスクリプトによって生成された多くのCコードが含まれていることを思い出してください。コンパイル時のオプションの多くはこの生成されたコードに影響を与えるため、融合をアセンブルする前にコードジェネレーターに提供する必要があります。コードジェネレーターに渡す必要があるコンパイル時オプションのセットは、SQLiteのリリースごとに異なる可能性がありますが、この記事の執筆時点では（SQLite 3.6.20、2009年11月4日頃）オプションのセットはコードジェネレーターが認識しなければならないものは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d08eefb01c3e7948c8ed07ad520422cff4b9225d" translate="yes" xml:space="preserve">
          <source>The very name &quot;Structured Query Language&quot; tells us that SQL should support nested queries. And, in fact, two different kinds of nesting are supported. Any SELECT statement that returns a single-row, single-column result can be used as a term in an expression of another SELECT statement. And, a SELECT statement that returns a single-column, multi-row result can be used as the right-hand operand of the IN and NOT IN operators. We will begin this section with an example of the first kind of nesting, where a single-row, single-column SELECT is used as a term in an expression of another SELECT. Here is our example:</source>
          <target state="translated">構造化されたクエリ言語」という名前は、SQLがネストされたクエリをサポートしなければならないことを教えてくれます。そして実際には、2種類の異なる入れ子がサポートされています。1行1列の結果を返すSELECT文は、別のSELECT文の式の項として使用することができます。また、1列で複数行の結果を返すSELECT文は、INおよびNOT IN演算子の右辺のオペランドとして使用することができます。このセクションでは、1行1列のSELECTが別のSELECT文の式の項として使用される、最初の種類の入れ子の例から始めます。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="20c4a011c8e3b37249d4469eb52a0ff7a1d9c48e" translate="yes" xml:space="preserve">
          <source>The vfs query parameter causes the database connection to be opened using the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; called</source>
          <target state="translated">vfsクエリパラメータにより、呼び出された&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を使用してデータベース接続が開かれます</target>
        </trans-unit>
        <trans-unit id="7fc9c565eeb1c6123557989180ff5a163d06934e" translate="yes" xml:space="preserve">
          <source>The view to drop is identified by the view-name and optional schema-name specified as part of the DROP VIEW statement. This reference is resolved using the standard procedure for &lt;a href=&quot;lang_naming&quot;&gt;object resolution&lt;/a&gt;.</source>
          <target state="translated">削除するビューは、DROP VIEWステートメントの一部として指定されたビュー名とオプションのスキーマ名によって識別されます。この参照は、&lt;a href=&quot;lang_naming&quot;&gt;オブジェクト解決の&lt;/a&gt;標準手順を使用して解決されます。</target>
        </trans-unit>
        <trans-unit id="3b2c6960eedc019bcf13fce258370b16a245ba89" translate="yes" xml:space="preserve">
          <source>The view v1 cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; because it is DISTINCT. It must instead be run as a subquery with the results being stored in a transient table, then the join is performed between t2 and the transient table. The push-down optimization pushes down the &quot;b BETWEEN 10 AND 20&quot; term into the view. This makes the transient table smaller, and helps the subquery to run faster if there is an index on t1.b. The resulting evaluation is like this:</source>
          <target state="translated">ビューv1 はDISTINCTであるため、&lt;a href=&quot;optoverview#flattening&quot;&gt;フラット化&lt;/a&gt;できません。代わりに、結果が一時テーブルに格納されるサブクエリとして実行する必要があります。その後、t2と一時テーブルの間で結合が実行されます。プッシュダウン最適化は、「b BETWEEN 10 AND 20」という用語をビューにプッシュダウンします。これにより、一時テーブルが小さくなり、t1.bにインデックスがある場合、サブクエリの実行が速くなります。結果の評価は次のようになります。</target>
        </trans-unit>
        <trans-unit id="ce6b93653a867ff824a137b275a2d8a4b5929427" translate="yes" xml:space="preserve">
          <source>The virtual machine itself is entirely contained in a single source file &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h&lt;/a&gt; header file defines an interface between the virtual machine and the rest of the SQLite library and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; which defines structures and interfaces that are private the virtual machine itself. Various other &lt;b&gt;vdbe*.c&lt;/b&gt; files are helpers to the virtual machine. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c&lt;/a&gt; file contains utilities used by the virtual machine and interface modules used by the rest of the library to construct VM programs. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; file contains external interfaces to the virtual machine such as the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int()&lt;/a&gt; and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Individual values (strings, integer, floating point numbers, and BLOBs) are stored in an internal object named &quot;Mem&quot; which is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;.</source>
          <target state="translated">仮想マシン自体は、単一のソースファイル&lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.cに&lt;/a&gt;完全に含まれています。&lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.hの&lt;/a&gt;ヘッダファイルは、仮想マシンとのSQLiteライブラリの残りの部分との間のインタフェース定義&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt;仮想マシン自体プライベートである構造とインタフェースを定義します。他のさまざまな&lt;b&gt;vdbe * .c&lt;/b&gt;ファイルは、仮想マシンのヘルパーです。&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.cの&lt;/a&gt;ファイルは、VMのプログラムを構築するために、ライブラリの残りの部分で使用される仮想マシンとのインタフェースモジュールで使用されるユーティリティが含まれています。&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.cの&lt;/a&gt;ファイルは以下のような仮想マシンに外部インターフェース含ま&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int（）&lt;/a&gt;と&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）を&lt;/a&gt;。個々の値（文字列、整数、浮動小数点数、BLOB）は、&lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;によって実装される「Mem」という名前の内部オブジェクトに格納されます。</target>
        </trans-unit>
        <trans-unit id="00bcd77d6dec3bc1a5f96c0e0f3985aefbea69f9" translate="yes" xml:space="preserve">
          <source>The virtual table contains an xShadowName method.</source>
          <target state="translated">仮想テーブルには xShadowName メソッドが含まれています。</target>
        </trans-unit>
        <trans-unit id="aba94b8d1e25fe7120c464dc013b1d34868edb66" translate="yes" xml:space="preserve">
          <source>The virtual table mechanism allows an application to publish interfaces that are accessible from SQL statements as if they were tables. SQL statements can do almost anything to a virtual table that they can do to a real table, with the following exceptions:</source>
          <target state="translated">仮想テーブルのメカニズムにより、アプリケーションはSQL文からアクセス可能なインターフェースを、あたかもテーブルであるかのように公開することができます。SQL ステートメントは、仮想テーブルに対して、実際のテーブルに対してできることと同じように、以下の例外を除いてほとんどすべてのことを行うことができます。</target>
        </trans-unit>
        <trans-unit id="7616eb3efb8cfc2b544466ae9f36f2a81289f276" translate="yes" xml:space="preserve">
          <source>The virtual table will return one row of output for each token in the input string. The &quot;token&quot; column is the text of the token. The &quot;start&quot; and &quot;end&quot; columns are the byte offset to the beginning and end of the token in the original input string. The &quot;position&quot; column is the sequence number of the token in the original input string. There is also an &quot;input&quot; column which is simply a copy of the input string that is specified in the WHERE clause. Note that a constraint of the form &quot;input=?&quot; must appear in the WHERE clause or else the virtual table will have no input to tokenize and will return no rows. The example above generates the following output:</source>
          <target state="translated">仮想テーブルは、入力文字列に含まれるトークンごとに1行の出力を返します。token」列はトークンのテキストです。start&quot; および &quot;end&quot; カラムは、元の入力文字列内のトークンの開始および終了に対するバイトオフセットです。position」列は、元の入力文字列中のトークンのシーケンス番号である。また、「input」列もあり、これは単にWHERE句で指定された入力文字列のコピーである。そうでなければ、仮想テーブルはトークン化する入力を持たず、行を返さないことに注意してください。上記の例では、次のような出力が生成されます。</target>
        </trans-unit>
        <trans-unit id="e7d6d48d0123dd78c2ece991b5f7661cea292174" translate="yes" xml:space="preserve">
          <source>The wal-index file or &quot;shm&quot; file is not actually used as a file. Rather, individual database clients mmap the shm file and use it as shared memory for coordinating access to the database and as a cache for quickly locating frame within the wal file. The name of the shm file is the main database file name with the four characters &quot;-shm&quot; appended. Or, for 8+3 filesystems, the shm file is the main database file with the suffix changed to &quot;.SHM&quot;.</source>
          <target state="translated">wal-indexファイルまたは &quot;shm &quot;ファイルは実際にはファイルとしては使用されません。むしろ、個々のデータベースクライアントはshmファイルをmmapし、データベースへのアクセスを調整するための共有メモリとして、また、walファイル内のフレームを素早く見つけるためのキャッシュとして使用します。shmファイルの名前は、メインのデータベースファイル名に4文字の&quot;-shm &quot;を付加したものです。または、8+3ファイルシステムでは、shmファイルはメインデータベースファイルで、サフィックスを&quot;.shm &quot;に変更したものです。</target>
        </trans-unit>
        <trans-unit id="2705cff44fec902d1ca3ce2af3b554cabc339fb3" translate="yes" xml:space="preserve">
          <source>The wal-index file, usually named &quot;X-shm&quot;.</source>
          <target state="translated">ウォルインデックスファイル、通常は「X-shm」と名付けられています。</target>
        </trans-unit>
        <trans-unit id="3164ee82328b180dbc8289eddc9db733f9109901" translate="yes" xml:space="preserve">
          <source>The wal-index is transient. After a crash, the wal-index is reconstructed from the original WAL file. The VFS is required to either truncate or zero the header of the wal-index when the last connection to it closes. Because the wal-index is transient, it can use an architecture-specific format; it does not have to be cross-platform. Hence, unlike the database and WAL file formats which store all values as big endian, the wal-index stores multi-byte values in the native byte order of the host computer.</source>
          <target state="translated">wal-indexは一時的なものです。クラッシュ後、wal-index は元の WAL ファイルから再構築されます。VFS は wal-index への最後の接続が終了すると、wal-index のヘッダを切り詰めるかゼロにする必要があります。wal-indexは過渡的なものであるため、アーキテクチャ固有のフォーマットを使用することができ、クロスプラットフォームである必要はありません。したがって、すべての値をビッグエンディアンで保存するデータベースや WAL ファイルフォーマットとは異なり、wal-index はホストコンピュータのネイティブバイト順でマルチバイト値を保存します。</target>
        </trans-unit>
        <trans-unit id="f37728360280f92c82e5f63eda2235cd3fe649d8" translate="yes" xml:space="preserve">
          <source>The wal_checkpoint pragma returns a single row with three integer columns. The first column is usually 0 but will be 1 if a RESTART or FULL or TRUNCATE checkpoint was blocked from completing, for example because another thread or process was actively using the database. In other words, the first column is 0 if the equivalent call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; would have returned &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or 1 if the equivalent call would have returned &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. The second column is the number of modified pages that have been written to the write-ahead log file. The third column is the number of pages in the write-ahead log file that have been successfully moved back into the database file at the conclusion of the checkpoint. The second and third column are -1 if there is no write-ahead log, for example if this pragma is invoked on a database connection that is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">wal_checkpointプラグマは、3つの整数列を持つ単一の行を返します。最初の列は通常0ですが、たとえば別のスレッドまたはプロセスがデータベースをアクティブに使用していたために、RESTARTまたはFULLまたはTRUNCATEチェックポイントの完了がブロックされた場合は1になります。換言すれば、最初の列は、と等価呼び出し場合は0である&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）が&lt;/a&gt;返されたであろう&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;同等の呼び出しが戻ってきたかどうか、1 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSYを&lt;/a&gt;。 2番目の列は、先行書き込みログファイルに書き込まれた変更済みページの数です。 3番目の列は、チェックポイントの終了時にデータベースファイルに正常に戻された先行書き込みログファイルのページ数です。たとえば、このプラグマが&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;ではないデータベース接続で呼び出された場合、2番目と3番目の列は、先行書き込みログがない場合は-1 です。</target>
        </trans-unit>
        <trans-unit id="7abca67d3b2f6649a3ed46e41721882b254d1af5" translate="yes" xml:space="preserve">
          <source>The way SQLite deals with this is to first run the inner SELECT (the one against examp2) and store its result in a private memory cell. SQLite then substitutes the value of this private memory cell for the inner SELECT when it evaluates the outer SELECT. The code looks like this:</source>
          <target state="translated">SQLiteがこれを処理する方法は、まず内側のSELECT(examp2に対するもの)を実行し、その結果をプライベート・メモリ・セルに格納します。SQLiteは、外側のSELECTを評価する際に、このプライベート・メモリ・セルの値を内側のSELECTの値に置き換えます。コードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d9f0711eae8ce05c73449f6cd3513a09a5b0c229" translate="yes" xml:space="preserve">
          <source>The way in which the IN and NOT IN operators handle NULL values in their right-hand expressions has been brought into compliance with the SQL standard and with other SQL database engines.</source>
          <target state="translated">IN および NOT IN 演算子が右辺の式で NULL 値を扱う方法は、SQL 標準および他の SQL データベースエンジンに準拠するようになりました。</target>
        </trans-unit>
        <trans-unit id="1bcbf2e1391b1aa7e3ebafdb83d7f3bc20c48ce0" translate="yes" xml:space="preserve">
          <source>The whole point of the xShadowName method is to protect the content of shadow tables from being corrupted by hostile SQL. Every virtual table implementation that uses shadow tables should be able to detect and cope with corrupted shadow table content. However, bugs in particular virtual table implementation might allow a deliberately corrupted shadow table to cause a crash or other malfunction. The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary SQL statements from deliberately corrupting shadow tables.</source>
          <target state="translated">xShadowName メソッドの全体的なポイントは、シャドウテーブルの内容が敵対的な SQL によって破損されないように保護することです。シャドウテーブルを使用するすべての仮想テーブルの実装は、破損したシャドウテーブルの内容を検出して対処することができるはずです。しかし、特定の仮想テーブル実装のバグにより、故意に破損したシャドウテーブルがクラッシュやその他の誤動作を引き起こす可能性があります。xShadowNameメカニズムは、通常のSQLステートメントがシャドウテーブルを故意に破損することを防ぐことで、ゼロデイエクスプロイトを回避しようとしています。</target>
        </trans-unit>
        <trans-unit id="7ba3625dd3002c676817bb5d0641f1c309f9b35c" translate="yes" xml:space="preserve">
          <source>The width field specifies the minimum width of the substituted value in the output. If the string or number that is written into the output is shorter than the width, then the value is padded. Padding is on the left (the value is right-justified) by default. If the &quot;-&quot; flag is used, then the padding is on the right and the value is left-justified.</source>
          <target state="translated">widthフィールドは、出力内の置換された値の最小幅を指定します。出力に書き込まれる文字列や数値が幅よりも短い場合、値はパディングされます。パディングは、デフォルトでは左側にある(値は右寄せになる)。フラグ&quot;-&quot;が使用された場合、パディングは右側になり、値は左寄せになる。</target>
        </trans-unit>
        <trans-unit id="a12aad5ee5dbe2d3fff555e1c8b3c9090a69eb38" translate="yes" xml:space="preserve">
          <source>The width is measured in bytes by default. However, if the &quot;!&quot; flag is present then the width is in characters. This only makes a difference for multi-byte utf-8 characters, and those only occur on string substitutions.</source>
          <target state="translated">デフォルトでは、幅はバイト単位で測定されます。しかし、&quot;!&quot; フラグがある場合は、幅は文字単位になります。これはマルチバイトの utf-8 文字にのみ影響を与え、文字列の置換時にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="bb37fe25186c24e9c2d6b18924cc12e6bf999427" translate="yes" xml:space="preserve">
          <source>The word transliterated into lower-case ASCII. There is a standard table of mappings from non-ASCII characters into ASCII. Examples: &quot;&amp;aelig;&quot; -&amp;gt; &quot;ae&quot;, &quot;&amp;thorn;&quot; -&amp;gt; &quot;th&quot;, &quot;&amp;szlig;&quot; -&amp;gt; &quot;ss&quot;, &quot;&amp;aacute;&quot; -&amp;gt; &quot;a&quot;, ... The accessory function spellfix1_translit(X) will do the non-ASCII to ASCII mapping. The built-in lower(X) function will convert to lower-case. Thus: k1 = lower(spellfix1_translit(word)). If the word is already all lower-case ASCII, then the k1 column will contain a NULL. This reduces the storage requirements for the %_vocab table and helps spellfix to run a little faster. Therefore, it is advantageous to populate as much of the spellfix table as possible using lower-case ASCII vocabulary.</source>
          <target state="translated">小文字のASCIIに音訳された単語。非ASCII文字からASCIIへのマッピングの標準的な表があります。例：「&amp;aelig;」-&amp;gt;「ae」、「&amp;thorn;」-&amp;gt;「th」、「&amp;szlig;」-&amp;gt;「ss」、「&amp;aacute;」-&amp;gt;「a」、...付属関数spellfix1_translit（X）は、非ASCIIからASCIIへのマッピング。組み込みのlower（X）関数は小文字に変換されます。したがって：k1 = lower（spellfix1_translit（word））。単語がすべて小文字のASCIIである場合、k1列にはNULLが含まれます。これにより、％_ vocabテーブルのストレージ要件が軽減され、spellfixの実行が少し速くなります。したがって、小文字のASCIIボキャブラリーを使用して、可能な限り多くのspellfixテーブルを埋めることが有利です。</target>
        </trans-unit>
        <trans-unit id="2aea0dad5536afb073da7952899f42822308cf24" translate="yes" xml:space="preserve">
          <source>The working directory</source>
          <target state="translated">作業ディレクトリ</target>
        </trans-unit>
        <trans-unit id="1191da9cfb737ab513b0974862b6931c34d468a3" translate="yes" xml:space="preserve">
          <source>The write-ahead log file, usually named &quot;X-wal&quot;.</source>
          <target state="translated">書き込み可能なログファイルで、通常は「X-wal」と名付けられています。</target>
        </trans-unit>
        <trans-unit id="aa76cd0207c05b41731ac87f189a853ae60f3634" translate="yes" xml:space="preserve">
          <source>The write-ahead log or &quot;wal&quot; file is a roll-forward journal that records transactions that have been committed but not yet applied to the main database. Details on the format of the wal file are describe in the &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL format&lt;/a&gt; subsection of the main &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The wal file is named by appending the four characters &quot;-wal&quot; to the end of the name of the main database file. Except on 8+3 filesystems, such names are not allowed, and in that case the file suffix is changed to &quot;.WAL&quot;. But as 8+3 filesystems are increasingly rare, that exceptional case can usually be ignored.</source>
          <target state="translated">先行書き込みログまたは「wal」ファイルは、コミットされているがメインデータベースにまだ適用されていないトランザクションを記録するロールフォワードジャーナルです。 walファイルの形式の詳細については、メイン&lt;a href=&quot;fileformat2&quot;&gt;ファイル形式の&lt;/a&gt;ドキュメントの&lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL形式の&lt;/a&gt;サブセクションをご覧ください。 walファイルの名前は、メインデータベースファイルの名前の末尾に「-wal」という4文字を追加したものです。 8 + 3ファイルシステムを除いて、そのような名前は許可されていません。その場合、ファイルのサフィックスは「.WAL」に変更されます。しかし、8 + 3ファイルシステムはますます珍しくなっているため、その例外的なケースは通常無視できます。</target>
        </trans-unit>
        <trans-unit id="9fcf91986e20f3838e989f19567544d31cd8c593" translate="yes" xml:space="preserve">
          <source>The writefile(X,Y) SQL function write the blob Y into the file named X and returns the number of bytes written. Use this function to extract the content of a single table column into a file. For example:</source>
          <target state="translated">writefile(X,Y)SQL 関数は、X という名前のファイルに blob Y を書き込み、書き込まれたバイト数を返します。この関数を使用して、単一のテーブル列の内容をファイルに抽出します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="35efa113638256d189c7bffd527a8b95982adee0" translate="yes" xml:space="preserve">
          <source>The writing test above is not completely fair, since SQLite is doing &lt;a href=&quot;transactional&quot;&gt;power-safe transactions&lt;/a&gt; whereas the direct-to-disk writing is not. To put the tests on a more equal footing, add either the --nosync option to the SQLite writes to disable calling fsync() or FlushFileBuffers() to force content to disk, or using the --fsync option for the direct-to-disk tests to force them to invoke fsync() or FlushFileBuffers() when updating disk files.</source>
          <target state="translated">上記の書き込みテストは完全に公平ではありません。SQLiteは&lt;a href=&quot;transactional&quot;&gt;パワーセーフトランザクションを実行しているの&lt;/a&gt;に対し、ディスクへの直接書き込みはそうではありません。テストをより均等に行うには、SQL書き込みに--nosyncオプションを追加して、fsync（）またはFlushFileBuffers（）の呼び出しを無効にしてコンテンツをディスクに強制するか、または--fsyncオプションを使用して直接ディスクテストでは、ディスクファイルの更新時に、fsync（）またはFlushFileBuffers（）を強制的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="3500eedb790da60f6c7c2c2fe42347161ad2dc7e" translate="yes" xml:space="preserve">
          <source>The xAccess method is used to check for access permissions on a file. The filename will be UTF-8 encoded. The flags argument will be &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to check for the existence of the file, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to check to see if the file is both readable and writable, or &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to check to see if the file is at least readable. The &quot;file&quot; named by the second parameter might be a directory or folder name.</source>
          <target state="translated">xAccessメソッドは、ファイルへのアクセス許可を確認するために使用されます。ファイル名はUTF-8でエンコードされます。 flags引数は次のようになります&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;、ファイルの存在を確認するために&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITEを&lt;/a&gt;ファイルは読み書き可能の両方であるかどうかを確認するために、または&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;ファイルは、少なくとも読み込み可能であるかどうかを確認します。 2番目のパラメーターで指定された「ファイル」は、ディレクトリーまたはフォルダー名である可能性があります。</target>
        </trans-unit>
        <trans-unit id="7e3dceb3a3d82f8b52bd7f5b2f951ed3b0619691" translate="yes" xml:space="preserve">
          <source>The xAccess() method is invoked again to detect if the journal file is still in the file system. If it is, then it is a hot-journal file and SQLite tries to roll it back (see section</source>
          <target state="translated">xAccess()メソッドが再び呼び出され、ジャーナルファイルがファイルシステム内に残っているかどうかを検出します。もしそうであれば、それはホットジャーナルファイルであり、SQLite はそれをロールバックしようとします (</target>
        </trans-unit>
        <trans-unit id="be1521ac61f6da801d0f89ccb40ef26362bd2aea" translate="yes" xml:space="preserve">
          <source>The xAccess() method of the VFS is allowed to return -1 to signal a memory allocation error.</source>
          <target state="translated">VFS の xAccess()メソッドは、メモリ割り当てエラーのシグナルとして -1 を返すことができます。</target>
        </trans-unit>
        <trans-unit id="dbb116d3015d148d9aef4ab4eaf91f8dc7699911" translate="yes" xml:space="preserve">
          <source>The xBestIndex function may have requested the values of certain expressions using the aConstraintUsage[].argvIndex values of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. Those values are passed to xFilter using the argc and argv parameters.</source>
          <target state="translated">xBestIndex関数は、&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;構造体のaConstraintUsage []。argvIndex値を使用して特定の式の値を要求した可能性があります。これらの値は、argcおよびargvパラメーターを使用してxFilterに渡されます。</target>
        </trans-unit>
        <trans-unit id="e673068c08d7f626c7139b66b363abe588afdbfb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method fills the idxNum and idxStr fields with information that communicates an indexing strategy to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. The information in idxNum and idxStr is arbitrary as far as the SQLite core is concerned. The SQLite core just copies the information through to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. Any desired meaning can be assigned to idxNum and idxStr as long as xBestIndex and xFilter agree on what that meaning is.</source>
          <target state="translated">xBestIndexメソッドは、インデックス戦略を&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドに伝える情報をidxNumおよびidxStrフィールドに入力します。SQLiteコアに関する限り、idxNumおよびidxStrの情報は任意です。SQLiteコアは、情報を&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドにコピーするだけです。xBestIndexとxFilterがその意味と一致する限り、idxNumとidxStrに任意の意味を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="7549b2c421b13b6947674708c7a5360fc1373a57" translate="yes" xml:space="preserve">
          <source>The xBestIndex method is required for every virtual table implementation.</source>
          <target state="translated">xBestIndex メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="6671b4241ef5e4b25933598f6cbd513b0faa9c69" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may optionally populate the idxFlags field with a mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag - SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite assumes that the strategy may visit at most one row.</source>
          <target state="translated">xBestIndex メソッドは、オプションで idxFlags フィールドに SQLITE_INDEX_SCAN_*フラグのマスクを指定することができます。現在、そのようなフラグは一つだけです-SQLITE_INDEX_SCAN_UNIQUE。xBestIndexメソッドがこのフラグを設定すると、SQLiteはストラテジーが最大でも1行を訪問すると仮定します。</target>
        </trans-unit>
        <trans-unit id="60dc1bff84d7b24ecf260c549a70a2e550acd608" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may set aConstraintUsage[].argvIndex entries to values greater than zero. Exactly one entry should be set to 1, another to 2, another to 3, and so forth up to as many or as few as the xBestIndex method wants. The EXPR of the corresponding constraints will then be passed in as the argv[] parameters to xFilter.</source>
          <target state="translated">xBestIndexメソッドは、aConstraintUsage[].argvIndexエントリをゼロよりも大きな値に設定することができます。正確には、1つのエントリを1に設定し、別のエントリを2に設定し、別のエントリを3に設定するなど、xBestIndexメソッドが望む数だけ、または少ない数だけ設定する必要があります。対応する制約のEXPRは、argv[]パラメータとしてxFilterに渡されます。</target>
        </trans-unit>
        <trans-unit id="b0c67bb7b3ba635b9cd74ad89d5155e843f934eb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method should return SQLITE_OK on success. If any kind of fatal error occurs, an appropriate error code (ex: &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;) should be returned instead.</source>
          <target state="translated">xBestIndexメソッドは成功するとSQLITE_OKを返します。何らかの致命的なエラーが発生した場合は、適切なエラーコード（例：&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;）が返されます。</target>
        </trans-unit>
        <trans-unit id="6e2147722085d4c968213130f4ef993a32c73b66" translate="yes" xml:space="preserve">
          <source>The xBestIndex method will be invoked once for each of the potential plans above. For plan 1, the aConstraint[].usable flag for for the SQLITE_CONSTRAINT_EQ constraint on the param1 column will be true because the right-hand side value for the &quot;param1 = ?&quot; constraint will be known, since it is determined by the outer realtab loop. But for plan 2, the aConstraint[].usable flag for &quot;param1 = ?&quot; will be false because the right-hand side value is determined by an inner loop and is thus an unknown quantity. Because param1 is a required input to the table-valued functions, the xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2, indicating that a required input is missing. This forces the query planner to select plan 1.</source>
          <target state="translated">xBestIndexメソッドは、上記の潜在的なプランのそれぞれに対して一度だけ呼び出されます。プラン1では、&quot;param1=? &quot;制約の右側の値は外側のrealtabループによって決定されるので、&quot;param1=? &quot;制約のためのSQLITE_CONSTRAINT_EQ制約のためのaConstraint[].usableフラグは真になります。しかし、プラン2の場合、&quot;param1=? &quot;制約の右側の値は内側のループによって決定されるため、未知の量であるため、&quot;param1=? &quot;制約のaConstraint[].usableフラグは偽になります。param1はテーブル値関数への必須入力であるため、xBestIndexメソッドはプラン2が提示されたときにSQLITE_CONSTRAINTを返し、必須入力が存在しないことを示します。これにより、クエリプランナはプラン1を選択するように強制されます。</target>
        </trans-unit>
        <trans-unit id="c5e6a28d9d92d2bf9deb3f28a367d165a9d141f6" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">SQLiteは、xCachesize（）メソッドをいつでも呼び出して、最初の引数として渡されるキャッシュインスタンスの推奨最大キャッシュサイズ（保存されるページ数）を設定できます。これは、SQLiteの &quot; &lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;コマンドを使用して構成された値です。bPurgeableパラメータと同様に、実装はこの値で何もする必要はありません。それは助言のみです。</target>
        </trans-unit>
        <trans-unit id="64860c154593114b929547aef1bfe359a445dd93" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">SQLiteは、xCachesize（）メソッドをいつでも呼び出して、最初の引数として渡されるキャッシュインスタンスの推奨最大キャッシュサイズ（保存されるページ数）を設定できます。これは、SQLiteの &quot; &lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;コマンドを使用して構成された値です。bPurgeableパラメータと同様に、実装はこの値で何もする必要はありません。それは助言のみです。</target>
        </trans-unit>
        <trans-unit id="76bfcc9d387b84934d7209d1ccf2568a52cae2ff" translate="yes" xml:space="preserve">
          <source>The xCheckReservedLock() method checks to see if another connection or another process is currently holding a reserved, pending, or exclusive lock on the file. It returns true or false.</source>
          <target state="translated">xCheckReservedLock()メソッドは、他の接続または他のプロセスが、現在ファイルの予約済み、保留中、または排他的なロックを保持しているかどうかをチェックします。このメソッドは、true または false を返します。</target>
        </trans-unit>
        <trans-unit id="5108534fb3c98c994a35c533b42cb72d472a86d4" translate="yes" xml:space="preserve">
          <source>The xClose method closes a cursor previously opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The SQLite core will always call xClose once for each cursor opened using xOpen.</source>
          <target state="translated">xCloseメソッドは、&lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;によって以前に開かれたカーソルを閉じます。SQLiteコアは、xOpenを使用して開いたカーソルごとに常にxCloseを呼び出します。</target>
        </trans-unit>
        <trans-unit id="a1fcaec496244ffb2502893506be9bff99222ddb" translate="yes" xml:space="preserve">
          <source>The xClose method closes the file. The space for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure is deallocated by the caller. But if the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains pointers to other allocated memory or resources, those allocations should be released by the xClose method.</source>
          <target state="translated">xCloseメソッドはファイルを閉じます。&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;構造のスペースは、呼び出し元によって割り当て解除されます。ただし、&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;に他の割り当てられたメモリまたはリソースへのポインターが含まれている場合、それらの割り当てはxCloseメソッドによって解放される必要があります。</target>
        </trans-unit>
        <trans-unit id="2af5d67c2c34fed358127148fe670412a17ae024" translate="yes" xml:space="preserve">
          <source>The xClose method is required for every virtual table implementation.</source>
          <target state="translated">xClose メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="57537332c9edcb104197db5e7bb9793f5df28547" translate="yes" xml:space="preserve">
          <source>The xColumn method is required for every virtual table implementation.</source>
          <target state="translated">xColumn メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="ef93eeb561a6057de6700b4a7eda4c4170148438" translate="yes" xml:space="preserve">
          <source>The xColumnSize API always returns -1. There is no way to determine the number of tokens in a value stored within a contentless FTS5 table configured with columnsize=0.</source>
          <target state="translated">xColumnSize API は常に -1 を返します。columnsize=0 で構成されたコンテントレス FTS5 テーブル内に格納された値のトークン数を決定する方法はありません。</target>
        </trans-unit>
        <trans-unit id="9e2d00478c87bed4be4b97709f42f53211a90ec1" translate="yes" xml:space="preserve">
          <source>The xConnect method is required for every virtual table implementation, though the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and xConnect pointers of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; object may point to the same function if the virtual table does not need to initialize backing store.</source>
          <target state="translated">けれどもxconnectコン方法は、すべての仮想テーブルの実装に必要とされる&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;のとxconnectのポインタ&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;仮想テーブルは、バッキングストアを初期化する必要がない場合、オブジェクトは、同じ機能を指すことがあります。</target>
        </trans-unit>
        <trans-unit id="3a84b2667247b1e27fdcdd3d4cc56221f573c090" translate="yes" xml:space="preserve">
          <source>The xConnect method is very similar to &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;. It has the same parameters and constructs a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure just like xCreate. And it must also call &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; like xCreate.</source>
          <target state="translated">xConnectメソッドはxCreateに非常に似てい&lt;a href=&quot;vtab#xcreate&quot;&gt;ます&lt;/a&gt;。同じパラメーターがあり、&lt;a href=&quot;c3ref/vtab&quot;&gt;xCreateと&lt;/a&gt;同じように新しいsqlite3_vtab構造を構築します。また、&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;xCreateの&lt;/a&gt;ようにsqlite3_declare_vtab （）を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="9ec50befd1d20d9f6756f231c4255cc685afba32" translate="yes" xml:space="preserve">
          <source>The xConnect method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">エクスコネクト方法は返す必要があり&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;、それが新しい仮想テーブルを作成することに成功、またはある場合&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;それが成功しなかった場合。成功しない場合は、&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;構造を割り当てないでください。失敗した場合、オプションでエラーメッセージが* pzErrに返される場合があります。アプリケーションにエラーが報告された後、SQLiteコアは&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を使用してスペースを解放しようとするため、エラーメッセージ文字列を保持するスペースは、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;などのSQLiteメモリ割り当て関数を使用して割り当てる必要があります。</target>
        </trans-unit>
        <trans-unit id="6920f3a6545664c297cabaad1f1d797cb28640a2" translate="yes" xml:space="preserve">
          <source>The xCreate and xConnect methods are only different when the virtual table has some kind of backing store that must be initialized the first time the virtual table is created. The xCreate method creates and initializes the backing store. The xConnect method just connects to an existing backing store. When xCreate and xConnect are the same, the table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;.</source>
          <target state="translated">xCreateメソッドとxConnectメソッドは、仮想テーブルが初めて作成されたときに初期化する必要があるバッキングストアの種類がある場合にのみ異なります。 xCreateメソッドは、バッキングストアを作成および初期化します。 xConnectメソッドは、既存のバッキングストアに接続するだけです。 xCreateとxConnectが同じ場合、テーブルは代名詞の&lt;a href=&quot;vtab#epovtab&quot;&gt;仮想テーブル&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="dcf39a347f064ec02d2e007cec689340fd805ffc" translate="yes" xml:space="preserve">
          <source>The xCreate method is called to create a new instance of a virtual table in response to a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If the xCreate method is the same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, then the virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;. If the xCreate method is omitted (if it is a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;.</source>
          <target state="translated">xCreateメソッドは、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントに応答して仮想テーブルの新しいインスタンスを作成するために呼び出されます。xCreateメソッドがxConnectメソッドと同じポインターの場合、仮想テーブルは&lt;a href=&quot;vtab#xconnect&quot;&gt;代名詞の&lt;/a&gt;&lt;a href=&quot;vtab#epovtab&quot;&gt;仮想テーブル&lt;/a&gt;です。xCreateメソッドが省略されている場合（NULLポインターの場合）、仮想テーブルは、&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;同名のみの仮想テーブル&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="7fa820ae673d5a152c6735ecfbe5a6902d1afc09" translate="yes" xml:space="preserve">
          <source>The xCreate method need not initialize the pModule, nRef, and zErrMsg fields of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object. The SQLite core will take care of that chore.</source>
          <target state="translated">xCreateメソッドは、&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;オブジェクトのpModule、nRef、およびzErrMsgフィールドを初期化する必要はありません。SQLiteコアがその面倒を処理します。</target>
        </trans-unit>
        <trans-unit id="06c7e419a8719bf400eb11e6ddbab813f843fcfc" translate="yes" xml:space="preserve">
          <source>The xCreate should return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">xCreateは返す必要があり&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;、それが新しい仮想テーブルの作成に成功した場合、または&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;それが成功しなかった場合。成功しない場合は、&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;構造を割り当てないでください。失敗した場合、オプションでエラーメッセージが* pzErrに返される場合があります。アプリケーションにエラーが報告された後、SQLiteコアは&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を使用してスペースを解放しようとするため、エラーメッセージ文字列を保持するスペースは、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;などのSQLiteメモリ割り当て関数を使用して割り当てる必要があります。</target>
        </trans-unit>
        <trans-unit id="f958ace0be88d27965e6fd7b0b417f1f44eb7a29" translate="yes" xml:space="preserve">
          <source>The xCurrentTime method finds the current time and date and writes the result as a double-precision floating point value into pointer provided by the second parameter. The time and date is in coordinated universal time (UTC) and is a fractional Julian day number.</source>
          <target state="translated">xCurrentTime メソッドは、現在の時刻と日付を検出し、その結果を倍精度浮動小数点値として 2 番目のパラメータで指定されたポインタに書き込みます。時刻と日付は、協定世界時 (UTC)であり、分数のユリウス日番号です。</target>
        </trans-unit>
        <trans-unit id="6df2a95b2c02a08ca9301c1af593f076dcec3de1" translate="yes" xml:space="preserve">
          <source>The xDelete callback, if one is specified, is also invoked on the auxiliary data pointer after the FTS5 query has finished.</source>
          <target state="translated">xDeleteコールバックが指定されている場合は、FTS5の問い合わせが終了した後、補助データポインタに対しても呼び出されます。</target>
        </trans-unit>
        <trans-unit id="684db9583b8006f9c3587ed123a3291e36233a15" translate="yes" xml:space="preserve">
          <source>The xDelete method in the built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now return SQLITE_IOERR_DELETE_NOENT if the file to be deleted does not exist.</source>
          <target state="translated">組み込みVFSのxDeleteメソッドは、削除するファイルが存在しない場合に&lt;a href=&quot;vfs&quot;&gt;SQLITE_IOERR_DELETE_NOENTを&lt;/a&gt;返すようになりました。</target>
        </trans-unit>
        <trans-unit id="8acbdfc184b8627360b75ab194ff6c7691155e56" translate="yes" xml:space="preserve">
          <source>The xDelete method is used to delete a file. The name of the file is given in the second parameter. The filename will be in UTF-8. The VFS must convert the filename into whatever character representation the underlying operating system expects. If the syncDir parameter is true, then the xDelete method should not return until the change to the directory contents for the directory containing the deleted file have been synced to disk in order to ensure that the file does not &quot;reappear&quot; if a power failure occurs soon after.</source>
          <target state="translated">xDeleteメソッドは、ファイルを削除するために使用されます。2 番目のパラメータにファイル名を指定します。ファイル名は UTF-8 になります。VFS は、ファイル名を、基礎となるオペレーティング・システムが期待する文字表現に変換する必要があります。syncDir パラメータが true の場合、xDelete メソッドは、削除されたファイルを含むディレクトリのディレクトリ内容の変更がディスクに同期されるまで返さないようにしてください。</target>
        </trans-unit>
        <trans-unit id="11b2a4e02961f3a81754bcacd1c2618edac811a1" translate="yes" xml:space="preserve">
          <source>The xDestroy callback is &lt;u&gt;not&lt;/u&gt; called if the sqlite3_create_collation_v2() function fails. Applications that invoke sqlite3_create_collation_v2() with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them. This is different from every other SQLite interface. The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）関数が失敗した場合、xDestroyコールバックは呼び出され&lt;u&gt;ませ&lt;/u&gt;ん。NULL以外のxDestroy引数を指定してsqlite3_create_collat​​ion_v2（）を呼び出すアプリケーションは、SQLiteが処理することを期待するのではなく、戻りコードを確認してアプリケーションデータポインター自体を破棄する必要があります。これは、他のすべてのSQLiteインターフェースとは異なります。不整合は残念ですが、下位互換性を壊さずに変更することはできません。</target>
        </trans-unit>
        <trans-unit id="82fcb2416a6d15ad9c7eed2868bb3c1083659be9" translate="yes" xml:space="preserve">
          <source>The xDestroy method is required for every virtual table implementation, though it is acceptable for the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; and xDestroy methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">すべての仮想テーブルの実装にはxDestroyメソッドが必要ですが、特定の仮想テーブルにとって意味がある場合は、xDisconnectメソッドとxDestroyメソッドが同じ関数であっても&lt;a href=&quot;vtab#xdisconnect&quot;&gt;問題&lt;/a&gt;ありません。</target>
        </trans-unit>
        <trans-unit id="433eafbb64ee6df6fcf2cd0863165758dd2318f2" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy（）メソッドは、xCreate（）によって割り当てられたキャッシュを削除するために使用されます。指定したキャッシュに関連付けられているすべてのリソースを解放する必要があります。xDestroy（）メソッドを呼び出した後、SQLiteは&lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt;ハンドルを無効と見なし、それを他のsqlite3_pcache_methods2関数で使用しません。</target>
        </trans-unit>
        <trans-unit id="8baf35611bcad0c5db55f35fee163e2aa0c149e9" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy（）メソッドは、xCreate（）によって割り当てられたキャッシュを削除するために使用されます。指定したキャッシュに関連付けられているすべてのリソースを解放する必要があります。xDestroy（）メソッドを呼び出した後、SQLiteは&lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt;ハンドルを無効と見なし、それを他のsqlite3_pcache_methods2関数で使用しません。</target>
        </trans-unit>
        <trans-unit id="604385447aab898766cb3896d8016d04ab97fc0d" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">xDeviceCharacteristics方法&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methodsは&lt;/a&gt;リターンにそのファイルを保持する大容量記憶装置のI / O特性を発現するこれらのビット値のベクトルであり、整数オブジェクト&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methodsを&lt;/a&gt;指すを。</target>
        </trans-unit>
        <trans-unit id="b98ec973b9735d7dd446dd0f56fe3b7eb0a27d7c" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">xDeviceCharacteristics方法&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methodsは&lt;/a&gt;リターンにそのファイルを保持する大容量記憶装置のI / O特性を発現するこれらのビット値のベクトルであり、整数オブジェクト&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methodsを&lt;/a&gt;指すを。</target>
        </trans-unit>
        <trans-unit id="c2e8466b1e208836960d6bb4f90ed3ea7832fd67" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method returns an integer bit vector that defines any special properties that the underlying storage medium might have that SQLite can use to increase performance. The allowed return is the bit-wise OR of the following values:</source>
          <target state="translated">xDeviceCharacteristics メソッドは、SQLite がパフォーマンスを向上させるために使用することができる、基礎となるストレージメディアが持つかもしれない特別なプロパティを定義した整数ビットベクタを返します。返される値は、以下の値のビット単位の OR です。</target>
        </trans-unit>
        <trans-unit id="1262b3501d52f25dbe2da92b37772cb17c293d40" translate="yes" xml:space="preserve">
          <source>The xDisconnect method is required for every virtual table implementation, though it is acceptable for the xDisconnect and &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">すべての仮想テーブルの実装にはxDisconnectメソッドが必要ですが、特定の仮想テーブルに意味がある場合は、&lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDisconnect&lt;/a&gt;メソッドとxDestroyメソッドが同じ関数であっても問題ありません。</target>
        </trans-unit>
        <trans-unit id="80202d349ad4d59a55548ad8afd689feeefba61b" translate="yes" xml:space="preserve">
          <source>The xDlOpen, xDlError, xDlSym, and xDlClose methods are all used for accessing shared libraries at run-time. These methods may be omitted (and their pointers set to zero) if the library is compiled with &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; or if the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface is never used to enable dynamic extension loading. The xDlOpen method opens a shared library or DLL and returns a pointer to a handle. NULL is returned if the open fails. If the open fails, the xDlError method can be used to obtain a text error message. The message is written into the zErrMsg buffer of the third parameter which is at least nByte bytes in length. The xDlSym returns a pointer to a symbol in the shared library. The name of the symbol is given by the second parameter. UTF-8 encoding is assumed. If the symbol is not found a NULL pointer is returned. The xDlClose routine closes the shared library.</source>
          <target state="translated">xDlOpen、xDlError、xDlSym、およびxDlCloseメソッドはすべて、実行時に共有ライブラリにアクセスするために使用されます。ライブラリが&lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt;でコンパイルされている場合、または&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;が使用されている場合、これらのメソッドは省略できます（およびそのポインタはゼロに設定されます）。動的拡張ロードを有効にするためにインターフェースが使用されることはありません。 xDlOpenメソッドは、共有ライブラリまたはDLLを開き、ハンドルへのポインターを返します。オープンが失敗した場合は、NULLが返されます。オープンが失敗した場合、xDlErrorメソッドを使用してテキストエラーメッセージを取得できます。メッセージは、長さが少なくともnByteバイトである3番目のパラメーターのzErrMsgバッファーに書き込まれます。 xDlSymは、共有ライブラリ内のシンボルへのポインタを返します。シンボルの名前は2番目のパラメーターで指定されます。 UTF-8エンコーディングが想定されています。シンボルが見つからない場合は、NULLポインターが返されます。 xDlCloseルーチンは、共有ライブラリを閉じます。</target>
        </trans-unit>
        <trans-unit id="2a328c23f376e27049c3463e790fd30ea24be07c" translate="yes" xml:space="preserve">
          <source>The xEof method is required for every virtual table implementation.</source>
          <target state="translated">xEofメソッドは、すべての仮想テーブルの実装に必要です。</target>
        </trans-unit>
        <trans-unit id="2f524de9f6418ba3f20971cbbb6e678439f267fb" translate="yes" xml:space="preserve">
          <source>The xEof method must return false (zero) if the specified cursor currently points to a valid row of data, or true (non-zero) otherwise. This method is called by the SQL engine immediately after each &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; and &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; invocation.</source>
          <target state="translated">xEofメソッドは、指定されたカーソルが現在有効なデータ行を指している場合はfalse（ゼロ）を返し、そうでない場合はtrue（ゼロ以外）を返す必要があります。このメソッドは、各&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;および&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;呼び出しの直後にSQLエンジンによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="31055a962a7bb13c9dfa534ee5cb14dc7402ab08" translate="yes" xml:space="preserve">
          <source>The xFetch() method locates a page in the cache and returns a pointer to an sqlite3_pcache_page object associated with that page, or a NULL pointer. The pBuf element of the returned sqlite3_pcache_page object will be a pointer to a buffer of szPage bytes used to store the content of a single database page. The pExtra element of sqlite3_pcache_page will be a pointer to the szExtra bytes of extra storage that SQLite has requested for each entry in the page cache.</source>
          <target state="translated">xFetch()メソッドはキャッシュ内のページを探し、そのページに関連付けられたsqlite3_pcache_pageオブジェクトへのポインタ、もしくはNULLポインタを返します。返されたsqlite3_pcache_pageオブジェクトのpBuf要素は、単一のデータベースページの内容を格納するために使用されるszPageバイトのバッファへのポインタになります。sqlite3_pcache_pageのpExtra要素は、ページキャッシュの各エントリに対してSQLiteが要求した追加ストレージのszExtraバイトへのポインタになります。</target>
        </trans-unit>
        <trans-unit id="eec30896c07568e6756a1fd11de9a9be38006b51" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the (new and experimental) &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer which is intended to be a pointer to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves opcodes less than 100 for its own use. A &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts.</source>
          <target state="translated">xFileControl（）メソッドは、カスタムVFS実装が（新しい実験的な）&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェースを使用して開いているファイルを直接制御できるようにする汎用インターフェースです。 2番目の「op」引数は整数のopcodeです。 3番目の引数は、戻り値を書き込むための引数またはスペースを含む可能性のある構造体へのポインターになることを目的とした汎用ポインターです。 xFileControl（）の潜在的な用途は、タイムアウト付きのロックのブロックを有効にする、ロック戦略を変更する（たとえば、ドットファイルロックを使用する）、ロックのステータスについて問い合わせる、または古いロックを解除する関数などです。 SQLiteコアは、独自に使用するために100未満のオペコードを予約しています。&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;オペコード&lt;/a&gt;のリスト100未満が使用可能です。カスタムxFileControlメソッドを定義するアプリケーションは、競合を回避するために、100より大きいオペコードを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="dddf7acfafd6d3f8269f8f981d3bcbe57970b96a" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl（）メソッドは、カスタムVFS実装が&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェースを使用して開いているファイルを直接制御できるようにする汎用インターフェースです。2番目の「op」引数は整数のopcodeです。3番目の引数は、戻り値を書き込むための引数またはスペースを含む可能性のある構造を指すことを目的とした汎用ポインターです。xFileControl（）の潜在的な用途は、タイムアウト付きのロックのブロックを有効にする、ロック戦略を変更する（たとえば、ドットファイルロックを使用する）、ロックのステータスについて問い合わせる、または古いロックを解除する関数などです。SQLiteコアは、100未満のすべてのオペコードを独自に使用するために予約しています。&lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;オペコード&lt;/a&gt;のリスト100未満が使用可能です。カスタムxFileControlメソッドを定義するアプリケーションは、競合を回避するために、100より大きいオペコードを使用する必要があります。 VFS実装は、認識しないファイル制御オペコードに対して&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="0cff0bc514819c033ff2d05910e11b13ceab5fce" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl（）メソッドは、カスタムVFS実装が&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェースを使用して開いているファイルを直接制御できるようにする汎用インターフェースです。2番目の「op」引数は整数のopcodeです。3番目の引数は、戻り値を書き込むための引数またはスペースを含む可能性のある構造を指すことを目的とした汎用ポインターです。xFileControl（）の潜在的な用途は、タイムアウト付きのロックのブロックを有効にする、ロック戦略を変更する（たとえば、ドットファイルロックを使用する）、ロックのステータスについて問い合わせる、または古いロックを解除する関数などです。SQLiteコアは、100未満のすべてのオペコードを独自に使用するために予約しています。&lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;オペコード&lt;/a&gt;のリスト100未満が使用可能です。カスタムxFileControlメソッドを定義するアプリケーションは、競合を回避するために、100より大きいオペコードを使用する必要があります。 VFS実装は、認識しないファイル制御オペコードに対して&lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="3203c926180842d31c782d904c037633ddf2f91f" translate="yes" xml:space="preserve">
          <source>The xFileSize() method determines the current size of the file in bytes and writes that value into *pSize. It returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt; if something goes wrong.</source>
          <target state="translated">xFileSize（）メソッドは、ファイルの現在のサイズをバイト単位で決定し、その値を* pSizeに書き込みます。成功した場合は&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返し、問題が&lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;発生した&lt;/a&gt;場合はSQLITE_IOERR_FSTATを返します。</target>
        </trans-unit>
        <trans-unit id="96653ab4bb654a8e871b1a8c14aa48716aadb8ae" translate="yes" xml:space="preserve">
          <source>The xFilter method is required for every virtual table implementation.</source>
          <target state="translated">xFilter メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="4479f4bd625e3440b28fa60e755d9671817cfbcf" translate="yes" xml:space="preserve">
          <source>The xFullPathname method is used to convert a relative pathname into a full pathname. The resulting full pathname is written into the buffer provided by the third parameter. SQLite will size the output buffer to at least mxPathname bytes. Both the input and output names should be in UTF-8.</source>
          <target state="translated">xFullPathname メソッドは、相対パス名をフルパス名に変換するために使用されます。結果として得られたフルパス名は、三番目のパラメータで指定したバッファに書き込まれます。SQLite は出力バッファを少なくとも mxPathname バイトのサイズにします。入力名と出力名は両方とも UTF-8 でなければなりません。</target>
        </trans-unit>
        <trans-unit id="5dbd41bd881211c13a1dbbcb8c736851e1bf5d97" translate="yes" xml:space="preserve">
          <source>The xGeom callback always does a depth-first search of the r-tree.</source>
          <target state="translated">xGeomコールバックは、常にr-treeの深さ優先検索を行います。</target>
        </trans-unit>
        <trans-unit id="454e11b15802805175a3b539debe13d361beb72d" translate="yes" xml:space="preserve">
          <source>The xGetTempName method computes the name of a temporary file that SQLite can use. The name should be written into the buffer given by the second parameter. SQLite will size that buffer to hold at least mxPathname bytes. The generated filename should be in UTF-8. To avoid security problems, the generated temporary filename should contain enough randomness to prevent an attacker from guessing the temporary filename in advance.</source>
          <target state="translated">xGetTempName メソッドは、SQLite が使用できる一時ファイルの名前を計算します。この名前は、2 番目のパラメータで指定されたバッファに書き込まれなければなりません。SQLite はこのバッファのサイズを、少なくとも mxPathname バイトを保持するようにします。生成されるファイル名はUTF-8でなければなりません。セキュリティ上の問題を避けるために、生成される一時ファイル名には、攻撃者が一時ファイル名を事前に推測できないように、十分なランダム性が含まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="5d25f32f0f944f020730e420a59b761837d6fa20" translate="yes" xml:space="preserve">
          <source>The xGetTempname method has been removed from &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. In its place, the xOpen method is enhanced to open a temporary file of its own invention when the filename parameter is NULL.</source>
          <target state="translated">xGetTempnameメソッドはsqlite3_vfsから削除され&lt;a href=&quot;c3ref/vfs&quot;&gt;ました&lt;/a&gt;。その代わりに、xOpenメソッドは、filenameパラメータがNULLの場合に独自の発明の一時ファイルを開くように拡張されています。</target>
        </trans-unit>
        <trans-unit id="e9de98bc73bd358a33146535bc6a4c0838edf0ac" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInitメソッドは、メモリアロケータを初期化します。たとえば、必要なミューテックスを割り当てたり、内部データ構造を初期化したりできます。 xShutdownメソッドは&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によって（間接的に）呼び出され、xInitによって取得されたすべてのリソースの割り当てを解除する必要があります。 pAppDataポインターは、xInitおよびxShutdownへの唯一のパラメーターとして使用されます。</target>
        </trans-unit>
        <trans-unit id="3fa9fa67f04b6378191cf480be2d31d4ea4b3e4c" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInitメソッドは、メモリアロケータを初期化します。たとえば、必要なミューテックスを割り当てたり、内部データ構造を初期化したりできます。 xShutdownメソッドは&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によって（間接的に）呼び出され、xInitによって取得されたすべてのリソースの割り当てを解除する必要があります。 pAppDataポインターは、xInitおよびxShutdownへの唯一のパラメーターとして使用されます。</target>
        </trans-unit>
        <trans-unit id="928f04710edbd4aadd8a60154ed8a2e307eed0ef" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">xInit（）メソッドは、&lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize（）&lt;/a&gt;への有効な呼び出しごとに1回呼び出されます（通常、プロセスの存続期間中に1回だけ）。 xInit（）メソッドには、sqlite3_pcache_methods2.pArg値のコピーが渡されます。 xInit（）メソッドの目的は、カスタムページキャッシュの実装に必要なグローバルデータ構造をセットアップすることです。 xInit（）メソッドがNULLの場合、アプリケーションで定義されたページキャッシュの代わりに、組み込みのデフォルトページキャッシュが使用されます。</target>
        </trans-unit>
        <trans-unit id="6ba32c8d759124102ccc057ecbe6a0c1c85fb3b5" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">xInit（）メソッドは、&lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize（）&lt;/a&gt;への有効な呼び出しごとに1回呼び出されます（通常、プロセスの存続期間中に1回だけ）。 xInit（）メソッドには、sqlite3_pcache_methods2.pArg値のコピーが渡されます。 xInit（）メソッドの目的は、カスタムページキャッシュの実装に必要なグローバルデータ構造をセットアップすることです。 xInit（）メソッドがNULLの場合、アプリケーションで定義されたページキャッシュの代わりに、組み込みのデフォルトページキャッシュが使用されます。</target>
        </trans-unit>
        <trans-unit id="8a32ff6fcc7d9e120e222fe6ef8bbf8b9661df8a" translate="yes" xml:space="preserve">
          <source>The xLock and xUnlock methods are used to set and clear file locks. SQLite supports five levels of file locks, in order:</source>
          <target state="translated">xLock および xUnlock メソッドを使用して、ファイルロックを設定したりクリアしたりします。SQLite はファイルロックのレベルを順に 5 段階でサポートしています。</target>
        </trans-unit>
        <trans-unit id="8a5c74b276f4ba001214e303873304b1cefc6f0e" translate="yes" xml:space="preserve">
          <source>The xMalloc, xRealloc, and xFree methods must work like the malloc(), realloc() and free() functions from the standard C library. SQLite guarantees that the second argument to xRealloc is always a value returned by a prior call to xRoundup.</source>
          <target state="translated">xMalloc、xRealloc、および xFree メソッドは、標準 C ライブラリの malloc()、realloc()、および free()関数と同じように動作しなければなりません。SQLite は、xRealloc の第二引数は常に xRoundup の前の呼び出しで返された値であることを保証しています。</target>
        </trans-unit>
        <trans-unit id="f3c67d901eafc4b8170f137f64b1ed5325131c31" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">この構造によって定義されたxMutexEndメソッドは、sqlite3_shutdown（）関数によってシステムシャットダウンの一部として呼び出されます。このメソッドの実装は、mutexメソッドの実装によって取得されたすべての未解決のリソース、特にxMutexInitメソッドによって取得されたリソースを解放すると予想されます。xMutexEnd（）インターフェースは、&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）を&lt;/a&gt;呼び出すたびに1回だけ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="29460abd69ce976afdb57bd86f856a912e6b2129" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">この構造によって定義されたxMutexEndメソッドは、sqlite3_shutdown（）関数によってシステムシャットダウンの一部として呼び出されます。このメソッドの実装は、mutexメソッドの実装によって取得されたすべての未解決のリソース、特にxMutexInitメソッドによって取得されたリソースを解放すると予想されます。xMutexEnd（）インターフェースは、&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）を&lt;/a&gt;呼び出すたびに1回だけ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cd4f06c8938e3564cfbf224eac3d8cf5b5b06a0d" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">この構造によって定義されたxMutexInitメソッドは、sqlite3_initialize（）関数によるシステム初期化の一部として呼び出されます。xMutexInitルーチンは、&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;への有効な呼び出しごとに1回だけSQLiteによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="dab4cb79a586f29424445d440e5fffbfe8ba4495" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">この構造によって定義されたxMutexInitメソッドは、sqlite3_initialize（）関数によるシステム初期化の一部として呼び出されます。xMutexInitルーチンは、&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;への有効な呼び出しごとに1回だけSQLiteによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="89ac720acef7b2cd1f40cadc5a9b4008a6051773" translate="yes" xml:space="preserve">
          <source>The xMutexInit() method must be threadsafe. It must be harmless to invoke xMutexInit() multiple times within the same process and without intervening calls to xMutexEnd(). Second and subsequent calls to xMutexInit() must be no-ops.</source>
          <target state="translated">xMutexInit()メソッドはスレッドセーフでなければなりません。同一プロセス内で xMutexEnd()への呼び出しを介さずに xMutexInit()を複数回呼び出すことは無害でなければなりません。2 回目以降の xMutexInit()の呼び出しは、何もしないようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="35cc67c51c972e7defc85a2cd19b646cf64aa418" translate="yes" xml:space="preserve">
          <source>The xNext method advances a &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; to the next row of a result set initiated by &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;. If the cursor is already pointing at the last row when this routine is called, then the cursor no longer points to valid data and a subsequent call to the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; method must return true (non-zero). If the cursor is successfully advanced to another row of content, then subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero).</source>
          <target state="translated">xNextメソッドは、&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;仮想テーブルカーソル&lt;/a&gt;を&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;によって開始された結果セットの次の行に進めます。このルーチンが呼び出されたときにカーソルがすでに最後の行を指している場合、カーソルは有効なデータを指していません。その後の&lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;メソッドの呼び出しはtrue（ゼロ以外）を返す必要があります。カーソルがコンテンツの別の行に正常に進んだ場合、その後の&lt;a href=&quot;vtab#xeof&quot;&gt;xEofの&lt;/a&gt;呼び出しはfalse（ゼロ）を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="c07bbf2e5005e8108d2f1c166d0b989d5b0ef5de" translate="yes" xml:space="preserve">
          <source>The xNext method is required for every virtual table implementation.</source>
          <target state="translated">xNext メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="eee0d952c4251db31a384eceabf2a26d2118eb4d" translate="yes" xml:space="preserve">
          <source>The xOpen method creates a new cursor used for accessing (read and/or writing) a virtual table. A successful invocation of this method will allocate the memory for the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (or a subclass), initialize the new object, and make *ppCursor point to the new object. The successful call then returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">xOpenメソッドは、仮想テーブルへのアクセス（読み取りおよび/または書き込み）に使用される新しいカーソルを作成します。このメソッドの呼び出しが成功すると、&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;（またはサブクラス）にメモリが割り当てられ、新しいオブジェクトが初期化され、* ppCursorが新しいオブジェクトを指すようになります。成功した呼び出しは&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="00b35252e3240b77ad5fc35ac862013d23c8ea89" translate="yes" xml:space="preserve">
          <source>The xOpen method is required for every virtual table implementation.</source>
          <target state="translated">xOpen メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="fe219d8e760e2d5872424a8a4fa6980f7d9bd820" translate="yes" xml:space="preserve">
          <source>The xOpen method need not initialize the pVtab field of the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure. The SQLite core will take care of that chore automatically.</source>
          <target state="translated">xOpenメソッドは、&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;構造体のpVtabフィールドを初期化する必要はありません。SQLiteコアはその雑用を自動的に処理します。</target>
        </trans-unit>
        <trans-unit id="5883a2e08ea426f3d0e98ebbcc84b207e43eeb5d" translate="yes" xml:space="preserve">
          <source>The xOutput callback is invoked zero or more times to return data to the application. The first parameter passed to each call is a copy of the pOut pointer supplied by the application. The second parameter, pData, points to a buffer nData bytes in size containing the chunk of output data being returned. If the xOutput callback successfully processes the supplied data, it should return SQLITE_OK to indicate success. Otherwise, it should return some other SQLite error code. In this case processing is immediately abandoned and the streaming API function returns a copy of the xOutput error code to the application.</source>
          <target state="translated">xOutput コールバックは、アプリケーションにデータを返すために 0 回以上呼び出されます。各コールに渡される最初のパラメータは、アプリケーションから供給された pOut ポインタのコピーです。2 番目のパラメータ pData は、返される出力データのチャンクを含むサイズのバッファ nData バイトを指します。xOutput コールバックが供給されたデータの処理に成功した場合、成功を示す SQLITE_OK を返します。それ以外の場合は、他の SQLite エラーコードを返します。この場合、処理は直ちに中止され、ストリーミング API 関数は xOutput エラー コードのコピーをアプリケーションに返します。</target>
        </trans-unit>
        <trans-unit id="4fdec734fe0825d4b45223206e7ef21a40dca7d6" translate="yes" xml:space="preserve">
          <source>The xPagecount() method must return the number of pages currently stored in the cache, both pinned and unpinned.</source>
          <target state="translated">xPagecount()メソッドは、現在キャッシュに保存されているページ数を返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="f7670800549df532ce782308a5027526fc2bbf4f" translate="yes" xml:space="preserve">
          <source>The xQueryFunc must set the eWithin field of sqlite3_rtree_query_info to one of the values NOT_WITHIN, PARTLY_WITHIN, or FULLY_WITHIN depending on whether or not the bounding box defined by aCoord[] is completely outside the region, overlaps the region, or is completely inside the region, respectively. In addition, the xQueryFunc must set the rScore field to a non-negative value that indicates the order in which subtrees and entries of the query should be analyzed and returned. Smaller scores are processed first.</source>
          <target state="translated">xQueryFuncは、sqlite3_rtree_query_infoのeWithinフィールドを、aCoord[]で定義されたバウンディングボックスが完全に領域の外にあるか、領域に重なっているか、完全に領域の内側にあるかに応じて、それぞれNOT_WITHIN、PARTLY_WITHIN、FULLY_WITHINのいずれかの値に設定しなければならない。さらに、xQueryFuncは、rScoreフィールドに、クエリのサブツリーとエントリが解析されて返されるべき順序を示す非負の値を設定しなければならない。スコアが小さいものが最初に処理されます。</target>
        </trans-unit>
        <trans-unit id="243e65d787818469363333eb640b0b44f38c6ec4" translate="yes" xml:space="preserve">
          <source>The xRandomness method is used exactly once to initialize the pseudo-random number generator (PRNG) inside of SQLite. Only the xRandomness method on the default VFS is used. The xRandomness methods on other VFSes are never accessed by SQLite. The xRandomness routine requests that nByte bytes of randomness be written into zOut. The routine returns the actual number of bytes of randomness obtained. The quality of the randomness so obtained will determine the quality of the randomness generated by built-in SQLite functions such as random() and randomblob(). SQLite also uses its PRNG to generate temporary file names. On some platforms (ex: Windows) SQLite assumes that temporary file names are unique without actually testing for collisions, so it is important to have good-quality randomness even if the random() and randomblob() functions are never used.</source>
          <target state="translated">xRandomnessメソッドは、SQLite内部の疑似乱数発生器(PRNG)を初期化するために一度だけ使用します。デフォルトの VFS 上の xRandomness メソッドのみが使用されます。他の VFS 上の xRandomness メソッドは、SQLite からアクセスされることはありません。xRandomness ルーチンは、ランダムネスの nByte バイトを zOut に書き込むように要求します。ルーチンは、得られたランダム性の実際のバイト数を返します。得られたランダム性の質は、random()や randlob()などの SQLite の組み込み関数によって生成されたランダム性の質を決定します。SQLite は PRNG を使用して一時的なファイル名を生成します。プラットフォームによっては(Windows など)、SQLite は衝突を実際にテストせずに一時ファイル名が一意であることを前提としているので、たとえ random()や randlob()関数が使用されなかったとしても、質の良いランダム性を持つことが重要です。</target>
        </trans-unit>
        <trans-unit id="2203fe5d9da94fc2d593e73757d6951b646a5aac" translate="yes" xml:space="preserve">
          <source>The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64() interfaces are not strictly a part of the filesystem, but they are included in the VFS structure for completeness. The xRandomness() function attempts to return nBytes bytes of good-quality randomness into zOut. The return value is the actual number of bytes of randomness obtained. The xSleep() method causes the calling thread to sleep for at least the number of microseconds given. The xCurrentTime() method returns a Julian Day Number for the current date and time as a floating point value. The xCurrentTimeInt64() method returns, as an integer, the Julian Day Number multiplied by 86400000 (the number of milliseconds in a 24-hour day). SQLite will use the xCurrentTimeInt64() method to get the current date and time if that method is available (if iVersion is 2 or greater and the function pointer is not NULL) and will fall back to xCurrentTime() if xCurrentTimeInt64() is unavailable.</source>
          <target state="translated">xRandomness()、xSleep()、xCurrentTime()、およびxCurrentTimeInt64()インターフェイスは、厳密にはファイルシステムの一部ではありませんが、完全性を確保するために VFS 構造体に含まれています。xRandomness()関数は、品質の良いランダム性の nBytes バイトを zOut に戻そうとします。返される値は、得られたランダム性の実際のバイト数です。xSleep()メソッドは、少なくとも指定されたマイクロ秒数だけスレッドをスリープさせます。xCurrentTime()メソッドは、現在の日付と時刻のユリウス日番号を浮動小数点値として返します。xCurrentTimeInt64()メソッドは、整数として、ジュリアン日番号に 86400000 (24 時間の 1 日のミリ秒数)を掛けたものを返します。SQLite は、xCurrentTimeInt64()メソッドが使用可能な場合 (iVersion が 2 以上で関数ポインタが NULL でない場合)には xCurrentTimeInt64()メソッドを使用して現在の日付と時刻を取得し、xCurrentTimeInt64()が使用できない場合は xCurrentTime()にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="9578c347ea12c88b2a68bb1b8891cc899dd6f688" translate="yes" xml:space="preserve">
          <source>The xRead method reads iAmt bytes from the file beginning at a byte offset to iOfst. The data read is stored in the pointer of the second parameter. xRead returns the &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt; if it was not able to read the full number of bytes because it reached end-of-file, or &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; for any other error.</source>
          <target state="translated">xReadメソッドは、iOfstへのバイトオフセットで始まるファイルからiAmtバイトを読み取ります。読み込まれたデータは、2番目のパラメーターのポインターに格納されます。 XREADを返し&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;、成功した場合には&lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt;、それはファイルの終わりに達した、またはので、バイトの完全な数を読み取ることができなかった場合&lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt;その他のエラーのために。</target>
        </trans-unit>
        <trans-unit id="179305437ddf972de11f25d6c031548629b7dbeb" translate="yes" xml:space="preserve">
          <source>The xRekey() method is used to change the key value associated with the page passed as the second argument. If the cache previously contains an entry associated with newKey, it must be discarded. Any prior cache entry associated with newKey is guaranteed not to be pinned.</source>
          <target state="translated">xRekey()メソッドは、第二引数として渡されたページに関連付けられたキー値を変更するために使用されます。キャッシュに newKey に関連付けられたエントリが以前に含まれていた場合は、それを破棄しなければなりません。newKey に関連付けられた以前のキャッシュエントリは、固定されないことが保証されています。</target>
        </trans-unit>
        <trans-unit id="ee97077a16637439ff4f073f89fa74d3ae66efba" translate="yes" xml:space="preserve">
          <source>The xRename method is optional. If omitted, then the virtual table may not be renamed using the ALTER TABLE RENAME command.</source>
          <target state="translated">xRename メソッドはオプションです。省略した場合は、ALTER TABLE RENAME コマンドを使用して仮想テーブルの名前を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="ac1529fc1db9096e5e7532c56994cf7e11a7e7d4" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundupメソッドは、特定の要求されたサイズが与えられた場合のメモリ割り当ての割り当てサイズを返します。ほとんどのメモリアロケータは、少なくとも8の次の倍数にメモリ割り当てを切り上げます。一部のアロケータは、より大きい倍数または2の&lt;a href=&quot;#sqlite3_free&quot;&gt;累乗に切り上げます。sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）を&lt;/a&gt;介して着信するすべてのメモリ割り当て要求は、最初にxRoundupを呼び出します。xRoundupが0を返す場合、対応するメモリ割り当てが失敗します。</target>
        </trans-unit>
        <trans-unit id="5558ee9f292501795b089dc2d3175bf349258bae" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundupメソッドは、特定の要求されたサイズが与えられた場合のメモリ割り当ての割り当てサイズを返します。ほとんどのメモリアロケータは、少なくとも8の次の倍数にメモリ割り当てを切り上げます。一部のアロケータは、より大きい倍数または2の&lt;a href=&quot;free&quot;&gt;累乗に切り上げます。sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）を&lt;/a&gt;介して着信するすべてのメモリ割り当て要求は、最初にxRoundupを呼び出します。xRoundupが0を返す場合、対応するメモリ割り当てが失敗します。</target>
        </trans-unit>
        <trans-unit id="ac776ca96c027496fe8cb024585d72e01e0bde03" translate="yes" xml:space="preserve">
          <source>The xRowid method is required for every virtual table implementation.</source>
          <target state="translated">xRowid メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="f91951a49d3cd2a19053a4c5034726651d8bcc0a" translate="yes" xml:space="preserve">
          <source>The xSectorSize returns the &quot;sector size&quot; of the underlying non-volatile media. A &quot;sector&quot; is defined as the smallest unit of storage that can be written without disturbing adjacent storage. On a disk drive the &quot;sector size&quot; has until recently been 512 bytes, though there is a push to increase this value to 4KiB. SQLite needs to know the sector size so that it can write a full sector at a time, and thus avoid corrupting adjacent storage space if a power loss occurs in the middle of a write.</source>
          <target state="translated">xSectorSize は、基礎となる不揮発性メディアの「セクタサイズ」を返します。セクタ」とは、隣接するストレージに影響を与えずに書き込めるストレージの最小単位と定義されています。ディスクドライブの「セクタサイズ」は最近まで512バイトでしたが、現在ではこの値を4KiBに引き上げる動きがあります。SQLite は、一度に完全なセクタを書き込めるようにセクタサイズを知る必要があり、書き込みの途中で停電が発生しても隣接するストレージスペースが破損しないようにします。</target>
        </trans-unit>
        <trans-unit id="7905596593f9a3650933e2dff7d4278590e16d18" translate="yes" xml:space="preserve">
          <source>The xSectorSize() method returns the sector size of the device that underlies the file. The sector size is the minimum write that can be performed without disturbing other bytes in the file. The xDeviceCharacteristics() method returns a bit vector describing behaviors of the underlying device:</source>
          <target state="translated">xSectorSize()メソッドは、ファイルの下敷きになっているデバイスのセクタサイズを返します。セクタサイズは、ファイル内の他のバイトに影響を与えることなく実行できる最小の書き込みサイズです。xDeviceCharacteristics()メソッドは、基礎となるデバイスの動作を記述したビットベクトルを返します。</target>
        </trans-unit>
        <trans-unit id="c28ec934424705226c30dba3dc7fb3bbb1c98c66" translate="yes" xml:space="preserve">
          <source>The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces are not used by the SQLite core. These optional interfaces are provided by some VFSes to facilitate testing of the VFS code. By overriding system calls with functions under its control, a test program can simulate faults and error conditions that would otherwise be difficult or impossible to induce. The set of system calls that can be overridden varies from one VFS to another, and from one version of the same VFS to the next. Applications that use these interfaces must be prepared for any or all of these interfaces to be NULL or for their behavior to change from one release to the next. Applications must not attempt to access any of these methods if the iVersion of the VFS is less than 3.</source>
          <target state="translated">xSetSystemCall()、xGetSystemCall()、および xNestSystemCall()インターフェイスは、SQLite コアでは使用されません。これらのオプションのインターフェイスは、VFS コードのテストを容易にするために、いくつかの VFS によって提供されています。制御下の関数でシステムコールをオーバーライドすることで、テストプログラムは、そうでなければ誘発することが困難であったり、不可能であったりする障害やエラー状態をシミュレートすることができます。オーバーライドできるシステムコールのセットは、VFS によって異なりますし、同じ VFS のバージョンによっても異なります。これらのインターフェイスを使用するアプリケーションは、これらのインターフェイスの一部または全部が NULL になったり、あるリリースから次のリリースへと動作が変更されたりすることに備えなければなりません。アプリケーションは、VFS の iVersion が 3 未満の場合、これらのメソッドへのアクセスを試みてはなりません。</target>
        </trans-unit>
        <trans-unit id="5423cabb179d0301d2f1838406af9e345543b685" translate="yes" xml:space="preserve">
          <source>The xShadowName method exists to allow SQLite to determine whether a certain real table is in fact a shadow table for a virtual table.</source>
          <target state="translated">xShadowName メソッドは、SQLite がある実在のテーブルが実際に仮想テーブルのシャドウテーブルであるかどうかを判断できるようにするために存在します。</target>
        </trans-unit>
        <trans-unit id="947c2bf35d5cbfd4ce5579dacd8c602d7123b2d2" translate="yes" xml:space="preserve">
          <source>The xShadowName method returns true when its input is the part of the table name past the last &quot;_&quot; character.</source>
          <target state="translated">xShadowNameメソッドは、その入力がテーブル名の最後の&quot;_&quot;文字以降の部分である場合に真を返します。</target>
        </trans-unit>
        <trans-unit id="bb9ed2671c0267a52c772896119a40dfbdf41d3e" translate="yes" xml:space="preserve">
          <source>The xShmLock method can transition between unlocked and SHARED or between unlocked and EXCLUSIVE. It cannot transition between SHARED and EXCLUSIVE.</source>
          <target state="translated">xShmLockメソッドは、unlockedとSHAREDの間、またはunlockedとEXCLUSIVEの間で遷移することができます。SHAREDとEXCLUSIVEの間で遷移することはできません。</target>
        </trans-unit>
        <trans-unit id="3b138a7b2ca75c6da01e38d919aae9bc4beaeeca" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">上xShmLock方法&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methodsは&lt;/a&gt; 0の間の値を使用することができ、これは、上部の「オフセット」引数としてバインド。SQLiteコアは、この範囲外のロックを取得または解放しようとはしません</target>
        </trans-unit>
        <trans-unit id="99e14d7c5dc9f436dda83c4868de4dcfa29aa8e2" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">上xShmLock方法&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methodsは&lt;/a&gt; 0の間の値を使用することができ、これは、上部の「オフセット」引数としてバインド。SQLiteコアは、この範囲外のロックを取得または解放しようとはしません</target>
        </trans-unit>
        <trans-unit id="c9d6171767cbe080777a834fc404f8313c3bd7a0" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown（）メソッドは&lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によって呼び出されます。必要に応じて、プロセスのシャットダウン前に未処理のリソースをクリーンアップするために使用できます。xShutdown（）メソッドはNULLである可能性があります。</target>
        </trans-unit>
        <trans-unit id="89b517d093efdb5642222dcbac94dd78a355996a" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown（）メソッドは&lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によって呼び出されます。必要に応じて、プロセスのシャットダウン前に未処理のリソースをクリーンアップするために使用できます。xShutdown（）メソッドはNULLである可能性があります。</target>
        </trans-unit>
        <trans-unit id="809b6a168241db65edee19e686edd4e9bd3b2bfa" translate="yes" xml:space="preserve">
          <source>The xSleep method is used to suspend the calling thread for at least the number of microseconds given. This method is used to implement the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; APIs. In the case of &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; the xSleep method of the default VFS is always used. If the underlying system does not have a microsecond resolution sleep capability, then the sleep time should be rounded up. xSleep returns this rounded-up value.</source>
          <target state="translated">xSleepメソッドは、少なくとも指定されたマイクロ秒数の間、呼び出しスレッドを一時停止するために使用されます。このメソッドは、&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;および&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt; API を実装するために使用されます。&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）の&lt;/a&gt;場合、デフォルトのVFSのxSleepメソッドが常に使用されます。基盤となるシステムにマイクロ秒の解像度のスリープ機能がない場合は、スリープ時間を切り上げる必要があります。xSleepは、この切り上げられた値を返します。</target>
        </trans-unit>
        <trans-unit id="097b3f659c15f2c222834063189d1813c9097500" translate="yes" xml:space="preserve">
          <source>The xSync method is called again, to ensure that the update to the</source>
          <target state="translated">への更新が確実に行われるように、xSyncメソッドが再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c43866c10fb70246bff455fcc260272ec7695054" translate="yes" xml:space="preserve">
          <source>The xSync method is used to force previously written data out of operating system cache and into non-volatile memory. The second parameter is usually &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;. If the second parameter is &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; then the xSync method should make sure that data has also been flushed through the disk controllers cache. The &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; parameter is the equivalent of the F_FULLSYNC ioctl() on Mac OS X. The xSync method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xSyncメソッドは、以前に書き込まれたデータをオペレーティングシステムキャッシュから不揮発性メモリに強制的に書き込むために使用されます。通常、2番目のパラメーターは&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;です。 2番目のパラメーターが&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULLの&lt;/a&gt;場合、xSyncメソッドは、ディスクコントローラーキャッシュを介してデータもフラッシュされていることを確認する必要があります。&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULLの&lt;/a&gt;パラメータは、Mac OS X.ザ・XSYNC法に）F_FULLSYNCのioctl（と同等である返し&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;成功と上&lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt;何かがうまくいかない場合。</target>
        </trans-unit>
        <trans-unit id="d363e92ec2dbc091f6f79c8b02f677c3bfbb4dc4" translate="yes" xml:space="preserve">
          <source>The xSync method of the file-handle opened on the journal file is called. This operation ensures that all</source>
          <target state="translated">ジャーナルファイル上で開かれたファイルハンドルのxSyncメソッドが呼び出されます。この操作により、すべての</target>
        </trans-unit>
        <trans-unit id="2abc7e1d2661195eacab3734a083049181c96938" translate="yes" xml:space="preserve">
          <source>The xTruncate method truncates a file to be nByte bytes in length. If the file is already nByte bytes or less in length then this method is a no-op. The xTruncate method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xTruncateメソッドは、ファイルをnByteバイトの長さに切り詰めます。ファイルの長さがすでにnByteバイト以下の場合、このメソッドは何もしません。xTruncateメソッドは、成功すると&lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_OKを&lt;/a&gt;返し、&lt;a href=&quot;rescode#ok&quot;&gt;問題&lt;/a&gt;が発生するとSQLITE_IOERR_TRUNCATEを返します。</target>
        </trans-unit>
        <trans-unit id="264cd9fc05e84b4a4186bdf81ed3b9dddd14f364" translate="yes" xml:space="preserve">
          <source>The xUpdate method is optional. If the xUpdate pointer in the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; for a virtual table is a NULL pointer, then the virtual table is read-only.</source>
          <target state="translated">xUpdateメソッドはオプションです。仮想テーブルの&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_moduleの&lt;/a&gt; xUpdateポインターがNULLポインターの場合、仮想テーブルは読み取り専用です。</target>
        </trans-unit>
        <trans-unit id="e7991b9300a6d5d1e9dd517f980e91bd729b810d" translate="yes" xml:space="preserve">
          <source>The xUpdate method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if it is successful. If a failure occurs, the xUpdate must return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. On a failure, the pVTab-&amp;gt;zErrMsg element may optionally be replaced with error message text stored in memory allocated from SQLite using functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;.</source>
          <target state="translated">xUpdateメソッドは、成功した場合にのみ、&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;返す必要があります。エラーが発生した場合、xUpdateは適切な&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;返す必要があります。失敗した場合、pVTab-&amp;gt; zErrMsg要素は、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;や&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;などの関数を使用して、SQLiteから割り当てられたメモリに格納されたエラーメッセージテキストで任意に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="4f4c20f5295bf2671dba3e7fbec564fd71238ee3" translate="yes" xml:space="preserve">
          <source>The xUpdate method will do a DELETE or an INSERT or both. The argv[0] element (which corresponds to memory cell P3) is the rowid of a row to delete. If argv[0] is NULL then no deletion occurs. The argv[1] element is the rowid of the new row. This can be NULL to have the virtual table select the new rowid for itself. The subsequent elements in the array are the values of columns in the new row.</source>
          <target state="translated">xUpdateメソッドは、DELETEまたはINSERT、またはその両方を行います。argv[0]要素(メモリセルP3に対応)は、削除する行の行IDです。argv[0]がNULLの場合、削除は行われません。argv[1]要素は、新しい行の行IDである。これを NULL にすると、仮想テーブルが新しい行 ID を選択するようになります。配列の後続の要素は、新しい行のカラムの値となります。</target>
        </trans-unit>
        <trans-unit id="dce6593181b88387e0232c4fe3315ea114b78c31" translate="yes" xml:space="preserve">
          <source>The xWrite method writes iAmt bytes of data from the second parameter into the file beginning at an offset of iOfst bytes. If the size of the file is less than iOfst bytes prior to the write, then xWrite should ensure that the file is extended with zeros up to iOfst bytes prior to beginning its write. xWrite continues to extends the file as necessary so that the size of the file is at least iAmt+iOfst bytes at the conclusion of the xWrite call. The xWrite method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If the write cannot complete because the underlying storage medium is full, then &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; is returned. &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; should be returned for any other error.</source>
          <target state="translated">xWriteメソッドは、iOfstバイトのオフセットで始まる2番目のパラメーターからiAmtバイトのデータをファイルに書き込みます。ファイルのサイズが書き込み前のiOfstバイトよりも小さい場合、xWriteは、書き込みを開始する前に、ファイルがゼロで最大iOfstバイトまで拡張されるようにする必要があります。 xWriteは、必要に応じてファイルを拡張し続けるため、xWrite呼び出しの終了時に、ファイルのサイズは少なくともiAmt + iOfstバイトになります。 xWriteメソッドは成功すると&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返します。基になるストレージメディアがいっぱいであるために書き込みを完了できない場合、&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;が返されます。その他のエラーの場合、&lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="d58a45ae0f446bdb86db23efea40a4365e8b2411" translate="yes" xml:space="preserve">
          <source>The zFormat string must not be NULL.</source>
          <target state="translated">zFormat 文字列は NULL であってはなりません。</target>
        </trans-unit>
        <trans-unit id="4f80fc797d2d3e861743d9ee1212caa09c71f3bc" translate="yes" xml:space="preserve">
          <source>The zName field holds the name of the VFS module. The name must be unique across all VFS modules.</source>
          <target state="translated">zName フィールドは、VFS モジュールの名前を保持します。この名前は、すべての VFS モジュールで一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="2e8507d62c194c1ae3ea2e8955ca09d80822bd5b" translate="yes" xml:space="preserve">
          <source>The zName field is the symbolic name of the VFS. This is the name that the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; compares against when it is looking for a VFS.</source>
          <target state="translated">zNameフィールドは、VFSの記号名です。これは、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;がVFSを探すときに比較する名前です。</target>
        </trans-unit>
        <trans-unit id="159171a13f5482b6256b050c73e581c3c1ed7fde" translate="yes" xml:space="preserve">
          <source>The zeroblob(N) function returns a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs can be used to reserve space for a BLOB that is later written using &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt;. This SQL function is implemented using the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; routine from the C/C++ interface.</source>
          <target state="translated">zeroblob（N）関数は、Nバイトの0x00で構成されるBLOBを返します。SQLiteはこれらのゼロブロブを非常に効率的に管理します。Zeroblobsを使用すると、後で&lt;a href=&quot;c3ref/blob_open&quot;&gt;増分BLOB I / O&lt;/a&gt;を使用して書き込まれるBLOBのスペースを予約できます。このSQL関数は、C / C ++インターフェースの&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob（）&lt;/a&gt;ルーチンを使用して実装されます。</target>
        </trans-unit>
        <trans-unit id="211680c2a7f3cd39edd65730ba2dc5798231d4d2" translate="yes" xml:space="preserve">
          <source>The zipfile module provides read/write access to simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archives&lt;/a&gt;. The current implementation has the following restrictions:</source>
          <target state="translated">zipfileモジュールは、単純な&lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIPアーカイブ&lt;/a&gt;への読み取り/書き込みアクセスを提供します。現在の実装には、次の制限があります。</target>
        </trans-unit>
        <trans-unit id="1b7b70776cb9a79f5d42a047fb481e44592ef0cc" translate="yes" xml:space="preserve">
          <source>The zipfile module provides three similar interfaces for accessing, updating and creating zip file archives:</source>
          <target state="translated">zipfile モジュールは、zip ファイルアーカイブへのアクセス、更新、作成のための 3 つの類似したインターフェイスを提供します。</target>
        </trans-unit>
        <trans-unit id="a3bf102cd7b1098b918321543923b0fbcf9afd25" translate="yes" xml:space="preserve">
          <source>The zipfile module provides two similar interfaces for accessing zip archives. A table-valued function, which provides read-only access to existing archives, and a virtual table interface, which provides both read and write access.</source>
          <target state="translated">zipfile モジュールは、zip アーカイブにアクセスするための二つの類似したインターフェイスを提供します。既存のアーカイブへの読み込み専用のアクセスを提供するテーブル値関数と、 読み込みと書き込みの両方のアクセスを提供する仮想テーブルインターフェースです。</target>
        </trans-unit>
        <trans-unit id="7f26831f509249abeae6c04bd252c7253425a19e" translate="yes" xml:space="preserve">
          <source>The zipfile() aggregate function may be called with 2, 4 or 5 arguments. If it is called with 5 arguments, then the entry added to the archive is equivalent to inserting the same values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;, &quot;data&quot; and &quot;method&quot; columns of a zipfile virtual table.</source>
          <target state="translated">zipfile()の集約関数は、2、4、5 のいずれかの引数で呼び出すことができます。5 つの引数で呼ばれた場合、アーカイブに追加されるエントリは、zipfile 仮想テーブルの &quot;name&quot;、&quot;mode&quot;、&quot;mtime&quot;、&quot;data&quot; および &quot;method&quot; カラムに同じ値を挿入することと同等のものとなります。</target>
        </trans-unit>
        <trans-unit id="fda3c54068d6592ac94595a28e9ae2b5a7631d94" translate="yes" xml:space="preserve">
          <source>Then any query that uses operators =, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;&amp;gt;, IN, LIKE, or GLOB on column &quot;c&quot; would be usable with the partial index because those comparison operators are only true if &quot;c&quot; is not NULL. So the following query could use the partial index:</source>
          <target state="translated">次に、列「c」で演算子=、&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt; =、&amp;lt;&amp;gt;、IN、LIKE、またはGLOBを使用するクエリは、部分インデックスで使用できます。 NULLではありません。したがって、次のクエリは部分インデックスを使用できます。</target>
        </trans-unit>
        <trans-unit id="d38e46789e87cb85236cff516beec8a98a69642c" translate="yes" xml:space="preserve">
          <source>Then continue to merge the changes in &quot;trunk&quot; with your &quot;private&quot; changes as described in section 3.7.</source>
          <target state="translated">その後、3.7項で説明したように、「trunk」の変更を「private」の変更にマージし続けます。</target>
        </trans-unit>
        <trans-unit id="4221ef1a5952683847cd93186bb995482d485923" translate="yes" xml:space="preserve">
          <source>Then creating &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt; in that schema that implement the official information schema tables using table-valued PRAGMA functions.</source>
          <target state="translated">次に、そのスキーマで、テーブル値のPRAGMA関数を使用して公式情報スキーマテーブルを実装する&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="24143dcd35d1fb5f0ef327aba489cfb57e18e5f5" translate="yes" xml:space="preserve">
          <source>Then download the new version of the SQLite sources and overwrite the files that are in the checkout.</source>
          <target state="translated">そして、新しいバージョンのSQLiteソースをダウンロードして、チェックアウトに入っているファイルを上書きします。</target>
        </trans-unit>
        <trans-unit id="350d0a66ff74448747b37fd69238737bb7294306" translate="yes" xml:space="preserve">
          <source>Then either of the two queries below may be executed to find the number of documents in the database that contain the word &quot;linux&quot; (351). Using one desktop PC hardware configuration, the query on the FTS3 table returns in approximately 0.03 seconds, versus 22.5 for querying the ordinary table.</source>
          <target state="translated">次に、以下の2つのクエリのいずれかを実行して、「linux」という単語を含むデータベース内のドキュメントの数を見つけることができます(351)。1台のデスクトップPCのハードウェア構成を使用すると、FTS3テーブルのクエリは約0.03秒で返されるのに対し、通常のテーブルのクエリは22.5秒で返されます。</target>
        </trans-unit>
        <trans-unit id="b72f2d807bd1572c917e30647dff75353e7ffc89" translate="yes" xml:space="preserve">
          <source>Then let the application maintain a separate pool of larger lookaside memory buffers that it can distribute to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; as they are created. In the common case, the application will only have a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and so the lookaside memory pool can consist of a single large buffer.</source>
          <target state="translated">次に、アプリケーションに、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が作成されたときにデータベース接続に配布できる、より大きなlookasideメモリバッファーの個別のプールを維持させます。一般的なケースでは、アプリケーションは単一の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;しか持たないため、lookasideメモリプールは単一の大きなバッファーで構成できます。</target>
        </trans-unit>
        <trans-unit id="13bc76c23a2d1597cb4fa248a96e4ed2a6339b15" translate="yes" xml:space="preserve">
          <source>Then one of the constraints would be on the &quot;a&quot; column with operator &quot;=&quot; and an expression of &quot;5&quot;. Constraints need not have a literal representation of the WHERE clause. The query optimizer might make transformations to the WHERE clause in order to extract as many constraints as it can. So, for example, if the WHERE clause contained something like this:</source>
          <target state="translated">そうすると、制約の1つは、演算子&quot;=&quot;と &quot;5 &quot;の式を持つ &quot;a &quot;列になります。制約は、WHERE句のリテラル表現を持つ必要はありません。クエリ・オプティマイザは、可能な限り多くの制約を抽出するために、WHERE句に変換を行うかもしれません。例えば、WHERE句に以下のようなものが含まれていたとします。</target>
        </trans-unit>
        <trans-unit id="a6d85a4cee37097aa0048aa17c7e903390d7845d" translate="yes" xml:space="preserve">
          <source>Then run &quot;sh speed-check.sh trunk&quot;.</source>
          <target state="translated">そして、&quot;sh speed-check.sh trunk &quot;を実行します。</target>
        </trans-unit>
        <trans-unit id="5af7ca0994a03bba6845a3d09f85ba03527c6bbf" translate="yes" xml:space="preserve">
          <source>Then that term is rewritten as follows:</source>
          <target state="translated">すると、その項は次のように書き換えられます。</target>
        </trans-unit>
        <trans-unit id="89cb6c0dfe329a7ee49493775fd34d7651a1097e" translate="yes" xml:space="preserve">
          <source>Then the LIKE operator pays attention to case and the example above would evaluate to false. Note that case insensitivity only applies to latin1 characters - basically the upper and lower case letters of English in the lower 127 byte codes of ASCII. International character sets are case sensitive in SQLite unless an application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#like&quot;&gt;like() SQL function&lt;/a&gt; are provided that take non-ASCII characters into account. But if an application-defined collating sequence and/or like() SQL function are provided, the LIKE optimization described here will never be taken.</source>
          <target state="translated">次に、LIKEオペレーターはケースに注意を払い、上の例はfalseと評価されます。大文字と小文字を区別しないのは、latin1文字にのみ適用されることに注意してください-基本的に、ASCIIの下位127バイトコードの英語の大文字と小文字。非ASCII文字を考慮に入れるアプリケーション定義の&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;および&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（）SQL関数&lt;/a&gt;が提供されていない限り、国際文字セットはSQLiteで大文字と小文字を区別します。ただし、アプリケーション定義の照合シーケンスやlike（）SQL関数が提供されている場合、ここで説明するLIKE最適化は行われません。</target>
        </trans-unit>
        <trans-unit id="be60a7454a5a8c066c86b3ca9b68995e4f6f1ddf" translate="yes" xml:space="preserve">
          <source>Then the RBU database should contain:</source>
          <target state="translated">そして、RBUデータベースが含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="996a8ef99f82edf5bb93411418cadd30d4e95347" translate="yes" xml:space="preserve">
          <source>Then the generated SQL will look like the following:</source>
          <target state="translated">すると、生成されたSQLは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0e329a491713b53943766e19e0cd3bc2370d4353" translate="yes" xml:space="preserve">
          <source>Then the index is usable by the query because the &quot;b=6&quot; term appears in both the index definition and in the query. Remember: terms in the index should be OR-connected and terms in the query should be AND-connected.</source>
          <target state="translated">すると、インデックスの定義とクエリの両方に &quot;b=6 &quot;という用語が現れるので、インデックスはクエリで使用可能になります。覚えておいてください:インデックス内の用語は OR 接続で、クエリ内の用語は AND 接続でなければなりません。</target>
        </trans-unit>
        <trans-unit id="2efe4248a37f7b9e147bfa69326ac21ae4833059" translate="yes" xml:space="preserve">
          <source>Then the index might be used if the initial columns of the index (columns a, b, and so forth) appear in WHERE clause terms. The initial columns of the index must be used with the *=* or *IN* or *IS* operators. The right-most column that is used can employ inequalities. For the right-most column of an index that is used, there can be up to two inequalities that must sandwich the allowed values of the column between two extremes.</source>
          <target state="translated">そうすると、インデックスの初期列(列a,bなど)がWHERE句の項に現れた場合にインデックスが使われるかもしれません。インデックスの最初の列は、*=*または*IN*または*IS*演算子を使用しなければなりません。使用される右端の列は、不等式を使用することができます。使用されるインデックスの最右端の列には、最大2つの不等式を使用することができ、その列の許容値を2つの極端の間に挟まなければなりません。</target>
        </trans-unit>
        <trans-unit id="f563dfd5bcb7f2cd99d04f3adadee6fc2e0e90d8" translate="yes" xml:space="preserve">
          <source>Then the index will &lt;u&gt;not&lt;/u&gt; be used because the expression on the CREATE INDEX statement (x+y) is not the same as the expression as it appears in the query (y+x). The two expressions might be mathematically equivalent, but the SQLite query planner insists that they be the same, not merely equivalent. Consider rewriting the query thusly:</source>
          <target state="translated">その後、CREATE INDEXステートメントの式（x + y）がクエリに表示される式（y + x）と同じではないため、インデックスは使用され&lt;u&gt;ません&lt;/u&gt;。2つの式は数学的に同等である可能性がありますが、SQLiteクエリプランナーは、それらが同じであるだけでなく、同じであると主張します。このようにクエリを書き直すことを検討してください：</target>
        </trans-unit>
        <trans-unit id="faa0b455785c0547f03cc054aee1b96482863f25" translate="yes" xml:space="preserve">
          <source>Then the locking mode applies only to the named database. If no database name qualifier precedes the &quot;locking_mode&quot; keyword then the locking mode is applied to all databases, including any new databases added by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands.</source>
          <target state="translated">次に、ロックモードは指定されたデータベースにのみ適用されます。「locking_mode」キーワードの前にデータベース名修飾子がない場合、ロックモードは、後続の&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;コマンドによって追加された新しいデータベースを含むすべてのデータベースに適用されます。</target>
        </trans-unit>
        <trans-unit id="2ace62cf521cfc04b47d7dad558287516162d423" translate="yes" xml:space="preserve">
          <source>Then the virtual table would be created with two hidden columns, and with datatypes of &quot;VARCHAR(12)&quot; and &quot;INTEGER&quot;.</source>
          <target state="translated">そうすると、2つの隠しカラムと &quot;VARCHAR(12)&quot;と &quot;INTEGER &quot;のデータ型を持つ仮想テーブルが作成されます。</target>
        </trans-unit>
        <trans-unit id="b398879a2efe1c2e2e8691470971432fd8ac7954" translate="yes" xml:space="preserve">
          <source>Then to read the first page of that database file, one merely runs:</source>
          <target state="translated">そして、そのデータベースファイルの最初のページを読むために、単に実行するだけです。</target>
        </trans-unit>
        <trans-unit id="9a0f2cc8cc7905afb88e588449e50b02e607b774" translate="yes" xml:space="preserve">
          <source>Then two &quot;virtual&quot; terms are added as follows:</source>
          <target state="translated">そして、以下のように2つの「仮想的な」用語が追加されます。</target>
        </trans-unit>
        <trans-unit id="1d3ddffeb2cfef8ef81678864135303a52c1015f" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It is also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">次に、&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX（）&lt;/a&gt;関数を使用して、大きな文字列値をSQLステートメントにバインドします。バインディングを使用すると、文字列内の引用文字をエスケープする必要がなくなり、SQLインジェクション攻撃のリスクが軽減されます。また、大きな文字列を解析またはコピーする必要がないため、実行速度も速くなります。</target>
        </trans-unit>
        <trans-unit id="265606c9637ac4024a4237e1919b8d5a2a194605" translate="yes" xml:space="preserve">
          <source>Then, love your neighbor as yourself.</source>
          <target state="translated">そして、隣人を自分のように愛しましょう。</target>
        </trans-unit>
        <trans-unit id="cf0cc9442c93b87173641af3ce48fe6ba6a56819" translate="yes" xml:space="preserve">
          <source>There are U or more such b-trees on a single level (see the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for an explanation of b-tree levels), where U is the value assigned to the &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge option&lt;/a&gt; option.</source>
          <target state="translated">単一レベルにU以上のそのようなbツリーがあります（bツリーレベルの説明については、&lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5自動マージオプションの&lt;/a&gt;ドキュメントを参照してください）。Uは、&lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5ユーザーマージオプション&lt;/a&gt;オプションに割り当てられた値です。</target>
        </trans-unit>
        <trans-unit id="fd10b08d9cff8fbc86ae03afd572ce0a4529a480" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;&lt;a href=&quot;zeroconf&quot;&gt;zero-configuration&lt;/a&gt;&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">サーバーレスであることには長所と短所があります。主な利点は、インストール、セットアップ、構成、初期化、管理、およびトラブルシューティングを行うための個別のサーバープロセスがないことです。これが、SQLiteが「&lt;a href=&quot;zeroconf&quot;&gt;ゼロ構成&lt;/a&gt;」データベースエンジンである理由の1つです。SQLiteを使用するプログラムは、実行前にデータベースエンジンを設定するための管理サポートを必要としません。ディスクにアクセスできるすべてのプログラムは、SQLiteデータベースを使用できます。</target>
        </trans-unit>
        <trans-unit id="9e47d4a7ae3779b3ce3872907368c2ebe6ca93d1" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;zero-configuration&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">サーバーレスにはメリットとデメリットがあります。主なメリットは、インストール、セットアップ、設定、初期化、管理、トラブルシューティングのための別個のサーバープロセスがないことです。これが SQLite が「設定不要」のデータベースエンジンである理由の 1 つです。SQLite を使用するプログラムは、実行前にデータベースエンジンを設定するための管理サポートを必要としません。ディスクにアクセスできるプログラムであれば、SQLite データベースを使用することができます。</target>
        </trans-unit>
        <trans-unit id="a00099ff32dd16c72c3ea081a513584d8f3c38e0" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using WAL instead of a rollback journal. Advantages include:</source>
          <target state="translated">ロールバックジャーナルではなくWALを使うことにはメリットとデメリットがあります。メリットとしては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="3093b427039bbfacae2cf7cc0c20cdff14795a5c" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</source>
          <target state="translated">メモリマップされたI/Oを使用することにはメリットとデメリットがあります。メリットには以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="79bd071128837bce919057f74da96b8e84ac063f" translate="yes" xml:space="preserve">
          <source>There are certain reasonable restrictions on expressions that appear in CREATE INDEX statements:</source>
          <target state="translated">CREATE INDEX文に現れる表現には、一定の合理的な制限があります。</target>
        </trans-unit>
        <trans-unit id="0440cacf20ea4b02e6a0db0e8999f07d0748bd04" translate="yes" xml:space="preserve">
          <source>There are compile-time options that will set upper bounds on the sizes of various structures in SQLite. The compile-time options normally set a hard upper bound that can be changed at run-time on individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface.</source>
          <target state="translated">SQLiteのさまざまな構造のサイズに上限を設定するコンパイル時オプションがあります。コンパイル時オプションは通常、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;インターフェース&lt;a href=&quot;c3ref/sqlite3&quot;&gt;を&lt;/a&gt;使用して個々のデータベース接続で実行時に変更できるハード上限を設定します。</target>
        </trans-unit>
        <trans-unit id="5db06d3cdfac9a23d2859adb4baf70db2e25be47" translate="yes" xml:space="preserve">
          <source>There are currently 170 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">現在、仮想マシンによって定義されている170のオペコードがあります。現在定義されているすべてのオペコードを以下の表に示します。このテーブルは、ファイル&lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt;からソースコードをスキャンして自動的に生成されました。</target>
        </trans-unit>
        <trans-unit id="2f94a164918f438c0d1173d53f7a4f94c08b35d7" translate="yes" xml:space="preserve">
          <source>There are currently the following configuration options:</source>
          <target state="translated">現在、以下の設定オプションがあります。</target>
        </trans-unit>
        <trans-unit id="3c95acf82c00de5d5751bda48036e2a0038274e3" translate="yes" xml:space="preserve">
          <source>There are details to fill in here. Perhaps a screen can be provided that displays a history changes (perhaps with a graph) allowing the user to select which version they want to view or edit. Perhaps some facility can be provided to merge forks that might occur in the version history. And perhaps the application should provide a means to purge old and unwanted versions. The key point is that using an SQLite database to store the content, rather than a ZIP archive, makes all of these features much, much easier to implement, which increases the possibility that they will eventually get implemented.</source>
          <target state="translated">ここに記入する詳細があります。おそらく、履歴の変更を表示する画面を提供することができます(おそらくグラフで)ユーザーが表示または編集したいバージョンを選択できるようにします。おそらく、バージョン履歴で発生する可能性のあるフォークをマージする機能を提供することができます。そして、アプリケーションは古いバージョンや不要なバージョンを削除する手段を提供すべきでしょう。重要なポイントは、ZIP アーカイブではなく、コンテンツを保存するために SQLite データベースを使用することで、これらの機能を実装するのが非常に簡単になり、最終的に実装される可能性が高くなるということです。</target>
        </trans-unit>
        <trans-unit id="98cb1601f44f3fee5a33f8d40abfeb82b5e7251a" translate="yes" xml:space="preserve">
          <source>There are five separate read locks, numbers 0 through 4. Read locks may be either SHARED or EXCLUSIVE. Connections obtain a shared lock on one of the read locks bytes while they are within a transaction. Connections also obtain an exclusive lock on read locks, one at a time, for the brief moment while they are updating the values of the corresponding read-marks. Read locks 1 through 4 are held exclusively when running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="translated">5つの個別の読み取りロックがあり、0から4の番号が付いています。読み取りロックはSHAREDまたはEXCLUSIVEのいずれかです。接続は、トランザクション内にある間、読み取りロックバイトの1つで共有ロックを取得します。また、接続は、対応する読み取りマークの値を更新している間、読み取りロックに対する排他ロックを一度に1つずつ取得します。読み取りロック1〜4は、&lt;a href=&quot;walformat#recovery&quot;&gt;リカバリの&lt;/a&gt;実行中にのみ保持されます。</target>
        </trans-unit>
        <trans-unit id="c457ee41ba8d1b7387ba8e7edc9a0ac19be4f375" translate="yes" xml:space="preserve">
          <source>There are five ways to describe starting and ending frame boundaries:</source>
          <target state="translated">開始枠と終了枠の境界を表現するには、5つの方法があります。</target>
        </trans-unit>
        <trans-unit id="4083c54b42aa73500fa86d4b0409e55690866a09" translate="yes" xml:space="preserve">
          <source>There are many advantages to using SQLite as an application file format, including:</source>
          <target state="translated">アプリケーションのファイル形式としてSQLiteを使用することには、以下のようなメリットがあります。</target>
        </trans-unit>
        <trans-unit id="7e1c62962db715e611550a655ba502415a8c24f6" translate="yes" xml:space="preserve">
          <source>There are many benefits to this approach, including improved performance, reduced cost and complexity, and improved reliability. See technical notes &lt;a href=&quot;aff_short&quot;&gt;&quot;aff_short.html&quot;&lt;/a&gt; and &lt;a href=&quot;appfileformat&quot;&gt;&quot;appfileformat.html&quot;&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;&quot;fasterthanfs.html&quot;&lt;/a&gt; for more information. This use case is closely related to the &lt;a href=&quot;#wireproto&quot;&gt;data transfer format&lt;/a&gt; and &lt;a href=&quot;#container&quot;&gt;data container&lt;/a&gt; use cases below.</source>
          <target state="translated">このアプローチには、パフォーマンスの向上、コストと複雑さの軽減、信頼性の向上など、多くの利点があります。テクニカルノートを参照してください&lt;a href=&quot;aff_short&quot;&gt;「aff_short.html」&lt;/a&gt;と&lt;a href=&quot;appfileformat&quot;&gt;「appfileformat.html」&lt;/a&gt;と&lt;a href=&quot;fasterthanfs&quot;&gt;「fasterthanfs.html」&lt;/a&gt;詳細については。この使用例は、以下の&lt;a href=&quot;#wireproto&quot;&gt;データ転送形式&lt;/a&gt;と&lt;a href=&quot;#container&quot;&gt;データコンテナーの&lt;/a&gt;使用例と密接に関連しています。</target>
        </trans-unit>
        <trans-unit id="a6dd1c1ec54122d1cd8a41e77d633d60c4de1054" translate="yes" xml:space="preserve">
          <source>There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.</source>
          <target state="translated">失敗した特定のI/O操作を識別するI/Oエラーのための多くの異なる拡張結果コードがあります。</target>
        </trans-unit>
        <trans-unit id="f265782324871b5641aee92d51fefe1edfb475af" translate="yes" xml:space="preserve">
          <source>There are many fraudulent USB sticks in circulation that report to have a high capacity (ex: 8GB) but are really only capable of storing a much smaller amount (ex: 1GB). Attempts to write on these devices will often result in unrelated files being overwritten. Any use of a fraudulent flash memory device can easily lead to database corruption, therefore. Internet searches such as &quot;fake capacity usb&quot; will turn up lots of disturbing information about this problem.</source>
          <target state="translated">大容量(例:8GB)を謳っているが、実際にはそれ以下の容量(例:1GB)しか保存できないという詐欺的なUSBメモリが多く流通しています。これらのデバイスに書き込みをしようとすると、関係のないファイルが上書きされてしまうことがよくあります。そのため、不正なフラッシュメモリを使用すると、簡単にデータベースの破損につながる可能性があります。インターネットで「偽の容量USB」などと検索すると、この問題についての不穏な情報がたくさん出てきます。</target>
        </trans-unit>
        <trans-unit id="a53dc58a565490cefd808a058bfaad47e191a084" translate="yes" xml:space="preserve">
          <source>There are many more features not listed above. SQLite may be small in size and have &quot;Lite&quot; in its name, but it is not lacking in capability.</source>
          <target state="translated">上記に挙げられていない機能は他にもたくさんあります。SQLiteはサイズが小さく、名前に「Lite」がついているかもしれませんが、機能が不足しているわけではありません。</target>
        </trans-unit>
        <trans-unit id="60f662540321a06d796e68831dc73409bf49f397" translate="yes" xml:space="preserve">
          <source>There are many other dot-commands available in the command-line shell. See the &quot;.help&quot; command for a complete list for any particular version and build of SQLite.</source>
          <target state="translated">コマンドラインシェルには他にも多くのドットコマンドがあります。特定のバージョンやビルドの SQLite の完全なリストは &quot;.help&quot; コマンドを参照してください。</target>
        </trans-unit>
        <trans-unit id="53f739b37a172fddf027f7c8afb4029bf933f8fe" translate="yes" xml:space="preserve">
          <source>There are many other testing options, which can be seen by running the command:</source>
          <target state="translated">他にも多くのテストオプションがあり、コマンドを実行することで確認することができます。</target>
        </trans-unit>
        <trans-unit id="461c7676d827031f4cd64d05f3d67e68ce256daf" translate="yes" xml:space="preserve">
          <source>There are many ways to measure test coverage. The most popular metric is &quot;statement coverage&quot;. When you hear someone say that their program as &quot;XX% test coverage&quot; without further explanation, they usually mean statement coverage. Statement coverage measures what percentage of lines of code are executed at least once by the test suite.</source>
          <target state="translated">テストカバレッジを測定する方法はたくさんあります。最もポピュラーな指標は「ステートメントカバレッジ」です。誰かが自分のプログラムが「○○%のテストカバレッジ」と言っているのを聞いたとき、その人たちはたいていステートメントカバレッジを意味しています。ステートメントカバレッジは、テストスイートによってコードの何パーセントの行が少なくとも一度は実行されたかを測定します。</target>
        </trans-unit>
        <trans-unit id="15784824361af8c293ec21cb8076051131fb442d" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits in TH3. One could generate a single test program that contained all test modules and all configuration files. However, such a test program might be too large to deploy on embedded platforms. (As of 2018-05-19, a full-up TH3 test is over 850,000 lines and 58MB of C code.) TH3 provides the ability to break the library of test modules up into smaller, more easily digested pieces.</source>
          <target state="translated">TH3 には任意の制限はありません。すべてのテストモジュールとすべての設定ファイルを含む単一のテストプログラムを作成することができます。しかし、そのようなテストプログラムは、組み込みプラットフォームにデプロイするには大きすぎるかもしれません。(2018-05-19現在、フルアップのTH3テストは85万行以上、58MBのCコードになります)。TH3は、テストモジュールのライブラリをより消化しやすい小さな断片に分割する機能を提供しています。</target>
        </trans-unit>
        <trans-unit id="67165e227e06a66e9e2a7c9a359bffd814ca48a8" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits on the number of indices that can be attached to a single table. The number of columns in an index is limited to the value set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,...).</source>
          <target state="translated">1つのテーブルにアタッチできるインデックスの数に任意の制限はありません。インデックス内の列数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;、...）によって設定された値に制限されます。</target>
        </trans-unit>
        <trans-unit id="75e5745eabbe1f0d9742be6d3047103706a06632" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;../threadsafe&quot;&gt;スレッド化モード&lt;/a&gt;をマルチスレッドに設定します。つまり、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトのミューテックスを無効にします。アプリケーションは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;へのアクセスをシリアライズする責任があります。ただし、他のミューテックスが有効になっているため、2つのスレッドが同じ&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;を同時に使用しない限り、SQLiteはマルチスレッド環境で安全に使用できます。 SQLiteが&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、マルチスレッド&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;と&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;を設定することはできません。戻ります&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERRORを&lt;/a&gt; SQLITE_CONFIG_MULTITHREAD構成オプションを指定して呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="438fea25e22862b67e0b2e195af310125649fa4d" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;../threadsafe&quot;&gt;スレッド化モード&lt;/a&gt;をシリアル化に設定します。つまり、このオプションは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続の&lt;/a&gt;再帰ミューテックスと&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトを含むすべてのミューテックスを有効にします。このモード（SQLiteが&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1で&lt;/a&gt;コンパイルされている場合のデフォルト）では、SQLiteライブラリ自体が&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;へのアクセスをシリアル化するため、アプリケーションは異なる&lt;a href=&quot;sqlite3&quot;&gt;データベースで&lt;/a&gt;同じデータベース接続または同じ&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を自由に使用できます。同時に。 SQLiteが&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0で&lt;/a&gt;コンパイルされている場合コンパイル時のオプションでは、直列化された設定することはできません&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;と&lt;a href=&quot;config&quot;&gt;sqlite3_configを（）&lt;/a&gt;が返されます&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERRORを&lt;/a&gt; SQLITE_CONFIG_SERIALIZEDコンフィギュレーションオプションを指定して呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="4b86fd3dbc8c8ae83073b70ec3ca59694912ef28" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;をシングルスレッドに設定します。つまり、すべてのミューテックスを無効にし、SQLiteを単一のスレッドでのみ使用できるモードにします。 SQLiteが&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;をデフォルト値のシングルスレッドから変更することはできないため、SQLITE_CONFIG_SINGLETHREAD構成オプションで呼び出された場合、&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;は&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="e6b294707b24261f0f532c64902934c051eedbd1" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;threadsafe&quot;&gt;スレッド化モード&lt;/a&gt;をマルチスレッドに設定します。つまり、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトのミューテックスを無効にします。アプリケーションは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;へのアクセスをシリアライズする責任があります。ただし、他のミューテックスが有効になっているため、2つのスレッドが同じ&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;を同時に使用しない限り、SQLiteはマルチスレッド環境で安全に使用できます。 SQLiteが&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、マルチスレッド&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;と&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;を設定することはできません。戻ります&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERRORを&lt;/a&gt; SQLITE_CONFIG_MULTITHREAD構成オプションを指定して呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="955a610f066915f2766fca467b944718d1ee6aea" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;threadsafe&quot;&gt;スレッド化モード&lt;/a&gt;をシリアル化に設定します。つまり、このオプションは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続の&lt;/a&gt;再帰ミューテックスと&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトを含むすべてのミューテックスを有効にします。このモード（SQLiteが&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1で&lt;/a&gt;コンパイルされている場合のデフォルト）では、SQLiteライブラリ自体が&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;へのアクセスをシリアル化するため、アプリケーションは異なる&lt;a href=&quot;#sqlite3&quot;&gt;データベースで&lt;/a&gt;同じデータベース接続または同じ&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を自由に使用できます。同時に。 SQLiteが&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0で&lt;/a&gt;コンパイルされている場合コンパイル時のオプションでは、直列化された設定することはできません&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;と&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_configを（）&lt;/a&gt;が返されます&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERRORを&lt;/a&gt; SQLITE_CONFIG_SERIALIZEDコンフィギュレーションオプションを指定して呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="1bc66a3a72545b16257e521a7b7467b7b7fb116b" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;をシングルスレッドに設定します。つまり、すべてのミューテックスを無効にし、SQLiteを単一のスレッドでのみ使用できるモードにします。 SQLiteが&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;をデフォルト値のシングルスレッドから変更することはできないため、SQLITE_CONFIG_SINGLETHREAD構成オプションで呼び出された場合、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="33e0331165757b835edb3c42bfc1d34942851312" translate="yes" xml:space="preserve">
          <source>There are numerous test cases that verify that SQLite is able to deal with malformed database files. These tests first build a well-formed database file, then add corruption by changing one or more bytes in the file by some means other than SQLite. Then SQLite is used to read the database. In some cases, the bytes changes are in the middle of data. This causes the content of the database to change while keeping the database well-formed. In other cases, unused bytes of the file are modified, which has no effect on the integrity of the database. The interesting cases are when bytes of the file that define database structure get changed. The malformed database tests verify that SQLite finds the file format errors and reports them using the &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; return code without overflowing buffers, dereferencing NULL pointers, or performing other unwholesome actions.</source>
          <target state="translated">SQLiteが不正なデータベースファイルを処理できることを確認する多数のテストケースがあります。これらのテストでは、最初に整形式のデータベースファイルを作成し、SQLite以外の方法でファイルの1バイト以上を変更して破損を追加します。次に、SQLiteを使用してデータベースを読み取ります。場合によっては、バイトの変更はデータの途中です。これにより、データベースの形式を維持しながら、データベースの内容が変更されます。他の場合では、ファイルの未使用のバイトが変更され、データベースの整合性には影響しません。興味深いケースは、データベース構造を定義するファイルのバイトが変更される場合です。不正なデータベーステストは、SQLiteがファイル形式エラーを見つけ、&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;を使用してそれらを報告することを確認します バッファのオーバーフロー、NULLポインタの逆参照、または他の不健全なアクションの実行なしの戻りコード。</target>
        </trans-unit>
        <trans-unit id="f9afe2547739122b5f898fca4cf352f033d81b8f" translate="yes" xml:space="preserve">
          <source>There are only two reasonable ways to implement this query. (There are many other possible algorithms, but none of the others are contenders for being the &quot;best&quot; algorithm.)</source>
          <target state="translated">このクエリを実装するための合理的な方法は2つしかありません(他にも多くの可能性のあるアルゴリズムがありますが、他のどれも「最良」のアルゴリズムであるとは言えません)。(他にも多くの可能性のあるアルゴリズムがありますが、他のアルゴリズムはどれも「最良」のアルゴリズムではありません)。</target>
        </trans-unit>
        <trans-unit id="35c4953b7b40ec225a59ad1651360c7dbd0086b0" translate="yes" xml:space="preserve">
          <source>There are other SQL database engines with liberal licenses that allow the code to be broadly and freely used. But those other engines are still governed by copyright law. SQLite is different in that copyright law simply does not apply.</source>
          <target state="translated">自由なライセンスを持つSQLデータベースエンジンは他にもあり、そのコードを広く自由に使うことができます。しかし、これらのエンジンは著作権法によって管理されています。SQLite は著作権法が適用されないという点で異なっています。</target>
        </trans-unit>
        <trans-unit id="00840e534b3409464615b9e5469c1789e0356b07" translate="yes" xml:space="preserve">
          <source>There are other VFS implementations both in the core SQLite source code library and in available extensions. The list above is not meant to be exhaustive but merely representative of the kinds of features that can be realized using the VFS interface.</source>
          <target state="translated">VFS の実装は、SQLite のコアソースコードライブラリと、利用可能な拡張機能の両方にあります。上記のリストは網羅的なものではなく、VFS インタフェースを使用して実現できる機能の種類の代表的なものにすぎません。</target>
        </trans-unit>
        <trans-unit id="fe657852dc4212647e79b2906ecbf326edcfcb96" translate="yes" xml:space="preserve">
          <source>There are several other ways to add an equivalent foreign key declaration to a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Refer to the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE documentation&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントに同等の外部キー宣言を追加するには、他にもいくつかの方法があります。詳細については、&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLEのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="14687afe7afa4066d985b4f03845594063586e18" translate="yes" xml:space="preserve">
          <source>There are several ways of thinking about the RELEASE command:</source>
          <target state="translated">RELEASEコマンドについては、いくつかの考え方があります。</target>
        </trans-unit>
        <trans-unit id="22c57ea3a56c1a621fcb33ba044a6de73ca1f510" translate="yes" xml:space="preserve">
          <source>There are several ways to approach this in FTS5:</source>
          <target state="translated">FTS5ではいくつかのアプローチ方法があります。</target>
        </trans-unit>
        <trans-unit id="de40b756c06e57b21f4c7c518f428b201082172b" translate="yes" xml:space="preserve">
          <source>There are some contexts in SQLite that do not allow the use of non-deterministic functions:</source>
          <target state="translated">SQLite には、非決定論的な関数の使用を許可しないコンテキストがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="ffb257ce26a3636acdb1a9134b8ec418a490f506" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of a VALUES clause that are not shown on the syntax diagrams:</source>
          <target state="translated">構文図には示されていないが、VALUES句の使用にはいくつかの制限がある。</target>
        </trans-unit>
        <trans-unit id="4fc9c795ba02424df295c5bd8e19a42a3240738c" translate="yes" xml:space="preserve">
          <source>There are three frame types: ROWS, GROUPS, and RANGE. The frame type determines how the starting and ending boundaries of the frame are measured.</source>
          <target state="translated">フレームの種類は3つあります。ROWS、GROUPS、RANGEです。フレームタイプは、フレームの開始境界と終了境界をどのように測定するかを決定します。</target>
        </trans-unit>
        <trans-unit id="b1e7d89744d05b6a27dde7db2836b2617aa1bbd6" translate="yes" xml:space="preserve">
          <source>There are three independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">コアとなる SQLite ライブラリのテストには、3 つの独立したテストハーネスが使用されています。それぞれのテストハーネスは、他のものとは別に設計、保守、管理されています。</target>
        </trans-unit>
        <trans-unit id="045c3584370eb289c548f60cb3b6ecaf401b3ed3" translate="yes" xml:space="preserve">
          <source>There are three levels to the shared-cache locking model, transaction level locking, table level locking and schema level locking. They are described in the following three sub-sections.</source>
          <target state="translated">共有キャッシュ・ロックモデルには、トランザクション・レベル・ロック、テーブル・レベル・ロック、スキーマ・レベル・ロックの3つのレベルがあります。これらは以下の3つのサブセクションで説明されています。</target>
        </trans-unit>
        <trans-unit id="944bcf56eaccf2f8d8f73507f47a4f5f610aa075" translate="yes" xml:space="preserve">
          <source>There are three reasons to set the locking-mode to EXCLUSIVE.</source>
          <target state="translated">ロックモードをEXCLUSIVEにする理由は3つあります。</target>
        </trans-unit>
        <trans-unit id="e889a4b513747e6b54c292e814d5a011df18d8e5" translate="yes" xml:space="preserve">
          <source>There are three special-case entries in the cost table:</source>
          <target state="translated">原価表には3つの特殊なケースの項目があります。</target>
        </trans-unit>
        <trans-unit id="3e8f3752e4f9aab9d7f5e605906342c5eeca4178" translate="yes" xml:space="preserve">
          <source>There are two advantages to using the SQLite printf functions instead of &lt;b&gt;sprintf&lt;/b&gt;. First of all, with the SQLite printf routines, there is never a danger of overflowing a static buffer as there is with &lt;b&gt;sprintf&lt;/b&gt;. The SQLite printf routines automatically allocate (and later frees) as much memory as is necessary to hold the SQL statements generated.</source>
          <target state="translated">&lt;b&gt;sprintfの&lt;/b&gt;代わりにSQLiteのprintf関数を使用することには2つの利点があります。まず、SQLiteのprintfルーチンを使用すると、&lt;b&gt;sprintfの&lt;/b&gt;ように静的バッファーがオーバーフローする危険はありません。SQLiteのprintfルーチンは、生成されたSQLステートメントを保持するために必要なだけのメモリを自動的に割り当てます（後で解放します）。</target>
        </trans-unit>
        <trans-unit id="391950a505dd77c6d9de2b0a8bf9dd26b935ed51" translate="yes" xml:space="preserve">
          <source>There are two aggregate SQL functions:</source>
          <target state="translated">集約SQL関数は2つあります。</target>
        </trans-unit>
        <trans-unit id="631b7dfac93f3d53c23db92b1bef743005732dff" translate="yes" xml:space="preserve">
          <source>There are two cases to consider: (1) Table &quot;tab1&quot; does not previously exist and (2) table &quot;tab1&quot; does already exist.</source>
          <target state="translated">考慮すべきケースは2つあります。(1)テーブル「tab1」が以前に存在しない場合と、(2)テーブル「tab1」が既に存在している場合です。</target>
        </trans-unit>
        <trans-unit id="b8b8531dc422d3e33d42cc7bdad0abd37870f1fe" translate="yes" xml:space="preserve">
          <source>There are two column (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array names azResult. Then azResult holds this content:</source>
          <target state="translated">2列(M==2)と3行(N==3)があります。このように、結果テーブルには8つのエントリがあります。結果テーブルが azResult という名前の配列に格納されているとします。すると、azResultにはこのような内容が格納されています。</target>
        </trans-unit>
        <trans-unit id="928a963ad2407ff0d2d21e12347ddb23d756bb64" translate="yes" xml:space="preserve">
          <source>There are two differences in this variation. The initial-select is &quot;SELECT 1&quot; instead of &quot;VALUES(1)&quot;. But those are just different syntaxes for saying exactly the same thing. The other change is that the recursion is stopped by a LIMIT rather than a WHERE clause. The use of LIMIT means that when the one-millionth row is added to the &quot;cnt&quot; table (and returned by the main SELECT, thanks to the query optimizer) then the recursion stops immediately regardless of how many rows might be left in the queue. On more complex queries, it can sometimes be difficult to ensure that the WHERE clause will eventually cause the queue to drain and the recursion to terminate. But the LIMIT clause will always stop the recursion. So it is good practice to always include a LIMIT clause as a safety if an upper bound on the size of the recursion is known.</source>
          <target state="translated">このバリエーションには2つの違いがあります。初期選択は &quot;VALUES(1)&quot;ではなく &quot;SELECT 1 &quot;になっています。しかし、これらは全く同じことを言うための異なる構文です。他の変更点は、WHERE句ではなくLIMITによって再帰が停止されていることです。LIMITの使用は、100万行目の行が &quot;cnt &quot;テーブルに追加されたとき(クエリオプティマイザのおかげでメインのSELECTで返されたとき)、キューに何行残っているかに関わらず、再帰が即座に停止することを意味します。より複雑なクエリでは、WHERE句が最終的にキューを排出して再帰を終了させることを確実にすることが難しい場合があります。しかし、LIMIT句は常に再帰を停止します。ですから、再帰のサイズの上限がわかっている場合には、安全のために LIMIT 句を常に含めることが良い習慣となります。</target>
        </trans-unit>
        <trans-unit id="10f943413bc9e88ca64edb6cc154e6b7583f6c77" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">ここには、togethrまたは個別に使用できる2つの個別の構成変更があります。&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREADの&lt;/a&gt;設定は、シリアル化へのアクセスというミューテックスを無効にし&lt;a href=&quot;c3ref/sqlite3&quot;&gt;、データベース接続&lt;/a&gt;オブジェクトと&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクト。この設定では、アプリケーションは複数のスレッドからSQLiteを自由に使用できますが、2つのスレッドが同じ&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;または同じデータベース接続に関連付けられている&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメントに&lt;/a&gt;同時にアクセスしないようにする必要があり&lt;a href=&quot;c3ref/sqlite3&quot;&gt;ます&lt;/a&gt;。 2つのスレッドは同時にSQLiteを使用できますが、別々の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続を&lt;/a&gt;使用する必要があります。 2番目の&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;設定すると、未解決のメモリ割り当て要求すべての合計サイズを追跡するSQLiteのメカニズムが無効になります。これにより、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;および&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;への各呼び出しをミューテックスする必要がなくなり、膨大な数のミューテックス操作が節約されます。ただし、メモリ統計メカニズムを無効にすると、&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;、&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;インターフェースが機能しなくなります。</target>
        </trans-unit>
        <trans-unit id="03b9684a8e7902c26ab2183576e54dd70242a272" translate="yes" xml:space="preserve">
          <source>There are two types of simple SELECT statement - aggregate and non-aggregate queries. A simple SELECT statement is an aggregate query if it contains either a GROUP BY clause or one or more aggregate functions in the result-set. Otherwise, if a simple SELECT contains no aggregate functions or a GROUP BY clause, it is a non-aggregate query.</source>
          <target state="translated">単純なSELECT文には、集約型と非集約型の2種類があります。単純なSELECT文にGROUP BY句または結果セットに1つ以上の集約関数が含まれている場合、集約クエリとなります。そうでない場合、単純なSELECT文に集約関数やGROUP BY句が含まれていない場合は、非集約クエリとなります。</target>
        </trans-unit>
        <trans-unit id="265655ffc7236582ade45c905963724f97d22dc0" translate="yes" xml:space="preserve">
          <source>There are two ways to use the &quot;content&quot; option:</source>
          <target state="translated">コンテンツ」オプションを使用する方法は2つあります。</target>
        </trans-unit>
        <trans-unit id="6c855557ba4350c988043164f7d90199d18c9af0" translate="yes" xml:space="preserve">
          <source>There are typically between 10 to 40 entries in the sqlite_stat4 table for each index for which statistics are available, however these limits are not hard bounds. The meanings of the columns in the sqlite_stat4 table are as follows:</source>
          <target state="translated">統計情報が利用可能な各インデックスのsqlite_stat4テーブルには通常10から40個のエントリがありますが、これらの制限はハードバウンズではありません。sqlite_stat4テーブルの列の意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7cc2860dd2126e117e20cc785f2f36fc98950f36" translate="yes" xml:space="preserve">
          <source>There are usually multiple entries in the sqlite_stat3 table for each index. The sqlite_stat3.sample column holds the value of the left-most field of an index identified by sqlite_stat3.idx and sqlite_stat3.tbl. The sqlite_stat3.nEq column holds the approximate number of entries in the index whose left-most column exactly matches the sample. The sqlite_stat3.nLt holds the approximate number of entries in the index whose left-most column is less than the sample. The sqlite_stat3.nDLt column holds the approximate number of distinct left-most entries in the index that are less than the sample.</source>
          <target state="translated">通常、各インデックスに対してsqlite_stat3テーブルには複数のエントリがあります。sqlite_stat3.sample列は、sqlite_stat3.idxとsqlite_stat3.tblで識別されるインデックスの左端のフィールドの値を保持します。sqlite_stat3.nEq列は、左端の列がサンプルと正確に一致するインデックスのおおよその項目数を保持します。sqlite_stat3.nLt列は、左端の列が標本より小さいインデックスのおおよその項目数を保持します。sqlite_stat3.nDLt列は、インデックスの左端の列が標本よりも小さい明確な左端のエントリのおおよその数を保持します。</target>
        </trans-unit>
        <trans-unit id="3bc8ca2faf5f82d403479bc810eea0e330c59fbe" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat3 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat3 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">インデックスごとに任意の数のsqlite_stat3エントリが存在できます。&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドは、典型的には、鍵空間を横切って大きなNEQ値で分布している10〜40個のサンプルを含むsqlite_stat3テーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="76781503806bdc9ca573d5796b00968614643484" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat4 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat4 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">インデックスごとに任意の数のsqlite_stat4エントリが存在できます。&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドは、典型的には、鍵空間を横切って大きなNEQ値で分布している10〜40個のサンプルを含むsqlite_stat4テーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="4935a4962bbd49a87bfec8ba26bcb0ee96e2bc65" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに定義されているビジーハンドラは1つだけです。新しいビジーハンドラーを設定すると、以前に設定されたハンドラーがクリアされます。&lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;を呼び出すか、&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt;を評価すると、ビジーハンドラーが変更され、以前に設定されたビジーハンドラーがクリアされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="595614b4fea7d83eeee9eca9b82c7f15a616950a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに定義されているビジーハンドラは1つだけです。新しいビジーハンドラーを設定すると、以前に設定されたハンドラーがクリアされます。&lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;を呼び出すか、&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt;を評価すると、ビジーハンドラーが変更され、以前に設定されたビジーハンドラーがクリアされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4557f81c54cd198ad30dafda03e1a7688c37ee6a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">特定の時点で特定の&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;に対して使用できるハンドラーは1つだけです。このルーチンを呼び出す前に別のビジーハンドラーが（&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;を使用して）定義されている場合、その別のビジーハンドラーはクリアされます。</target>
        </trans-unit>
        <trans-unit id="6c5612f166f3c19adb75f5b9420223d984d062bf" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">特定の時点で特定の&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;に対して使用できるハンドラーは1つだけです。このルーチンを呼び出す前に別のビジーハンドラーが（&lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;を使用して）定義されている場合、その別のビジーハンドラーはクリアされます。</target>
        </trans-unit>
        <trans-unit id="da947c700e89a2839d81ef99abfdba549201cf04" translate="yes" xml:space="preserve">
          <source>There can only be a single error logging callback per process. The error logging callback is registered at start-time using C-code similar to the following:</source>
          <target state="translated">プロセスごとに1つのエラーロギングコールバックだけが存在することができます。エラーロギングコールバックは、以下のようなCコードを使用してスタート時に登録されます。</target>
        </trans-unit>
        <trans-unit id="297da7a4ca1508d9a0851c1993606776e3a61cd5" translate="yes" xml:space="preserve">
          <source>There can only be a single trace callback registered on a database connection. Each use of &quot;trace&quot; or &quot;trace_v2&quot; cancels all prior trace callback.</source>
          <target state="translated">データベース接続に登録されているトレースコールバックは 1 つだけです。trace&quot; または &quot;trace_v2&quot; を使用するたびに、それ以前のトレースコールバックはすべてキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="13fe35de43729e33636f83c267efada945c04a07" translate="yes" xml:space="preserve">
          <source>There exists some subtle problem with mmap() on QNX such that making a second mmap() call against a single file descriptor can cause the memory obtained from the first mmap() call to be zeroed. SQLite on unix uses mmap() to create a shared memory region for transaction coordination in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, and it will call mmap() multiple times for large transactions. The QNX mmap() has been demonstrated to corrupt database file under that scenario. QNX engineers are aware of this problem and are working on a solution; the problem may have already been fixed by the time you read this.</source>
          <target state="translated">QNXのmmap（）には、単一のファイル記述子に対して2番目のmmap（）呼び出しを行うと、最初のmmap（）呼び出しから取得されたメモリがゼロになる可能性があるなど、いくつかの微妙な問題があります。 UNIX上のSQLiteはmmap（）を使用して、&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;でのトランザクション調整用の共有メモリ領域を作成し、大規模なトランザクションの場合はmmap（）を複数回呼び出します。 QNX mmap（）は、そのシナリオでデータベースファイルを破損することが実証されています。 QNXエンジニアはこの問題を認識しており、解決に取り組んでいます。これを読んだ時点で、問題はすでに修正されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="d56d459074bf9b196b2551c494a4c7bec9d94df2" translate="yes" xml:space="preserve">
          <source>There has lately been a lot of interest in &quot;safe&quot; programming languages like Rust or Go in which it is impossible, or is at least difficult, to make common programming errors like memory leaks or array overruns. So the question often arises as to why SQLite is not coded in a &quot;safe&quot; language.</source>
          <target state="translated">最近、RustやGoのような「安全な」プログラミング言語が注目されていますが、この言語ではメモリリークや配列のオーバーランのような一般的なプログラミングエラーを起こすことは不可能です。そこで、なぜ SQLite は「安全な」言語でコーディングされていないのか、という疑問がよく出てきます。</target>
        </trans-unit>
        <trans-unit id="52072b3d340cc958b2ff6cebc4a70e99aba7da9e" translate="yes" xml:space="preserve">
          <source>There have been three historical file formats for SQLite. SQLite 1.0 through 1.0.32 used the &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; library as its storage engine. SQLite 2.0.0 through 2.8.17 used a custom b-tree storage engine that supported only text keys and data. All modern versions of SQLite (3.0.0 to present) use a b-tree storage engine that has full support for binary data and Unicode.</source>
          <target state="translated">SQLiteには、3つの歴史的なファイル形式があります。SQLite 1.0から1.0.32までは、ストレージエンジンとして&lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt;ライブラリを使用していました。SQLite 2.0.0から2.8.17までは、テキストキーとデータのみをサポートするカスタムBツリーストレージエンジンを使用していました。SQLiteの最新バージョン（3.0.0から現在まで）はすべて、バイナリデータとUnicodeを完全にサポートするBツリーストレージエンジンを使用しています。</target>
        </trans-unit>
        <trans-unit id="3be8d2f16b71e4444f7f725739b5254eb08f103c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; which will return the integer key for the most recent insert operation.</source>
          <target state="translated">最新の挿入操作の整数キーを返す&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;という名前の関数があります。</target>
        </trans-unit>
        <trans-unit id="2c4047eace270e4351576190943319e0de00174c" translate="yes" xml:space="preserve">
          <source>There is a limit, set using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;, to the number of databases that can be simultaneously attached to a single database connection.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;と&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;を使用して設定された、単一のデータベース接続に同時に接続できるデータベースの数には制限があります。</target>
        </trans-unit>
        <trans-unit id="d03b97c401c9a348f14fea8d291ce117238dc810" translate="yes" xml:space="preserve">
          <source>There is a long list of conditions that must all be met in order for query flattening to occur. Some of the constraints are marked as obsolete by italic text. These extra constraints are retained in the documentation to preserve the numbering of the other constraints.</source>
          <target state="translated">クエリの平坦化が発生するためには、すべて満たさなければならない条件の長いリストがあります。いくつかの制約は、イタリック体のテキストで廃止されたものとしてマークされています。これらの余分な制約は、他の制約の番号付けを維持するために、ドキュメントに保持されています。</target>
        </trans-unit>
        <trans-unit id="098b1868e66c13228c4371a548aa26b3bfac10d5" translate="yes" xml:space="preserve">
          <source>There is a new TypeOf() function used to determine if an expression is numeric or text.</source>
          <target state="translated">式が数値かテキストかを判断するために使用される新しい TypeOf()関数があります。</target>
        </trans-unit>
        <trans-unit id="e6da2fbcc052924976fcf688d82595c343604804" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_master.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">AUTOINCREMENTを使用する通常のテーブルごとに、sqlite_sequenceテーブルに単一の行があります。テーブルの名前（sqlite_master.nameに表示される）はsqlite_sequence.mainフィールドにあり、そのテーブルに挿入された最大の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;はsqlite_sequence.seqフィールドにあります。 AUTOINCREMENTテーブルの新しい自動生成整数主キーは、そのテーブルのsqlite_sequence.seqフィールドより大きいことが保証されています。 AUTOINCREMENTテーブルのsqlite_sequence.seqフィールドがすでに最大の整数値（9223372036854775807）にある場合、自動生成された整数のプライマリを使用してそのテーブルに新しい行を追加しようとすると、&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULLで&lt;/a&gt;失敗します。エラー。sqlite_sequence.seqフィールドは、新しいエントリがAUTOINCREMENTテーブルに挿入されると、必要に応じて自動的に更新されます。AUTOINCREMENTテーブルのsqlite_sequence行は、テーブルが削除されると自動的に削除されます。AUTOINCREMENTテーブルの更新時にAUTOINCREMENTテーブルのsqlite_sequence行が存在しない場合は、新しいsqlite_sequence行が作成されます。AUTOINCREMENTテーブルのsqlite_sequence.seq値が手動で整数以外の値に設定されていて、その後にAUTOINCREMENTテーブルを挿入または更新しようとした場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="f02c79b70988445eed051dee5ef879c5abc0fcef" translate="yes" xml:space="preserve">
          <source>There is a single row of the dbstat table for each page in the database file. Freelist pages, the lock page, and pointer-map pages of the database file do not appear in the dbstat virtual table.</source>
          <target state="translated">dbstat テーブルには、データベース ファイル内の各ページに対して 1 行の行があります。データベースファイルのフリーリストページ、ロックページ、ポインタマップページは、dbstat仮想テーブルには表示されません。</target>
        </trans-unit>
        <trans-unit id="aad819f0714ba351410884e15d9171da8c02d268" translate="yes" xml:space="preserve">
          <source>There is also a &quot;.once -e&quot; command which works similarly, except that it names the temporary file with a &quot;.txt&quot; suffix so that the default text editor for the system will be invoked, instead of the default spreadsheet.</source>
          <target state="translated">.once -e&quot; コマンドもありますが、これは一時ファイルの名前に &quot;.txt&quot; という接尾辞を付けて、デフォルトのスプレッドシートではなく、システムのデフォルトのテキストエディタが起動されるようにすることを除いては、同様に動作します。</target>
        </trans-unit>
        <trans-unit id="d689365d69d51f44124dabea5ed23d15cbc239dd" translate="yes" xml:space="preserve">
          <source>There is also a function for computing the Wagner edit distance or the Levenshtein distance between a pattern and a word. This function is exposed as spellfix1_editdist(X,Y). The edit distance function returns the &quot;cost&quot; of converting X into Y. Some transformations cost more than others. Changing one vowel into a different vowel, for example is relatively cheap, as is doubling a constant, or omitting the second character of a double-constant. Other transformations or more expensive. The idea is that the edit distance function returns a low cost for words that are similar and a higher cost for words that are further apart. In this implementation, the maximum cost of any single-character edit (delete, insert, or substitute) is 100, with lower costs for some edits (such as transforming vowels).</source>
          <target state="translated">また、パターンと単語の間の Wagner edit distance や Levenshtein distance を計算する関数もあります。この関数は spellfix1_editdist(X,Y)という名前で公開されています。この関数は、X を Y に変換する際の「コスト」を返します。たとえば、ある母音を別の母音に変えるのは比較的安価ですし、定数を 2 倍にしたり、二重定数の二文字目を省略したりするのと同じです。その他の変換やより高価です。これは、編集距離関数が、似ている単語に対しては低いコストを返し、さらに離れている単語に対しては高いコストを返すという考え方である。この実装では、1文字の編集(削除、挿入、置換)の最大コストは100であり、いくつかの編集(母音の変換など)ではコストが低くなります。</target>
        </trans-unit>
        <trans-unit id="8f729e8ad1be217b3b85bb1dbd08e4580826f423" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode for the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; that allows an application to query the powersafe overwrite property for a database file.</source>
          <target state="translated">また、アプリケーションがデータベースファイルのpowersafe overwriteプロパティをクエリできるようにする&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）の&lt;/a&gt;新しい&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt;オペコードもあります。</target>
        </trans-unit>
        <trans-unit id="d5d98dc46e0aff9a749813616cdf742a9f8913ea" translate="yes" xml:space="preserve">
          <source>There is also an SQL function that can be used to load extensions: &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension(X,Y)&lt;/a&gt;. It works just like the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C interface.</source>
          <target state="translated">拡張機能のロードに使用できるSQL関数&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（X、Y）もあり&lt;/a&gt;ます。&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt; Cインターフェースと同じように機能します。</target>
        </trans-unit>
        <trans-unit id="043cd14b86c980f673cef92a152d79c2c6e3cf2c" translate="yes" xml:space="preserve">
          <source>There is always a default VFS. The legacy interfaces &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; always use the default VFS. The new interface for creating database connections, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, allows you to specify which VFS you want to use by name.</source>
          <target state="translated">常にデフォルトのVFSがあります。従来のインターフェース&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;と&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）は&lt;/a&gt;常にデフォルトのVFSを使用します。データベース接続を作成するための新しいインターフェース&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;を使用すると、使用するVFSを名前で指定できます。</target>
        </trans-unit>
        <trans-unit id="a75d63f61cb222d77eadc6074711ab25e460df12" translate="yes" xml:space="preserve">
          <source>There is always one VFS which is the default VFS. On unix systems, the &quot;unix&quot; VFS comes up as the default and on windows it is &quot;win32&quot;. If no other actions are taken, new database connections will make use of the default VFS.</source>
          <target state="translated">デフォルトのVFSは常に1つです。unixシステムでは、&quot;unix&quot; VFSがデフォルトで、Windowsでは &quot;win32 &quot;です。他に何もしなければ、新しいデータベース接続はデフォルトのVFSを使用します。</target>
        </trans-unit>
        <trans-unit id="a07e87b2dfc85be098248de6c63083968b9cc2a5" translate="yes" xml:space="preserve">
          <source>There is an additional quasi-persistent &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; file and &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; shared memory file associated with each database, which can make SQLite less appealing for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;.</source>
          <target state="translated">追加の準永続的な「 &lt;code&gt;-wal&lt;/code&gt; 」ファイルと「 &lt;code&gt;-shm&lt;/code&gt; 」共有メモリファイルが各データベースに関連付けられているため、SQLiteを&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイル形式&lt;/a&gt;として使用するのに魅力がなくなります。</target>
        </trans-unit>
        <trans-unit id="6c15ef6d2dec509f5afb1c6ad236607cae0e66e0" translate="yes" xml:space="preserve">
          <source>There is an assortment of sqlite3_bind routines used to assign values to wildcards in a prepared SQL statement. Unbound wildcards are interpreted as NULLs. Bindings are not reset by sqlite3_reset(). But wildcards can be rebound to new values after an sqlite3_reset().</source>
          <target state="translated">準備されたSQL文のワイルドカードに値を代入するために使用されるsqlite3_bindルーチンがあります。束縛されていないワイルドカードはNULLとして解釈されます。バインドはsqlite3_reset()によってリセットされません。しかし、ワイルドカードはsqlite3_reset()の後で新しい値にリバウンドすることができます。</target>
        </trans-unit>
        <trans-unit id="1cba197f7f4cf87333685b6d55dd8ea7d285abdf" translate="yes" xml:space="preserve">
          <source>There is an implied &quot;&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&quot; instruction inserted at the very end of every program. So a jump past the last instruction of the program is the same as executing &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;.</source>
          <target state="translated">すべてのプログラムの最後に暗黙の「&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0 &quot;命令が挿入されています。したがって、プログラムの最後の命令を通過するジャンプは、&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;を実行することと同じです。</target>
        </trans-unit>
        <trans-unit id="16ef4ec82cf13cdae86f5bf01316c19576909f0f" translate="yes" xml:space="preserve">
          <source>There is an unofficial and unsanctioned Git clone of this repository at &lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqliteに&lt;/a&gt;、このリポジトリの非公式で認可されていないGitクローンがあります。</target>
        </trans-unit>
        <trans-unit id="bea5c372cd0bf0b6a49c619c32079d5921e4aed3" translate="yes" xml:space="preserve">
          <source>There is another, deprecated, method for invoking the optimize operation using a SELECT statement. New code should use statements similar to the INSERT above to optimize FTS structures.</source>
          <target state="translated">SELECT文を使用して最適化処理を実行するための別の、非推奨の方法があります。新しいコードでは、FTS構造を最適化するために上記のINSERTと同様のステートメントを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="b085a1ad6ab5d12c0b0eb9f325abf631b21418bf" translate="yes" xml:space="preserve">
          <source>There is no &quot;CREATE TEMP VIRTUAL TABLE&quot; statement. To create a temporary virtual table, add the &quot;temp&quot; schema before the virtual table name.</source>
          <target state="translated">CREATE TEMP VIRTUAL TABLE」文はありません。一時的な仮想テーブルを作成するには、仮想テーブル名の前に &quot;temp &quot;スキーマを追加します。</target>
        </trans-unit>
        <trans-unit id="f17db4bcecd606fe4d51c30c972432fc774cef49" translate="yes" xml:space="preserve">
          <source>There is no RESERVED lock on the corresponding database file.</source>
          <target state="translated">対応するデータベース・ファイルには、RESERVEDEDロックはありません。</target>
        </trans-unit>
        <trans-unit id="e99ed00de2d6f07769da563a3ed2aa8bf01a7e2e" translate="yes" xml:space="preserve">
          <source>There is no agreement on what the C datatype for a UTF-16 string should be. Therefore, SQLite uses a generic type of void* to refer to UTF-16 strings. Client software can cast the void* to whatever datatype is appropriate for their system.</source>
          <target state="translated">UTF-16文字列のCデータ型はどうあるべきかについては合意がありません。そのため、SQLiteではUTF-16文字列を参照するために一般的な型のvoid*を使用しています。クライアントソフトウェアは、システムに適したデータ型にvoid*をキャストすることができます。</target>
        </trans-unit>
        <trans-unit id="c505515229e6ccfbb2128baeaa4350ad9e337f7c" translate="yes" xml:space="preserve">
          <source>There is no conflicting row in this case. The results of invoking the sqlite3changeset_conflict() API are undefined.</source>
          <target state="translated">この場合、競合する行はありません。sqlite3changeset_conflict()APIを呼び出した結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="a04b936246a75ee50e5104c87c5e5c3bc05ae139" translate="yes" xml:space="preserve">
          <source>There is no pre-defined release cycle. Releases occur when there is a critical mass of feature enhancements and/or bug fixes. Historically, releases have occurred about 5 or 6 times per year. Users of SQLite pick up new releases from the website on an as-needed basis.</source>
          <target state="translated">事前に定義されたリリースサイクルはありません。リリースは、機能強化やバグ修正がクリティカルな量に達したときに発生します。歴史的に、リリースは年に5、6回程度行われてきました。SQLite のユーザーは、必要に応じてウェブサイトから新しいリリースを入手します。</target>
        </trans-unit>
        <trans-unit id="dd71d330015524aacf28e91f9c23458da952387d" translate="yes" xml:space="preserve">
          <source>There is no reserved lock on the main database file.</source>
          <target state="translated">メインデータベースファイルには予約ロックがありません。</target>
        </trans-unit>
        <trans-unit id="7df732794b7961185fb08c11a413b1539639964a" translate="yes" xml:space="preserve">
          <source>There is no support for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Changes to virtual tables are not captured.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;はサポートされていません。仮想テーブルへの変更はキャプチャされません。</target>
        </trans-unit>
        <trans-unit id="11d7bfeb25e84c6d1e9766a1abf1f94079350c5e" translate="yes" xml:space="preserve">
          <source>There is normally one row per index, with the index identified by the name in the sqlite_stat1.idx column. The sqlite_stat1.tbl column is the name of the table to which the index belongs. In each such row, the sqlite_stat.stat column will be a string consisting of a list of integers followed by zero or more arguments. The first integer in this list is the approximate number of rows in the index. (The number of rows in the index is the same as the number of rows in the table, except for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.) The second integer is the approximate number of rows in the index that have the same value in the first column of the index. The third integer is the number number of rows in the index that have the same value for the first two columns. The N-th integer (for N&amp;gt;1) is the estimated average number of rows in the index which have the same value for the first N-1 columns. For a K-column index, there will be K+1 integers in the stat column. If the index is unique, then the last integer will be 1.</source>
          <target state="translated">通常、インデックスごとに1つの行があり、インデックスはsqlite_stat1.idx列の名前で識別されます。sqlite_stat1.tbl列は、インデックスが属するテーブルの名前です。このような各行のsqlite_stat.stat列は、整数のリストとそれに続く0個以上の引数で構成される文字列になります。このリストの最初の整数は、インデックス内のおおよその行数です。（インデックスの行数は、&lt;a href=&quot;partialindex&quot;&gt;部分的なインデックス&lt;/a&gt;を除いて、テーブルの行数と同じです。。）2番目の整数は、インデックスの最初の列に同じ値を持つインデックスの行の概数です。3番目の整数は、最初の2つの列に同じ値を持つインデックス内の行の数です。N番目の整数（N&amp;gt; 1の場合）は、最初のN-1列と同じ値を持つインデックスの行の推定平均数です。K列のインデックスの場合、stat列にはK + 1の整数があります。インデックスが一意の場合、最後の整数は1になります。</target>
        </trans-unit>
        <trans-unit id="c9c3e6d9120e8e4bfa41b1d6a3111f7343cb6f19" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative malloc()/free() implementations without having to modify any core SQLite code.</source>
          <target state="translated">コアとなる SQLite のコードを変更することなく、アプリケーションが代替の malloc()/free()実装を定義できるようにするコンパイル時のオプションが追加されました。</target>
        </trans-unit>
        <trans-unit id="f62ae2b58bd448bf76ec1b9c9d9ded56906eaff1" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative mutex implementations without having to modify any core SQLite code.</source>
          <target state="translated">これにより、アプリケーションはSQLiteのコアコードを変更することなく、代替のミューテックス実装を定義することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="b1cb6058c59ace1351641df9e565cb12b51e73fe" translate="yes" xml:space="preserve">
          <source>There is one entry in the %_node table for each R*Tree node. An R*Tree node consists of one or more entries that are proximate to one another. The nodes of an R*Tree for a tree. All nodes other than the root have an entry in the %_parent shadow table that identifies the parent node. Each entry in an R*Tree has a rowid. The %_rowid shadow table maps entry rowids to the node that contains that entry.</source>
          <target state="translated">各 R*Tree ノードには %_node テーブルに 1 つのエントリがあります。R*Tree ノードは、互いに近接している 1 つ以上のエントリで構成されます。ツリーの R*Tree のノード。ルート以外のすべてのノードには、親ノードを識別する %_parent シャドウ・テーブルのエントリがあります。R*Tree の各エントリには rowid があります。rowid シャドウ・テーブルは、エントリの行 ID をそのエントリを含むノードにマップします。</target>
        </trans-unit>
        <trans-unit id="91aa566670abb0466fc190ee57ffd69271a7af7c" translate="yes" xml:space="preserve">
          <source>There is one exception to the previous paragraph: when a row is inserted, updated or deleted, if one or more of its primary key columns contain a NULL value, no record of the change is made.</source>
          <target state="translated">行の挿入、更新、削除の際に、1つ以上の主キー列にNULL値が含まれている場合、変更の記録は作成されません。</target>
        </trans-unit>
        <trans-unit id="545885bb104866881571615fd910604fef6b0f44" translate="yes" xml:space="preserve">
          <source>There is one important difference between ON UPDATE foreign key actions and SQL triggers. An ON UPDATE action is only taken if the values of the parent key are modified so that the new parent key values are not equal to the old. For example:</source>
          <target state="translated">外部キーのON UPDATEアクションとSQLトリガーの間には、1つの重要な違いがあります。ON UPDATEアクションは、親キーの値が変更され、新しい親キーの値が古い値と一致しない場合にのみ実行されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="67f4030e1b4840bae9054c024eff72bf5cb42560" translate="yes" xml:space="preserve">
          <source>There is one other subtle difference between &quot;docid&quot; and the normal SQLite aliases for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete values to two or more aliases of the rowid column, SQLite writes the rightmost of such values specified in the INSERT or UPDATE statement to the database. However, assigning a non-NULL value to both the &quot;docid&quot; and one or more of the SQLite rowid aliases when inserting or updating an FTS table is considered an error. See below for an example.</source>
          <target state="translated">docid&quot; と rowid 列の通常の SQLite エイリアスとの間には、もう一つ微妙な違いがあります。通常、INSERT 文または UPDATE 文が rowid 列の 2 つ以上のエイリアスに個別の値を割り当てる場合、SQLite は INSERT 文または UPDATE 文で指定された値のうち、一番右の値をデータベースに書き込みます。ただし、FTS テーブルを挿入または更新する際に、&quot;docid&quot; と SQLite rowid の 1 つ以上のエイリアスの両方に NULL でない値を代入すると、エラーとみなされます。以下の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="f856aedc1ad69cfc42357d4bdb200682208f50ab" translate="yes" xml:space="preserve">
          <source>There is only one sorter object, so there are no instructions to open or close it. It is opened automatically when needed, and it is closed when the VDBE program halts.</source>
          <target state="translated">ソーターオブジェクトは1つしかないので、開閉の指示はない。必要に応じて自動的に開き、VDBEプログラムが停止すると閉じます。</target>
        </trans-unit>
        <trans-unit id="6e50e0d48c576b86d93a31befcc02f54e14b5267" translate="yes" xml:space="preserve">
          <source>There is the extra operation of &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; which, though automatic by default, is still something that application developers need to be mindful of.</source>
          <target state="translated">&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;の追加操作がありますが、これはデフォルトでは自動ですが、アプリケーション開発者が注意する必要があるものです。</target>
        </trans-unit>
        <trans-unit id="62428f96be095192850e1858e6283c21fe02dd48" translate="yes" xml:space="preserve">
          <source>There is write permission on the directory containing the database so that the &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files can be created.</source>
          <target state="translated">&lt;code&gt;-shm&lt;/code&gt; および &lt;code&gt;-wal&lt;/code&gt; ファイルを作成できるように、データベースを含むディレクトリに書き込み権限があります。</target>
        </trans-unit>
        <trans-unit id="5b6352389dca7ff834f53599bb4e1238c6a257d8" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">ブロックされた接続によって登録された最大1つのロック解除通知コールバックがある場合があります。ブロックされた接続にすでに登録されたロック解除通知コールバックがあるときにsqlite3_unlock_notify（）が呼び出された場合、新しいコールバックが古いコールバックを置き換えます。 2番目の引数としてNULLポインターを指定してsqlite3_unlock_notify（）を呼び出すと、既存のロック解除通知コールバックはキャンセルされます。ブロックされた接続のロック解除通知コールバックは、&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;を使用してブロックされた接続を閉じることによってキャンセルすることもできます。</target>
        </trans-unit>
        <trans-unit id="474f04800d7576cb1df432f79959d44e97ec88c4" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">ブロックされた接続によって登録された最大1つのロック解除通知コールバックがある場合があります。ブロックされた接続にすでに登録されたロック解除通知コールバックがあるときにsqlite3_unlock_notify（）が呼び出された場合、新しいコールバックが古いコールバックを置き換えます。 2番目の引数としてNULLポインターを指定してsqlite3_unlock_notify（）を呼び出すと、既存のロック解除通知コールバックはキャンセルされます。ブロックされた接続のロック解除通知コールバックは、&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;を使用してブロックされた接続を閉じることによってキャンセルすることもできます。</target>
        </trans-unit>
        <trans-unit id="51e2e6b0569ca6a8c745966ed3e14378d13e60a9" translate="yes" xml:space="preserve">
          <source>There might be merge conflicts. In other words, it might be that the changes from (2) to (3) are incompatible with the changes from (1) to (4). In that case, the maintainer will have to manually resolve the conflicts. Hopefully conflicts will not come up that often. Conflicts are less likely to occur when the private edits are kept to a minimum.</source>
          <target state="translated">マージコンフリクトがあるかもしれません。言い換えれば、(2)から(3)への変更と(1)から(4)への変更が矛盾しているかもしれません。その場合、メンテナは手動でコンフリクトを解決しなければなりません。うまくいけば、コンフリクトはそれほど頻繁には起こらないでしょう。プライベートな編集を最小限に抑えれば、コンフリクトは起こりにくくなります。</target>
        </trans-unit>
        <trans-unit id="c1f15675484de7896b9f4cea6917b5f96c0a2c61" translate="yes" xml:space="preserve">
          <source>There might be one or more &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; objects open and in use on the virtual table instance and perhaps even on the row of the virtual table when the xUpdate method is invoked. The implementation of xUpdate must be prepared for attempts to delete or modify rows of the table out from other existing cursors. If the virtual table cannot accommodate such changes, the xUpdate method must return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">1つ以上の&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;オブジェクトが開いていて、仮想テーブルインスタンスで使用されている可能性があります。また、xUpdateメソッドが呼び出されたときに仮想テーブルの行で使用されている可能性もあります。xUpdateの実装は、他の既存のカーソルからテーブルの行を削除または変更する試みに備えて準備する必要があります。仮想テーブルがそのような変更に対応できない場合、xUpdateメソッドは&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;返す必要があります。</target>
        </trans-unit>
        <trans-unit id="f17a65d092891c67c0c7c0d6ffba57606e51c65a" translate="yes" xml:space="preserve">
          <source>There must be a read-lock on the database (either a transaction must be started or there must be an open cursor) before executing this instruction.</source>
          <target state="translated">この命令を実行する前に、データベースにリードロックがなければなりません(トランザクションが開始されているか、オープンカーソルがなければなりません)。</target>
        </trans-unit>
        <trans-unit id="838abced0ca5c629a232ce0c8ac382dc2a5201e9" translate="yes" xml:space="preserve">
          <source>There must be no overlap in the bands of rowids for the various tables in a union-vtab.</source>
          <target state="translated">union-vtab内の様々なテーブルのrowidsのバンドが重複していてはいけません。</target>
        </trans-unit>
        <trans-unit id="2f109c8b1d1e372963703dc38ccb68fefa2006aa" translate="yes" xml:space="preserve">
          <source>There must be no overlapping rowid ranges in the rows returned by the SQL statement. It is an error if there are.</source>
          <target state="translated">SQL 文によって返される行には、重複する rowid の範囲があってはなりません。重複している場合はエラーになります。</target>
        </trans-unit>
        <trans-unit id="af3fe573da439b499f0025edd3eb3c7aa3d7e8cd" translate="yes" xml:space="preserve">
          <source>There must not be a write transaction open on schema S of database connection D.</source>
          <target state="translated">データベース接続DのスキーマS上に書き込みトランザクションが開いていてはいけません。</target>
        </trans-unit>
        <trans-unit id="3d41940c4561987aa3b448b06598e8d1c6472839" translate="yes" xml:space="preserve">
          <source>There should be exactly one call to sqlite3_backup_finish() for each successful call to sqlite3_backup_init().</source>
          <target state="translated">sqlite3_backup_init()の呼び出しが成功するたびに、sqlite3_backup_finish()を1回だけ呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="9cf5a0f0e6851073aea7c635470af127d9d907d8" translate="yes" xml:space="preserve">
          <source>There were reports that SQLite did not perform as well on an indexed table. This test was recently added to disprove those rumors. It is true that SQLite is not as fast at creating new index entries as the other engines (see Test 6 below) but its overall speed is still better.</source>
          <target state="translated">SQLiteがインデックス付きのテーブルではパフォーマンスが低いという報告がありました。このテストはそれらの噂を反証するために最近追加されました。確かにSQLiteは他のエンジンほど新しいインデックスエントリを作成する速度は速くありませんが(下記のテスト6を参照)、全体的な速度はまだ優れています。</target>
        </trans-unit>
        <trans-unit id="7cdb3ca5132a0c3bc86c19fe3abd0889729f8701" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">これらのAPIは、ライブラリが&lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; Cプリプロセッサシンボルでコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="04c8e718505dcab90cfc6233e2bd22375b7164d1" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">これらのAPIは、ライブラリが&lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; Cプリプロセッサシンボルでコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="c0bacb531ef3c143611b93d8575c5722c7b86645" translate="yes" xml:space="preserve">
          <source>These action code values signify what kind of operation is to be authorized. The 3rd and 4th parameters to the authorization callback function will be parameters or NULL depending on which of these codes is used as the second parameter. The 5th parameter to the authorizer callback is the name of the database (&quot;main&quot;, &quot;temp&quot;, etc.) if applicable. The 6th parameter to the authorizer callback is the name of the inner-most trigger or view that is responsible for the access attempt or NULL if this access attempt is directly from top-level SQL code.</source>
          <target state="translated">これらのアクションコードの値は、どのような操作を認可するかを示します。認証コールバック関数の3番目と4番目のパラメータは、2番目のパラメータとしてどのコードを使用するかに応じてパラメータかNULLになります。認可コールバック関数の5番目のパラメータは、データベースの名前(該当する場合は &quot;main&quot;、&quot;temp &quot;など)です。認証先コールバックの6番目のパラメータは、アクセス試行の原因となった最上位のトリガまたはビューの名前、またはアクセス試行がトップレベルSQLコードから直接行われている場合はNULLです。</target>
        </trans-unit>
        <trans-unit id="08d99679f060455eb057ba3c4cf117bfe450c567" translate="yes" xml:space="preserve">
          <source>These and other similar syntax restrictions are described in the text.</source>
          <target state="translated">これらおよび他の類似の構文の制限については、本文に記載されています。</target>
        </trans-unit>
        <trans-unit id="373ccf29c36481aabf98cf8d5fcf341e72288794" translate="yes" xml:space="preserve">
          <source>These are just a few of the benefits of using SQLite as an application file format &amp;mdash; the benefits that seem most likely to improve the user experience for applications like OpenOffice. Other applications might benefit from SQLite in different ways. See the &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt; document for additional ideas.</source>
          <target state="translated">これらは、SQLiteをアプリケーションファイル形式として使用する利点のほんの一部です。OpenOfficeなどのアプリケーションのユーザーエクスペリエンスを向上させる可能性が最も高いと思われる利点です。他のアプリケーションは、SQLiteからさまざまな方法で恩恵を受けるかもしれません。その他のアイデアについては、&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイル形式の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="840704459c7bebebba604f0b7c84031cf12ac5c7" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">これらは、&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob（）の&lt;/a&gt;ようなルーチンへの最後の引数として渡されるデストラクタの特別な値です。デストラクタの引数がSQLITE_STATICの場合、コンテンツポインタは定数であり、変更されることはありません。破壊する必要はありません。SQLITE_TRANSIENT値は、コンテンツが近い将来変更される可能性があり、SQLiteが戻る前にコンテンツの独自のプライベートコピーを作成する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="3097b1326f3eb788f48bb5e49292e793f88d3f73" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">これらは、&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob（）の&lt;/a&gt;ようなルーチンへの最後の引数として渡されるデストラクタの特別な値です。デストラクタの引数がSQLITE_STATICの場合、コンテンツポインタは定数であり、変更されることはありません。破壊する必要はありません。SQLITE_TRANSIENT値は、コンテンツが近い将来変更される可能性があり、SQLiteが戻る前にコンテンツの独自のプライベートコピーを作成する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="49e507a42bf99a1526a38fb0d00d4e955eae6280" translate="yes" xml:space="preserve">
          <source>These are the eight locks supported:</source>
          <target state="translated">これらはサポートされている8つのロックです。</target>
        </trans-unit>
        <trans-unit id="d61de6a061e0e9a67e085323db1a55d01abf6a99" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">これらはVFSの実装に便利なユーティリティルーチンで、データベースファイルが特定のクエリパラメータを含むURIであるかどうかをチェックし、その場合はそのクエリパラメータの値を取得します。</target>
        </trans-unit>
        <trans-unit id="0ae1c1d92689387597a221cbf4a8586463c0d9b8" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">これらのビット値は、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;インターフェースの3番目のパラメーター、および&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;メソッドの4番目のパラメーターで使用するためのものです。</target>
        </trans-unit>
        <trans-unit id="091c1cd775270574b7e8fe92576bddaa3dc774e3" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">これらのビット値は、&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;インターフェースの3番目のパラメーター、および&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;メソッドの4番目のパラメーターで使用するためのものです。</target>
        </trans-unit>
        <trans-unit id="7379d4e0ce4f6675fd9028087eadfa8eb7ff4976" translate="yes" xml:space="preserve">
          <source>These changes in the default behavior of SQLite are not a compatibility break. All legacy database files continue to be readable and writable by newer versions of SQLite, and all newly created database files continue to be readable and writable by legacy versions of the SQLite library. The only thing that is changing is some default settings. This should result in a performance increase for many applications.</source>
          <target state="translated">これらのSQLiteのデフォルト動作の変更は、互換性の問題ではありません。すべてのレガシーデータベースファイルは、新しいバージョンの SQLite で読み書き可能な状態を維持し、新しく作成されたデータベースファイルは、レガシーバージョンの SQLite ライブラリで読み書き可能な状態を維持します。変更されるのは、いくつかのデフォルト設定だけです。これにより、多くのアプリケーションでパフォーマンスが向上するはずです。</target>
        </trans-unit>
        <trans-unit id="f8b6f19362cf61de4d3d35983b38ffd9c2bbd4d6" translate="yes" xml:space="preserve">
          <source>These constant define integer codes that represent the various text encodings supported by SQLite.</source>
          <target state="translated">これらの定数は、SQLite でサポートされている様々なテキストエンコーディングを表す整数コードを定義しています。</target>
        </trans-unit>
        <trans-unit id="28ee7781baba8510621fd94348e40d728944ee20" translate="yes" xml:space="preserve">
          <source>These constants are codes for each of those types.</source>
          <target state="translated">これらの定数は、それぞれのタイプのコードです。</target>
        </trans-unit>
        <trans-unit id="5d678085fc410906abd9ecdf3f62895a2bdac8f9" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">これらの定数は&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;によって返され、評価されるSQLステートメントの&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;モードが&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装に通知されます。</target>
        </trans-unit>
        <trans-unit id="8d5af3a6c05bd2fcca2c0f972b2fd66256957f31" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">これらの定数は&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;によって返され、評価されるSQLステートメントの&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;モードが&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装に通知されます。</target>
        </trans-unit>
        <trans-unit id="e0814beadd7fffeacf97b8f77142e48bc418e590" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;インターフェースの2番目の引数として渡すことができる使用可能な整数「動詞」です。</target>
        </trans-unit>
        <trans-unit id="ee8e50c4c247f1789de616c3122fcd5d75fef481" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;インターフェースの2番目の引数として渡すことができる使用可能な整数「動詞」です。</target>
        </trans-unit>
        <trans-unit id="5685826d85b489c4a4722d59958f312636d778f9" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースの最初の引数として渡すことができる使用可能な整数構成オプションです。</target>
        </trans-unit>
        <trans-unit id="cb2ae78ea5b1ae2e5bfc176e2229bcc4eaa83a74" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースの最初の引数として渡すことができる使用可能な整数構成オプションです。</target>
        </trans-unit>
        <trans-unit id="b8b83f50bcee4d621ab3350b27ae006d83053d8d" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースの2番目の引数として渡すことができる使用可能な整数構成オプションです。</target>
        </trans-unit>
        <trans-unit id="bfdbb7c579979335802d5433a0c4351cc2e64138" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースの2番目の引数として渡すことができる使用可能な整数構成オプションです。</target>
        </trans-unit>
        <trans-unit id="adcbc56bb51ca533b4d845770250da49d6cb92e5" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control（）の&lt;/a&gt;最初の引数として使用される有効なオペレーションコードパラメーターです。</target>
        </trans-unit>
        <trans-unit id="c9e83fda514b191357ca2f8a433c34a6a2561552" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control（）の&lt;/a&gt;最初の引数として使用される有効なオペレーションコードパラメーターです。</target>
        </trans-unit>
        <trans-unit id="01b7633fac6735c207dc2ef793e2ed3c159bf015" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;インターフェースに3番目のパラメーターとして渡される「チェックポイントモード」のすべての有効な値を定義します。これらの各チェックポイントモードの意味の詳細については、&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）の&lt;/a&gt;ドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="1096d3bfc46b56a1b04a8f3fad11f5e8e55e3e9f" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;インターフェースに3番目のパラメーターとして渡される「チェックポイントモード」のすべての有効な値を定義します。これらの各チェックポイントモードの意味の詳細については、&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）の&lt;/a&gt;ドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="f262688fc8aaf9f38b8c78556de1b6829b6de723" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;インターフェースの「prepFlags」パラメーターに渡すことができるさまざまなフラグを定義します。</target>
        </trans-unit>
        <trans-unit id="52a7e652cd3193b904625b47cf5fc5b4007943d0" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;および&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;インターフェースの「prepFlags」パラメーターに渡すことができるさまざまなフラグを定義します。</target>
        </trans-unit>
        <trans-unit id="f4779c39284f3e8f89de78b1cf22bb4300a2dde2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;を使用して実行時に下げることができるさまざまなパフォーマンス制限を定義します。さまざまな制限の意味の概要を以下に示します。追加情報は&lt;a href=&quot;limits&quot;&gt;、SQLiteの制限に&lt;/a&gt;あります。</target>
        </trans-unit>
        <trans-unit id="dc33a9fdf99d3b7c3164b92212d61358e77ed2b2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;../limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;を使用して実行時に下げることができるさまざまなパフォーマンス制限を定義します。さまざまな制限の意味の概要を以下に示します。追加情報は&lt;a href=&quot;../limits&quot;&gt;、SQLiteの制限に&lt;/a&gt;あります。</target>
        </trans-unit>
        <trans-unit id="2d9ca50401c9fc616026596d32b3930da4b3846d" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;トレースロジックを使用して監視できるイベントのクラスを識別します。&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（D、M、X、P）&lt;/a&gt;のM引数は、次の定数の1つ以上のOR結合された組み合わせです。トレースコールバックの最初の引数は、次の定数のいずれかです。</target>
        </trans-unit>
        <trans-unit id="ed407cdd4869216425bae7d051975b3bcd0fdc3b" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;トレースロジックを使用して監視できるイベントのクラスを識別します。&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（D、M、X、P）&lt;/a&gt;のM引数は、次の定数の1つ以上のOR結合された組み合わせです。トレースコールバックの最初の引数は、次の定数のいずれかです。</target>
        </trans-unit>
        <trans-unit id="14266cc61d0db9a630a6d1107d408c2e2d4959a8" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;#SQLITE_ANY&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2（）&lt;/a&gt;の4番目の引数として&lt;a href=&quot;#SQLITE_ANY&quot;&gt;優先テキストエンコーディング&lt;/a&gt;とORで結合されます。</target>
        </trans-unit>
        <trans-unit id="4e4c2775c736d10a648ec5f64c5240681b8a597f" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;c_any&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;、&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;、または&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2（）&lt;/a&gt;の4番目の引数として&lt;a href=&quot;c_any&quot;&gt;優先テキストエンコーディング&lt;/a&gt;とORで結合されます。</target>
        </trans-unit>
        <trans-unit id="d452c2a5987467cef42875b2093f98a07b801c06" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">これらの関数（まとめて「関数作成ルーチン」と呼ばれます）は、SQL関数または集約を追加するため、または既存のSQL関数または集約の動作を再定義するために使用されます。3つの &quot;sqlite3_create_function *&quot;ルーチンの唯一の違いは、2番目のパラメーター（作成される関数の名前）に期待されるテキストエンコーディングと、アプリケーションデータポインターのデストラクターコールバックの有無です。関数sqlite3_create_window_function（）は似ていますが、&lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;集計ウィンドウ関数に&lt;/a&gt;必要な追加のコールバック関数を提供できます。</target>
        </trans-unit>
        <trans-unit id="460bddf16e550adbe692fb026aea91fd5c1a8fa1" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">これらの関数（まとめて「関数作成ルーチン」と呼ばれます）は、SQL関数または集約を追加するため、または既存のSQL関数または集約の動作を再定義するために使用されます。3つの &quot;sqlite3_create_function *&quot;ルーチンの唯一の違いは、2番目のパラメーター（作成される関数の名前）に期待されるテキストエンコーディングと、アプリケーションデータポインターのデストラクターコールバックの有無です。関数sqlite3_create_window_function（）は似ていますが、&lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;集計ウィンドウ関数に&lt;/a&gt;必要な追加のコールバック関数を提供できます。</target>
        </trans-unit>
        <trans-unit id="f5aa8ee7f5d5dcd17c7a255e21fd6564afc6f3cb" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;../datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">これらの関数は、最初の引数として指定された&lt;a href=&quot;sqlite3&quot;&gt;データベース接続に&lt;/a&gt;関連付けられた&lt;a href=&quot;../datatype3#collation&quot;&gt;照合を&lt;/a&gt;追加、削除、または変更します。</target>
        </trans-unit>
        <trans-unit id="ed63a5a7289985766e806cdca8d318ceb652f682" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">これらの関数は、最初の引数として指定された&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続に&lt;/a&gt;関連付けられた&lt;a href=&quot;datatype3#collation&quot;&gt;照合を&lt;/a&gt;追加、削除、または変更します。</target>
        </trans-unit>
        <trans-unit id="e828096ae0ef377574b3a48a5e49c755665e8418" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">これらの関数は&lt;a href=&quot;capi3ref&quot;&gt;非推奨です&lt;/a&gt;。古いコードとの下位互換性を維持するために、これらの関数は引き続きサポートされています。ただし、新しいアプリケーションでは、これらの関数の使用を避ける必要があります。プログラマがこれらの関数を回避するように促すために、それらが何をするかについては説明しません。</target>
        </trans-unit>
        <trans-unit id="a53c5b52778acbd5177be1207d66b6e2855a89a9" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">これらの関数は&lt;a href=&quot;experimental&quot;&gt;非推奨です&lt;/a&gt;。古いコードとの下位互換性を維持するために、これらの関数は引き続きサポートされています。ただし、新しいアプリケーションでは、これらの関数の使用を避ける必要があります。プログラマがこれらの関数を回避するように促すために、それらが何をするかについては説明しません。</target>
        </trans-unit>
        <trans-unit id="20e0d52fc906194ab3c598ecb16113bb7e27244d" translate="yes" xml:space="preserve">
          <source>These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values. If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved. An example of where this might be useful is in a regular-expression matching function. The compiled version of the regular expression can be stored as metadata associated with the pattern string. Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.</source>
          <target state="translated">これらの関数は、(非集約的な)SQL関数がメタデータを引数値に関連付けるために使用することができます。クエリ実行中に同じ値が同じSQL関数の複数回の呼び出しに渡された場合、状況によっては関連付けられたメタデータが保存されることがあります。これが有用な例として、正規表現のマッチング関数があります。正規表現のコンパイルされたバージョンを、パターン文字列に関連付けられたメタデータとして保存することができます。パターン文字列が同じである限り、コンパイルされた正規表現を同じ関数の複数回の呼び出しで再利用することができます。</target>
        </trans-unit>
        <trans-unit id="6522a9f48ff48fe82ed5d5982cbd1db9ee5c56d5" translate="yes" xml:space="preserve">
          <source>These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.</source>
          <target state="translated">これらの関数は、0000-01-01 00:00:00~9999-12-31 23:59:59の間の日付(ジュリアン日番号1721059.5~5373484.5)でのみ動作します。この範囲外の日付については、これらの関数の結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="c8d304d80363d45f2a701bb02157d9c038cae0f9" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">これらの関数は、準備されたステートメントでホストパラメーターに値をバインドするために使用される関数の&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;パラメーターバインド&lt;/a&gt;ファミリーと非常によく似ています。追加情報については、&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQLパラメーターの&lt;/a&gt;資料を参照してください。</target>
        </trans-unit>
        <trans-unit id="b317ce2527b91fa298699867534154a11da36ac3" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">これらの関数は、準備されたステートメントでホストパラメーターに値をバインドするために使用される関数の&lt;a href=&quot;bind_blob&quot;&gt;パラメーターバインド&lt;/a&gt;ファミリーと非常によく似ています。追加情報については、&lt;a href=&quot;bind_blob&quot;&gt;SQLパラメーターの&lt;/a&gt;資料を参照してください。</target>
        </trans-unit>
        <trans-unit id="ab78522f9e6af4ebb0a819cdbba908125b1aa9de" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトのxFileControlメソッドと&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェイスのオペコードです。</target>
        </trans-unit>
        <trans-unit id="a38e815d9a81f8a36563593031ac86d208aff3ef" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトのxFileControlメソッドと&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェイスのオペコードです。</target>
        </trans-unit>
        <trans-unit id="ea60b84c9e9ef3033a276fcbd9184666b77d102f" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxAccessメソッドの3番目のパラメーターとして使用できます。それらは、xAccessメソッドが探しているアクセス許可の種類を決定します。SQLITE_ACCESS_EXISTSでは、xAccessメソッドはファイルが存在するかどうかを確認するだけです。SQLITE_ACCESS_READWRITEを使用すると、xAccessメソッドは、指定されたディレクトリが読み取りと書き込みの両方が可能かどうかを確認します（つまり、ディレクトリ内でファイルを追加、削除、名前変更できるかどうか）。SQLITE_ACCESS_READWRITE定数は現在、&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマで&lt;/a&gt;のみ使用されていますただし、これはSQLiteの将来のリリースで変更される可能性があります。SQLITE_ACCESS_READを使用すると、xAccessメソッドはファイルが読み取り可能かどうかを確認します。SQLITE_ACCESS_READ定数は現在使用されていませんが、SQLiteの将来のリリースで使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="311aa59e56c46be41f406ebc987fb4c56872151d" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxAccessメソッドの3番目のパラメーターとして使用できます。それらは、xAccessメソッドが探しているアクセス許可の種類を決定します。SQLITE_ACCESS_EXISTSでは、xAccessメソッドはファイルが存在するかどうかを確認するだけです。SQLITE_ACCESS_READWRITEを使用すると、xAccessメソッドは、指定されたディレクトリが読み取りと書き込みの両方が可能かどうかを確認します（つまり、ディレクトリ内でファイルを追加、削除、名前変更できるかどうか）。SQLITE_ACCESS_READWRITE定数は現在、&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマで&lt;/a&gt;のみ使用されていますただし、これはSQLiteの将来のリリースで変更される可能性があります。SQLITE_ACCESS_READを使用すると、xAccessメソッドはファイルが読み取り可能かどうかを確認します。SQLITE_ACCESS_READ定数は現在使用されていませんが、SQLiteの将来のリリースで使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8e30f4610e846824046fcc55a5610ab368656db0" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">これらの整数定数はxShmLock法によって許容される様々なロック操作を定義&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methodsを&lt;/a&gt;。以下は、xShmLockメソッドへのフラグの唯一の有効な組み合わせです。</target>
        </trans-unit>
        <trans-unit id="63c61207725308cbbebcd362e48d34bfbbce9eff" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">これらの整数定数はxShmLock法によって許容される様々なロック操作を定義&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methodsを&lt;/a&gt;。以下は、xShmLockメソッドへのフラグの唯一の有効な組み合わせです。</target>
        </trans-unit>
        <trans-unit id="46be45c61b7407297842f2bf5d770d15053c4ac4" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status（）&lt;/a&gt;によって返されるさまざまな実行時ステータスパラメータを指定します。</target>
        </trans-unit>
        <trans-unit id="9d8a64fd442238eaa787788726abe76149b5cae0" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;status&quot;&gt;sqlite3_status（）&lt;/a&gt;によって返されるさまざまな実行時ステータスパラメータを指定します。</target>
        </trans-unit>
        <trans-unit id="1dd74d0b7bde7f62eaef94d29d31baa355fc24b9" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">これらのインターフェースは、以前に&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;から取得したsqlite3_strオブジェクトにコンテンツを追加します。</target>
        </trans-unit>
        <trans-unit id="f4c68aa7a2ee53b8d7d01e966ec46bd4df66a0b8" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">これらのインターフェースは、以前に&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;から取得したsqlite3_strオブジェクトにコンテンツを追加します。</target>
        </trans-unit>
        <trans-unit id="37d07c864bda5264afb416a4db651631968abf92" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">これらのインターフェースは、Windowsでのみ使用できます。&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インターフェースが関連付けられている値を設定するために使用される&lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;又は&lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; typeパラメータの値に応じて、Z値に、変数。以前の値を&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;で解放するには、zValueパラメータをNULLにする必要があります。 NULL以外の値は、使用前に&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリにコピーされます。&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インタフェース戻り&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;、成功を示すために&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERRORを&lt;/a&gt;タイプがサポートされていない場合、または&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;メモリを割り当てることができなかった場合。&lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;変数の値は、WinRTやUWPなど、その概念が存在しないWin32のサブプラットフォーム上の現在のディレクトリの代わりとして機能することを目的としています。&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt;と&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt;インターフェースは、文字列パラメータを除いsqlite3_win32_set_directoryインタフェースと全く同じで、それぞれ、UTF-8やUTF-16でなければならない振る舞います。</target>
        </trans-unit>
        <trans-unit id="e3077cf84285d5d0c77e1603a1b1cc3c809c60d7" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">これらのインターフェースは、Windowsでのみ使用できます。&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インターフェースが関連付けられている値を設定するために使用される&lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;又は&lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; typeパラメータの値に応じて、Z値に、変数。以前の値を&lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;で解放するには、zValueパラメータをNULLにする必要があります。 NULL以外の値は、使用前に&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリにコピーされます。&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インタフェース戻り&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;、成功を示すために&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERRORを&lt;/a&gt;タイプがサポートされていない場合、または&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;メモリを割り当てることができなかった場合。&lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;変数の値は、WinRTやUWPなど、その概念が存在しないWin32のサブプラットフォーム上の現在のディレクトリの代わりとして機能することを目的としています。&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt;と&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt;インターフェースは、文字列パラメータを除いsqlite3_win32_set_directoryインタフェースと全く同じで、それぞれ、UTF-8やUTF-16でなければならない振る舞います。</target>
        </trans-unit>
        <trans-unit id="bf73a94780de490a8f9c02eb38be04e9aad9c703" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">これらのインターフェースは、SQLiteが&lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt;コンパイル時オプションを使用してコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="2573d74316b2beb50fe8b93933b238b687b3e25f" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">これらのインターフェースは、SQLiteが&lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt;コンパイル時オプションを使用してコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="1dfbcb8f183f59b84e1cdc3c799c0026a4da7b1c" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">これらのインターフェイスは、SQLiteのパフォーマンスに関するランタイムステータス情報を取得し、オプションでさまざまな上限基準点をリセットするために使用されます。最初の引数は、測定する特定のパラメーターの整数コードです。認識される整数コードの形式は&lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS _...&lt;/a&gt;です。パラメータの現在の値は* pCurrentに返されます。記録された最高値は* pHighwaterに返されます。 resetFlagがtrueの場合、最大レコード値は* pHighwaterが書き込まれた後にリセットされます。一部のパラメーターは最高値を記録しません。これらのパラメーターの場合、* pHighwaterには何も書き込まれず、resetFlagは無視されます。その他のパラメーターは、現在の値ではなく、最高水準点のみを記録します。これらの後者のパラメーターについては、* pCurrentには何も書き込まれません。</target>
        </trans-unit>
        <trans-unit id="9a006bb7b78680fec3ca85a8c33bf946ae2c290a" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">これらのインターフェイスは、SQLiteのパフォーマンスに関するランタイムステータス情報を取得し、オプションでさまざまな上限基準点をリセットするために使用されます。最初の引数は、測定する特定のパラメーターの整数コードです。認識される整数コードの形式は&lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS _...&lt;/a&gt;です。パラメータの現在の値は* pCurrentに返されます。記録された最高値は* pHighwaterに返されます。 resetFlagがtrueの場合、最大レコード値は* pHighwaterが書き込まれた後にリセットされます。一部のパラメーターは最高値を記録しません。これらのパラメーターの場合、* pHighwaterには何も書き込まれず、resetFlagは無視されます。その他のパラメーターは、現在の値ではなく、最高水準点のみを記録します。これらの後者のパラメーターについては、* pCurrentには何も書き込まれません。</target>
        </trans-unit>
        <trans-unit id="7a26bb8a6cfb99470baf86e2f9ba8d8fe1ec3d04" translate="yes" xml:space="preserve">
          <source>These interfaces can be used by an application to monitor how much memory SQLite is using. The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently in use and the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; returns the maximum instantaneous memory usage. Neither routine includes the overhead associated with the memory allocator. These routines are provided for use by the application. SQLite never invokes them itself. So if the application is providing its own memory allocation subsystem, it can omit these interfaces if desired.</source>
          <target state="translated">アプリケーションはこれらのインターフェースを使用して、SQLiteが使用しているメモリの量を監視できます。&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;リターン現在使用されているメモリのバイト数と&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;瞬間最大メモリ使用量を返します。どちらのルーチンにも、メモリアロケータに関連するオーバーヘッドは含まれていません。これらのルーチンは、アプリケーションで使用するために提供されています。 SQLiteがそれ自体を呼び出すことはありません。したがって、アプリケーションが独自のメモリ割り当てサブシステムを提供している場合、必要に応じてこれらのインターフェイスを省略できます。</target>
        </trans-unit>
        <trans-unit id="5d867180f3b3d1ed5572faf6a624799c6449d787" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">これらのインターフェースは、&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;、&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;、および&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; Cプリプロセッサマクロと同じ情報を提供しますが、ヘッダーファイルではなくライブラリに関連付けられています。慎重なプログラマーは、アプリケーションにassert（）ステートメントを含めて、これらのインターフェイスから返された値がヘッダー内のマクロと一致することを確認し、アプリケーションがライブラリとヘッダーファイルに一致するようにコンパイルされるようにします。</target>
        </trans-unit>
        <trans-unit id="7e7f85933d01fbbc2719e5dc64309e8e175f6d5d" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">これらのインターフェースは、&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;、&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;、および&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; Cプリプロセッサマクロと同じ情報を提供しますが、ヘッダーファイルではなくライブラリに関連付けられています。慎重なプログラマーは、アプリケーションにassert（）ステートメントを含めて、これらのインターフェイスから返された値がヘッダー内のマクロと一致することを確認し、アプリケーションがライブラリとヘッダーファイルに一致するようにコンパイルされるようにします。</target>
        </trans-unit>
        <trans-unit id="8f3967be8dcb65457d2a35a639ddbcd4e8748853" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">これらのインターフェイスは、&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトの現在のステータスを返します。</target>
        </trans-unit>
        <trans-unit id="9f4d86f27a761f3cf1b6a9d1b51464453bd7acc2" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">これらのインターフェイスは、&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトの現在のステータスを返します。</target>
        </trans-unit>
        <trans-unit id="c1a8d7ae768abbd8bdb6f16b4e0e326ba78812f7" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">これらのマクロはWindowsでのみ使用できます。これらは、&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インターフェイスへのtype引数に許可される値を定義します。</target>
        </trans-unit>
        <trans-unit id="a687dbdbbc158f7b1d8247c45af66df0ad45cf41" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">これらのマクロはWindowsでのみ使用できます。これらは、&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インターフェイスへのtype引数に許可される値を定義します。</target>
        </trans-unit>
        <trans-unit id="8efdced9c4da4c580aa62b3a5a3c4685a1b1ed67" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">これらのマクロは、&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;インターフェースのさまざまなオプションを定義し、&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;実装がそれらの動作をカスタマイズおよび最適化するために使用できます。</target>
        </trans-unit>
        <trans-unit id="648697ac8bc614b007ee6a86dba8449e42be0af2" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">これらのマクロは、&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;インターフェースのさまざまなオプションを定義し、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブルの&lt;/a&gt;実装がそれらの動作をカスタマイズおよび最適化するために使用できます。</target>
        </trans-unit>
        <trans-unit id="e2c086e3788cfb99a6897d54171eed03d73b01e8" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">これらのマクロは、&lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []。opフィールドに許可される値を定義しました。各値は、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;を使用するクエリのwHERE句の制約条件の一部である演算子を表します。</target>
        </trans-unit>
        <trans-unit id="fa39882fd7522d6ac624eca8d9d3a80dde9e04fa" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">これらのマクロは、&lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []。opフィールドに許可される値を定義しました。各値は、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;を使用するクエリのwHERE句の制約条件の一部である演算子を表します。</target>
        </trans-unit>
        <trans-unit id="cef481ad6fa7db18e075879f04ed74ee515d6f8c" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">これらのメソッドは結果コードを返しません。エラーが発生した場合、その事実は&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトに記録され、その後の&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）の&lt;/a&gt;呼び出しで回復できます。</target>
        </trans-unit>
        <trans-unit id="cf9638bb05ccc82e92352f4c91e50e88181ed764" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">これらのメソッドは結果コードを返しません。エラーが発生した場合、その事実は&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトに記録され、その後の&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）の&lt;/a&gt;呼び出しで回復できます。</target>
        </trans-unit>
        <trans-unit id="c8abab119f90d9828a9a200b591657ce6dda56d7" translate="yes" xml:space="preserve">
          <source>These methods provide the virtual table implementation an opportunity to implement nested transactions. They are always optional and will only be called in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23) and later.</source>
          <target state="translated">これらのメソッドは、仮想テーブルの実装に、ネストされたトランザクションを実装する機会を提供します。これらは常にオプションであり、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;バージョン3.7.7&lt;/a&gt;（2011-06-23）以降でのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="46bde550196023cbdbd528e902d936fa4e39c988" translate="yes" xml:space="preserve">
          <source>These operations are described in detail in section</source>
          <target state="translated">これらの操作については、セクション</target>
        </trans-unit>
        <trans-unit id="8a581a47ac4eaa711b3f420b4ba4930e1f71a44b" translate="yes" xml:space="preserve">
          <source>These options are obsolete and should not be used by new code. They are retained for backwards compatibility but are now no-ops.</source>
          <target state="translated">これらのオプションは廃止されたものであり、新しいコードでは使用しないでください。これらは下位互換性のために保持されていますが、現在はノーオプションとなっています。</target>
        </trans-unit>
        <trans-unit id="559388a0d9af9b6cbe52d397cd3542b5b1c78fdd" translate="yes" xml:space="preserve">
          <source>These pages are intended to be precise and detailed specification. For a tutorial introduction, see instead:</source>
          <target state="translated">これらのページは、正確で詳細な仕様を意図しています。チュートリアルの紹介は、代わりに参照してください。</target>
        </trans-unit>
        <trans-unit id="6abb0e63f8d45e8d38ed1d32dbd7bc6804598807" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">これらのパラメーターとその意味は、予告なしに変更されることがあります。これらの値はテスト専用です。アプリケーションでは、これらのパラメーターまたは&lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;インターフェースを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="572f36fd8fcb5b2b9a0c163c10706d2d9c69fa95" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">これらのパラメーターとその意味は、予告なしに変更されることがあります。これらの値はテスト専用です。アプリケーションでは、これらのパラメーターまたは&lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;インターフェースを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="f8a0b86303fc051c5fd0870031ccb3460d4da0f7" translate="yes" xml:space="preserve">
          <source>These pragmas are only available in builds using non-standard compile-time options.</source>
          <target state="translated">これらのプラグマは、非標準のコンパイル時オプションを使用したビルドでのみ利用可能です。</target>
        </trans-unit>
        <trans-unit id="7d1b3b12b0e1a81b824764e591a7c4f5ca02302c" translate="yes" xml:space="preserve">
          <source>These pragmas are used for testing SQLite and are not recommended for use in application programs.</source>
          <target state="translated">これらのプラグマはSQLiteのテストに使用され、アプリケーションプログラムでの使用は推奨されていません。</target>
        </trans-unit>
        <trans-unit id="995493d489d94b8be4b015e9bc63ccee86968693" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">これらのプリプロセッサマクロは、&lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;インターフェイスに関連付けられたカウンター値を示す整数コードを定義します。さまざまなカウンタの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="45f1f746bd34bc0ce563d83def09a125c5bf05c1" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">これらのプリプロセッサマクロは、&lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;インターフェイスに関連付けられたカウンター値を示す整数コードを定義します。さまざまなカウンタの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2638c6822db8d54f4bd5ddffbdd3a5cd063ac265" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">これらのルーチンは非推奨です。ここで説明するルーチンの代わりに&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;インターフェースを使用してください。</target>
        </trans-unit>
        <trans-unit id="79eec12a37e6ba999a536376578f3d7f9c0f472e" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">これらのルーチンは非推奨です。ここで説明するルーチンの代わりに&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;インターフェースを使用してください。</target>
        </trans-unit>
        <trans-unit id="88da5c4ccf3f13c2b355a0a8cea0eee5123dacc4" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">これらのルーチンは、SQL関数と集計を実装するxFuncまたはxFinalコールバックによって使用されます。詳細については、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9ac11b77df30733555a1b785ff3b36747aa22425" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">これらのルーチンは、SQL関数と集計を実装するxFuncまたはxFinalコールバックによって使用されます。詳細については、&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;および&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a645fc58a9b80b5d58439099cf576c18383cf676" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">これらのルーチンは、新しい&lt;a href=&quot;#sqlite3_module&quot;&gt;仮想テーブルモジュール&lt;/a&gt;名を登録するために使用されます。モジュール名は、モジュールを使用して新しい&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;を作成する前、およびモジュールに既存の&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;を使用する前に登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="947d0c2cba6cd0b29a7af62bdccba7526d0c92de" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">これらのルーチンは、新しい&lt;a href=&quot;module&quot;&gt;仮想テーブルモジュール&lt;/a&gt;名を登録するために使用されます。モジュール名は、モジュールを使用して新しい&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;を作成する前、およびモジュールに既存の&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;を使用する前に登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="52698fd9d4ddf179ee30cea3431e78d27c345761" translate="yes" xml:space="preserve">
          <source>These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing. These routines return 1 if the input string appears to be a complete SQL statement. A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement. Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator. Whitespace and comments that follow the final semicolon are ignored.</source>
          <target state="translated">これらのルーチンは、現在入力されているテキストが完全なSQL文を形成しているように見えるかどうか、またはテキストをSQLiteに送信して解析する前に追加入力が必要かどうかを判断するために、コマンドライン入力時に便利です。これらのルーチンは、入力文字列が完全なSQL文であるように見える場合に1を返します。文の最後がセミコロントークンで終わり、整形されたCREATE TRIGGER文の接頭辞ではない場合、文は完全であると判断されます。文字列リテラルや引用符で囲まれた識別子名やコメントの中に埋め込まれたセミコロンは独立したトークンではないので(それらは埋め込まれたトークンの一部です)、文のターミネータとしてカウントされません。最後のセミコロンに続く空白やコメントは無視されます。</target>
        </trans-unit>
        <trans-unit id="1eee207918e3686e6a6a0aff77d6f8f4cd324299" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;../printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;../printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;../printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;../printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;../printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">これらのルーチンは、標準Cライブラリの「printf（）」ファミリーの関数に似ています。これらのルーチンは、標準ライブラリprintf（）からの一般的なフォーマットオプションのほとんどと、いくつかの追加の非標準フォーマット（&lt;a href=&quot;../printf#percentq&quot;&gt;％q&lt;/a&gt;、&lt;a href=&quot;../printf#percentq&quot;&gt;％Q&lt;/a&gt;、&lt;a href=&quot;../printf#percentw&quot;&gt;％w&lt;/a&gt;、および&lt;a href=&quot;../printf#percentz&quot;&gt;％z&lt;/a&gt;）を理解します。詳細については、&lt;a href=&quot;../printf&quot;&gt;組み込みのprintf（）の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5d6ce4df9ede9c6a9b8604117d8eeec42326da1e" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">これらのルーチンは、標準Cライブラリの「printf（）」ファミリーの関数に似ています。これらのルーチンは、標準ライブラリprintf（）からの一般的なフォーマットオプションのほとんどと、いくつかの追加の非標準フォーマット（&lt;a href=&quot;printf#percentq&quot;&gt;％q&lt;/a&gt;、&lt;a href=&quot;printf#percentq&quot;&gt;％Q&lt;/a&gt;、&lt;a href=&quot;printf#percentw&quot;&gt;％w&lt;/a&gt;、および&lt;a href=&quot;printf#percentz&quot;&gt;％z&lt;/a&gt;）を理解します。詳細については、&lt;a href=&quot;printf&quot;&gt;組み込みのprintf（）の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d695b797410a06f75931294f55b67ec9c439fcc7" translate="yes" xml:space="preserve">
          <source>These routines do not parse the SQL statements thus will not detect syntactically incorrect SQL.</source>
          <target state="translated">これらのルーチンはSQL文を解析しないので、構文的に正しくないSQLは検出されません。</target>
        </trans-unit>
        <trans-unit id="7531da5fcda9441742ab989cffc3d5a7ea0da49d" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトからタイプ、サイズ、コンテンツ情報を抽出します。保護されたsqlite3_valueオブジェクトは、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;と&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;実装にパラメーター情報を渡すために使用されます。</target>
        </trans-unit>
        <trans-unit id="c79baca34267204233cef0f72fa563f702ea3b9b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトからタイプ、サイズ、コンテンツ情報を抽出します。保護されたsqlite3_valueオブジェクトは、&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;と&lt;a href=&quot;../vtab&quot;&gt;仮想テーブルの&lt;/a&gt;実装にパラメーター情報を渡すために使用されます。</target>
        </trans-unit>
        <trans-unit id="b6356562f1a7ea967d47e4aa35dbd596cfeb17ce" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value *&lt;/a&gt;パラメータを提供したSQL関数と同じスレッドから呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="ea74f3659cddc5ce0c6b4fa5c6b8b6ea6fcf9692" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;value&quot;&gt;sqlite3_value *&lt;/a&gt;パラメータを提供したSQL関数と同じスレッドから呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="a54537ed3c843a1d7c75c98c519dd12715dd5904" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread in which the SQL function is running.</source>
          <target state="translated">これらのルーチンは、SQL関数が実行されているのと同じスレッドから呼び出されなければなりません。</target>
        </trans-unit>
        <trans-unit id="aea4f6b4200dc559c39531008b13c73c4dca39ea" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">これらのルーチンは、filename引数で指定されたSQLiteデータベースファイルを開きます。 filename引数は、sqlite3_open（）およびsqlite3_open_v2（）の場合はUTF-8として、sqlite3_open16（）の場合はネイティブバイトオーダーのUTF-16として解釈されます。&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルは通常、エラーが発生した場合でも、* ppDbで返されます。唯一の例外は、SQLiteが&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクトを保持するメモリを割り当てることができない場合、&lt;a href=&quot;#sqlite3&quot;&gt;SQLite3&lt;/a&gt;オブジェクトへのポインタの代わりにNULLが* ppDbに書き込まれることです。データベースが正常に開かれた（または作成された）場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;が返されます。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;ルーチンを使用して、sqlite3_open（）ルーチンのいずれかが失敗した後のエラーの英語の説明を取得できます。</target>
        </trans-unit>
        <trans-unit id="24814302ce83d408ddc70164757005571a98a1af" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">これらのルーチンは、filename引数で指定されたSQLiteデータベースファイルを開きます。 filename引数は、sqlite3_open（）およびsqlite3_open_v2（）の場合はUTF-8として、sqlite3_open16（）の場合はネイティブバイトオーダーのUTF-16として解釈されます。&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルは通常、エラーが発生した場合でも、* ppDbで返されます。唯一の例外は、SQLiteが&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクトを保持するメモリを割り当てることができない場合、&lt;a href=&quot;sqlite3&quot;&gt;SQLite3&lt;/a&gt;オブジェクトへのポインタの代わりにNULLが* ppDbに書き込まれることです。データベースが正常に開かれた（または作成された）場合、&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;が返されます。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;または&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;ルーチンを使用して、sqlite3_open（）ルーチンのいずれかが失敗した後のエラーの英語の説明を取得できます。</target>
        </trans-unit>
        <trans-unit id="4cb0a6ed5fd628702f759fa88fc57a08522ef219" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの特定の結果列の起点であるデータベース、テーブル、およびテーブル列を判別する手段を提供します。データベース、テーブル、または列の名前は、UTF-8またはUTF-16文字列として返すことができます。 _database_ルーチンはデータベース名を返し、_table_ルーチンはテーブル名を返し、origin_ルーチンは列名を返します。返された文字列は、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;を使用して破棄されるまで、またはステートメントが特定の実行のために&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;への最初の呼び出しによって自動的に再準備されるまで、または同じ情報が別のエンコーディングで再度要求されるまで有効です。</target>
        </trans-unit>
        <trans-unit id="6747cec9622a96ae1091ed2adc2461d962bf2710" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの特定の結果列の起点であるデータベース、テーブル、およびテーブル列を判別する手段を提供します。データベース、テーブル、または列の名前は、UTF-8またはUTF-16文字列として返すことができます。 _database_ルーチンはデータベース名を返し、_table_ルーチンはテーブル名を返し、origin_ルーチンは列名を返します。返された文字列は、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;を使用して破棄されるまで、またはステートメントが特定の実行のために&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;への最初の呼び出しによって自動的に再準備されるまで、または同じ情報が別のエンコーディングで再度要求されるまで有効です。</target>
        </trans-unit>
        <trans-unit id="723ec7b5764e01bb470a171ac81db6f1bccacf01" translate="yes" xml:space="preserve">
          <source>These routines provide access to the set of SQL language keywords recognized by SQLite. Applications can uses these routines to determine whether or not a specific identifier needs to be escaped (for example, by enclosing in double-quotes) so as not to confuse the parser.</source>
          <target state="translated">これらのルーチンは、SQLite が認識する SQL 言語キーワードのセットへのアクセスを提供します。アプリケーションはこれらのルーチンを使用して、パーサを混乱させないように特定の識別子をエスケープする必要があるかどうかを判断することができます(例えば、ダブルクォートで囲むなど)。</target>
        </trans-unit>
        <trans-unit id="c63151a5ae56c785b897a0325e0c6f8aa37ea7fb" translate="yes" xml:space="preserve">
          <source>These routines provide direct access to the version of the Wagner edit-distance function that allows for application-defined weights on edit operations. The first two forms of this function compare pattern P against word W and return the edit distance. In the first function, the langid is assumed to be 0 and in the second, the langid is given by the L parameter. The third form of this function reloads edit distance coefficients from the table named by T.</source>
          <target state="translated">これらのルーチンは、編集操作にアプリケーション定義の重み付けを可能にする Wagner edit-distance 関数のバージョンへの直接アクセスを提供します。この関数の最初の2つの形式は、パターンPと単語Wを比較し、編集距離を返します。最初の関数では,langidは0と仮定され,2番目の関数では,langidはLパラメータによって与えられます.この関数の第3の形式は,Tで指定されたテーブルから編集距離係数を再読み込みします.</target>
        </trans-unit>
        <trans-unit id="6ece6463ac2989d7eff64fecae9f2305cb234cc2" translate="yes" xml:space="preserve">
          <source>These routines register callback functions that can be used for tracing and profiling the execution of SQL statements.</source>
          <target state="translated">これらのルーチンは、SQL文の実行のトレースやプロファイリングに使用できるコールバック関数を登録します。</target>
        </trans-unit>
        <trans-unit id="40a118423314c412a0ead5a2681ebf518ed77f67" translate="yes" xml:space="preserve">
          <source>These routines return 0 if the statement is incomplete. If a memory allocation fails, then SQLITE_NOMEM is returned.</source>
          <target state="translated">これらのルーチンは、ステートメントが不完全な場合は 0 を返します。メモリの割り当てに失敗した場合は、SQLITE_NOMEMが返されます。</target>
        </trans-unit>
        <trans-unit id="324c17666cfb5119bcfea9a10a94bbaee6b00643" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">これらのルーチンは、クエリの現在の結果行の単一の列に関する情報を返します。いずれの場合も、最初の引数は評価&lt;a href=&quot;#sqlite3_stmt&quot;&gt;され&lt;/a&gt;ている準備済みステートメント（&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;またはそのバリアントの1つから返された&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt * &lt;/a&gt;）へのポインターであり、2番目の引数は情報を返す必要がある列のインデックスです。結果セットの左端の列のインデックスは0です。結果の列の数は、&lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;を使用して決定できます。</target>
        </trans-unit>
        <trans-unit id="5435456a1f2380e65f87b371b45464ea838877ae" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">これらのルーチンは、クエリの現在の結果行の単一の列に関する情報を返します。いずれの場合も、最初の引数は評価&lt;a href=&quot;stmt&quot;&gt;され&lt;/a&gt;ている準備済みステートメント（&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;またはそのバリアントの1つから返された&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt * &lt;/a&gt;）へのポインターであり、2番目の引数は情報を返す必要がある列のインデックスです。結果セットの左端の列のインデックスは0です。結果の列の数は、&lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;を使用して決定できます。</target>
        </trans-unit>
        <trans-unit id="86c424b8734fe7ddecb01d35115c043c61c06f29" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの結果セットの特定の列に割り当てられた名前を返します。sqlite3_column_name（）インターフェースはゼロで終了するUTF-8文字列へのポインターを返し、sqlite3_column_name16（）はゼロで終了するUTF-16文字列へのポインターを返します。最初のパラメーターは、&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントを実装する&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。2番目のパラメーターは列番号です。左端の列は番号0です。</target>
        </trans-unit>
        <trans-unit id="c92c0a5a51a4b6415e4465e481831e591f5adbb3" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの結果セットの特定の列に割り当てられた名前を返します。sqlite3_column_name（）インターフェースはゼロで終了するUTF-8文字列へのポインターを返し、sqlite3_column_name16（）はゼロで終了するUTF-16文字列へのポインターを返します。最初のパラメーターは、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントを実装する&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。2番目のパラメーターは列番号です。左端の列は番号0です。</target>
        </trans-unit>
        <trans-unit id="5de2bfd9e6d919b373b4c3d1b80a7310909f2955" translate="yes" xml:space="preserve">
          <source>These routines should return true if the mutex in their argument is held or not held, respectively, by the calling thread.</source>
          <target state="translated">これらのルーチンは、引数に含まれるミューテックスが呼び出されたスレッドによって保持されている場合と保持されていない場合、それぞれ真を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="afa365b8dc52497e4284392ecbb9654dff91e29b" translate="yes" xml:space="preserve">
          <source>These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB.</source>
          <target state="translated">これらのルーチンは、最初の JSON 引数が整形されていない場合や、PATH 引数が整形されていない場合、またはいずれかの引数が BLOB である場合にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="040db3ed336324c99d540be07030ca6b73dfe1d9" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt;ポインターと整数の列番号の代わりに単一の&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトポインターを取ることを除いて、対応する&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;列アクセス関数と&lt;/a&gt;同じように機能します。</target>
        </trans-unit>
        <trans-unit id="8f8d6c3e862ca519958d58c8125484847b89c711" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt;ポインターと整数の列番号の代わりに単一の&lt;a href=&quot;value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトポインターを取ることを除いて、対応する&lt;a href=&quot;column_blob&quot;&gt;列アクセス関数と&lt;/a&gt;同じように機能します。</target>
        </trans-unit>
        <trans-unit id="95d389aedaf4f8ce85f9804703017919fd80feca" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトでのみ機能します。&lt;a href=&quot;#sqlite3_value&quot;&gt;保護さ&lt;/a&gt;れていないsqlite3_valueでこれらのルーチンを使用しようとしても、スレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="7a8ed928c1fb3dc4a20d3be2fb5cfe01bd35f70b" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトでのみ機能します。&lt;a href=&quot;value&quot;&gt;保護さ&lt;/a&gt;れていないsqlite3_valueでこれらのルーチンを使用しようとしても、スレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="cf9c078687c96682c6a85bb7a67b91a68491a0f8" translate="yes" xml:space="preserve">
          <source>These static mutexes are reserved for use internally by SQLite and should not be used by the application. The static mutexes are all non-recursive.</source>
          <target state="translated">これらの静的ミューテックスは SQLite 内部で使用するために予約されており、アプリケーションでは使用してはいけません。これらの静的ミューテックスはすべて再帰的ではありません。</target>
        </trans-unit>
        <trans-unit id="a11e17b224413c41480316935dad79b1f586c189" translate="yes" xml:space="preserve">
          <source>These techniques are designed to aid in understanding the core SQLite library itself, not applications that merely use SQLite.</source>
          <target state="translated">これらのテクニックは、単にSQLiteを使用しているだけのアプリケーションではなく、コアとなるSQLiteライブラリ自体を理解するのに役立つように設計されています。</target>
        </trans-unit>
        <trans-unit id="7f9968558d6525a5e69fdd942a06f1a35ab390ef" translate="yes" xml:space="preserve">
          <source>These tests are on a relatively small (approximately 14 megabyte) database. They do not measure how well the database engines scale to larger problems.</source>
          <target state="translated">これらのテストは、比較的小さな(約14メガバイト)データベースを対象としています。これらのテストは、データベースエンジンがどれだけ大きな問題に対応できるかを測定するものではありません。</target>
        </trans-unit>
        <trans-unit id="f97df2bc02e2ab86d912a22d332def150459caf8" translate="yes" xml:space="preserve">
          <source>These tests did not attempt to measure multi-user performance or optimization of complex queries involving multiple joins and subqueries.</source>
          <target state="translated">これらのテストでは、複数のジョインやサブクエリを含む複雑なクエリのマルチユーザー・パフォーマンスや最適化を測定しようとはしていません。</target>
        </trans-unit>
        <trans-unit id="dd70aa0fe10c02751ca4c43bd10acab99e561495" translate="yes" xml:space="preserve">
          <source>These three ways of committing a transaction correspond to the DELETE, TRUNCATE, and PERSIST settings, respectively, of the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;.</source>
          <target state="translated">トランザクションをコミットするこれらの3つの方法は、それぞれ、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_modeプラグマ&lt;/a&gt;のDELETE、TRUNCATE、およびPERSIST設定に対応しています。</target>
        </trans-unit>
        <trans-unit id="8f79d49bdd4e3aeeeb4789bde61715a9a01e430c" translate="yes" xml:space="preserve">
          <source>These two rules describe how the query planner for SQLite works as of this writing (2013-08-01). And the rules above will always be honored. However, future versions of SQLite might incorporate a better theorem prover that can find other cases where W&amp;rArr;X is true and thus may find more instances where partial indexes are useful.</source>
          <target state="translated">これらの2つのルールは、SQLiteのクエリプランナーがこの記事（2013-08-01）でどのように機能するかを説明しています。そして、上記のルールは常に守られます。ただし、SQLiteの将来のバージョンには、W&amp;rArr;Xがtrueである他のケースを見つけることができるより優れた定理証明機能が組み込まれる可能性があるため、部分インデックスが役立つインスタンスがさらに見つかる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c8fd956e215d583a512e53c2c78546d08e30ff46" translate="yes" xml:space="preserve">
          <source>Things That Can Go Wrong</source>
          <target state="translated">うまくいかないことがある</target>
        </trans-unit>
        <trans-unit id="42067c10086226bb2498180a8a023f3ac259d639" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">トリガープログラムの実行中にsqlite3_changes（）関数を実行すると、状況はさらに複雑になります。これは、プログラムが&lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes（）SQL関数を&lt;/a&gt;使用する場合、または他のコールバック関数がsqlite3_changes（）を直接呼び出す場合に発生する可能性があります。基本的に：</target>
        </trans-unit>
        <trans-unit id="53a7af1ec1bf96fe1cf7aeeb3a8a96e5b6a416b2" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">トリガープログラムの実行中にsqlite3_changes（）関数を実行すると、状況はさらに複雑になります。これは、プログラムが&lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes（）SQL関数を&lt;/a&gt;使用する場合、または他のコールバック関数がsqlite3_changes（）を直接呼び出す場合に発生する可能性があります。基本的に：</target>
        </trans-unit>
        <trans-unit id="774483139813d257b6024c3ca6cbcda75578301f" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a separate computer program. The original SQL text is source code. A prepared statement object is the compiled object code. All SQL must be converted into a prepared statement before it can be run.</source>
          <target state="translated">それぞれのSQL文を個別のコンピュータプログラムと考えてください。元のSQL文はソースコードです。準備された文オブジェクトは、コンパイルされたオブジェクトコードです。すべてのSQLは、実行する前に準備された文に変換されなければなりません。</target>
        </trans-unit>
        <trans-unit id="2f8cd345a6425d660448be637505c8f25ad1aef9" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a small computer program. The purpose of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is to compile that program into object code. The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is the object code. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface then runs the object code to get a result.</source>
          <target state="translated">各SQLステートメントを小さなコンピュータープログラムと考えてください。&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;の目的は、そのプログラムをオブジェクトコードにコンパイルすることです。&lt;a href=&quot;c3ref/stmt&quot;&gt;プリペアドステートメントは、&lt;/a&gt;オブジェクトコードです。次に&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;インターフェースはオブジェクトコードを実行して結果を取得します。</target>
        </trans-unit>
        <trans-unit id="cfafbb2da361739c04c43a8272cc38856e9c67a7" translate="yes" xml:space="preserve">
          <source>Third Improvement: Versioning</source>
          <target state="translated">3回目の改善。バージョニング</target>
        </trans-unit>
        <trans-unit id="865c9c12492c3442466282bf437772709b257a8a" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirstColumn() set iCol to -1).</source>
          <target state="translated">detail=none &quot;オプションで作成されたFTS5テーブルで使用した場合、このAPIは非常に遅くなる可能性があります。FTS5 テーブルが &quot;detail=none&quot; &quot;content=&quot; オプションのいずれかで作成された場合 (つまり、コンテンツレステーブルの場合)、この API は常に空のセットを繰り返し処理します (xPhraseFirstColumn()への呼び出しはすべて iCol を -1 に設定します)。</target>
        </trans-unit>
        <trans-unit id="ebf79b4cb55761477acdbbee63fd4654b2112a93" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option.</source>
          <target state="translated">このAPIは、&quot;detail=none &quot;または &quot;detail=column &quot;オプションで作成されたFTS5テーブルで使用すると、非常に遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="320a596dec5edeedf6c5c2728a533311ecff7379" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirst() set iCol to -1).</source>
          <target state="translated">このAPIは、&quot;detail=none &quot;または &quot;detail=column &quot;オプションで作成されたFTS5テーブルで使用すると、非常に遅くなる可能性があります。FTS5 テーブルが &quot;detail=none&quot; または &quot;detail=column&quot; および &quot;content=&quot; オプションのいずれかで作成されている場合 (つまり、コンテンツレステーブルの場合)、この API は常に空のセットを繰り返し処理します (xPhraseFirst()へのすべての呼び出しは iCol を -1 に設定します)。</target>
        </trans-unit>
        <trans-unit id="f65fb946e21f0df296308a1267bfc8d75459c36f" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always returns 0.</source>
          <target state="translated">このAPIは、&quot;detail=none &quot;または &quot;detail=column &quot;オプションで作成されたFTS5テーブルで使用すると、非常に遅くなる可能性があります。FTS5 テーブルが &quot;detail=none&quot; または &quot;detail=column&quot; と &quot;content=&quot; オプションのいずれかで作成された場合 (つまり、コンテンツレステーブルの場合)、この API は常に 0 を返します。</target>
        </trans-unit>
        <trans-unit id="43444bfacf757a80f8f09485afde0ead5f0a776e" translate="yes" xml:space="preserve">
          <source>This API function is used to query the FTS table for phrase iPhrase of the current query. Specifically, a query equivalent to:</source>
          <target state="translated">本 API 関数は、現在のクエリの phrase iPhrase を FTS テーブルに問い合わせるために使用する。具体的には、これに相当するクエリ。</target>
        </trans-unit>
        <trans-unit id="d89725045237fc9113c1fa0f974917002e582aec" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">このAPIは、ライブラリーがプリプロセッサーシンボル&lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUSが&lt;/a&gt;定義されてビルドされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="48dac83568aa304395644b3c39b1c1984d8ea7c3" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">このAPIは、ライブラリーがプリプロセッサーシンボル&lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUSが&lt;/a&gt;定義されてビルドされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="f548cc5880d8bc2ce8ab0c825c0274336bee682c" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">このAPIは、特定の名前と数のパラメーターを持つ関数のグローバルバージョンが存在することを確認します。このAPIが呼び出される前にそのような関数が存在しない場合、新しい関数が作成されます。新しい関数の実装により、常に例外がスローされます。そのため、新しい機能はそれ自体では何の役にも立ちません。その唯一の目的は、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;によってオーバーロードできるプレースホルダー関数になることです。</target>
        </trans-unit>
        <trans-unit id="8540f6a2004da77a77789ccfaf202735cf5c6ba1" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">このAPIは、特定の名前と数のパラメーターを持つ関数のグローバルバージョンが存在することを確認します。このAPIが呼び出される前にそのような関数が存在しない場合、新しい関数が作成されます。新しい関数の実装により、常に例外がスローされます。そのため、新しい機能はそれ自体では何の役にも立ちません。その唯一の目的は、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;によってオーバーロードできるプレースホルダー関数になることです。</target>
        </trans-unit>
        <trans-unit id="6ab96b1e97da69a025cb8ca96b99b710398cad45" translate="yes" xml:space="preserve">
          <source>This C-preprocess macro determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt; configuration setting. It defaults to 1 (on) which means that covering indices are used for full table scans where possible, in order to reduce I/O and improve performance. However, the use of a covering index for a full scan will cause results to appear in a different order from legacy, which could cause some (incorrectly-coded) legacy applications to break. Hence, the covering index scan option can be disabled at compile-time on systems that what to minimize their risk of exposing errors in legacy applications.</source>
          <target state="translated">このC-プリプロセスマクロは、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt;構成設定のデフォルト設定を決定します。デフォルトは1（オン）です。これは、I / Oを減らしてパフォーマンスを向上させるために、可能な場合は全表スキャンにカバーするインデックスが使用されることを意味します。ただし、フルスキャンにカバリングインデックスを使用すると、結果がレガシーとは異なる順序で表示されるため、一部の（正しくコーディングされていない）レガシーアプリケーションが破損する可能性があります。したがって、レガシーアプリケーションでエラーを公開するリスクを最小限に抑えるために、システムのコンパイル時にカバーインデックススキャンオプションを無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="9b6673eaea3893e3fceb60fe446b80a1ff19d0e8" translate="yes" xml:space="preserve">
          <source>This DELETE statement will remove every record from the &quot;examp&quot; table where the &quot;two&quot; column is less than 50. The code generated to do this is as follows:</source>
          <target state="translated">このDELETE文は、&quot;examp &quot;テーブルから &quot;two &quot;カラムが50未満のすべてのレコードを削除します。これを行うために生成されたコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b0bfab415a485beb9edddb8d5188d00815376867" translate="yes" xml:space="preserve">
          <source>This allows optimizations: (a) when P4==0 there is no need to test the RowSet object for P3, as it is guaranteed not to contain it, (b) when P4==-1 there is no need to insert the value, as it will never be tested for, and (c) when a value that is part of set X is inserted, there is no need to search to see if the same value was previously inserted as part of set X (only if it was previously inserted as part of some other set).</source>
          <target state="translated">これにより最適化が可能になります。(a)P4==0の場合、P3が含まれていないことが保証されているので、RowSetオブジェクトをテストする必要はありません。 (b)P4==-1の場合、値を挿入する必要はありません。</target>
        </trans-unit>
        <trans-unit id="e9de882f0fc5b21571717171f0fcc8e049f8f4b3" translate="yes" xml:space="preserve">
          <source>This allows separate database connections to share the same in-memory database. Of course, all database connections sharing the in-memory database need to be in the same process. The database is automatically deleted and memory is reclaimed when the last connection to the database closes.</source>
          <target state="translated">これにより、別々のデータベース接続が同じインメモリデータベースを共有することができます。もちろん、インメモリデータベースを共有するすべてのデータベース接続は、同じプロセスである必要があります。データベースへの最後の接続が終了すると、データベースは自動的に削除され、メモリは再利用されます。</target>
        </trans-unit>
        <trans-unit id="c92e98ecc01f031d3a1efe7cd735db9a008161b9" translate="yes" xml:space="preserve">
          <source>This article also uses the terms &quot;bytecode program&quot; and &quot;prepared statement&quot; interchangeably, as they are mostly the same thing.</source>
          <target state="translated">この記事では、&quot;バイトコードプログラム &quot;と &quot;準備されたステートメント &quot;という用語も、ほとんど同じものであるため、互換的に使用しています。</target>
        </trans-unit>
        <trans-unit id="a9af0cbe702f19f3f49888228ef0df406a0e5175" translate="yes" xml:space="preserve">
          <source>This article defines what the limits of SQLite are and how they can be customized for specific applications. The default settings for limits are normally quite large and adequate for almost every application. Some applications may want to increase a limit here or there, but we expect such needs to be rare. More commonly, an application might want to recompile SQLite with much lower limits to avoid excess resource utilization in the event of bug in higher-level SQL statement generators or to help thwart attackers who inject malicious SQL statements.</source>
          <target state="translated">この記事では、SQLite の制限とは何か、そして特定のアプリケーション用にどのようにカスタマイズできるかを定義しています。デフォルトの制限値の設定は通常かなり大きく、ほとんどすべてのアプリケーションに適しています。アプリケーションによっては制限値を増やしたい場合もあるかもしれませんが、そのようなニーズは稀だと考えています。より一般的には、高レベルのSQL文生成器にバグが発生した場合の過剰なリソース利用を避けるため、あるいは悪意のあるSQL文を注入する攻撃者を阻止するために、アプリケーションははるかに低い制限値でSQLiteを再コンパイルしたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="316fd7167581f1bf3b1521c621172952b269d34a" translate="yes" xml:space="preserve">
          <source>This article describes how the SQLite developers measure CPU usage, what those measurements actually mean, and the techniques used by SQLite developers on their continuing quest to further reduce the CPU usage of the SQLite library.</source>
          <target state="translated">この記事では、SQLite 開発者がどのようにして CPU 使用率を測定しているのか、その測定値が実際に何を意味しているのか、そして SQLite ライブラリの CPU 使用率をさらに削減するために SQLite 開発者が使用しているテクニックについて説明しています。</target>
        </trans-unit>
        <trans-unit id="926f25884d306babc2c568ebac87d0360fd509bf" translate="yes" xml:space="preserve">
          <source>This article describes the SQLite OS portability layer or &quot;VFS&quot; - the module at the bottom of the SQLite implementation stack that provides portability across operating systems.</source>
          <target state="translated">この記事では、SQLite OS のポータビリティ層、つまり「VFS」について説明します。</target>
        </trans-unit>
        <trans-unit id="e9493c358448eb3b281eac84dedc92f4531c0a0b" translate="yes" xml:space="preserve">
          <source>This article describes the techniques used by SQLite to create the illusion of atomic commit.</source>
          <target state="translated">この記事では、アトミックコミットのような錯覚を起こすために SQLite で使用されるテクニックについて説明します。</target>
        </trans-unit>
        <trans-unit id="c7354274b5f5ad835c3ba9869336d09f507f1b91" translate="yes" xml:space="preserve">
          <source>This article describes the various temporary files that SQLite creates and uses. It describes when the files are created, when they are deleted, what they are used for, why they are important, and how to avoid them on systems where creating temporary files is expensive.</source>
          <target state="translated">この記事では、SQLite が作成して使用する様々な一時ファイルについて説明します。この記事では、いつファイルが作成され、いつ削除され、何のために使用されるのか、なぜ重要なのか、そして一時ファイルの作成に費用がかかるシステムではどのようにして回避するのかについて説明します。</target>
        </trans-unit>
        <trans-unit id="bf37adfcb2e68d7e2d42601f83e22affd6226d10" translate="yes" xml:space="preserve">
          <source>This article does not contain a step-by-step recipe for compiling SQLite. That would be difficult since each development situation is different. Rather, this article describes and illustrates the principals behind the compilation of SQLite. Typical compilation commands are provided as examples with the expectation that application developers can use these examples as guidance for developing their own custom compilation procedures. In other words, this article provides ideas and insights, not turnkey solutions.</source>
          <target state="translated">この記事には、SQLiteをコンパイルするためのステップバイステップのレシピは含まれていません。それぞれの開発状況が異なるため、それは難しいでしょう。むしろ、この記事ではSQLiteのコンパイルの背後にある原理を説明し、説明します。典型的なコンパイルコマンドは例として提供されており、アプリケーション開発者が独自のコンパイル手順を開発するための指針としてこれらの例を使用できることを期待しています。言い換えれば、この記事はアイデアと洞察を提供するものであり、即効性のある解決策を提供するものではありません。</target>
        </trans-unit>
        <trans-unit id="945df33c68655603cf7dd0502f5d42134ad32f1a" translate="yes" xml:space="preserve">
          <source>This article has been revised multiple times in an attempt to improve clarity, address concerns and misgivings, and to fix errors identified on &lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt; and &lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt;. The complete edit history can be seen at &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt;. (Usage hint: Click on any two nodes of the graph for a diff.)</source>
          <target state="translated">この記事は、明快さを改善し、懸念と不安に対処し、&lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;、&lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt;、&lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobstersで&lt;/a&gt;特定されたエラーを修正するために、何度も改訂されました。完全な編集履歴は、&lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https：//sqlite.org/docsrc/finfo/pages/whynotgit.inで&lt;/a&gt;確認できます。（使用上のヒント：グラフの任意の2つのノードをクリックして差分を表示します。）</target>
        </trans-unit>
        <trans-unit id="62a4071d7245439102f2788bb499d61e09713933" translate="yes" xml:space="preserve">
          <source>This article has reviewed all of the major techniques used by SQLite's VDBE to implement SQL statements. What has not been shown is that most of these techniques can be used in combination to generate code for an appropriately complex query statement. For example, we have shown how sorting is accomplished on a simple query and we have shown how to implement a compound query. But we did not give an example of sorting in a compound query. This is because sorting a compound query does not introduce any new concepts: it merely combines two previous ideas (sorting and compounding) in the same VDBE program.</source>
          <target state="translated">この記事では、SQLiteのVDBEがSQL文を実装するために使用する主要なテクニックをすべてレビューしてきました。これまで見てこなかったのは、これらのテクニックのほとんどが、適切に複雑なクエリ文のコードを生成するために組み合わせて使用できるということです。例えば、単純なクエリでソートがどのように行われるかを示し、複合クエリを実装する方法を示しました。しかし、複合クエリでのソートの例は示していません。これは、複合クエリのソートは新しい概念を導入していないからである。これは、以前の2つの概念(ソートと複合)を同じVDBEプログラムで組み合わせただけである。</target>
        </trans-unit>
        <trans-unit id="a20be3ae1245d83ff9c73306d203b42ad8b16c54" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; a comparison between Fossil and Git. See &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; for one comparison of the two systems. There are others as well.</source>
          <target state="translated">この記事はFossilとGitの比較ではあり&lt;u&gt;ません&lt;/u&gt;。2つのシステムの1つの比較については、&lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https：//fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt;を参照してください。他にもあります。</target>
        </trans-unit>
        <trans-unit id="afdaa5ec4a00df9435f74fca69ef2e683fab815e" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; advocating that you switch your projects away from Git. You can use whatever version control system you want. If you are perfectly happy with Git, then by all means keep using Git. But, if you are wondering if there isn't something better, then maybe try to understand the perspectives presented below. Use the insights thus obtained to find or write a different and better version control system, or to just make improvements to Git itself.</source>
          <target state="translated">この記事では、プロジェクトをGitから切り替えることを推奨して&lt;u&gt;いません&lt;/u&gt;。必要なバージョン管理システムを使用できます。 Gitに完全に満足している場合は、必ずGitを使い続けてください。しかし、もっと良いものはないのかと疑問に思っているのなら、以下に示す見方を理解してみてください。このようにして得られた洞察を使用して、別のより良いバージョン管理システムを見つけたり、書き込んだり、Git自体を改善したりします。</target>
        </trans-unit>
        <trans-unit id="7e8b2b9b07235888ae1de754eef75c5cbe3b972b" translate="yes" xml:space="preserve">
          <source>This article is a brief introduction to how the VDBE works and in particular how the various VDBE instructions (documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;) work together to do useful things with the database. The style is tutorial, beginning with simple tasks and working toward solving more complex problems. Along the way we will visit most submodules in the SQLite library. After completing this tutorial, you should have a pretty good understanding of how SQLite works and will be ready to begin studying the actual source code.</source>
          <target state="translated">この記事は、VDBEがどのように機能するか、特にさまざまなVDBE命令（&lt;a href=&quot;opcode&quot;&gt;ここに&lt;/a&gt;記載されている）がデータベースで有用なことを行うためにどのように機能するかについての簡単な紹介です。スタイルはチュートリアルであり、単純なタスクから始まり、より複雑な問題の解決に向けて取り組みます。途中、SQLiteライブラリのほとんどのサブモジュールにアクセスします。このチュートリアルを完了すると、SQLiteがどのように機能するかをかなり理解でき、実際のソースコードの調査を開始する準備が整います。</target>
        </trans-unit>
        <trans-unit id="2a689ac1a6bfa9fdba228a490c8ca90cb86bfd11" translate="yes" xml:space="preserve">
          <source>This article is about the bottom layer.</source>
          <target state="translated">この記事は底辺層についての記事です。</target>
        </trans-unit>
        <trans-unit id="8376dd4be0a7eabaff5c0a359df7f198ffdee0ed" translate="yes" xml:space="preserve">
          <source>This article only mentions the most important and most commonly used SQLite interfaces. The SQLite library includes many other APIs implementing useful features that are not described here. A &lt;a href=&quot;c3ref/funclist&quot;&gt;complete list of functions&lt;/a&gt; that form the SQLite application programming interface is found at the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ Interface Specification&lt;/a&gt;. Refer to that document for complete and authoritative information about all SQLite interfaces.</source>
          <target state="translated">この記事では、最も重要で最も一般的に使用されるSQLiteインターフェイスについてのみ説明します。 SQLiteライブラリには、ここで説明されていない便利な機能を実装する他の多くのAPIが含まれています。SQLiteアプリケーションプログラミングインターフェイスを形成する&lt;a href=&quot;c3ref/funclist&quot;&gt;関数&lt;/a&gt;の完全なリストは、&lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++インターフェイス仕様にあり&lt;/a&gt;ます。すべてのSQLiteインターフェイスに関する完全で信頼できる情報については、そのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ecb82abd11a7741bac191b285785a86679cd3dd8" translate="yes" xml:space="preserve">
          <source>This article outlines one possible method for keeping a private branch of SQLite in sync with the public SQLite source code. There are many ways of maintaining a private branch, of course. Nobody is compelled to use the method describe here. This article is not trying to impose a particular procedure on maintainers of private branches. The point of this article is to offer an example of one process for maintaining a private branch which can be used as a template for designing processes best suited for the circumstances of each individual project.</source>
          <target state="translated">この記事では、SQLite のプライベートブランチをパブリック SQLite のソースコードと同期させて維持するための方法を概説します。もちろん、プライベートブランチを維持する方法はたくさんあります。ここで説明した方法を使うことを強制されることはありません。この記事はプライベートブランチのメンテナに特定の手続きを課そうとしているわけではありません。この記事のポイントは、個々のプロジェクトの状況に合わせて最適なプロセスを設計するためのテンプレートとして使用できるプライベートブランチを維持するためのプロセスの一例を提供することです。</target>
        </trans-unit>
        <trans-unit id="6e9369c9e16c87662c003b06c9e9f9920fb45e35" translate="yes" xml:space="preserve">
          <source>This article overviews the importance of query planning, describes some of the problems inherent to query planning, and outlines how the NGQP solves those problems.</source>
          <target state="translated">この記事では、クエリ計画の重要性を概観し、クエリ計画に内在する問題のいくつかを説明し、NGQPがこれらの問題をどのように解決しているかを概説します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
