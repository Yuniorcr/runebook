<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="afce5a653d0b42c7793177067bc50ad86675aae0" translate="yes" xml:space="preserve">
          <source>If there exists an index that maps the &quot;two&quot; column of the &quot;examp&quot; table into integers, then SQLite will use that index to find the integer keys of all rows in examp that have a value of 50 for column two, or all rows that are less than 50, etc. But the following queries cannot use the index:</source>
          <target state="translated">もし &quot;examp &quot;テーブルの &quot;two &quot;カラムを整数にマッピングするインデックスが存在する場合、SQLiteはそのインデックスを使用して、examp内のすべての行のうち、カラム2の値が50である行、または50より小さい行などの整数キーを見つけます。しかし、以下のクエリはインデックスを使用できません。</target>
        </trans-unit>
        <trans-unit id="856948c8edddeced0c9cafe3bd0f42f4ee0fc501" translate="yes" xml:space="preserve">
          <source>If there has been one or more REPLACE resolutions on a key, it is rebased according to a REPLACE.</source>
          <target state="translated">キーに1つ以上のREPLACE決議があった場合、REPLACEに従ってリベースされます。</target>
        </trans-unit>
        <trans-unit id="4dc77fa5e92703a982360848038ee795cce33659" translate="yes" xml:space="preserve">
          <source>If there have been no REPLACE resolutions on a key, then the local changeset is rebased according to the most recent of the OMIT resolutions.</source>
          <target state="translated">キーに REPLACE 決議がなかった場合、ローカル変更セットは、OMIT 決議のうち最新のものに基づいてリベースされます。</target>
        </trans-unit>
        <trans-unit id="b7ee1d4caced0cc280acbdfbbd3da7974e0aedc7" translate="yes" xml:space="preserve">
          <source>If there is a USING clause then each of the column names specified must exist in the datasets to both the left and right of the join-operator. For each pair of named columns, the expression &quot;lhs.X = rhs.X&quot; is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which all such expressions evaluates to true are included from the result set. When comparing values as a result of a USING clause, the normal rules for handling affinities, collation sequences and NULL values in comparisons apply. The column from the dataset on the left-hand side of the join-operator is considered to be on the left-hand side of the comparison operator (=) for the purposes of collation sequence and affinity precedence.</source>
          <target state="translated">USING句がある場合、指定された各列名は、結合演算子の左側と右側の両方のデータセットに存在する必要があります。名前付き列の各ペアについて、式 &quot;lhs.X = rhs.X&quot;は、デカルト積の各行に対して&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;ブール式&lt;/a&gt;として評価されます。結果セットには、そのような式がすべてtrueと評価された行のみが含まれます。 USING句の結果として値を比較する場合、比較における類似性、照合シーケンス、およびNULL値の処理に関する通常の規則が適用されます。結合演算子の左側にあるデータセットの列は、照合順序とアフィニティの優先順位のために、比較演算子（=）の左側にあると見なされます。</target>
        </trans-unit>
        <trans-unit id="d234388212b95e999640f17f4b156605cf6f600f" translate="yes" xml:space="preserve">
          <source>If there is already a read transaction open when this function is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR, SQLITE_BUSY or SQLITE_ERROR_SNAPSHOT is returned. If another error code - for example SQLITE_PROTOCOL or an SQLITE_IOERR error code - is returned, then the final state of the read transaction is undefined. If SQLITE_OK is returned, then the read transaction is now open on database snapshot P.</source>
          <target state="translated">この関数が呼び出されたときに既にオープンされている読み取りトランザクションがある場合、SQLITE_ERROR、SQLITE_BUSY、またはSQLITE_ERROR_SNAPSHOTが返されても、同じ読み取りトランザクションは(同じデータベースのスナップショット上で)オープンされたままです。SQLITE_PROTOCOL や SQLITE_IOERR などの別のエラーコードが返された場合、読み取りトランザクションの最終状態は未定義です。SQLITE_OK が返された場合、読み取りトランザクションはデータベースのスナップショット P で開かれています。</target>
        </trans-unit>
        <trans-unit id="b3ba606d14be7904e644a6f345ba54604a8e5ba7" translate="yes" xml:space="preserve">
          <source>If there is already an auxiliary data pointer when this function is invoked, then it is replaced by the new pointer. If an xDelete callback was specified along with the original pointer, it is invoked at this point.</source>
          <target state="translated">この関数が呼び出されたときに既に補助データポインタがある場合は、そのポインタが新しいポインタに置き換えられます。元のポインタと一緒に xDelete コールバックが指定されていた場合は、この時点で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7d3f7f6da384d18458af17b6bbb473e63bd6c0a4" translate="yes" xml:space="preserve">
          <source>If there is an AS clause on the result, then the name of the column is the right-hand side of the AS clause.</source>
          <target state="translated">結果にAS句がある場合、カラム名はAS句の右側になります。</target>
        </trans-unit>
        <trans-unit id="ea4985ea47701fb618426a82280d62d99731524f" translate="yes" xml:space="preserve">
          <source>If there is an ON clause then the ON expression is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the expression evaluates to true are included from the dataset.</source>
          <target state="translated">ON句がある場合、ON式はデカルト積の各行に対して&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;ブール式&lt;/a&gt;として評価されます。式がtrueと評価される行のみがデータセットから含まれます。</target>
        </trans-unit>
        <trans-unit id="2e70dfed6b6c48ce8dce24e64f939fa0229381a9" translate="yes" xml:space="preserve">
          <source>If there is no compatible table, it is not an error, but none of the changes associated with the table are applied. A warning message is issued via the sqlite3_log() mechanism with the error code SQLITE_SCHEMA. At most one such warning is issued for each table in the changeset.</source>
          <target state="translated">互換性のあるテーブルがない場合はエラーではありませんが、そのテーブルに関連付けられた変更は何も適用されません。警告メッセージはsqlite3_log()メカニズムを介してエラーコードSQLITE_SCHEMAで発行されます。このような警告は、チェンジセット内の各テーブルに対して最大で1つ発行されます。</target>
        </trans-unit>
        <trans-unit id="8b1f218c8fcc4cd8280015ffb23038ba539a45b9" translate="yes" xml:space="preserve">
          <source>If there is no index named</source>
          <target state="translated">という名前のインデックスがない場合</target>
        </trans-unit>
        <trans-unit id="5f851a7381e365ca34ec1852c08b2f940f8860fc" translate="yes" xml:space="preserve">
          <source>If there is no selftest table, the &quot;.selftest&quot; command runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;.</source>
          <target state="translated">セルフテストテーブルがない場合、「。selftest」コマンドは&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA&lt;/a&gt; integer_checkを実行します。</target>
        </trans-unit>
        <trans-unit id="c042772d4bc73bd02a9ce067deaf034251147e0f" translate="yes" xml:space="preserve">
          <source>If there is only a single table or subquery in the FROM clause, then the input data used by the SELECT statement is the contents of the named table. If there is more than one table or subquery in FROM clause then the contents of all tables and/or subqueries are joined into a single dataset for the simple SELECT statement to operate on. Exactly how the data is combined depends on the specific &lt;a href=&quot;syntax/join-operator&quot;&gt;join-operator&lt;/a&gt; and &lt;a href=&quot;syntax/join-constraint&quot;&gt;join-constraint&lt;/a&gt; used to connect the tables or subqueries together.</source>
          <target state="translated">FROM句にテーブルまたはサブクエリが1つしかない場合、SELECTステートメントで使用される入力データは、名前付きテーブルの内容です。FROM句に複数のテーブルまたはサブクエリがある場合は、すべてのテーブルまたはサブクエリ、あるいはその両方の内容が単一のデータセットに結合され、単純なSELECTステートメントが処理されます。データが正確に結合される方法は、テーブルまたはサブクエリを接続するために使用される特定の&lt;a href=&quot;syntax/join-operator&quot;&gt;結合演算子&lt;/a&gt;と&lt;a href=&quot;syntax/join-constraint&quot;&gt;結合制約に&lt;/a&gt;依存します。</target>
        </trans-unit>
        <trans-unit id="4c64aa9b4e57f38edc6d2ba80d1689a5d372c4ee" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">これらのルーチンが、&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt;ポインターを受け取ったアプリケーション定義関数を含むスレッドとは異なるスレッド内から呼び出された場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="cd8848554ca2d7f3d01b722c239f1dc6287ba93f" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">これらのルーチンが、&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt;ポインターを受け取ったアプリケーション定義関数を含むスレッドとは異なるスレッド内から呼び出された場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="915164f8017ef4e64adbf0d45fa62da4e11e9b32" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro disables the &quot;deferred token&quot; optimization in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;. The &quot;deferred token&quot; optimization avoids loading massive posting lists for terms that are in most documents of the collection and instead simply scans for those tokens in the document source. &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; should get exactly the same answer both with and without this optimization.</source>
          <target state="translated">このCプリプロセッサマクロが&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4の&lt;/a&gt;「遅延トークン」最適化を無効にする場合。 「据え置きトークン」の最適化により、コレクションのほとんどの文書にある用語の大量の投稿リストのロードが回避され、代わりに文書ソース内のそれらのトークンがスキャンされます。&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;は、この最適化の有無にかかわらず、まったく同じ答えを得るはずです。</target>
        </trans-unit>
        <trans-unit id="ae29c8f0136956324cb9875e314002993d7a9c98" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined and if the xDeviceCharacteristics method of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object for a database file reports (via one of the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bits) that the filesystem supports atomic writes and if a transaction involves a change to only a single page of the database file, then the transaction commits with just a single write request of a single page of the database and no rollback journal is created or written. On filesystems that support atomic writes, this optimization can result in significant speed improvements for small updates. However, few filesystems support this capability and the code paths that check for this capability slow down write performance on systems that lack atomic write capability, so this feature is disabled by default.</source>
          <target state="translated">このCプリプロセッサマクロが定義されており、データベースファイルの&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトのxDeviceCharacteristicsメソッドが（&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt;ビットの1つを介して）ファイルシステムがアトミックな書き込みをサポートしていること、およびトランザクションにデータベースの単一ページのみの変更が含まれていることを報告する場合ファイルの場合、トランザクションはデータベースの単一ページの単一の書き込み要求だけでコミットされ、ロールバックジャーナルは作成または書き込まれません。アトミックな書き込みをサポートするファイルシステムでは、この最適化により、小さな更新の速度が大幅に向上する可能性があります。ただし、この機能をサポートするファイルシステムはほとんどなく、この機能をチェックするコードパスは、アトミック書き込み機能がないシステムでの書き込みパフォーマンスを低下させるため、この機能はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="f74239b5b9713fd263bba27dcb07765bb74b0239" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, directory syncs are disabled. SQLite typically attempts to sync the parent directory when a file is deleted to ensure the directory entries are updated immediately on disk.</source>
          <target state="translated">この C プリプロセッサ マクロが定義されている場合、ディレクトリの同期は無効になります。SQLite は通常、ファイルが削除されたときに親ディレクトリの同期を試み、ディレクトリエントリがディスク上で即座に更新されるようにします。</target>
        </trans-unit>
        <trans-unit id="5737b83035ce500dcfa496d2b2b66e0845cad862" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, large file support is disabled.</source>
          <target state="translated">このCプリプロセッサマクロが定義されている場合、ラージファイルのサポートは無効になります。</target>
        </trans-unit>
        <trans-unit id="262e2217c94b5b2f3ea64e55aebf18183a8f388a" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer in &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; is omitted from the build and is unavailable to applications.</source>
          <target state="translated">このC-プリプロセッサマクロが定義されている場合、&lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt;にトークナイザ&lt;a href=&quot;fts3&quot;&gt;FTS3が&lt;/a&gt;ビルドから省略及びアプリケーションに利用不可能です。</target>
        </trans-unit>
        <trans-unit id="39617688d9840b06235bc5d306b07bb0ba889ba9" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, then extra code is included that allows SQLite to function on a filesystem that only support 8+3 filenames. If the value of this macro is 1, then the default behavior is to continue to use long filenames and to only use 8+3 filenames if the database connection is opened using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; with the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter. If the value of this macro is 2, then the use of 8+3 filenames becomes the default but may be disabled on using the &lt;code&gt;8_3_names=0&lt;/code&gt; query parameter.</source>
          <target state="translated">このCプリプロセッサマクロが定義されている場合、SQLiteが8 + 3のファイル名のみをサポートするファイルシステムで機能できるようにする追加のコードが含まれます。このマクロの値が1の場合、デフォルトの動作では、長いファイル名を引き続き使用し、クエリパラメータ&quot; &lt;code&gt;8_3_names=1&lt;/code&gt; &quot;を持つ&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;を使用してデータベース接続が開かれている場合は、8 + 3ファイル名のみを使用します。このマクロの値が2の場合、8 + 3ファイル名の使用がデフォルトになりますが、 &lt;code&gt;8_3_names=0&lt;/code&gt; クエリパラメータを使用すると無効になる場合があります。</target>
        </trans-unit>
        <trans-unit id="ad3d89f2752a79cf47c58e04a726219583d11898" translate="yes" xml:space="preserve">
          <source>If this SELECT returns any rows at all, then SQLite concludes that deleting the row from the parent table would violate the foreign key constraint and returns an error. Similar queries may be run if the content of the parent key is modified or a new row is inserted into the parent table. If these queries cannot use an index, they are forced to do a linear scan of the entire child table. In a non-trivial database, this may be prohibitively expensive.</source>
          <target state="translated">この SELECT が行を全く返さない場合、SQLite は親テーブルから行を削除すると外部キー制約に違反すると結論付け、エラーを返します。親キーの内容が変更されたり、親テーブルに新しい行が挿入されたりした場合にも、同様のクエリが実行されることがあります。これらのクエリがインデックスを使用できない場合は、子テーブル全体のリニアスキャンを行うことを余儀なくされます。非自明なデータベースでは、これは法外なコストがかかるかもしれません。</target>
        </trans-unit>
        <trans-unit id="d8ee4bc759bb4de0d55341a4133e995c0e985e4b" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with the SQLITE_ENABLE_ICU pre-processor symbol defined, then there exists a built-in tokenizer named &quot;icu&quot; implemented using the ICU library. The first argument passed to the xCreate() method (see fts3_tokenizer.h) of this tokenizer may be an ICU locale identifier. For example &quot;tr_TR&quot; for Turkish as used in Turkey, or &quot;en_AU&quot; for English as used in Australia. For example:</source>
          <target state="translated">この拡張モジュールが SQLITE_ENABLE_ICU プリプロセッサシンボルを定義してコンパイルされている場合、ICU ライブラリを使用して実装された &quot;icu&quot; という名前の組み込みトークナイザーが存在します。このトークナイザーの xCreate()メソッド (fts3_tokenizer.h を参照)に渡される最初の引数は、ICU のロケール識別子である可能性があります。例えば、トルコで使われているトルコ語は &quot;tr_TR&quot;、オーストラリアで使われている英語は &quot;en_AU &quot;などです。例えば、トルコ語なら &quot;tr_TR&quot;、オーストラリアで使われている英語なら &quot;en_AU &quot;など。</target>
        </trans-unit>
        <trans-unit id="d023458a29576f7575443a7b9afec6275af3fcf1" translate="yes" xml:space="preserve">
          <source>If this function is called when the iterator does not point to a valid entry, SQLITE_MISUSE is returned and the output variables zeroed. Otherwise, SQLITE_OK is returned and the output variables populated as described above.</source>
          <target state="translated">イテレータが有効なエントリを指していない場合にこの関数が呼び出されると、SQLITE_MISUSEが返され、出力変数がゼロになります。そうでない場合は、SQLITE_OKが返され、上で説明したように出力変数が生成されます。</target>
        </trans-unit>
        <trans-unit id="575c4fba56a8b3b5c139b07c2f0bb05a15bdbd1b" translate="yes" xml:space="preserve">
          <source>If this function needs to obtain extra database locks before dirty pages can be flushed to disk, it does so. If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner. If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database. If any databases are skipped because locks cannot be obtained, but no other error occurs, this function returns SQLITE_BUSY.</source>
          <target state="translated">この関数は、ダーティページをディスクにフラッシュする前にデータベースのロックを追加で取得する必要がある場合、それを行います。これらのロックがすぐに取得できず、ビジーハンドラコールバックが設定されている場合は、通常の方法で呼び出されます。それでも必要なロックが得られない場合、そのデータベースはスキップされ、次の(もしあれば)データベースに属するダーティページのフラッシュが試みられます。ロックが取得できなかったためにデータベースがスキップされたが、他のエラーが発生しなかった場合、この関数は SQLITE_BUSY を返します。</target>
        </trans-unit>
        <trans-unit id="4a59fbb2ab0548034e0f0c93999e3d83e86e0a83" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">このグローバル変数がフォルダー（別名ディレクトリ）の名前である文字列を指すようにした場合、相対パス名で指定され、組み込みのWindows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt;を使用するときにSQLiteによって作成またはアクセスされるすべてのデータベースファイルは、そのディレクトリを基準にしてください。この変数がNULLポインターの場合、SQLiteは、相対パス名で指定されたすべてのデータベースファイルがプロセスの現在のディレクトリからの相対パスであると想定します。 Windows VFSのみがこのグローバル変数を使用します。 UNIX VFSでは無視されます。</target>
        </trans-unit>
        <trans-unit id="84ebd8e9c186529f8ee21c34bc9c7d688ed08739" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">このグローバル変数がフォルダー（別名ディレクトリ）の名前である文字列を指すようにした場合、相対パス名で指定され、組み込みのWindows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を使用するときにSQLiteによって作成またはアクセスされるすべてのデータベースファイルは、そのディレクトリを基準にしてください。この変数がNULLポインターの場合、SQLiteは、相対パス名で指定されたすべてのデータベースファイルがプロセスの現在のディレクトリからの相対パスであると想定します。 Windows VFSのみがこのグローバル変数を使用します。 UNIX VFSでは無視されます。</target>
        </trans-unit>
        <trans-unit id="ae61adf99b3e9cfc86e28932de2b54c5d4c9e28e" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">このグローバル変数がフォルダー（別名ディレクトリー）の名前である文字列を指すようにすると、組み込みの&lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt;を使用するときにSQLiteによって作成されたすべての一時ファイルがそのディレクトリーに配置されます。この変数がNULLポインターの場合、SQLiteは適切な一時ファイルディレクトリを検索します。</target>
        </trans-unit>
        <trans-unit id="2fef70c16016d67dc3025afd347c1e52be3b317a" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">このグローバル変数がフォルダー（別名ディレクトリー）の名前である文字列を指すようにすると、組み込みの&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を使用するときにSQLiteによって作成されたすべての一時ファイルがそのディレクトリーに配置されます。この変数がNULLポインターの場合、SQLiteは適切な一時ファイルディレクトリを検索します。</target>
        </trans-unit>
        <trans-unit id="377f589c93b8d1620f4832f74e589324c623fda3" translate="yes" xml:space="preserve">
          <source>If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.</source>
          <target state="translated">このインターフェイスが xConnect または xCreate 仮想テーブルメソッドのコンテキスト外で呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="16ae3ddca07ff1751105a0aea6145c79101d244a" translate="yes" xml:space="preserve">
          <source>If this macro is defined to a positive integer</source>
          <target state="translated">このマクロが正の整数に定義されている場合</target>
        </trans-unit>
        <trans-unit id="5cc647c8428edf625b094fb0de5d9a7c439f06d1" translate="yes" xml:space="preserve">
          <source>If this macro is defined, then the special &quot;$</source>
          <target state="translated">このマクロが定義されている場合、特別な「$</target>
        </trans-unit>
        <trans-unit id="53c0130971cedde038e298ffc488f5a86580ab11" translate="yes" xml:space="preserve">
          <source>If this option is defined, SQLite's built-in date and time manipulation functions are omitted. Specifically, the SQL functions julianday(), date(), time(), datetime() and strftime() are not available. The default column values CURRENT_TIME, CURRENT_DATE and CURRENT_TIMESTAMP are still available.</source>
          <target state="translated">このオプションが定義されている場合、SQLiteに組み込まれている日付と時刻の操作関数は省略されます。具体的には、SQL 関数 julianday()、date()、time()、datetime()、および strftime()は使用できません。デフォルトのカラム値である CURRENT_TIME、CURRENT_DATE、CURRENT_TIMESTAMP は引き続き利用可能です。</target>
        </trans-unit>
        <trans-unit id="3a2de06267117d8a8013c26631a2b4a79f2165b1" translate="yes" xml:space="preserve">
          <source>If this option is defined, the library cannot create or write to databases that support &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;. Executing a &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; statement is not an error (since unknown PRAGMAs are silently ignored), but does not return a value or modify the auto-vacuum flag in the database file. If a database that supports auto-vacuum is opened by a library compiled with this option, it is automatically opened in read-only mode.</source>
          <target state="translated">このオプションが定義されている場合、ライブラリは&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;をサポートするデータベースを作成またはデータベースに書き込むことができません。&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt;ステートメントの実行はエラーではありませんが（不明なPRAGMAは通知なしで無視されるため）、値を返したり、データベースファイルの自動バキュームフラグを変更したりしません。自動バキュームをサポートするデータベースが、このオプションでコンパイルされたライブラリーによって開かれた場合、それは自動的に読み取り専用モードで開かれます。</target>
        </trans-unit>
        <trans-unit id="0d1cff91ceb786cc24acfd1c107d786b9aaa0367" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; syntax is not recognized.</source>
          <target state="translated">このオプションが定義されている場合、&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約&lt;/a&gt;構文は認識されません。</target>
        </trans-unit>
        <trans-unit id="de1fe97e82a4364864c18ee6d16ca1ab17fe291c" translate="yes" xml:space="preserve">
          <source>If this option is defined, then it must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate a parse.c file. Because of this, this option may only be used when the library is built from source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the collection of pre-packaged C files provided for non-Unix like platforms on the website.</source>
          <target state="translated">このオプションが定義されている場合は、&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーター&lt;/a&gt;ツールを使用してparse.cファイルを生成するときにも定義する必要があります。このため、このオプションは、ライブラリがソースから構築された場合にのみ使用できます。&lt;a href=&quot;amalgamation&quot;&gt;アマルガム化&lt;/a&gt;や、Webサイト上の非UNIXライクなプラットフォーム用に提供されている事前にパッケージ化されたCファイルのコレクションからではありません。</target>
        </trans-unit>
        <trans-unit id="391001eddc6a6f9380d8efca6c5990bffd30c02d" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only only works, of course, on systems that support alloca().</source>
          <target state="translated">このオプションを有効にすると、alloca()メモリアロケータが適切ないくつかの状況で使用されるようになります。これにより、バイナリが少し小さくなり、より高速になります。SQLITE_USE_ALLOCA のコンパイル時にのみ機能するのは、もちろん alloca()をサポートしているシステムでのみです。</target>
        </trans-unit>
        <trans-unit id="e396be7869391838487d1744007a3e656f8af09d" translate="yes" xml:space="preserve">
          <source>If this option is passed a non-zero argument, the &quot;.expert&quot; command generates similar data distribution statistics for all indexes considered based on PERCENT percent of the rows currently stored in each database table. For databases with unusual data distributions, this may lead to better index recommendations, particularly if the application intends to run ANALYZE.</source>
          <target state="translated">このオプションに0以外の引数を渡すと、&quot;.expert &quot;コマンドは、各データベーステーブルに現在格納されている行のPERCENTパーセントに基づいて、考慮されるすべてのインデックスについて同様のデータ分布統計を生成します。異常なデータ分布を持つデータベースでは、特にアプリケーションがANALYZEを実行しようとしている場合には、これがより良いインデックスの推奨につながるかもしれません。</target>
        </trans-unit>
        <trans-unit id="84432c7bc70fca55a254f66874dd4bc62fe9abea" translate="yes" xml:space="preserve">
          <source>If this option is present, then SQLite will use the isnan() function from the system math library. This is an alias for the &lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt; configuration option.</source>
          <target state="translated">このオプションが存在する場合、SQLiteはシステム数学ライブラリのisnan（）関数を使用します。これは、&lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt;構成オプションのエイリアスです。</target>
        </trans-unit>
        <trans-unit id="8be490fe1c118ec4e22a3ceeab9a17451a39a86c" translate="yes" xml:space="preserve">
          <source>If this option is present, then the built-in &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator will be case sensitive. This same effect can be achieved at run-time using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">このオプションが存在する場合、組み込みの&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子では大文字と小文字が区別されます。これと同じ効果は、実行時に&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_likeプラグマ&lt;/a&gt;を使用して実現できます。</target>
        </trans-unit>
        <trans-unit id="ada121bcb0877b4a8c48986ff56dc5ba81d63e98" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">このルーチンが以前に呼び出されていない場合、または前の呼び出しでNが1未満か、PのNULLポインターがあった場合、PRNGは、デフォルトの&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxRandomnessメソッドから取得した乱数を使用してシードされます。このルーチンへの以前の呼び出しでNが1以上で、NULLでないPがあった場合、&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomnessメソッドに頼ることなく、疑似乱数が内部的に生成されます。</target>
        </trans-unit>
        <trans-unit id="37bc48a662f5023c1e8434007284ca1643b9979a" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">このルーチンが以前に呼び出されていない場合、または前の呼び出しでNが1未満か、PのNULLポインターがあった場合、PRNGは、デフォルトの&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxRandomnessメソッドから取得した乱数を使用してシードされます。このルーチンへの以前の呼び出しでNが1以上で、NULLでないPがあった場合、&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomnessメソッドに頼ることなく、疑似乱数が内部的に生成されます。</target>
        </trans-unit>
        <trans-unit id="7e75d3fd5002bfcaea7e83bd9fd2a7a917209184" translate="yes" xml:space="preserve">
          <source>If this value is returned, any changes applied so far are rolled back and the call to sqlite3changeset_apply() returns SQLITE_ABORT.</source>
          <target state="translated">この値が返された場合、これまでに適用された変更はすべてロールバックされ、sqlite3changeset_apply()の呼び出しはSQLITE_ABORTを返します。</target>
        </trans-unit>
        <trans-unit id="aefcb4f212e79bade6ab9e99069db614c4e4b2ca" translate="yes" xml:space="preserve">
          <source>If tracing is enabled (by the sqlite3_trace()) interface, then the UTF-8 string contained in P4 is emitted on the trace callback. Or if P4 is blank, use the string returned by sqlite3_sql().</source>
          <target state="translated">(sqlite3_trace()インタフェースによって)トレースが有効になっている場合、P4に含まれるUTF-8文字列がトレースコールバックで出力されます。または、P4が空白の場合は、sqlite3_sql()によって返された文字列を使用します。</target>
        </trans-unit>
        <trans-unit id="3f4fc8020e070710f30d36574cc04f57550a8abc" translate="yes" xml:space="preserve">
          <source>If two database connections shared the same cache and the reader has enabled the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt;, then the reader will be able to see changes made by the writer before the writer transaction commits. The combined use of &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is the only way that one database connection can see uncommitted changes on a different database connection. In all other circumstances, separate database connections are completely isolated from one another.</source>
          <target state="translated">2つのデータベース接続が同じキャッシュを共有し、リーダーが&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommittedプラグマ&lt;/a&gt;を有効にしている場合、リーダーは、ライタートランザクションがコミットする前にライターによって行われた変更を確認できます。併用&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;READ_UNCOMMITTEDプラグマは、&lt;/a&gt; 1つのデータベース接続が異なるデータベース接続にコミットされていない変更を見ることができる唯一の方法です。他のすべての状況では、個別のデータベース接続は互いに完全に分離されています。</target>
        </trans-unit>
        <trans-unit id="b41151cd8ed57f8a05f71e68d3e6f727b509adc0" translate="yes" xml:space="preserve">
          <source>If two or more distinct but shareable in-memory databases are needed in a single process, then the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter can be used with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; to create a named in-memory database:</source>
          <target state="translated">1つのプロセスで2つ以上の異なるが共有可能なインメモリデータベースが必要な場合は、&lt;a href=&quot;uri#coreqp&quot;&gt;mode = memory&lt;/a&gt;クエリパラメーターを&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;と共に使用して、名前付きインメモリデータベースを作成できます。</target>
        </trans-unit>
        <trans-unit id="7c051c04a74b426b583f6b46003048b9ec27b20e" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">2つ以上のスレッドが同じ&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;と結果列に対して1つ以上の&lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;列メタデータインターフェイス&lt;/a&gt;を同時に呼び出す場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="3f3b1a7191faa957bd4b9a2df637334c8be60539" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">2つ以上のスレッドが同じ&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;と結果列に対して1つ以上の&lt;a href=&quot;column_database_name&quot;&gt;列メタデータインターフェイス&lt;/a&gt;を同時に呼び出す場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="f59e0a816231da9addc2b58ecf1aebf4318f03f1" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more of these routines against the same prepared statement and column at the same time then the results are undefined.</source>
          <target state="translated">2つ以上のスレッドが、同じ準備されたステートメントとカラムに対して、これらのルーチンのうちの1つ以上を同時に呼び出した場合、結果は未定義になります。</target>
        </trans-unit>
        <trans-unit id="47c7553b72e9db086338dfa731f7055b973ce5ac" translate="yes" xml:space="preserve">
          <source>If two processes have open connections to the same database file and one process closes its connection, unlinks the file, then creates a new database file in its place with the same name and reopens the new file, then the two processes will be talking to different database files with the same name. (Note that this is only possible on Posix and Posix-like systems that permit a file to be unlinked while it is still open for reading and writing. Windows does not allow this to occur.) Since rollback journals and WAL files are based on the name of the database file, the two different database files will share the same rollback journal or WAL file. A rollback or recovery for one of the databases might use content from the other database, resulting in corruption. A similar problem occurs if a database file is renamed while it is opened and a new file is created with the old name.</source>
          <target state="translated">2つのプロセスが同じデータベースファイルへの接続を開いていて、1つのプロセスがその接続を閉じ、そのファイルのリンクを解除し、その場所に同じ名前の新しいデータベースファイルを作成し、新しいファイルを再び開いた場合、2つのプロセスは同じ名前の異なるデータベースファイルと話をしていることになります(これは、ファイルを読み書きするために開いたままでリンクを解除することを許可しているPosixやPosixに似たシステムでのみ可能です)。(これは、ファイルが読み書き可能な状態で開いている間にリンクを解除することを許可しているPosixやPosixに似たシステムでのみ可能であることに注意してください。Windowsでは、これは許可されていません)。ロールバックジャーナルとWALファイルはデータベースファイルの名前に基づいているので、2つの異なるデータベースファイルは同じロールバックジャーナルまたはWALファイルを共有します。一方のデータベースのロールバックやリカバリは、もう一方のデータベースのコンテンツを使用する可能性があり、破損の原因となります。同様の問題は、データベース ファイルを開いているときに名前が変更され、古い名前で新しいファイルが作成された場合にも発生します。</target>
        </trans-unit>
        <trans-unit id="0f73506a4d083541e30151f33df9ff76bf05c8d1" translate="yes" xml:space="preserve">
          <source>If using the MATCH or = operators, the expression to the left of the MATCH operator is usually the name of the FTS5 table (the exception is when &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;specifying a column-filter&lt;/a&gt;). The expression on the right must be a text value specifying the term to search for. For the table-valued function syntax, the term to search for is specified as the first table argument. For example:</source>
          <target state="translated">MATCHまたは=演算子を使用する場合、MATCH演算子の左側の式は通常、FTS5テーブルの名前です（&lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column-filterを指定する&lt;/a&gt;場合は例外です）。右側の式は、検索する用語を指定するテキスト値である必要があります。テーブル値関数構文の場合、検索する用語は最初のテーブル引数として指定されます。例えば：</target>
        </trans-unit>
        <trans-unit id="10c759f053d61c7e03ff959d29d1e1974783d209" translate="yes" xml:space="preserve">
          <source>If using the MinGW compiler, the command-line is this:</source>
          <target state="translated">MinGWコンパイラを使用している場合、コマンドラインはこのようになります。</target>
        </trans-unit>
        <trans-unit id="06877745f4f906674e7afae07a31cb3adf870f29" translate="yes" xml:space="preserve">
          <source>If using the amalgamation autoconf based build system, setting the CPPFLAGS environment variable while running the 'configure' script is an easy way to set these macros. For example, the following command:</source>
          <target state="translated">amalgamation autoconf ベースのビルドシステムを使用している場合、'configure' スクリプトを実行している間に CPPFLAGS 環境変数を設定すると、これらのマクロを設定する簡単な方法があります。例えば、以下のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="c06d03a70a5b876ea7069032c87d9367a09e46c5" translate="yes" xml:space="preserve">
          <source>If when you try to load your library you get back an error message that says &quot;mach-o, but wrong architecture&quot; then you might need to add command-line options &quot;-arch i386&quot; or &quot;arch x86_64&quot; to gcc, depending on how your application is built.</source>
          <target state="translated">ライブラリを読み込もうとしたときに &quot;mach-o,but wrong architecture&quot; というエラーメッセージが返ってくる場合は、アプリケーションのビルド方法に応じて、gcc に &quot;-arch i386&quot; や &quot;arch x86_64&quot; というコマンドラインオプションを追加する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="7cf9b897ab48ed18b82e59ac2a561abc36b27d81" translate="yes" xml:space="preserve">
          <source>If while attempting to detect a</source>
          <target state="translated">を検出しようとしている間に</target>
        </trans-unit>
        <trans-unit id="56ea56ee57997f44a3b4181f1b3a8efe3168e325" translate="yes" xml:space="preserve">
          <source>If xBestIndex returns &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, that does not indicate an error. Rather, SQLITE_CONSTRAINT indicates that the particular combination of input parameters specified should not be used in the query plan. The SQLITE_CONSTRAINT return is useful for &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that have required parameters. If the aConstraint[].usable field is false for one of the required parameter, then the xBestIndex method should return SQLITE_CONSTRAINT.</source>
          <target state="translated">xBestIndexが返す場合&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINTを&lt;/a&gt;、それはエラーを示すものではありません。 SQLITE_CONSTRAINTは、指定された入力パラメーターの特定の組み合わせをクエリプランで使用しないことを示しています。 SQLITE_CONSTRAINTの戻り&lt;a href=&quot;vtab#tabfunc2&quot;&gt;値&lt;/a&gt;は、必要なパラメーターを持つテーブル値関数に役立ちます。必須パラメーターの1つでaConstraint []。usableフィールドがfalseの場合、xBestIndexメソッドはSQLITE_CONSTRAINTを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="f2ddd15ff69a5ac03ff2cdad02ade0037f75db16" translate="yes" xml:space="preserve">
          <source>If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill in the unread portions of the buffer with zeros. A VFS that fails to zero-fill short reads might seem to work. However, failure to zero-fill short reads will eventually lead to database corruption.</source>
          <target state="translated">xRead()が SQLITE_IOERR_SHORT_READ を返す場合、バッファの未読部分もゼロで埋めなければなりません。ショートリードのゼロフィルに失敗したVFSはうまくいくように見えるかもしれません。しかし、ショートリードのゼロフィルに失敗すると、最終的にはデータベースの破損につながります。</target>
        </trans-unit>
        <trans-unit id="4c77d01ec7cf778a68ddf7a39c6762175e2b9a47" translate="yes" xml:space="preserve">
          <source>If you abuse the library by trying to call &lt;b&gt;sqlite_step&lt;/b&gt; inappropriately it will attempt return SQLITE_MISUSE. This can happen if you call sqlite_step() on the same virtual machine at the same time from two or more threads or if you call sqlite_step() again after it returned SQLITE_DONE or SQLITE_ERROR or if you pass in an invalid virtual machine pointer to sqlite_step(). You should not depend on the SQLITE_MISUSE return code to indicate an error. It is possible that a misuse of the interface will go undetected and result in a program crash. The SQLITE_MISUSE is intended as a debugging aid only - to help you detect incorrect usage prior to a mishap. The misuse detection logic is not guaranteed to work in every case.</source>
          <target state="translated">&lt;b&gt;sqlite_stepを&lt;/b&gt;不適切に&lt;b&gt;呼び出そ&lt;/b&gt;うとしてライブラリを乱用すると、&lt;b&gt;SQLITE_MISUSE&lt;/b&gt;が返されます。これは、2つ以上のスレッドから同時に同じ仮想マシンでsqlite_step（）を呼び出した場合、またはSQLITE_DONEまたはSQLITE_ERRORを返した後に再度sqlite_step（）を呼び出した場合、または無効な仮想マシンポインタをsqlite_step（ ）。エラーを示すためにSQLITE_MISUSE戻りコードに依存するべきではありません。インターフェイスの誤用が検出されず、プログラムがクラッシュする可能性があります。 SQLITE_MISUSEはデバッグの補助としてのみ意図されており、事故の前に誤った使用法を検出するのに役立ちます。誤用検出ロジックは、すべてのケースで機能するとは限りません。</target>
        </trans-unit>
        <trans-unit id="873a7faf9a3abe0d1c1b374fb25f49d1d975c393" translate="yes" xml:space="preserve">
          <source>If you append the character '*' to the end of the pattern, then a prefix search is performed. For example:</source>
          <target state="translated">パターンの最後に文字'*'を追加すると、接頭辞検索が行われます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="feb267998fb090ad7c9de72555f7d36aa562a1a7" translate="yes" xml:space="preserve">
          <source>If you are a &quot;rustacean&quot; and feel that Rust already meets the preconditions listed above, and that SQLite should be recoded in Rust, then you are welcomed and encouraged to contact the SQLite developers privately and argue your case.</source>
          <target state="translated">もしあなたが &quot;rustacean &quot;で、Rust が上記の前提条件を既に満たしており、SQLite が Rust で再コード化されるべきだと感じているのであれば、個人的に SQLite 開発者に連絡して、あなたの主張を主張することを歓迎し、奨励します。</target>
        </trans-unit>
        <trans-unit id="abe76df81a0ba114f6ec2f514aa5a8bd31614980" translate="yes" xml:space="preserve">
          <source>If you are a devoted Git user, you can still easily access SQLite. This section gives some hints on how to do so.</source>
          <target state="translated">Git の熱心なユーザーであれば、SQLite に簡単にアクセスすることができます。このセクションでは、その方法についていくつかのヒントを紹介します。</target>
        </trans-unit>
        <trans-unit id="b343ba4a7d7f527696dab2d0f4840db430c944d2" translate="yes" xml:space="preserve">
          <source>If you are an SQLite user whose has stumbled over some quirk of SQLite that is not mentioned here, please send us an email so that we can document the problem.</source>
          <target state="translated">もしあなたがSQLiteユーザーで、ここに記載されていないSQLiteの奇妙な点に躓いてしまった場合は、その問題を文書化するためにメールを送ってください。</target>
        </trans-unit>
        <trans-unit id="5de71147613f21cf2bdcb3bcc197abf7747cdeb4" translate="yes" xml:space="preserve">
          <source>If you are using separate source files, name all of the source files instead of just the two amalgamation source files. Once this is done, commit your changes as follows:</source>
          <target state="translated">別々のソースファイルを使用している場合は、2つのアマルガムソースファイルだけではなく、すべてのソースファイルに名前を付けてください。これが完了したら、以下のように変更をコミットします。</target>
        </trans-unit>
        <trans-unit id="4850a90372994c2a6bc8e2907d79c1145e74bbe1" translate="yes" xml:space="preserve">
          <source>If you delete a lot of data and want to shrink the database file, run the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. VACUUM will reconstruct the database from scratch. This will leave the database with an empty free-list and a file that is minimal in size. Note, however, that the VACUUM can take some time to run and it can use up to twice as much temporary disk space as the original file while it is running.</source>
          <target state="translated">大量のデータを削除し、データベースファイルを&lt;a href=&quot;lang_vacuum&quot;&gt;圧縮&lt;/a&gt;する場合は、VACUUMコマンドを実行します。 VACUUMはデータベースを最初から再構築します。これにより、データベースには空の空きリストと最小サイズのファイルが残ります。ただし、VACUUMの実行にはしばらく時間がかかり、実行中の元のファイルの最大2倍の一時ディスク容量を使用する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f248ef1c5726530e6b14bd3353f02b25fd1dbc4" translate="yes" xml:space="preserve">
          <source>If you delete the</source>
          <target state="translated">を削除した場合</target>
        </trans-unit>
        <trans-unit id="45dba72fc49e11d88cfbda6839af5580be8953a7" translate="yes" xml:space="preserve">
          <source>If you do not have a backup, recovery is very difficult. You might be able to find partial string data in a binary dump of the raw database file. Recovering numeric data might also be possible given special tools, though to our knowledge no such tools exist. SQLite is sometimes compiled with the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; option which overwrites all deleted content with zeros. If that is the case then recovery is clearly impossible. Recovery is also impossible if you have run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; since the data was deleted. If SQLITE_SECURE_DELETE is not used and VACUUM has not been run, then some of the deleted content might still be in the database file, in areas marked for reuse. But, again, there exist no procedures or tools that we know of to help you recover that data.</source>
          <target state="translated">バックアップがない場合、リカバリは非常に困難です。生データベースファイルのバイナリダンプで部分的な文字列データを見つけることができる場合があります。数値データの回復は、特別なツールがあれば可能かもしれませんが、私たちの知る限り、そのようなツールは存在しません。 SQLiteは、削除されたすべてのコンテンツをゼロで上書きする&lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt;オプションを使用してコンパイルされることがあります。その場合、回復は明らかに不可能です。データが削除されてから&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;を実行した場合も、リカバリは不可能です。 SQLITE_SECURE_DELETEが使用されておらず、VACUUMが実行されていない場合、削除されたコンテンツの一部は、データベースファイルの再利用のマークが付けられた領域に残っている可能性があります。しかし、繰り返しになりますが、そのデータを回復するのに役立つ手順やツールはありません。</target>
        </trans-unit>
        <trans-unit id="6123d0cbcd49adc87278ebf33c0308d19e13c18e" translate="yes" xml:space="preserve">
          <source>If you do not want to use your web browser to view the new check-in, you can get some information from the command-line using commands like these:</source>
          <target state="translated">Webブラウザを使って新規チェックインを表示したくない場合は、以下のようなコマンドを使ってコマンドラインから情報を得ることができます。</target>
        </trans-unit>
        <trans-unit id="c8e5a488a0f9459d060660cf0d22bea3c48ed8ca" translate="yes" xml:space="preserve">
          <source>If you feel that you need dynamic pointer type strings in your application, that is a strong indicator that you are misusing the pointer-passing interface. Your intended use may be unsafe. Please rethink your design. Determine if you really need to be passing pointers through SQL in the first place. Or perhaps find a different mechanism other than the pointer-passing interfaces described by this article.</source>
          <target state="translated">アプリケーションで動的なポインタ型の文字列が必要だと感じた場合、それはポインタ通過インタフェースを誤って使用していることを強く示しています。あなたの意図した使用は安全ではないかもしれません。設計を再考してください。そもそもポインタをSQLに渡す必要があるのかどうかを判断してください。あるいは、この記事で説明したポインタ・パス・インターフェイス以外の別のメカニズムを見つけてください。</target>
        </trans-unit>
        <trans-unit id="88a9f11dc162c0fbb6ecd06e339a9fb7195e5fab" translate="yes" xml:space="preserve">
          <source>If you find errors in either the documentation or the code, feel free to fix them and/or contact the author at &lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt;. Your bug fixes or suggestions are always welcomed.</source>
          <target state="translated">ドキュメントまたはコードのいずれかにエラーが見つかった場合は、自由に修正するか、作者（&lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com）にお問い合わせください&lt;/a&gt;。バグ修正や提案はいつでも歓迎します。</target>
        </trans-unit>
        <trans-unit id="888116b604c695e34258cc3ceb95b003a7ab4815" translate="yes" xml:space="preserve">
          <source>If you have a backup copy of your database file, recover the information from your backup.</source>
          <target state="translated">データベースファイルのバックアップコピーがある場合は、バックアップから情報を復元します。</target>
        </trans-unit>
        <trans-unit id="882c38087164067f62c9c7b1c8a9cb99d1dcf2ef" translate="yes" xml:space="preserve">
          <source>If you have a database of large BLOBs, do you get better read performance when you store the complete BLOB content directly in the database or is it faster to store each BLOB in a separate file and store just the corresponding filename in the database?</source>
          <target state="translated">大規模なBLOBのデータベースを持っている場合、完全なBLOBの内容を直接データベースに格納した方が読み込みパフォーマンスが向上するのでしょうか?それとも、各BLOBを個別のファイルに格納し、対応するファイル名だけをデータベースに格納した方が速いのでしょうか?</target>
        </trans-unit>
        <trans-unit id="763f3c8f82a8dbfe2292008ca244c1681fbd52b1" translate="yes" xml:space="preserve">
          <source>If you have a script and you want to start debugging at some point half-way through that script, simply set a breakpoint in gdb (or whatever debugger you are using) on the test_breakpoint() function, and add a &quot;.breakpoint&quot; command where you want to stop. When you reach that first breakpoint, set whatever additional breakpoints are variable traces you need.</source>
          <target state="translated">スクリプトがあり、そのスクリプトの途中でデバッグを開始したい場合、test_breakpoint()関数で gdb (または使用しているデバッガ)にブレークポイントを設定し、停止したい場所に &quot;.breakpoint&quot; コマンドを追加するだけです。最初のブレークポイントに到達したら、必要に応じて追加のブレークポイントを変数トレースに設定します。</target>
        </trans-unit>
        <trans-unit id="a1693c0c5d23752d02c6e3b93f043c8eb31a26df" translate="yes" xml:space="preserve">
          <source>If you have done any assembly language programming or have worked with any kind of abstract machine before, all of these details should be familiar to you. So let's jump right in and start looking as some code.</source>
          <target state="translated">アセンブリ言語でプログラミングをしたことがある人や、以前に抽象的な機械を扱ったことがある人なら、これらの詳細はすべてお馴染みのものでしょう。それでは、すぐに飛び込んでコードを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ec726a0b109ca2b2f984dbfe63a95238609005d5" translate="yes" xml:space="preserve">
          <source>If you intend to use this virtual table in cooperation with an &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; table (for spelling correction of search terms) then you might extract the vocabulary using an &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; table:</source>
          <target state="translated">この仮想テーブルを&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;テーブルと組み合わせて使用する場合（検索語のスペル修正用）、&lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt;テーブルを使用して語彙を抽出できます。</target>
        </trans-unit>
        <trans-unit id="20f09458f074cbdfa69a4cd879b9a24a9c5ffaed" translate="yes" xml:space="preserve">
          <source>If you made NL to CR-NL line ending changes or space to tab indentation changes in the original baseline, make the same changes to the new source file.</source>
          <target state="translated">元のベースラインで NL から CR-NL への改行やスペースからタブのインデントを変更した場合は、新しいソース ファイルにも同じ変更を加えます。</target>
        </trans-unit>
        <trans-unit id="5e4831ba155a21bf312a9328909ee6b27a5a08fb" translate="yes" xml:space="preserve">
          <source>If you need to verify that the SQLite source code that you have is authentic and has not been modified in any way (perhaps by an adversary) that can be done using a few simple command-line tools. At the root of the SQLite source tree is a file named &quot;manifest&quot;. The manifest file contains the name of every other file in the source tree together with either a SHA1 or SHA3-256 hash for that file. (SHA1 is used for older files and SHA3-256 for newer files.) You can write a script to extract these hashes and verify them against the source code files. The hash name for the check-in is just the SHA3-256 hash of the &quot;manifest&quot; file itself.</source>
          <target state="translated">あなたが持っているSQLiteソースコードが本物であり、(おそらく敵対者によって)いかなる方法でも変更されていないことを確認する必要がある場合は、いくつかのシンプルなコマンドラインツールを使用して行うことができます。SQLite ソースツリーのルートには、「マニフェスト」という名前のファイルがあります。マニフェストファイルには、ソースツリー内の他のすべてのファイルの名前と、そのファイルの SHA1 または SHA3-256 ハッシュが含まれています(古いファイルでは SHA1 が使用されます)。(SHA1 は古いファイルに、SHA3-256 は新しいファイルに使用されます。)これらのハッシュを抽出し、ソース コード ファイルと照合して検証するスクリプトを記述することができます。チェックインのためのハッシュ名は、単に「マニフェスト」ファイル自体の SHA3-256 ハッシュです。</target>
        </trans-unit>
        <trans-unit id="13da8fa523e1031c91ec41d25db356602a2c65ba" translate="yes" xml:space="preserve">
          <source>If you specify a column a width of 0, then the column width is automatically adjusted to be the maximum of three numbers: 10, the width of the header, and the width of the first row of data. This makes the column width self-adjusting. The default width setting for every column is this auto-adjusting 0 value.</source>
          <target state="translated">列の幅を0に指定した場合、列の幅は3つの数字の最大値になるように自動的に調整されます。10、ヘッダの幅、データの最初の行の幅の3つの数字の最大値になるように自動的に調整されます。これにより、カラムの幅は自己調整されます。すべてのカラムのデフォルトの幅の設定は、この自動調整された0の値です。</target>
        </trans-unit>
        <trans-unit id="473942d6eb4b318988fc65567c504fbaea4558ae" translate="yes" xml:space="preserve">
          <source>If you use version 2.6.0 or later of the library to open a database file that was originally created by version 2.5.6 or earlier, an attempt to rebuild the database into the new format will occur automatically. This can take some time for a large database. (Allow 1 or 2 seconds per megabyte of database under Unix - longer under Windows.) This format conversion is irreversible. It is &lt;strong&gt;strongly&lt;/strong&gt; suggested that you make a backup copy of older database files prior to opening them with version 2.6.0 or later of the library, in case there are errors in the format conversion logic.</source>
          <target state="translated">ライブラリのバージョン2.6.0以降を使用して、バージョン2.5.6以前で作成されたデータベースファイルを開くと、データベースを新しい形式に再構築する試みが自動的に行われます。大規模なデータベースの場合、これには時間がかかる場合があります。 （Unixではデータベースのメガバイトあたり1秒または2秒を許可します-Windowsではより長くなります。）このフォーマット変換は元に戻せません。&lt;strong&gt;強く&lt;/strong&gt;、あなたがた場合にフォーマット変換ロジックにエラーがある、以降のライブラリのバージョン2.6.0またはそれらを開く前に、古いデータベースファイルのバックアップコピーを作成することを示唆しました。</target>
        </trans-unit>
        <trans-unit id="57f756e359121a9c945b91158a295a20dd82b0db" translate="yes" xml:space="preserve">
          <source>If you want to configure the new project, type:</source>
          <target state="translated">新しいプロジェクトを設定したい場合は、タイプします。</target>
        </trans-unit>
        <trans-unit id="bda3419a07a7eb3933cb5a599b2b66398d9d3b26" translate="yes" xml:space="preserve">
          <source>If you want to know how the SQLite library works internally, you need to begin with a solid understanding of the Virtual Database Engine or VDBE. The VDBE occurs right in the middle of the processing stream (see the &lt;a href=&quot;arch&quot;&gt;architecture diagram&lt;/a&gt;) and so it seems to touch most parts of the library. Even parts of the code that do not directly interact with the VDBE are usually in a supporting role. The VDBE really is the heart of SQLite.</source>
          <target state="translated">SQLiteライブラリが内部でどのように機能するかを知りたい場合は、まず仮想データベースエンジンまたはVDBEをしっかりと理解する必要があります。 VDBEは処理ストリームの真ん中に発生するため（&lt;a href=&quot;arch&quot;&gt;アーキテクチャ図を参照&lt;/a&gt;）、ライブラリのほとんどの部分に影響しているようです。 VDBEと直接対話しないコードの部分でさえ、通常はサポートの役割を果たします。 VDBEは本当にSQLiteの心臓部です。</target>
        </trans-unit>
        <trans-unit id="45ef57f77f1b898b089bfb8776638647a0457adc" translate="yes" xml:space="preserve">
          <source>If you want to use a keyword as a name, you need to quote it. There are four ways of quoting keywords in SQLite:</source>
          <target state="translated">キーワードを名前として使いたい場合は、そのキーワードを引用する必要があります。SQLiteでキーワードを引用するには4つの方法があります。</target>
        </trans-unit>
        <trans-unit id="33c132e45cdeb83d38d9892ca9d1c9494534573d" translate="yes" xml:space="preserve">
          <source>If you will be opening multiple database connections in your application, rather than invoking the extension entry points for each database connection separately, you might want to consider using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions and to cause them to be automatically started as each database connection is opened. You only have to register each extension once, and you can do so near the beginning of your main() routine. Using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions makes your extensions work as if they were built into the core SQLite - they automatically exist whenever you open a new database connection without needing to be initialized. Just be sure to complete any configuration you need to accomplish using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; before registering your extensions, since the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface implicitly calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">アプリケーションで複数のデータベース接続を開く場合は、各データベース接続の拡張エントリポイントを個別に呼び出すのではなく、&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;インターフェースを使用して拡張を登録し、それぞれの拡張を自動的に開始することを検討できます。データベース接続が開かれます。各拡張機能を登録する必要があるのは一度だけであり、main（）ルーチンの開始近くで登録できます。&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;インターフェースを使用して拡張機能を登録すると、拡張機能はコアSQLiteに組み込まれているかのように機能します。初期化する必要なく新しいデータベース接続を開くと、拡張機能は自動的に存在します。使用するために必要な設定をすべて完了してください。&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;以来、拡張機能を登録する前に&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;インタフェースは暗黙的に呼び出します&lt;a href=&quot;c3ref/initialize&quot;&gt;（）sqlite3_initializeを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2a19b719f76f7faa9b10e93907a0fe776f85db7" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 140 terabytes in size, assuming you can find a disk drive and filesystem that will support 140-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="translated">データが1つのディスクファイルに収まりきらない、あるいは収まりきらないサイズにまで大きくなるのであれば、SQLite以外のソリューションを選択すべきです。SQLite は、140 テラバイトのファイルをサポートするディスク ドライブとファイルシステムがあれば、140 テラバイトまでのデータベースをサポートしています。それでも、コンテンツのサイズがテラバイトの範囲内に収まりそうな場合は、集中型のクライアント/サーバーデータベースを検討するのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="b8bce6edf7a889c813c03d5b445472e1ddc49ad2" translate="yes" xml:space="preserve">
          <source>If your system defines a custom OS interface for SQLite or if you were using the undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface, then you will need to make modifications in order to upgrade to SQLite version 3.5.0. This may seem painful at first glance. But as you look more closely, you will probably discover that your changes are made smaller and easier to understand and manage by the new SQLite interface. It is likely that your changes will now also work seamlessly with the SQLite amalgamation. You will no longer need to make any changes to the code SQLite source code. All of your changes can be effected by application code and you can link against a standard, unmodified version of the SQLite amalgamation. Furthermore, the OS interface layer, which was formerly undocumented, is now an officially support interface for SQLite. So you have some assurance that this will be a one-time change and that your new backend will continue to work in future versions of SQLite.</source>
          <target state="translated">システムがSQLiteのカスタムOSインターフェースを定義している場合、または文書化されていない&lt;b&gt;sqlite3_os_switch（）&lt;/b&gt;を使用していた場合&lt;b&gt;&lt;/b&gt;インターフェイス、SQLiteバージョン3.5.0にアップグレードするために変更を加える必要があります。これは一見苦痛に思えるかもしれません。しかし、よく見ると、変更が小さくなり、新しいSQLiteインターフェースによって理解と管理が容易になることに気付くでしょう。これで、変更がSQLiteアマルガムとシームレスに機能するようになります。コードSQLiteソースコードに変更を加える必要はもうありません。すべての変更はアプリケーションコードの影響を受ける可能性があり、SQLite融合の標準の変更されていないバージョンに対してリンクできます。さらに、以前はドキュメント化されていなかったOSインターフェース層が、SQLiteの公式サポートインターフェースになりました。したがって、これは1回限りの変更であり、新しいバックエンドがSQLiteの将来のバージョンでも引き続き機能することが保証されます。</target>
        </trans-unit>
        <trans-unit id="4d01491e7aaf0e3b7eeb3d6755bf0ba092a441ec" translate="yes" xml:space="preserve">
          <source>If zipfile() is invoked with 2 arguments, then the entry added to the archive is equivalent to that added by inserting the same two values into the &quot;name&quot; and &quot;data&quot; columns of a zipfile virtual table, with all other values set to NULL. If invoked with 4 arguments, it is equivalent to inserting the 4 values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot; and &quot;data&quot; columns. In other words, the following pairs of queries are equivalent:</source>
          <target state="translated">zipfile()が 2 つの引数で起動された場合、 アーカイブに追加されるエントリは、同じ 2 つの値を zipfile 仮想テーブルの &quot;name&quot; と &quot;data&quot; カラムに挿入して追加したものと同等のものとなり、 他のすべての値は NULL に設定されます。4 つの引数で呼び出された場合、4 つの値を &quot;name&quot;,&quot;mode&quot;,&quot;mtime&quot;,&quot;data&quot; の列に挿入するのと同じことになります。言い換えれば、以下のペアのクエリが等価である。</target>
        </trans-unit>
        <trans-unit id="d49c9a42ebbe9cba3927bb51a35d92fe353713e9" translate="yes" xml:space="preserve">
          <source>If, as part of the</source>
          <target state="translated">の一部として</target>
        </trans-unit>
        <trans-unit id="1b931ae5cbce5d6c96daf33260c2b72ee5539dbd" translate="yes" xml:space="preserve">
          <source>If, while opening a</source>
          <target state="translated">を開いている間に</target>
        </trans-unit>
        <trans-unit id="f48c9c6740ea7cbd9ee32d778ecff2f9da591ab1" translate="yes" xml:space="preserve">
          <source>IfNoHope</source>
          <target state="translated">IfNoHope</target>
        </trans-unit>
        <trans-unit id="0d430ae72e07c71cbfc6aac6b856ba69c4a14902" translate="yes" xml:space="preserve">
          <source>IfNot</source>
          <target state="translated">IfNot</target>
        </trans-unit>
        <trans-unit id="d2a091305f84e463b224fd2549c504926b658103" translate="yes" xml:space="preserve">
          <source>IfNotZero</source>
          <target state="translated">IfNotZero</target>
        </trans-unit>
        <trans-unit id="8ea5813d833284a6b426730c347d4a031b76be44" translate="yes" xml:space="preserve">
          <source>IfNullRow</source>
          <target state="translated">IfNullRow</target>
        </trans-unit>
        <trans-unit id="7661d111573d853c18bf38582f4762e932f703e7" translate="yes" xml:space="preserve">
          <source>IfPos</source>
          <target state="translated">IfPos</target>
        </trans-unit>
        <trans-unit id="a6bb95ea00b2b20f56a2debeb7afeb897471ef50" translate="yes" xml:space="preserve">
          <source>IfSmaller</source>
          <target state="translated">IfSmaller</target>
        </trans-unit>
        <trans-unit id="91d8cebb7b70f29e3262ce44bfc944c449089a8d" translate="yes" xml:space="preserve">
          <source>Ignore extra whitespace at the end of of &quot;.&quot; commands in the shell.</source>
          <target state="translated">シェル内の &quot;.&quot; コマンドの末尾にある余分な空白を無視するようにしました。</target>
        </trans-unit>
        <trans-unit id="d609bda3312485a36bcab24d9a33ae880a4d9c03" translate="yes" xml:space="preserve">
          <source>Immediately after an iterator is created by sqlite3changeset_start(), it does not point to any change in the changeset. Assuming the changeset is not empty, the first call to this function advances the iterator to point to the first change in the changeset. Each subsequent call advances the iterator to point to the next change in the changeset (if any). If no error occurs and the iterator points to a valid change after a call to sqlite3changeset_next() has advanced it, SQLITE_ROW is returned. Otherwise, if all changes in the changeset have already been visited, SQLITE_DONE is returned.</source>
          <target state="translated">sqlite3changeset_start()によってイテレータが作成された直後は、チェンジセット内のいかなる変更も指し示しません。チェンジセットが空ではないと仮定して、この関数の最初の呼び出しは、チェンジセットの最初の変更を指すようにイテレータを進めます。それ以降の各呼び出しは、チェンジセット内の次の変更点を指すようにイテレータを進めます(もしあれば)。エラーが発生せず、sqlite3changeset_next()が呼び出された後にイテレータが有効な変更を指し示す場合、SQLITE_ROWが返されます。そうでなければ、チェンジセット内のすべての変更がすでに訪問されている場合、SQLITE_DONEが返されます。</target>
        </trans-unit>
        <trans-unit id="49deaa07b4de652a28623d07d5618cb8f1e55666" translate="yes" xml:space="preserve">
          <source>Immediately following the wal-header are zero or more frames. Each frame consists of a 24-byte frame-header followed by a</source>
          <target state="translated">wal-headerの直後には、0個以上のフレームがある。各フレームは、24バイトのフレームヘッダの後に</target>
        </trans-unit>
        <trans-unit id="efc77ef3528cb380e78002c642146ddfcb72a6c8" translate="yes" xml:space="preserve">
          <source>Implement a procedure that calls &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and passes it a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure from the previous step. This procedure is probably the only exported symbol in the source file that implements your VFS.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;を呼び出して、前の手順の&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;構造体へのポインタを渡すプロシージャを実装します。この手順は、おそらくVFSを実装するソースファイル内の唯一のエクスポートされたシンボルです。</target>
        </trans-unit>
        <trans-unit id="5f991f27713d088110dc4560a5b48613a2e55fa7" translate="yes" xml:space="preserve">
          <source>Implement the &quot;LIMIT ... OFFSET ...&quot; clause on SELECT statements.</source>
          <target state="translated">SELECT文に「LIMIT ...OFFSET ...」句を実装しました。</target>
        </trans-unit>
        <trans-unit id="cb1780300fa34dfe12b3de8afb5a8d426d248748" translate="yes" xml:space="preserve">
          <source>Implement the methods required by the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトが必要とするメソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="edbf1d07115719c5c7e93d86f1046b341948dbde" translate="yes" xml:space="preserve">
          <source>Implement the other methods required by &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfsが&lt;/a&gt;必要とする他のメソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="a8b02a72a8b5be24e42656704837d215920a00aa" translate="yes" xml:space="preserve">
          <source>Implement the xOpen method that opens a file and populates an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object, including setting pMethods to point to the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object from the previous step.</source>
          <target state="translated">前の手順の&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトを指すようにpMethodsを設定するなど、ファイルを開いて&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトにデータを入力するxOpenメソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="87cdff8728ab99514f76ab384b99b3f529310cf0" translate="yes" xml:space="preserve">
          <source>Implementation Limits For SQLite</source>
          <target state="translated">SQLite の実装の限界</target>
        </trans-unit>
        <trans-unit id="32808d9f543dc0758af6de0786717c61ede1f9c3" translate="yes" xml:space="preserve">
          <source>Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.</source>
          <target state="translated">集約SQL関数の実装では、このルーチンを使用して、その状態を格納するためのメモリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="4018bcd662e8105cb957cfc5a507fd128f58cc71" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;c3ref/create_function&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="translated">カスタム補助関数の実装は、&lt;a href=&quot;c3ref/create_function&quot;&gt;スカラーSQL関数の&lt;/a&gt;実装に似ています。実装は、次のように定義されたタイプfts5_extension_functionのC関数である必要があります。</target>
        </trans-unit>
        <trans-unit id="cf816f713b7837e18241382d77dfd40a1b6bacf3" translate="yes" xml:space="preserve">
          <source>Implicit versus explicit transactions</source>
          <target state="translated">暗黙の取引と明示の取引</target>
        </trans-unit>
        <trans-unit id="2f1059e48758f0fdc4ddd1f86b6fae46066d008b" translate="yes" xml:space="preserve">
          <source>Important bug fix: the IN operator was not working if either the left-hand or right-hand side was derived from an INTEGER PRIMARY KEY.</source>
          <target state="translated">重要なバグ修正:左側または右側のどちらかが INTEGER PRIMARY KEY から派生している場合に IN 演算子が動作していませんでした。</target>
        </trans-unit>
        <trans-unit id="a0fe78ecda103e8930771647f6dec46b0b349000" translate="yes" xml:space="preserve">
          <source>Impose A Limit On Heap Size</source>
          <target state="translated">ヒープサイズに制限をかける</target>
        </trans-unit>
        <trans-unit id="ed65a595437d44d40ac23326bd1b47c2bed21cbd" translate="yes" xml:space="preserve">
          <source>Imposter Tables</source>
          <target state="translated">インポスターテーブル</target>
        </trans-unit>
        <trans-unit id="8bd676db829fa1254e9904aed550e4eaa10267fe" translate="yes" xml:space="preserve">
          <source>Imposter tables are intended for analysis and debugging only. This is not a feature that most application developers should understand or even know about. Imposter tables are for experts only.</source>
          <target state="translated">Imposterテーブルは、分析とデバッグのみを目的としています。これは、ほとんどのアプリケーション開発者が理解すべき機能ではありませんし、知るべき機能でもありません。インポスターテーブルは、エキスパートのみを対象としています。</target>
        </trans-unit>
        <trans-unit id="310974bd6288a19d56c62511f50674a5f6b79b46" translate="yes" xml:space="preserve">
          <source>Improper use of imposter tables can cause index corruption, though any corruption created this way can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_reindex&quot;&gt;偽の&lt;/a&gt;テーブルを不適切に使用すると、インデックスが破損する可能性がありますが、この方法で作成された破損はREINDEXを実行することで修正できます。</target>
        </trans-unit>
        <trans-unit id="7cc4395a9bbe14f613da8e2834455cc8120ab269" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;omit-left-join optimization&lt;/a&gt; so that it works in cases where the right-hand table is UNIQUE but not necessarily NOT NULL.</source>
          <target state="translated">omit &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;-left-join最適化を&lt;/a&gt;改善して、右側のテーブルがUNIQUEであるが必ずしもNOT NULLではない場合に機能するようにします。</target>
        </trans-unit>
        <trans-unit id="15dafad2713cbb23a2ff9f35c0397160bab08c72" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#pushdown&quot;&gt;push-down optimization&lt;/a&gt; so that it works for many LEFT JOINs.</source>
          <target state="translated">&lt;a href=&quot;optoverview#pushdown&quot;&gt;プッシュダウンの最適化を&lt;/a&gt;改善して、多くのLEFT JOINで機能するようにします。</target>
        </trans-unit>
        <trans-unit id="115d57ca1c0c67b9c62b8627805bc54cd437ed61" translate="yes" xml:space="preserve">
          <source>Improve the format of the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; raw output, so that it gives better information about the query plan and about the relationships between the various components of the plan.</source>
          <target state="translated">&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLANの&lt;/a&gt; raw出力のフォーマットを改善して、クエリプランおよびプランのさまざまなコンポーネント間の関係についてのより良い情報を提供します。</target>
        </trans-unit>
        <trans-unit id="14bd38dceda1ed2c01f162d1f3444a0f4f8b3ecd" translate="yes" xml:space="preserve">
          <source>Improve the performance of fts3/4 queries that use the OR operator and at least one auxiliary fts function.</source>
          <target state="translated">OR演算子と少なくとも1つの補助fts関数を使用するfts3/4クエリのパフォーマンスを改善しました。</target>
        </trans-unit>
        <trans-unit id="b9c8f318457693f2fa88c903d8d43102377e8c69" translate="yes" xml:space="preserve">
          <source>Improve the performance of the &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace() SQL function&lt;/a&gt; for cases where there are many substitutions on megabyte-sized strings, in an attempt to avoid OSSFuzz timeouts during testing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</source>
          <target state="translated">テスト中のOSSFuzzタイムアウトを回避するために、メガバイトサイズの文字列で多くの置換が行われる場合の&lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace（）SQL関数&lt;/a&gt;のパフォーマンスを改善します。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="018ed5007819cc6bdecc581d33162266f7dd3fe7" translate="yes" xml:space="preserve">
          <source>Improved Concurrency</source>
          <target state="translated">並行性の向上</target>
        </trans-unit>
        <trans-unit id="072e9878a7002455b6aee44f48f435995e934eb5" translate="yes" xml:space="preserve">
          <source>Improved Concurrency.</source>
          <target state="translated">並行性の向上。</target>
        </trans-unit>
        <trans-unit id="fd596055fe2374f07cb22e2ed1eddaf72d523d42" translate="yes" xml:space="preserve">
          <source>Improved accuracy of floating-point conversions using &quot;long double&quot;.</source>
          <target state="translated">long double」を使用した浮動小数点変換の精度を向上させました。</target>
        </trans-unit>
        <trans-unit id="93fc56155be2598f9cbcf49e841b4a0140cf2c72" translate="yes" xml:space="preserve">
          <source>Improved algorithm for running queries with both an ORDER BY and a LIMIT where only the inner-most loop naturally generates rows in the correct order.</source>
          <target state="translated">ORDER BYとLIMITの両方を使用してクエリを実行する際に、最内周ループだけが正しい順序で行を自然に生成するようにアルゴリズムを改良しました。</target>
        </trans-unit>
        <trans-unit id="b070ecb9dcd3bd88a65a96d0f66e5d97c46345dc" translate="yes" xml:space="preserve">
          <source>Improved concurrency.</source>
          <target state="translated">並行性が向上しました。</target>
        </trans-unit>
        <trans-unit id="9f23829b58c284f668ccf3661f99fc3dbbec1e58" translate="yes" xml:space="preserve">
          <source>Improved crash-robustness: write the database page size into the rollback journal header.</source>
          <target state="translated">クラッシュ・ロバスト性の向上:データベースのページサイズをロールバック・ジャーナル・ヘッダに記述するようにしました。</target>
        </trans-unit>
        <trans-unit id="7321289816f2bf6478248e1de203f755159291e2" translate="yes" xml:space="preserve">
          <source>Improved de-quoting of column names for &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; statements with an aggregate query on the right-hand side.</source>
          <target state="translated">右側に集約クエリがある&lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt;ステートメントの列名のクォートの改善。</target>
        </trans-unit>
        <trans-unit id="bf0fc640800a9514f6d8718203e257a7690d605b" translate="yes" xml:space="preserve">
          <source>Improved error detection of misused aggregate functions.</source>
          <target state="translated">誤用された集計関数のエラー検出を改善しました。</target>
        </trans-unit>
        <trans-unit id="10bc21bc5dd5e57a67add58ea3202819c9a3c931" translate="yes" xml:space="preserve">
          <source>Improved error messages for &quot;foreign key mismatch&quot; showing the names of the two tables involved.</source>
          <target state="translated">外部キーの不一致」のエラーメッセージに、関係する2つのテーブル名を表示するようにしました。</target>
        </trans-unit>
        <trans-unit id="90dbb37d863c75537960cc5646693be15d517e85" translate="yes" xml:space="preserve">
          <source>Improved error messages for invalid boolean arguments to dot-commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;ドットコマンドに対する無効なブール引数のエラーメッセージが改善されました。</target>
        </trans-unit>
        <trans-unit id="b0dec14662a3a9f70430b0cb1619e2a60b783318" translate="yes" xml:space="preserve">
          <source>Improved error messages in the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension.</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;拡張のエラーメッセージが改善されました。</target>
        </trans-unit>
        <trans-unit id="2c62ff1f4b8293cf16ee945ea648937c03b9bc58" translate="yes" xml:space="preserve">
          <source>Improved fuzz-testing of database files, with fixes for problems found.</source>
          <target state="translated">データベースファイルのファズテストを改善し、見つかった問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="26cc1d230c175a8810d6dd909c46be8d110c203b" translate="yes" xml:space="preserve">
          <source>Improved name resolution for deeply nested queries.</source>
          <target state="translated">深い入れ子になったクエリの名前解決が改善されました。</target>
        </trans-unit>
        <trans-unit id="d3565d7b7ed6ef82845a8772788a705a908dc7c3" translate="yes" xml:space="preserve">
          <source>Improved optimization of &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt;演算子の最適化の改善。</target>
        </trans-unit>
        <trans-unit id="a23eee66d3ed2b6341f9511337eea95095e21556" translate="yes" xml:space="preserve">
          <source>Improved optimization of AND and OR operators when one or the other operand is a constant.</source>
          <target state="translated">一方または他方のオペランドが定数である場合のAND演算子およびOR演算子の最適化を改善しました。</target>
        </trans-unit>
        <trans-unit id="524c0e2c2353a4bf3f7178e269f56a6cac4ecf9b" translate="yes" xml:space="preserve">
          <source>Improved optimization of ORDER BY clauses on compound queries.</source>
          <target state="translated">複合クエリのORDER BY句の最適化を改善しました。</target>
        </trans-unit>
        <trans-unit id="af8c59932cd987b7607835b656e726f3dcea902b" translate="yes" xml:space="preserve">
          <source>Improved optimization of aggregate subqueries contained within an aggregate query.</source>
          <target state="translated">アグリゲートクエリ内に含まれるアグリゲートサブクエリの最適化が改善されました。</target>
        </trans-unit>
        <trans-unit id="d664cf7cb7a8aa891620cace778bbb7e18301125" translate="yes" xml:space="preserve">
          <source>Improved optimization of queries containing aggregate min() or max().</source>
          <target state="translated">集約min()またはmax()を含むクエリの最適化が改善されました。</target>
        </trans-unit>
        <trans-unit id="84a557fad116fe49221d1a9424a92f1e575e49e1" translate="yes" xml:space="preserve">
          <source>Improved performance of queries with many OR-connected terms in the WHERE clause that can all be indexed.</source>
          <target state="translated">すべてのインデックスを作成できるWHERE句で、多くのOR接続語を持つクエリのパフォーマンスを向上させました。</target>
        </trans-unit>
        <trans-unit id="fc268c97ccbef9521d6905694e7c21645578065f" translate="yes" xml:space="preserve">
          <source>Improved pthreads detection in configure scripts.</source>
          <target state="translated">configureスクリプトでのpthreadの検出を改善しました。</target>
        </trans-unit>
        <trans-unit id="17ac50232b81e80729264e903268e1bebc9e53d7" translate="yes" xml:space="preserve">
          <source>Improved query plan optimization when the DISTINCT keyword is present.</source>
          <target state="translated">DISTINCTキーワードが存在する場合のクエリプランの最適化を改善しました。</target>
        </trans-unit>
        <trans-unit id="59b96d30821cc9cbdef8a394c82f7fd97d223fd7" translate="yes" xml:space="preserve">
          <source>Improved resistance against goofy query planner decisions caused by incomplete or incorrect modifications to the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; table by the application.</source>
          <target state="translated">アプリケーションによる&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;テーブルの不完全または誤った変更によって引き起こされる、間抜けなクエリプランナーの決定に対する耐性の向上。</target>
        </trans-unit>
        <trans-unit id="6b8ef39e97edafb5ec621a586930697f00cfaa0e" translate="yes" xml:space="preserve">
          <source>Improved response to out-of-memory errors</source>
          <target state="translated">メモリ切れエラーへの対応が改善されました。</target>
        </trans-unit>
        <trans-unit id="5ae15f37694ee149c6eea70b18fae46fd07528e4" translate="yes" xml:space="preserve">
          <source>Improved robustness against corrupt database files.</source>
          <target state="translated">破損したデータベースファイルに対するロバスト性を向上させました。</target>
        </trans-unit>
        <trans-unit id="166028811fd163330b2455278e9c44de42779fbe" translate="yes" xml:space="preserve">
          <source>Improved support for Cygwin.</source>
          <target state="translated">Cygwinのサポートを強化しました。</target>
        </trans-unit>
        <trans-unit id="4c53e2cba5a1410927dfe514c0901b0fd71f140c" translate="yes" xml:space="preserve">
          <source>Improved support for using the STDCALL calling convention in winsqlite3.dll.</source>
          <target state="translated">winsqlite3.dllでのSTDCALL呼び出し規則の使用のサポートを改善しました。</target>
        </trans-unit>
        <trans-unit id="92763dc3583bdd282b9026c7f80e9e51775413fc" translate="yes" xml:space="preserve">
          <source>Improved syntax error messages in the parser</source>
          <target state="translated">パーサーでの構文エラーメッセージの改善</target>
        </trans-unit>
        <trans-unit id="35f950df2561f1db8f684a7b33f41fde15c8c04c" translate="yes" xml:space="preserve">
          <source>Improved test coverage</source>
          <target state="translated">テストカバレッジの向上</target>
        </trans-unit>
        <trans-unit id="6fb91ee1a232fc876617f991f25282c326c1cf11" translate="yes" xml:space="preserve">
          <source>Improved test coverage. Fixed a few obscure bugs found by the improved tests.</source>
          <target state="translated">テスト範囲を改善しました。改良されたテストで見つかったいくつかの不明瞭なバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="5177fb86b97cfe6466bc589640835c3dab84ade3" translate="yes" xml:space="preserve">
          <source>Improved the cost estimation for an index scan which includes a WHERE clause that can be partially or fully evaluated using columns in the index and without having to do a table lookup. This fixes a performance regression that occurred for some obscure queries following the ORDER BY LIMIT optimization introduced in &lt;a href=&quot;#version_3_12_0&quot;&gt;version 3.12.0&lt;/a&gt;.</source>
          <target state="translated">インデックスの列を使用して部分的または完全に評価できるWHERE句を含むインデックススキャンのコスト見積もりを改善しました。テーブルルックアップを実行する必要はありません。これにより、&lt;a href=&quot;#version_3_12_0&quot;&gt;バージョン3.12.0で&lt;/a&gt;導入されたORDER BY LIMIT最適化に続く不明瞭なクエリで発生したパフォーマンスの低下が修正されます。</target>
        </trans-unit>
        <trans-unit id="9737446abc238ba64625d047b10e2ea194379924" translate="yes" xml:space="preserve">
          <source>Improved the query planner so that the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; can be used on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if one or more of the disjuncts use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; operators.</source>
          <target state="translated">クエリプランナーが改善され、1つ以上の論理和が&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;、&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;、&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;、&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;演算子を使用している場合でも、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;で&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR最適化&lt;/a&gt;を使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="7c7991b90a25fa494ea7173ba16f41d0e843c78b" translate="yes" xml:space="preserve">
          <source>Improved the windows VFS to better defend against interference from anti-virus software.</source>
          <target state="translated">Windows VFSを改善し、アンチウイルスソフトウェアからの干渉をよりよく防御できるようにしました。</target>
        </trans-unit>
        <trans-unit id="6c9542942225b685370a9ff791f1911ab55a40d4" translate="yes" xml:space="preserve">
          <source>Improved tracing and debugging facilities in the Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Windows &lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt;改善されたトレースおよびデバッグ機能。</target>
        </trans-unit>
        <trans-unit id="c1ee9a0442382c4cebcfe1b576c0d1fff396e4cb" translate="yes" xml:space="preserve">
          <source>Improved unicode filename handling in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; on Windows.</source>
          <target state="translated">Windowsの&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;でのUnicodeファイル名の処理が改善されました。</target>
        </trans-unit>
        <trans-unit id="09e6f225ca0ca885645a927e0763b14b484dc7f0" translate="yes" xml:space="preserve">
          <source>Improvements and bug-fixes in support for &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINTの&lt;/a&gt;サポートにおける改善とバグ修正。</target>
        </trans-unit>
        <trans-unit id="c4b534f7c6c26f504f16d9c38af50fef3ae45002" translate="yes" xml:space="preserve">
          <source>Improvements to &quot;dot-command&quot; handling in the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインインターフェース&lt;/a&gt;での「ドットコマンド」処理の改善。</target>
        </trans-unit>
        <trans-unit id="47099268e1cc1a7d37272d0a960d324c9d2e5b20" translate="yes" xml:space="preserve">
          <source>Improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3の&lt;/a&gt;改善。</target>
        </trans-unit>
        <trans-unit id="18fe2fab208a9bdfd95bd5b0724b7f338ba76be8" translate="yes" xml:space="preserve">
          <source>Improvements to cost estimates for the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview#skipscan&quot;&gt;スキップスキャン最適化の&lt;/a&gt;コスト見積もりの​​改善。</target>
        </trans-unit>
        <trans-unit id="5353c2af79675cc29c5733088967c970c2cbd2d3" translate="yes" xml:space="preserve">
          <source>Improvements to test coverage, other minor bugs fixed, memory leaks plugged, code refactored and/or recommended in places for easier reading.</source>
          <target state="translated">テストカバレッジの改善、その他の軽微なバグの修正、メモリリークの修正、コードのリファクタリング、読みやすい場所での推奨などを行いました。</target>
        </trans-unit>
        <trans-unit id="1672d028ed8042c2cdc755bd4feb4bfb1a305542" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;.help&quot; command.</source>
          <target state="translated">.help&quot; コマンドの改良。</target>
        </trans-unit>
        <trans-unit id="9829e00db8ef5babdf62ad53520c9aed14ba5d0e" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;PRAGMA integrity_check&quot; command</source>
          <target state="translated">PRAGMA integrity_check &quot;コマンドの改善</target>
        </trans-unit>
        <trans-unit id="e5c25ee1584b55a6798dccb371f9de65d6e26320" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;改善：</target>
        </trans-unit>
        <trans-unit id="7bd7a08c86f6e2927260bf75b7f206267bdb5a66" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli#recover&quot;&gt;.recover dot-command&lt;/a&gt; in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it recovers more content from corrupt database files.</source>
          <target state="translated">破損したデータベースファイルからより多くのコンテンツを回復できるように、&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;の&lt;a href=&quot;cli#recover&quot;&gt;.recoverドットコマンドの&lt;/a&gt;改善。</target>
        </trans-unit>
        <trans-unit id="56bedeb29e748e173925f592478fb7224bd2a9a7" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;automerge command&lt;/a&gt; of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; to better control the index size for a full-text index that is subject to a large number of updates.</source>
          <target state="translated">改善&lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;自動マージコマンド&lt;/a&gt;の&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;良く多数の更新の対象となるフルテキストインデックスのインデックスサイズを制御します。</target>
        </trans-unit>
        <trans-unit id="4f8a0d7434e9fa0e3d93bd594ec2f731beeeee4c" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;optoverview&quot;&gt;クエリプランナーの&lt;/a&gt;改善：</target>
        </trans-unit>
        <trans-unit id="64a384308e143ce85fad7f48be7bf89bd88826a0" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax bubble diagrams&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;syntaxdiagrams&quot;&gt;構文バブル図の&lt;/a&gt;改善</target>
        </trans-unit>
        <trans-unit id="444f392b3ac06b6a270033461a34681437b33fc9" translate="yes" xml:space="preserve">
          <source>Improvements to the Makefiles and build scripts used by VisualStudio.</source>
          <target state="translated">VisualStudio で使用される Makefile とビルドスクリプトの改善。</target>
        </trans-unit>
        <trans-unit id="187c307e740f14eb7715914261b63385a7891140" translate="yes" xml:space="preserve">
          <source>Improvements to the amalgamation generator script so that all symbols are prefixed with either SQLITE_PRIVATE or SQLITE_API.</source>
          <target state="translated">アマルガム生成スクリプトの改良により、すべてのシンボルの前に SQLITE_PRIVATE または SQLITE_API のいずれかが付くようになりました。</target>
        </trans-unit>
        <trans-unit id="8487f548381bd47de49bbe554c9e3c26fcef5a1f" translate="yes" xml:space="preserve">
          <source>Improvements to the comments in the VDBE byte-code display when running &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_explain&quot;&gt;EXPLAINの&lt;/a&gt;実行時のVDBEバイトコード表示のコメントの改善。</target>
        </trans-unit>
        <trans-unit id="e6a8494de38f18f2b5e148ff117a682e5366a648" translate="yes" xml:space="preserve">
          <source>Improvements to the effectiveness and accuracy of the &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; SQL hint functions.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;尤度（）&lt;/a&gt;、尤度&lt;a href=&quot;lang_corefunc#likely&quot;&gt;（）&lt;/a&gt;、および&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;可能性（）の&lt;/a&gt; SQLヒント関数の有効性と精度の改善。</target>
        </trans-unit>
        <trans-unit id="fb078db70835b73a43d340944c34ddf931e04436" translate="yes" xml:space="preserve">
          <source>Improvements to the handling of CSV inputs in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;でのCSV入力の処理の改善</target>
        </trans-unit>
        <trans-unit id="35621122cb25f12ea29297b200f9cd7f54653df0" translate="yes" xml:space="preserve">
          <source>Improvements to the query planner so that it makes better estimates of plan costs and hence does a better job of choosing the right plan, especially when &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; is used.</source>
          <target state="translated">特に&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;が使用されている場合に、クエリプランナーの改善により、プランのコストをより正確に見積もり、適切なプランをより適切に選択できるようになりました。</target>
        </trans-unit>
        <trans-unit id="b56408ef9cd6514cec8e529db1c7c154a8214dac" translate="yes" xml:space="preserve">
          <source>Improvements to the windows makefiles and build processes.</source>
          <target state="translated">Windows の makefile とビルドプロセスの改善。</target>
        </trans-unit>
        <trans-unit id="b24a3b4f842f4beb9d0cf338bd2105050638be32" translate="yes" xml:space="preserve">
          <source>In &quot;line&quot; mode, each column in a row of the database is shown on a line by itself. Each line consists of the column name, an equal sign and the column data. Successive records are separated by a blank line. Here is an example of line mode output:</source>
          <target state="translated">行」モードでは、データベースの行の各列がそれ自身で行として表示されます。各行は、カラム名、等号、カラムデータで構成されています。連続するレコードは空白行で区切られます。以下にラインモードの出力例を示します。</target>
        </trans-unit>
        <trans-unit id="ba464cb54f172ce24a6d088a3cb06af2c611f784" translate="yes" xml:space="preserve">
          <source>In &quot;quote&quot; mode, the output is formatted as SQL literals. Strings are enclosed in single-quotes and internal single-quotes are escaped by doubling. Blobs are displayed in hexadecimal blob literal notation (Ex: x'abcd'). Numbers are displayed as ASCII text and NULL values are shown as &quot;NULL&quot;. All columns are separated from each other by a comma (or whatever alternative character is selected using &quot;.separator&quot;).</source>
          <target state="translated">quote &quot;モードでは、出力はSQLリテラルとしてフォーマットされます。文字列はシングルクォートで囲まれ、内部のシングルクォートは倍数でエスケープされます。ブロブは16進数のブロブリテラル表記で表示されます(例:x'abcd')。数字はASCIIテキストとして表示され、NULL値は &quot;NULL &quot;として表示されます。すべての列はカンマで区切られています(または、&quot;.separator &quot;を使用して選択された代替文字であれば何でも構いません)。</target>
        </trans-unit>
        <trans-unit id="e70135d1b4c87e02724b6a6725f67c0cdcedb6a8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">で&lt;a href=&quot;../wal&quot;&gt;WALモード&lt;/a&gt;、複数&lt;a href=&quot;sqlite3&quot;&gt;のデータベース接続&lt;/a&gt;同じデータベースファイルに開かれている各データベース・ファイルの異なるバージョンの履歴を読み出すことができます。ときに&lt;a href=&quot;sqlite3&quot;&gt;、データベース接続が&lt;/a&gt;読み取りトランザクションを開始トランザクションが最初に始めたとき、それは時間のポイントのために存在していたとして、その接続はデータベースの不変のコピーを見ています。他の接続からのその後のデータベースへの変更は、新しい読み取りトランザクションが開始されるまでリーダーには表示されません。</target>
        </trans-unit>
        <trans-unit id="545faac3a749c9fbe686ac2c42b0a8ce0746bb4b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), shared-cache mode was modified so that the same cache can be shared across an entire process rather than just within a single thread. Prior to this change, there were restrictions on passing database connections between threads. Those restrictions were dropped in 3.5.0 update. This document describes shared-cache mode as of version 3.5.0.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;バージョン3.5.0&lt;/a&gt;（2007-09-04）、共有キャッシュ・モードは、同じキャッシュがプロセス全体を横切るだけではなく、単一のスレッド内で共有することができるように変更されました。この変更の前は、スレッド間でのデータベース接続の受け渡しに制限がありました。これらの制限は3.5.0アップデートで削除されました。このドキュメントでは、バージョン3.5.0以降の共有キャッシュモードについて説明します。</target>
        </trans-unit>
        <trans-unit id="8b22aada76f514795f041039b72ce60807690314" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; mode, call fsync() immediately after truncating the journal file to ensure that the transaction is durable across a power loss.</source>
          <target state="translated">では&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;プラグマjournal_mode = TRUNCATEの&lt;/a&gt;モード、コールのfsync（）すぐにジャーナル・ファイルを切り捨てた後、トランザクションが電力損失全体の耐久性があることを確認します。</target>
        </trans-unit>
        <trans-unit id="b06cad3e4dffb16827f43add94eb56f4465695b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, attempting to attach the same database file more than once results in an error.</source>
          <target state="translated">では&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;、エラーが発生し複数回同じデータベースファイルを添付しようとします。</target>
        </trans-unit>
        <trans-unit id="4d45c296410a6677088e7e7ac84b1e93a1f22edc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">で&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;、複数&lt;a href=&quot;#sqlite3&quot;&gt;のデータベース接続&lt;/a&gt;同じデータベースファイルに開かれている各データベース・ファイルの異なるバージョンの履歴を読み出すことができます。ときに&lt;a href=&quot;#sqlite3&quot;&gt;、データベース接続が&lt;/a&gt;読み取りトランザクションを開始トランザクションが最初に始めたとき、それは時間のポイントのために存在していたとして、その接続はデータベースの不変のコピーを見ています。他の接続からのその後のデータベースへの変更は、新しい読み取りトランザクションが開始されるまでリーダーには表示されません。</target>
        </trans-unit>
        <trans-unit id="ddd420dd1a1ef7aee27736d7c043708aacde1ceb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode when synchronous is NORMAL (1), the WAL file is synchronized before each &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the database file is synchronized after each completed &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the WAL file header is synchronized when a WAL file begins to be reused after a checkpoint, but no sync operations occur during most transactions. With synchronous=FULL in WAL mode, an additional sync operation of the WAL file happens after each transaction commit. The extra WAL sync following each transaction help ensure that transactions are durable across a power loss. Transactions are consistent with or without the extra syncs provided by synchronous=FULL. If durability is not a concern, then synchronous=NORMAL is normally all one needs in WAL mode.</source>
          <target state="translated">で&lt;a href=&quot;wal&quot;&gt;WALの&lt;/a&gt;モード同期は、NORMAL（1）である場合、WALファイルには、各前同期化され&lt;a href=&quot;wal#ckpt&quot;&gt;たチェックポイント&lt;/a&gt;と各完了後にデータベースファイルが同期され&lt;a href=&quot;wal#ckpt&quot;&gt;、チェックポイント&lt;/a&gt; WALファイルは、チェックポイント後に再利用され始めたときとWALファイルヘッダが同期され、ありません同期操作は、ほとんどのトランザクション中に発生します。 WALモードでsynchronized = FULLを使用すると、トランザクションがコミットされるたびに、WALファイルの追加の同期操作が発生します。各トランザクションに続く追加のWAL同期により、停電時でもトランザクションの耐久性が確保されます。トランザクションは、synchronized = FULLによって提供される追加の同期の有無にかかわらず一貫しています。耐久性が問題にならない場合は、通常、synchronous = NORMALがWALモードで必要なすべてです。</target>
        </trans-unit>
        <trans-unit id="1207ec4eb27468881c3e5a75c509547ec16346af" translate="yes" xml:space="preserve">
          <source>In DDL</source>
          <target state="translated">DDLでは</target>
        </trans-unit>
        <trans-unit id="0fc22d3edb7a25933470b0fc98cd018feb112e2e" translate="yes" xml:space="preserve">
          <source>In DML</source>
          <target state="translated">DMLでは</target>
        </trans-unit>
        <trans-unit id="805c25b267572c14bae2116b6611f039f1f80c5c" translate="yes" xml:space="preserve">
          <source>In I/O error tests, after the I/O error simulation failure mechanism is disabled, the database is examined using &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to make sure that the I/O error has not introduced database corruption.</source>
          <target state="translated">I / Oエラーテストでは、I / Oエラーシミュレーションの失敗メカニズムを無効にした後、&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMAの整合性&lt;/a&gt;チェックを使用してデータベースを調べ、I / Oエラーがデータベースの破損を引き起こしていないことを確認します。</target>
        </trans-unit>
        <trans-unit id="0f2cfcdcfc92b4b01bee8dec645ecb5ceaaa8098" translate="yes" xml:space="preserve">
          <source>In Lemon, the tokenizer calls the parser. Yacc operates the other way around, with the parser calling the tokenizer. The Lemon approach is reentrant and threadsafe, whereas Yacc uses global variables and is therefore neither. Reentrancy is especially important for SQLite since some SQL statements make recursive calls to the parser. For example, when parsing a CREATE TABLE statement, SQLite invokes the parser recursively to generate an INSERT statement to make a new entry in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table.</source>
          <target state="translated">レモンでは、トークナイザーはパーサーを呼び出します。Yaccは逆の方法で動作し、パーサーはトークナイザーを呼び出します。レモンのアプローチは再入可能でスレッドセーフですが、Yaccはグローバル変数を使用するため、どちらも使用されません。一部のSQLステートメントはパーサーを再帰的に呼び出すため、再入可能性はSQLiteにとって特に重要です。たとえば、CREATE TABLEステートメントを解析する場合、SQLiteはパーサーを再帰的に呼び出してINSERTステートメントを生成し、&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;テーブルに新しいエントリを作成します。</target>
        </trans-unit>
        <trans-unit id="d3369588aeb6a765cf20a5709a06e66a042c401f" translate="yes" xml:space="preserve">
          <source>In NORMAL locking-mode (the default unless overridden at compile-time using &lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;), a database connection unlocks the database file at the conclusion of each read or write transaction. When the locking-mode is set to EXCLUSIVE, the database connection never releases file-locks. The first time the database is read in EXCLUSIVE mode, a shared lock is obtained and held. The first time the database is written, an exclusive lock is obtained and held.</source>
          <target state="translated">NORMALロッキングモード（コンパイル時に&lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;を使用してオーバーライドされない限り、デフォルト）では、データベース接続は、各読み取りまたは書き込みトランザクションの終了時にデータベースファイルのロックを解除します。ロッキングモードがEXCLUSIVEに設定されている場合、データベース接続はファイルロックを解放しません。データベースが初めてEXCLUSIVEモードで読み取られるときに、共有ロックが取得されて保持されます。データベースが初めて書き込まれるときに、排他ロックが取得されて保持されます。</target>
        </trans-unit>
        <trans-unit id="f8c693ba3fad2e1d7df97dd42327c19b66a284bb" translate="yes" xml:space="preserve">
          <source>In SQLite</source>
          <target state="translated">SQLiteでは</target>
        </trans-unit>
        <trans-unit id="e298a84cbd8720f440fc21a95dd67ebcefa40857" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06) and later, the colUsed field is available to indicate which fields of the virtual table are actually used by the statement being prepared. If the lowest bit of colUsed is set, that means that the first column is used. The second lowest bit corresponds to the second column. And so forth. If the most significant bit of colUsed is set, that means that one or more columns other than the first 63 columns are used. If column usage information is needed by the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method, then the required bits must be encoded into either the idxNum or idxStr output fields.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;バージョン3.10.0&lt;/a&gt;（2016-01-06）以降では、準備中のステートメントが実際に仮想テーブルのどのフィールドを使用しているかを示すために、colUsedフィールドを使用できます。 colUsedの最下位ビットが設定されている場合、それは最初の列が使用されることを意味します。 2番目に低いビットは2番目の列に対応します。などなど。 colUsedの最上位ビットが設定されている場合は、最初の63列以外の1つ以上の列が使用されていることを意味します。&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドで列の使用情報が必要な場合、必要なビットをidxNumまたはidxStr出力フィールドにエンコードする必要があります。</target>
        </trans-unit>
        <trans-unit id="828bdde156beec9d0455bf5a047ac9dedf77b343" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;version 3.28.0&lt;/a&gt; (2019-04-16), windows function support was extended to include the EXCLUDE clause, GROUPS frame types, window chaining, and support for &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; and &quot;&amp;lt;expr&amp;gt; FOLLOWING&quot; boundaries in RANGE frames.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;バージョン3.28.0&lt;/a&gt;（2019-04-16）では、Windows関数のサポートが拡張され、EXCLUDE句、GROUPSフレームタイプ、ウィンドウチェーン、および &quot;&amp;lt;expr&amp;gt; PRECEDING&quot;および &quot;&amp;lt;expr&amp;gt; FOLLOWING&quot;境界のサポートが含まれています。 RANGEフレーム。</target>
        </trans-unit>
        <trans-unit id="7a9dbb486e8961eb98612eeeff0292e2cdc9f06c" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26) and earlier, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; used to always return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it was invoked again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; without an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. This caused problems on some poorly written smartphone applications which did not correctly handle the &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; and &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error returns. Rather than fix the many defective smartphone applications, the behavior of SQLite was changed in 3.6.23.2 to automatically reset the prepared statement. But that changed caused issues in other improperly implemented applications that were actually looking for an &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return to terminate their query loops. (Anytime an application gets an SQLITE_MISUSE error code from SQLite, that means the application is misusing the SQLite interface and is thus incorrectly implemented.) The SQLITE_OMIT_AUTORESET interface was added to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;version 3.7.5&lt;/a&gt; (2011-02-01) in an effort to get all of the (broken) applications to work again without having to actually fix the applications.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;バージョン3.6.23.1&lt;/a&gt;（2010-03-26）以前では、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_reset（）&lt;/a&gt;への呼び出しを&lt;a href=&quot;c3ref/reset&quot;&gt;介さ&lt;/a&gt;ずに&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;以外を返した後に再度呼び出された場合、sqlite3_step（）は常に&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;を返していました。これにより、&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;および&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;エラーが正しく返されなかった、不適切に作成されたスマートフォンアプリケーションで問題が発生しました。多くの欠陥のあるスマートフォンアプリケーションを修正するのではなく、SQLiteの動作が3.6.23.2で変更され、準備されたステートメントが自動的にリセットされました。しかし、この変更により、&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;実際に探していた他の不適切に実装されたアプリケーションで問題が発生しました。戻り、クエリループを終了します。（アプリケーションがSQLiteからSQLITE_MISUSEエラーコードを受け取ったときは常に、アプリケーションがSQLiteインターフェースを誤用しているため、正しく実装されていません。）SQLITE_OMIT_AUTORESETインターフェースは、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;バージョン&lt;/a&gt; 3.7.5 （2011-02-01）に追加されました。実際にアプリケーションを修正する必要なく、すべての（壊れた）アプリケーションを再び機能させる。</target>
        </trans-unit>
        <trans-unit id="ae75dbb8c6b830d21fb52ab24e85cf97f8c0d055" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26) and later, an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; message is sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; every time a statement is prepared that uses an automatic index. Application developers can and should use these warnings to identify the need for new persistent indices in the schema.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;バージョン3.8.0&lt;/a&gt;（2013-08-26）以降では、自動インデックスを使用するステートメントが準備されるたびに、&lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt;メッセージが&lt;a href=&quot;errlog&quot;&gt;エラーログに&lt;/a&gt;送信されます。アプリケーション開発者は、これらの警告を使用して、スキーマ内の新しい永続インデックスの必要性を特定できます。</target>
        </trans-unit>
        <trans-unit id="311b836bebf13bf229bfb5d427d7d61edb397191" translate="yes" xml:space="preserve">
          <source>In SQLite Version 3</source>
          <target state="translated">SQLiteバージョン3では</target>
        </trans-unit>
        <trans-unit id="44b0d77bd3716352e42cf5f2569dabd7987b859f" translate="yes" xml:space="preserve">
          <source>In SQLite version 2</source>
          <target state="translated">SQLiteバージョン2では</target>
        </trans-unit>
        <trans-unit id="ab1b358df4951321dec42436274a7fc7055620c8" translate="yes" xml:space="preserve">
          <source>In SQLite version 2, if many processes are reading from the database, it might be the case that there is never a time when there are no active readers. And if there is always at least one read lock on the database, no process would ever be able to make changes to the database because it would be impossible to acquire a write lock. This situation is called &lt;em&gt;writer starvation&lt;/em&gt;.</source>
          <target state="translated">SQLiteバージョン2では、多くのプロセスがデータベースから読み取っている場合、アクティブなリーダーが存在しない時間がない場合があります。また、データベースに常に少なくとも1つの読み取りロックがある場合、書き込みロックを取得することが不可能であるため、データベースに変更を加えることができるプロセスはありません。この状況は、&lt;em&gt;ライターの飢餓&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="0e7545ebfe6eb34f26f31fe8304f6f550663c8e8" translate="yes" xml:space="preserve">
          <source>In SQLite version 3, the sqlite3_exec routine is just a wrapper around calls to the prepared statement interface.</source>
          <target state="translated">SQLiteバージョン3では、sqlite3_execルーチンはprepared statementインターフェースの呼び出しのラッパーに過ぎません。</target>
        </trans-unit>
        <trans-unit id="e7a56207acc60b29c6f42211f54c5ca8f6e54fa3" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.0, the rowid is a 64-bit signed integer. This is an expansion of SQLite version 2.8 which only permitted rowids of 32-bits.</source>
          <target state="translated">SQLite バージョン 3.0 では、rowid は 64 ビットの符号付き整数です。これは SQLite バージョン 2.8 を拡張したもので、32 ビットの行 ID のみを許可していました。</target>
        </trans-unit>
        <trans-unit id="eade6a0b14d85e68f1dde5969cd3e571c5e3e4f6" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted. That capability is no longer provided. Only built-in memory allocators can be used.</source>
          <target state="translated">SQLite バージョン 3.5.0 および 3.5.1 では、これらのルーチンの組み込み実装を省略する SQLITE_OMIT_MEMORY_ALLOCATION を定義することが可能でした。その機能はもはや提供されていません。組み込みのメモリアロケータのみが使用できます。</target>
        </trans-unit>
        <trans-unit id="7278a0046b6c686e7491a606645054d45ac6a9da" translate="yes" xml:space="preserve">
          <source>In SQLite versions 3.3.0 through 3.4.2 when shared-cache mode is enabled, a database connection may only be used by the thread that called &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; to create it. And a connection could only share cache with another connection in the same thread. These restrictions were dropped beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04).</source>
          <target state="translated">SQLiteバージョン3.3.0〜3.4.2では、共有キャッシュモードが有効になっている場合、データベース接続は、それを作成するために&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;を呼び出したスレッドでのみ使用できます。また、接続は、同じスレッド内の別の接続とのみキャッシュを共有できました。これらの制限は、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;バージョン3.5.0&lt;/a&gt;（2007-09-04）から削除されました。</target>
        </trans-unit>
        <trans-unit id="4af0e6be92f4dba4280a2c7e3664bbca74929393" translate="yes" xml:space="preserve">
          <source>In SQLite, a column with type INTEGER PRIMARY KEY is an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; (except in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) which is always a 64-bit signed integer.</source>
          <target state="translated">SQLiteでは、タイプINTEGER PRIMARY KEYの列は&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;（&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルを除く）のエイリアスであり、常に64ビットの符号付き整数です。</target>
        </trans-unit>
        <trans-unit id="d48f1e4d1dbe48d61b2a0bc14d1d629523402032" translate="yes" xml:space="preserve">
          <source>In SQLite, a database object (a table, index, trigger or view) is identified by the name of the object and the name of the database that it resides in. Database objects may reside in the main database, the temp database, or in an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;.</source>
          <target state="translated">SQLiteでは、データベースオブジェクト（テーブル、インデックス、トリガー、またはビュー）は、オブジェクトの名前と、それが常駐するデータベースの名前で識別されます。データベースオブジェクトは、メインデータベース、一時データベース、または&lt;a href=&quot;lang_attach&quot;&gt;アタッチされたデータベース&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d037fc285a8e821543df8fc13d9f7837388fd3a" translate="yes" xml:space="preserve">
          <source>In SQLite, table rows normally have a 64-bit signed integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; which is unique among all rows in the same table. (&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are the exception.)</source>
          <target state="translated">SQLiteでは、通常、テーブルの行には64ビットの符号付き整数&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDが&lt;/a&gt;あり、同じテーブルのすべての行の中で一意です。（&lt;a href=&quot;withoutrowid&quot;&gt;ROWID&lt;/a&gt;テーブルなしは例外です。）</target>
        </trans-unit>
        <trans-unit id="fe38d7c32db7d9028a7337d49fe5d30adb864ee5" translate="yes" xml:space="preserve">
          <source>In SQLite, the answer to the previous question is &quot;no&quot;. For testing purposes, the SQLite source code defines macros called ALWAYS() and NEVER(). The ALWAYS() macro surrounds conditions which are expected to always evaluate as true and NEVER() surrounds conditions that are always evaluated to false. These macros serve as comments to indicate that the conditions are defensive code. In release builds, these macros are pass-throughs:</source>
          <target state="translated">SQLite では、先ほどの質問の答えは「いいえ」です。テストのために、SQLite のソースコードでは ALWAYS()および NEVER()と呼ばれるマクロが定義されています。ALWAYS()マクロは、常に真として評価されると予想される条件を囲み、NEVER()は常に偽として評価される条件を囲みます。これらのマクロは、条件が防御コードであることを示すコメントとして機能します。リリースビルドでは、これらのマクロはパススルーです。</target>
        </trans-unit>
        <trans-unit id="f43676df6968c4bb63677e4842db7886283fb3e7" translate="yes" xml:space="preserve">
          <source>In SQLite, the presence of assert(X) means that the developers have a proof that X is always true. Readers can depend upon X being true to help them reason about the code. An assert(X) is a strong statement about the truth of X. There is no doubt.</source>
          <target state="translated">SQLite では、assert(X)が存在するということは、開発者が X が常に真であるという証明を持っていることを意味します。読者はXが真であることを信頼して、コードについての推論を行うことができます。assert(X)は X の真実についての強力なステートメントです。</target>
        </trans-unit>
        <trans-unit id="afc867db69a6f0ff03a7d5c74a860a19b5e1f763" translate="yes" xml:space="preserve">
          <source>In WAL mode, changes to the database are detected using the wal-index and so the change counter is not needed. Hence, the change counter might not be incremented on each transaction in WAL mode.</source>
          <target state="translated">WALモードでは、データベースへの変更はwal-indexを使用して検出されるため、変更カウンタは必要ありません。したがって、WALモードでは、変更カウンタはトランザクションごとにインクリメントされないかもしれません。</target>
        </trans-unit>
        <trans-unit id="56b4d5a656b5f1cb948b72fc909adc62f6fce99b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, all ORDER BY expressions are handled as aliases for one of the result columns of the compound. If an ORDER BY expression is not an integer alias, then SQLite searches the left-most SELECT in the compound for a result column that matches either the second or third rules above. If a match is found, the search stops and the expression is handled as an alias for the result column that it has been matched against. Otherwise, the next SELECT to the right is tried, and so on. If no matching expression can be found in the result columns of any constituent SELECT, it is an error. Each term of the ORDER BY clause is processed separately and may be matched against result columns from different SELECT statements in the compound.</source>
          <target state="translated">で&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECT&lt;/a&gt;文で、表現BYすべてORDERは、化合物の結果列の一つの別名として扱われます。 ORDER BY式が整数エイリアスでない場合、SQLiteはコンパウンドの左端のSELECTを検索して、上記の2番目または3番目のルールに一致する結果列を探します。一致が見つかった場合、検索は停止し、式は一致した結果列のエイリアスとして処理されます。そうでない場合は、右側の次のSELECTが試行されます。構成するSELECTの結果列に一致する式が見つからない場合は、エラーです。 ORDER BY句の各用語は個別に処理され、コンパウンド内の異なるSELECTステートメントからの結果列と照合されます。</target>
        </trans-unit>
        <trans-unit id="7e23feed60f0ebed492861c5dd540e487916faa3" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may have an ORDER BY clause. That ORDER BY clause will apply across all elements of the compound. If the right-most element of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause, then no ORDER BY clause is allowed on that statement.</source>
          <target state="translated">で&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECT&lt;/a&gt;文で、最後または一番右&lt;a href=&quot;lang_select#simpleselect&quot;&gt;の単純なSELECTは、&lt;/a&gt; ORDER BY句を持つことができます。そのORDER BY句は、複合のすべての要素に適用されます。一番右の要素ならば&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECTが&lt;/a&gt;ある&lt;a href=&quot;lang_select#values&quot;&gt;VALUESの&lt;/a&gt;句は、ORDER BY句なしORDERはその文では許可されません。</target>
        </trans-unit>
        <trans-unit id="60dd93ddbe8f5275cb023ced823e2e72128039a2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may contain a LIMIT clause. In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, the LIMIT clause applies to the entire compound, not just the final SELECT. If the right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; then no LIMIT clause is allowed.</source>
          <target state="translated">で&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECT&lt;/a&gt;、最後または一番右&lt;a href=&quot;lang_select#simpleselect&quot;&gt;の単純なSELECTは、&lt;/a&gt; LIMIT句が含まれていてもよいです。で&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECT&lt;/a&gt;、LIMIT句は全体の化合物だけではなく、最後のSELECTに適用されます。右端の&lt;a href=&quot;lang_select#simpleselect&quot;&gt;単純なSELECT&lt;/a&gt;が&lt;a href=&quot;lang_select#values&quot;&gt;VALUES句の&lt;/a&gt;場合、LIMIT句は許可されません。</target>
        </trans-unit>
        <trans-unit id="4a8149bd98030a655ea899de201ec17546792e89" translate="yes" xml:space="preserve">
          <source>In a CASE with a base expression, the base expression is evaluated just once and the result is compared against the evaluation of each WHEN expression from left to right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression for which the comparison is true. Or, if none of the WHEN expressions evaluate to a value equal to the base expression, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions produce a result equal to the base expression, the overall result is NULL.</source>
          <target state="translated">ベース式を持つCASEでは、ベース式は一度だけ評価され、その結果は左から右に向かって各WHEN式の評価と比較されます。CASE式の結果は、比較が真である最初のWHEN式に対応するTHEN式の評価となります。あるいは、WHEN式のどれも基底式に等しい値に評価されない場合、ELSE式がある場合は、ELSE式を評価した結果である。ELSE式が存在せず、WHEN式のどれも基底式と等しい結果を生成しない場合、全体の結果はNULLとなります。</target>
        </trans-unit>
        <trans-unit id="9908cac3e7af8453ade042a08abc46157b47dbc8" translate="yes" xml:space="preserve">
          <source>In a CASE without a base expression, each WHEN expression is evaluated and the result treated as a boolean, starting with the leftmost and continuing to the right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression that evaluates to true. Or, if none of the WHEN expressions evaluate to true, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions are true, then the overall result is NULL.</source>
          <target state="translated">ベース式のないCASEでは、各WHEN式が評価され、その結果は、左端から始まり右に続くブーリアンとして扱われます。CASE式の結果は、真と評価される最初のWHEN式に対応するTHEN式の評価となります。または、WHEN式のどれもが真に評価されない場合、ELSE式があれば、その評価結果。ELSE式が存在せず、WHEN式のどれも真でない場合、全体の結果はNULLとなります。</target>
        </trans-unit>
        <trans-unit id="6181d4389ce1218d0117e383d6876208b5204220" translate="yes" xml:space="preserve">
          <source>In a compound SELECT, all the constituent SELECTs must return the same number of result columns. As the components of a compound SELECT must be simple SELECT statements, they may not contain &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses. &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses may only occur at the end of the entire compound SELECT, and then only if the final element of the compound is not a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause.</source>
          <target state="translated">複合SELECTでは、すべての構成SELECTが同じ数の結果列を返す必要があります。複合SELECTのコンポーネントは単純なSELECTステートメントである必要があるため、&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;句や&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;句を含めることはできません。&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;句と&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;句は、複合SELECT全体の最後にのみ出現し、複合の最後の要素が&lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt;句でない場合にのみ出現します。</target>
        </trans-unit>
        <trans-unit id="78d71ac8fe601725ccb2ce14d7f5ff1b4e551c1c" translate="yes" xml:space="preserve">
          <source>In a custom format defined by the RBU application.</source>
          <target state="translated">RBUアプリケーションによって定義されたカスタムフォーマットで。</target>
        </trans-unit>
        <trans-unit id="c01843d896cd964dc56835ee2c755615d047e3ab" translate="yes" xml:space="preserve">
          <source>In a database that uses ptrmap pages, all pages at locations identified by the computation in the previous paragraph must be ptrmap page and no other page may be a ptrmap page. Except, if the byte-lock page happens to fall on the same page number as a ptrmap page, then the ptrmap is moved to the following page for that one case.</source>
          <target state="translated">ptrmapページを使用するデータベースでは、前項の計算で特定された位置にあるすべてのページがptrmapページでなければならず、それ以外のページがptrmapページになってはならない。ただし、バイトロックページがたまたまptrmapページと同じページ番号に該当する場合は、その1つの場合を除いて、ptrmapは次のページに移動されます。</target>
        </trans-unit>
        <trans-unit id="27e8a07a53d50d810a0832f44496263b4918565d" translate="yes" xml:space="preserve">
          <source>In a database with ptrmap pages, the first ptrmap page is page 2. A ptrmap page consists of an array of 5-byte entries. Let J be the number of 5-byte entries that will fit in the usable space of a page. (In other words, J=U/5.) The first ptrmap page will contain back pointer information for pages 3 through J+2, inclusive. The second pointer map page will be on page J+3 and that ptrmap page will provide back pointer information for pages J+4 through 2*J+3 inclusive. And so forth for the entire database file.</source>
          <target state="translated">ptrmapページを持つデータベースでは、最初のptrmapページは2ページ目である。ptrmapページは5バイトのエントリの配列で構成される。1ページの使用可能なスペースに収まる5バイトエントリの数をJとする(言い換えれば、J=U/5)。(言い換えれば、J=U/5)最初のptrmapページには、3ページ目からJ+2ページ目までのバックポインタ情報が格納される。2番目のポインタマップページはJ+3ページにあり、そのptrmapページはJ+4から2*J+3までのページのバックポインタ情報を提供します。といった具合に、データベースファイル全体の情報を提供します。</target>
        </trans-unit>
        <trans-unit id="413d5f86aecfe4e03a70ec087a2506b07314a985" translate="yes" xml:space="preserve">
          <source>In a general query, dependencies need not be on a single loop, and hence the matrix of dependencies might not be representable as a graph. For example, one of the WHERE clause constraints might be S.a=L.b+P.c, implying that the S loop must be an inner loop of both L and P. Such dependencies cannot be drawn as a graph since there is no way for an arc to originate at two or more nodes at once.</source>
          <target state="translated">一般的な問い合わせでは、依存関係は単一のループ上にある必要はなく、依存関係の行列はグラフとして表現できない場合があります。例えば、WHERE句制約の1つは、S.a=L.b+P.cとなり、SループがLとPの両方の内側ループでなければならないことを暗示しています。</target>
        </trans-unit>
        <trans-unit id="3cba367e5a45e9ef327972801946d29ebc579596" translate="yes" xml:space="preserve">
          <source>In a join, two or more tables are combined to generate a single result. The result table consists of every possible combination of rows from the tables being joined. The easiest and most natural way to implement this is with nested loops.</source>
          <target state="translated">結合では、2つ以上のテーブルを結合して1つの結果を生成します。結果テーブルは、結合されるテーブルの行のすべての可能な組み合わせで構成されます。これを実装する最も簡単で自然な方法は、入れ子になったループです。</target>
        </trans-unit>
        <trans-unit id="ea43a43981be0da7d2383a4a8fa8f578ad332998" translate="yes" xml:space="preserve">
          <source>In a more complete build, SQLite also uses library routines like malloc() and free() and operating system interfaces for opening, reading, writing, and closing files. But even then, the number of dependencies is very small. Other &quot;modern&quot; language, in contrast, often require multi-megabyte runtimes loaded with thousands and thousands of interfaces.</source>
          <target state="translated">より完全なビルドでは、SQLite は malloc()や free()のようなライブラリルーチンや、ファイルを開いたり、読んだり、書いたり、閉じたりするためのオペレーティングシステムのインターフェイスも使用しています。しかし、それでも依存関係の数は非常に少ないのです。対照的に、他の「現代的な」言語では、多くの場合、何千、何千ものインターフェイスを搭載したマルチメガバイトのランタイムを必要とします。</target>
        </trans-unit>
        <trans-unit id="84d7fa8dbd084f79299c977c5d7f182884242ce4" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, access to the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; is serialized if and only if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is enabled. If &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled then the methods in &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; must take care of their own serialization needs.</source>
          <target state="translated">マルチスレッドアプリケーションでは、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;が有効な場合にのみ、&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;へのアクセスがシリアル化されます。場合&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUSが&lt;/a&gt;無効になっている、その後のメソッド&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methodsは&lt;/a&gt;自分のシリアル化のニーズの世話をする必要があります。</target>
        </trans-unit>
        <trans-unit id="f07ff4f6d979804b51470d547e3016d910de27f0" translate="yes" xml:space="preserve">
          <source>In a multithreaded environment, SQLite uses mutexes to serialize access to shared resources. The mutex subsystem is only required for applications that access SQLite from multiple threads. For single-threaded applications, or applications which only call SQLite from a single thread, the mutex subsystem can be completely disabled by recompiling with the following option:</source>
          <target state="translated">マルチスレッド環境では、SQLite はミューテックスを使用して共有リソースへのアクセスをシリアライズします。ミューテックスサブシステムが必要なのは、複数のスレッドからSQLiteにアクセスするアプリケーションのみです。シングルスレッドのアプリケーションや、単一のスレッドからのみSQLiteを呼び出すアプリケーションでは、以下のオプションを使用して再コンパイルすることで、ミューテックスサブシステムを完全に無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="4d4533ee698cc81c52715976a896f4db12f7a8cf" translate="yes" xml:space="preserve">
          <source>In a normal index, there is a one-to-one mapping between rows in a table and entries in each index associated with that table. However, in a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, the index b-tree only contains entries corresponding to table rows for which the WHERE clause expression on the CREATE INDEX statement is true. Corresponding rows in the index and table b-trees share the same rowid or primary key values and contain the same value for all indexed columns.</source>
          <target state="translated">通常のインデックスでは、テーブルの行とそのテーブルに関連付けられた各インデックスのエントリとの間に1対1のマッピングがあります。ただし、&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;では、インデックスBツリーには、CREATE INDEXステートメントのWHERE句の式が真であるテーブル行に対応するエントリのみが含まれます。インデックスとテーブルのBツリーの対応する行は、同じROWIDまたは主キーの値を共有し、すべてのインデックス付き列に同じ値を含みます。</target>
        </trans-unit>
        <trans-unit id="ce9e9da4042a8b1a6fff277efdbca241b2bb44b8" translate="yes" xml:space="preserve">
          <source>In a prefix search, the matchlen is the number of characters in the string that match against the prefix. For a non-prefix search, this is the same as length(word).</source>
          <target state="translated">プレフィックス検索の場合、matchlen は、プレフィックスにマッチする文字列の文字数です。プレフィックス以外の検索では、これは length(word)と同じです。</target>
        </trans-unit>
        <trans-unit id="540eb7e11b15dfedf16222538153a627d93ae118" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat3 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if the entry with left-most column S1 is earlier in the index b-tree than the entry with left-most column S2, then in the sqlite_stat3 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">整形されたsqlite_stat3テーブルでは、単一のインデックスのサンプルはインデックスの中で発生するのと同じ順番で現れなければなりません。言い換えれば、左端の列S1を持つエントリが左端の列S2を持つエントリよりもインデックスb-treeの中で早い場合、sqlite_stat3テーブルでは、サンプルS1はサンプルS2よりも小さいrowidを持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="471a1674cd89ff60cc26aaa2e09dcb5715c114d4" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat4 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if entry S1 is earlier in the index b-tree than entry S2, then in the sqlite_stat4 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">整形されたsqlite_stat4テーブルでは、単一のインデックスのサンプルはインデックスの中に現れるのと同じ順番で現れなければなりません。言い換えれば、エントリS1がエントリS2よりもインデックスb-treeの中で早い場合、sqlite_stat4テーブルでは、サンプルS1はサンプルS2よりも小さい行IDを持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="211f3f65b2d350ffdf823361c3c94beeb6b3685e" translate="yes" xml:space="preserve">
          <source>In addition to &quot;supporting&quot; SQLite through the year 2050, the developers also promise to keep the SQLite &lt;a href=&quot;cintro&quot;&gt;C-language API&lt;/a&gt; and &lt;a href=&quot;fileformat2&quot;&gt;on-disk format&lt;/a&gt; fully backwards compatible. This means that application written to use SQLite today should be able to link against and use future versions of SQLite released decades in the future.</source>
          <target state="translated">2050年までのSQLiteの「サポート」に加えて、開発者はSQLite &lt;a href=&quot;cintro&quot;&gt;C言語API&lt;/a&gt;と&lt;a href=&quot;fileformat2&quot;&gt;ディスク上のフォーマットを&lt;/a&gt;完全に下位互換性を保つことも約束します。つまり、今日SQLiteを使用するように作成されたアプリケーションは、何十年も後にリリースされるSQLiteの将来のバージョンにリンクして使用できるはずです。</target>
        </trans-unit>
        <trans-unit id="2d62e10830dbc04e04eb1ce98ea4d36c1849dd6d" translate="yes" xml:space="preserve">
          <source>In addition to WHERE clause constraints, the SQLite core also tells the xBestIndex method about the ORDER BY clause. (In an aggregate query, the SQLite core might put in GROUP BY clause information in place of the ORDER BY clause information, but this fact should not make any difference to the xBestIndex method.) If all terms of the ORDER BY clause are columns in the virtual table, then nOrderBy will be the number of terms in the ORDER BY clause and the aOrderBy[] array will identify the column for each term in the order by clause and whether or not that column is ASC or DESC.</source>
          <target state="translated">WHERE 句の制約に加えて、SQLite コアは ORDER BY 句についても xBestIndex メソッドに伝えます。(集計クエリでは、SQLite コアは ORDER BY 句の情報の代わりに GROUP BY 句の情報を入れるかもしれませんが、この事実は xBestIndex メソッドには何の影響もありません)。ORDER BY 句のすべての項が仮想テーブルのカラムである場合、nOrderBy は ORDER BY 句の項数となり、aOrderBy[]配列は ORDER BY 句の各項のカラムと、そのカラムが ASC か DESC かを識別します。</target>
        </trans-unit>
        <trans-unit id="ae32760f149e6ccbf9d662c3e5f266d79f8381ea" translate="yes" xml:space="preserve">
          <source>In addition to being a result code, the SQLITE_ABORT value is also used as a &lt;a href=&quot;c3ref/c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_ABORT値は、結果コードであるだけでなく、&lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;インターフェースから返される&lt;a href=&quot;c3ref/c_fail&quot;&gt;競合解決モード&lt;/a&gt;としても使用されます。</target>
        </trans-unit>
        <trans-unit id="7bf173fd8743d9addd4d23da77cbd1023dcac612" translate="yes" xml:space="preserve">
          <source>In addition to locking this byte, a connection running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; also gets an exclusive lock on all other WAL locks except for WAL_READ_LOCK(0).</source>
          <target state="translated">このバイトをロックすることに加えて、&lt;a href=&quot;walformat#recovery&quot;&gt;リカバリ&lt;/a&gt;を実行している接続は、WAL_READ_LOCK（0）を除く他のすべてのWALロックに対しても排他ロックを取得します。</target>
        </trans-unit>
        <trans-unit id="cb3414acfc85a9001c1b555d3204dd8c38c36eeb" translate="yes" xml:space="preserve">
          <source>In addition to making SQLite easier to incorporate into other projects, the amalgamation also makes it run faster. Many compilers are able to do additional optimizations on code when it is contained with in a single translation unit such as it is in the amalgamation. We have measured performance improvements of between 5 and 10% when we use the amalgamation to compile SQLite rather than individual source files. The downside of this is that the additional optimizations often take the form of function inlining which tends to make the size of the resulting binary image larger.</source>
          <target state="translated">アマルガムは SQLite を他のプロジェクトに組み込むのを容易にするだけでなく、実行速度も向上させます。多くのコンパイラは、アマルガムのような単一の翻訳ユニットにコードが含まれている場合、コードに対して追加の最適化を行うことができます。個々のソースファイルではなく、SQLiteをコンパイルするためにアマルガムを使用した場合、5~10%のパフォーマンス向上が確認されています。これの欠点は、追加の最適化が関数のインライン化という形で行われることが多く、結果として得られるバイナリイメージのサイズを大きくする傾向があることです。</target>
        </trans-unit>
        <trans-unit id="dc82fe62c10524b3d4ccdfbeed7cfd03442b0fdf" translate="yes" xml:space="preserve">
          <source>In addition to providing built-in &quot;simple&quot;, &quot;porter&quot; and (possibly) &quot;icu&quot; and &quot;unicode61&quot; tokenizers, FTS provides an interface for applications to implement and register custom tokenizers written in C. The interface used to create a new tokenizer is defined and described in the fts3_tokenizer.h source file.</source>
          <target state="translated">組み込みの &quot;simple&quot;、&quot;porter&quot;、(おそらく)&quot;icu&quot;、&quot;unicode61 &quot;トークナイザーを提供することに加えて、FTSはアプリケーションがC言語で書かれたカスタムトークナイザーを実装し、登録するためのインターフェイスを提供しています。</target>
        </trans-unit>
        <trans-unit id="7ffa68d498101dd69c9fe08bfcd580625d879a08" translate="yes" xml:space="preserve">
          <source>In addition to the incompatible changes listed above, SQLite version 3.6.0 adds the following backwards compatible changes and enhancements:</source>
          <target state="translated">上記の互換性のない変更点に加え、SQLite バージョン 3.6.0 では、以下のような下位互換性のある変更点と機能強化が追加されています。</target>
        </trans-unit>
        <trans-unit id="8f29eabb94163c908fdf9ce75645a4e743012d26" translate="yes" xml:space="preserve">
          <source>In addition to the official repositories, the developers typically keep complete clones of all software on their personal machines. And there are uncountable clones scattered about the internet.</source>
          <target state="translated">公式リポジトリに加えて、開発者は通常、すべてのソフトウェアの完全なクローンを個人のマシンに保存しています。そして、インターネット上には数え切れないほどのクローンが散らばっています。</target>
        </trans-unit>
        <trans-unit id="7d07efab2f131a863a93f94a25375b6ef4bc7a4a" translate="yes" xml:space="preserve">
          <source>In addition to the primary vdbe.c source code file, there are other helper code files in the source tree, all of whose names begin with &quot;vdbe&quot; - short for &quot;Virtual DataBase Engine&quot;.</source>
          <target state="translated">ソースツリーには、プライマリの vdbe.c ソースコードファイルに加えて、他にもヘルパーコードファイルがあり、その名前はすべて &quot;vdbe&quot; で始まります。</target>
        </trans-unit>
        <trans-unit id="77b9657ef03e307e851c2e7bae3bdd3ad8613131" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_master table may contain zero or more entries for</source>
          <target state="translated">アプリケーションおよび/または開発者がCREATE文SQLを使って作成したテーブル、インデックス、ビュー、トリガに加えて、sqlite_masterテーブルは0個以上の</target>
        </trans-unit>
        <trans-unit id="a409c2d7a3384bc3f57eb2c0537e46f7868645bd" translate="yes" xml:space="preserve">
          <source>In addition to the three major test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="translated">3つの主要なテストハーネスに加えて、特殊なテストを実装する他のいくつかの小さなプログラムがあります。</target>
        </trans-unit>
        <trans-unit id="0718e6fdf0cd1e299f6d920f46595f0908dd4b09" translate="yes" xml:space="preserve">
          <source>In addition, there are some defined constants:</source>
          <target state="translated">さらに、いくつかの定義された定数があります。</target>
        </trans-unit>
        <trans-unit id="650bcf7f3c9667b8bca2e9d81188fd4ca62bdf99" translate="yes" xml:space="preserve">
          <source>In all of the full-text queries above, the right-hand operand of the MATCH operator is a string consisting of a single term. In this case, the MATCH expression evaluates to true for all documents that contain one or more instances of the specified word (&quot;sqlite&quot;, &quot;search&quot; or &quot;database&quot;, depending on which example you look at). Specifying a single term as the right-hand operand of the MATCH operator results in the simplest and most common type of full-text query possible. However more complicated queries are possible, including phrase searches, term-prefix searches and searches for documents containing combinations of terms occurring within a defined proximity of each other. The various ways in which the full-text index may be queried are &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">上記のすべての全文クエリでは、MATCH演算子の右側のオペランドは、単一の用語で構成される文字列です。この場合、MATCH式は、指定した単語（「sqlite」、「search」、または「database」のどちらの例を見るかに応じて）の1つ以上のインスタンスを含むすべてのドキュメントに対してtrueと評価されます。 MATCH演算子の右側のオペランドとして単一の用語を指定すると、可能な最も単純で最も一般的なタイプのフルテキストクエリになります。ただし、フレーズ検索、用語接頭辞検索、相互に定義された近接範囲内に出現する用語の組み合わせを含むドキュメントの検索など、より複雑なクエリが可能です。フルテキストインデックスを照会するさまざまな方法を&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;以下に説明します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fec3ea71809f1fd12bdd320ecfb2400479f6f909" translate="yes" xml:space="preserve">
          <source>In all of the write tests, it is important to disable anti-virus software prior to running the direct-to-disk performance tests. We found that anti-virus software slows down direct-to-disk by an order of magnitude whereas it impacts SQLite writes very little. This is probably due to the fact that direct-to-disk changes thousands of separate files which all need to be checked by anti-virus, whereas SQLite writes only changes the single database file.</source>
          <target state="translated">すべての書き込みテストでは、直接ディスクへのパフォーマンステストを実行する前に、アンチウイルスソフトウェアを無効にすることが重要です。ウィルス対策ソフトウェアは、SQLite の書き込みにはほとんど影響を与えないのに対し、Direct-to-disk の速度を桁違いに遅くすることがわかりました。これは、SQLite の書き込みが単一のデータベースファイルを変更するだけであるのに対し、Direct-to-disk が何千もの個別ファイルを変更するという事実に起因していると考えられます。</target>
        </trans-unit>
        <trans-unit id="19fd1c2e26ad6ba4190cb1ba85655e3d415fb1a9" translate="yes" xml:space="preserve">
          <source>In all other cases this function returns SQLITE_MISUSE.</source>
          <target state="translated">それ以外の場合、この関数は SQLITE_MISUSE を返します。</target>
        </trans-unit>
        <trans-unit id="a9b1d686d80c16cbd892850ec817e33e118fdb64" translate="yes" xml:space="preserve">
          <source>In all the examples above, there has only been a single SELECT statement. If a query contains sub-selects, those are shown as being children of the outer SELECT. For example:</source>
          <target state="translated">上記のすべての例では、SELECT文は1つしかありません。クエリにサブセレクトが含まれている場合、それらは外側のSELECTの子として表示されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c9c18ce865540a24f1f5ee5d4ef74324465c3e44" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement, a list of column names can be set to a row value of the same size.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;ステートメント、列名のリストは、同じサイズの行の値に設定することができます。</target>
        </trans-unit>
        <trans-unit id="34ecd17e630ff3ecf740af54bcb0cb9af6e271db" translate="yes" xml:space="preserve">
          <source>In an expression used as part of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;式インデックスの&lt;/a&gt;一部として使用される式内。</target>
        </trans-unit>
        <trans-unit id="68e31982331dd4f44aeeef7efedd25a5db6a0a14" translate="yes" xml:space="preserve">
          <source>In an index on a WITHOUT ROWID table, if a column of the PRIMARY KEY is also a column in the index and has a matching collating sequence, then the indexed column is not repeated in the table-key suffix on the end of the index record. As an example, consider the following SQL:</source>
          <target state="translated">WITHOUT ROWIDテーブル上のインデックスにおいて、PRIMARY KEYのカラムがインデックス内のカラムでもあり、照合順序が一致している場合、インデックスレコードの末尾のテーブルキー接尾辞では、インデックス化されたカラムは繰り返されません。例として、次のようなSQLを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="b98eca53cbed3b51f01e882fbf03443737203ad3" translate="yes" xml:space="preserve">
          <source>In an interior b-tree page, the pointers and keys logically alternate with a pointer on both ends. (The previous sentence is to be understood conceptually - the actual layout of the keys and pointers within the page is more complicated and will be described in the sequel.) All keys within the same page are unique and are logically organized in ascending order from left to right. (Again, this ordering is logical, not physical. The actual location of keys within the page is arbitrary.) For any key X, pointers to the left of a X refer to b-tree pages on which all keys are less than or equal to X. Pointers to the right of X refer to pages where all keys are greater than X.</source>
          <target state="translated">内部のb-treeページでは、ポインタとキーは論理的に両端にポインタを持って交互に配置されます。(前の文は概念的に理解されるべきものですが、ページ内のキーとポインタの実際のレイアウトはもっと複雑で、後述します)。同じページ内のすべてのキーは一意であり、左から右へと昇順に論理的に整理されています。(繰り返しになりますが、この順序は論理的なものであり、物理的なものではありません。ページ内のキーの実際の位置は任意です)。任意のキーXに対して、Xの左側のポインタは、すべてのキーがX以下かそれ以下のb-treeページを指します。</target>
        </trans-unit>
        <trans-unit id="39488c0191328e370ea86a4f1833476c2e9dc423" translate="yes" xml:space="preserve">
          <source>In an ordinary SQLite table, the PRIMARY KEY is really just a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; index. The key used to look up records on disk is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. The special &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; column type in ordinary SQLite tables causes the column to be an alias for the rowid, and so an INTEGER PRIMARY KEY is a true PRIMARY KEY. But any other kind of PRIMARY KEYs, including &quot;INT PRIMARY KEY&quot; are just unique indexes in an ordinary rowid table.</source>
          <target state="translated">通常のSQLiteテーブルでは、PRIMARY KEYは実際には単なる&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;一意の&lt;/a&gt;インデックスです。ディスク上のレコードを検索するために使用されるキーは、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。通常のSQLiteテーブルの特別な「&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;」列タイプでは、列がROWIDのエイリアスになるため、INTEGER PRIMARY KEYは真のPRIMARY KEYです。ただし、「INT PRIMARY KEY」を含む他の種類のPRIMARY KEYは、通常のROWIDテーブル内の一意のインデックスにすぎません。</target>
        </trans-unit>
        <trans-unit id="2602231eda03cd82b0bfe3849f20e2339713b36f" translate="yes" xml:space="preserve">
          <source>In any aggregate function that takes a single argument, that argument can be preceded by the keyword DISTINCT. In such cases, duplicate elements are filtered before being passed into the aggregate function. For example, the function &quot;count(distinct X)&quot; will return the number of distinct values of column X instead of the total number of non-null values in column X.</source>
          <target state="translated">1 つの引数を取る集約関数では、その引数の前にキーワード DISTINCT を付けることができます。このような場合、重複する要素は、集約関数に渡される前にフィルタリングされます。例えば、関数 &quot;count(distinct X)&quot;は、列Xの非ヌル値の合計数ではなく、列Xのdistinctな値の数を返します。</target>
        </trans-unit>
        <trans-unit id="15eb51d3758bed15da54f5c0830882a735d49cb2" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_master table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_master table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="translated">ptrmapページを含むデータベースファイルでは、すべてのb-treeルートページは、ルートではないb-treeページ、セルペイロードオーバーフローページ、フリーリストページの前に置かなければなりません。この制限により、自動バキュームやインクリメンタルバキュームの間にルートページが移動することはありません。自動バキュームロジックはsqlite_masterテーブルのroot_pageフィールドを更新する方法を知らないので、sqlite_masterテーブルの完全性を維持するために自動バキューム中にルートページが移動されないようにする必要があります。ルートページはCREATE TABLE、CREATE INDEX、DROP TABLE、DROP INDEX操作によってデータベースファイルの先頭に移動されます。</target>
        </trans-unit>
        <trans-unit id="016fc239bf2f87e674a823e588afff2d09643b5a" translate="yes" xml:space="preserve">
          <source>In automatic EXPLAIN QUERY PLAN mode, the shell automatically runs a separate EXPLAIN QUERY PLAN query for each statement you enter and displays the result before actually running the query. Use the &quot;.eqp off&quot; command to turn automatic EXPLAIN QUERY PLAN mode back off.</source>
          <target state="translated">EXPLAIN QUERY PLAN自動実行モードでは、シェルは、入力された文ごとに別個のEXPLAIN QUERY PLANクエリを自動的に実行し、クエリを実際に実行する前に結果を表示します。自動EXPLAIN QUERY PLANモードをオフにするには、&quot;.eqp off &quot;コマンドを使用してください。</target>
        </trans-unit>
        <trans-unit id="a0296b5facf2017142e185ec710adebd650dd374" translate="yes" xml:space="preserve">
          <source>In batch-mode operation, where an FTS table is initially built up using a large number of INSERT operations, then queried repeatedly without further changes, it is often a good idea to run &quot;optimize&quot; after the last INSERT and before the first query.</source>
          <target state="translated">バッチモードの操作では、FTSテーブルが最初に多数のINSERT操作を使用して構築され、その後、それ以上変更することなく繰り返しクエリを実行する場合、最後のINSERTの後、最初のクエリの前に &quot;optimize &quot;を実行するのが良いアイデアであることがよくあります。</target>
        </trans-unit>
        <trans-unit id="0f704787571a999cc9c3b84bb71144a5bcf64e37" translate="yes" xml:space="preserve">
          <source>In both cases, the split amalgamation can be obtained by substituting &quot;sqlite3-all.c&quot; for &quot;sqlite3.c&quot; as the make target.</source>
          <target state="translated">いずれの場合も、makeターゲットを &quot;sqlite3.c &quot;に &quot;sqlite3-all.c &quot;を代入することで、分割アマルガムが得られます。</target>
        </trans-unit>
        <trans-unit id="fc2950d0c83c287a896b8aadaea3a0c15a77bfa3" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">簡単に言うと、sqlite3_wal_checkpoint（D、X）は、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; DのデータベースXの&lt;a href=&quot;../wal&quot;&gt;先行書き込みログの&lt;/a&gt;内容をデータベースファイルに転送し、先行書き込みログをリセットします。追加情報については、&lt;a href=&quot;../wal#ckpt&quot;&gt;チェックポイントの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="05e7a053b7377f3e594b4b5661cacef3a8037473" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">簡単に言うと、sqlite3_wal_checkpoint（D、X）は、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; DのデータベースXの&lt;a href=&quot;wal&quot;&gt;先行書き込みログの&lt;/a&gt;内容をデータベースファイルに転送し、先行書き込みログをリセットします。追加情報については、&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイントの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="9c00ece9c1ea98470c62a3e9e8dcd9514aa371cf" translate="yes" xml:space="preserve">
          <source>In brief, the CPU performance of SQLite is measured as follows:</source>
          <target state="translated">簡単に言うと、SQLiteのCPU性能は以下のように測定されます。</target>
        </trans-unit>
        <trans-unit id="9e64879e9d401b77adebcff06d6d47d07d757ab4" translate="yes" xml:space="preserve">
          <source>In cases where it is complicated, the complications in applying a changeset lie in conflict resolution. Refer to the API documentation linked above for details.</source>
          <target state="translated">複雑な場合、チェンジセットを適用する際の複雑さは、競合の解決にあります。詳細については、上記のリンク先の API ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="0d808e9f43de5ebbcabce2337be4b9dd05f38065" translate="yes" xml:space="preserve">
          <source>In cases where two or more phrase instances overlap (share one or more tokens in common), a single open and close marker is inserted for each set of overlapping phrases. For example:</source>
          <target state="translated">2 つ以上のフレーズ インスタンスが重なっている (1 つ以上のトークンを共有している)場合は、重なっているフレーズのセットごとに 1 つの開閉マーカが挿入されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c541beea5651ea9308221a19ef6bad8134493156" translate="yes" xml:space="preserve">
          <source>In column mode, each record is shown on a separate line with the data aligned in columns. For example:</source>
          <target state="translated">カラムモードでは、各レコードは別々の行に表示され、データは列に整列して表示されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="27dcedbb38ae9d16b71fde759bf65bb67ce0f587" translate="yes" xml:space="preserve">
          <source>In common use, SQLite databases tend to range in size from a few kilobytes to a few gigabytes, though terabyte-size SQLite databases are known to exist in production.</source>
          <target state="translated">一般的に使用されているSQLiteデータベースのサイズは、数キロバイトから数ギガバイトまでの範囲になりますが、テラバイトサイズのSQLiteデータベースが本番環境に存在することが知られています。</target>
        </trans-unit>
        <trans-unit id="15ec9746d32bfb65e8d0e42717374e59fcc87690" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil is a single standalone binary which is installed by putting it on $PATH. That one binary contains all the functionality of core Git and also GitHub and/or GitLab. It manages a community server with wiki, bug tracking, and forums, provides packaged downloads for consumers, login managements, and so forth, with no extra software required.</source>
          <target state="translated">対照的に、Fossil はスタンドアロンのバイナリで、それを $PATH に置くことでインストールされます。この1つのバイナリにはコアGitのすべての機能が含まれており、GitHubやGitLabも含まれています。wiki、バグ追跡、フォーラムなどのコミュニティサーバーを管理し、消費者向けのパッケージダウンロード、ログイン管理などを提供し、余分なソフトウェアを必要としません。</target>
        </trans-unit>
        <trans-unit id="a51fb2bb312c4e04f9b038dff963c7e47c882987" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil users only need to think about their working directory and the check-in they are working on. That is 60% less distraction. Every developer has a finite number of brain-cycles. Fossil requires fewer brain-cycles to operate, thus freeing up intellectual resources to focus on the software under development.</source>
          <target state="translated">これに対して、Fossilのユーザーは、作業ディレクトリと作業中のチェックインのことだけを考えればいい。これは気が散ることを60%減らすことになります。すべての開発者は有限の脳サイクルを持っています。Fossilは操作に必要なブレインサイクルが少ないので、開発中のソフトウェアに集中するための知的リソースが解放されます。</target>
        </trans-unit>
        <trans-unit id="0fcdb16d38afda3fa9a7a2e8625220ffc33d6191" translate="yes" xml:space="preserve">
          <source>In either case, if performance problems do arise in an SQLite application those problems can often be resolved by adding one or two &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements to the schema or perhaps running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; one time and without having to touch a single line of application code. But if a performance problem comes up in a custom or pile-of-files format, the fix will often require extensive changes to application code to add and maintain new indices or to extract information using different algorithms.</source>
          <target state="translated">どちらの場合でも、SQLiteアプリケーションでパフォーマンスの問題が発生した場合、1つまたは2つの&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントをスキーマに追加するか、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZEを&lt;/a&gt; 1回実行するだけで、アプリケーションコードの1行に触れる必要がないため、これらの問題を解決できることがよくあります。ただし、パフォーマンスの問題がカスタムまたはパイルオブファイル形式で発生した場合、多くの場合、新しいインデックスを追加して維持したり、さまざまなアルゴリズムを使用して情報を抽出したりするために、アプリケーションコードを大幅に変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="25aa68ecfd2b0c4f0ec2db607f906e4651bce4ef" translate="yes" xml:space="preserve">
          <source>In every case, the pager cache size was adjusted to keep the amount of cache memory at about 2MB. For example, a 2000 page cache was used for 1024 byte pages and a 31 page cache was used for 65536 byte pages. The BLOB values were read in a random order.</source>
          <target state="translated">いずれの場合も、ページャーのキャッシュサイズは、キャッシュメモリ量が2MB程度になるように調整した。例えば、2000ページのキャッシュは1024バイトのページに使用され、31ページのキャッシュは65536バイトのページに使用された。BLOB値はランダムな順序で読み込まれた。</target>
        </trans-unit>
        <trans-unit id="cf40b39d63a8fb0ce771e83c7921ec57173f92f8" translate="yes" xml:space="preserve">
          <source>In extreme cases, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors, rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="translated">極端な場合は、&lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;オプションを使用してSQLiteをコンパイルし、SQLiteに&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;）インターフェースを介してヒープとして使用する固定メモリチャンクを提供することを検討してください。これにより、悪意のあるSQLが過剰な量のメモリを使用してサービス拒否攻撃を実行するのを防ぎます。 SQLiteが使用するために（たとえば）5 MBのメモリが提供されている場合、そのメモリが消費されると、SQLiteはアプリケーションの他の部分が必要とするメモリを吸収するのではなく、SQLITE_NOMEMエラーを返し始めます。これはSQLiteのメモリもサンドボックス化するため、アプリケーションの他の部分での解放後の書き込みエラーがSQLiteに問題を引き起こしたり、その逆が起こったりすることはありません。</target>
        </trans-unit>
        <trans-unit id="b60127a70276716ca6ce96b164af1caff22c34ff" translate="yes" xml:space="preserve">
          <source>In fairness to PostgreSQL, it started thrashing on this test. A knowledgeable administrator might be able to get PostgreSQL to run a lot faster here by tweaking and tuning the server a little.</source>
          <target state="translated">PostgreSQLの公平性を考えれば、このテストでは、PostgreSQLの動作が不安定になっていました。知識のある管理者であれば、サーバを少し調整したりチューニングしたりすることで、PostgreSQLをより高速に動作させることができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="776b2a0854afad2e6c812aae004c09f148d516c9" translate="yes" xml:space="preserve">
          <source>In fairness, having a built-in implementation of printf() also comes with some disadvantages. To wit:</source>
          <target state="translated">公平に考えれば、printf()の組み込み実装を持っていることには、いくつかの欠点もあります。それは、以下のようなことです。</target>
        </trans-unit>
        <trans-unit id="c2fda1dfe98bf18ac7aa5572676942f62e5e1fe2" translate="yes" xml:space="preserve">
          <source>In first form, if the main database has already been created, then this pragma returns the text encoding used by the main database, one of 'UTF-8', 'UTF-16le' (little-endian UTF-16 encoding) or 'UTF-16be' (big-endian UTF-16 encoding). If the main database has not already been created, then the value returned is the text encoding that will be used to create the main database, if it is created by this session.</source>
          <target state="translated">最初の形式では、メインデータベースが既に作成されている場合、このpragmaはメインデータベースで使用されるテキストエンコーディングを、'UTF-8'、'UTF-16le' (リトルエンディアンのUTF-16エンコーディング)、または'UTF-16be' (ビッグエンディアンのUTF-16エンコーディング)のいずれかで返します。メインデータベースがまだ作成されていない場合、返される値は、このセッションでメインデータベースが作成された場合、メインデータベースの作成に使用されるテキストエンコーディングです。</target>
        </trans-unit>
        <trans-unit id="b4265b09e5ee96a8a7b2a30c889a0bcc8a3fb773" translate="yes" xml:space="preserve">
          <source>In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number.</source>
          <target state="translated">フォーマット 4、7、および 10 では、端数秒値 SS.SSS は小数点以下に 1 桁以上の数字を持つことができます。この例では、最初の3桁だけが結果にとって重要であるため、正確に3桁の桁が示されていますが、入力文字列は3桁以下でもそれ以上でも構いませんし、日付/時刻関数は依然として正しく動作します。同様に、フォーマット12は10桁の有効数字で示されていますが、日付/時刻関数は、ユリウス日の数字を表すのに必要な数だけ、または数だけの数字を受け入れます。</target>
        </trans-unit>
        <trans-unit id="af29b68f8112f5b3ba3c7546feb616bd5c5cfef7" translate="yes" xml:space="preserve">
          <source>In formats 5 through 7, the &quot;T&quot; is a literal character separating the date and the time, as required by &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt;. Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string 'now', is converted into the current date and time as obtained from the xCurrentTime method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in use. The 'now' argument to date and time functions always returns exactly the same value for multiple invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call. &lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;Universal Coordinated Time (UTC)&lt;/a&gt; is used. Format 12 is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt; expressed as a floating point value.</source>
          <target state="translated">形式5〜7では、「T」は、&lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601で&lt;/a&gt;要求されているように、日付と時刻を区切るリテラル文字です。時間のみを指定するフォーマット8から10は、2000-01-01の日付を想定しています。形式11、文字列「now」は、使用中の&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxCurrentTimeメソッドから取得した現在の日付と時刻に変換されます。日付と時刻関数の 'now'引数は、同じ&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出し内の複数の呼び出しに対して常に正確に同じ値を返します。&lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;協定世界時（UTC）&lt;/a&gt;が使用されます。形式12は、浮動小数点値として表される&lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;ユリウス日数&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f289b58633d51c42244b9615eefef812e48059b3" translate="yes" xml:space="preserve">
          <source>In general, you can do anything with a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that can be done with an ordinary table, except that you cannot create indices or triggers on a virtual table. Some virtual table implementations might impose additional restrictions. For example, many virtual tables are read-only.</source>
          <target state="translated">一般に、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;でインデックスやトリガーを作成できないことを除いて、通常のテーブルで実行できる仮想テーブルで何でも実行できます。一部の仮想テーブルの実装では、追加の制限が課される場合があります。たとえば、多くの仮想テーブルは読み取り専用です。</target>
        </trans-unit>
        <trans-unit id="eeca88e5ce04c05464f766d95ff0eeb5cfc7eabb" translate="yes" xml:space="preserve">
          <source>In hindsight, we should not have tried to make SQLite accept MySQL 3.x syntax, and should have never allowed double-quoted string literals. However, there are countless applications that make use of double-quoted string literals and so we continue to support that capability to avoid breaking legacy.</source>
          <target state="translated">今思えば、SQLite が MySQL 3.x の構文を受け入れるようにしようとするべきではなかったし、二重引用符で囲まれた文字列リテラルを許可すべきではありませんでした。しかし、二重引用符で囲まれた文字列リテラルを使用するアプリケーションは数え切れないほどあるので、レガシーを壊さないようにその機能をサポートし続けます。</target>
        </trans-unit>
        <trans-unit id="f3caa4201cfb419be724f72954ef422185458de8" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">デフォルトの構成では、SQLite APIルーチンは30の整数&lt;a href=&quot;../rescode&quot;&gt;結果コードの&lt;/a&gt; 1つを返します。ただし、経験から、これらの結果コードの多くは粒度が粗すぎることがわかっています。それらはプログラマーが望むかもしれないほど問題について多くの情報を提供しません。これに対処するために、SQLiteの新しいバージョン（バージョン3.3.8 2006-10-09以降）では、エラーに関するより詳細な情報を提供する追加の結果コードのサポートが含まれています。これらの&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;は、&lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt; API を使用して、データベース接続ごとに有効または無効になります。または、最新のエラーの拡張コードは、&lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="3039a66b6632d9561c27b79f80cd7bfba4d1c329" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">デフォルトの構成では、SQLite APIルーチンは30の整数&lt;a href=&quot;rescode&quot;&gt;結果コードの&lt;/a&gt; 1つを返します。ただし、経験から、これらの結果コードの多くは粒度が粗すぎることがわかっています。それらはプログラマーが望むかもしれないほど問題について多くの情報を提供しません。これに対処するために、SQLiteの新しいバージョン（バージョン3.3.8 2006-10-09以降）では、エラーに関するより詳細な情報を提供する追加の結果コードのサポートが含まれています。これらの&lt;a href=&quot;rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;は、&lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt; API を使用して、データベース接続ごとに有効または無効になります。または、最新のエラーの拡張コードは、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="c851426635cb37e8f1ffc6284cb9e22ec511a9f4" translate="yes" xml:space="preserve">
          <source>In keeping with the pile-of-files theme, OpenDocument stores all slide content in a single big XML file named &quot;content.xml&quot;. LibreOffice reads and parses this entire file just to display the first slide. LibreOffice also seems to read all images into memory as well, which makes sense seeing as when the user does &quot;File/Save&quot; it is going to have to write them all back out again, even though none of them changed. The net effect is that start-up is slow. Double-clicking an OpenDocument file brings up a progress bar rather than the first slide. This results in a bad user experience. The situation grows ever more annoying as the document size increases.</source>
          <target state="translated">ファイルの山」というテーマに沿って、OpenDocument はすべてのスライドの内容を「content.xml」という名前の単一の大きな XML ファイルに保存します。LibreOfficeは、最初のスライドを表示するためだけに、このファイル全体を読み込んで解析します。LibreOfficeはまた、すべての画像をメモリに読み込んでいるようです。これは、ユーザーが「ファイル/保存」をするときに、何も変更していないにもかかわらず、すべての画像を再び書き出さなければならないことを考えると、理にかなっています。その結果、起動が遅くなります。OpenDocumentファイルをダブルクリックすると、最初のスライドではなくプログレスバーが表示されます。これは悪いユーザー体験になります。この状況は、ドキュメントのサイズが大きくなるにつれて、ますますイライラしてきます。</target>
        </trans-unit>
        <trans-unit id="c55972e777545acb2431d05db4c4023b23be4d2b" translate="yes" xml:space="preserve">
          <source>In many cases, method (1) above is the best approach. It does not add extra data to the FTS index or require FTS5 to query for multiple terms, so it is efficient in terms of disk space and query speed. However, it does not support prefix queries very well. If, as suggested above, the token &quot;first&quot; is substituted for &quot;1st&quot; by the tokenizer, then the query:</source>
          <target state="translated">多くの場合、上記(1)の方法が最良のアプローチである。この方法は、FTSインデックスに余分なデータを追加したり、FTS5に複数の用語の問い合わせを要求したりすることがないので、ディスク容量や問い合わせ速度の点で効率的です。しかし、プレフィックスクエリはあまりサポートしていません。上で提案されているように、トークンライザによってトークン「1st」が「1st」に置き換えられた場合、クエリは</target>
        </trans-unit>
        <trans-unit id="5d477280cde1f0cb61a1a86eeb18153043aeb432" translate="yes" xml:space="preserve">
          <source>In most SQL databases, if you have a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, or &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraint on a table and you try to do an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that violates the constraint, the database will abort the operation in progress, back out any prior changes associated with the same UPDATE or INSERT statement, and return an error. This is the default behavior of SQLite, though SQLite also allows one to define alternative ways for dealing with constraint violations. This article describes those alternatives and how to use them.</source>
          <target state="translated">ほとんどのSQLデータベースでは、テーブルに&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;、&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;、または&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;制約があり、その制約に違反する&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;または&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;を実行しようとすると、データベースは進行中の操作を中止し、関連する以前の変更をすべて取り消します。同じUPDATEまたはINSERTステートメントで、エラーを返します。これはSQLiteのデフォルトの動作ですが、SQLiteでは、制約違反に対処するための代替方法を定義することもできます。この記事では、これらの代替策とその使用方法について説明します。</target>
        </trans-unit>
        <trans-unit id="a92a8e52f2222eb943cf97b12f1b58ee960571a6" translate="yes" xml:space="preserve">
          <source>In most SQL implementations, output columns of an aggregate query may only reference aggregate functions or columns named in the GROUP BY clause. It does not make good sense to reference an ordinary column in an aggregate query because each output row might be composed from two or more rows in the input table(s).</source>
          <target state="translated">ほとんどのSQL実装では、集約クエリの出力カラムは集約関数かGROUP BY句で指定されたカラムのみを参照することができます。各出力行は入力テーブルの2つ以上の行から構成されている可能性があるため、集約クエリで通常のカラムを参照することはあまり意味がありません。</target>
        </trans-unit>
        <trans-unit id="ebf21aed9282198e08f544c4b59f1cde35658d89" translate="yes" xml:space="preserve">
          <source>In most applications, the database page cache subsystem within SQLite uses more dynamically allocated memory than all other parts of SQLite combined. It is not unusual to see the database page cache consume over 10 times more memory than the rest of SQLite combined.</source>
          <target state="translated">ほとんどのアプリケーションでは、SQLite 内のデータベースページキャッシュサブシステムは、SQLite の他のすべての部分を合わせたものよりも多くの動的に割り当てられたメモリを使用しています。データベースページキャッシュがSQLiteの他の部分を合わせると10倍以上のメモリを消費することも珍しくありません。</target>
        </trans-unit>
        <trans-unit id="ea5d93a0bdef6b6a869ec9bc6ec20416d6dd4af5" translate="yes" xml:space="preserve">
          <source>In most applications, the number of columns is small - a few dozen. There are places in the SQLite code generator that use algorithms that are O(N&amp;sup2;) where N is the number of columns. So if you redefine SQLITE_MAX_COLUMN to be a really huge number and you generate SQL that uses a large number of columns, you may find that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; runs slowly.</source>
          <target state="translated">ほとんどのアプリケーションでは、列の数は少なく、数ダースです。SQLiteコードジェネレーターには、O（N&amp;sup2;）のアルゴリズムを使用する場所があります。Nは列の数です。そのため、SQLITE_MAX_COLUMNを非常に大きな数に再定義し、多数の列を使用するSQLを生成すると、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）の&lt;/a&gt;実行が遅くなることがあります。</target>
        </trans-unit>
        <trans-unit id="5715db4d1b11556e8f8726b68f211a79da84d8fd" translate="yes" xml:space="preserve">
          <source>In most cases, UNIQUE and PRIMARY KEY constraints are implemented by creating a unique index in the database. (The exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and PRIMARY KEYs on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) Hence, the following schemas are logically equivalent:</source>
          <target state="translated">ほとんどの場合、UNIQUEおよびPRIMARY KEY制約は、データベースに一意のインデックスを作成することによって実装されます。（例外は、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;およびPRIMARY KEYです。）したがって、次のスキーマは論理的に同等です。</target>
        </trans-unit>
        <trans-unit id="5a1cd73f371732c3b6f817956ff2682bb7f1000a" translate="yes" xml:space="preserve">
          <source>In most cases, you will want to supplement the basic commands above with &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; appropriate for your application. Commonly used compile-time options include:</source>
          <target state="translated">ほとんどの場合、アプリケーションに適した&lt;a href=&quot;compile&quot;&gt;コンパイル時オプションで&lt;/a&gt;上記の基本的なコマンドを補足する必要があります。一般的に使用されるコンパイル時オプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="97ef5a309f4aafbcba4ef803b72a915f31e696d6" translate="yes" xml:space="preserve">
          <source>In most contexts, the special &quot;rowid&quot; column of normal tables can also be called &quot;oid&quot; or &quot;_rowid_&quot;. However, only &quot;rowid&quot; works as the keyword in the CREATE TABLE statement.</source>
          <target state="translated">ほとんどの文脈では、通常のテーブルの特別な &quot;rowid &quot;カラムは &quot;oid &quot;や&quot;_rowid_&quot;と呼ぶこともできます。しかし、&quot;rowid &quot;のみがCREATE TABLE文のキーワードとして機能します。</target>
        </trans-unit>
        <trans-unit id="08bdbf2096af9fe45fd4ac595bd3e0c7bb6e8da7" translate="yes" xml:space="preserve">
          <source>In most other SQL database engines the datatype is associated with the table column that holds the data - with the data container. In SQLite 3.0, the datatype is associated with the data itself, not with its container. &lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;Paul Graham&lt;/a&gt; in his book</source>
          <target state="translated">他のほとんどのSQLデータベースエンジンでは、データ型は、データを保持するテーブル列に関連付けられています-データコンテナー。SQLite 3.0では、データ型はコンテナではなくデータ自体に関連付けられています。&lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;ポール・グラハム&lt;/a&gt;の著書</target>
        </trans-unit>
        <trans-unit id="9b4441386a86e2d230e048847afd960634eadb47" translate="yes" xml:space="preserve">
          <source>In normal cases, new content is appended to the WAL file until the WAL file accumulates about 1000 pages (and is thus about 4MB in size) at which point a checkpoint is automatically run and the WAL file is recycled. The checkpoint does not normally truncate the WAL file (unless the &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt; is set). Instead, it merely causes SQLite to start overwriting the WAL file from the beginning. This is done because it is normally faster to overwrite an existing file than to append. When the last connection to a database closes, that connection does one last checkpoint and then deletes the WAL and its associated shared-memory file, to clean up the disk.</source>
          <target state="translated">通常の場合、新しいコンテンツは、WALファイルが約1000ページ（つまり、サイズが約4MB）になるまでチェックポイントが自動的に実行され、WALファイルがリサイクルされるまで、WALファイルに追加されます。チェックポイントは通常、WALファイルを切り捨てません（&lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limitプラグマ&lt;/a&gt;が設定されていない場合）。代わりに、SQLiteがWALファイルを最初から上書きし始めるだけです。これは、通常、追加するよりも既存のファイルを上書きする方が速いためです。データベースへの最後の接続が閉じると、その接続は最後の1つのチェックポイントを実行し、WALとそれに関連する共有メモリファイルを削除して、ディスクをクリーンアップします。</target>
        </trans-unit>
        <trans-unit id="9b10dbf3c620afa11c457409454feda884f8c775" translate="yes" xml:space="preserve">
          <source>In older versions of SQLite, shared cache mode could not be used together with virtual tables. This restriction was removed in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10).</source>
          <target state="translated">SQLiteの以前のバージョンでは、共有キャッシュモードは仮想テーブルと一緒に使用できませんでした。この制限はSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;バージョン3.6.17&lt;/a&gt;（2009-08-10）で削除されました。</target>
        </trans-unit>
        <trans-unit id="c0ec8617fee4e8f946bad89174a49f940e3f428d" translate="yes" xml:space="preserve">
          <source>In one test that indexed a large set of emails (1636 MiB on disk), the FTS index was 743 MiB on disk with detail=full, 340 MiB with detail=column and 134 MiB with detail=none.</source>
          <target state="translated">大規模な電子メールのセット(ディスク上の1636 MiB)をインデックス化した1つのテストでは、FTSのインデックスはディスク上の743 MiB(detail=fullの場合)、340 MiB(detail=columnの場合)、134 MiB(detail=noneの場合)となっていました。</target>
        </trans-unit>
        <trans-unit id="79708a29f43e4b6af877ac3750b35c58a6cfa4a6" translate="yes" xml:space="preserve">
          <source>In order for an application to &lt;a href=&quot;fts5#extending_fts5&quot;&gt;add new extensions to FTS5&lt;/a&gt;, such as new tokenizers, the application needs a pointer to the &quot;fts5_api&quot; object.</source>
          <target state="translated">アプリケーションが&lt;a href=&quot;fts5#extending_fts5&quot;&gt;新しいトークナイザー&lt;/a&gt;などの新しい拡張機能をFTS5に追加するには、アプリケーションは「fts5_api」オブジェクトへのポインターを必要とします。</target>
        </trans-unit>
        <trans-unit id="28a836bfad6faf09ee027032e5467aeee1a64f66" translate="yes" xml:space="preserve">
          <source>In order for the OR-by-UNION technique shown above to be useful, there must be an index available that helps resolve every OR-connected term in the WHERE clause. If even a single OR-connected term is not indexed, then a full table scan would have to be done in order to find the rowids generated by the one term, and if SQLite has to do a full table scan, it might as well do it on the original table and get all of the results in a single pass without having to mess with union operations and follow-on binary searches.</source>
          <target state="translated">上で示した OR-by-UNION テクニックを有効にするためには、WHERE 句の中の OR 接続されたすべての項を解決するのに役立つインデックスが必要です。もし単一の OR 接続された項がインデックス化されていない場合は、その項が生成した行 ID を見つけるためにテーブルのフルスキャンを行わなければなりません。</target>
        </trans-unit>
        <trans-unit id="eb3713c378b1d1ce3d9a0c47d48cd2eaea6cff83" translate="yes" xml:space="preserve">
          <source>In order to allow multiple threads to use the same database connection at the same time, SQLite must make extensive use of mutexes. And for this reason a new mutex subsystem as been added. The mutex subsystem as the following interface:</source>
          <target state="translated">複数のスレッドが同時に同じデータベース接続を使用できるようにするためには、SQLite はミューテックスを広く利用しなければなりません。このため、新しいミューテックスサブシステムが追加されました。ミューテックスサブシステムは次のようなインターフェースです。</target>
        </trans-unit>
        <trans-unit id="2b5d71d84c9eba5a8b5eeb690db9b2671be986f0" translate="yes" xml:space="preserve">
          <source>In order to avoid this problem, instead of a single large buffer, input is passed to a streaming API functions by way of a callback function that the sessions module invokes to incrementally request input data as it is required. In all cases, a pair of API function parameters such as</source>
          <target state="translated">この問題を避けるために、入力は単一の大きなバッファの代わりに、必要に応じて入力データをインクリメンタルに要求するためにセッションモジュールが呼び出すコールバック関数を介してストリーミングAPI関数に渡されます。どのような場合でも、API関数のパラメータとして</target>
        </trans-unit>
        <trans-unit id="4b125f2963fbbbf781a2aacf5295274d0ac9b884" translate="yes" xml:space="preserve">
          <source>In order to calculate a documents score, the full-text query is separated into its component phrases. The bm25 score for document</source>
          <target state="translated">ドキュメントのスコアを計算するために、フルテキストクエリを構成フレーズに分離します。ドキュメントのBM25スコア</target>
        </trans-unit>
        <trans-unit id="7154e5ea3dd269ef8c7a3c815659cc160be40ee6" translate="yes" xml:space="preserve">
          <source>In order to change the mapping of the rank column for a single query, a term similar to either of the following is added to the WHERE clause of a query:</source>
          <target state="translated">単一のクエリのランク列のマッピングを変更するには、以下のいずれかに似た用語をクエリのWHERE句に追加します。</target>
        </trans-unit>
        <trans-unit id="2abb792779e09d00b7b2cceff1ab43c73c0ae359" translate="yes" xml:space="preserve">
          <source>In order to create an FTS4 table that does not store a copy of the indexed documents at all, the content option should be set to an empty string. For example, the following SQL creates such an FTS4 table with three columns - &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;:</source>
          <target state="translated">インデックス化された文書のコピーを全く保存しないFTS4テーブルを作成するためには、contentオプションを空の文字列に設定する必要があります。例えば、以下のSQLは、&quot;a&quot;、&quot;b&quot;、&quot;c &quot;の3つのカラムを持つこのようなFTS4テーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="dfa1c414109c4c2ee027ceb1647c28553c0a4044" translate="yes" xml:space="preserve">
          <source>In order to create or modify an existing zip file, a &quot;zipfile&quot; virtual table must be created in the database schema. The CREATE VIRTUAL TABLE statement expects a path to the zip file as its only argument. For example, to write to zip file &quot;test.zip&quot; in the current directory, a zipfile table may be created using:</source>
          <target state="translated">既存の zip ファイルを作成または変更するには、データベーススキーマに &quot;zipfile&quot; 仮想テーブルを作成する必要があります。CREATE VIRTUAL TABLE文は、唯一の引数としてzipファイルへのパスを指定します。例えば、カレントディレクトリ内のzipファイル &quot;test.zip &quot;に書き込むには、以下のようにしてzipファイルテーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="46eb456df96a41735386e11e34c4d6e23c625078" translate="yes" xml:space="preserve">
          <source>In order to determine whether or not the database file has changed, SQLite uses a counter in the database header (in bytes 24 through 27) which is incremented during every change operation. SQLite saves a copy of this counter prior to releasing its database lock. Then after acquiring the next database lock it compares the saved counter value against the current counter value and erases the cache if the values are different, or reuses the cache if they are the same.</source>
          <target state="translated">データベースファイルが変更されたかどうかを判断するために、SQLite はデータベースヘッダ内のカウンタ(24 バイトから 27 バイトまで)を使用します。SQLite はデータベースロックを解放する前にこのカウンタのコピーを保存します。次のデータベースロックを取得した後、SQLiteは保存されたカウンタの値を現在のカウンタの値と比較し、値が異なる場合はキャッシュを消去し、値が同じ場合はキャッシュを再利用します。</target>
        </trans-unit>
        <trans-unit id="c5338f8b41864bbeb0f4c2c2e58a285f7e7a5717" translate="yes" xml:space="preserve">
          <source>In order to gain experience with the main ideas surrounding asynchronous IO, this implementation is deliberately kept simple. Additional capabilities may be added in the future.</source>
          <target state="translated">非同期 IO に関する主な考え方を経験するために、この実装は意図的にシンプルにしています。将来的には追加機能が追加されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a809ecf69a6ad9ffe3bc78cfb9dbeacb5971a731" translate="yes" xml:space="preserve">
          <source>In order to guarantee that database files are always consistent, SQLite will occasionally ask the operating system to flush all pending writes to persistent storage then wait for that flush to complete. This is accomplished using the &lt;code&gt;fsync()&lt;/code&gt; system call under unix and &lt;code&gt;FlushFileBuffers()&lt;/code&gt; under Windows. We call this flush of pending writes a &quot;sync&quot;.</source>
          <target state="translated">データベースファイルが常に一貫していることを保証するために、SQLiteは、オペレーティングシステムに永続ストレージへの保留中の書き込みをすべてフラッシュし、そのフラッシュが完了するのを待つように要求することがあります。これは、使用して達成される &lt;code&gt;fsync()&lt;/code&gt; UNIXと下のシステムコール &lt;code&gt;FlushFileBuffers()&lt;/code&gt; Windowsで。この保留中の書き込みのフラッシュを「同期」と呼びます。</target>
        </trans-unit>
        <trans-unit id="3d3d52a785446942df482ef9658c77840bb31674" translate="yes" xml:space="preserve">
          <source>In order to maintain full backwards compatibility for legacy applications, the URI filename capability is disabled by default. URI filenames can be enabled or disabled using the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=1&lt;/a&gt; or &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=0&lt;/a&gt; compile-time options. The compile-time setting for URI filenames can be changed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) or &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,0) configuration calls. Regardless of the compile-time or start-time settings, URI filenames can be enabled for individual database connections by including the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; bit in the set of bits passed as the F parameter to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2(N,P,F,V)&lt;/a&gt;.</source>
          <target state="translated">レガシーアプリケーションの完全な下位互換性を維持するために、URIファイル名機能はデフォルトで無効になっています。&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 1&lt;/a&gt;または&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 0&lt;/a&gt;コンパイル時オプションを使用して、URIファイル名を有効または無効にできます。URIファイル名のコンパイル時設定は、&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;、1）または&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;、0）構成呼び出しを使用して、開始時に変更できます。コンパイル時または開始時の設定に関係なく、Fパラメーターとして&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（N、P、F、V）に&lt;/a&gt;渡されるビットのセットに&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;ビットを含めることにより、個々のデータベース接続でURIファイル名を有効にできます。。</target>
        </trans-unit>
        <trans-unit id="ee9ce9696c9f5b398459fe9fa5003d871b602ba2" translate="yes" xml:space="preserve">
          <source>In order to maximize compatibility between SQLite and other database engines, and so that the example above will work on SQLite as it does on other SQL database engines, SQLite supports the concept of &quot;type affinity&quot; on columns. The type affinity of a column is the recommended type for data stored in that column. The important idea here is that the type is recommended, not required. Any column can still store any type of data. It is just that some columns, given the choice, will prefer to use one storage class over another. The preferred storage class for a column is called its &quot;affinity&quot;.</source>
          <target state="translated">SQLiteと他のデータベースエンジン間の互換性を最大化し、上記の例がSQLite上でも他のSQLデータベースエンジンと同様に動作するようにするために、SQLiteはカラムの &quot;型の親和性 &quot;という概念をサポートしています。カラムの型の親和性とは、そのカラムに格納されているデータに推奨される型のことです。ここで重要なのは、型は推奨されるものであり、必須ではないということです。どのカラムでも、どのようなタイプのデータを格納することができます。ただ、いくつかのカラムは、選択の余地があれば、別のストレージクラスよりも、あるストレージクラスを使用することを好むということです。カラムに好ましいストレージクラスは、その「親和性」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="c4c58e4d4912a4704b0cbb27832e1afdc4578e5c" translate="yes" xml:space="preserve">
          <source>In order to port SQLite to a new operating system - an operating system not supported by default - the application must provide...</source>
          <target state="translated">SQLite を新しいオペレーティング・システム(デフォルトではサポートされていないオペレーティング・システム)に移植するためには、アプリケーションは...</target>
        </trans-unit>
        <trans-unit id="9139039adfb729ff69195002226ce412be58a20b" translate="yes" xml:space="preserve">
          <source>In order to prevent the number of b-trees in the database from becoming too large (slowing down queries), smaller b-trees are periodically merged into single larger b-trees containing the same data. By default, this happens automatically within INSERT, UPDATE or DELETE statements that modify the full-text index. The 'automerge' parameter determines how many smaller b-trees are merged together at a time. Setting it to a small value can speed up queries (as they have to query and merge the results from fewer b-trees), but can also slow down writing to the database (as each INSERT, UPDATE or DELETE statement has to do more work as part of the automatic merging process).</source>
          <target state="translated">データベース内のb-木の数が大きくなりすぎてクエリが遅くなるのを防ぐために、小さなb-木は定期的に同じデータを含む単一の大きなb-木にマージされます。デフォルトでは、これはフルテキストインデックスを変更するINSERT、UPDATE、またはDELETE文の中で自動的に行われます。automerge' パラメータは、一度に何本の小さな b-木をマージするかを決定します。これを小さな値に設定すると、クエリを高速化することができます(より少ないb-木からの結果をクエリしてマージしなければならないので)が、データベースへの書き込みを遅くすることもできます(各INSERT、UPDATE、またはDELETE文は、自動マージ処理の一部としてより多くの作業をしなければならないので)。</target>
        </trans-unit>
        <trans-unit id="3d48be902e74206d36d33669d85fb41c800c7878" translate="yes" xml:space="preserve">
          <source>In order to provide portability between across operating systems, SQLite uses abstract object called the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Each VFS provides methods for opening, read, writing, and closing files on disk, and for other OS-specific task such as finding the current time, or obtaining randomness to initialize the built-in pseudo-random number generator. SQLite currently provides VFSes for unix (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; file) and Windows (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; file).</source>
          <target state="translated">SQLiteは、オペレーティングシステム間での移植性を提供するために、&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;と呼ばれる抽象オブジェクトを使用します。各VFSは、ディスク上のファイルを開いたり、読み込んだり、書き込んだり、閉じたりするためのメソッドを提供します。また、現在の時刻を検索したり、ランダム性を取得して組み込みの疑似乱数ジェネレーターを初期化したりするなど、他のOS固有のタスクを実行します。 SQLiteは現在、UNIX（&lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;ファイル内）およびWindows（os_win.cファイル内）用のVFSを提供して&lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;い&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="31ad990efe0b69348774fca33a1caeca8003e9e6" translate="yes" xml:space="preserve">
          <source>In order to rebase a local changeset, the remote changeset must first be applied to the local database using sqlite3changeset_apply_v2() and the buffer of rebase information captured. Then:</source>
          <target state="translated">ローカルのチェンジセットをリベースするためには、まずリモートのチェンジセットをsqlite3changeset_apply_v2()を使用してローカルのデータベースに適用し、リベース情報のバッファをキャプチャしなければなりません。そして、リベース情報のバッファをキャプチャします。</target>
        </trans-unit>
        <trans-unit id="aa098185ca802c3d4bb821bfd07089d8121f87d8" translate="yes" xml:space="preserve">
          <source>In order to return data from the database to the user, for example as the results of a SELECT query, SQLite must at some point read data from the database file. Usually, data is read from the database file in aligned blocks of</source>
          <target state="translated">データベースからデータをユーザーに返すためには、例えばSELECTクエリの結果として、SQLiteはある時点でデータベースファイルからデータを読み込まなければなりません。通常、データはデータベースファイルから</target>
        </trans-unit>
        <trans-unit id="fbe7b2f0d6747492938cc0cedd14f11e91e462ca" translate="yes" xml:space="preserve">
          <source>In order to save space, this backing table may be omitted by setting the columnsize option to zero. For example:</source>
          <target state="translated">スペースを節約するために、columnizeオプションを0に設定することで、この裏付け表を省略することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1dc49d196adf92707040503b638c58b0d1b51283" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">成功するには、&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（D、S、P）&lt;/a&gt;が呼び出されたときにデータベース接続が&lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;自動コミットモードであって&lt;/a&gt;はなりません。スキーマSで既に開いている読み取りトランザクションがある場合、データベースハンドルにはアクティブなステートメント（sqlite3_step（）に渡され、sqlite3_reset（）またはsqlite3_finalize（）には渡されないSELECTステートメント）があってはなりません。これらの条件のいずれかに違反した場合、スキーマSが存在しない場合、またはスナップショットオブジェクトが無効な場合は、SQLITE_ERRORが返されます。</target>
        </trans-unit>
        <trans-unit id="4bcc91176e8c72eef945e65a5e94e40093e70723" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">成功するには、&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（D、S、P）&lt;/a&gt;が呼び出されたときにデータベース接続が&lt;a href=&quot;get_autocommit&quot;&gt;自動コミットモードであって&lt;/a&gt;はなりません。スキーマSで既に開いている読み取りトランザクションがある場合、データベースハンドルにはアクティブなステートメント（sqlite3_step（）に渡され、sqlite3_reset（）またはsqlite3_finalize（）には渡されないSELECTステートメント）があってはなりません。これらの条件のいずれかに違反した場合、スキーマSが存在しない場合、またはスナップショットオブジェクトが無効な場合は、SQLITE_ERRORが返されます。</target>
        </trans-unit>
        <trans-unit id="3885c40685a2b0fc9bd29a3371e31ed82a66178a" translate="yes" xml:space="preserve">
          <source>In order to use FTS5 instead of FTS3 or FTS4, applications usually require minimal modifications. Most of these fall into three categories - changes required to the CREATE VIRTUAL TABLE statement used to create the FTS table, changes required to SELECT queries used to execute queries against the table, and changes required to applications that use &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">FTS3またはFTS4の代わりにFTS5を使用するために、アプリケーションは通常最小限の変更を必要とします。これらのほとんどは、FTSテーブルの作成に使用されるCREATE VIRTUAL TABLEステートメントに必要な変更、テーブルに対するクエリの実行に使用されるSELECTクエリに必要な変更、および&lt;a href=&quot;fts3#snippet&quot;&gt;FTS補助関数&lt;/a&gt;を使用するアプリケーションに必要な変更の3つのカテゴリに分類されます。</target>
        </trans-unit>
        <trans-unit id="362a80a01b0db13fb3dac03d2ae8d3c5e2853e16" translate="yes" xml:space="preserve">
          <source>In order to use foreign key constraints in SQLite, the library must be compiled with neither &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; or &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; defined. If SQLITE_OMIT_TRIGGER is defined but SQLITE_OMIT_FOREIGN_KEY is not, then SQLite behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14) - foreign key definitions are parsed and may be queried using &lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;, but foreign key constraints are not enforced. The &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command is a no-op in this configuration. If OMIT_FOREIGN_KEY is defined, then foreign key definitions cannot even be parsed (attempting to specify a foreign key definition is a syntax error).</source>
          <target state="translated">SQLiteで外部キー制約を使用するには、&lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt;または&lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGERが&lt;/a&gt;定義されていない状態でライブラリをコンパイルする必要があります。 SQLITE_OMIT_TRIGGERは定義されているがSQLITE_OMIT_FOREIGN_KEYが定義されていない場合、SQLiteは&lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;バージョン3.6.19&lt;/a&gt;（2009-10-14）より前と同様に動作します-外部キー定義は解析され、&lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;を使用してクエリできますが、外部キー制約は強制されません。&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA FOREIGN_KEYS&lt;/a&gt;コマンドは、この構成では何もしません。 OMIT_FOREIGN_KEYが定義されている場合、外部キー定義を解析することもできません（外部キー定義を指定しようとすると、構文エラーになります）。</target>
        </trans-unit>
        <trans-unit id="2a10b918ff09134ab69409cf683db7b4a9557318" translate="yes" xml:space="preserve">
          <source>In order to use this command to delete a row, the text value 'delete' must be inserted into the special column with the same name as the table. The rowid of the row to delete is inserted into the rowid column. The values inserted into the other columns must match the values currently stored in the table. For example:</source>
          <target state="translated">このコマンドを使用して行を削除するためには、テーブルと同じ名前の特殊な列にテキスト値「delete」を挿入する必要があります。削除する行の rowid が rowid 列に挿入されます。他の列に挿入される値は、現在テーブルに格納されている値と一致している必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="18acf9de092948631a77a8a7268e93e0863d7575" translate="yes" xml:space="preserve">
          <source>In ordinary indexes, there is exactly one entry in the index for every row in the table. In partial indexes, only some subset of the rows in the table have corresponding index entries. For example, a partial index might omit entries for which the column being indexed is NULL. When used judiciously, partial indexes can result in smaller database files and improvements in both query and write performance.</source>
          <target state="translated">通常のインデックスでは、テーブル内の各行に対してインデックス内に正確に1つのエントリが存在します。部分インデックスでは、テーブル内の行の一部のサブセットのみが対応するインデックス項目を持ちます。たとえば、部分インデックスでは、インデックスを作成する列がNULLであるエントリを省略することができます。慎重に使用すれば、部分インデックスはデータベースファイルを小さくし、クエリと書き込みの両方のパフォーマンスを向上させることができます。</target>
        </trans-unit>
        <trans-unit id="2aff0a10aa915dae8ca55cc20203451ac3b580cc" translate="yes" xml:space="preserve">
          <source>In other words, an SQLite database can do everything that a pile-of-files or wrapped pile-of-files format can do, plus much more, and with greater lucidity. An SQLite database is a more versatile container than key/value filesystem or a ZIP archive. (For a detailed example, see the &lt;a href=&quot;affcase1&quot;&gt;OpenOffice case study&lt;/a&gt; essay.)</source>
          <target state="translated">言い換えると、SQLiteデータベースは、パイルオブファイルまたはラップされたパイルオブファイル形式で実行できるすべての操作に加えて、さらに多くのことをより明確に実行できます。 SQLiteデータベースは、キー/値ファイルシステムやZIPアーカイブよりも用途の広いコンテナです。 （詳細な例については、&lt;a href=&quot;affcase1&quot;&gt;OpenOfficeケーススタディ&lt;/a&gt;エッセイを参照してください。）</target>
        </trans-unit>
        <trans-unit id="a0407b322bda5c84932b9210d6c9dd55dfaff1cd" translate="yes" xml:space="preserve">
          <source>In other words, if X begins a write transaction using &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; then issues one or more &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and/or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements, then those changes are visible to subsequent &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that are evaluated in database connection X. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements on a different database connection Y will show no changes until the X transaction commits. But &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements in X will show the changes prior to the commit.</source>
          <target state="translated">換言すれば、Xは、使用して書き込みトランザクションを開始する場合&lt;a href=&quot;lang_transaction#immediate&quot;&gt;IMMEDIATE BEGIN&lt;/a&gt;次いで課題一つ以上の&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、および/または&lt;a href=&quot;lang_insert&quot;&gt;INSERTの&lt;/a&gt;それらの変化は、その後に表示され、文の&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;データベース接続X.で評価されるステートメント&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;別に文データベース接続Yは、Xトランザクションがコミットするまで変更を表示しません。しかし、Xの&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントは、コミット前の変更を表示します。</target>
        </trans-unit>
        <trans-unit id="b76e19862dad40faf099a9e663056c35b57f6bbd" translate="yes" xml:space="preserve">
          <source>In other words, make the same sqlite3_test_control() call except change the last two parameters to zero.</source>
          <target state="translated">言い換えれば、最後の2つのパラメータをゼロに変更する以外は、同じsqlite3_test_control()を呼び出してください。</target>
        </trans-unit>
        <trans-unit id="a943abceb2efdd003ead8aa4530811df4446fd2f" translate="yes" xml:space="preserve">
          <source>In other words, opening and using a database file that has two or more names results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">言い換えれば、2つ以上の名前を持つデータベースファイルを開いて使用すると、定義されていない、おそらく望ましくない動作をすることになります。</target>
        </trans-unit>
        <trans-unit id="5f5d40599d0989dfe7615dba1f4690adcb6d4ca6" translate="yes" xml:space="preserve">
          <source>In other words, powersafe overwrite means that there is no &quot;collateral damage&quot; when a power loss occurs while writing. Only those bytes actually being written might be damaged.</source>
          <target state="translated">言い換えれば、パワーズセーフ上書きは、書き込み中に停電が発生しても「巻き添え被害」が発生しないことを意味しています。実際に書き込まれているバイトだけがダメージを受ける可能性があります。</target>
        </trans-unit>
        <trans-unit id="ebd1e3e7febed4c7b9b73c22b3802bc322206c02" translate="yes" xml:space="preserve">
          <source>In other words, since 2004 all SQLite releases have been backwards compatible, though not necessarily forwards compatible.</source>
          <target state="translated">言い換えれば、2004年以降、すべてのSQLiteリリースは、必ずしも前方互換性があるわけではありませんが、後方互換性があります。</target>
        </trans-unit>
        <trans-unit id="1f360548804fb547b2c55aa98cf2f1549c641a34" translate="yes" xml:space="preserve">
          <source>In other words, the session extension provides a facility for SQLite database files that is similar to the unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;patch&lt;/a&gt; utility program, or to the &quot;merge&quot; capabilities of version control systems such as &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;, &lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;, or &lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;.</source>
          <target state="translated">つまり、セッション拡張機能は、UNIX &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;パッチ&lt;/a&gt;ユーティリティプログラムや、&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;、&lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;、&lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;などのバージョン管理システムの「マージ」機能に類似したSQLiteデータベースファイルの機能を提供します。</target>
        </trans-unit>
        <trans-unit id="c9d46649fb7fd18d588f4a5f73a3e3c10dcafa53" translate="yes" xml:space="preserve">
          <source>In other words, unlinking or renaming an open database file results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">言い換えれば、開いているデータベースファイルのリンクを解除したり、名前を変更したりすると、定義されていない、おそらく望ましくない動作をすることになります。</target>
        </trans-unit>
        <trans-unit id="a8fad5ad802fc08a8688a68301e637bb10e07021" translate="yes" xml:space="preserve">
          <source>In other words, you should call sqlite3_column_text(), sqlite3_column_blob(), or sqlite3_column_text16() first to force the result into the desired format, then invoke sqlite3_column_bytes() or sqlite3_column_bytes16() to find the size of the result. Do not mix calls to sqlite3_column_text() or sqlite3_column_blob() with calls to sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16() with calls to sqlite3_column_bytes().</source>
          <target state="translated">言い換えれば、まずsqlite3_column_text()、sqlite3_column_blob()、またはsqlite3_column_text16()を呼び出して結果を希望の形式に強制し、次にsqlite3_column_bytes()またはsqlite3_column_bytes16()を呼び出して結果のサイズを求める必要があります。sqlite3_column_text()やsqlite3_column_blob()の呼び出しとsqlite3_column_bytes16()の呼び出しを混ぜてはいけません。</target>
        </trans-unit>
        <trans-unit id="456e92a6a9d74515a6d36409e4455702906122d6" translate="yes" xml:space="preserve">
          <source>In practical terms, what the powersafe write property means is that when the disk controller detects an impending power loss, it finishes writing whatever sector it is working on prior to parking the heads. It means that individual sector writes will complete once started, even if there is a power loss.</source>
          <target state="translated">実際的には、パワーセーフ書き込みプロパティが意味するのは、ディスクコントローラが差し迫った停電を検出した場合、ヘッドを駐車する前に、作業中のセクタの書き込みを終了するということです。これは、たとえ停電があったとしても、個々のセクタの書き込みが一旦開始されれば完了することを意味します。</target>
        </trans-unit>
        <trans-unit id="9fe8084319ab239e87ac8042e3d629376c48f43e" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">実際には、メタデータは、リテラル値および&lt;a href=&quot;../lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;と、それから構成される式を含む、コンパイル時定数である関数パラメーターの関数呼び出し間で保持されます。</target>
        </trans-unit>
        <trans-unit id="553ff79ef31136314c6f3a02cf8b8c9de3d93346" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">実際には、メタデータは、リテラル値および&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;と、それから構成される式を含む、コンパイル時定数である関数パラメーターの関数呼び出し間で保持されます。</target>
        </trans-unit>
        <trans-unit id="235238a95713f71f096fe2094b1d8d70514424be" translate="yes" xml:space="preserve">
          <source>In precompiled SQLite libraries available on the website, the Unix versions are compiled with THREADSAFE turned off but the Windows versions are compiled with THREADSAFE turned on. If you need something different that this you will have to recompile.</source>
          <target state="translated">ウェブサイトで公開されているプリコンパイルされたSQLiteライブラリでは、Unix版はTHREADSAFEをオフにしてコンパイルされていますが、Windows版はTHREADSAFEをオンにしてコンパイルされています。これとは異なるものが必要な場合は、再コンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="49d7b0c7067454bf2994ce5482f78c23710e1d3a" translate="yes" xml:space="preserve">
          <source>In prior discussion, it was assumed that each SQL statement is prepared once, evaluated, then destroyed. However, SQLite allows the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; to be evaluated multiple times. This is accomplished using the following routines:</source>
          <target state="translated">以前の説明では、各SQLステートメントは一度準備され、評価されてから破棄されると想定されていました。ただし、SQLiteでは、同じ&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を複数回評価できます。これは、次のルーチンを使用して実行されます。</target>
        </trans-unit>
        <trans-unit id="86c3b83aa53c8f50b7b8f707247a7f27be6c0dc8" translate="yes" xml:space="preserve">
          <source>In processing the query above, SQLite invokes the sumint callbacks as follows:</source>
          <target state="translated">上記のクエリを処理する際に、SQLiteは以下のようにsumintコールバックを呼び出します。</target>
        </trans-unit>
        <trans-unit id="59cf5532e18c9ee34b181fd5de97a560addf74bf" translate="yes" xml:space="preserve">
          <source>In queries that are driven by a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, avoid unnecessary tests of the constraint named in the WHERE clause of the partial index, since we know that constraint must always be true.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;によって駆動されるクエリでは、制約が常にtrueでなければならないことがわかっているため、部分インデックスのWHERE句で指定された制約の不要なテストを回避します。</target>
        </trans-unit>
        <trans-unit id="82246b58b2662ec98735d83b367a59b70f82fb40" translate="yes" xml:space="preserve">
          <source>In rollback mode, SQLite implements isolation by locking the database file and preventing any reads by other database connections while each write transaction is underway. Readers can be be active at the beginning of a write, before any content is flushed to disk and while all changes are still held in the writer's private memory space. But before any changes are made to the database file on disk, all readers must be (temporally) expelled in order to give the writer exclusive access to the database file. Hence, readers are prohibited from seeing incomplete transactions by virtue of being locked out of the database while the transaction is being written to disk. Only after the transaction is completely written and synced to disk and commits are the readers allowed back into the database. Hence readers never get a chance to see partially written changes.</source>
          <target state="translated">ロールバックモードでは、SQLite はデータベースファイルをロックし、各書き込みトランザクションが実行されている間、他のデータベース接続による読み込みを防止することで分離を実装しています。読み込みは書き込みの開始時にアクティブにすることができ、ディスクにコンテンツがフラッシュされる前に、すべての変更がライターのプライベートメモリ空間に保持されている間に行うことができます。しかし、ディスク上のデータベースファイルに変更が加えられる前に、ライターがデータベースファイルに排他的にアクセスできるようにするために、すべてのリーダーは(一時的に)追放されなければなりません。したがって、トランザクションがディスクに書き込まれている間は、データベースからロックアウトされているため、読者は不完全なトランザクションを見ることが禁じられている。トランザクションが完全に書き込まれ、ディスクに同期されてコミットされた後にのみ、 読者はデータベースに戻ることが許される。したがって、読者は部分的に書き込まれた変更を見る機会を得ることができません。</target>
        </trans-unit>
        <trans-unit id="068d2699f531d0825115d300a0cccce10e48a71e" translate="yes" xml:space="preserve">
          <source>In spite of the disadvantages, the developers believe that having a built-in printf() implementation inside of SQLite is a net positive.</source>
          <target state="translated">欠点があるにもかかわらず、開発者たちは、SQLite の中に組み込みの printf()の実装があることは正味のプラスになると考えています。</target>
        </trans-unit>
        <trans-unit id="cf039b1afa32ebe62123ae1292d3fdd466d22e3b" translate="yes" xml:space="preserve">
          <source>In step 2 of the procedure above, the database file is not locked before it is read from. This is the only exception to the locking rules described in section</source>
          <target state="translated">上記手順のステップ2では、データベースファイルを読み出す前にロックされません。で説明したロック規則の唯一の例外です。</target>
        </trans-unit>
        <trans-unit id="8ea8892717935eea12390eaf98af13ff334785db" translate="yes" xml:space="preserve">
          <source>In summary then, any query with aggregate functions is implemented by two loops. The first loop scans the input table and computes aggregate information into buckets and the second loop scans through all the buckets to compute the final result.</source>
          <target state="translated">要約すると、集約関数を持つクエリは2つのループによって実装されます。1つ目のループは入力テーブルをスキャンしてバケットに集約情報を計算し、2つ目のループはすべてのバケットをスキャンして最終的な結果を計算します。</target>
        </trans-unit>
        <trans-unit id="2fe8cccc0c3831ee16f379b0a96fc3ebe090262e" translate="yes" xml:space="preserve">
          <source>In summary, the claim of this essay is that using SQLite as a container for an application file format like OpenDocument and storing lots of smaller objects in that container works out much better than using a ZIP archive holding a few larger objects. To wit:</source>
          <target state="translated">要約すると、このエッセイの主張は、SQLite を OpenDocument のようなアプリケーションファイル形式のコンテナとして使用し、そのコンテナ内に多くの小さなオブジェクトを保存することは、いくつかの大きなオブジェクトを保持する ZIP アーカイブを使用するよりもはるかにうまくいくということです。ウィットによれば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="14368b74fc6cabbc46f6b11af62f68ec319ac0f1" translate="yes" xml:space="preserve">
          <source>In support of the &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; goal for SQLite, the parser code generated by Lemon has no unreachable branches, and contains extra (compile-time selected) instrumentation useful for measuring test coverage.</source>
          <target state="translated">SQLite の&lt;a href=&quot;testing#mcdc&quot;&gt;100％MC / DCテスト&lt;/a&gt;目標をサポートするため、Lemonによって生成されたパーサーコードには到達できないブランチがなく、テストカバレッジの測定に役立つ追加の（コンパイル時に選択された）インスツルメンテーションが含まれています。</target>
        </trans-unit>
        <trans-unit id="aad3b77ed5e3adba0d4656a1d99071301ddd4bc1" translate="yes" xml:space="preserve">
          <source>In the &quot;fossil delta&quot; format - the format used for blob deltas by the &lt;a href=&quot;http://fossil-scm.org&quot;&gt;Fossil source-code management system&lt;/a&gt;, or</source>
          <target state="translated">「fossil delta」形式&lt;a href=&quot;http://fossil-scm.org&quot;&gt;-Fossilソースコード管理システム&lt;/a&gt;によってblobデルタに使用される形式、または</target>
        </trans-unit>
        <trans-unit id="30519768573ed5dd959ec460751bfce418bf4435" translate="yes" xml:space="preserve">
          <source>In the &quot;without ANALYZE&quot; case on the left, the NN algorithm chooses loop P (PLINK) as the outer loop because 4.9 is less than 5.2, resulting in path P-T which is algorithm-1. NN only looks at the single best choice at each step so it completely misses the fact that 5.2+4.4 makes a slightly cheaper plan than 4.9+4.8. But the N3 algorithm keeps track of the 5 best paths for a 2-way join, so it ends up selecting path T-P because of its slightly lower overall cost. Path T-P is algorithm-2.</source>
          <target state="translated">左の「ANALYZEなし」のケースでは、4.9が5.2よりも小さいため、NNアルゴリズムは外側のループとしてループP(PLINK)を選択し、結果としてアルゴリズム1のパスP-Tが得られます。NNは各ステップで単一の最良の選択を見るだけなので、5.2+4.4の方が4.9+4.8よりもわずかに安いプランになるという事実を完全に見逃しています。しかし、NN3アルゴリズムは2ウェイ結合のための5つのベストパスを追跡しているので、パスT-Pを選択します。パスT-Pはアルゴリズム2です。</target>
        </trans-unit>
        <trans-unit id="88edd036016e74b41ab30f363489bc8baf2ff243" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt;, the application needs to tell the extension the location of a C-language array that contains the data for the table-valued function that the extension implements.</source>
          <target state="translated">で&lt;a href=&quot;carray&quot;&gt;CARRAY拡張子&lt;/a&gt;、アプリケーションは拡張を拡張実装するテーブル値関数のデータを含むC言語のアレイの位置を指示する必要があります。</target>
        </trans-unit>
        <trans-unit id="0673453ee376202611f58f23515a709feb8d4034" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, enhance the &quot;.mode&quot; command so that it restores the default column and row separators for modes &quot;line&quot;, &quot;list&quot;, &quot;column&quot;, and &quot;tcl&quot;.</source>
          <target state="translated">で&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;、それはモード『ライン』、 『リスト』、 『列』、および『TCL』のデフォルトの列と行区切り文字を復元するように、「.mode」コマンドを高めます。</target>
        </trans-unit>
        <trans-unit id="c5b3d2f7e7ec64c2ea66a15e4b9de436ddc07a10" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH operator&lt;/a&gt; (which does the full-text search) needs to communicate details of matching entries to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; functions so that those functions can convert the details of the match into useful output.</source>
          <target state="translated">で&lt;a href=&quot;fts3&quot;&gt;FTS3の&lt;/a&gt;拡張、&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH演算子&lt;/a&gt;（フルテキスト検索を行い）に一致するエントリの詳細を通信する必要がある&lt;a href=&quot;fts3#snippet&quot;&gt;（スニペット）&lt;/a&gt;、&lt;a href=&quot;fts3#offsets&quot;&gt;オフセット（） &lt;/a&gt;、及び&lt;a href=&quot;fts3#matchinfo&quot;&gt;（）のMatchInfo&lt;/a&gt;これらの関数は、一致の詳細を変換することができるような機能を有用な出力に。</target>
        </trans-unit>
        <trans-unit id="7f5a2150475db6cefe817c8c9175290580ea2ad7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;json1&quot;&gt;JSON extension&lt;/a&gt;, fix the JSON validator so that it correctly rejects invalid backslash escapes within strings.</source>
          <target state="translated">では&lt;a href=&quot;json1&quot;&gt;JSON拡張&lt;/a&gt;、それが正しく、文字列内の無効なバックスラッシュエスケープを拒否するようにJSONバリデータを修正します。</target>
        </trans-unit>
        <trans-unit id="29cf2e016ded4e45037d7dd8bd42e21681c156af" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;, add extra sync operations to avoid the possibility of corruption following a power failure.</source>
          <target state="translated">で&lt;a href=&quot;rbu&quot;&gt;RBU拡張&lt;/a&gt;、停電、以下の破損の可能性を回避するために、余分な同期操作を追加します。</target>
        </trans-unit>
        <trans-unit id="11f2b4a17490be52b1b76c1ff6aa70a95cb65d46" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension, when rounding 64-bit floating point numbers to 32-bit for storage, always round in a direction that causes the bounding box to get larger.</source>
          <target state="translated">で&lt;a href=&quot;rtree&quot;&gt;RTREEの&lt;/a&gt;バウンディングボックスが大きく取得させる方向に常にラウンド、貯蔵のために32ビットを64ビットの浮動小数点数を丸める拡張、。</target>
        </trans-unit>
        <trans-unit id="240fef4158af161eb22e60a820c151dc84eafe1e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;, add the -uri option to the &quot;sqlite3&quot; TCL command used for creating new database connection objects.</source>
          <target state="translated">では&lt;a href=&quot;tclsqlite&quot;&gt;TCLインタフェース&lt;/a&gt;、新しいデータベース接続オブジェクトを作成するために使用される「sqlite3の」TCLコマンドに-uriオプションを追加します。</target>
        </trans-unit>
        <trans-unit id="156e69c7f61ba1dcce1a1142af151766e801c151" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL language interface&lt;/a&gt;, &quot;@variable&quot; instead of &quot;$variable&quot; always binds as a blob.</source>
          <target state="translated">では&lt;a href=&quot;tclsqlite&quot;&gt;TCL言語インタフェース&lt;/a&gt;の代わりに「$変数」の、「@Variable」ブロブいつものように結合します。</target>
        </trans-unit>
        <trans-unit id="d3bfa67674bb524ce3387e6563f15051a77fe593" translate="yes" xml:space="preserve">
          <source>In the C programming language where &lt;b&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/b&gt; and &lt;b&gt;&lt;code&gt;||&lt;/code&gt;&lt;/b&gt; are &quot;short-circuit&quot; operators, MC/DC and branch coverage are very nearly the same thing. The primary difference is in boolean vector tests. One can test for any of several bits in bit-vector and still obtain 100% branch test coverage even though the second element of MC/DC - the requirement that each condition in a decision take on every possible outcome - might not be satisfied.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/b&gt;および&lt;b&gt; &lt;code&gt;||&lt;/code&gt; の&lt;/b&gt; Cプログラミング言語「短絡」演算子であるMC / DCとブランチカバレッジはほとんど同じものです。主な違いは、ブールベクトルテストです。 MC / DCの2番目の要素（意思決定の各条件がすべての可能な結果を​​とるという要件）が満たされない場合でも、ビットベクトルのいくつかのビットのいずれかをテストし、100％分岐テストカバレッジを取得できます。</target>
        </trans-unit>
        <trans-unit id="a49a291dae627f989ba703462ee2c7e1bcc8b060" translate="yes" xml:space="preserve">
          <source>In the C programming language, it is very easy to write code that has &quot;undefined&quot; or &quot;implementation defined&quot; behavior. That means that the code might work during development, but then give a different answer on a different system, or when recompiled using different compiler options. Examples of undefined and implementation-defined behavior in ANSI C include:</source>
          <target state="translated">C言語のプログラミング言語では、「未定義」または「実装で定義された」動作を持つコードを書くことは非常に簡単です。これは、開発中には動作していても、別のシステムでは動作したり、別のコンパイラオプションを使用して再コンパイルした場合には別の答えが返ってくる可能性があることを意味します。ANSI C での未定義および実装定義の動作の例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="c817a7331349197e219cdd351370db507b5f89c0" translate="yes" xml:space="preserve">
          <source>In the COPY command, backslash can now be used to escape a newline.</source>
          <target state="translated">COPYコマンドで、バックスラッシュを使用して改行をエスケープできるようになりました。</target>
        </trans-unit>
        <trans-unit id="cb9f3cc234a2699a8be8b939bc81e4cd1e3c8028" translate="yes" xml:space="preserve">
          <source>In the Fossil full-text search system, documents that participate in the full-text search (wiki pages, tickets, check-ins, documentation files, etc) are tracked by a table called &quot;ftsdocs&quot; (&lt;u&gt;f&lt;/u&gt;ull &lt;u&gt;t&lt;/u&gt;ext &lt;u&gt;s&lt;/u&gt;earch &lt;u&gt;doc&lt;/u&gt;ument&lt;u&gt;s&lt;/u&gt;). As new documents are added to the repository, they are not indexed right away. Indexing is deferred until there is a search request. The ftsdocs table contains an &quot;idxed&quot; field which is true if the document has been indexed and false if not.</source>
          <target state="translated">化石全文検索システム、フルテキスト検索に参加したドキュメント（Wikiページ、チケット、チェックイン、ドキュメントファイルなど）で（「ftsdocs」と呼ばれるテーブルによって追跡されている&lt;u&gt;F&lt;/u&gt; ULL &lt;u&gt;トン&lt;/u&gt;内線&lt;u&gt;の&lt;/u&gt; earchが&lt;u&gt;ドキュメント&lt;/u&gt; ument &lt;u&gt;秒&lt;/u&gt;）。新しいドキュメントがリポジトリに追加されると、すぐにインデックスが作成されません。インデックス作成は、検索リクエストがあるまで延期されます。ftsdocsテーブルには、ドキュメントがインデックス付けされている場合はtrue、そうでない場合はfalseである「idxed」フィールドが含まれています。</target>
        </trans-unit>
        <trans-unit id="54570b346f4d608f2bbac12e4181cf27370c513d" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;とそのバリアントへのSQLステートメントテキスト入力では、リテラルは次のテンプレートのいずれかに一致する&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターに&lt;/a&gt;置き換えられます。</target>
        </trans-unit>
        <trans-unit id="2d198fd96a87b68a84840a27e15d7192fd58115f" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;とそのバリアントへのSQLステートメントテキスト入力では、リテラルは次のテンプレートのいずれかに一致する&lt;a href=&quot;../lang_expr#varparam&quot;&gt;パラメーターに&lt;/a&gt;置き換えられます。</target>
        </trans-unit>
        <trans-unit id="0bfef1786d8548ec0f82e3f4f67466b9d9c84839" translate="yes" xml:space="preserve">
          <source>In the TCL test harness, the crash simulation is done in a separate process. The main testing process spawns a child process which runs some SQLite operation and randomly crashes somewhere in the middle of a write operation. A special &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; randomly reorders and corrupts the unsynchronized write operations to simulate the effect of buffered filesystems. After the child dies, the original test process opens and reads the test database and verifies that the changes attempted by the child either completed successfully or else were completely rolled back. The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is used to make sure no database corruption occurs.</source>
          <target state="translated">TCLテストハーネスでは、クラッシュシミュレーションは別のプロセスで行われます。メインのテストプロセスは、SQLite操作を実行する子プロセスを生成し、書き込み操作の途中でランダムにクラッシュします。特別な&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;は、非同期の書き込み操作をランダムに並べ替えて破壊し、バッファリングされたファイルシステムの効果をシミュレートします。子が死亡した後、元のテストプロセスが開いてテストデータベースを読み取り、子が試みた変更が正常に完了したか、完全にロールバックされたかを確認します。&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;プラグマは&lt;/a&gt;必ず何のデータベースの破損が発生しないために使用されます。</target>
        </trans-unit>
        <trans-unit id="2e83d8a255a88980125401cd881c484a48bd6dc6" translate="yes" xml:space="preserve">
          <source>In the TPC-H Q8 query, the setup costs are all negligible, all dependencies are between individual nodes, and there is no ORDER BY, GROUP BY, or DISTINCT clause. So for TPC-H Q8, the graph above is a reasonable representation of what needs to be computed. The general case involves a lot of extra complication, which for clarity is neglected in the remainder of this article.</source>
          <target state="translated">TPC-H Q8 クエリでは、セットアップ・コストはすべて無視できる程度であり、依存関係はすべて個々のノード間であり、ORDER BY、GROUP BY、DISTINCT句はありません。したがって、TPC-H Q8の場合、上のグラフは、計算する必要があることを合理的に表現しています。一般的なケースでは、多くの余分な複雑さを伴いますが、この記事の残りの部分では明確にするために無視しています。</target>
        </trans-unit>
        <trans-unit id="9f3539e13c22fa6c6ec2b58a1ccd7e90a2d77370" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt; WHERE句内。</target>
        </trans-unit>
        <trans-unit id="b6311a2e6a2d0640df13bf33c58d5ba4044c66ce" translate="yes" xml:space="preserve">
          <source>In the Windows OS driver, reacquire a SHARED lock if an attempt to acquire an EXCLUSIVE lock fails. Ticket #2354</source>
          <target state="translated">Windows OSドライバで、EXCLUSIVEロックの取得に失敗した場合にSHAREDロックを再取得するという問題がありました。チケット番号2354</target>
        </trans-unit>
        <trans-unit id="c812acc1f415592dcfc5eeb302d23caa6a39526f" translate="yes" xml:space="preserve">
          <source>In the above paragraph, the term &quot;equal&quot; means equal when values are compared using the rules &lt;a href=&quot;datatype3#comparisons&quot;&gt;specified here&lt;/a&gt;. The following clarifications apply:</source>
          <target state="translated">上記の段落で、「等しい」という用語は、&lt;a href=&quot;datatype3#comparisons&quot;&gt;ここで指定され&lt;/a&gt;たルールを使用して値を比較するときに等しいことを意味します。次の説明が適用されます。</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">上記の中で</target>
        </trans-unit>
        <trans-unit id="441e596237bc1ae031cea29bc5e12b44c88ed81c" translate="yes" xml:space="preserve">
          <source>In the above, &amp;lt;content&amp;gt; is replaced by the name of the content table. By default, &amp;lt;content_rowid&amp;gt; is replaced by the literal text &quot;rowid&quot;. Or, if the &quot;content_rowid&quot; option is set within the CREATE VIRTUAL TABLE statement, by the value of that option. &amp;lt;cols&amp;gt; is replaced by a comma-separated list of the FTS5 table column names. For example:</source>
          <target state="translated">上記の&amp;lt;content&amp;gt;は、コンテンツテーブルの名前に置き換えられます。デフォルトでは、&amp;lt;content_rowid&amp;gt;はリテラルテキスト「rowid」に置き換えられます。または、「content_rowid」オプションがCREATE VIRTUAL TABLEステートメント内でそのオプションの値によって設定されている場合。&amp;lt;cols&amp;gt;は、FTS5テーブルの列名のコンマ区切りのリストに置き換えられます。例えば：</target>
        </trans-unit>
        <trans-unit id="a2464dd3bf1c506de33685f476dfeec6d3c9f83a" translate="yes" xml:space="preserve">
          <source>In the above, the user creates the database schema (a single table - &quot;x1&quot;), and then uses the &quot;.expert&quot; command to analyze a query, in this case &quot;SELECT * FROM x1 WHERE a=? AND b&amp;gt;?&quot;. The shell tool recommends that the user create a new index (index &quot;x1_idx_000123a7&quot;) and outputs the plan that the query would use in &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; format. The user then creates an index with an equivalent schema and runs the analysis on the same query again. This time the shell tool does not recommend any new indexes, and outputs the plan that SQLite will use for the query given the existing indexes.</source>
          <target state="translated">上記では、ユーザーはデータベーススキーマ（単一のテーブル-&quot;x1&quot;）を作成し、次に &quot;.expert&quot;コマンドを使用してクエリを分析します。この場合、 &quot;SELECT * FROM x1 WHERE a =？AND b&amp;gt;？ 」シェルツールは、ユーザーが新しいインデックス（インデックス &quot;x1_idx_000123a7&quot;）を作成し、クエリが&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;形式で使用するプランを出力することを推奨します。次に、ユーザーは同等のスキーマでインデックスを作成し、同じクエリで再度分析を実行します。今回、シェルツールは新しいインデックスを推奨せず、SQLiteが既存のインデックスを指定したクエリに使用する計画を出力します。</target>
        </trans-unit>
        <trans-unit id="94df2ec8cdab4e4a1c3463eb8499a5bac9b92ebf" translate="yes" xml:space="preserve">
          <source>In the call above, pBuf is a pointer to a large, contiguous chunk of memory space that SQLite will use to satisfy all of its memory allocation needs. pBuf might point to a static array or it might be memory obtained from some other application-specific mechanism. szBuf is an integer that is the number of bytes of memory space pointed to by pBuf. mnReq is another integer that is the minimum size of an allocation. Any call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc(N)&lt;/a&gt; where N is less than mnReq will be rounded up to mnReq. mnReq must be a power of two. We shall see later that the mnReq parameter is important in reducing the value of &lt;b&gt;n&lt;/b&gt; and hence the minimum memory size requirement in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;.</source>
          <target state="translated">上記の呼び出しで、pBufは、SQLiteがメモリ割り当てのすべてのニーズを満たすために使用する、大きく連続したメモリ領域のチャンクへのポインタです。 pBufは静的配列を指す場合もあれば、他のアプリケーション固有のメカニズムから取得したメモリである場合もあります。 szBufは、pBufが指すメモリ空間のバイト数である整数です。 mnReqは、割り当ての最小サイズである別の整数です。&lt;a href=&quot;c3ref/free&quot;&gt;N&lt;/a&gt;がmnReqより小さいsqlite3_malloc（N）への呼び出しは、mnReqに切り上げられます。 mnReqは2の累乗でなければなりません。後でmnReqパラメータが&lt;b&gt;n&lt;/b&gt;の値を減らすのに重要であること、したがって&lt;a href=&quot;malloc#nofrag&quot;&gt;Robson証明の&lt;/a&gt;最小メモリサイズ要件がわかることを確認します。</target>
        </trans-unit>
        <trans-unit id="90165ee71034491a4c0d9359bc73082f9488de28" translate="yes" xml:space="preserve">
          <source>In the call above, pMem is a pointer to an &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object that defines the interface to the application-specific memory allocator. The &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object is really just a structure containing pointers to functions to implement the various memory allocation primitives.</source>
          <target state="translated">上記の呼び出しでは、pMemは、アプリケーション固有の&lt;a href=&quot;c3ref/mem_methods&quot;&gt;メモリア&lt;/a&gt;ロケーターへのインターフェイスを定義するsqlite3_mem_methodsオブジェクトへのポインターです。&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methodsの&lt;/a&gt;オブジェクトは、実際に様々なメモリ割り当てプリミティブを実装する関数へのポインタを含むだけの構造です。</target>
        </trans-unit>
        <trans-unit id="890332a4e5fd5b1fbcf7ece72dd3f24eeb42de4e" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, whenever the word &quot;column&quot; is used in the foregoing text, one can substitute &quot;indexed expression&quot; (meaning a copy of the expression that appears in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement) and everything will work the same.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;式&lt;/a&gt;のインデックスの場合、前述のテキストで「列」という単語が使用されている場合は常に、「インデックス付き式」（&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントに表示される式のコピーを意味する）に置き換えることができ、すべてが同じように機能します。</target>
        </trans-unit>
        <trans-unit id="d6023ff2ef6625bf825c5177040f5f9d0c7e6eaa" translate="yes" xml:space="preserve">
          <source>In the case of sqlite3changeset_start_strm(), the xInput callback may be invoked by the sessions module at any point during the lifetime of the iterator. If such an xInput callback returns an error, the iterator enters an error state, whereby all subsequent calls to iterator functions immediately fail with the same error code as returned by xInput.</source>
          <target state="translated">sqlite3changeset_start_strm()の場合、xInputコールバックはイテレータが生きている間、いつでもセッション・モジュールによって呼び出されます。このようなxInputコールバックがエラーを返すと、イテレータはエラー状態になり、それ以降のイテレータ関数の呼び出しはすべてxInputが返したのと同じエラーコードで直ちに失敗します。</target>
        </trans-unit>
        <trans-unit id="2c842ccec3d83bffac0868a71bae98e55882c42d" translate="yes" xml:space="preserve">
          <source>In the cases above, the values returned by the function affects the information stored in the database file. The values of functions in CHECK constraints determines which entries are valid for a table, and functions in the WHERE clause of a partial index or in an index on an expression compute values stored in the index b-tree. If any of these functions later returns a different value, then the database might no longer be well-formed. Hence, to avoid database corruption, only deterministic functions can be used in the contexts above.</source>
          <target state="translated">上記のケースでは、関数によって返される値は、データベース・ファイルに格納された情報に影響を与えます。CHECK制約内の関数の値は、テーブルに対して有効なエントリを決定し、部分インデックスのWHERE句または式のインデックス内の関数は、インデックスb-treeに格納された値を計算します。これらの関数のいずれかが後で異なる値を返した場合、データベースはもはや十分に形成されていないかもしれません。したがって、データベースの破損を避けるために、上記の文脈では決定論的な関数のみを使用することができます。</target>
        </trans-unit>
        <trans-unit id="212f1ca207fd318cb7601421ea08bad1d38b37aa" translate="yes" xml:space="preserve">
          <source>In the command-line shell, use popen() instead of fopen() if the first character of the argument to the &quot;.output&quot; command is &quot;|&quot;.</source>
          <target state="translated">コマンドラインシェルでは、&quot;.output &quot;コマンドの引数の最初の文字が&quot;|&quot;の場合、fopen()の代わりにpopen()を使用します。</target>
        </trans-unit>
        <trans-unit id="bd2d277ff0771ee506fb5065fe7a06ad8e377ea0" translate="yes" xml:space="preserve">
          <source>In the current implementation of SQLite, the SQL parser only works with UTF-8 text. So if you supply UTF-16 text it will be converted. This is just an implementation issue and there is nothing to prevent future versions of SQLite from parsing UTF-16 encoded SQL natively.</source>
          <target state="translated">現在のSQLiteの実装では、SQLパーサはUTF-8テキストでしか動作しません。そのため、UTF-16テキストを指定した場合は変換されます。これは単なる実装上の問題であり、将来のバージョンの SQLite が UTF-16 エンコードされた SQL をネイティブで解析することを妨げるものは何もありません。</target>
        </trans-unit>
        <trans-unit id="2904f602a19479b220a87ade171425cb57484f61" translate="yes" xml:space="preserve">
          <source>In the current implementation, a table is analyzed if and only if all of the following are true:</source>
          <target state="translated">現在の実装では、以下のすべてが真である場合にのみ、テーブルが解析されます。</target>
        </trans-unit>
        <trans-unit id="f2454c76bf66b1405ea30b83fd1ca60a2a98f0ef" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">現在の実装では、&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt;句が原因で競合する行が削除されても、更新フックは呼び出されません。&lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;トランケート最適化&lt;/a&gt;を使用して行が削除されたときにも、更新フックは呼び出されません。この段落で定義されている例外は、SQLiteの将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="fb481751cd63e35f2d57a7f24a37356fd4bf25b0" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">現在の実装では、&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt;句が原因で競合する行が削除されても、更新フックは呼び出されません。&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;トランケート最適化&lt;/a&gt;を使用して行が削除されたときにも、更新フックは呼び出されません。この段落で定義されている例外は、SQLiteの将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="6c3c5dcd56d182703694f79901fe613441a9864b" translate="yes" xml:space="preserve">
          <source>In the current row, the number of times the phrase appears in the column.</source>
          <target state="translated">現在の列では、そのフレーズの出現回数が表示されています。</target>
        </trans-unit>
        <trans-unit id="d3116d32ea608324199d5e0469ef8b030b799865" translate="yes" xml:space="preserve">
          <source>In the diagram at the right, we show that the information that was held in user space is cleared when the lock is released. This used to be literally true for older versions of SQLite. But more recent versions of SQLite keep the user space information in memory in case it might be needed again at the start of the next transaction. It is cheaper to reuse information that is already in local memory than to transfer the information back from the operating system disk cache or to read it off of the disk drive again. Prior to reusing the information in user space, we must first reacquire the shared lock and then we have to check to make sure that no other process modified the database file while we were not holding a lock. There is a counter in the first page of the database that is incremented every time the database file is modified. We can find out if another process has modified the database by checking that counter. If the database was modified, then the user space cache must be cleared and reread. But it is commonly the case that no changes have been made and the user space cache can be reused for a significant performance savings.</source>
          <target state="translated">右の図では、ロックが解除されると、ユーザ空間に保持されていた情報がクリアされることを示しています。これは古いバージョンのSQLiteでは文字通り真実でした。しかし、最近のバージョンのSQLiteでは、次のトランザクションの開始時に再び必要になるかもしれない場合に備えて、ユーザ空間の情報をメモリに保持しています。オペレーティングシステムのディスクキャッシュから情報を転送したり、ディスクドライブから情報を読み出すよりも、ローカルメモリにある情報を再利用する方が安く済みます。ユーザースペースにある情報を再利用する前に、まず共有ロックを再取得し、ロックを保持していない間に他のプロセスがデータベースファイルを変更していないことを確認しなければなりません。データベースの最初のページには、データベースファイルが変更されるたびにインクリメントされるカウンタがあります。このカウンタをチェックすることで、他のプロセスがデータベースを変更したかどうかを知ることができます。データベースが変更された場合は、ユーザースペースキャッシュをクリアして再読込しなければなりません。しかし、一般的には何も変更されていないことが多く、ユーザースペースキャッシュを再利用することで大幅なパフォーマンスの低下を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="bc4afe67e993812e607ae27c7ab087c30151c22e" translate="yes" xml:space="preserve">
          <source>In the diagram, each of the 8 tables in the FROM clause of the query is identified by a large circle with the label of the FROM-clause term: N2, S, L, P, O, C, N1 and R. The arcs in the graph represent the estimated cost of computing each term assuming that the origin of the arc is in an outer loop. For example, the cost of running the S loop as an inner loop to L is 2.30 whereas the cost of running the S loop as an outer loop to L is 9.17.</source>
          <target state="translated">この図では、問い合わせのFROM句の8つのテーブルのそれぞれは、FROM句の項のラベルが付いた大きな円で識別されています。グラフ内の円弧は、円弧の原点が外側のループにあると仮定した場合の各項の計算コストの推定値を表しています。例えば、SループをLへの内ループとして実行するコストは2.30であるのに対し、SループをLへの外ループとして実行するコストは9.17である。</target>
        </trans-unit>
        <trans-unit id="395caf8810d6babac050840aec487ecca9bbc4bd" translate="yes" xml:space="preserve">
          <source>In the event of an operating system or power failure, the various combinations of file-system software and storage hardware available provide varying levels of guarantee as to the integrity of the data written to the file system just before or during the failure. The exact combination of IO operations that SQLite is required to perform in order to safely modify a database file depend on the exact characteristics of the target platform.</source>
          <target state="translated">オペレーティングシステムや電源障害が発生した場合、利用可能なファイルシステムソフトウェアとストレージハードウェアの様々な組み合わせにより、障害発生直前や障害発生中にファイルシステムに書き込まれたデータの整合性を様々なレベルで保証することができます。データベースファイルを安全に修正するために SQLite が実行する必要のある IO 操作の正確な組み合わせは、ターゲットプラットフォームの正確な特性に依存します。</target>
        </trans-unit>
        <trans-unit id="fbf76308006177e994e0ad525f9e6c338bce580b" translate="yes" xml:space="preserve">
          <source>In the example above, all the rows for each partition are grouped together in the final output. This is because the PARTITION BY clause is a prefix of the ORDER BY clause on the overall query. But that does not have to be the case. A partition can be composed of rows scattered about haphazardly within the result set. For example:</source>
          <target state="translated">上の例では、各パーティションのすべての行が最終的な出力でグループ化されています。これは、PARTITION BY句がクエリ全体のORDER BY句の接頭辞になっているからです。しかし、そうである必要はありません。パーティションは、結果セット内に散らばった行で構成することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5cf1e8a43e9d63b712df3d7090fc5c9414ccb7c0" translate="yes" xml:space="preserve">
          <source>In the example above, each triple identifies the location of a token instance by rowid, column number (columns are numbered sequentially starting at 0 from left to right) and position within the column value (the first token in a column value is 0, the second is 1, and so on). Using this index, FTS5 is able to provide timely answers to queries such as &quot;the set of all documents that contain the token 'A'&quot;, or &quot;the set of all documents that contain the sequence 'Y Z'&quot;. The list of instances associated with a single token is called an &quot;instance-list&quot;.</source>
          <target state="translated">上の例では、各トリプルは、rowid、カラム番号(カラムは左から順に0から順に番号が振られている)、カラム値内の位置(カラム値内の最初のトークンは0、2番目のトークンは1、など)によって、トークンインスタンスの位置を特定している。このインデックスを使用することで、FTS5は、「トークン'A'を含むすべての文書の集合」や「シーケンス'Y Z'を含むすべての文書の集合」のようなクエリに対するタイムリーな回答を提供することができる。単一のトークンに関連付けられたインスタンスのリストは、「インスタンスリスト」と呼ばれる。</target>
        </trans-unit>
        <trans-unit id="6670429b3f62749505c4b98851abdba99076dc7b" translate="yes" xml:space="preserve">
          <source>In the example above, if most purchase orders do not have a &quot;parent&quot; purchase order, then most parent_po values will be NULL. That means only a small subset of the rows in the purchaseorder table will be indexed. Hence the index will take up much less space. And changes to the original purchaseorder table will run faster since the po_parent index only needs to be updated for those exceptional rows where parent_po is not NULL. But the index is still useful for querying. In particular, if one wants to know all &quot;children&quot; of a particular purchase order &quot;?1&quot;, the query would be:</source>
          <target state="translated">上記の例では、ほとんどの購入注文に「親」の購入注文がない場合、ほとんどの parent_po 値は NULL になります。これは、購入注文テーブルの行のごく一部がインデックス化されることを意味します。そのため、インデックスが占めるスペースはかなり少なくなります。po_parentインデックスは、parent_poがNULLではない例外的な行のために更新する必要があるだけなので、元の購入オーダーテーブルへの変更はより速く実行されます。しかし、インデックスはクエリを実行するのに便利です。特に、特定の購入注文「?1」のすべての「子」を知りたい場合、クエリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="093d39a0dc19bc985afaed609f6ca65b1771f970" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.header on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.header off&quot; instead. (The &quot;.header off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="translated">上の例では、「.header on」行は、出力の最初の行としてカラムラベルを出力します。これは、結果として出力されるCSVファイルの最初の行にカラムラベルが表示されることを意味します。列ラベルが不要な場合は、「.header off」を設定してください。(「.header off」の設定はデフォルトであり、ヘッダーが以前にオンになっていない場合は省略することができます)。</target>
        </trans-unit>
        <trans-unit id="10cd93c52fe5f9cca786dee67c9404fab91f9de8" translate="yes" xml:space="preserve">
          <source>In the example above, the window frame consists of all rows between the previous row (&quot;1 PRECEDING&quot;) and the following row (&quot;1 FOLLOWING&quot;), inclusive, where rows are sorted according to the ORDER BY clause in the window-defn (in this case &quot;ORDER BY a&quot;). For example, the frame for the row with (a=3) consists of rows (2, 'B', 'two'), (3, 'C', 'three') and (4, 'D', 'one'). The result of group_concat(b, '.') for that row is therefore 'B.C.D'.</source>
          <target state="translated">上の例では、ウィンドウフレームは、前の行(&quot;1 PRECEDING&quot;)と次の行(&quot;1 FOLLOWING&quot;)の間のすべての行で構成されており、その中の行は、ウィンドウ-defnのORDER BY句(この場合は &quot;ORDER BY a&quot;)に従ってソートされます。例えば、(a=3)の行のフレームは、(2,'B','2')、(3,'C','3')、(4,'D','1')の行で構成されています。したがって、その行に対するgroup_concat(b,'.')の結果は、'B.C.D'となります。</target>
        </trans-unit>
        <trans-unit id="b3d6a23d97e4594c0776e73b100f4f0f95f7c245" translate="yes" xml:space="preserve">
          <source>In the example queries above, every row of the table being queried must be loaded off of the disk and examined, even if only a small percentage of the rows end up in the result. This can take a long time on a big table. To speed things up, SQLite can use an index.</source>
          <target state="translated">上記の例のクエリでは、たとえ結果がごく一部の行であっても、クエリされたテーブルのすべての行がディスクからロードされ、検査されなければなりません。これは、大きなテーブルでは長い時間がかかります。これを高速化するために、SQLite ではインデックスを使用することができます。</target>
        </trans-unit>
        <trans-unit id="097fb65fd13aa3cb8c9440796ac79504d1b2d367" translate="yes" xml:space="preserve">
          <source>In the example, instead of a single sort of 7 elements, there are 5 sorts of one-element each and 1 sort of 2 elements for the case of fruit=='Orange'.</source>
          <target state="translated">この例では、果物=='Orange'の場合は、7要素の1ソートではなく、1要素ずつ5ソート、2要素1ソートとなっています。</target>
        </trans-unit>
        <trans-unit id="28b65ff31e772aaf95fd7eecfcefa7c33d5a2c49" translate="yes" xml:space="preserve">
          <source>In the example, the values in the &quot;term&quot; column are all lower case, even though they were inserted into table &quot;ft&quot; in mixed case. This is because an fts4aux table contains the terms as extracted from the document text by the &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. In this case, since table &quot;ft&quot; uses the &lt;a href=&quot;fts3#tokenizer&quot;&gt;simple tokenizer&lt;/a&gt;, this means all terms have been folded to lower case. Also, there is (for example) no row with column &quot;term&quot; set to &quot;apple&quot; and column &quot;col&quot; set to 1. Since there are no instances of the term &quot;apple&quot; in column 1, no row is present in the fts4aux table.</source>
          <target state="translated">この例では、「term」列の値は、大文字と小文字が混在するテーブル「ft」に挿入されていても、すべて小文字です。で、文書テキストから抽出されたようfts4aux表は用語が含まれているためです&lt;a href=&quot;fts3#tokenizer&quot;&gt;トークナイザ&lt;/a&gt;。この場合、テーブル &quot;ft&quot;は&lt;a href=&quot;fts3#tokenizer&quot;&gt;単純なトークナイザを&lt;/a&gt;使用しているため、すべての用語が小文字に変換されています。また、（たとえば）列「term」が「apple」に設定され、列「col」が1に設定されている行はありません。列1に「apple」という用語のインスタンスがないため、行に存在しません。 fts4auxテーブル。</target>
        </trans-unit>
        <trans-unit id="4d08492de7be0204d6bca6b75942d78b6a5e659c" translate="yes" xml:space="preserve">
          <source>In the examples above,</source>
          <target state="translated">上記の例では</target>
        </trans-unit>
        <trans-unit id="de880219c17c8178404452e7a6a65a0e25a5ab03" translate="yes" xml:space="preserve">
          <source>In the examples above, the APPCOST table would be interrogated to find the edit distance coefficients. It is the presence of the &quot;edit_cost_table=&quot; parameter to the spellfix1 module name that causes editdist3() to be used in place of the built-in edit distance function. If APPCOST is an empty string, then the built-in Wagner edit-distance function is used.</source>
          <target state="translated">上記の例では、編集距離係数を見つけるために APPCOST テーブルを照会しています。spellfix1 モジュール名に &quot;edit_cost_table=&quot; パラメータがあると、組み込みの編集距離関数の代わりに editdist3()が使用されます。APPCOST が空文字列の場合は、組み込みの Wagner 編集距離関数が使用されます。</target>
        </trans-unit>
        <trans-unit id="e3adc83f3d79277fad8353d570dcfc825d479731" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK制約の&lt;/a&gt;式で。</target>
        </trans-unit>
        <trans-unit id="7ff8ef765e12ede160f30458a862b4edd37cec09" translate="yes" xml:space="preserve">
          <source>In the extreme case where the columns being indexed cover all columns of the PRIMARY KEY, the index will consist of only the columns being indexed. The ex25acde example above demonstrates this. Each entry in the ex25acde index consists of only the columns a, c, d, and e, in that order.</source>
          <target state="translated">インデックス化される列が PRIMARY KEY のすべての列をカバーしている極端なケースでは、インデックスはインデックス化される列のみで構成されます。上のex25acdeの例がこれを示しています。ex25acde インデックスの各エントリは、a,c,d,e の順に列 a,c,d,e だけで構成されています。</target>
        </trans-unit>
        <trans-unit id="f9d2f7bcd7e33c3c61f03684e92a0123ee2c50c1" translate="yes" xml:space="preserve">
          <source>In the first case, when the table does not previously exist, the table is automatically created and the content of the first row of the input CSV file is used to determine the name of all the columns in the table. In other words, if the table does not previously exist, the first row of the CSV file is interpreted to be column names and the actual data starts on the second row of the CSV file.</source>
          <target state="translated">最初のケースでは、テーブルが事前に存在しない場合は、自動的にテーブルが作成され、入力されたCSVファイルの1行目の内容から、テーブル内のすべての列の名前が決定されます。つまり、テーブルが事前に存在しない場合は、CSVファイルの1行目の内容がカラム名と解釈され、実際のデータはCSVファイルの2行目から開始されます。</target>
        </trans-unit>
        <trans-unit id="8cfb2ab353eeb9931ea61c166eef50db11918f37" translate="yes" xml:space="preserve">
          <source>In the following example, the window frame for each row consists of all rows from the current row to the end of the set, where rows are sorted according to &quot;ORDER BY a&quot;.</source>
          <target state="translated">次の例では、各行のウィンドウフレームは、現在の行からセットの最後までのすべての行で構成されており、行は「ORDER BY a」に従ってソートされています。</target>
        </trans-unit>
        <trans-unit id="ad3b432372161232b364559d85e3c83dbfa80ec8" translate="yes" xml:space="preserve">
          <source>In the following query, the optimizer is free to reorder the tables of FROM clause anyway it sees fit:</source>
          <target state="translated">次のクエリでは、オプティマイザは自由にFROM句のテーブルを並べ替えることができます。</target>
        </trans-unit>
        <trans-unit id="213dce290e5c56de530174ae284660516d8c6333" translate="yes" xml:space="preserve">
          <source>In the future, this option may also disable other floating point functionality, for example the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double()&lt;/a&gt; and &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double()&lt;/a&gt; API functions.</source>
          <target state="translated">将来、このオプションは他の浮動小数点機能、たとえば&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double（）&lt;/a&gt;、&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double（）&lt;/a&gt;、&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double（）&lt;/a&gt;および&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double（）&lt;/a&gt; API関数も無効にする可能性があります。</target>
        </trans-unit>
        <trans-unit id="dfaedc6be2b7553cc537d3ce90c362a4be2c9a84" translate="yes" xml:space="preserve">
          <source>In the latter query, the query plan must be &lt;a href=&quot;#option2&quot;&gt;option 2&lt;/a&gt;. Note that you must use the keyword &quot;CROSS&quot; in order to disable the table reordering optimization; INNER JOIN, NATURAL JOIN, JOIN, and other similar combinations work just like a comma join in that the optimizer is free to reorder tables as it sees fit. (Table reordering is also disabled on an outer join, but that is because outer joins are not associative or commutative. Reordering tables in OUTER JOIN changes the result.)</source>
          <target state="translated">後者のクエリでは、クエリプランは&lt;a href=&quot;#option2&quot;&gt;オプション2である&lt;/a&gt;必要があります。テーブルの並べ替えの最適化を無効にするには、キーワード「CROSS」を使用する必要があることに注意してください。INNER JOIN、NATURAL JOIN、JOIN、およびその他の同様の組み合わせは、コンマ結合と同じように機能し、オプティマイザーはテーブルを適切に並べ替えることができます。（外部ジョインではテーブルの並べ替えも無効になりますが、これは外部ジョインが結合的または可換的でないためです。OUTERJOINでテーブルを並べ替えると結果が変わります。）</target>
        </trans-unit>
        <trans-unit id="db1ceb5581cb83e63561f68248a7b5044a5f4d90" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">従来のインターフェースでは、戻り値は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSEの&lt;/a&gt;いずれかになります。 「v2」インターフェースを使用すると、他の&lt;a href=&quot;rescode&quot;&gt;結果コード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;も返される場合があります。</target>
        </trans-unit>
        <trans-unit id="c4f1e2e6a1b6e2882af269cc303fc56c8348c472" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">従来のインターフェースでは、戻り値は&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;、&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;、&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;、&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;、または&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSEの&lt;/a&gt;いずれかになります。 「v2」インターフェースを使用すると、他の&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;も返される場合があります。</target>
        </trans-unit>
        <trans-unit id="3e24ef81342a9cacce2edb83f3edc5fc97054dd2" translate="yes" xml:space="preserve">
          <source>In the previous query the fruit='Peach' constraint narrowed the result down to a single row. But the same technique works even if multiple rows are obtained. Suppose we looked up the price of Oranges instead of Peaches:</source>
          <target state="translated">前のクエリでは、fruit='Peach'制約により、結果は1行に絞られました。しかし、複数の行が得られた場合でも同じ手法が有効です。例えば、桃ではなくオレンジの価格を調べたとします。</target>
        </trans-unit>
        <trans-unit id="33c558ed5ce36b119e16ee3e9d824eb5021f92cb" translate="yes" xml:space="preserve">
          <source>In the previous sections, we have seen how moving from a key/value store implemented as a ZIP archive to a simple SQLite database with just three tables can add significant capabilities to an application file format. We could continue to enhance the schema with new tables, with indexes added for performance, with triggers and views for programming convenience, and constraints to enforce consistency of content even in the face of programming errors. Further enhancement ideas include:</source>
          <target state="translated">前のセクションでは、ZIP アーカイブとして実装されたキー/値ストアから、わずか 3 つのテーブルを持つシンプルな SQLite データベースに移行することで、アプリケーションのファイル形式に重要な機能を追加できることを見てきました。新しいテーブル、パフォーマンスのために追加されたインデックス、プログラミングの利便性のためのトリガーとビュー、プログラミングエラーに直面してもコンテンツの一貫性を強制するための制約など、スキーマの強化を続けていくことができます。さらなる強化案としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="6567a872214501806e02589f934b8c11a8b0e4f5" translate="yes" xml:space="preserve">
          <source>In the previous, the &quot;type NOT IN ('object','array')&quot; term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:</source>
          <target state="translated">先ほどの例では、WHERE句の &quot;type NOT IN ('object','array')&quot;の項はコンテナを抑制し、リーフ要素のみを通しています。この方法でも同じ効果が得られます。</target>
        </trans-unit>
        <trans-unit id="1dd63ff23c59a1e0a739d0a06a35ed29c44ad2c6" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indices the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and then use that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="translated">上記のクエリで、t1とt2の両方に約N行がある場合、インデックスがないと、クエリはO（N * N）時間を必要とします。一方、テーブルt2にインデックスを作成するにはO（NlogN）時間を要し、そのインデックスを使用してクエリを評価するにはさらにO（NlogN）時間必要です。&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;情報がない場合、SQLiteはNが100万であると推測しているため、自動インデックスを構築する方が安価なアプローチになると考えています。</target>
        </trans-unit>
        <trans-unit id="d42fa24dde8794f21d6a489ff49ead792c8bc812" translate="yes" xml:space="preserve">
          <source>In the query above, one would presumably bind the binary BLOB description of the precise boundary of the 12th district to the &quot;:boundary&quot; parameter.</source>
          <target state="translated">上記のクエリでは、12区の正確な境界を表すバイナリBLOBの記述を&quot;:boundary &quot;パラメータにバインドします。</target>
        </trans-unit>
        <trans-unit id="5dbfd2d21d7bf5385c8b5fed28f3d0558f663390" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;PARTITION BY c&quot; clause breaks the result set up into three partitions. The first partition has three rows with c=='one'. The second partition has two rows with c=='three' and the third partition has two rows with c=='two'.</source>
          <target state="translated">上のクエリでは、&quot;PARTITION BY c &quot;句は、結果セットを3つのパーティションに分割します。最初のパーティションはc=='1'で3行です。2番目のパーティションはc=='3'で2行、3番目のパーティションはc=='2'で2行です。</target>
        </trans-unit>
        <trans-unit id="ff23670a4dd151a2afe2511d238ffe5c9f59a6d2" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;a&quot; column is part of the GROUP BY clause and so each row of the output contains one of the distinct values for &quot;a&quot;. The &quot;c&quot; column is contained within the &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum()&lt;/a&gt; aggregate function and so that output column is the sum of all &quot;c&quot; values in rows that have the same value for &quot;a&quot;. But what is the result of the bare column &quot;b&quot;? The answer is that the &quot;b&quot; result will be the value for &quot;b&quot; in one of the input rows that form the aggregate. The problem is that you usually do not know which input row is used to compute &quot;b&quot;, and so in many cases the value for &quot;b&quot; is undefined.</source>
          <target state="translated">上記のクエリでは、「a」列はGROUP BY句の一部であるため、出力の各行には「a」の個別の値の1つが含まれています。「c」列は&lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum（）&lt;/a&gt;集約関数内に含まれているため、出力列は「a」に対して同じ値を持つ行のすべての「c」値の合計になります。しかし、裸の列「b」の結果は何ですか？その答えは、「b」の結果は、集計を形成する入力行の1つにおける「b」の値になるということです。問題は、通常、「b」の計算にどの入力行が使用されているかわからないため、多くの場合、「b」の値は未定義です。</target>
        </trans-unit>
        <trans-unit id="cd7c1539a48900d085cdab5fe3ab086624874b10" translate="yes" xml:space="preserve">
          <source>In the query above, the subquery &quot;SELECT b FROM ex2&quot; is evaluated and its results are stored in a temporary table (actually a temporary index) that allows one to determine whether or not a value ex2.b exists using a simple binary search. Once this table is constructed, the outer query is run and for each prospective result row a check is made to see if ex1.a is contained within the temporary table. The row is output only if the check is true.</source>
          <target state="translated">上記のクエリでは、サブクエリ &quot;SELECT b FROM ex2 &quot;が評価され、その結果が一時テーブル(実際には一時インデックス)に格納され、単純なバイナリ検索を使用してex2.bの値が存在するかどうかを判断することができます。このテーブルが構築されると、外部クエリが実行され、各結果の候補行に対して、ex1.aが一時テーブルに含まれているかどうかのチェックが行われます。チェックが真の場合にのみ、行が出力されます。</target>
        </trans-unit>
        <trans-unit id="e4290c818e5599eff7616300b06206a049026a55" translate="yes" xml:space="preserve">
          <source>In the query above, the values for the first_name and last_name columns will correspond to the row that satisfied the max(salary) condition.</source>
          <target state="translated">上記のクエリでは、first_name列とlast_name列の値は、max(salary)条件を満たした行に対応します。</target>
        </trans-unit>
        <trans-unit id="812c0304c15e5adbac36486ee814e9ec1db44d78" translate="yes" xml:space="preserve">
          <source>In the revised query, the subquery implemented by a co-routine computes the five most recent values for &quot;a&quot;. Those five values are passed from the co-routine up into the outer query where the &quot;expensive_function()&quot; is invoked on only the specific rows that the application cares about.</source>
          <target state="translated">修正されたクエリでは、サブルーチンによって実装された副問い合わせが &quot;a &quot;の最新の5つの値を計算します。これら5つの値はサブルーチンから外部クエリに渡され、アプリケーションが気にする特定の行のみに&quot; expensive_function()&quot;が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5464a60c31d2aba9c62ea2f61ec84b78e0768c87" translate="yes" xml:space="preserve">
          <source>In the second example, the expression in the DO UPDATE clause is of the form &quot;excluded.phonenumber&quot;. The &quot;excluded.&quot; prefix causes the &quot;phonenumber&quot; to refer to the value for phonenumber that would have been inserted had there been no conflict. Hence, the effect of the upsert is to insert a phonenumber of Alice if none exists, or to overwrite any prior phonenumber for Alice with the new one.</source>
          <target state="translated">2番目の例では、DO UPDATE句の式は &quot;excluded.phonenumber &quot;という形式である。接頭辞 &quot;excluded.&quot;は、&quot;phonenumber &quot;が、競合がなければ挿入されていたであろうphonenumberの値を参照していることを意味する。したがって、アップサートの効果は、アリスの電話番号が存在しない場合にアリスの電話番号を挿入するか、 アリスの以前の電話番号を新しい電話番号で上書きすることである。</target>
        </trans-unit>
        <trans-unit id="0d5709c51541d0085c2cbbc496ec178e66f3f72e" translate="yes" xml:space="preserve">
          <source>In the sequence on the left, the second insert will fail. In this case, the strings '0' and '0.0' are treated as numbers since they are being inserted into a numeric column but 0==0.0 which violates the uniqueness constraint. However, the second insert in the right-hand sequence works. In this case, the constants 0 and 0.0 are treated a strings which means that they are distinct.</source>
          <target state="translated">左のシーケンスでは、2回目の挿入に失敗します。この場合、文字列 '0' と '0.0' は数値列に挿入されているので数値として扱われますが、0==0.0 は一意性制約に違反しています。しかし、右手の列の2番目の挿入は動作します。この場合、定数0と0.0は文字列として扱われます。</target>
        </trans-unit>
        <trans-unit id="a547afdf67cd8d948e7c4160e0e5b6f6d4b49400" translate="yes" xml:space="preserve">
          <source>In the shell, &lt;b&gt;sqlite_interrupt()&lt;/b&gt; is invoked when the user presses Control-C</source>
          <target state="translated">シェルでは、ユーザーがControl-Cを押すと&lt;b&gt;sqlite_interrupt（）&lt;/b&gt;が呼び出されます</target>
        </trans-unit>
        <trans-unit id="8d983faa26111b1d1fcd83dfccc76792d6f87417" translate="yes" xml:space="preserve">
          <source>In the spellfix1 algorithm, cFrom is the text as the user entered it and cTo is the correctly spelled text as it exists in the database. The goal of the editdist3 algorithm is to determine how close the user-entered text is to the dictionary text.</source>
          <target state="translated">spellfix1アルゴリズムでは、cFromはユーザーが入力したテキストであり、cToはデータベースに存在する正しくスペルされたテキストです。editdist3アルゴリズムの目的は、ユーザーが入力したテキストが辞書のテキストにどれだけ近いかを判断することです。</target>
        </trans-unit>
        <trans-unit id="f33fd6db9521ba57d781c7a6cc1cb461b4a1e385" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, now print the version number on initial startup.</source>
          <target state="translated">sqliteシェルで、初期起動時にバージョン番号を表示するようにしました。</target>
        </trans-unit>
        <trans-unit id="567ed9c7de12cfc6ba8542459479acb37712e779" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, print the &quot;Database opened READ ONLY&quot; message to stderr instead of stdout.</source>
          <target state="translated">sqliteシェルでは、&quot;Database opened READ ONLY &quot;メッセージをstdoutの代わりにstderrに出力します。</target>
        </trans-unit>
        <trans-unit id="04b0bd3687019af0690c1810844c9c6e7505bacb" translate="yes" xml:space="preserve">
          <source>In the statement above, the FTS3 cursor pointer generated by the MATCH operator is send into the carray() table-valued function instead of its intended recipient snippet(). The carray() function treats the pointer as a pointer to an array of integers and returns each integer one by one, thus leaking the content of the FTS3 cursor object. Since the FTS3 cursor object contains pointers to other objects, the statement above would be a pointer leak.</source>
          <target state="translated">上の文では、MATCH演算子によって生成されたFTS3カーソルポインタは、意図された受信者であるsnippet()の代わりにcarray()テーブル値関数に送られています。carray()関数はポインタを整数の配列へのポインタとして扱い、各整数を1つずつ返すので、FTS3カーソルオブジェクトの内容が漏れます。FTS3 カーソルオブジェクトには他のオブジェクトへのポインタが含まれているので、上の文はポインタの漏洩となる。</target>
        </trans-unit>
        <trans-unit id="e5c24d1846d01f843a98c707910ed22a0e9486cc" translate="yes" xml:space="preserve">
          <source>In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier. The values of these parameters (also called &quot;host parameter names&quot; or &quot;SQL parameters&quot;) can be set using the sqlite3_bind_*() routines defined here.</source>
          <target state="translated">上記のテンプレートでは、NNNは整数リテラルを表し、VVVVは英数字の識別子を表します。これらのパラメータ(&quot;ホストパラメータ名 &quot;または &quot;SQLパラメータ &quot;とも呼ばれます)の値は、ここで定義されているsqlite3_bind_*()ルーチンを使って設定することができます。</target>
        </trans-unit>
        <trans-unit id="dee8f982211055f9a9e8d1a438d7f794e0810555" translate="yes" xml:space="preserve">
          <source>In the underlying &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt;, each rowid is stored as a &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt;. That means that small non-negative rowid values take up less disk space than large or negative rowid values.</source>
          <target state="translated">基礎となる&lt;a href=&quot;fileformat2&quot;&gt;ファイル形式では&lt;/a&gt;、各ROWIDは&lt;a href=&quot;fileformat2#varint&quot;&gt;可変長整数&lt;/a&gt;として格納されます。つまり、負でない小さなROWID値は、大きなまたは負のROWID値よりもディスク容量を消費しません。</target>
        </trans-unit>
        <trans-unit id="147d02b1e1e949a788ff444f3cb5e754276ba6d2" translate="yes" xml:space="preserve">
          <source>In this case the aConstraint[].op value is the same as the value returned by &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; for FUNCTION.</source>
          <target state="translated">この場合、aConstraint []。op値は、FUNCTIONの&lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction（）&lt;/a&gt;によって返される値と同じです。</target>
        </trans-unit>
        <trans-unit id="b6bf8cbfac9c457904e9c2859da73ee4a95d3f0d" translate="yes" xml:space="preserve">
          <source>In this case using the temporary b-tree can be avoided by creating an index on t2(c), as follows:</source>
          <target state="translated">この場合、以下のようにt2(c)上にインデックスを作成することで、一時的なb-treeの使用を避けることができます。</target>
        </trans-unit>
        <trans-unit id="a530fdc0efceb4d3e07dfc220358b90fa2145a02" translate="yes" xml:space="preserve">
          <source>In this case, SQLite still does a single binary search to find the first entry of the index where fruit='Orange'. Then it extracts the rowid from the index and uses that rowid to lookup the original table entry via binary search and output the price from the original table. But instead of quitting, the database engine then advances to the next row of index to repeat the process for next fruit='Orange' entry. Advancing to the next row of an index (or table) is much less costly than doing a binary search since the next row is often located on the same database page as the current row. In fact, the cost of advancing to the next row is so cheap in comparison to a binary search that we usually ignore it. So our estimate for the total cost of this query is 3 binary searches. If the number of rows of output is K and the number of rows in the table is N, then in general the cost of doing the query is proportional to (K+1)*logN.</source>
          <target state="translated">この場合でも、SQLite は単一のバイナリ検索を行い、fruit='Orange' のインデックスの最初のエントリを見つけます。そして、インデックスから rowid を抽出し、その rowid を使用してバイナリ検索で元のテーブルエントリを検索し、元のテーブルから価格を出力します。しかし、データベースエンジンは、終了する代わりに、次の fruit='Orange' エントリのために処理を繰り返すために、インデックスの次の行に進みます。インデックス(またはテーブル)の次の行に進むことは、バイナリ検索を行うよりもはるかにコストがかかりません。実際、次の行に進むコストはバイナリ検索に比べて非常に安いので、通常は無視しています。したがって、このクエリの総コストの見積もりは3回のバイナリ検索です。出力の行数をK、テーブルの行数をNとすると、一般的にこのクエリを行うコストは(K+1)*logNに比例します。</target>
        </trans-unit>
        <trans-unit id="419a046b4e9791c3dfbe6ecdc597fd0e975a6969" translate="yes" xml:space="preserve">
          <source>In this chart, an SQL statement (&quot;SELECT v FROM kv WHERE k=?1&quot;) is prepared once. Then for each blob, the blob key value is bound to the ?1 parameter and the statement is evaluated to extract the blob content.</source>
          <target state="translated">この図では、SQL文(&quot;SELECT v FROM kv WHERE k=?1&quot;)を一度用意します。そして、各ブロブについて、ブロブ・キーの値を?1パラメータにバインドし、文を評価してブロブの内容を抽出します。</target>
        </trans-unit>
        <trans-unit id="67f262080695617f0fd577e77df041ccaf828f11" translate="yes" xml:space="preserve">
          <source>In this example, the content of the docs.body field for the entry where docs.name is &quot;report-15&quot; will be sent to the editor. After the editor returns, the result will be written back into the docs.body field.</source>
          <target state="translated">この例では、docs.nameが &quot;report-15 &quot;のエントリのdocs.bodyフィールドの内容がエディタに送られます。エディタが戻ってきた後、結果はdocs.bodyフィールドに書き戻されます。</target>
        </trans-unit>
        <trans-unit id="3455933a8fde6f3fc95c8e0f500aee581e4e0da2" translate="yes" xml:space="preserve">
          <source>In this example, the demo_data.boundary field is intended to hold some kind of binary representation of the precise boundaries of the object. The R*Tree index only holds an axis-aligned rectangular boundary for the object. The R*Tree boundary is just an approximation of the true object boundary. So what typically happens is that the R*Tree index is used to narrow a search down to a list of candidate objects and then more detailed and expensive computations are done on each candidate to find if the candidate truly meets the search criteria.</source>
          <target state="translated">この例では、demo_data.boundary フィールドは、オブジェクトの正確な境界のバイナリ表現を保持することを目的としています。R*Tree インデックスは、オブジェクトの軸に沿った長方形の境界のみを保持します。R*Tree の境界は、真のオブジェクトの境界の近似値にすぎません。そのため、一般的には、R*Tree インデックスを使用して、候補となるオブジェクトのリストに絞って検索を行い、その候補が本当に検索条件を満たしているかどうかを見つけるために、各候補に対してより詳細で高価な計算を行います。</target>
        </trans-unit>
        <trans-unit id="0eba84e3861d469d7f133f2d07dd6079cc3e76b6" translate="yes" xml:space="preserve">
          <source>In this example, the rowids are not consecutive but they are ordered. SQLite usually creates rowids beginning with one and increasing by one with each added row. But if rows are deleted, gaps can appear in the sequence. And the application can control the rowid assigned if desired, so that rows are not necessarily inserted at the bottom. But regardless of what happens, the rowids are always unique and in strictly ascending order.</source>
          <target state="translated">この例では、行番号は連続していませんが、順番に並んでいます。SQLiteでは通常、行番号は1から始まり、行が追加されるごとに1ずつ増えていきます。しかし、行が削除された場合には、行の並びに空白が生じる可能性があります。また、アプリケーションは必要に応じて割り当てられた行IDを制御することができるので、行が必ずしも一番下に挿入されるわけではありません。しかし、何が起こったかに関係なく、行IDは常に一意で、厳密に昇順になります。</target>
        </trans-unit>
        <trans-unit id="5350836f804099dba5657839c67d9e6572dea27d" translate="yes" xml:space="preserve">
          <source>In this example, the t2 table is used in a subquery to translate values of the t1.b column. If each table contains N rows, SQLite expects that the subquery will run N times, and hence it will believe it is faster to construct an automatic, transient index on t2 first and then use that index to satisfy the N instances of the subquery.</source>
          <target state="translated">この例では、t1.b列の値を変換する副問い合わせでt2テーブルが使用されています。各テーブルがN行を含む場合、SQLiteは副問い合わせがN回実行されることを想定しているため、最初にt2に自動で過渡的なインデックスを構築してから、そのインデックスを使用して副問い合わせのN個のインスタンスを満たす方が速いと考えています。</target>
        </trans-unit>
        <trans-unit id="c42a9794244d33827402d87bbb30dbcaf8693beb" translate="yes" xml:space="preserve">
          <source>In this last example, the phonebook2 entry is only updated if the validDate for the newly inserted value is newer than the entry already in the table. If the table already contains an entry with the same name and a current validDate, then the WHERE clause causes the DO UPDATE to become a no-op.</source>
          <target state="translated">この最後の例では、新しく挿入された値のvalidDateが既にテーブルにあるエントリよりも新しい場合にのみ、電話帳2のエントリが更新されます。テーブルに同じ名前で現在のvalidDateを持つエントリが既に含まれている場合、WHERE句によってDO UPDATEが実行されなくなります。</target>
        </trans-unit>
        <trans-unit id="25dff0fca0922d5e6626c7a322eba86698c2596d" translate="yes" xml:space="preserve">
          <source>In this latter table, there is only a single B-Tree which uses the &quot;word&quot; column as its key and the &quot;cnt&quot; column as its data. (Technicality: the low-level implementation actually stores both &quot;word&quot; and &quot;cnt&quot; in the &quot;key&quot; area of the B-Tree. But unless you are looking at the low-level byte encoding of the database file, that fact is unimportant.) Because there is only a single B-Tree, the text of the &quot;word&quot; column is only stored once in the database. Furthermore, querying the &quot;cnt&quot; value for a specific &quot;word&quot; only involves a single binary search into the main B-Tree, since the &quot;cnt&quot; value can be retrieved directly from the record found by that first search and without the need to do a second binary search on the rowid.</source>
          <target state="translated">この後者のテーブルでは、&quot;word &quot;列をキーとし、&quot;cnt &quot;列をデータとする単一のB-Treeだけが存在します(技術的な問題:低レベルの実装では、実際には &quot;word &quot;と &quot;cnt &quot;の両方を &quot;キー &quot;領域に格納します)。(技術的な問題:低レベルの実装では、実際には &quot;word &quot;と &quot;cnt &quot;の両方をB-Treeの &quot;key &quot;エリアに格納しています。しかし、データベースファイルの低レベルのバイトエンコーディングを見ていない限り、この事実は重要ではありません)。B-Treeは1つしかないので、&quot;word &quot;列のテキストはデータベースに1回しか格納されません。さらに、特定の &quot;word &quot;に対する &quot;cnt &quot;値の問い合わせは、メインのB-Treeへの1回のバイナリ検索だけで済む。</target>
        </trans-unit>
        <trans-unit id="27f1607d8d73cecfa7aadf0af1217d0ee5b1b3de" translate="yes" xml:space="preserve">
          <source>In this query, the &quot;xaxis&quot; and &quot;yaxis&quot; CTEs define the grid of points for which the Mandelbrot Set will be approximated. Each row in the &quot;m(iter,cx,cy,x,y)&quot; CTE means that after &quot;iter&quot; iterations, the Mandelbrot iteration starting at cx,cy has reached point x,y. The number of iterations in this example is limited to 28 (which severely limits the resolution of the computation, but is sufficient for low-resolution ASCII-art output). The &quot;m2(iter,cx,cy)&quot; CTE holds the maximum number of iterations reached when starting at point cx,cy. Finally, each row in the &quot;a(t)&quot; CTE holds a string which is a single line of the output ASCII-art. The SELECT statement at the end just queries the &quot;a&quot; CTE to retrieve all lines of ASCII-art, one by one.</source>
          <target state="translated">このクエリでは、&quot;xaxis &quot;および &quot;yaxis&quot; CTEは、マンデルブロー集合が近似される点のグリッドを定義します。m(iter,cx,cy,x,y)&quot; CTEの各行は、&quot;iter &quot;反復の後、cx,cyから始まるマンデルブロ反復が点x,yに到達したことを意味します。この例の反復回数は 28 回に制限されています (これは計算の解像度を著しく制限していますが,低解像度の ASCII アート出力には十分です)。m2(iter,cx,cy)&quot; CTE は、点 cx,cy から開始したときに到達した最大反復回数を保持します。最後に、&quot;a(t)&quot; CTEの各行は、出力されたASCIIアートの1行の文字列を保持する。最後のSELECT文は、ASCIIアートの全行を1行ずつ取得するために &quot;a&quot; CTEに問い合わせを行うだけです。</target>
        </trans-unit>
        <trans-unit id="e3c6ef43db25cfa53ed4da6f4cdaac9eb93f9ff7" translate="yes" xml:space="preserve">
          <source>In this schema, instead of each slide having a page number that determines its order within the presentation, each slide has a unique integer identifier that is unrelated to where it occurs in sequence. The order of slides in the presentation is determined by a list of slideIds, stored as a text string in the MANIFEST column of the VERSION table. Since multiple entries are allowed in the VERSION table, that means that multiple presentations can be stored in the same document.</source>
          <target state="translated">このスキーマでは、各スライドがプレゼンテーション内での順序を決定するページ番号を持つ代わりに、各スライドは、順序のどこで発生するかとは関係のない一意の整数の識別子を持ちます。プレゼンテーション内のスライドの順序は、VERSION テーブルの MANIFEST 列にテキスト文字列として格納された slideIds のリストによって決定されます。VERSION テーブルでは複数のエントリが許可されているので、同じドキュメントに複数のプレゼンテーションを格納することができます。</target>
        </trans-unit>
        <trans-unit id="0941893928b48e6ed8f71fafe5691ea7ff76077a" translate="yes" xml:space="preserve">
          <source>In this system, each entry in the song table is required to map to an entry in the album table with the same combination of artist and album.</source>
          <target state="translated">このシステムでは、曲表の各エントリは、アーティストとアルバムの組み合わせが同じであるアルバム表のエントリにマッピングする必要があります。</target>
        </trans-unit>
        <trans-unit id="e2304a60e4555367ae83803d8a81dcbbc6bac3fc" translate="yes" xml:space="preserve">
          <source>In this way the new pointer-passing interface seems to solve all of the security problems associated with passing pointer values from one extension to another in SQLite.</source>
          <target state="translated">このようにして、新しいポインタ渡しインターフェースは、SQLite のある拡張子から別の拡張子へのポインタ値の渡しに関連するセキュリティ上の問題をすべて解決しているように見えます。</target>
        </trans-unit>
        <trans-unit id="5b4cc2bd1f16fd79626e9a2d355ec8140a8334dd" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">4番目の引数を持つこれらのルーチンでは、その値はパラメーターのバイト数です。明確にするために：値は&lt;u&gt;バイト&lt;/u&gt;数です&lt;u&gt;&lt;/u&gt;値ではなく、文字数。 sqlite3_bind_text（）またはsqlite3_bind_text16（）の4番目のパラメーターが負の場合、文字列の長さは最初のゼロターミネーターまでのバイト数になります。 sqlite3_bind_blob（）の4番目のパラメーターが負の場合、動作は未定義です。負でない4番目のパラメーターがsqlite3_bind_text（）またはsqlite3_bind_text16（）またはsqlite3_bind_text64（）に提供される場合、そのパラメーターは、文字列がNULで終了していると想定してNULターミネーターが発生するバイトオフセットでなければなりません。 4番目のパラメーターの値より小さいバイトオフセットでNUL文字が発生した場合、結果の文字列値には埋め込みNULが含まれます。 NULが埋め込まれた文字列を含む式の結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="e5828032be03f722c81b6852fba96bca0f86ff7f" translate="yes" xml:space="preserve">
          <source>In truncate journal mode, the transaction is committed by truncating the journal file to zero length rather than deleting the journal file (as in DELETE mode) or by zeroing the header (as in PERSIST mode). TRUNCATE mode shares the advantage of PERSIST mode that the directory that contains the journal file and database does not need to be updated. Hence truncating a file is often faster than deleting it. TRUNCATE has the additional advantage that it is not followed by a system call (ex: fsync()) to synchronize the change to disk. It might be safer if it did. But on many modern filesystems, a truncate is an atomic and synchronous operation and so we think that TRUNCATE will usually be safe in the face of power failures. If you are uncertain about whether or not TRUNCATE will be synchronous and atomic on your filesystem and it is important to you that your database survive a power loss or operating system crash that occurs during the truncation operation, then you might consider using a different journaling mode.</source>
          <target state="translated">TRUNCATEジャーナルモードでは、トランザクションは、ジャーナルファイルを削除するのではなく(DELETEモードのように)、ヘッダーをゼロにする(PERSISTモードのように)、ジャーナルファイルをゼロ長に切り詰めることによってコミットされます。TRUNCATEモードは、ジャーナルファイルとデータベースを含むディレクトリを更新する必要がないというPERSISTモードの利点を共有しています。そのため、ファイルを削除するよりも、ファイルを切り詰める方が高速であることが多いです。TRUNCATEには、変更をディスクに同期させるためのシステムコール(例:fsync()のような)が後に続かないという追加の利点があります。その方が安全かもしれません。しかし、多くの最新のファイルシステムでは、TRUNCATE はアトミックで同期的な操作なので、 TRUNCATE は通常、停電に直面しても安全だと考えています。ファイルシステム上でTRUNCATEが同期的でアトミックな操作であるかどうかが不明で、TRUNCATE操作中に発生した停電やオペレーティングシステムのクラッシュにデータベースが耐えられるかどうかが重要な場合は、別のジャーナリングモードを使用することを検討するかもしれません。</target>
        </trans-unit>
        <trans-unit id="0ad1bfd687f56543c8ea5ff79723971d89b554aa" translate="yes" xml:space="preserve">
          <source>In version 3.5.9 the query above would return a single column named &quot;t1.a&quot;. In version 3.6.0 the column name is just &quot;a&quot;.</source>
          <target state="translated">バージョン3.5.9では、上記のクエリは &quot;t1.a &quot;という名前の単一のカラムを返します。バージョン 3.6.0 では、カラム名は単に &quot;a&quot; です。</target>
        </trans-unit>
        <trans-unit id="b38dc06ca0b3ec94d37d385f6a25506410f69b7f" translate="yes" xml:space="preserve">
          <source>In very old versions of SQLite (before version 3.7.11 - 2012-03-20) the ROLLBACK will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are any pending queries. In more recent versions of SQLite, the ROLLBACK will proceed and pending statements will often be aborted, causing them to return an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. In SQLite version 3.8.8 (2015-01-16) and later, a pending read will continue functioning after the ROLLBACK as long as the ROLLBACK does not modify the database schema.</source>
          <target state="translated">SQLiteの非常に古いバージョン（バージョン3.7.11-2012-03-20より前）では、保留中のクエリがある場合、ROLLBACKはエラーコード&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSYで&lt;/a&gt;失敗します。 SQLiteの最新バージョンでは、ROLLBACKが続行され、保留中のステートメントが中止されることが多く、&lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;または&lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt;エラーが返されます。 SQLiteバージョン3.8.8（2015-01-16）以降では、ROLLBACKがデータベーススキーマを変更しない限り、ROLLBACK後も保留中の読み取りは機能し続けます。</target>
        </trans-unit>
        <trans-unit id="b499aec31026161ef5b7e71ea3cf99793674a2a9" translate="yes" xml:space="preserve">
          <source>In words, we have a database table named &quot;examp&quot; that has two columns of data named &quot;one&quot; and &quot;two&quot;. Now suppose we want to insert a single record into this table. Like this:</source>
          <target state="translated">言い換えれば、&quot;examp &quot;という名前のデータベーステーブルがあり、そこには &quot;1 &quot;と &quot;2 &quot;という2つの列のデータがあります。ここで、このテーブルに1つのレコードを挿入したいとします。このようにします。</target>
        </trans-unit>
        <trans-unit id="538f80f611dd84d930a92b9f7317e8773bd20fa3" translate="yes" xml:space="preserve">
          <source>In-Memory Databases</source>
          <target state="translated">インメモリデータベース</target>
        </trans-unit>
        <trans-unit id="d29dcc989f8aeac43865c646816b27c0bf5d86c1" translate="yes" xml:space="preserve">
          <source>In-memory Databases And Shared Cache</source>
          <target state="translated">インメモリデータベースと共有キャッシュ</target>
        </trans-unit>
        <trans-unit id="f87e1ebcfb907fda4b66420b21bcba1a298d5d80" translate="yes" xml:space="preserve">
          <source>In-memory databases are allowed to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; if they are opened using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. If the unadorned &quot;:memory:&quot; name is used to specify the in-memory database, then that database always has a private cache and is this only visible to the database connection that originally opened it. However, the same in-memory database can be opened by two or more database connections as follows:</source>
          <target state="translated">インメモリデータベースは、&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;を使用して開かれている場合、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;を使用できます。装飾されていない &quot;：memory：&quot;名を使用してインメモリデータベースを指定すると、そのデータベースには常にプライベートキャッシュがあり、これは最初にデータベースを開いたデータベース接続にのみ表示されます。ただし、次のように、同じインメモリデータベースを2つ以上のデータベース接続で開くことができます。</target>
        </trans-unit>
        <trans-unit id="4e5ba204b0641a7420c326e6c9ccf4a171f01a91" translate="yes" xml:space="preserve">
          <source>Include a digit somewhere in every identifier name.</source>
          <target state="translated">すべての識別子名のどこかに桁を含めてください。</target>
        </trans-unit>
        <trans-unit id="609cf98670fbb073608f2b25b70dd7c1c13a30bc" translate="yes" xml:space="preserve">
          <source>Include a static string in the library that responds to the RCS &quot;ident&quot; command and which contains the library version number.</source>
          <target state="translated">RCS &quot;ident &quot;コマンドに応答し、ライブラリのバージョン番号を含む静的文字列をライブラリに含めます。</target>
        </trans-unit>
        <trans-unit id="c0417d1d2b8071cc5718dd6c321dee3ddd0e2b30" translate="yes" xml:space="preserve">
          <source>Incompatible changes are covered first since they are the most important to maintainers and programmers.</source>
          <target state="translated">互換性のない変更は、メンテナやプログラマーにとって最も重要な変更なので、最初に取り上げます。</target>
        </trans-unit>
        <trans-unit id="bc118ee16ef865aed415e5f3a8d6022aa76b72dd" translate="yes" xml:space="preserve">
          <source>Inconsistent result set column names between CREATE TABLE AS and a simple SELECT. Ticket &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</source>
          <target state="translated">CREATE TABLE ASと単純なSELECTの間で一貫性のない結果セット列名。チケット&lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7579773ac4d764f11e434b97ff14dade4554c12" translate="yes" xml:space="preserve">
          <source>Incorporate makefile patches form A. Rottmann to use LIBTOOL</source>
          <target state="translated">A.Rottmannからのmakefileパッチを組み込み、LIBTOOLを使用するようにしました。</target>
        </trans-unit>
        <trans-unit id="78318ed3e6ca4f2006eecd671fb4e1b78bbf85cb" translate="yes" xml:space="preserve">
          <source>Incorrect</source>
          <target state="translated">Incorrect</target>
        </trans-unit>
        <trans-unit id="f074a009d21038c67513df8d49c6353ecce4802a" translate="yes" xml:space="preserve">
          <source>Incorrect assert() statement removed. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;.</source>
          <target state="translated">誤ったassert（）ステートメントが削除されました。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86f64d7d599af33f2e2d357b68bfbc2590e32e39" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="translated">不適切な列のデータ型が報告されました。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5010ff6ebfa98793b55410eccec7fb293111ca61" translate="yes" xml:space="preserve">
          <source>Incorrect query results on a join with a ORDER BY DESC. Ticket &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;.</source>
          <target state="translated">ORDER BY DESCを使用した結合で不正なクエリが発生します。チケット&lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d72bf52d94d169fcce6582014fa4914c962c4cbe" translate="yes" xml:space="preserve">
          <source>Incorrect query results when the skip-ahead-distinct optimization is used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;.</source>
          <target state="translated">先読みスキップ最適化を使用すると、クエリ結果が不正になります。チケット&lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b88b306633c693ef74330d871a60d1a4c0698aa" translate="yes" xml:space="preserve">
          <source>Incorrect result on the less-than operator in &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rowvalue&quot;&gt;行の値の小&lt;/a&gt;なり演算子の結果が正しくありません。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353e2ea7a72adf3f039c8f1d29d7d6a2765ce415" translate="yes" xml:space="preserve">
          <source>IncrVacuum</source>
          <target state="translated">IncrVacuum</target>
        </trans-unit>
        <trans-unit id="21ef0be270a54a1cdd6fa173d6d67cc79394e640" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; allocation size from 100 to 128 bytes.</source>
          <target state="translated">デフォルトの&lt;a href=&quot;malloc#lookaside&quot;&gt;lookasideメモリアロケータの&lt;/a&gt;割り当てサイズを100バイトから128バイトに増やします。</target>
        </trans-unit>
        <trans-unit id="40e4fa7cf5d195215158819dc861b48ed9ae1b97" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; size from 512,125 to 1200,100 as this provides better performance while only adding 56KB of extra memory per connection. Memory-sensitive applications can restore the old default at compile-time, start-time, or run-time.</source>
          <target state="translated">接続ごとに56KBのメモリを追加するだけでパフォーマンスが向上するため、デフォルトの&lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt;サイズを512,125から1200,100に増やします。メモリに依存するアプリケーションは、コンパイル時、開始時、または実行時に古いデフォルトを復元できます。</target>
        </trans-unit>
        <trans-unit id="0e1c35718b4f025f2f5dcc35d709e6b06c180f12" translate="yes" xml:space="preserve">
          <source>Increase the default size of a lookahead cache line from 100 to 128 bytes.</source>
          <target state="translated">ルックヘッドキャッシュ行のデフォルトサイズを100バイトから128バイトに増やす。</target>
        </trans-unit>
        <trans-unit id="7da2a83b3ac0a9788385c812ce2d8ccd3f55fd86" translate="yes" xml:space="preserve">
          <source>Increase the default value of &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; to 50 and make sure that it is honored in every place that a schema change might force a statement retry.</source>
          <target state="translated">&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt;のデフォルト値を50に増やし、スキーマの変更によってステートメントの再試行が強制される可能性があるすべての場所でそれが受け入れられることを確認します。</target>
        </trans-unit>
        <trans-unit id="8609e4a99103452adeaaadda83f7438f10dd550a" translate="yes" xml:space="preserve">
          <source>Increase the maximum &quot;scope&quot; value for the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension from 6 to 30.</source>
          <target state="translated">&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;拡張の「スコープ」の最大値を6から30に増やします。</target>
        </trans-unit>
        <trans-unit id="c2f2fd643cba996348fe945409caf6a8045d3c9f" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of a database pages from 32KiB to 64KiB.</source>
          <target state="translated">データベースページの最大サイズを32KiBから64KiBに拡大。</target>
        </trans-unit>
        <trans-unit id="45c470cb2d5edd4a76a24043774f958df34166de" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 30 to 62 (though the default value remains at 10).</source>
          <target state="translated">&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt;の最大値を30から62に増やします（ただし、デフォルト値は10のままです）。</target>
        </trans-unit>
        <trans-unit id="bb8cf068d7b2280526a2d202959cea91dd49770d" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 62 to 125.</source>
          <target state="translated">&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt;の最大値を62から125に増やします。</target>
        </trans-unit>
        <trans-unit id="69df92b5969bbc35734aa6107d3290339d53b888" translate="yes" xml:space="preserve">
          <source>Increase the timeout in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; before issuing an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error from 1 second to 10 seconds.</source>
          <target state="translated">&lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt;エラーを発行する前に、&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;のタイムアウトを1秒から10秒に増やします。</target>
        </trans-unit>
        <trans-unit id="9f009e1e744f83083af0b2cc7e6b2078c78f112f" translate="yes" xml:space="preserve">
          <source>Increased robustness against malicious SQL that is run against a maliciously corrupted database.</source>
          <target state="translated">悪意を持って破損したデータベースに対して実行される悪意のあるSQLに対する堅牢性が向上しました。</target>
        </trans-unit>
        <trans-unit id="6b178246a9f68a2d5235ede0c3d198671a18c66b" translate="yes" xml:space="preserve">
          <source>Increased the version number on the &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; to 3 and added new methods xSetSysCall, xGetSysCall, and xNextSysCall used for doing full-coverage testing.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;VFSオブジェクト&lt;/a&gt;のバージョン番号を3に増やし、フルカバレッジテストの実行に使用される新しいメソッドxSetSysCall、xGetSysCall、およびxNextSysCallを追加しました。</target>
        </trans-unit>
        <trans-unit id="5b01748d80c9a44e0b5e68cd44f76d6fdcd5fbdb" translate="yes" xml:space="preserve">
          <source>Increment a &quot;constraint counter&quot; by P2 (P2 may be negative or positive). If P1 is non-zero, the database constraint counter is incremented (deferred foreign key constraints). Otherwise, if P1 is zero, the statement counter is incremented (immediate foreign key constraints).</source>
          <target state="translated">制約カウンタ」をP2でインクリメントする(P2は負でも正でもよい)。P1が0以外の場合、データベースの制約カウンタがインクリメントされます(外部キー制約の遅延)。そうでなければ、P1がゼロの場合、文カウンタをインクリメントする(即時外部キー制約)。</target>
        </trans-unit>
        <trans-unit id="9728ef186d1aa3193e57c71ddbd9cc22dfa95396" translate="yes" xml:space="preserve">
          <source>Increment the schema version number using &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version=X&lt;/a&gt; where X is one more than the old schema version number found in step 2 above.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version = X&lt;/a&gt;を使用してスキーマバージョン番号をインクリメントします。Xは、上記のステップ2で見つかった古いスキーマバージョン番号よりも1つ大きくなります。</target>
        </trans-unit>
        <trans-unit id="8144fd658d7904e59a32604de5f5f1ca74f2f2ee" translate="yes" xml:space="preserve">
          <source>Increment the value of P1 so that &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes will jump the first time they are evaluated for this run.</source>
          <target state="translated">なるようにP1の値をインクリメント&lt;a href=&quot;opcode#Once&quot;&gt;すると&lt;/a&gt;オペコードは、彼らがこの実行のために評価されている最初の時間をジャンプします。</target>
        </trans-unit>
        <trans-unit id="99958674e5ab051f627364f0e7aec7700da2c443" translate="yes" xml:space="preserve">
          <source>Incremental And Continuous Updates</source>
          <target state="translated">増分的および継続的な更新</target>
        </trans-unit>
        <trans-unit id="c978bfe7fe02498da062fb7e2f5271fe832940ed" translate="yes" xml:space="preserve">
          <source>Index B-Tree Interior Cell (header 0x02):</source>
          <target state="translated">インデックスB-ツリー内部セル(ヘッダ0x02)。</target>
        </trans-unit>
        <trans-unit id="4e71969581a513a52c19a67df3b923e84e3cb4d7" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Cell (header 0x0a):</source>
          <target state="translated">インデックス B-Tree リーフセル(ヘッダ 0x0a)。</target>
        </trans-unit>
        <trans-unit id="6834f50285e5eaa6aab20cfc4003ad141369bccf" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Or Interior Cell:</source>
          <target state="translated">Index B-Tree Leaf or Interior Cell.</target>
        </trans-unit>
        <trans-unit id="d05474cb52cfb6c27f6a9c375d177e07d462e5e6" translate="yes" xml:space="preserve">
          <source>Index Interior (0x02)</source>
          <target state="translated">インデックス内部 (0x02)</target>
        </trans-unit>
        <trans-unit id="f35ac0d24fd01ec25554f05ecc89c727c71a1e04" translate="yes" xml:space="preserve">
          <source>Index Leaf (0x0a)</source>
          <target state="translated">インデックスリーフ(0x0a</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">指定された名前のパラメータのインデックス</target>
        </trans-unit>
        <trans-unit id="239b13bdf631a9f83fa9a8a3d5c3895198fcc15a" translate="yes" xml:space="preserve">
          <source>Indexes On Expressions</source>
          <target state="translated">式のインデックス</target>
        </trans-unit>
        <trans-unit id="f48dd71980245b4a0803daa066444bcb1b77f26c" translate="yes" xml:space="preserve">
          <source>Indexes are removed with the &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; command.</source>
          <target state="translated">インデックスは&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;コマンドで削除されます。</target>
        </trans-unit>
        <trans-unit id="535c9c6ad77a4b24ea3df3e8a1b9f2c196027e6c" translate="yes" xml:space="preserve">
          <source>Indexes can use &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; and &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</source>
          <target state="translated">インデックスは&lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt;と&lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;を使用できます</target>
        </trans-unit>
        <trans-unit id="5826c397297007e146b25d7bb80a3a9d200a4f00" translate="yes" xml:space="preserve">
          <source>Indices are not required for child key columns but they are almost always beneficial. Returning to the example in &lt;a href=&quot;#fk_basics&quot;&gt;section 1&lt;/a&gt;, each time an application deletes a row from the</source>
          <target state="translated">インデックスは子キー列には必要ありませんが、ほとんどの場合有益です。&lt;a href=&quot;#fk_basics&quot;&gt;セクション1&lt;/a&gt;の例に戻り、アプリケーションが行を削除するたびに</target>
        </trans-unit>
        <trans-unit id="952faf72c9a83e116cef336ce73f046eb32c95b9" translate="yes" xml:space="preserve">
          <source>Indices with names of the form &quot;sqlite_autoindex_TABLE_N&quot; that are used to implement &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on ordinary tables.</source>
          <target state="translated">通常のテーブルに&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;および&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;制約を実装するために使用される「sqlite_autoindex_TABLE_N」の形式の名前を持つインデックス。</target>
        </trans-unit>
        <trans-unit id="853f712d884520adb0232cc6445c159a48a0d960" translate="yes" xml:space="preserve">
          <source>Individual database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can choose to participate or not participate in shared cache mode by using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags the third parameter. The use of either of these flags overrides the global shared cache mode setting established by &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. No more than one of the flags should be used; if both SQLITE_OPEN_SHAREDCACHE and SQLITE_OPEN_PRIVATECACHE flags are used in the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;を使用して作成された個々のデータベース接続は、&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;または&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;フラグの3番目のパラメーターを使用して、共有キャッシュモードに参加するか、参加しないかを選択できます。これらのフラグのいずれかを使用すると、&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;によって確立されたグローバル共有キャッシュモード設定が上書きされます。フラグは1つだけ使用してください。 SQLITE_OPEN_SHAREDCACHEフラグとSQLITE_OPEN_PRIVATECACHEフラグの両方が&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）の&lt;/a&gt; 3番目の引数で使用されている場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="e34e9639a7829e3d1eeead355b99441da28ac59a" translate="yes" xml:space="preserve">
          <source>Individual fields of the shm header, except for the salt values copied from the WAL header, are unsigned integers in the native byte-order of the host machine. The salt values are exact copies from the WAL header and are in whatever byte order is used by the WAL file. The size of integers may be 8, 16, 32, or 64 bits. A detailed breakout of the individual fields of the shm header follows:</source>
          <target state="translated">WAL ヘッダーからコピーされた salt 値を除いた shm ヘッダーの個々のフィールドは、ホストマシンのネイティブバイトオーダーの符号なし整数です。ソルト値は WAL ヘッダーからの正確なコピーであり、WAL ファイルで使用されるバイトオーダーである。整数のサイズは8、16、32、64ビットです。shmヘッダの個々のフィールドの詳細なブレークアウトは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="afaa9b90ffb384cf537b3db99f57a1ca2ab340a0" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like *a=5* or *x&amp;gt;y* or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indices for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="translated">個々のサブタームは、* a = 5 *または* x&amp;gt; y *のような単一の比較式であるか、LIKEまたはBETWEEN式であるか、またはAND接続されたサブサブタームの括弧で囲まれたリストです。各サブタームは、それ自体がWHERE句全体であるかのように分析され、サブターム自体がインデックス付け可能かどうかを確認します。場合&lt;u&gt;毎&lt;/u&gt;または句の部分項が別々に割出し可能である次にOR句は、別のインデックスがOR句の各用語を評価するために使用されるように符号化されるかもしれません。 SQLiteがOR句の用語ごとに別々のインデックスを使用する方法について考える1つの方法は、WHERE句が次のように書き換えられることを想像することです。</target>
        </trans-unit>
        <trans-unit id="7a9fd17dd36196733342a48e4a93f680869a4f7c" translate="yes" xml:space="preserve">
          <source>Individual virtual table implementations might impose additional constraints. For example, some virtual implementations might provide read-only tables. Or some virtual table implementations might allow &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; but not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Or some virtual table implementations might limit the kinds of UPDATEs that can be made.</source>
          <target state="translated">個々の仮想テーブルの実装により、追加の制約が課される場合があります。たとえば、一部の仮想実装は読み取り専用テーブルを提供する場合があります。または、仮想テーブルの実装によっては、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;または&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;は許可されても、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;は許可されない場合があります。または、仮想テーブルの実装によっては、実行できるUPDATEの種類が制限される場合があります。</target>
        </trans-unit>
        <trans-unit id="b7ab8cb519f7ae8e1280427c18f93285db556ab6" translate="yes" xml:space="preserve">
          <source>Infinite loop on an UPDATE that uses an OR operator in the WHERE clause. Problem introduced with 3.17.0 and reported on the mailing list about one year later. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;.</source>
          <target state="translated">WHERE句でOR演算子を使用するUPDATEの無限ループ。3.17.0で問題が発生し、約1年後にメーリングリストで報告されました。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9779307227ff608723d6f1acc622b0fbd0d99060" translate="yes" xml:space="preserve">
          <source>Information about the ORDER BY clause is stored in aOrderBy[]. Each term of aOrderBy records a column of the ORDER BY clause.</source>
          <target state="translated">ORDER BY節に関する情報は、aOrderBy[]に格納されます。aOrderByの各項は、ORDER BY句の列を記録します。</target>
        </trans-unit>
        <trans-unit id="8900519c8c00e46885e8acc9f5e07ba3fa96d336" translate="yes" xml:space="preserve">
          <source>Informix</source>
          <target state="translated">Informix</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="c807a586d6078a7e14adef4ebb7912d0c6f4aa53" translate="yes" xml:space="preserve">
          <source>InitCoroutine</source>
          <target state="translated">InitCoroutine</target>
        </trans-unit>
        <trans-unit id="9ceecfe65e61c428178f61207aad8930969e6176" translate="yes" xml:space="preserve">
          <source>Initial Public Release of Alpha code</source>
          <target state="translated">アルファコードの初回公開</target>
        </trans-unit>
        <trans-unit id="22e34d8b442d40192baed65a8aa102e6e94f33a1" translate="yes" xml:space="preserve">
          <source>Initial release of version 2.0. The idea of renaming the library to &quot;SQLus&quot; was abandoned in favor of keeping the &quot;SQLite&quot; name and bumping the major version number.</source>
          <target state="translated">バージョン2.0の初期リリース。ライブラリの名前を &quot;SQLus&quot; に変更するというアイデアは、&quot;SQLite&quot; の名前を維持し、メジャーバージョン番号を変更することで放棄されました。</target>
        </trans-unit>
        <trans-unit id="8f5bfa371a731c186afb7ca1237eb5d4d7f1e077" translate="yes" xml:space="preserve">
          <source>Initial size of the database in pages</source>
          <target state="translated">データベースの初期サイズ(ページ数</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">SQLite ライブラリの初期化</target>
        </trans-unit>
        <trans-unit id="d191407d44cf9ade286348bd4b44b9f7f3e25feb" translate="yes" xml:space="preserve">
          <source>Initialize index X to be N-200 (where N is the size of a database page in bytes.</source>
          <target state="translated">インデックスXをN-200(ここでNはデータベースページのサイズをバイト単位で表します)に初期化します。</target>
        </trans-unit>
        <trans-unit id="8e6cd4e5b42b5a543357e6d81e6f378b25c829f6" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;b&gt;azColumnName[]&lt;/b&gt; array for the callback.</source>
          <target state="translated">コールバックの&lt;b&gt;azColumnName []&lt;/b&gt;配列を初期化します。</target>
        </trans-unit>
        <trans-unit id="5f7aab6a3275a65fb3b4985527f188c8b61dc3b5" translate="yes" xml:space="preserve">
          <source>Initialize the checksum to the checksum nonce value found in the journal header at offset 12.</source>
          <target state="translated">チェックサムを、オフセット12のジャーナル・ヘッダにあるチェックサム・ノンス値に初期化します。</target>
        </trans-unit>
        <trans-unit id="404f059fc8a52705cd25b69b3e9ff09c1be18ec9" translate="yes" xml:space="preserve">
          <source>Inner joins can be freely reordered. However a left outer join is neither commutative nor associative and hence will not be reordered. Inner joins to the left and right of the outer join might be reordered if the optimizer thinks that is advantageous but the outer joins are always evaluated in the order in which they occur.</source>
          <target state="translated">内側結合は自由に並び替えることができます。しかし、左の外側結合は可換的でも連想的でもないので、並び替えられません。オプティマイザが有利だと考えた場合、外側結合の左と右の内側結合は並べ替えられるかもしれませんが、外側結合は常に発生した順番で評価されます。</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="6173fc45fc7b2219f9b313a58dd34b30a31fc6dc" translate="yes" xml:space="preserve">
          <source>Insert that single row into the recursive table</source>
          <target state="translated">その一行を再帰表に挿入します。</target>
        </trans-unit>
        <trans-unit id="e9c69a8b8aca121e6ec4067a03fd7e5c40db2b72" translate="yes" xml:space="preserve">
          <source>Insert the integer value held by register P2 into a RowSet object held in register P1.</source>
          <target state="translated">レジスタP2で保持している整数値を、レジスタP1で保持しているRowSetオブジェクトに挿入します。</target>
        </trans-unit>
        <trans-unit id="85a8fe292b0b6ab92cb375e9d651b4f869ca615a" translate="yes" xml:space="preserve">
          <source>Inserting Records Into The Database</source>
          <target state="translated">データベースにレコードを挿入する</target>
        </trans-unit>
        <trans-unit id="d9102185aa139480514433588d7c7980df39e939" translate="yes" xml:space="preserve">
          <source>Instead of a separate OFFSET clause, the LIMIT clause may specify two scalar expressions separated by a comma. In this case, the first expression is used as the OFFSET expression and the second as the LIMIT expression. This is counter-intuitive, as when using the OFFSET clause the second of the two expressions is the OFFSET and the first the LIMIT. This reversal of the offset and limit is intentional - it maximizes compatibility with other SQL database systems. However, to avoid confusion, programmers are strongly encouraged to use the form of the LIMIT clause that uses the &quot;OFFSET&quot; keyword and avoid using a LIMIT clause with a comma-separated offset.</source>
          <target state="translated">独立したOFFSET句の代わりに、LIMIT句はカンマで区切られた2つのスカラ式を指定することができます。この場合、最初の式がOFFSET式として使用され、2番目の式がLIMIT式として使用されます。これは直観的ではありませんが、OFFSET句を使用する場合、2つの式のうち2番目の式がOFFSET、1番目の式がLIMITとなります。オフセットとリミットのこの反転は意図的なもので、他のSQLデータベースシステムとの互換性を最大化します。しかし、混乱を避けるために、プログラマーは、&quot;OFFSET &quot;キーワードを使用する形式のLIMIT句を使用し、カンマで区切られたオフセットを持つLIMIT句の使用を避けることを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="d84a58129471e483da1b069622f8ee436752fbf7" translate="yes" xml:space="preserve">
          <source>Instead of deleting records where the &quot;two&quot; column is less than 50, this statement just puts the &quot;one&quot; column in parentheses The VDBE program to implement this statement follows:</source>
          <target state="translated">この文では、&quot;2 &quot;列が50未満のレコードを削除する代わりに、&quot;1 &quot;列を括弧で囲んでいるだけである。 この文を実装するVDBEプログラムは以下の通りである。</target>
        </trans-unit>
        <trans-unit id="123ee948ecafb3b169cf486ec20a13fbb0b9103f" translate="yes" xml:space="preserve">
          <source>Instead of providing full Unicode case support by default, SQLite provides the ability to link against external Unicode comparison and conversion routines. The application can overload the built-in &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; collating sequence (using &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;) and the built-in &lt;a href=&quot;lang_corefunc#like&quot;&gt;like()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; functions (using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;). The SQLite source code includes an &quot;ICU&quot; extension that does these overloads. Or, developers can write their own overloads based on their own Unicode-aware comparison routines already contained within their project.</source>
          <target state="translated">SQLiteは、デフォルトで完全なUnicodeケースサポートを提供する代わりに、外部Unicode比較および変換ルーチンに対してリンクする機能を提供します。アプリケーションは、組み込みの&lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt;照合シーケンス（&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;を使用）および組み込みの&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（）&lt;/a&gt;、&lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper（）&lt;/a&gt;、&lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower（）&lt;/a&gt;関数（&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;を使用）をオーバーロードできます。 SQLiteソースコードには、これらのオーバーロードを実行する「ICU」拡張機能が含まれています。または、開発者は、プロジェクト内に既に含まれている独自のUnicode対応の比較ルーチンに基づいて独自のオーバーロードを作成できます。</target>
        </trans-unit>
        <trans-unit id="e02d371a11cece5f4e01254e6fedf80303033a58" translate="yes" xml:space="preserve">
          <source>Instead of using a single data structure on disk to store the full-text index, FTS5 uses a series of b-trees. Each time a new transaction is committed, a new b-tree containing the contents of the committed transaction is written into the database file. When the full-text index is queried, each b-tree must be queried individually and the results merged before being returned to the user.</source>
          <target state="translated">フルテキストインデックスを格納するためにディスク上の単一のデータ構造を使用する代わりに、FTS5は一連のb-木を使用する。新しいトランザクションがコミットされるたびに、コミットされたトランザクションの内容を含む新しいb-木がデータベースファイルに書き込まれる。フルテキストインデックスがクエリされるとき、各bツリーは個別にクエリされ、結果がマージされてからユーザに返されなければならない。</target>
        </trans-unit>
        <trans-unit id="17249ad26f29e1aabdd8d073e961780b07d76064" translate="yes" xml:space="preserve">
          <source>Instead of using bm25() with no trailing arguments, the specific auxiliary function mapped to the rank column may be configured either on a per-query basis, or by setting a different persistent default for the FTS table.</source>
          <target state="translated">bm25()を最後の引数なしで使用する代わりに、ランク列にマップされた特定の補助関数は、クエリごとに、またはFTSテーブルに別の永続的なデフォルトを設定することによって設定することができます。</target>
        </trans-unit>
        <trans-unit id="f96fd53b0d03f5a031e6bd07854c303b890ed6f3" translate="yes" xml:space="preserve">
          <source>Instead of writing separately to the full-text index and the content table, some users may wish to use database triggers to keep the full-text index up to date with respect to the set of documents stored in the content table. For example, using the tables from earlier examples:</source>
          <target state="translated">全文インデックスとコンテンツテーブルに別々に書き込む代わりに、データベースのトリガーを使用して、コンテンツテーブルに格納されている文書のセットに関して、全文インデックスを最新の状態に保つことを望むユーザーもいるかもしれません。例えば、以前の例のテーブルを使用して、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="2dfaa927aed3a85d724ea909cde490986f208ecf" translate="yes" xml:space="preserve">
          <source>Instruction 1 is of particular importance in this example. Normally, the Column instruction extracts the value of a column from a larger record in the data of an SQLite file entry. Instruction 1 sets a flag on the transient table so that Column will instead treat the key of the SQLite file entry as if it were data and extract column information from the key.</source>
          <target state="translated">この例では、命令1が特に重要です。通常、Column 命令は SQLite ファイル エントリのデータ内のより大きなレコードからカラムの値を抽出します。命令 1 は過渡的なテーブルにフラグを設定して、Column が代わりに SQLite ファイル エントリのキーをあたかもデータであるかのように扱い、キーからカラム情報を抽出するようにします。</target>
        </trans-unit>
        <trans-unit id="5a41b63030179eee6fe726824158f303ff0039a4" translate="yes" xml:space="preserve">
          <source>Instructions 0 though 4 are as in the INSERT example. They start transactions for the main and temporary databases, verify the database schema for the main database, and open a read cursor on the table &quot;examp&quot;. Notice that the cursor is opened for reading, not writing. At this stage of the program we are only going to be scanning the table, not changing it. We will reopen the same table for writing later, at instruction 15.</source>
          <target state="translated">命令0から4は、INSERTの例と同じです。それらは、メイン・データベースと一時データベースのトランザクションを開始し、メイン・データベースのデータベース・スキーマを検証し、テーブル &quot;examp &quot;上に読み取りカーソルを開きます。カーソルは書き込みではなく読み込みのために開かれていることに注意してください。このプログラムのこの段階では、テーブルをスキャンするだけで、変更はしません。同じテーブルを後で、命令15で書き込み用に開き直します。</target>
        </trans-unit>
        <trans-unit id="b00a667a760d339b93dad1b03b5b7f4819103702" translate="yes" xml:space="preserve">
          <source>Instructions 11 through 18 implement a loop over all index records with the key that was fetched by instruction 8. All of the index records with this key will be contiguous in the index table, so we walk through them and fetch the corresponding table key from the index. This table key is then used to move the cursor to that row in the table. The rest of the loop is the same as the loop for the non-indexed SELECT query.</source>
          <target state="translated">命令11から18までは、命令8によってフェッチされたキーを持つすべてのインデックスレコード上のループを実装します。このキーを持つすべてのインデックスレコードはインデックステーブル内で連続しているので、それらをウォークスルーし、インデックスから対応するテーブルキーをフェッチします。そして、このテーブルキーは、テーブル内のその行にカーソルを移動させるために使用されます。残りのループは、インデックスを持たないSELECTクエリのループと同じです。</target>
        </trans-unit>
        <trans-unit id="93ad75caff49702ce2412b358044c514b17d458d" translate="yes" xml:space="preserve">
          <source>Instructions 18 through 23 implement a loop over every row of the table being indexed. For each table row, we first extract the integer key for that row using Recno in instruction 19, then get the value of the &quot;two&quot; column using Column in instruction 20. The &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; instruction at 21 converts data from the &quot;two&quot; column (which is on the top of the stack) into a valid index key. For an index on a single column, this is basically a no-op. But if the P1 operand to MakeIdxKey had been greater than one multiple entries would have been popped from the stack and converted into a single index key. The &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt; instruction at 22 is what actually creates the index entry. IdxPut pops two elements from the stack. The top of the stack is used as a key to fetch an entry from the index table. Then the integer which was second on stack is added to the set of integers for that index and the new record is written back to the database file. Note that the same index entry can store multiple integers if there are two or more table entries with the same value for the two column.</source>
          <target state="translated">命令18から23は、インデックス付けされるテーブルのすべての行にループを実装します。テーブルの各行について、最初に命令19のRecnoを使用してその行の整数キーを抽出し、次に命令20の列を使用して「2」列の値を取得します&lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;。21のMakeIdxKey&lt;/a&gt;命令は「2」列からデータを変換します（これはスタックの一番上にあります）有効なインデックスキーに。単一列のインデックスの場合、これは基本的に何もしません。ただし、MakeIdxKeyのP1オペランドが1より大きい場合、複数のエントリがスタックからポップされ、単一のインデックスキーに変換されます。&lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt;22の命令は、実際にインデックスエントリを作成するものです。IdxPutは、スタックから2つの要素をポップします。スタックの最上部は、インデックステーブルからエントリをフェッチするためのキーとして使用されます。次に、スタックの2番目の整数がそのインデックスの整数のセットに追加され、新しいレコードがデータベースファイルに書き戻されます。2つの列に同じ値を持つ2つ以上のテーブルエントリがある場合、同じインデックスエントリが複数の整数を格納できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d073fd93c649c9cf841978f9cb4f52abf67079a9" translate="yes" xml:space="preserve">
          <source>Instructions 19 through 25 construct a new database record that will be used to replace the existing record. This is the same kind of code that we saw in the description of INSERT and will not be described further. After instruction 25 executes, the stack looks like this:</source>
          <target state="translated">命令19から25は、既存のレコードを置き換えるために使用される新しいデータベースレコードを構築します。これはINSERTの説明で見たのと同じ種類のコードなので、これ以上は説明しません。命令25が実行された後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="560e44647be24d5aca941bd1314e718abb8f4a57" translate="yes" xml:space="preserve">
          <source>Instructions 2 and 3 open a read cursor on the database table that is to be queried. This works the same as the OpenWrite instruction in the INSERT example except that the cursor is opened for reading this time instead of for writing. Instruction 4 verifies the database schema as in the INSERT example.</source>
          <target state="translated">命令2と3は、問い合わせ先のデータベース・テーブル上に読み取りカーソルを開きます。これはINSERTの例のOpenWrite命令と同じように動作しますが、今回はカーソルが書き込み用ではなく読み取り用に開かれています。命令4はINSERTの例と同様にデータベーススキーマを検証します。</target>
        </trans-unit>
        <trans-unit id="fca2a6be701ffa87d686ce081ffdb761ec90891d" translate="yes" xml:space="preserve">
          <source>Instructions for compiling for Android are &lt;a href=&quot;#compile-android&quot;&gt;shown below&lt;/a&gt;.</source>
          <target state="translated">Android向けのコンパイル手順を&lt;a href=&quot;#compile-android&quot;&gt;以下に示します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="8245fcad9e0056a0d272c8564c605d1f5607526e" translate="yes" xml:space="preserve">
          <source>IntCopy</source>
          <target state="translated">IntCopy</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="d591fd91d02ea91f2fb6bfc98baa68985aa1c55d" translate="yes" xml:space="preserve">
          <source>Integer arithmetic operations that would have resulted in overflow are now performed using floating-point instead.</source>
          <target state="translated">オーバーフローの原因となっていた整数演算が、代わりに浮動小数点を使用して実行されるようになりました。</target>
        </trans-unit>
        <trans-unit id="a45ac87a27eab6aa76ce2b5c611f2a64d3669419" translate="yes" xml:space="preserve">
          <source>Integer values stored as part of segment b-tree nodes are encoded using the FTS varint format. This encoding is similar, but &lt;b&gt;not identical&lt;/b&gt;, to the &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint format&lt;/a&gt;.</source>
          <target state="translated">セグメントbツリーノードの一部として格納された整数値は、FTS varint形式を使用してエンコードされます。このエンコーディングは&lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint形式&lt;/a&gt;と似ていますが&lt;b&gt;、同じ&lt;/b&gt;ではあり&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="e5d27de0bdb200a7cf8d08a229aa8daa78f0e8ef" translate="yes" xml:space="preserve">
          <source>IntegrityCk</source>
          <target state="translated">IntegrityCk</target>
        </trans-unit>
        <trans-unit id="825d7872ab454dde0951d75f4e8c3836556b73f2" translate="yes" xml:space="preserve">
          <source>Intended Use Of This Memory Slot</source>
          <target state="translated">このメモリスロットの使用目的</target>
        </trans-unit>
        <trans-unit id="bad6e55f508278bbd1f2de2f51b2cfa41d861db7" translate="yes" xml:space="preserve">
          <source>Interbase</source>
          <target state="translated">Interbase</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="5fe5b201b27c997051ff6e5d94d0bbfdf6211714" translate="yes" xml:space="preserve">
          <source>Interior pages of table b-trees have no payload and so there is never any payload to spill.</source>
          <target state="translated">テーブルbツリーの内部ページにはペイロードがないので、こぼれ落ちるペイロードがあることはありません。</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="2e2e38ed2987465eebf4fce7929c514aa147e99c" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs</source>
          <target state="translated">内部BLOBと外部BLOB</target>
        </trans-unit>
        <trans-unit id="8f5ed2d53487fd119b9560f28f441dc6f596f2d9" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs in SQLite</source>
          <target state="translated">SQLiteにおける内部BLOBと外部BLOBの比較</target>
        </trans-unit>
        <trans-unit id="e76edc7c42bb9553424aeb43d13659b70db42f10" translate="yes" xml:space="preserve">
          <source>Internal schema objects used by SQLite may include the following:</source>
          <target state="translated">SQLite が使用する内部スキーマオブジェクトには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="f7a3c018025e7b8852ebedd2735d4dc85161ed87" translate="yes" xml:space="preserve">
          <source>Internal table</source>
          <target state="translated">内部テーブル</target>
        </trans-unit>
        <trans-unit id="43a9dae252aed092af4315626ccea64ecf3ea367" translate="yes" xml:space="preserve">
          <source>Internally, Geopoly stores polygons in a binary format - an SQL BLOB. Details of the binary format are given below. All of the Geopoly interfaces are able to accept polygons in either the GeoJSON format or in the binary format.</source>
          <target state="translated">内部的には、GeopolyはポリゴンをSQL BLOBというバイナリ形式で保存します。バイナリフォーマットの詳細は以下に記載されています。すべてのGeopolyインターフェースは、GeoJSONフォーマットまたはバイナリフォーマットのポリゴンを受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="f1e37c3aeef00d8b7d2ca4c1560bedb3798f4927" translate="yes" xml:space="preserve">
          <source>Internationalization of the TRIM() function. Ticket #2323</source>
          <target state="translated">TRIM()関数の国際化。チケット #2323</target>
        </trans-unit>
        <trans-unit id="888710a95af8568e1d72613950e6141b6fd4f17f" translate="yes" xml:space="preserve">
          <source>Interpret the byte at offset X into the page as an 8-bit unsigned integer and add the value of that integer to the checksum.</source>
          <target state="translated">ページ内のオフセットXのバイトを8ビットの符号なし整数として解釈し、その整数の値をチェックサムに加算します。</target>
        </trans-unit>
        <trans-unit id="0a6e9fc795cd5f992a07708fafc38d37296f0f2e" translate="yes" xml:space="preserve">
          <source>Interpret the content of register P1 as an integer. Store the ones-complement of the P1 value into register P2. If P1 holds a NULL then store a NULL in P2.</source>
          <target state="translated">レジスタP1の内容を整数として解釈します。P1 の値の ones-complement をレジスタ P2 に格納します。P1がNULLを保持している場合は、P2にNULLを格納します。</target>
        </trans-unit>
        <trans-unit id="5e8db10d44914bca3da452a09d9353f35541c4d5" translate="yes" xml:space="preserve">
          <source>Interpret the data that cursor P1 points to as a structure built using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction. (See the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode for additional information about the format of the data.) Extract the P2-th column from this record. If there are less that (P2+1) values in the record, extract a NULL.</source>
          <target state="translated">カーソルP1が指すデータを、&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;命令を使用して作成された構造体として解釈します。（データの形式の詳細については、&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;オペコードを参照してください。）このレコードからP2番目の列を抽出します。レコードの値が（P2 + 1）より少ない場合は、NULLを抽出します。</target>
        </trans-unit>
        <trans-unit id="2f79feeee233aec484084c713d84bf8b19e18fec" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store that boolean (a 0 or 1) in register P2. Or if the value in register P1 is NULL, then the P3 is stored in register P2. Invert the answer if P4 is 1.</source>
          <target state="translated">レジスタP1の値をブール値として解釈します。そのブール値(0または1)をレジスタP2に格納する。または、レジスタP1の値がNULLであれば、そのP3をレジスタP2に格納する。P4が1であれば答えを反転させます。</target>
        </trans-unit>
        <trans-unit id="11ded0e7491f472be93758e1becf6a72788c6084" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store the boolean complement in register P2. If the value in register P1 is NULL, then a NULL is stored in P2.</source>
          <target state="translated">レジスタP1の値をブール値として解釈します。そのブール値の補数をレジスタP2に格納します。レジスタP1の値がNULLの場合は、P2にNULLを格納します。</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">長時間実行中のクエリの割り込み</target>
        </trans-unit>
        <trans-unit id="5c1dd154209c449e02a41fa43190c4baa16c350d" translate="yes" xml:space="preserve">
          <source>Introduce extended error codes and add error codes for various kinds of I/O errors.</source>
          <target state="translated">拡張エラーコードを導入し、各種I/Oエラーのエラーコードを追加します。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="99fc2e9eb55cb6b8a4a8e79d3fb3b2c33516ae12" translate="yes" xml:space="preserve">
          <source>Introspect the disk content of an SQLite database file (the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;)</source>
          <target state="translated">SQLiteデータベースファイル（&lt;a href=&quot;dbstat&quot;&gt;dbstat仮想テーブル&lt;/a&gt;）のディスクコンテンツをイントロスペクトする</target>
        </trans-unit>
        <trans-unit id="eca078956e48bad9ba22213be258664ddfba5fe3" translate="yes" xml:space="preserve">
          <source>Intuitively, we humans understand that algorithm-1 is best. Each check-in is likely to have few children (one child is the most common case) and each child can be tested for the $trunk tag in logarithmic time. Indeed, algorithm-1 is the faster choice in practice. But the NGQP has no intuition. The NGQP must use hard math, and algorithm-2 is slightly better mathematically. This is because, in the absence of other information, the NGQP must assume that the indexes PLINK_I1 and TAGXREF_I1 are of equal quality and are equally selective. Algorithm-2 uses one field of the TAGXREF_I1 index and both fields of the PLINK_I1 index whereas algorithm-1 only uses the first field of each index. Since algorithm-2 uses more index material, the NGQP is correct to judge it to be the better algorithm. The scores are close and algorithm-2 just barely squeaks ahead of algorithm-1. But algorithm-2 really is the correct choice here.</source>
          <target state="translated">直感的に、私たち人間はアルゴリズム-1が最良であることを理解しています。各チェックインは、子供が少ない(1人の子供が最も一般的なケースです)可能性が高く、各子供は対数時間で$trunkタグをテストすることができます。実際、実際にはアルゴリズム-1の方が速い選択です。しかし、NGQPには直感がありません。NGQPは難しい数学を使わなければならず、アルゴリズム-2の方が数学的にはわずかに優れています。これは、他の情報がない場合、NGQPはインデックスPLINK_I1とTAGXREF_I1が同等の品質であり、等しく選択的であると仮定しなければならないからです。アルゴリズム-2は、アルゴリズム-1が各インデックスの最初のフィールドのみを使用するのに対し、TAGXREF_I1インデックスの1つのフィールドとPLINK_I1インデックスの両方のフィールドを使用する。アルゴリズム-2はより多くのインデックスを使用するので、NGQPはそれがより優れたアルゴリズムであると判断するのが正しいです。スコアは近くにあり、アルゴリズム-2 はアルゴリズム-1 の前をかろうじてこけています。しかし、ここではアルゴリズム-2 が本当に正しい選択です。</target>
        </trans-unit>
        <trans-unit id="b761791d82a982a68e59a508cac1ee842272cd79" translate="yes" xml:space="preserve">
          <source>Invert A Changeset</source>
          <target state="translated">チェンジセットの反転</target>
        </trans-unit>
        <trans-unit id="e32caad6eec08f7fecc6a1b58616c917f68be530" translate="yes" xml:space="preserve">
          <source>Invert the changeset before applying it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">チェンジセットを適用する前に反転させます。これは、適用する前にsqlite3changeset_invert()を使用してチェンジセットを反転させることと同等です。このフラグをパッチセットで指定するのはエラーです。</target>
        </trans-unit>
        <trans-unit id="78ac8e24cc6e1af906f6d84df224cae4a5dbdc9c" translate="yes" xml:space="preserve">
          <source>Invert the changeset while iterating through it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">チェンジセットを反復処理しながら反転させます。これは、適用する前にsqlite3changeset_invert()を使用してチェンジセットを反転させることと同等です。このフラグをパッチセットで指定するのはエラーです。</target>
        </trans-unit>
        <trans-unit id="1f705eccb3bd6ee22f3941d7379adda7f2017d82" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; on the database connection handle associated with the supplied statement handle to register for an unlock-notify callback. If the call to unlock_notify() returns SQLITE_LOCKED, then return this value to the caller.</source>
          <target state="translated">提供されたステートメントハンドルに関連付けられたデータベース接続ハンドルで&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;を呼び出し、ロック解除通知コールバックに登録します。unlock_notify（）の呼び出しがSQLITE_LOCKEDを返す場合、この値を呼び出し元に返します。</target>
        </trans-unit>
        <trans-unit id="7c709a0509002cbc5917883c970a9481452275c1" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to a FuncDef object that defines the function) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">レジスタP2から取り出されたP5の引数とその後継者でユーザ関数(P4は関数を定義するFuncDefオブジェクトへのポインタ)を呼び出します。関数の結果はレジスタP3に格納されます。レジスタP3は関数の入力の一つであってはなりません。</target>
        </trans-unit>
        <trans-unit id="d5afe87b60965605a9297c781c01328e7ab18fc9" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">レジスタP2とその後継から取り出されたP5の引数でユーザ関数(P4は実行される関数へのポインタを含むsqlite3_contextオブジェクトへのポインタ)を呼び出します。関数の結果はレジスタP3に格納されます。レジスタP3は関数の入力の一つであってはなりません。</target>
        </trans-unit>
        <trans-unit id="ec3125db909dbad56a3a25ad8b3535b576369321" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command once with the parameter set to -N, then</source>
          <target state="translated">パラメータを -N に設定した状態で 'merge' コマンドを一度だけ呼び出してから</target>
        </trans-unit>
        <trans-unit id="7dd177608c23145959faf29e93b347c2a9c95d8f" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command zero or more times with the parameter set to N.</source>
          <target state="translated">パラメータを N に設定して、'merge' コマンドを 0 回以上実行します。</target>
        </trans-unit>
        <trans-unit id="66ccce8dbed894fb937993244705085ff4d8803a" translate="yes" xml:space="preserve">
          <source>Invoke the callback function for the current row of the result.</source>
          <target state="translated">結果の現在の行のコールバック関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="125398c8d0ddcbf991b86f4ee6d99da4c12cf932" translate="yes" xml:space="preserve">
          <source>Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation, so thousands of calls may be required to apply a complete update. The sqlite3rbu_step() interface will return SQLITE_DONE when the update has been completely applied.</source>
          <target state="translated">sqlite3rbuオブジェクトポインタXに対してsqlite3rbu_step(X)関数を1回以上呼び出します。 sqlite3rbu_step()の各呼び出しは1つのb-tree操作を実行するので、完全な更新を適用するためには何千回も呼び出す必要があるかもしれません。sqlite3rbu_step()インタフェースは、更新が完全に適用されたときにSQLITE_DONEを返します。</target>
        </trans-unit>
        <trans-unit id="09ac0f478fa9c31ebe084063003a8993cc83456c" translate="yes" xml:space="preserve">
          <source>Invoke the xValue() function and store the result in register P3.</source>
          <target state="translated">xValue()関数を呼び出し、その結果をレジスタP3に格納します。</target>
        </trans-unit>
        <trans-unit id="ec2b47e7de90dfad0a6211ad1cb07982eafe0cde" translate="yes" xml:space="preserve">
          <source>Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.</source>
          <target state="translated">NULLポインタ上でsqlite3_finalize()を呼び出すことは無害なノーオペです。</target>
        </trans-unit>
        <trans-unit id="bd8202d31b1a7640473e2e12fd946892b1ec4008" translate="yes" xml:space="preserve">
          <source>Invoking this pragma with an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; C interface with a &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3rd parameter&lt;/a&gt; corresponding to the argument:</source>
          <target state="translated">引数を指定してこのプラグマを呼び出すことは、引数に対応する&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3番目のパラメーターを指定&lt;/a&gt;して&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt; Cインターフェイスを呼び出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="5f0e3d2a93c21482714b0b7a93ae0ad2d3dfb1f3" translate="yes" xml:space="preserve">
          <source>Invoking this pragma without an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface.</source>
          <target state="translated">引数なしでこのプラグマを呼び出すことは、&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; Cインターフェースを呼び出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="8cedb7aa520fd9ec8eb114043f05f6f9d17e93dd" translate="yes" xml:space="preserve">
          <source>Is SQLite threadsafe?</source>
          <target state="translated">SQLiteはスレッドセーフですか?</target>
        </trans-unit>
        <trans-unit id="d993744fe6f739c6aa4d5f6de34d342868d7e529" translate="yes" xml:space="preserve">
          <source>Is replaced by:</source>
          <target state="translated">置き換えられています。</target>
        </trans-unit>
        <trans-unit id="accaed01010f56d422eef5c33bfb4384f7eeeed3" translate="yes" xml:space="preserve">
          <source>IsNull</source>
          <target state="translated">IsNull</target>
        </trans-unit>
        <trans-unit id="a0830278e8f462114ebf33a9e4e362b34c86b01d" translate="yes" xml:space="preserve">
          <source>IsTrue</source>
          <target state="translated">IsTrue</target>
        </trans-unit>
        <trans-unit id="3dea5e42ca2754f9e6823ecfc4f51c71cf05676a" translate="yes" xml:space="preserve">
          <source>Isolation And Concurrency</source>
          <target state="translated">分離と並行性</target>
        </trans-unit>
        <trans-unit id="6a3e64b57124b4061c4f707d69ad242f0d0e0ef1" translate="yes" xml:space="preserve">
          <source>Isolation Between Database Connections</source>
          <target state="translated">データベース接続間の分離</target>
        </trans-unit>
        <trans-unit id="e3488e8cb34f4c736ddb072c649ba2a6c79489e5" translate="yes" xml:space="preserve">
          <source>Isolation In SQLite</source>
          <target state="translated">SQLiteでの分離</target>
        </trans-unit>
        <trans-unit id="2dfabf57c5175b858eac45130bf0b51df7502b3e" translate="yes" xml:space="preserve">
          <source>Issue an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; warning on the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; whenever the query planner uses an automatic index.</source>
          <target state="translated">クエリプランナーが自動インデックスを使用する&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;場合は&lt;/a&gt;常に、&lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_CONFIG_LOGでSQLITE_WARNING_AUTOINDEX&lt;/a&gt;警告を発行します。</target>
        </trans-unit>
        <trans-unit id="ffb450eea3632a82507d6bc65c2b7d60604799db" translate="yes" xml:space="preserve">
          <source>Issue an SQLITE_WARNING message on the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; is used.</source>
          <target state="translated">&lt;a href=&quot;quirks#dblquote&quot;&gt;二重引用符で囲まれた文字列リテラル&lt;/a&gt;が使用されている場合は、&lt;a href=&quot;errlog&quot;&gt;エラーログで&lt;/a&gt; SQLITE_WARNINGメッセージを発行します。</target>
        </trans-unit>
        <trans-unit id="887bf7a7997457d1a84b4ef3887a47fd35509c6e" translate="yes" xml:space="preserve">
          <source>Issue an error rather instead of an assertion-fault or null-pointer dereference when the sqlite_master table is corrupted so that the sqlite_sequence table root page is really a btree-index page. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</source>
          <target state="translated">sqlite_stableテーブルのルートページが実際にはbtreeインデックスページになるように、sqlite_masterテーブルが破損している場合は、アサーションフォールトまたはnullポインター逆参照の代わりにエラーを発行します。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="265877cc565c8d7a6873f0a63d90a0fdd348de2c" translate="yes" xml:space="preserve">
          <source>It an error if database zFrom does not exist or does not contain the required compatible table.</source>
          <target state="translated">データベース zFrom が存在しないか、必要な互換性のあるテーブルが含まれていない場合のエラーです。</target>
        </trans-unit>
        <trans-unit id="0e154e176231a0aafc6a2d79aba315f0be81a2c2" translate="yes" xml:space="preserve">
          <source>It cannot be used to copy data to or from in-memory databases.</source>
          <target state="translated">インメモリデータベースへの、またはインメモリデータベースからのデータのコピーには使用できません。</target>
        </trans-unit>
        <trans-unit id="6fd3c51616175d12c8323af133471dff22943ef2" translate="yes" xml:space="preserve">
          <source>It could handle a special case of SQLITE_LOCKED that can occur when dropping a table or index.</source>
          <target state="translated">テーブルやインデックスを削除したときに発生する SQLITE_LOCKED の特殊なケースを扱うことができました。</target>
        </trans-unit>
        <trans-unit id="186b030c86f45f0c84d4dba2b997ab209083ef94" translate="yes" xml:space="preserve">
          <source>It could manage thread priorities.</source>
          <target state="translated">スレッドの優先順位を管理することができました。</target>
        </trans-unit>
        <trans-unit id="46b90c15208f2a0e159c21cdb03813412db842c6" translate="yes" xml:space="preserve">
          <source>It exists, and</source>
          <target state="translated">それは存在し</target>
        </trans-unit>
        <trans-unit id="40ecc5a776918cb0ff3984e5d8619d213f6f930d" translate="yes" xml:space="preserve">
          <source>It is a good idea to establish a convention for determining the RBU vacuum state database name based on the target database name. The example code below uses &quot;&amp;lt;target&amp;gt;-vacuum&quot;, where &amp;lt;target&amp;gt; is the name of the database being vacuumed.</source>
          <target state="translated">ターゲットデータベース名に基づいてRBUバキューム状態データベース名を決定するための規則を確立することをお勧めします。以下のコード例では、「&amp;lt;target&amp;gt; -vacuum」を使用しています。ここで、&amp;lt;target&amp;gt;は、バキュームされるデータベースの名前です。</target>
        </trans-unit>
        <trans-unit id="bc2605e225f0c06786d4d6602b4aa9c521bcd8db" translate="yes" xml:space="preserve">
          <source>It is acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine before &lt;b&gt;sqlite_step&lt;/b&gt; has returned SQLITE_DONE. Doing so has the effect of interrupting the operation in progress. Partially completed changes will be rolled back and the database will be restored to its original state (unless an alternative recovery algorithm is selected using an ON CONFLICT clause in the SQL being executed.) The effect is the same as if a callback function of &lt;b&gt;sqlite_exec&lt;/b&gt; had returned non-zero.</source>
          <target state="translated">&lt;b&gt;sqlite_step&lt;/b&gt;が&lt;b&gt;SQLITE_DONE&lt;/b&gt;を返す前に、仮想マシンで&lt;b&gt;sqlite_finalize&lt;/b&gt;を呼び出すことは許容されます。これを行うと、進行中の操作が中断されます。部分的に完了した変更はロールバックされ、データベースは元の状態に復元されます（実行中のSQLでON CONFLICT句を使用して代替の復旧アルゴリズムが選択されている場合を除く）。効果は、&lt;b&gt;sqlite_execの&lt;/b&gt;コールバック関数が&lt;b&gt;持っ&lt;/b&gt;ていた場合と同じです。ゼロ以外を返しました。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9b1cdd52a287f4e7becc07615494854f9dea1062" translate="yes" xml:space="preserve">
          <source>It is also acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine that has never been passed to &lt;b&gt;sqlite_step&lt;/b&gt; even once.</source>
          <target state="translated">また、一度も&lt;b&gt;sqlite_stepに&lt;/b&gt;渡されたことがない仮想マシンで&lt;b&gt;sqlite_finalize&lt;/b&gt;を呼び出すこともできます。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8524404ce2a2650e2fd11b49dcd571c2f2744c61" translate="yes" xml:space="preserve">
          <source>It is also possible to create custom tokenizers for FTS5. The API for doing so is &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">FTS5のカスタムトークナイザーを作成することもできます。そのためのAPIについては&lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;、ここ&lt;/a&gt;で説明します。</target>
        </trans-unit>
        <trans-unit id="af4ea7504b8858e61227bf5cbac3c869a2ebb0cf" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the set of codepoints that unicode61 treats as separator characters. The &quot;separators=&quot; option may be used to specify one or more extra characters that should be treated as separator characters, and the &quot;tokenchars=&quot; option may be used to specify one or more extra characters that should be treated as part of tokens instead of as separator characters. For example:</source>
          <target state="translated">unicode61 がセパレータキ ャ ラ ク タ と し て扱う コ ー ド 点の集合を カ ス タ マ イ ズす る こ と も で き ます。separators=&quot;オプションを使って、セパレータ文字として扱うべき1つ以上の余分な文字を指定したり、&quot;tokenchars=&quot;オプションを使って、セパレータ文字としてではなくトークンの一部として扱うべき1つ以上の余分な文字を指定したりすることができます。例えば、&quot;tokenchars=&quot;オプションを使用して、セパレータ文字としてではなくトークンの一部として扱うべき1つ以上の余分な文字を指定することができます。</target>
        </trans-unit>
        <trans-unit id="756b3fcc2f7b6b94c8632586f6c6ecc720cec025" translate="yes" xml:space="preserve">
          <source>It is an error to add types, constraints or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; declarations to a CREATE VIRTUAL TABLE statement used to create an FTS5 table. Once created, an FTS5 table may be populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements like any other table. Like any other table with no PRIMARY KEY declaration, an FTS5 table has an implicit INTEGER PRIMARY KEY field named rowid.</source>
          <target state="translated">FTS5テーブルの作成に使用されるCREATE VIRTUAL TABLEステートメントにタイプ、制約、または&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;宣言を追加すると、エラーになります。作成されたFTS5テーブルは、他のテーブルと同様に、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE、&lt;/a&gt;または&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントを使用して入力できます。PRIMARY KEY宣言のない他のテーブルと同様に、FTS5テーブルには、rowidという名前の暗黙のINTEGER PRIMARY KEYフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="444eee32669789fe15a56475160491d70e6d7f57" translate="yes" xml:space="preserve">
          <source>It is an error to attempt to set the sz or rawdata field to any value other than NULL.</source>
          <target state="translated">sz または rawdata フィールドに NULL 以外の値を設定しようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="24bfd3e9a865c193cff416ba8b58e38e3815e72c" translate="yes" xml:space="preserve">
          <source>It is an error to set the columnsize option to any value other than 0 or 1.</source>
          <target state="translated">columnsize オプションを 0 または 1 以外の値に設定するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="66b8e09fbd7b220da38b0f56a632afa06ded1cc2" translate="yes" xml:space="preserve">
          <source>It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time xToken() is called. Multiple synonyms may be specified for a single token by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. There is no limit to the number of synonyms that may be provided for a single token.</source>
          <target state="translated">最初に xToken()が呼び出されたときに FTS5_TOKEN_COLOCATED フラグを指定するのはエラーです。xToken(FTS5_TOKEN_COLOCATED)を連続して複数回呼び出すことで、1つのトークンに対して複数の同義語を指定することができます。1 つのトークンに対して提供される同義語の数に制限はありません。</target>
        </trans-unit>
        <trans-unit id="f8a103b729e696566ddb48fa0100f23ca6a9cb4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the cursor is used only for appending and so if the cursor is valid, then the cursor must already be pointing at the end of the btree and so no changes are made to the cursor.</source>
          <target state="translated">カーソルは追加にのみ使用されると仮定されているので、カーソルが有効な場合、カーソルは既にbtreeの最後を指しているはずなので、カーソルに変更は加えられません。</target>
        </trans-unit>
        <trans-unit id="28727e9350bc13e9dd557e61676acaf81b800e9f" translate="yes" xml:space="preserve">
          <source>It is assumed that writing a series of sequential blocks of data to a file in order is faster than writing the same blocks in an arbitrary order.</source>
          <target state="translated">ファイルに連続したブロックのデータを順番に書き込むことは、同じブロックを任意の順番で書き込むよりも高速であることが前提となっています。</target>
        </trans-unit>
        <trans-unit id="90995e42fb1f9b39bc19b92ec7c0b1c1c734e41d" translate="yes" xml:space="preserve">
          <source>It is created using a call to sqlite3changegroup_new().</source>
          <target state="translated">sqlite3changegroup_new()の呼び出しを使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="4e7aaf577a2ee286bdd21a85c82980a7edeb975b" translate="yes" xml:space="preserve">
          <source>It is difficult to update individual entries in a ZIP archive. It is especially difficult to update individual entries in a ZIP archive in a way that does not destroy the entire document if the computer loses power and/or crashes in the middle of the update. It is not impossible to do this, but it is sufficiently difficult that nobody actually does it. Instead, whenever the user selects &quot;File/Save&quot;, the entire ZIP archive is rewritten. Hence, &quot;File/Save&quot; takes longer than it ought, especially on older hardware. Newer machines are faster, but it is still bothersome that changing a single character in a 50 megabyte presentation causes one to burn through 50 megabytes of the finite write life on the SSD.</source>
          <target state="translated">ZIP アーカイブ内の個々のエントリを更新することは困難です。特に、更新の途中でコンピュータの電源が落ちたり、クラッシュしたりした場合に、ドキュメント全体を破壊しない方法で、ZIPアーカイブ内の個々のエントリを更新することは困難です。これを行うことは不可能ではありませんが、実際には誰もやっていないほど困難です。その代わり、ユーザが「ファイル/保存」を選択するたびに、ZIP アーカイブ全体が書き換えられます。そのため、特に古いハードウェアでは、&quot;ファイル/保存 &quot;に時間がかかります。新しいマシンはより高速ですが、50メガバイトのプレゼンテーションで一文字を変更すると、SSDの有限の書き込み寿命である50メガバイトを焼き尽くすことになるのは、まだ気になるところです。</target>
        </trans-unit>
        <trans-unit id="5567ffe2a8c6dd00685158eaaf03eb7345f63a44" translate="yes" xml:space="preserve">
          <source>It is illegal for P1 and P3 to be the same register. Sometimes, if P3 is the same register as P2, the implementation is able to avoid a memcpy().</source>
          <target state="translated">P1とP3が同じレジスタであることは違法です。時々、P3がP2と同じレジスタであれば、実装はmemcpy()を避けることができます。</target>
        </trans-unit>
        <trans-unit id="e08adbd91885a13f3de038527a6e47107fedd5af" translate="yes" xml:space="preserve">
          <source>It is important that all connections to the same database file use the same locking protocol. If one application is using POSIX advisory locks and another application is using dot-file locking, then the two applications will not see each other's locks and will not be able to coordinate database access, possibly leading to database corruption.</source>
          <target state="translated">同じデータベースファイルへのすべての接続が同じロックプロトコルを使用することが重要です。あるアプリケーションがPOSIXアドバイザリロックを使用し、別のアプリケーションがドットファイルロックを使用している場合、2つのアプリケーションはお互いのロックを見ることができず、データベースへのアクセスを調整することができず、データベースの破損につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="8c1111b9c3326c8dd11b23932594b685a7b1d3f7" translate="yes" xml:space="preserve">
          <source>It is important to note that changing versions of SQLite might cause changes in query plans. The same version of SQLite will always pick the same query plan, but if you relink your application to use a different version of SQLite, then query plans might change. In rare cases, an SQLite version change might lead to a performance regression. This is one reason you should consider statically linking your applications against SQLite rather than use a system-wide SQLite shared library which might change without your knowledge or control.</source>
          <target state="translated">SQLite のバージョンを変更すると、クエリプランが変更される可能性があることに注意することが重要です。同じバージョンの SQLite は常に同じクエリプランを選択しますが、異なるバージョンの SQLite を使用するようにアプリケーションを再リンクした場合、クエリプランが変更される可能性があります。まれに、SQLite のバージョンの変更がパフォーマンスの低下につながることがあります。これが、システム全体のSQLite共有ライブラリを使用するよりも、SQLiteに対してアプリケーションを静的にリンクすることを検討すべき理由の一つです。</target>
        </trans-unit>
        <trans-unit id="2fb1bf740043ac6cffabf7ccc0393c49b8d377d2" translate="yes" xml:space="preserve">
          <source>It is important to realize that neither &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; nor &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; do anything that cannot be accomplished using the core routines. In fact, these wrappers are implemented purely in terms of the core routines.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;も&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;も、コアルーチンを使用して達成できないことは何もしないことを理解することが重要です。実際、これらのラッパーは、コアルーチンの観点から純粋に実装されています。</target>
        </trans-unit>
        <trans-unit id="e6f1d24d369dd36a94bbbfa574744f4d470ce689" translate="yes" xml:space="preserve">
          <source>It is important to store all pages of a sector in the rollback journal in order to prevent database corruption following a power loss while writing the sector. Suppose that pages 1, 2, 3, and 4 are all stored in sector 1 and that page 2 is modified. In order to write the changes to page 2, the underlying hardware must also rewrite the content of pages 1, 3, and 4 since the hardware must write the complete sector. If this write operation is interrupted by a power outage, one or more of the pages 1, 3, or 4 might be left with incorrect data. Hence, to avoid lasting corruption to the database, the original content of all of those pages must be contained in the rollback journal.</source>
          <target state="translated">セクタの書き込み中に停電が発生してデータベースが破損するのを防ぐために、セクタの全ページをロールバックジャーナルに格納することが重要です。ページ 1、2、3、4 がすべてセクタ 1 に格納されており、ページ 2 が変更されているとします。ページ 2 への変更を書き込むためには、ハードウェアが完全なセクタを書き込まなければならないため、基礎となるハードウェアはページ 1、3、および 4 の内容も書き換えなければなりません。この書き込み動作が停電によって中断された場合、ページ1、3、または4のうちの1つまたは複数のページが正しくないデータで残される可能性があります。したがって、データベースへの永続的な破損を避けるために、これらのページのすべての元の内容をロールバックジャーナルに含める必要があります。</target>
        </trans-unit>
        <trans-unit id="128a48935084af31c9e8080ab5a8fbf025139866" translate="yes" xml:space="preserve">
          <source>It is important to understand these two different definitions for &quot;serverless&quot;. When a database claims to be &quot;serverless&quot;, be sure to discern whether they mean &quot;classic serverless&quot; or &quot;neo-serverless&quot;.</source>
          <target state="translated">サーバーレス」の2つの異なる定義を理解することが重要です。データベースが「サーバーレス」であると主張している場合、それが「クラシックサーバーレス」を意味しているのか「ネオサーバーレス」を意味しているのかを見分けるようにしてください。</target>
        </trans-unit>
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">gcovテスト実行と2回目の実際のテスト実行の両方で同じ出力が得られることを確認することが重要です。出力に違いがある場合は、SQLite コードに未定義の動作や不確定な動作が使用されている(つまりバグ)か、コンパイラにバグがあることを示しています。SQLite は過去 10 年間で GCC,Clang,MSVC のそれぞれでバグに遭遇してきたことに注意してください。コンパイラのバグは、まれではありますが発生します。</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">SQLite のコンパイル時オプションのすべての可能な組み合わせをテストすることは不可能です。しかし、以下のコンパイル時オプションのセットは、常に完全にテストされている設定の一つです。</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">もちろん、実際の電源障害を使用してクラッシュテストを行うことは実際的ではないので、クラッシュテストはシミュレーションで行われます。テストハーネスがクラッシュ後のデータベースファイルの状態をシミュレートできるようにする代替の&lt;a href=&quot;c3ref/vfs&quot;&gt;仮想ファイルシステム&lt;/a&gt;が挿入されます。</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">指定されたテーブルがデータベースに存在しない場合はエラーではありません。また、指定されたテーブルが PRIMARY KEY を持っていない場合もエラーではありません。しかし、これらのシナリオのいずれにおいても変更は記録されません。</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">既存の&lt;a href=&quot;lang_createtrigger&quot;&gt;トリガー&lt;/a&gt;と同じ名前のテーブルを作成してもエラーにはなりません。</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">&lt;em&gt;まったく&lt;/em&gt;同じSQLステートメントを2回以上評価することは、一般的には役に立ちません。多くの場合、同様のステートメントを評価する必要があります。たとえば、INSERTステートメントを異なる値で複数回評価したい場合があります。または、WHERE句の異なるキーを使用して、同じクエリを複数回評価することもできます。これに対応するために、SQLiteでは、SQLステートメントに、評価前に値に「バインド」された&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;を含めることができます。これらの値は後で変更でき、同じ&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を新しい値を使用してもう一度評価できます。</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">Gitでチェックインの子孫を見つけることは不可能ではありません。ただ難しいだけです。たとえば、Unixでチェックインの子孫を見つけるためのコマンドシーケンスを示す&lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflowページ&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">インデックスを使用するために、インデックスのすべての列がWHERE句の用語に含まれている必要はありません。ただし、使用されるインデックスの列にギャップがあってはなりません。したがって、上記の例のインデックスでは、列cを制約するWHERE句の用語がない場合、列aとbを制約する用語はインデックスで使用できますが、列dからzを制約する用語は使用できません。同様に、インデックス列は、不等式のみによって制約されている列の右側にある場合、（インデックス作成の目的で）通常は使用されません。 （例外については、以下の&lt;a href=&quot;optoverview#skipscan&quot;&gt;スキップスキャン最適化を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">チェンジセットまたはパッチセットを抽出した後、セッションオブジェクトを削除する必要はありません。データベースハンドルに接続したままにすることができ、以前と同様に構成されたテーブルの変更の監視を続行します。ただし、&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;または&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;がセッションオブジェクトで2回目に呼び出された場合、変更セットまたはパッチセットには、セッションの作成以降に接続で行われた&lt;em&gt;すべての&lt;/em&gt;変更が含まれます。つまり、sqlite3session_changeset（）またはsqlite3session_patchset（）の呼び出しによってセッションオブジェクトがリセットまたはゼロにされることはありません。</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">最初のトランザクションの後のトランザクションについては、データベースヘッダの変更カウンタをインクリメントする必要はありません。これにより、ロールバックジャーナルとメインデータベースファイルの両方に1ページ目の書き込みが保存されることが多いです。</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">sqlite3_column_type()で指定した形式でデータを取得する必要はありません。別のフォーマットが要求された場合、データは自動的に変換されます。</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">単一のFTSクエリで、languageid値が異なる行を返すことはできません。他の演算子（例：lid！= 5、lid &amp;lt;= 5）を使用するWHERE句を追加した結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">内容のないFTS4テーブルに格納されている行をUPDATEまたはDELETEすることはできません。これを試みるとエラーになります。</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">空のデータベースで、または&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;を使用して、または&lt;a href=&quot;backup&quot;&gt;バックアップAPI&lt;/a&gt;を使用してバックアップから復元することによって、WALモードに入った後で&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;を変更することはできません。ページサイズを変更するには、ロールバックジャーナルモードになっている必要があります。</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;マルチステートメントトランザクションの&lt;/a&gt;途中で外部キー制約を有効または無効にすることはできません（SQLiteが&lt;a href=&quot;c3ref/get_autocommit&quot;&gt;自動コミットモードで&lt;/a&gt;ない場合）。これを実行しようとしてもエラーは返されません。効果はありません。</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">ALTER TABLE ...新しい列のデフォルト値がNULLでない限り、REFERENCES句を含む列を追加するために &quot;ALTER TABLE ...ADD COLUMN &quot;構文を使用することはできません。これを試みようとするとエラーを返します。</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">この変数を一度に複数のスレッドで読み取ったり変更したりすることは安全ではありません。&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;が別のスレッドで同時に使用されている場合、この変数を読み取ったり変更したりするのは安全ではありません。この変数は、プロセスの初期化の一部として一度、SQLiteインターフェースルーチンが呼び出される前に設定され、その後はこの変数は変更されないままであることが意図されています。</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">この変数を一度に複数のスレッドで読み取ったり変更したりすることは安全ではありません。&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;が別のスレッドで同時に使用されている場合、この変数を読み取ったり変更したりするのは安全ではありません。この変数は、プロセスの初期化の一部として一度、SQLiteインターフェースルーチンが呼び出される前に設定され、その後はこの変数は変更されないままであることが意図されています。</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">各エントリが異なるサウンドスライク値を持つ限り、同じ単語に対して複数のエントリを作成しても構いません。サウンドスライク値が指定されていない場合、サウンドスライクのデフォルトは単語そのものであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">2つ以上の拡張機能を静的にリンクする場合、一般的な &quot;sqlite3_extension_init &quot;というエントリーポイント名ではなく、拡張機能のファイル名に基づいたエントリーポイント名を使用することが特に重要です。一般名を使用した場合、同じシンボルの定義が複数存在し、リンクは失敗します。</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">同じ関数の複数の実装を同じ名前で登録することができますが、引数の数や優先するテキストエンコーディングが異なる場合もあります。SQLite は、その SQL 関数の使用方法に最も近い実装を使用します。負ではない nArg パラメータを持つ関数の実装は、負の nArg パラメータを持つ関数の実装よりもマッチします。優先されるテキストエンコーディングがデータベースのエンコーディングと一致する関数は、エンコーディングが異なる関数よりも一致します。エンコーディングの違いがUTF16leとUTF16beの間にある関数は、エンコーディングの違いがUTF8とUTF16の間にある関数よりも近い一致となります。</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">ライブラリコンパイル時のCプリプロセッサシンボル&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;がこのプラグマ設定を上書きする可能性があります。次の表は、&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;プリプロセッサマクロとtemp_storeプラグマの相互作用をまとめたものです。</target>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">証明機能の将来の拡張により、特定の組み込み関数へのNULL入力が常にNULL応答になることを認識できるようになる可能性があります。しかし、すべての組み込み関数がそのプロパティを持っているわけではありません（たとえば、&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;）。もちろん、証明者が&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;について推論することはできません。</target>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">SQLITE_OMIT _...オプションの事前定義されたセットで動作する特別な&lt;a href=&quot;amalgamation&quot;&gt;融合&lt;/a&gt;を構築することが可能です。そのための手順は、&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...のドキュメントに記載&lt;/a&gt;されています。</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">1つのデータベースハンドルに接続された複数のセッションオブジェクトを作成することができます。</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">もちろん、カスタムフォーマットや pile-of-files フォーマットを拡張することも可能ですが、それを行うのははるかに難しいことが多いです。インデックスが追加された場合、対応するテーブルを変更するすべてのアプリケーションコードは、それらのインデックスを最新の状態に保つように配置され、修正されなければなりません。カラムが追加された場合は、対応するテーブルにアクセスするすべてのアプリケーションコードを配置し、新しいカラムを考慮に入れるように修正しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">関数の2つの形式の引数の数が異なる限り、単純な関数と同じ名前の集約関数を持つことができます。たとえば、単一の引数を持つ&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max（）&lt;/a&gt;関数は集約であり、2つ以上の引数を持つ&lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max（）&lt;/a&gt;関数は単純な関数です。通常、集計関数はウィンドウ関数としても使用できます。</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">SQLiteがSELECT DISTINCTとUNIONの目的のためにNULLを別個のものとして扱うようにすることが可能です。これを行うには、 &lt;code&gt;sqliteInt.h&lt;/code&gt; ソースファイルのNULL_ALWAYS_DISTINCT #defineの値を変更して再コンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">コマンドの実行前後に&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt; APIから返された値を確認することで、 'merge'コマンドがマージするBツリーを見つけたかどうかを判断できます。2つの値の差が2以上の場合、作業は実行されています。差が2未満の場合、 'merge'コマンドは何もしませんでした。この場合、少なくともFTSテーブルが次に更新されるまでは、同じ「マージ」コマンドを再度実行する必要はありません。</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">t2 &quot;テーブルに書き込むことが可能で、インデックスの内容を変更することができます。しかし、そうすると、&quot;t1bc &quot;インデックスは親テーブル &quot;t1 &quot;と同期しなくなってしまいます。同期が取れていないインデックスは、正しくないクエリ結果をもたらす可能性がある。</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">アプリケーションは、明示的にROLLBACKコマンドを発行することによって、上記のエラーに応答することが推奨される。エラー応答によってトランザクションが既に自動的にロールバックされている場合、ROLLBACKコマンドはエラーで失敗しますが、これによって害はありません。</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">現在データベース操作を実行しているスレッドとは別のスレッドからこのルーチンを呼び出しても安全です。しかし、sqlite3_interrupt（）が戻る前に閉じられている、または閉じられる可能性のある&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;でこのルーチンを呼び出すのは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">現在データベース操作を実行しているスレッドとは別のスレッドからこのルーチンを呼び出しても安全です。しかし、sqlite3_interrupt（）が戻る前に閉じられている、または閉じられる可能性のある&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;でこのルーチンを呼び出すのは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">コールバックが関連するテーブルへの書き込みを含む SQL 文を xConflict コールバック内から実行しても安全です。これを使用して、アプリケーションの競合解決戦略をさらにカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">SQLite の拡張機能では、サブコンポーネント間や拡張機能とアプリケーション間で非 SQL 値を通信するのが便利な場合があります。いくつかの例があります。</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">外部コンテンツFTS5テーブルのコンテンツがコンテンツテーブルと最新の状態に保たれていることを確認することは、依然としてユーザーの責任である。これを行う1つの方法は、トリガーを使用することです。例えば、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">この関数の呼び出しに成功した後、バッファアロケーションを解放するために、最終的に*ppOutポインタでsqlite3_free()を呼び出すのは呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）に&lt;/a&gt;渡してイテレータを最終的に破棄するのは呼び出し側の責任です。変更セット（pChangeset）を含むバッファは、イテレータが破棄されるまで有効である必要があります。</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">&lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）に&lt;/a&gt;渡してイテレータを最終的に破棄するのは呼び出し側の責任です。変更セット（pChangeset）を含むバッファは、イテレータが破棄されるまで有効である必要があります。</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">確かに、アプリケーションが信頼できないソースから完全なバイナリSQLiteデータベースファイルをインポートすることがあり、そのようなインポートが攻撃のベクトルとなる可能性があります。しかし、SQLite のコードパスは限られており、非常によくテストされています。また、信頼されていないデータベースを読みたいアプリケーションには、使用前に攻撃の可能性を検出するための事前検証ルーチンが用意されています。</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">通常、同じ名前のテーブル、インデックス、ビューが既に存在するデータベースに新しいテーブルを作成しようとするとエラーになります。しかし、&quot;IF NOT EXISTS &quot;句がCREATE TABLE文の一部として指定され、同名のテーブルやビューが既に存在する場合、CREATE TABLEコマンドは何の効果もありません(エラーメッセージも返されません)。IF NOT EXISTS &quot;句が指定されていても、既存のインデックスのためにテーブルを作成できない場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;式のインデックス&lt;/a&gt;を含むデータベースでは使用できません。</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">マージにコンフリクトが発生している可能性があります。コンフリクトは、同じ行のコードが丸(1)と(4)と丸(2)と(3)の間で異なる方法で変更された場合に発生します。merge コマンドは、競合があった場合にその旨を通知し、競合している行の両方のバージョンを出力に含めます。競合を含むファイルを表示し、手動で競合を解決する必要があります。</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">左側に(文字列やブロブではなく)数値を持つことで、LIKEやGLOB演算子を真にすることはできないはずです。これは、どちらかを意味します。</target>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">これらの機能を実装するためには、それぞれがデータベースファイル形式に互換性のない変更を必要とするため、バージョン3.0に移行する必要がありました。APIのクリーンアップのような他の互換性のない変更は、互換性のない変更を一度に済ませるのが最善であるという理論のもとに、同時に導入されました。</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">unicode (UTF8)テキストで動作します。</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">そのマスター・ジャーナルが存在するか、マスター・ジャーナル名が空文字列であり</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">そのサイズは512バイトよりも大きく</target>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">J.J.M.ロブソン &quot;動的ストレージ割り当てに関するいくつかの関数の境界&quot;</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON サポート</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">順番に参加する</target>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">結合の並べ替えは自動的に行われ、通常は十分に機能します。特に、利用可能なインデックスに関する統計を収集するために&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;が使用されている場合は、プログラマが考える必要はありません。ただし、プログラマーからのヒントが必要になる場合があります。たとえば、次のスキーマについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">ジャーナルファイル形式</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">ジャーナルヘッダー形式</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">ジャーナルレコード形式</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">計算機学会誌</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">データベースのページを追記する</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">ページを追悼する</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">ユリウスの日番号</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">レジスタP1の値がFalseの場合はP2にジャンプします。値が0の数値の場合はFalseとみなされます。P1の値がNULLの場合は、P3が0でない場合にのみジャンプします。</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">レジスタP1の値がNULLの場合はP2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">レジスタP1の値がNULLでなければP2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">レジスタP1の値が真であればP2にジャンプします。数値で0以外の値であれば真とみなされます。P1の値がNULLの場合は、P3が0でない場合にのみジャンプします。</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">最新の&lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;命令で、P1ベクトルがP2ベクトルに等しいかそれよりも小さいかによって、アドレスP1、P2、またはP3にある命令にジャンプします。</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">レジスタP1のアドレスの次の命令にジャンプします。ジャンプ後、レジスタP1は未定義となります。</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">ZIPアーカイブを管理するための「zip」プログラムと、Tarballを管理するための&lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;「tar」プログラム&lt;/a&gt;があるように、SQLアーカイブを管理するための「sqlar」プログラムが存在します。 「sqlar」プログラムは、新しいSQLiteアーカイブを作成したり、既存のアーカイブの内容を一覧表示したり、アーカイブからファイルを追加または削除したり、アーカイブからファイルを抽出したりできます。別の「sqlarfs」プログラムは、SQLiteアーカイブを&lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuseファイルシステム&lt;/a&gt;としてマウントできます。</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">あなたの人生の行動を常に見守ってください。</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">目の前の死を毎日維持してください。</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">NUMERICにキャストする際には、整数の完全な精度を保つようにしてください(可能であれば)。チケット #2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">キーポイント。</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">このエッセイからの主なポイント。</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">生のデータベースファイルの内容を格納するキー/値のストア。キーはページ番号、値はバイナリページの内容です。</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">キーワード引数は、オプションで引用符で囲むことができます。（例： &lt;code&gt;'yes' [FALSE]&lt;/code&gt; 。）一部のプラグマは、引数として文字列リテラルを取ります。pragmaがキーワード引数を取る場合、通常は同等の数値も受け取ります。たとえば、「0」と「いいえ」は「1」と「はい」と同じ意味です。設定の値を照会すると、多くのプラグマはキーワードではなく数値を返します。</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">神はどこでもあなたを見ていると確信しています。</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">左結合</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">LEFT JOINの排除は、LEFT JOINがビューの内部で使用され、LEFT JOINの右側のテーブルの列がどれも参照されないような方法でビューが使用されている場合によく発生します。</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">LEFT JOIN強度低下最適化</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">LEFT OUTER JOINは実装されていますが、RIGHT OUTER JOINやFULL OUTER JOINは実装されていません。</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">LIKE最適化</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">COLLATE NOCASE を持つカラムで LIKE 最適化が動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0では行が表示されません。すべての行を表示するにはLIMIT -1を使用してください。</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0がサブクエリで動作するようになりました</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">大容量のWALファイル</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">最終インサート ロイド</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">その後、図中の丸(4)で示すように、SQLite バージョン 3.6.16 がリリースされます。この時点で、プライベートブランチのメンテナは、(1)から(4)への変更をすべてマージし、それらの変更を(3)に適用します。その結果、バージョン(5)はSQLite 3.6.16に編集を加えたものになります。</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">リーディングスペースは削除されています。</target>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">リーフペイロード分数。32である必要があります。</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">左オペランド</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">左のオペランドが見つかりました。</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">出力の値を左寄せにします。デフォルトは右寄せである。幅がゼロであるか、置換される値の長さよりも小さい場合、パディングはなく、&quot;-&quot; フラグは無効です。</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">レガシーバージョン(3.22.0より古い)のセッションモジュールでは、sqlite_stat1テーブルに加えられた変更を捕捉できません。sqlite3changeset_apply()関数のレガシーバージョンは、チェンジセットやパッチセットの一部であるsqlite_stat1テーブルへの変更を黙って無視します。</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">Lemonは独自のソースリポジトリを持っていません。むしろ、Lemon は SQLite ソースツリーの中のいくつかのファイルから構成されています。</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">レモンはLALR（1）パーサーを生成します。その操作は、より身近なツールである&lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt;や&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;に似ていますが、Lemonは次のような重要な改善を加えています。</target>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">レモンには「フォールバック」トークンという概念があります。SQL言語には多数のキーワードが含まれており、これらのキーワードは識別子名と衝突する可能性があります。Lemonは、いくつかのキーワードを識別子に &quot;フォールバック &quot;することができるように指定する機能を持っています。キーワードが構文エラーとなるコンテキストで入力トークンストリームに現れた場合、構文エラーが発生する前に、トークンは自動的にそのフォールバックに変換されます。この機能により、パーサは識別子として使用される予約語に対して非常に寛容になることができます。</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">レモンは、構文エラーや他のアボートされたパースに続くメモリや他のリソースを取り戻すために使用できる非終端デストラクタの概念を持っています。</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">レモンは、&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;拡張機能でクエリパターン式の解析を生成するためにも使用されます。この場合、入力文法ファイルは&lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">レモンはSQLiteでは2箇所で使われています。</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">Lemonは文法ファイルルールの条件付きコンパイルをサポートしているので、コンパイル時のオプションに応じて異なるパーサーを生成することができます。</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">Lemonは、D.Richard Hipp(SQLiteの生みの親でもある)が1987年から1992年の間にデューク大学の大学院に在籍していた時に書いたものです。Lemonのオリジナルの作成日は失われていますが、おそらく1990年頃のことでしょう。LemonはLALR(1)パーサを生成します。Limeという名前のLL(1)パーサ生成ツールがありましたが、Limeのソースコードは失われています。</target>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">長さ指定</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">管理が少ないということは、プログラマーがソフトウェア(この場合はSQLite)の作業に時間を割いて、バージョン管理システムと格闘する時間が少ないということです。</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">使用メモリの削減</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">KをM+((P-M)%(U-4)とする。)</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">X を ((U-12)*64/255)-23 とする。ペイロードサイズPがX以下の場合、ペイロード全体がb-treeページに格納されます。M を ((U-12)*32/255)-23 とし、K を M+((P-M)%(U-4))とします。PがXより大きい場合、インデックスのb-treeページに格納されているバイト数は、KがX以下であればKであり、そうでなければMである。インデックスページに格納されているバイト数は、M以下になることはありません。</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">X を U-35 とする。ペイロードサイズPがX以下の場合、ペイロード全体がb-treeリーフページに格納されます。M を ((U-12)*32/255)-23 とし、K を M+((P-M)%(U-4))とする。PがXより大きい場合、テーブルのb-treeリーフページに格納されているバイト数は、KがX以下であればKであり、そうでなければMである。リーフページに格納されているバイト数はMより決して小さくない。</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">Xを部分インデックスのWHERE句の式とし、Wをインデックス付きのテーブルを使用するクエリのWHERE句とします。次に、クエリはW&amp;rArr;Xの場合、部分インデックスの使用を許可されます。ここで、&amp;rArr;演算子（通常は「暗黙的」と発音）は、「XまたはWではない」と同等の論理演算子です。したがって、特定のクエリで部分インデックスが使用可能かどうかを判断すると、1次論理の定理が証明されます。</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">Xを連続した整数{h,h+1,h+2,...,h+N}の最大の集合とします.Xの各jに対して,aPgno[j%8192]!=0となるような連続した整数{h,h+1,h+2,...,h+N}の集合は,aPgno[h%8192]==0の場合は空になります.Xの集合は,値h%8192から始まり,Xにh%8192を加え,最初のaPgno[h%8192]が0になるまでhを増加させることで簡単に計算できます.</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">データベースのページサイズ(ジャーナルヘッダのオフセット24の整数値)をNとすると、ページレコードの形式は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">データ型 &quot;u8&quot;,&quot;u16&quot;,&quot;u32 &quot;はそれぞれ長さ8,16,32ビットの符号なし整数を意味する。すると、shmファイルの最初の32768バイト単位は以下のように構成される。</target>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">アライスノードの数をM、ボブノードの数をNとすると、2つのシナリオが考えられる。最初のシナリオでは、MとNは両方とも2であるが、各ノードには数千のエッジがある。この場合,オプション1が好ましい.オプション1では,内部ループはノードのペア間にエッジが存在するかどうかをチェックし,見つかった場合にはその結果を出力します.しかし、aliceとbobのノードはそれぞれ2つしかないので、内部ループは4回しか実行されず、クエリは非常に速くなります。オプション2は、ここではもっと時間がかかります。オプション2の外側のループは2回しか実行されませんが、各aliceノードから出るエッジの数が多いので、真ん中のループは何千回も繰り返し実行しなければなりません。これはもっと遅くなります。そこで、最初のシナリオでは、オプション1を使用することを好みます。</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">Mがゼロよりも大きい場合、Mページレコードの後、ジャーナルファイルはセクタサイズの次の倍数までゼロパディングされ、別のジャーナルヘッダーが挿入されます。同じジャーナル内のすべてのジャーナルヘッダは、同じデータベースのページサイズとセクタサイズを含まなければなりません。</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">アマルガムのソースコードを使用していると仮定してみましょう。以下のようにプロジェクトにベースラインを追加します。</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">ファイルを保存するために ZIP アーカイブを使用する代わりに、OpenDocument が以下のような単一テーブルスキーマを持つ非常にシンプルな SQLite データベースを使用していたとします。</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">以下のような表記法(ロブソンの表記法と似ていますが、同じではありません)を使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">現実になりましょう。Gitが次善のユーザーエクスペリエンスを提供することに真剣に異議を唱える人はほとんどいません。基礎となる実装の多くは、ユーザーインターフェイスに表示されます。インターフェイスが非常に悪いので、&lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;偽のgit manページ&lt;/a&gt;を生成するパロディサイトさえあります。</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">ここで何が起こっているのか、もう少し詳しく見てみましょう。最初のSELECTは、命令5から10までのループによって実装されています。命令5はカーソルを巻き戻すことでループを初期化します。命令6は「examp」から「2」列の値を抽出し、命令7はこれを行に変換します。命令8は空の文字列をスタックに押し込む。最後に、命令9はその行を一時テーブルに書き込みます。しかし、PutStrKeyオペコードは、スタックの先頭をレコードデータとして使用し、スタックの次の行をキーとして使用することを覚えておいてください。INSERT文では、MakeRecordオペコードによって生成された行がレコード・データであり、レコード・キーはNewRecnoオペコードによって生成された整数です。しかし、ここでは役割が逆になっており、MakeRecordによって生成された行がレコードキーで、レコードデータは単なる空の文字列です。</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">C で書かれたライブラリは、ランタイムに大きな依存性を持ちません。最小限の設定では、SQLite が必要とするのは標準 C ライブラリの以下のルーチンだけです。</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">C++やJavaで書かれたライブラリは、一般的に同じ言語で書かれたアプリケーションでしか使用できません。HaskellやJavaで書かれたアプリケーションからC++で書かれたライブラリを呼び出すことは困難です。一方、Cで書かれたライブラリは、どのプログラミング言語からでも呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">ライブラリサイズの最適化。</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">--fileと同様に、ファイルFILEをアーカイブとして使用しますが、&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt;を使用してファイルを開き、FILEがすでに存在する場合にアーカイブがFILEの最後に追加されるようにします。</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">コンテンツレステーブルと同様に、外部コンテンツテーブルは REPLACE 競合処理をサポートしていません。REPLACE 競合処理を指定した操作は、ABORT を使用して処理されます。</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">他の仮想テーブルタイプと同様に、新しいFTSテーブルは&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントを使用して作成されます。USINGキーワードに続くモジュール名は、「fts3」または「fts4」のいずれかです。仮想テーブルモジュールの引数は空のままにできます。その場合、「content」という名前の単一のユーザー定義列を持つFTSテーブルが作成されます。または、モジュール引数にカンマ区切りの列名のリストを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">sqlite3rbu_step()と同様に、バキューム操作が終了した場合、sqlite3rbu_close()はSQLITE_DONEを返します。バキュームが終了していないがエラーが発生していない場合は、SQLITE_OKが返されます。または、エラーが発生した場合は、SQLiteエラーコードが返されます。sqlite3rbu_step()の前の呼び出しの一部としてエラーが発生した場合、sqlite3rbu_close()は同じエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">dump」コマンドと同様に、「.recover」は、データベースファイルの内容全体をテキストに変換しようとする。違いは、通常のSQLデータベースインターフェイスを使用してデータを読み込むのではなく、&quot;.recover &quot;は可能な限り多くのデータベースページから直接抽出されたデータに基づいてデータベースを再構築しようとする点である。データベースが破損している場合、&quot;.recover &quot;は通常、データベースの破損していないすべての部分からデータを復元することができますが、&quot;.dump &quot;は破損の最初の兆候に遭遇したときに停止します。</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">リミット設定</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integer_checkが&lt;/a&gt;生成する出力の量を制限します。</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">再帰降下パーサーでのスタックの過剰な使用を回避するために、JSONオブジェクトと配列の再帰の深さを制限します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">制限と警告</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">OpenDocument プレゼンテーションフォーマットの限界</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">SQLite での制限</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">で始まり、SQL文の途中ではない行はコメントとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">典型的なワークロードを代表する約30,000のSQL文を実行するテストプログラムに対してSQLiteをリンクします。</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">Linus Torvalds さんが 2006-06-27 の Git メーリングリストで違う言葉を使って同じことを言っていました。</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">定数のリスト。</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">機能のリスト。</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">オブジェクトのリスト。</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">PRAGMA一覧</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">SQLite 定数のリスト</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">SQLite 関数のリスト</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">SQLite オブジェクトのリスト</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">仮想テーブルの一覧</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">処理中の各ファイルを一覧表示します。</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">アーカイブの内容をリストアップします。引数が指定されていない場合は、すべてのファイルをリストアップします。それ以外の場合は、引数として指定されたファイルのみがリストアップされます。現在のところ、--verbose オプションはこのコマンドの動作を変更しません。将来的には変更されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">アーカイブ内のファイルを一覧表示します。</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">INの右辺のリスト値は、マテリアライズされなければならない副問い合わせとして扱われます。つまり、前の文があたかもそうであるかのように振る舞います。</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">以下にリストアップされているのは、サウンドライクなエントリを追加することが意味を持つかもしれないいくつかのケースです。具体的なエントリはアプリケーションとターゲット言語に依存します。</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">進んで聖なる朗読に耳を傾ける。</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">リテラル値(定数</target>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">リテラル値</target>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">LoC推奨ストレージフォーマット</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">拡張機能をロードする</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">テーブル間の違いをセッションに読み込む</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">差分を計算する前に、共有ライブラリまたはDLLファイルLIBRARYをSQLiteにロードします。これは、スキーマで必要とされるアプリケーション定義の&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;を追加するために使用できます。</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">ロード可能な拡張サンク</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">ロード可能な拡張機能は C コードです。ほとんどの Unix ライクなオペレーティングシステム上でコンパイルするには、通常は次のようなコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">ローカルDELETE</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">ローカルINSERT</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">ローカルUPDATE</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">ローカルタイム修飾子</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">ロック名</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">ロックオフセット</target>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">ロックと並行性</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">ロックと同時実行制御は&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;ページャーモジュール&lt;/a&gt;によって処理されます。ページャーモジュールは、SQLiteを &quot;ACID&quot;（Atomic、Consistent、Isolated、Durable）にする責任があります。ページャーモジュールは、すべての変更が一度に行われるか、まったく行われないか、2つ以上のプロセスが同時に互換性のない方法でデータベースにアクセスしようとしないこと、および変更が書き込まれると変更がすべて一度に行われるようにします。明示的に削除されるまで存続します。ページャーは、ディスクファイルの内容の一部のメモリキャッシュも提供します。</target>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">ロングオプション</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">長期サポート</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">ロングスタイルとショートスタイルの選択肢が混在していてもよい。例えば、以下のようなものが該当します。</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">より長い答え：テーブルの列を&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;として宣言すると、テーブルのその列にNULLを挿入するたびに、NULLは自動的にその列の最大値より1大きい整数に変換されます。テーブル内の他のすべての行、またはテーブルが空の場合は1。または、最大の既存の整数キー9223372036854775807が使用中の場合、未使用のキー値がランダムに選択されます。たとえば、次のようなテーブルがあるとします。</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;用のルックアサイドバッファ割り当て。</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">ルックサイドメモリアロケータ</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">たくさんのバグ修正。</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">小さなバグ修正がたくさん。</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">貞操観念を愛する。</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">断食を愛する。</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">敵を愛せ</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">後輩が大好きです。</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">データベースファイルの低レベル制御</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">低レベルシステムエラーコード</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">優先順位が最も低い(ゆるいグループ化)。</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">Mは常に((U-12)*32/255)-23です。</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">MASK ビット 0x02 が設定されます。</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Mac は unix に似ていますが、通常の共有ライブラリの規約には従いません。Mac で共有ライブラリをコンパイルするには、次のようなコマンドを使います。</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">API関数&lt;b&gt;const&lt;/b&gt;で選択したパラメーターを作成しました。これは完全に下位互換性があるはずです。</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">メイド&lt;a href=&quot;testing#aflfuzz&quot;&gt;アメリカンファジーロプはfuzzer&lt;/a&gt;のSQLiteのの標準部品&lt;a href=&quot;testing&quot;&gt;テスト戦略&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">CACHE_SIZE プラグマを永続化しました。</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">マジックナンバー。0x377f0682または0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">MC / DCを100％に維持することは、面倒で時間がかかります。完全なカバレッジテストを維持するために必要な労力のレベルは、通常のアプリケーションではおそらく費用対効果が高くありません。ただし、SQLiteのような&lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;非常に広く展開&lt;/a&gt;されているインフラストラクチャライブラリ、特にその性質上過去の間違いを「記憶」しているデータベースライブラリに対しては、フルカバレッジテストが正当化されると考えています。</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">SQLiteのプライベートブランチの管理</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">メイクは&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;）（sqlite3_compileoption_used&lt;/a&gt;に応答&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;コンパイル時のオプション。</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">WinCE はこの関数をサポートしていないため、AreFileApisANSI()を WinCE で動作しないマクロにするようにしました。</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">コマンドラインシェルからのCSV(カンマ区切りの値)出力を、より一般的な慣習に近いものにする</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">複合SELECT文でLIMITが機能するようにします。</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">レジスタP1...P1+P3をレジスタP2...P2+P3にコピーします。</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">ソートする際には、数値とテキスト値を区別するようにしてください。テキスト値は memcmp()に従ってソートします。数値は数値順にソートします。</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">レジスタP1をレジスタP2に浅くコピーする。</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">新しいページを確保するためにあらゆる努力をしてください。新しいページの割り当てが事実上不可能な場合のみ NULL を返します。</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">太陽が沈む前に敵と仲直りしましょう。</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">DISTINCT演算子が降順のインデックスを使用して実装されている場合でも、ORDER BYが行を昇順で配置することを確認してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9eの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">シェルの&lt;b&gt;.dump&lt;/b&gt;コマンドの出力で、対応するTABLEの後にVIEWが作成されていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">すべての個々のデータベースファイルにEXCLUSIVEロックと有効なジャーナルがあることを確認してください。</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">停電が発生しても、電源が復旧した後もデータが残っているように、すべてのロールバックジャーナルデータが実際にディスクの表面に書き込まれていることを確認してください(オペレーティングシステムやディスクコントローラのキャッシュに保持されているだけではありません)。</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">INSERTのVALUES句の関数式が正しいことを確認してください。</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">データベースファイル名は8+3ファイル名の形式に従い、空の名前や拡張子を持たないようにしてください。言い換えれば、データベースファイル名には、ベース名に1文字から8文字、拡張子に1文字から3文字の間の文字を含める必要があります。空の拡張子は許されません。</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">RESERVEDロックで接続がブロックされた場合、ロックが解除された後も接続を継続できるようにしてください。(チケット#3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">単一ステートメント内の複数のトリガーからの&lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata（）&lt;/a&gt;値が互いに干渉しないことを確認してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">バッファーサイズが1未満の場合、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;インターフェイスがバッファーをゼロで終了しないことを確認してください。チケット＃2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">MIN()および MAX()の最適化がサブクエリ内で動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">ORDER BY LIMIT最適化（チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09eから&lt;/a&gt;）がINTEGER PRIMARY KEYのIN演算子で機能することを確認します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454cの&lt;/a&gt;修正</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">TCL言語インタフェースが64ビットマシン上で64ビット整数で正しく動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">malloc()が失敗した場合に、インメモリバックエンドのレスポンスが正気であることを確認するようにしてください。</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">クエリオプティマイザが複合SELECT文のすべての項の依存関係をチェックするようにしてください。チケット番号#2640。</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">各SQLコマンドの最後にセミコロンを入力してください! sqlite3プログラムは、SQLコマンドが完了したときにセミコロンを探します。もしセミコロンを省略した場合、sqlite3は継続プロンプトを表示し、現在のSQLコマンドに追加されるテキストを入力するのを待ちます。この機能により、複数行にまたがるSQLコマンドを入力することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">そのスクリプトを実行可能にして $PATH に置いてください。そして、以下のようにkvtestプログラムをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">再び「as」キーワードを任意にします。</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;オプションを使用してコンパイルする場合、&lt;a href=&quot;dbstat&quot;&gt;dbstat仮想テーブル&lt;/a&gt;を標準ビルドの一部にします。</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">GLOBとLIKE演算子をプログラマがオーバーライドできる関数にする。これにより、例えばLIKE演算子を大文字小文字を区別するように変更することができます。</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">LIMIT句が副問い合わせで動作するようにしました。(ただし、ORDER BYはまだ動作しません)。</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">ライブラリをスレッドセーフにする。(コードはあり、動作しているように見えますが、ストレスをかけていません)。</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">Windows 用のコンパイルと Unix 用のコンパイルを検出するために、 os.h ヘッダファイルをより強固なものにしました。</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;でOVERLAPPEDを使用して、一部のシステムコールを回避し、パフォーマンスを向上させます。</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">必要に応じて、&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張の&lt;/a&gt;ワンパスUPDATEおよびDELETEクエリプランを使用します。</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">Makefile の更新</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Makefileの更新と雑なバグ修正。</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">A.RottmannからのMakefileの更新</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">他の種類のテーブルスキーマの変更を行う</target>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">不正なデータベーステスト</target>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">コマンドラインからの SQLite アーカイブの管理</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">マニフェストタイプとBLOBのサポート</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">マニフェストタイピングとBLOBのサポート。</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">CROSS JOINを用いたクエリプランの手動制御</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">SQLITE_STAT テーブルを使用したクエリプランの手動制御</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">多くの SQLITE_OMIT_マクロは、コンパイル時に機能を省略し、ライブラリのフットプリントを減らすために挿入します。</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">多くの SQLite 関数は、成功か失敗かを示すために、ここで示したセットから整数の結果コードを返します。</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">SQLiteでは多くの小さなクエリが効率的</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">多くのアプリケーションは、シャットダウン時に&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;を呼び出して&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;を破棄します。または、例えば、そのようSQLiteのを使用するアプリケーション&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイルフォーマットは、&lt;/a&gt;開くことがあります&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続を&lt;/a&gt;ファイル/開く]メニューのアクションに応じて、その後、対応する破壊する&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;ファイル/閉じるメニューに対応しています。</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">多くのアプリケーションでは、SQLite をエンタープライズ RDBMS の関連コンテンツのキャッシュとして使用しています。これにより、ほとんどのクエリがローカルキャッシュに対して実行され、ネットワークの往復を避けることができるため、待ち時間が短縮されます。また、ネットワークと中央データベースサーバの負荷も軽減されます。また、多くの場合、ネットワークが停止してもクライアント側のアプリケーションが動作を継続できることを意味します。</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#coverage&quot;&gt;100％のブランチテストカバレッジの&lt;/a&gt;提供をサポートするための、多くのコードの簡素化と不明瞭なバグ修正。</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">多くのドキュメントの更新</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">完全で機能するロード可能な拡張機能の多くの例は、&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;サブディレクトリのSQLiteソースツリーにあります。そのディレクトリ内の各ファイルは個別の拡張子です。ドキュメントは、ファイルのヘッダーコメントによって提供されます。&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt;サブディレクトリにあるいくつかの拡張機能について簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">configure スクリプトの多くの改善とクリーンアップ</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">シェルの多くの改良と強化。</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">テストスイートの多くの改善。テストカバレッジが98%を超えるようになりました</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">多くのマイクロ最適化により、以前のリリースと比較して、同じ数のCPUサイクルで20.3％多い作業が行われます。&lt;a href=&quot;#version_3_8_0&quot;&gt;バージョン3.8.0&lt;/a&gt;以降の累積パフォーマンスの向上は61％です。（使用して測定&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrindを&lt;/a&gt;上&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.cの&lt;/a&gt; GCC 4.8.1と-OsとUbuntuの13.10のx64上のワークロード。あなたのパフォーマンスは変更になる場合があります。）</target>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">多くのマイクロ最適化が行われ、その結果、以前のリリースよりも高速なライブラリが得られました。</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">多くのマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">多くの迷惑なバグが修正されました。</target>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C言語インターフェイス&lt;/a&gt;のルーチンの多くは、成功または失敗のいずれかを示す数値の結果コードを返し、失敗の場合は、失敗の原因についての何らかの考えを提供します。このドキュメントでは、これらの数値結果コードのそれぞれの意味を説明するよう努めています。</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">多くの操作、特に I/O を多用する操作は、コンテンツをカーネル空間とユーザ空間の間でコピーする必要があるため、高速化することができます。</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">多くのプログラムは、&lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen（）&lt;/a&gt;、&lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread（）&lt;/a&gt;、および&lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite（）&lt;/a&gt;を使用して、自社開発の形式でデータのファイルを作成および管理します。 SQLiteはこれらの代替として特にうまく機能します</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">多くの読者が、過去の開発活動の履歴を表示するのに適したサードパーティ製の Git 用 GUI を推奨しています。その中には、ネイティブの Git や GitHub よりもうまく機能するものもあるかもしれませんが、いずれも Git が同期した際に歴史的なブランチ名を保存しないという事実に阻まれます。また、他のツールの方が優れているとしても、必要な情報を得るためにサードパーティのツールを使わなければならないという事実は、コアシステムの良さをよく表していません。</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">多くの小さなパフォーマンスの最適化。</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">多くのバグ修正と互換性の強化。</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">多くの、多くのマイナーなバグ修正とドキュメントの更新。</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">マスタージャーナルポインター</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">マスタージャーナル</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">マスタージャーナル</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">クエリ1とクエリ2の両方が一致した場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">クエリ1またはクエリ2のいずれかが一致した場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">クエリ1がマッチし、クエリ2がマッチしない場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">マッチ情報b旗</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">マッチインフォ×フラグ</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">マッチ情報と旗</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">ビューとサブクエリのマテリアライゼーション</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">数学演算子（+、-、*、/、％、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、＆、|）は、両方のオペランドを数値のように解釈します。 STRINGまたはBLOBオペランドは、自動的にREALまたはINTEGER値に変換されます。 STRINGまたはBLOBが実数のように見える場合（小数点または指数がある場合）、または値が64ビット符号付き整数として表すことができる範囲外の場合、REALに変換されます。それ以外の場合、オペランドはINTEGERに変換されます。数学的オペランドの暗黙の型変換は、&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CASTからNUMERICへの&lt;/a&gt;文字列のわずかな違いであり、実数のように見えるが小数部分がないBLOB値は、CASTからNUMERICの場合のようにINTEGERに変換されるのではなく、REALとして保持され&lt;a href=&quot;lang_expr#castexpr&quot;&gt;ます。&lt;/a&gt;。 STRINGまたはBLOBからREALまたはINTEGERへの変換は、不可逆的で不可逆的であっても実行されます。一部の数学演算子（％、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、＆、および|）は、INTEGERオペランドを必要とします。これらの演算子の場合、REALオペランドは&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CASTからINTEGERへの&lt;/a&gt;変換と同じ方法でINTEGERに変換されます。 &amp;lt;&amp;lt;、&amp;gt;&amp;gt;、＆、および|演算子は常にINTEGER（またはNULL）の結果を返しますが、％演算子はそのオペランドのタイプに応じてINTEGERまたはREAL（またはNULL）を返します。算術演算子のNULLオペランドは、NULLの結果になります。決して数値ではなく、NULLでない数学演算子のオペランドは、0または0.0に変換されます。ゼロによる除算はNULLの結果を与えます。</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">最大組み込みペイロード率。64でなければなりません。</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">最大行数</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">最大 xShmLock インデックス</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">マックスオープンパラメータ</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">悪を行わず善を行うことができますように</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">自分を許し、人を許すことができますように</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">あなたが自由に分かち合い、与える以上のものを取ることがありませんように。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">これらのコマンドを使用して、データベースからのブロブの読み込みと個々のファイルからの読み込みのパフォーマンスを測定します。</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">updateオプションを追加して、書き込みパフォーマンスを測定します。これにより、ブロブは全く同じサイズの別のランダムなブロブで上書きされます。</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">Ubuntu 16.04,x64,gcc 5.4.0,-Osでcachegrindを使用して測定しました。</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">上記の測定は、2017-10-08のSQLiteバージョン&lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt;を使用して行われました。</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">SQLiteでのCPU使用量の測定と削減</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">メモリ割り当てルーチン</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">メモリわりあてサブシステム</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">メモリアロケータの統計</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">メモリースロット</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;、...）開始時間オプションと&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;コンパイル時間オプションの組み合わせを使用すると、メモリアカウンティングが無効になります。</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;、...）開始時間オプションと&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;コンパイル時間オプションの組み合わせを使用すると、メモリアカウンティングが無効になります。</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0でコンパイルされていない限り、メモリ割り当て統計はデフォルトで有効になっています。この場合、メモリ割り当て統計はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0でコンパイルされていない限り、メモリ割り当て統計はデフォルトで有効になっています。この場合、メモリ割り当て統計はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">メモリ割り当て、大文字と小文字を区別しない文字列比較ルーチン、移植可能なテキストから数値への変換ルーチン、およびその他のユーティリティは&lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.cにあり&lt;/a&gt;ます。パーサーが使用するシンボルテーブルは、&lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.cにある&lt;/a&gt;ハッシュテーブルによって維持されます。&lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.cの&lt;/a&gt;ソースファイルは、Unicode変換サブルーチンが含まれています。 SQLiteは、&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.cに&lt;/a&gt;独自の実装の&lt;a href=&quot;printf&quot;&gt;printf（）&lt;/a&gt;（一部拡張あり）と、random.cに独自の疑似乱数ジェネレータ（PRNG）を&lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;持ってい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">メモリ統計</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt;によって返される情報を保持するメモリは、malloc（）から取得されます。しかし、呼び出し側の関数はこの情報を直接解放しようとするべきではありません。代わりに、テーブルが不要になったときにテーブル&lt;b&gt;全体&lt;/b&gt;を&lt;b&gt;sqlite_free_table&lt;/b&gt;に渡します。結果セットが空の場合に返されるようなNULLポインタで&lt;b&gt;sqlite_free_table&lt;/b&gt;を呼び出すのは安全です。</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">メモリマップI/O</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4 と memsys6 は 2007 年頃に導入された実験的なメモリアロケータで、その後、新しい価値を与えないことが明らかになったため、2008 年頃にソースツリーから削除されました。</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">開発の変更点をメインのトランクにマージしました。BTree ファイル構造を使用するための将来の作業では、別の CVS ソースツリーを使用することになります。この CVS ツリーは、SQLite の GDBM バージョンのみをサポートし続けます。</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatchは、JSONオブジェクトの要素を追加、変更、または削除できるため、JSONオブジェクトの場合、json_patch（）ルーチンは、&lt;a href=&quot;json1#jset&quot;&gt;json_set（）&lt;/a&gt;および&lt;a href=&quot;json1#jrm&quot;&gt;json_remove（）の&lt;/a&gt;汎用的な置き換えです。ただし、MergePatchはJSON配列オブジェクトをアトミックとして扱います。MergePatchは、配列に追加したり、配列の個々の要素を変更したりすることはできません。アレイ全体を1つのユニットとして挿入、置換、または削除することしかできません。したがって、json_patch（）は、配列、特に多くの部分構造を持つ配列を含むJSONを処理する場合にはあまり役に立ちません。</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">&lt;a href=&quot;sessionintro&quot;&gt;セッション&lt;/a&gt;拡張をトランクにマージしました。</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">メタデータは、この関数の5番目以降の引数として渡されたメモリの位置に書き込むことで返されます。これらの引数のいずれかがNULLであっても構いませんが、その場合はメタデータの対応する要素は省略されます。</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">メソッド(2)は、(1)と(3)の中間点を提供します。このメソッドを使用すると、'1s*'のようなクエリは、リテラルトークン &quot;1st &quot;を含むドキュメントにはマッチしますが、&quot;first &quot;にはマッチしません(トークナイザーが接頭辞の同義語を提供できないことを前提としています)。しかし、'1st'のようなプレフィックスではないクエリは、&quot;1st &quot;と &quot;first &quot;に対してマッチします。この方法では、FTSインデックスに余分なエントリが追加されないので、余分なディスクスペースを必要としません。一方で、FTSインデックスの個別のクエリが各同義語に対して必要となるため、MATCHクエリの実行にはより多くのCPUサイクルが必要となるかもしれません。</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;、&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;、&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;、&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp（）&lt;/a&gt;、&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;、&lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">メソッド：&lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add（）&lt;/a&gt;、&lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">数百万、数百万のテストケース</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">埋込ペイロードの最小割合。32でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">最小行数</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">ホームページの軽微な修正。</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">より多くのコンパイラをサポートするためのマイナーな構文の変更。</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">他のコードを少し速く実行するために、他のコードを微調整しました。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">その他の&lt;a href=&quot;cpu#microopt&quot;&gt;マイクロ最適化&lt;/a&gt;により、CPU使用率が約2.1％削減されます。</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">その他のコードサイズの最適化とバグ修正</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">その他のドキュメントの強化。</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">その他のマイクロ最適化により、一般的なワークロードでのCPU使用率が7％以上削減されます。このリリースのほとんどの最適化はフロントエンドで行われました（&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">その他のマイクロ最適化により、前のリリースと比較して、同じ数のCPUサイクルで22.3％多い作業が発生します。SQLiteは、&lt;a href=&quot;#version_3_8_0&quot;&gt;バージョン3.8.0の&lt;/a&gt; 2倍、&lt;a href=&quot;#version_3_3_9&quot;&gt;バージョン3.3.9の&lt;/a&gt; 3倍の速度で実行されます。（使用して測定&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrindを&lt;/a&gt;上&lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.cの&lt;/a&gt; GCC 4.8.2と-OsとUbuntuの14.04のx64上のワークロード。あなたのパフォーマンスは変更になる場合があります。）</target>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">その他のマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">その他の最適化により、&lt;a href=&quot;cpu&quot;&gt;使用されるCPUサイクルが&lt;/a&gt; 2％削減されます。</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">その他の性能強化</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">借金」「ツェツェ」「グエン」「ヴァンヌイ」などの雑多な問題語</target>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">コールバックの欠落</target>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">最新のファイルシステムは、ディスクアクセスがシーケンシャルである場合に高速に動作します。したがって、データベースファイルのコンテンツが順次ページにある場合、SQLiteはより高速に実行されます。データベース内のページのどの部分がシーケンシャルであるかを見つける（したがって、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUMを&lt;/a&gt;いつ行うかを決定するのに役立つ測定値を取得する）には、次のようなクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">幅広い組み込みシステムをサポートするための&lt;a href=&quot;c3ref/vfs&quot;&gt;仮想ファイルシステム&lt;/a&gt;インターフェイスの変更。詳細については、&lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt;を参照してください。***互換性がない可能性のある変更***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">パーサーテーブルが4倍小さくなるように、&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーターを&lt;/a&gt;変更しました。</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;および&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt;を変更して、バッファサイズの計算で「+4」のマジックナンバーを削除しました。</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">明示的に要求された場合、組み込みSQLITE_MASTERテーブルのスキーマを出力するように&lt;b&gt;sqlite&lt;/b&gt;シェルプログラムを変更しました。</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">新しいインターフェイスルーチンを使用するように&lt;b&gt;sqlite&lt;/b&gt;シェルプログラムを変更しました。</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">&quot;ls&quot;がファイル名を印刷する方法と同様に、複数の列でテーブルのリストを印刷するために、新しいsqlite_get_table（）APIを利用するように&lt;b&gt;sqlite&lt;/b&gt;シェルを変更しました。</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">&quot;.schema&quot;コマンドの出力で各CREATEステートメントの最後にセミコロンを出力するように&lt;b&gt;sqlite&lt;/b&gt;シェルを変更しました。</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">B-Tree モジュールと Pager モジュールを変更し、実データを含まないディスクページ(フリーページ)はジャーナル化されず、変更されてもメモリからディスクに書き戻されないようにしました。これは、ページには実データが含まれていないので、データベースの整合性には影響しませんが、大規模な INSERT 操作が約 2.5 倍、大規模な DELETE が約 5 倍速くなります。</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">ジャーナルファイル形式を変更し、OSのクラッシュや停電後に発生する破損に強くなるようにしました。</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">TCLインターフェイスを変更して、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">システムの負荷とプロセッサ速度に依存するテストを識別し、それらの (まれな)テストの 1 つに失敗したからといって、ライブラリが誤動作しているとは限らないことをユーザーに警告するために、テストスクリプトを変更します。コードに変更はありません。</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">データベースページの内容を変更する</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">データベースページの変更、追加、または切り捨て</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">より積極的な&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">片方またはもう片方が常に偽である場合のAND演算子のより積極的な最適化。</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">より複雑なクエリでは、一時テーブルを避けるためにクエリの平坦化を採用できる場合とできない場合があります。クエリを平坦化できるかどうかは、副問い合わせや外部問い合わせに集約関数、ORDER BY句やGROUP BY句、LIMIT句などが含まれているかどうかに依存します。問い合わせが平坦化できる場合とできない場合のルールは非常に複雑であり、このドキュメントの範囲を超えています。</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">より効率的なブーリアン値のエンコーディングにより、データベースファイルが小さくなります。</target>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">特にアプリケーションが数百または数千のカスタム関数を定義している場合、アプリケーション&lt;a href=&quot;c3ref/create_function&quot;&gt;定義のSQL関数の&lt;/a&gt;より効率的な処理。</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">WindowsでのsqliteFileExists()のより効率的な実装。(Joel Luscyによる)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">メモリ切れエラーの処理がより強固になりました。</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">他にも提案が...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">1 つのクエリに複数の NEAR 演算子が出現することがあります。この場合、near演算子で区切られた用語または語句の各ペアは、文書内で互いに指定された近接度内に出現しなければなりません。上記の例のブロックと同じテーブルとデータを使用します。</target>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">ほとんどのR*Treeクエリは深度優先検索を使用します。これは、rScoreをiLevelと等しく設定することで実現されます。深さ優先検索は、優先度キュー内の要素数を最小限に抑えることができるため、通常は優先度優先検索が好まれます。しかし、アプリケーションによっては、rScore を mxLevel-iLevel に設定することで実現できる、幅優先検索を好む場合もあります。rScore のためにより複雑な式を作成することで、アプリケーションは、サブツリーが検索され、リーフ R*Tree エントリが返される順序を詳細に制御することができます。例えば、何百万もの R*Tree エントリを持つアプリケーションでは、最大または最も重要なエントリが最初に返されるように rScore を配置することで、アプリケーションは最も重要な情報を素早く表示し、利用可能になるにつれて小さくて重要ではない詳細を埋めることができます。</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">ほとんどのSQLデータベースエンジン(私たちが知る限り、SQLite以外のすべてのSQLデータベースエンジン)は、静的な型付けを使用しています。静的型付けでは、値のデータ型はコンテナ、つまり値が格納されている特定のカラムによって決定されます。</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">ほとんどの SQL データベースエンジンはクライアント/サーバベースです。サーバーレスの中でも、複数のアプリケーションが同時に同じデータベースにアクセスできるのはSQLiteだけです。</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">ほとんどの SQL データベースエンジンはクライアント/サーバーベースです。サーバーレスの中でも、複数のアプリケーションが同時に同じデータベースにアクセスできるのは、この著者が知っている中ではSQLiteだけです。</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">ほとんどのSQLデータベースエンジンは、独立したサーバープロセスとして実装されています。データベースにアクセスしたいプログラムは、ある種のプロセス間通信(一般的にはTCP/IP)を使用してサーバーと通信し、サーバーにリクエストを送信して結果を受信します。SQLiteでは、このようには動作しません。SQLiteでは、データベースにアクセスしようとするプロセスは、ディスク上のデータベースファイルから直接読み書きを行います。中間のサーバープロセスはありません。</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">ほとんどのSQLデータベースエンジンは、すでに解析されたスキーマを様々なシステムテーブルに保存しています。これらのデータベースエンジンでは、ALTER TABLEは対応するシステムテーブルに変更を加えるだけです。</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">ほとんどのSQLデータベースエンジンは静的型付けを使用しています。データ型はテーブルの各列に関連付けられており、その列にはその特定のデータ型の値しか格納できません。SQLite では、マニフェスト型付けを使用することでこの制限を緩和しています。マニフェスト型付けでは、データ型は値自体のプロパティであり、値が格納されている列のプロパティではありません。このため、SQLite では、任意のデータ型の値を、そのカラムの宣言された型に関係なく、任意のカラムに格納することができます。(この規則にはいくつかの例外があります。INTEGER PRIMARY KEY カラムは整数のみを格納することができます。また、SQLiteは可能な場合には、そのカラムの宣言されたデータ型に値を強制的に格納しようとします)。</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">ほとんどのアプリケーションフォーマットは、これらの3つのカテゴリのいずれかに当てはまります。</target>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">ほとんどのアプリケーションでは、前のセクションで説明したセッションモジュールの機能のみを使用します。しかし、チェンジセットとパッチセットのブロブの使用と操作には、以下の追加機能が利用できます。</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">ほとんどのアプリケーションは、デフォルトの構成でSQLiteを使用して問題なく機能し、特別なコンパイル時の構成はありません。ほとんどの開発者は、このドキュメントを完全に無視し、特別な知識や特別なアクションを実行することなく&lt;a href=&quot;amalgamation&quot;&gt;、統合&lt;/a&gt;からSQLiteを簡単に構築できます。</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">ほとんどのビルドでは、システムメモリ割り当てルーチンも使用しています。</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">ほとんどの組み込みウィンドウ関数はフレーム仕様を無視しますが、例外は first_value()、last_value()、nth_value()です。ビルトインウィンドウ関数の呼び出しの一部としてFILTER句を指定するのは構文エラーです。</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">ほとんどのメモリ統計情報はグローバルであるため、統計情報の追跡はミューテックスでシリアル化されなければなりません。統計情報はデフォルトでオンになっていますが、無効にするオプションもあります。メモリ統計情報を無効にすることで、SQLiteはメモリの割り当てや解放のたびにミューテックスを入力したり残したりする必要がなくなります。この節約は、ミューテックス処理が高価なシステムでは顕著です。メモリ統計情報を無効にするには、以下のインターフェイスを起動時に使用します。</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">ほとんどのオブジェクト参照は、特定のタイプのオブジェクトにのみ解決できます（たとえば、DROP TABLEステートメントの一部である参照は、テーブルオブジェクトにのみ解決でき、インデックス、トリガー、またはビューには解決できません）。ただし、コンテキストによっては（&lt;a href=&quot;lang_reindex&quot;&gt;REINDEXなど&lt;/a&gt;）、オブジェクト参照が複数のタイプのオブジェクトに解決される場合があります。名前付きオブジェクトのデータベーススキーマを検索する場合、参照のコンテキストで使用できないタイプのオブジェクトは常に無視されます。</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">SQLiteソースツリーのコードのほとんどは、純粋に&lt;a href=&quot;testing&quot;&gt;テストと検証に&lt;/a&gt;専念しています。信頼性はSQLiteにとって重要です。テストインフラストラクチャのタスクの1つは、SQLiteが動的に割り当てられたメモリを誤用しないこと、SQLiteがメモリをリークしないこと、SQLiteが動的メモリ割り当ての失敗に正しく応答することを確認することです。</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">ほとんどの場合、sqlite3は入力行を読み込んでSQLiteライブラリに渡して実行します。しかし、ドット(&quot;.&quot;)で始まる入力行は、sqlite3プログラム自身によって傍受され、解釈されます。これらの &quot;ドットコマンド &quot;は通常、クエリの出力形式を変更したり、パッケージ化されたクエリ文を実行したりするために使用されます。元々ドットコマンドは数個しかありませんでしたが、長年にわたって多くの新機能が蓄積され、今日では60個以上になりました。</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">ほとんどの場合、SQLite のクエリプランナは良い仕事をしてくれます。しかし、クエリプランナが動作するためにはインデックスが必要です。これらのインデックスは通常、プログラマが追加しなければなりません。まれに、クエリプランナのAIが最適でないアルゴリズムを選択することがあります。そのような場合には、プログラマはクエリプランナがより良い仕事をするのを助けるために、追加のヒントを提供したいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">他のほとんどの SQL データベースエンジンは、ほとんどのテーブルの各行に一定量のディスク容量を割り当てています。これらのエンジンは、長さの異なる BLOB や CLOB を扱うために特別な仕掛けをしています。しかし、ほとんどのテーブルでは、ある列をVARCHAR(100)と宣言すると、その列に実際にどれだけの情報が格納されているかに関わらず、データベースエンジンは100バイトのディスク領域を割り当てます。</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">他のほとんどの SQL データベースエンジンはこれよりもはるかに大きいです。IBMは最近リリースされたCloudScapeデータベースエンジンは &quot;たった &quot;2MiBのjarファイルだと自慢しています。Firebirdは、そのクライアント側のライブラリがたったの350KiBだと自慢しています。これはSQLiteと同じくらいの大きさで、データベースエンジンさえ含まれていません。OracleのBerkeley DBライブラリは450KiBで、SQLのサポートを省略しており、プログラマには単純なキー/値のペアだけを提供しています。</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">他のほとんどのSQLデータベースエンジンでは、あるプラットフォームから別のプラットフォームに移動するときや、ソフトウェアの新しいバージョンにアップグレードするときに、データベースをダンプしてリストアする必要があります。</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">ほとんどのプログラマーは、&lt;a href=&quot;amalgamation&quot;&gt;統合&lt;/a&gt;を使用してSQLiteをアプリケーションにコンパイルします。&lt;a href=&quot;amalgamation&quot;&gt;合併は、&lt;/a&gt; C-コードですが、それは「ソースコード」ではありません。&lt;a href=&quot;amalgamation&quot;&gt;合併は、&lt;/a&gt;スクリプトによって、ソースコードから生成されます。</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">SQLiteのほとんどのテーブルは、一意の整数キー（&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;または&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;）とそれに続くコンテンツを持つ0個以上の行で構成されます。（例外は、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルです。）行は、ROWIDの昇順で論理的に格納されます。例として、この記事では「FruitsForSale」という名前のテーブルを使用します。このテーブルでは、さまざまな果物が栽培されている州と市場での単価に関連付けられています。スキーマはこれです：</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">典型的なSQLiteデータベーススキーマのほとんどのテーブルはrowidテーブルです。</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">swarmvtab のほとんどのユーザーは、上記の機能のみを使用します。このセクションでは、より難解な使用例のために設計された機能について説明します。これらの機能はすべて、CREATE VIRTUAL TABLEコマンドの一部としてSQL文の後にオプションのパラメータを指定します。オプションのパラメータは、名前の後に&quot;=&quot;文字を続けて指定し、その後に任意で引用符で囲まれた値を指定します。空白文字で名前、&quot;=&quot;文字、値を区切ることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">BLOBハンドルを新しい行に移動する</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">レジスタP1...P1+P3-1のP3値をレジスタP2...P2+P3-1に移動します。レジスタP1..P1+P3-1はNULLを保持したままになります。レジスタ範囲P1..P1+P3-1とP2..P2+P3-1が重なるのはエラーです。P3が1より小さいのはエラーです。</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">カーソルP1をnull行に移動します。任意の&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;カーソルがヌル行にあるときに発生する操作は常にNULLを記述します。</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">Webサイトとドキュメントファイルをソースツリーから&lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;別のCMシステムに移動し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">CVS リポジトリを www.sqlite.org に移動しました。</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">SQLite 3.4.2から3.5.0への移行</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">SQLite 3.5.9から3.6.0への移行</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">ジャーナルファイルをあるデータベースから別のデータベースに移動します。</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/intro&quot;&gt;C言語インターフェイスの&lt;/a&gt;多くは、ソースファイル&lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;、&lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;、および&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.cに&lt;/a&gt;ありますが、一部のルーチンは、ファイルスコープを持つデータ構造にアクセスできる他のファイルに散在しています。&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;ルーチンが実装されて&lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;。&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;ルーチンがで発見され&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;。&lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;インターフェースはである&lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;。&lt;a href=&quot;tclsqlite&quot;&gt;TCLインタフェース&lt;/a&gt;によって実装され&lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">複数ファイル取引</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">複数の文字の挿入、削除、置換は、コストテーブルに列挙することができます。</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">複数列インデックス</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">マルチカラムインデックスは、クエリのWHERE句の制約条件がANDで接続されている場合にのみ機能します。つまり、Idx3とIdx4は、オレンジとカリフォルニア産の両方のアイテムを検索する場合に便利ですが、オレンジとカリフォルニア産の両方のアイテムを検索する場合には、どちらのインデックスもそれほど便利ではありません。</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">複数のプログラミング言語</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">複数のVFSを同時に登録できます。各VFSには一意の名前があります。同じプロセス内の個別の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、異なるVFSを同時に使用できます。さらに言えば、単一のデータベース接続で&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;コマンドを使用して複数のデータベースファイルが開かれている場合、接続されている各データベースが異なるVFSを使用している可能性があります。</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">FTSテーブルへのレコード挿入のコストを削減するために、単一のbツリーの代わりに複数のbツリー構造が使用されます。すでに多くのデータを含むFTSテーブルに新しいレコードが挿入される場合、新しいレコードに含まれる用語の多くは、既存の多数のレコードにすでに存在している可能性が高い。単一のb-treeを使用した場合、大規模なdoclist構造をデータベースからロードし、新しいdocidと用語オフセットリストを含むように修正し、データベースに書き戻す必要があります。複数のb-treeテーブルを使用すると、後で既存のb-tree(またはb-tree)とマージできる新しいb-treeを作成することで、このような事態を避けることができます。b-tree構造のマージは、バックグラウンドタスクとして実行することもできますし、一定数の個別のb-tree構造が蓄積された後に実行することもできます。もちろん、この方式はクエリをより高価なものにします(FTSコードは複数のb-treeの中の個々の用語を検索し、その結果をマージしなければならないので)が、実際にはこのオーバーヘッドは無視できることが多いことがわかっています。</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">バージョン3.15.0で導入された&lt;a href=&quot;rowvalue&quot;&gt;行値&lt;/a&gt;ロジックに対する複数のバグ修正。</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">複数のコメンテーターが、ポインタ型に動的な文字列を使用し、SQLiteが型文字列の所有権を持ち、それを使用し終わったときに自動的に型文字列を解放するようにしたいという願望を表明しています。この設計は以下の理由で却下されました。</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">非同期IOのこの実装を使用した単一プロセス内の複数の接続は、単一のデータベースファイルに同時にアクセスすることができます。ユーザーの視点から見ると、すべての接続が単一のプロセス内からのものであれば、&quot;通常の &quot;SQLiteと非同期バックエンドを使用したSQLiteで提供される同時実行性に違いはありません。</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">複数の接続が同時にリードロックを保持する場合があります。多くのスレッドが重複するリードロックを取得している場合、少なくとも1つのスレッドが常にリードロックを保持している場合があります。そうすると、書き込みロックを待っているテーブルは永遠に待つことになります。このシナリオは &quot;ライター飢餓 &quot;と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE &lt;/a&gt;&lt;a href=&quot;c3ref/sqlite3&quot;&gt;を&lt;/a&gt;使用した同じデータベース接続上の複数のデータベース</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">複数のプロセスが同じアプリケーションファイルにアタッチすることができ、お互いに干渉することなく読み書きすることができます。</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">複数のプロセスが同時に同じデータベースを開くことができます。複数のプロセスが同時にSELECTを実行することができます。しかし、データベースに変更を加えることができるのは1つのプロセスだけです。</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">複数の小規模なソートをまとめて使用すると、単一の大規模なソートよりも少ないCPUサイクルを使用します。</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
