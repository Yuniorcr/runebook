<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">レジスタP1の値とレジスタP2の値を掛け合わせ、その結果をレジスタP3に格納します。どちらかの入力がNULLの場合、結果はNULLになります。</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">nullに0を乗算すると、nullは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">変異検査スクリプト</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">突然変異検査は、高速なワークステーションでは1回の検査に5分程度かかることがあり、分岐命令ごとに2回の検査があり、20,000以上の分岐命令があるため、時間がかかることがあります。動作を高速化するための努力がなされています。例えば、TH3 は最初のエラーを見つけるとすぐに終了するようにコンパイルされており、多くの突然変異が簡単に検出されるため、多くのサイクルが数秒で発生します。それにもかかわらず、mutation-test.tclスクリプトには、テストするコード行の範囲を制限するコマンドラインオプションが含まれているので、突然変異テストは最近変更されたコードブロックに対してのみ実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">ミューテックスハンドル</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">Mutex メソッド オブジェクト</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">ミューテックスの種類</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">ミューテックス検証ルーチン</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">ミューテックスは安いですが、無料ではないので、ミューテックスを完全に無効にした方がパフォーマンスは良くなります。その結果、ライブラリのフットプリントも少し小さくなります。コンパイル時にミューテックスを無効にすることは、意味のあるアプリケーションには最適化することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">ミューテックスは&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">ミューテックスは&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">WHERE句の式 &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; が機能しません。column1の値が &quot;column1&quot;である行だけでなく、テーブルのすべての行が返されます。</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">私のクエリは、私が期待するカラム名を返しません。これはバグでしょうか?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL バージョン 3.23.41 は UNION をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12でさえ</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13と奇数</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1(コスト:5.52</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2(コスト:5.52</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1(コスト:11.04</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">ネイティブキャラクター(70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">注意:この拡張機能は非推奨です。代わりに [WAL mode]をお勧めします。</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">NEAR クエリ</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">NEAR クエリは利用できません。</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">新しい参照と古い参照が有効です。</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">NEW リファレンスは有効です。</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN日</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN時間</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">エヌエヌエヌエヌ議事録</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">エヌエヌエヌ月</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN年</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">エヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌエヌ秒</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">不存在演算子</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">ふていにゅうえんざんし</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">NOT NULLL制約</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">NOT NULL 制約は優先されます。</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">SQLiteでのNULL処理</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">SQLiteと他のデータベースエンジンとの比較でのNULL処理</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL 値 (シリアルタイプ 0)を最初にソートします。</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL 値は、空の文字列ではなく NULL ポインタとしてコールバックに報告されるようになりました。</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">NULLS LAST</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULLは最初にソートします。</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">ホストパラメータ名</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">データベースファイルを格納するフォルダ名</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">一時ファイルを保存しているフォルダ名</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">デフォルトの照合順序の名前</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">名前付きwindow-defn句は、WINDOW句を使用してSELECT文に追加され、window関数の呼び出しの中で名前で参照されることもあります。例えば、以下のSELECT文は、2つの名前付きwindow-defn句、&quot;win1 &quot;と &quot;win2 &quot;を含んでいます。</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">ネーミングの変更</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">ほぼすべてのシステムは C で書かれたライブラリを呼び出す機能を持っていますが、これは他の実装言語には当てはまりません。</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">.width&quot; コマンドの負の数値は、右寄せの原因となります。</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;、&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;、および&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;を使用したネストされたトランザクション</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">神の憐れみを絶望してはならない。</target>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">それにもかかわらず、アプリケーション開発者は、メモリ割り当てサブシステムの状態を監視し、メモリ使用量がロブソン制限に近づいたり超えたりしたときにアラームを発生させるように警告されています。このようにして、アプリケーションは、障害が発生する前に十分な警告をオペレーターに提供します。SQLite の&lt;a href=&quot;malloc#memstatus&quot;&gt;メモリ統計&lt;/a&gt;インターフェイスは、このタスクの監視部分を完了するために必要なすべてのメカニズムをアプリケーションに提供します。</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">とはいえ、バグは発生します。信頼されていない SQL 入力やデータベースファイルを SQLite に送信するアプリケーションを書いている場合、攻撃対象を減らし、検出されなかったバグによるゼロデイエクスプロイトを防ぐための追加のステップがあります。</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">それにもかかわらず、メモリ割り当てサイズの計算における整数オーバーフローは、SQLiteが対処したい懸念事項です。問題を防ぐために、すべての SQLite 内部メモリ割り当ては、64 ビット符号付き整数のサイズパラメータを取るシンラッパー関数を使用して行われます。SQLite のソースコードは監査され、すべてのサイズ計算が 64 ビット符号付き整数を使用して行われていることを確認しています。SQLite は、一度に約 2GB を超えるメモリの割り当てを拒否します。(一般的な使用方法では、SQLite は一度に約 8KB 以上のメモリを割り当てることはめったにありませんので、2GB の割り当て制限は負担になりません)。そのため、64ビットのサイズパラメータはオーバーフローを検出するために多くの余裕を提供しています。すべてのサイズ計算が 64 ビット符号付き整数で行われていることを確認するのと同じ監査では、計算中に 64 ビット整数をオーバーフローさせることが不可能であることも確認されます。</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">とはいえ、どんなソフトウェアも100%完璧ではありません。SQLiteには、データベースの破損を引き起こす可能性のある歴史的なバグがいくつかありました(現在は修正されています)。また、まだ発見されていないバグがいくつかあるかもしれません。大規模なテストが行われ、SQLiteが広く使われているため、データベースの破損の原因となるバグは非常に目立たない傾向にあります。アプリケーションがSQLiteのバグに遭遇する可能性は低いのです。これを説明するために、2009-04-01 から 2013-04-15 までの 4 年間に SQLite で発見されたすべてのデータベース破損バグの説明を以下に示します。この説明は、SQLite のバグがテスト手順をすり抜けてリリースに至るまでにどのような種類のバグがあるのか、読者に直感的な感覚を与えてくれるはずです。</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">新しい&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt;コンパイル時オプションが追加されました</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">新しい変更点</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">新しいファイル形式</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">組み込みの日付/時刻関数に新しいHH:MM:SS修飾子を追加しました。</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">新しいVFSはsqlite3_vfs_register()で登録されます。各新規VFSは、makeDfltフラグが設定されていればデフォルトのVFSになります。同じVFSを複数回登録しても問題ありません。既存のVFSをデフォルトVFSにするには、makeDfltフラグをセットして再度登録します。同じ名前の異なるVFSが2つ登録されている場合の動作は未定義です。名前が NULL または空文字列の VFS が登録されている場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">新しいアプリケーションでは、常に呼び出す必要があります&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;の代わりに、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepareは）（ &lt;/a&gt;。古い&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;は、下位互換性のために保持されています。しかし、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;ははるかに優れたインターフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは、&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;../rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい構成オプションが追加される可能性があります。既存の構成オプションは廃止される可能性があります。アプリケーションは&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースは、非ゼロ返され&lt;a href=&quot;../rescode&quot;&gt;たエラーコードを&lt;/a&gt;廃止またはサポートされていない構成オプションが呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">SQLiteによって作成された新しいデータベースファイルは、デフォルトでフォーマット4を使用します。&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_formatプラグマは、&lt;/a&gt;設定することで、フォーマットのバージョン番号は1ではなく4にデフォルトにすることができる形式1を使用して、新しいデータベースファイルを作成するためのSQLiteを引き起こすために使用することができます&lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;コンパイル時に= 1を。</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">SQLite の将来のバージョンでは、新しいエラーコードが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">新しいエクステンションです。</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">一般的な使用のために25%から35%縮小された新しいファイル形式。</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">SQLite の将来のリリースでは、新しいフラグが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">アプリケーション定義のSQL関数を呼び出した&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルを返す新しいインターフェース&lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">新しいインターフェース&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）を&lt;/a&gt;使用すると、サイズと長さの制限を接続ごとおよび実行時に設定できます。</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">新しいインタフェース:sqlite3_bind_parameter_index()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">test_quota.c アドオンモジュールに新しいインターフェースが追加されました。</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">常に &quot;sqlite_&quot;で始まる新しい内部スキーマオブジェクト名は、将来のリリースでSQLiteファイルフォーマットに追加されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">新しいメモリアロケータは、SQLiteのソースツリーの一部である必要はありもsqlite3.cには含まれません&lt;a href=&quot;amalgamation&quot;&gt;合併&lt;/a&gt;。個々のアプリケーションは、起動時にSQLiteに独自のメモリアロケータを提供できます。</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">補助メモリの使用を構成するための&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;新しいオプション：--pagecache、-lookaside、および--scratch。</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">新しいクエリの最適化。</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">今後のリリースでは、新しいランタイムリミットカテゴリが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">新しいステータスパラメータは随時追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">テストスイートに新しいテストが追加されました。</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">SQLite の将来の拡張機能では、stat 列の末尾に新しいテキストトークンが追加される可能性があります。互換性のために、 stat カラムの最後にある認識されていないトークンは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">今後のリリースでは、新しいトレース定数が追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい動詞が追加される可能性があります。既存の動詞は廃止される可能性があります。アプリケーションは&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;廃止またはサポートされていない動詞が呼び出された場合のインターフェースは、非ゼロのエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">SQLiteの将来のリリースでは、新しい動詞が追加される可能性があります。既存の動詞は廃止される可能性があります。アプリケーションは&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;からの戻りコードをチェックして、呼び出しが機能したことを確認する必要があります。&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;廃止またはサポートされていない動詞が呼び出された場合のインターフェースは、非ゼロのエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">新しい zip アーカイブは、zipfile()集約関数を使用してメモリ内で完全に構築することができます。集計関数が訪れる各行は、ZIP アーカイブへのエントリを追加します。返される値は、アーカイブ画像全体を含む blob となります。</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">新しいディスクドライブは、4096バイトのセクターを使用し始めました。 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;バージョン3.7.10&lt;/a&gt;（2012-01-16）以降、SQLite開発チームはxSectorSizeを変更して実験を行い、爆風半径として4096バイトを報告しました。これにより、多くのデータベースで書き込みオーバーヘッドが増加するという影響がありました。データベースのための&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;プラグマPAGE_SIZE&lt;/a&gt;以前はそれが唯一のバックアップに1つのページを持っていたのに対し、データベース内の1つのページへの変更を行う1024（非常に一般的な選択肢は）今、ロールバック・ジャーナルへのバックアップ3つの、隣接する他のページへのSQLiteが必要です変わりました。では&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;、各トランザクションは、トランザクションごとに書き込まれている余分なバイト数千の結果として、WALファイルではなく、次の512バイト境界で次の4096バイト境界にパディングされなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">次に、以下のようなコマンドを使って、すべての blob のコピーをディレクトリ内の個々のファイルに作成します。</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">次に、出来上がったkvtest-android実行ファイルをAndroidデバイスに移動します。</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">次に、どんなオレンジでも良いのではなく、カリフォルニア産のオレンジの価格を調べたいとします。適切なクエリは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">いいえ(注1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">同じデータベース接続上での操作間の分離ができない</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">アプリケーションファイルのI/Oコードを書き込んでデバッグすることはできません。</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">変更なし</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">現在の行情報や競合する行情報は提供されません。与えられたsqlite3_changeset_iterハンドルで呼び出すことができる唯一の関数はsqlite3changeset_fk_conflicts()です。</target>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">不明なプラグマが発行されてもエラーメッセージは生成されません。未知のプラグマは単に無視されます。これは、プラグマ文の中にタイプミスがあっても、ライブラリがその事実をユーザに知らせないことを意味します。</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">ロックスタイルはありません。上記のいずれにも対応できない場合は、このロックスタイルが使用されます。データベースのロック機構を使用しない。このシステムを使用する場合、単一のデータベースが複数のクライアントからアクセスされることは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">データベースにはロックはありません。データベースは読み書きできません。内部的にキャッシュされたデータはすべて疑わしいものとみなされ、使用する前にデータベースファイルとの照合が必要です。他のプロセスは、それぞれのロック状態が許す限り、データベースを読み書きすることができます。これがデフォルトの状態です。</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">使わなくなった。</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">使わなくなりました。</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">誰もThe Ruleに従う必要はありませんし、The Ruleを知っている必要もありませんし、The Ruleが良い考えであると考える必要もありません。SQLiteの創設者は、The Ruleに従う人は誰でもより幸せで生産的な人生を送ることができると信じていますが、そのアドバイスに異議を唱えたり、無視したりするのは個人の自由です。</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">他のプロセスがデータベースを変更することはないので、トランザクションの最初に変更カウンタをチェックしてユーザースペースのキャッシュをクリアする必要はありません。</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">RBU更新が適用されている間は、ターゲット・データベースに他の書き込みが発生することはありません。これを防ぐために、ターゲット・データベースではリード・ロックが保持されています。</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">トランザクション内を除き、読み取りまたは書き込みは発生しません。データベースにアクセスするコマンド（基本的には、いくつかの&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;ステートメントを除くすべてのSQLコマンド）は、トランザクションがまだ有効になっていない場合、自動的にトランザクションを開始します。自動的に開始されたトランザクションは、最後のSQLステートメントが完了するとコミットされます。</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">union-vtab内のどのテーブルにも</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">SQLite データベースから情報を削除すると、未使用のディスク領域は内部の「フリーリスト」に追加され、次にデータを挿入するときに再利用されます。ディスク領域が失われることはありません。しかし、それがオペレーティングシステムに戻されることはありません。</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">非ASCII範囲文字(すなわち127より大きいユニコードコードコードポイント)、または</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">Vista 以外の Windows プラットフォームでは、DST ルールは 1 つのセットしかサポートしていません。Vistaでは2つのルールしかサポートしていません。そのため、これらのプラットフォームでは、過去のDSTの計算は正しくありません。たとえば、米国では2007年にDSTルールが変更されました。Vista以外のWindowsプラットフォームでは、2007年の新しいDSTルールがそれ以前のすべての年にも適用されます。Vistaでは、規則が変更された1986年まで遡って正しい結果が得られるようになります。</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">非決定論的関数は、引数が常に同じであっても、呼び出しごとに異なる答えを与える可能性があります。以下に非決定論的関数の例を示します。</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">ノンストリーミング相当</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">チェンジセット(またはパッチセット)を入力として受け取る非ストリーミング関数は、チェンジセット全体をメモリ内の単一のバッファに格納する必要があります。同様に、チェンジセットやパッチセットを返す関数は、sqlite3_malloc()を使って確保された単一の大きなバッファへのポインタを返します。通常はこれが便利です。しかし、低メモリ環境で動作するアプリケーションが非常に大きなチェンジセットを扱う必要がある場合、必要とされる大きな連続したメモリの割り当ては負担になります。</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">SQLite が存在していた最初の 10 年間は、安全なプログラミング言語は存在しませんでした。SQLiteはGoやRustで再コード化することができますが、そうすることで修正されるよりもはるかに多くのバグが発生し、コードが遅くなる可能性が高いようです。</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">xSavepoint()、xRelease()、または xRollbackTo()メソッドは、xBegin()と xCommit()または xRollback()のいずれかを呼び出す間を除いて、いずれも呼び出されることはありません。</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">通常の関数はxFuncのみを指定し、xStepとxFinalをNULLにします。集約関数はxStepとxFinalを指定し、xFuncをNULLにします。sqlite3_create_aggregate()APIは別途ありません。</target>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">通常、FTS5は、メインのFTS5テーブルに挿入されたトークンの各列の値のサイズを別のテーブルに格納する特別なバッキングテーブルをデータベース内に保持します。このバッキングテーブルは、&lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize &lt;/a&gt;&lt;a&gt;API関数&lt;/a&gt;によって使用されます。これは、組み込みの&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25ランキング関数&lt;/a&gt;によって使用されます（他のランキング関数にも役立つ可能性があります）。</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">通常、NULL SQL結果は&lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt;設定を使用して配列に格納されます。ただし、&lt;b&gt;-withoutnulls&lt;/b&gt;オプションを使用すると、NULL SQL値により、対応する配列要素が設定解除されます。</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">通常、SQLite は、セクタの一部を更新している間に停電が発生した場合、復旧後のデバイスセクタ全体の内容が疑われると想定しています。ファイル内のセクタの任意の部分に書き込みを行った後、変更されたセクタの内容はシステム内のどこか(メインメモリ、ディスクキャッシュなど)の揮発性バッファに保持されていると想定されます。SQLite は、更新されたデータが永続的なストレージメディアに到達したとは考えていません。</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">通常、トークンまたはトークンプレフィックスクエリは、MATCH演算子の左側に指定されたFTSテーブルのカラムに対してマッチされます。あるいは、FTS テーブル自体と同じ名前の特別なカラムが指定されている場合は、すべてのカラムに対してマッチされます。これは、基本的な用語クエリの前にカラム名の後に&quot;:&quot;文字を指定することで上書きすることができます。カラム名と&quot;:&quot;文字の間にはスペースがあってもよいが、カラム名と&quot;:&quot;文字の間にはスペースはない。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">通常、SQLインデックスはテーブルのカラムを参照します。しかし、インデックスはテーブルのカラムを含む式にも形成することができます。</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">通常、プライベートブランチとパブリックブランチを切り替えると、fossilはチェックアウト内のすべてのファイルを修正します。しかし、この時点ではどちらのブランチでもファイルは同じなので、修正の必要はありません。</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">通常、フルテキストクエリでは大文字と小文字が区別されません。ただし、これは、照会されるFTSテーブルが使用する特定の&lt;a href=&quot;fts3#tokenizer&quot;&gt;トークナイザーに&lt;/a&gt;依存します。詳細については、&lt;a href=&quot;fts3#tokenizer&quot;&gt;トークナイザー&lt;/a&gt;のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">通常、FTSモジュールは、テーブルのすべての列のすべての用語の転置インデックスを保持する。このオプションは、インデックスにエントリを追加してはならない列の名前を指定するために使用される。複数の &quot;notindexed &quot;オプションを使用して、複数の列をインデックスから除外することを指定することができる。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">通常、データベース&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PAGE_SIZE&lt;/a&gt;とデータベースがサポートするかどうか&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuumは、&lt;/a&gt;データベースファイルが実際に作成される前に設定する必要があります。しかし、ないときに&lt;a href=&quot;wal&quot;&gt;先行書き込みログ&lt;/a&gt;モード、&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PAGE_SIZE&lt;/a&gt;及び/又は&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuumの&lt;/a&gt;既存のデータベースの特性は、使用して変更することができる&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PAGE_SIZE&lt;/a&gt;および/または&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;プラグマauto_vacuum&lt;/a&gt;プラグマと直ちにデータベースを掃除します。すると&lt;a href=&quot;wal&quot;&gt;、先行書き込みログ&lt;/a&gt;モードのみ&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuumの&lt;/a&gt;サポートプロパティは、VACUUMを使用して変更することができます。</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">通常、SQLite がデータベースファイルに書き込む際には、書き込み操作が終了するまで待ってから呼び出し元のアプリケーションに制御を返します。ファイルシステムへの書き込みは通常、CPUに依存した操作に比べて非常に遅いため、これがパフォーマンスのボトルネックになることがあります。非同期I/Oバックエンドは、SQLiteがバックグラウンドで実行している別のスレッドを使ってすべての書き込み要求を実行するようにする拡張機能です。これはシステム全体のリソース(CPUやディスクの帯域幅など)を削減するものではありませんが、データベースへの書き込み中でもSQLiteが呼び出し元に制御を迅速に返すことができるようになります。</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">通常、行がFTS5テーブルに挿入されると、様々なフルテキストインデックスエントリやその他のデータと同様に、その行のコピーがFTS5モジュールによって管理されるプライベートテーブルに格納されます。ユーザ又は補助関数の実装によってFTS5テーブルから列の値が要求されると、このプライベートテーブルから読み出される。content」オプションは、FTSフルテキストインデックスエントリのみを格納するFTS5テーブルを作成するために使用することができる。列の値自体は、通常、関連するフルテキストインデックス項目よりもはるかに大きいので、これはデータベースのスペースを大幅に節約することができる。</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">すべてのアプリケーションがこれらの条件を満たすわけではありません。幸いなことに、これらの条件を満たしていなくても、NGQPは通常、良い問い合わせプランを見つけます。しかし、パフォーマンスの低下が発生する場合もあります(まれにですが)。</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">すべてのテストケースがこの方法で処理できるわけではありません。一部のテストケースでは、ディスクアクセス数、ソート操作、フルスキャンステップ、またはクエリ中に発生するその他の処理ステップをカウントすることで、最適化によって本当に計算量が削減されているかどうかを確認します。これらのテストケースは、最適化が無効になっている場合には失敗するように見えます。しかし、テストケースの大部分は単に正しい答えが得られたかどうかをチェックするだけで、最適化の有無にかかわらずすべてのケースを正常に実行して、最適化が誤動作を引き起こさないことを示します。</target>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">上記の例には示されていませんが、新しいテーブルのさまざまな側面を構成するために、CREATE VIRTUAL TABLEステートメントの一部としてFTS5に提供できる&lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;さまざまなオプション&lt;/a&gt;もあります。これらを使用して、FTS5テーブルがドキュメントとクエリから用語を抽出する方法を変更したり、ディスクに追加のインデックスを作成してプレフィックスクエリを高速化したり、他の場所に格納されているコンテンツのインデックスとして機能するFTS5テーブルを作成したりできます。</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">Nota bene.</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK制約を&lt;/a&gt;追加する場合、CHECK制約はテーブルの既存の行に対してテストされないことにも注意してください。これにより、CHECK制約に違反するデータを含むテーブルが作成される可能性があります。SQLiteの将来のバージョンでは、追加されたCHECK制約を検証するように変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">単調に増加する」というのは、ROWIDが常に正確に1だけ増加することを意味するわけではないことに注意してください。1は通常の増分です。しかし、(例えば)一意性制約のために挿入が失敗した場合、失敗した挿入試行の ROWID はその後の挿入で再利用されず、結果として ROWID シーケンスにギャップが生じる可能性があります。AUTOINCREMENT は、自動的に選択された ROWID が増加することを保証しますが、それらが順次になることは保証しません。</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;または&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;は、副作用としてデータベースを間接的に変更する可能性があることに注意してください。たとえば、アプリケーションが&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;を呼び出す関数 &quot;eval（）&quot;を定義している場合、次のSQLステートメントは副作用によってデータベースファイルを変更します。</target>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は、デフォルトでは非決定的と&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;見なされ&lt;/a&gt;、関数の登録時にSQLITE_DETERMINISTICフラグを使用しない限り、CREATE INDEXステートメントで使用できない場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;または&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;は、副作用としてデータベースを間接的に変更する可能性があることに注意してください。たとえば、アプリケーションが&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;を呼び出す関数 &quot;eval（）&quot;を定義している場合、次のSQLステートメントは副作用によってデータベースファイルを変更します。</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">Idx3には、元の&lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;と同じ情報がすべて含まれていることに注意してください。Idx3があれば、Idx1はもう必要ありません。「桃の価格」クエリは、Idx3の「state」列を単に無視することで、Idx3を使用して満たすことができます。</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">MinGWは32ビットのDLLのみを生成することに注意してください。別のMinGW64プロジェクトがあり、これを使って64ビットDLLを生成することができます。おそらくコマンドラインの構文は似ていると思われます。また、MSVCの最近のバージョンでは、WinXPやそれ以前のバージョンのWindowsでは動作しないDLLを生成することにも注意してください。そのため、生成されたDLLの互換性を最大限に高めるためには、MinGWをお勧めします。目安としては、MinGWを使って32ビットのDLLを生成し、MSVCを使って64ビットのDLLを生成するのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNOREは、&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;インターフェースから返される&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;競合解決モード&lt;/a&gt;としても使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNOREは、&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;インターフェースから返される&lt;a href=&quot;c_fail&quot;&gt;競合解決モード&lt;/a&gt;としても使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">SQLite では IN または NOT IN 演算子の右側にあるスカラ値の括弧付きリストを空リストにすることができますが、他のほとんどの SQL データベースエンジンや SQL92 標準では、リストに少なくとも 1 つの要素を含める必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">SQLite は自動的に適切な拡張子のサフィックス (&quot;windows では&quot;.dll&quot;、Mac では &quot;.dylib&quot;、他のほとんどの Unix では &quot;.so&quot;)を拡張子ファイル名に追加することに注意してください。一般的には、拡張子のフルパス名を指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLiteには、圧倒的多数のアプリケーションに完全に適した&lt;a href=&quot;../malloc#altalloc&quot;&gt;組み込みメモリアロケータ&lt;/a&gt;がいくつか付属しており、このオブジェクトは、特殊なメモリ割り当て要件を持つごく少数のアプリケーションにのみ役立つことに注意してください。このオブジェクトは、SQLiteのテスト中に、メモリ不足状態をシミュレートする代替メモリアロケータを指定して、SQLiteがそのような状態から正常に回復することを確認するためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLiteには、圧倒的多数のアプリケーションに完全に適した&lt;a href=&quot;malloc#altalloc&quot;&gt;組み込みメモリアロケータ&lt;/a&gt;がいくつか付属しており、このオブジェクトは、特殊なメモリ割り当て要件を持つごく少数のアプリケーションにのみ役立つことに注意してください。このオブジェクトは、SQLiteのテスト中に、メモリ不足状態をシミュレートする代替メモリアロケータを指定して、SQLiteがそのような状態から正常に回復することを確認するためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">SQLite は WITHOUT ROWID 仮想テーブルの PRIMARY KEY を強制しないことに注意してください。強制するかどうかは、基礎となる仮想テーブルの実装の責任となります。しかし、SQLite は PRIMARY KEY 制約が有効であること、つまり識別された列が本当に UNIQUE で NOT NULL であることを前提としており、その前提を用いて仮想テーブルに対するクエリを最適化します。</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">SQLiteは、オペレーティングシステムとハードウェアが同期要求のステータスについて教えているものをすべて信じなければならないことに注意してください。 SQLiteがどちらかが嘘であり、書き込みが順不同で発生している可能性があることを検出する方法はありません。ただし、&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt; SQLiteは、デフォルトのロールバックジャーナルモードよりも、順序の乱れた書き込みをはるかに許容します。 WALモードでは、失敗した同期操作がデータベースの破損を引き起こす可能性があるのは、&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;操作中のみです。 COMMIT中に同期が失敗すると、耐久性が失われる可能性がありますが、データベースファイルが破損することはありません。したがって、同期操作の失敗によるデータベースの破損に対する防御策の1つは、SQLiteをWALモードで使用し、チェックポイントをできるだけ少なくすることです。</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">SQLite はソートされたデータ構造である b-tree を使用しているため、SELECT 文の WHERE 句に等しさや不等しさのテストが含まれている場合にインデックスを使用することができることに注意してください。以下のようなクエリでは、インデックスが利用可能であればインデックスを使用することができます。</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">FLOATING POINT&quot; の宣言型は、&quot;POINT&quot; の最後に &quot;INT&quot; があるため、REAL ではなく INTEGER との親和性を持つことに注意してください。また、宣言された &quot;STRING&quot; の型は、NUMERIC の親和性を持ち、TEXT の親和性を持ちません。</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">ポリゴンを反転する変換では、頂点の順序が逆になる可能性があることに注意してください。つまり、変換により、頂点が反時計回りではなく時計回りに循環する場合があります。これは、変換後に&lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw（）&lt;/a&gt;関数を使用して結果を送信することで修正できます。</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">内部のトランザクションが(RELEASEコマンドを使用して)コミットした後、外部のトランザクションのROLLBACKによってその作業が取り消されるかもしれないことに注意すること。停電、プログラムのクラッシュ、OS のクラッシュは、一番外側のトランザクションをロールバックさせ、その外側のトランザクショ ン内で発生したすべての変更を元に戻し、RELEASE コマンドによって「コミット」されたと思われる変更でさえも元に戻す。コンテンツは、最も外側のトランザクションがコミットするまで、実際にはディスク上にコミットされません。</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">複数のリモートチェンジセットからの競合解決は、行単位ではなく、フィールド単位で結合されることに注意してください。これは、複数のリモートUPDATE操作の場合、単一のローカル変更の一部のフィールドはREPLACEでリベースされ、他のフィールドはOMITでリベースされる可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">UTF-16be と UTF-16le 間の変換は常にその場で行われ、先行ポ イ ン タ ーは無効にはなりません。その他の種類の変換は可能な場合にはその場で行われますが、それが不可能な場合もあり、その場合には先行ポインタは無効になります。</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">ZIP アーカイブからレコードを削除しても、アーカイブ内で使われているスペースを取り戻すわけではないことに注意してください。この非効率性を回避する一つの方法は、編集したアーカイブの内容に基づいて新しい zip アーカイブを作成することです。例えば、仮想テーブル temp.zzz を介してアクセスされたアーカイブを編集した後、次のようにします。</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">オペレーティングシステムによって、共有ライブラリのファイル名のサフィックスが異なることに注意してください。Windowsは「.dll」を使用し、Macは「.dylib」を使用し、mac以外のほとんどのunixは「.so」を使用します。コードを移植可能にする場合は、共有ライブラリのファイル名から接尾辞を省略できます。適切な接尾辞は、&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;インターフェースによって自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">shmファイルの各32768バイトのユニットには、それぞれ独自のaHashとaPgno配列があることに注意してください。一つのユニットの aHash 配列は、同じユニット内の aPgno エントリを見つけるのにのみ役立ちます。全体的な FindFrame(P,M)関数は、答えが見つかるまで、最新のユニットから始まり、最も古いユニットに遡ってハッシュ検索を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">FTS3 を有効にすると FTS4 も使用可能になることに注意してください。SQLITE_ENABLE_FTS4 コンパイル時オプションは別途用意されていません。SQLite のビルドは FTS3 と FTS4 の両方をサポートしているか、どちらもサポートしていません。</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">上記で詳述したいくつかのコーナーケースの違いを除いて、WITHOUT ROWIDテーブルとROWIDテーブルは同じように動作することに注意してください。どちらも同じSQL文が与えられたときに同じ答えを生成します。ですから、開発サイクルの後半にアプリケーションで実験を実行して、WITHOUT ROWIDテーブルの使用が役に立つかどうかをテストするのは簡単なことです。良い戦略は、製品開発の終わり近くまでWITHOUT ROWIDを気にしないことです。その後、戻ってテストを実行し、非整数のPRIMARY KEYを持つテーブルにWITHOUT ROWIDを追加することがパフォーマンスに役立つかどうかを確認し、WITHOUT ROWIDは役立つ場合にのみ保持することです。</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">geopoly は左下を原点とする伝統的な右手の直交座標系を使用しているのに対し、SVG は左上を原点とする左手の座標系を使用していることに注意してください。geopoly_svg()ルーチンは座標系を変換しようとしないので、表示される画像は鏡像で表示され、回転されます。それが望ましくない場合は、 geopoly_svg()にポリゴンを渡す前に、 geopoly_xform()ルーチンを使用して、出力を直交座標系から SVG 座標系に変換することができます。</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">非決定的関数が&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;でタグ付けされている場合、その関数が&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt; WHERE句または&lt;a href=&quot;expridx&quot;&gt;式インデックス&lt;/a&gt;で使用されると、関数が異なる回答を返し始めると、関連付けられたインデックスが破損する可能性があることに注意してください。。 SQL関数がほぼ確定的であり（つまり、&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）の&lt;/a&gt;ようにほとんど変更されない場合）、破損したインデックスで使用される場合、&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;を実行することで破損を修正できます。</target>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">動的ミューテックスパラメータ(SQLITE_MUTEX_FASTまたはSQLITE_MUTEX_RECURSIVE)が使用されている場合、sqlite3_mutex_alloc()はコールごとに異なるミューテックスを返すことに注意してください。静的なミューテックス型の場合は、同じ型番号を持つ全ての呼び出しで同じミューテックスが返されます。</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">WHERE 句に &quot;langid=N&quot; を含まない場合は、言語 0 (上の例では英語)を対象とした検索になることに注意しましょう。すべての言語を一度に検索する方法はありません。</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">ほとんどの場合、SQLiteはクエリのFROM句の各テーブルに対して単一のインデックスしか使用しないことに注意してください。ここで説明する二番目のOR句の最適化は、このルールの例外です。OR句では、OR句の各サブタームに対して異なるインデックスが使用されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">特別な &quot;:memory:&quot; という名前が適用され、純粋なインメモリデータベースを作成するためには、 ファイル名の中に追加のテキストがあってはならないことに注意してください。したがって、ディスクベースのデータベースは、以下のようにパス名を前置してファイル内に作成することができます。&quot;./:memory:&quot; のようにパス名を前置することで、ファイル内にディスクベースのデータベースを作成することができます。</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">上の図では、プライベートな編集を単一のコミットとして表示したことに注意してください。これは表示をわかりやすくするためだけのものです。何十個も何百個もの小さな変更を個別に行い、それぞれを個別にコミットすることを止めるものは何もありません。実際には、多くの小さな変更を行うことが望ましい作業方法です。すべての変更を単一のコミットで行う唯一の理由は、図を描きやすくするためです。</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">この設計では、トークナイザーがパーサーを呼び出すことに注意してください。YACCとBISONに精通している人々は、逆の方法でパーサーにトークナイザーを呼び出させるのに慣れているかもしれません。ただし、トークナイザがパーサーを呼び出すようにすると、スレッドセーフにすることができ、実行速度が向上するため、より優れています。</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">イン&lt;a href=&quot;lang_expr#glob&quot;&gt;フィックス&lt;/a&gt;関数（&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;、GLOB、&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;、および&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;）は、引数の順序を逆にすることに注意してください。したがって、「like（A、B）」は「B like A」と同等です。「B like A」の形式の場合、B項は関数の最初の引数と見なされます。ただし、「like（A、B）」の場合、A項が最初の引数と見なされます。</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">.import &quot;コマンドを実行する前に &quot;mode &quot;を &quot;csv &quot;に設定することが重要であることに注意してください。これは、コマンドラインシェルが入力ファイルのテキストを他の形式として解釈しようとするのを防ぐために必要です。</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">インデックス検索を効率的に行うためには、R*Treeインデックス内のすべての座標に制約がある必要はないことに注意してください。例えば、35番目の平行線と重なるすべてのオブジェクトを検索したいとします。</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">BIGSTRING の値を引用する必要はないことに注意してください。これは自動的に行われます。BIGSTRING が大きな文字列やバイナリオブジェクトの場合は、この方法の方が書きやすいだけでなく、 $BIGSTRING の内容のコピーを作成しなくて済むので、はるかに効率的です。</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">2つ以上のスレッドがSQLiteライブラリを使用して同じSQLiteデータベースファイルにアクセスすることは完全に安全であることに注意してください。SQLite 用の unix ドライバは POSIX 勧告のロックの癖を知っており、それを回避しています。この問題は、スレッドが SQLite ライブラリをバイパスしてデータベースファイルを直接読み込もうとした場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">データベースのファイル名になんらかの拡張子を付けることが非常に重要であることに注意してください。拡張子がない場合、SQLiteはファイルのベース名に追加して補助ファイル名を作成します。したがって、「 &lt;code&gt;db01&lt;/code&gt; 」という名前のデータベースには、「 &lt;code&gt;db01-journal&lt;/code&gt; 」という名前の&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;ファイルがあります。また、このファイル名には3文字に短縮する拡張子がないため、そのまま使用され、8 + 3の命名規則に違反します。</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0&lt;/a&gt;（2015-10-14）より前では、SQLiteは呼び出す前にNULLのxCreateメソッドをチェックしていませんでした。したがって、名前のみの仮想テーブルがSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;バージョン3.8.11.1&lt;/a&gt;（2015-07-29）以前に登録され、その仮想テーブルモジュールに対して&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;コマンドが試行されると、NULLポインターへのジャンプが発生し、クラッシュ。</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">gcovでSQLiteを実行することはSQLiteのテストではないことに注意してください&amp;mdash;これはテストスイートのテストです。-fprofile-argsおよび-ftest-coverageオプションによりコンパイラーが異なるコードを生成するため、gcovの実行ではSQLiteをテストしません。gcovの実行は、テストスイートが100％ブランチテストカバレッジを提供することを確認するだけです。gcovの実行は、テストのテスト-メタテストです。</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;定数は&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;コールバックからの潜在的な戻り値としても使用され、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;も&lt;a href=&quot;rescode&quot;&gt;結果コードで&lt;/a&gt;あることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;および&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェースはINSTEAD OFトリガーの起動をカウントしませんが、&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changesプラグマ&lt;/a&gt;はINSTEAD OFトリガーの起動をカウントすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;定数は&lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;コールバックからの潜在的な戻り値としても使用され、&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;も&lt;a href=&quot;../rescode&quot;&gt;結果コードで&lt;/a&gt;あることに注意してください。</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">DO UPDATE句は、INSERT時に制約エラーが発生した1つの行に対してのみ動作することに注意してください。アクションをその1行に制限するWHERE句を含める必要はありません。DO UPDATEの最後にあるWHERE句の唯一の使用法は、DO UPDATEを元の値および/または新しい値に応じて、オプションでDO UPDATEをno-opに変更することです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">SQLITE_TEXT 定数は SQLite バージョン 2 でも全く異なる意味で使われていたことに注意してください。SQLite バージョン 2 と SQLite バージョン 3 の両方にリンクするソフトウェアは、SQLITE_TEXT ではなく SQLITE3_TEXT を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">SQLite パーサーは、インデックスを使用することが可能であっても、必ずしもインデックスを使用するコードを生成するとは限らないことに注意してください。以下のクエリは現在のところインデックスを使用しません。</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">複合クエリ用のUNION ALL演算子は、それ自体では過渡インデックスを使用しないことに注意してください(もちろん、UNION ALLの右と左の副問い合わせがどのように構成されているかによっては過渡インデックスを使用するかもしれませんが)。</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;オーソライザー&lt;/a&gt;コールバックは、sqlite3_prepare（）またはそのバリアントの間にのみ呼び出されることに注意してください。前の段落で述べたように、sqlite3_step（）がsqlite3_prepare_v2（）を呼び出してスキーマの変更後にステートメントを再準備しない限り、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;でのステートメント評価中は認可は実行されません。</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;オーソライザー&lt;/a&gt;コールバックは、sqlite3_prepare（）またはそのバリアントの間にのみ呼び出されることに注意してください。前の段落で述べたように、sqlite3_step（）がsqlite3_prepare_v2（）を呼び出してスキーマの変更後にステートメントを再準備しない限り、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;でのステートメント評価中は認可は実行されません。</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">SQLiteが使用する文字エンコーディングメカニズムは、実行時に変更できないことに注意してください。これはコンパイル時のオプションのみです。&lt;b&gt;sqlite_encoding&lt;/b&gt;文字列だけでライブラリがコンパイルされた方法を説明します。</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">同期設定がFULLの場合、ロールバックジャーナルのチェックサムは必要ないことに注意してください。チェックサムに依存するのは、 synchronous が NORMAL に下げられたときだけです。とはいえ、チェックサムは決して問題にならないので、同期の設定に関係なくロールバックジャーナルに含まれます。</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">コマンドラインシェルプログラムでは、拡張機能のロードが既に有効になっている（&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;インターフェイスをセットアップの一部として呼び出すことにより）ため、上記のコマンドは特別なスイッチ、セットアップ、またはその他の複雑な作業なしで機能します。</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">デストラクタ関数Dはポインタ値Pに対するものであり、型文字列Tに対するものではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">整数キーは、挿入直前のテーブルにあった最大のキーよりも1つ大きいことに注意してください。新しいキーは現在テーブルにあるすべてのキーに対して一意ですが、以前にテーブルから削除されたキーと重複する場合があります。テーブルの存続期間を通じて一意のキーを作成するには、&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;キーワードを&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;宣言に追加します。次に、選択されたキーは、そのテーブルに存在する最大のキーより1つ多くなります。可能な最大のキーが以前にそのテーブルに存在していた場合、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;は&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;エラーコードで失敗します。</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">&lt;a href=&quot;inmemorydb&quot;&gt;インメモリデータベース&lt;/a&gt;のjournal_mode はMEMORYまたはOFFであり、別の値に変更できないことに注意してください。&lt;a href=&quot;inmemorydb&quot;&gt;インメモリデータベース&lt;/a&gt;のjournal_modeをMEMORYまたはOFF以外の設定に変更しようとしても無視されます。また、トランザクションがアクティブな間は、journal_modeを変更できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">上記のルーチンのリストは実際のものではなく概念的なものであることに注意してください。これらのルーチンの多くには、複数のバージョンがあります。例えば、番組上のリスト、単一の名前付きルーチン&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;実際には、わずかに異なる方法で同じことを達成する3つの別々のルーチンがある場合：&lt;a href=&quot;c3ref/open&quot;&gt;（sqlite3_open）は&lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;と&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（） &lt;/a&gt;。リストには実際にはそのようなルーチンが存在しない場合の&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;が記載されています。リストに示されている「sqlite3_column（）」は、さまざまなデータ型の列データを追加するルーチン全体のプレースホルダーです。</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">OOM オーバーレイが使用されている場合でも、メモリリーク検出ロジックは動作し続けることに注意してください。これにより、SQLite がメモリ割り当てエラーに遭遇してもメモリリークが発生しないことが確認されます。また、OOM オーバーレイは、メモリ割り当ての不正使用をチェックするインスツルメンテッド・メモリ・アロケータを含む、あらゆる基礎となるメモリ・アロケータで動作することにも注意してください。このようにして、OOM エラーが他の種類のメモリ使用エラーを誘発しないことが検証されています。</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLiteが理解できるキーワードの数は、コンパイル時のオプションに依存する可能性があることに注意してください。たとえば、SQLiteが&lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;オプションを使用してコンパイルされている場合、「VACUUM」はキーワードではありません。また、新しいキーワードがSQLiteの将来のリリースに追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLiteが理解できるキーワードの数は、コンパイル時のオプションに依存する可能性があることに注意してください。たとえば、SQLiteが&lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;オプションを使用してコンパイルされている場合、「VACUUM」はキーワードではありません。また、新しいキーワードがSQLiteの将来のリリースに追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">カラムの親和性を決定するルールの順序が重要であることに注意してください。宣言された型が &quot;CHARINT &quot;であるカラムは、ルール1と2の両方にマッチしますが、最初のルールが優先されるため、カラムの親和性はINTEGERになります。</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">一次結果コードは常に拡張結果コードの一部であることに注意してください。完全な32ビットの拡張結果コードが与えられると、アプリケーションは、拡張結果コードの最下位8ビットを抽出するだけで、対応する主結果コードを常に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">このSELECTクエリのプログラムには、INSERTの例で使用したトランザクション命令とコミット命令が含まれていないことに注意してください。SELECTはデータベースを変更しない読み取り操作なので、トランザクションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">readfile（X）およびwritefile（X、Y）関数は拡張関数であり、コアSQLiteライブラリに組み込まれていないことに注意してください。これらのルーチンは、&lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLiteソースコードリポジトリ&lt;/a&gt;の&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt;ソースファイルで&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能&lt;/a&gt;として使用できます。</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">非BLOB値をBLOBにキャストした結果とBLOB値を非BLOB値にキャストした結果は、データベースの&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;エンコーディング&lt;/a&gt;がUTF-8、UTF-16be、またはUTF-16leのいずれであるかによって異なる場合があることに注意してください。 。</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_apply_v2（）APIはまだ&lt;b&gt;実験&lt;/b&gt;段階であり、変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_start_v2（）APIはまだ&lt;b&gt;実験&lt;/b&gt;段階であり、変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">単項* + *演算子は&lt;a href=&quot;datatype3#affinity&quot;&gt;式&lt;/a&gt;から型の類似性も削除することに注意してください。場合によっては、式の意味に微妙な変化が生じることがあります。上記の例では、列* x *に&lt;a href=&quot;datatype3#affinity&quot;&gt;TEXTアフィニティがある&lt;/a&gt;場合、比較 &quot;x = 5&quot;はテキストとして行われます。ただし、* + *演算子はアフィニティを削除します。したがって、「+ x = 5」の比較では、列* x *のテキストが数値5と比較され、常にfalseになります。</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">実際には許可されていない構文図を通るパスがあることに注意してください。いくつかの例があります。</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">等号演算子には、等号演算子と等号演算子ではない演算子があります。等号は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">これはあくまでも思考実験であることに注意してください。私たちは OpenDocument を変更することを提案しているわけではありません。また、この記事は現在の OpenDocument のデザインを批判するものでもありません。このエッセイのポイントは、将来のファイルフォーマットのデザインを改善する方法を提案することです。</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">この問題は、ロックを取得しようとした結果、I/O エラーが発生した場合にのみ発生することに注意してください。ロックが単に付与されなかった場合(他のスレッドやプロセスが既に競合するロックを保持しているため)、破損は発生しません。共有メモリ上のファイルロックを取得しようとしたときに I/O エラーで失敗するようなオペレーティングシステムはありません。したがって、これは実際の問題ではなく理論上の問題です。言うまでもなく、この問題は実際に観測されたことがありません。この問題は、I/O エラーをシミュレートするテストハーネスで SQLite のストレステストを行っているときに発見されました。</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;と同様に、このルーチンは文字列が一致しない場合、一致時にゼロを返し、ゼロ以外を返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;および&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;と同様に、このルーチンは文字列が一致しない場合、一致時にゼロを返し、ゼロ以外を返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">関連するテーブルが削除されると、トリガーが自動的に削除されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">SQLiteがSQLITE_THREADSAFE = 0でコンパイルされている場合、SQLiteをスレッドセーフにするコードはビルドから省略されます。これが発生すると、開始時または実行時に&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;を変更することができません。</target>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">LIKEまたはGLOB演算子の右側が&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターで&lt;/a&gt;あり、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;を使用してステートメントが準備される場合、ステートメントが自動的に再解析され、各実行の最初の&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しで再コンパイルされることに注意してください。右側のパラメーターへのバインドは、前回の実行以降変更されています。この再解析と再コンパイルは、スキーマの変更後に発生するアクションと基本的に同じです。クエリプランナーがLIKEまたはGLOB演算子の右側にバインドされた新しい値を調べて、上記の最適化を採用するかどうかを決定できるように、再コンパイルが必要です。</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">型変換が発生した場合、sqlite3_column_blob(),sqlite3_column_text(),および/または sqlite3_column_text16()の前の呼び出しによって返されたポインタが無効になることがあることに注意してください。以下の場合、型変換やポインタが無効になることがあります。</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;をNORMALに設定すると、チェックポイントがI / Oバリアまたは同期操作（UNIXではfsync（）、WindowsではFlushFileBuffers（））を発行する唯一の操作になることに注意してください。したがって、アプリケーションが別のスレッドまたはプロセスでチェックポイントを実行する場合、データベースクエリと更新を実行しているメインスレッドまたはプロセスが同期操作をブロックすることはありません。これは、ビジーなディスクドライブで実行されているアプリケーションの「ラッチアップ」を防ぐのに役立ちます。この構成の欠点は、トランザクションが永続的でなくなり、電源障害またはハードリセットの後にロールバックされる可能性があることです。</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">ANALYZEでは、コスト推定値がより現実と一致しており、NNとN3の両方でアルゴリズム-1が選択されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">&lt;a href=&quot;vtab#xfilter&quot;&gt;xBestIndex&lt;/a&gt;からのidxNumおよびidxStr出力はxFilterへの必須入力であるため、xBestIndexは常にxFilterの前に呼び出されることに注意してください。ただし、xBestIndexが成功した後でxFilterが呼び出されるという保証はありません。</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">仮想テーブル名 (&quot;stat&quot;)の前に &quot;temp.&quot; という修飾子があることに注意してください。この修飾子により、仮想テーブルは一時的なものとなり、現在のデータベース接続の間だけ存在します。これが推奨されるアプローチです。</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">特に最後の箇条書きに注意してください。sqlite3_set_auxdata(C,N,P,X)のデストラクタXはsqlite3_set_auxdata()インタフェースが戻る前に呼ばれるかもしれません。したがって、sqlite3_set_auxdata()は関数の実装の終わり近くで呼ばれるべきであり、sqlite3_set_auxdata()が呼ばれた後はPを使ってはいけません。</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">これらのトリガーでの&lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote（）SQL関数&lt;/a&gt;の使用に注意してください。quote（）関数は、引数をSQLステートメントに含めるのに適した形式に変換します。数値は変更されずに通過します。文字列の前後に単一引用符が追加され、内部の単一引用符はエスケープされます。BLOB値は、SQL標準の16進BLOB表記を使用してレンダリングされます。quote（）関数を使用すると、取り消しとやり直しに使用されるSQLステートメントがSQLインジェクションから常に安全になります。</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">「estimatedRows」、「idxFlags」、およびcolUsedフィールドの警告に注意してください。これらのフィールドは、SQLiteバージョン3.8.2、3.9.0、および3.10.0でそれぞれ追加されました。これらのフィールドを読み書きする拡張機能では、まず、使用中のSQLiteライブラリのバージョンが適切なバージョン以上であることを確認する必要があります。おそらく、&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;から返された値を定数3008002、3009000、3010000 と比較します。古いバージョンのSQLiteによって作成されたsqlite3_index_info構造体のこれらのフィールドにアクセスしようとした結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注：「&lt;small&gt;&lt;i&gt;（exp）&lt;/i&gt;&lt;/small&gt;」でマークされた関数は&lt;a href=&quot;capi3ref&quot;&gt;実験的なもので&lt;/a&gt;あり、名前に&lt;s&gt;取り消し線&lt;/s&gt;が&lt;a href=&quot;capi3ref&quot;&gt;引かれた&lt;/a&gt;関数は非推奨です。</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注：「&lt;small&gt;&lt;i&gt;（exp）&lt;/i&gt;&lt;/small&gt;」でマークされた関数は&lt;a href=&quot;experimental&quot;&gt;実験的なもので&lt;/a&gt;あり、名前に&lt;s&gt;取り消し線&lt;/s&gt;が&lt;a href=&quot;experimental&quot;&gt;引かれた&lt;/a&gt;関数は非推奨です。</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">注：この記事のセクション2.0と3.0は、&lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt;と&lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;へのコメントに応じて追加されました。</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注：このメソッドはMacOS X 10.7およびiOSバージョン5.0では無効であり、常にSQLITE_MISUSEを返します。これらのシステムでは、共有キャッシュモードは、ビアごとのデータベース接続を有効にする必要がある&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;と&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHEを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注：このメソッドはMacOS X 10.7およびiOSバージョン5.0では無効であり、常にSQLITE_MISUSEを返します。これらのシステムでは、共有キャッシュモードは、ビアごとのデータベース接続を有効にする必要がある&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;と&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHEを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview&quot;&gt;クエリオプティマイザ&lt;/a&gt;に関する注意事項。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">LIKE 演算子がどのように実装されているかに注目してください。これはSQLiteのユーザー定義関数なので、関数定義のアドレスはP3で指定されています。オペランドP1は、スタックから取得する関数引数の数です。この場合、LIKE()関数は2つの引数を取ります。引数はスタックから逆順(右から左)に取り出されますので、マッチするパターンはスタックの一番上の要素で、次の要素は比較するデータです。戻り値はスタックに押し出されます。</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">上のクエリがどのように動作するかに注目してください。R*Tree インデックスは、経度 -81...-79.6 と緯度 35.0...36.2 のバウンディングボックス内に含まれるエントリを見つけるために外側のループ内で実行されます。見つかった各オブジェクト識別子について、SQLite は demo_data テーブルの対応するエントリを検索します。次に、demo_data テーブルの境界フィールドをパラメータとして contained_in()関数を使用し、その関数が true を返すと、demo_data テーブルの objname フィールドがクエリ結果の次の行として返されます。</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">他のすべての日付と時刻の関数は strftime()で表現できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">SQLite テーブルを使用してコンテンツを小さな断片に分割することで、実装に柔軟性を与えることに注意してください。アプリケーションは、起動時にすべてのコンテンツをメモリに読み込むことができます。あるいは、数ページだけをメモリに読み込んで残りをディスクに保存することもできます。あるいは、一度に単一のページだけをメモリに読み込むこともできます。また、アプリケーションの異なるバージョンでは、ファイル形式を変更することなく、異なる選択をすることができます。このようなオプションは、すべてのコンテンツがZIPアーカイブ内の単一の大きなXMLファイルにある場合には利用できません。</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">ダミーレコードの &quot;ホスト &quot;の値はNULLなので、result[]配列にはそのスロットにNULLポインタが含まれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">関数のパラメータがSQLiteバージョン2.Xのように文字列へのポインタではなく、sqlite3_value構造体へのポインタになったことに注目してください。</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">共有ロックはオペレーティングシステムのディスクキャッシュ上にあり、ディスク自体にはないことに注意してください。ファイルロックは、通常、オペレーティングシステムのカーネル内のフラグに過ぎません (詳細は特定の OS レイヤーインターフェースに依存します)。(詳細は特定の OS レイヤーインターフェースに依存します。)したがって、オペレーティングシステムがクラッシュしたり、電源が切れたりすると、ロックは即座に消えてしまいます。また、ロックを作成したプロセスが終了した場合も、通常はロックは消えます。</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">fts3tokenize仮想テーブルからの結果セット内のトークンは、トークナイザーのルールに従って変換されていることに注意してください。この例では「porter」トークナイザーを使用したため、「This」トークンは「thi」に変換されました。トークンの元のテキストが必要な場合は、&lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr（）&lt;/a&gt;関数で「start」列と「end」列を使用して取得できます。例えば：</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">ListRead 命令と Next 命令の類似性に注目してください。どちらの操作もこのルールに従って動作します。</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">平均的な読み込み性能と平均的な書き込み性能の間にはトレードオフがあることにも注意してください。読み込み性能を最大化するためには、WALを可能な限り小さくしたいので、チェックポイントを頻繁に、おそらくCOMMITごとに実行するのと同じくらいの頻度で実行したいと考えます。書き込み性能を最大化するには、各チェックポイントのコストを可能な限り多くの書き込みに渡って償却したいと考えます。したがって、チェックポイントをどのくらいの頻度で実行するかの決定は、アプリケーションの相対的な読み取りと書き込みのパフォーマンス要件に応じて、アプリケーションごとに異なる場合があります。デフォルトの戦略は、WAL が 1000 ページに達したらチェックポイントを実行するというもので、この戦略はワークステーション上のテストアプリケーションではうまく機能しているようですが、他の戦略は異なるプラットフォームや異なるワークロードではよりうまく機能するかもしれません。</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">MSVC++6で再びコンパイルできるようになりました。</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">Solaris、OpenBSD、および fdatasync()関数を欠いた他の Unix バリアントでのコンパイルが可能になりました。</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">では、身長180cm以上の組織内の全員の名前を検索するクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">では、MとNがともに3500の場合を考えてみましょう。アリスノードは豊富にあります。しかし、これらのノードのそれぞれが1つか2つの辺だけでつながっているとします。この場合、オプション2が好ましい。オプション2では、外側のループはまだ3500回実行しなければなりませんが、中間のループは外側のループごとに1回か2回しか実行しませんし、内側のループは中間のループごとに1回しか実行しません(全く実行しない場合)。つまり、内側ループの総反復回数は7000回程度になります。一方、オプション1の場合は、外側ループと中間ループをそれぞれ3500回ずつ実行しなければならず、結果として中間ループの反復回数は1200万回になります。このように、2番目のシナリオでは、オプション2はオプション1の2000倍近く速くなります。</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">これで、この演習の要点であるSQLiteにプライベートなカスタム変更を加える時がきました。&quot; &lt;code&gt;fossil update private&lt;/code&gt; &quot;コマンドを使用して（まだそこにいない場合）プライベートブランチに切り替え、テキストエディターでソースファイルを表示して、必要な変更を行います。変更が完了したら、次のコマンドを使用してそれらの変更をコミットします。</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">では、このインデックスがどのように使われるのか見てみましょう。次のクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">さて、user.phoneフィールドには、ユーザーが電話番号を1つだけ持っている場合はプレーンテキストが含まれ、ユーザーが複数の電話番号を持っている場合はJSON配列が含まれているとします。同じ質問をします。&quot;どのユーザーが704市外局番に電話番号を持っていますか?&quot; しかし、json_each()は第一引数として整形された JSON を必要とするため、json_each()関数は 2 つ以上の電話番号を持つユーザーに対してのみ呼び出すことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">パブリックブランチとプライベートブランチが異なるため、「 &lt;code&gt;fossil update trunk&lt;/code&gt; 」コマンドと「 &lt;code&gt;fossil update private&lt;/code&gt; 」コマンドを実行して、ブランチ間を切り替えると、チェックアウト内のファイルがfossilによって実際に変更されることがわかります。</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">Null-indicatorは、列の値がNULLであることを示すオプションの文字列です。デフォルトは空の文字列です。column-separatorとnull-indicatorはオプションの位置引数であることに注意してください。null-indicatorが指定されている場合は、column-separator引数を指定し、null-indicator引数の前に指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">結果セットのカラム数</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">SQLパラメータの数</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">事前のチェックポイントで既にデータベースにバックフィルされているWALフレームの数</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">バックフィルが試みられたが、バックフィルが成功しなかった可能性のあるWALフレームの数。</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">ペイロードのバイト数</target>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">結果セットの列数</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">WALファイル内の有効なフレーム数とコミットされたフレーム数。</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">DISTINCTキーワードでも、数値型とテキスト型の違いがあります。</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">数値(シリアルタイプ1~9)は、NULLの後に数値順にソートします。</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">数値は数値順に次のようにソートされます。</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">多数のバグ修正とドキュメントの更新。</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">多数のコード最適化、コードフットプリントを小さくするために設計された特別な最適化。</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">数々のマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">その他多数の性能強化</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-OpenOffice などで使用されているオープンドキュメントのプレゼンテーションフォーマット</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-OpenOffice などで使用されているオープンドキュメント形式です。</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">FROM句のないクエリでは、OFFSET句は無視されます。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSETは正しい答えを与えます。しかし、OFFSETはオフセット値に比例した時間を必要とします。LIMIT x OFFSET y &quot;で実際に何が起こるかというと、SQLiteはクエリを &quot;LIMIT x+y &quot;として計算し、最初のy値をアプリケーションに返さずに破棄します。そのため、ウィンドウが長いリストの一番下に向かって下にスクロールし、y の値がどんどん大きくなっていくと、連続したオフセットの計算に時間がかかります。</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">古い参照は有効です。</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">オンコンフリクト句</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOMテストは、OOMエラーをシミュレートすることによって行われます。 SQLiteは、アプリケーションが&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;を使用して代替のmalloc（）実装を置き換えることを可能にします、...） インターフェース。 TCLとTH3のテストハーネスはどちらも、特定の数の割り当て後に失敗するようにリギングできるmalloc（）の変更バージョンを挿入できます。これらのインストルメント化されたmallocは、1回だけ失敗してから再び作業を開始するか、最初の失敗後に失敗し続けるように設定できます。 OOMテストはループで実行されます。ループの最初の反復で、インストルメント化されたmallocは、最初の割り当てで失敗するようにリギングされます。次に、いくつかのSQLite操作が実行され、SQLiteがOOMエラーを正しく処理したことを確認するためのチェックが行われます。次に、インストルメント化されたmallocの障害までの時間カウンターを1つ増やし、テストを繰り返します。ループは、シミュレーション全体のOOM障害に遭遇することなく、操作全体が完了するまで実行されます。このようなテストは2回実行され、一度、インストルメント化されたmallocが1回だけ失敗するように設定し、インストルメント化mallocを設定して、最初の失敗の後に継続的に失敗するように設定します。</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">並び順</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ORDER BYとGROUP BYでは、制限付きメモリを使用するようになりました。</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">クエリに同じGROUP BYがある場合、ORDER BYは無視されます。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ORDER BY はサブセレクトで動作します。</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">OSインタフェース</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">OSインタフェースファイル仮想メソッドオブジェクト</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">OSインタフェースオブジェクト</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">OSインタフェースオープンファイルハンドル</target>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">たとえ彼らが(神が禁じている)他の行動をとることがあっても、「彼らが言うことをして、彼らがすることをしてはならない」という主の戒めに注意して、神があなたの上に権威を置かれた人の命令にすべてのことで従いなさい。</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">オブジェクト指向設計</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">オブジェクト指向はデザインパターンであって、プログラミング言語ではありません。アセンブリ言語を含め、どんな言語でもオブジェクト指向プログラミングを行うことができます。いくつかの言語(例:C++やJava)はオブジェクト指向をより簡単にしています。しかし、C言語のような言語でもオブジェクト指向プログラミングはできます。</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">オブジェクト指向だけが有効な設計パターンではありません。多くのプログラマは、純粋にオブジェクトの観点から考えるように教えられてきました。そして、確かに、オブジェクトは問題を分解するのに良い方法であることが多い。しかし、オブジェクトは唯一の方法ではありませんし、問題を分解する最良の方法とは限りません。古き良き手続き的なコードの方が、オブジェクト指向のコードよりも書きやすく、メンテナンスや理解が容易で、高速であることもあります。</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">トリガーの不明瞭なバグ修正（&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">廃止された文書</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">チェンジグループからのコンポジット チェンジセットの取得</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">集計関数コンテキストの取得</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">チェンジセット イテレータからの矛盾する行値の取得</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">チェンジセット イテレータからの現在の操作の取得</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">表の主キー定義の取得</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">URIパラメータの値の取得</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">データベースファイルのPENDINGロックとEXCLUSIVEロックを取得します。他のプロセスがまだSHAREDロックを持っている場合、ライタはEXCLUSIVEロックを取得できるようになる前に、SHAREDロックがクリアされるまで待たなければならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">チェンジグループの現在の内容を表すチェンジセット(またはパッチセット)を含むバッファを取得します。changegroupへの入力がそれ自体がチェンジセットであった場合、出力はチェンジセットになります。あるいは、入力がパッチセットであった場合、出力はパッチセットでもあります。</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">第一引数として渡されたセッション・オブジェクトにアタッチされたテーブルの変更を含むチェンジセットを取得します。成功した場合、*ppChangesetをチェンジセットを含むバッファを指すように設定し、*pnChangesetをチェンジセットのサイズをバイト単位で設定してからSQLITE_OKを返します。エラーが発生した場合、*ppChangeset と *pnChangeset の両方をゼロに設定し、SQLite エラー・コードを返します。</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">特定のテーブルのロックを取得します。この命令は、共有キャッシュ機能が有効な場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">データベースファイルのEXCLUSIVEロックを取得し、上記の手順1-3のアルゴリズムを使用して、すべてのメモリ変更がデータベースファイルに書き込まれていることを確認します。</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">変更セット・イテレータからの new.*値の取得</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">変更セット・イテレータからの old.*値の取得</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">fossilから最新のSQLiteコードを取得します。</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">SQL値の取得</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">の取得</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">ミューテックスを取得します。</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">時折、深刻な問題が発見され、通常のメンテナンスリリースに対して小さな「パッチ」リリースを行わなければならないことがあります。パッチはメンテナンスリリースとは異なり、以前のリリースから変更されたコードの行数が非常に少ないという点で区別されます。メンテナンスリリースがバグフリーであることを確認することで、パッチリリースを避けるためのあらゆる努力がなされています。</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">もちろん、ANALYZEが有効に機能するのは、そもそもデータベースにかなりの量のコンテンツが蓄積されている場合に限られます。多くのデータを蓄積することが予想される新しいデータベースを作成する場合、&quot;ANALYZE sqlite_master &quot;コマンドを実行してSQLITE_STAT1テーブルを作成し、アプリケーションの典型的なデータベースを記述したコンテンツでSQLITE_STAT1テーブルを事前に埋め込んで(通常のINSERT文を使用して)おくことができます。</target>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">もちろん、上記の4つのステップのいずれかを実行中にエラーが発生する可能性があります。このような場合は</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">もちろん、通常のSQLiteテーブルであれば、整数の主キーに対するクエリも効率的に実行されますので、前者は大した問題ではありません。R*Treeを使う本当の理由は、座標範囲に対する不等式クエリを効率的に行うためです。ノースカロライナ州シャーロット付近に含まれるインデックスのすべての要素を見つけるには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">もちろん、システムリカバリー後に存在する可能性もあります。</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">もちろん、通常は、すべての変更をアトミックに適用することはできません。</target>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">もちろん、最終的にはWALファイルに追加されたすべてのトランザクションを元のデータベースに戻したいと考えています。WALファイルのトランザクションをデータベースに戻すことを&quot;</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">もちろん、クエリの出力をrowidで順番に並べることは滅多にありません。通常は、他のカラムで出力を順番に並べたいものです。</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">もちろん、例に示した &quot;t1bc &quot;と &quot;t2 &quot;の代わりに、希望するインデックスとインポスターテーブル名を代入してください。.imposter &quot;コマンドは、&quot;t1bc &quot;インデックスのスキーマを読み込み、その情報を使用してインポスターテーブル用の互換性のあるCREATE TABLE文を構築し、その後、過渡的なインポスターテーブルを自動的に作成するために必要なすべての呼び出しを行います。</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">もちろん、上記の2つのクエリは完全に等価というわけではありません。例えば、LIKEクエリは &quot;linuxophobe &quot;や &quot;EnterpriseLinux &quot;のような用語を含む行にマッチします(実際にはEnron E-Mail Datasetにはそのような用語は含まれていません)。どちらの検索も大文字小文字を区別しません。FTS3テーブルのディスク消費量は、通常のテーブルが1453 MBであるのに対し、FTS3テーブルは約2006 MBです。上記の SELECT クエリの実行に使用したのと同じハードウェア構成を使用した場合、FTS3 テーブルの入力に要した時間は、通常のテーブルが 25 分であったのに対し、31 分弱でした。</target>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">もちろん、ハードウェア、ファイルシステム、オペレーティング・システムによって異なる場合があります。特定のデザインにコミットする前に、ターゲットハードウェアでこれらの数字をダブルチェックしてください。</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">これらの変更のうち、形式的な意味での非互換性があるのは 1a と 2a から 2c だけです。しかし、以前に SQLite ソースにカスタムの変更を加えたことのあるユーザ(例えば、組み込みハードウェア用のカスタム OS レイヤを追加するなど)は、これらの変更がより大きな影響を与えることに気づくかもしれません。一方で、これらの変更の重要な目的は、異なるオペレーティングシステムで使用するためのSQLiteのカスタマイズをより簡単にすることです。</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">SQLiteの古いバージョンは、読み取り専用のWALモードデータベースを読み取ることができませんでした。つまり、WALモードのデータベースを読み取るには、書き込みアクセス権が必要でした。この制約は、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;バージョン3.22.0&lt;/a&gt;（2018-01-22）から緩和されました。</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">古いバージョンのfirebirdでは、SELECT DISTINCTやUNIONからはすべてのNULLを省略しています。</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">MSVC ユーザーがビルドしやすくするために、makefile での &quot;awk&quot; の使用をすべて省略しました。</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">省略されたパラメータは、デフォルト値を使用します。STEPのデフォルト値は1です。END のデフォルトは 9223372036854775807 です。START のデフォルト値は 0 です。</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">Androidでは、インターネットの怪しげなコーナーからダウンロードした信頼できないアプリから渡された任意のSQLを盲目的に実行するサービスがたくさんあると言われています。Androidのサービスは、信頼されていないソースからのSQLを実行することについては、より警戒されているはずだ。筆者はそれに反して具体的な例を持っていないが、存在するという噂を聞いたことがある。仮にすべての Android サービスがより慎重になり、実行するすべての SQL を適切に検証したとしても、それらが安全であることを確認するためにすべての SQL を監査することは難しいだろう。それゆえ、セキュリティに関心のある人たちは、任意のSQLテキストを渡すことで悪用されることがないようにしたいと考えている。</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">Linux やその他の Unix システムでは、次のように入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">Win32では、存在しないファイルを削除しようとしてもエラーを返さないようにしました。</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">Windows システムでは、フォルダは次の順序で検索されます。</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">MSVCを搭載したWindowsでは、Makefile.mscでnmakeを使用します。</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">Windowsでは、入力します。</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">上の&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;、WALは、第一のXSYNC方法使用永続ストレージにフラッシュされる&lt;a href=&quot;c3ref/io_methods&quot;&gt;VFSを&lt;/a&gt;。次に、WALの有効なコンテンツがデータベースファイルに転送されます。最後に、データベースは別のxSyncメソッド呼び出しを使用して永続ストレージにフラッシュされます。xSync操作は書き込みバリアとして機能します。xSyncの前に起動されたすべての書き込みは、xSyncの開始後に起動される書き込みの前に完了する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">インデックスを使用するDISTINCTクエリでは、適切なインデックスが利用可能な場合には、行をステップスルーするのではなく、インデックスを使用して次の明確なエントリにスキップしてみてください。</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">従来のスピニングディスクでは、セクタとは、読み取りと書き込みの両方の方向の転送の最小単位である。しかし、フラッシュメモリでは、通常、読み込みの最小サイズは書き込みの最小サイズよりもはるかに小さくなります。SQLiteは最小書き込み量にしか関心がないので、この記事では「セクタ」というと、大容量ストレージに一度に書き込める最小データ量のことを指します。</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">上&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ROWIDまたはINTEGER PRIMARY KEY列が明示的に値が与えられていない場合、それは通常、1つ以上の現在使用されている最大ROWIDより、未使用整数で自動的に満たされます。これは、AUTOINCREMENTキーワードが使用されているかどうかに関係なく当てはまります。</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">UPSERTでは、制約チェックの順序が再配置される場合、挿入されたコンテンツのアフィニティ変換が制約チェックの前に行われることを確認してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9eの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">undo::undo または undo::redo を呼び出すたびに、undo/redo モジュールは、すべてのトップレベルの名前空間で status_refresh および reload_all メソッドを自動的に呼び出します。これらのメソッドは、表示を再構築したり、データベースに対する undo/redone の変更に基づいてプログラムの状態を更新したりするために定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">同期ファイルシステムを持つ組み込みシステムでは、TRUNCATEはPERSISTよりも動作が遅くなります。コミット操作は同じ速度です。しかし、ファイルの最後に追加するよりも既存のコンテンツを上書きする方が速いため、TRUNCATEの後に続くトランザクションは遅くなります。新しいジャーナルファイルエントリはTRUNCATEの後に常に追加されますが、通常はPERSISTで上書きされます。</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">ほとんどのシステムでは、malloc()システムコールは 8 バイトの境界に整列したバッファを返します。しかし、一部のシステム (例:windows)では malloc()は 4 バイトアライメントされたポインタを返します。このコンパイル時オプションは、malloc()から 4 バイトアライメントされたポインタを返すシステムで使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">新しいバージョンのSQLiteでは、読み取り専用メディア上のWALモードデータベースや、書き込み権限を持たないWALモードデータベースでも、以下の条件の1つ以上が満たされていれば読み込むことができます。</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">起動時に、&lt;b&gt;sqlite3&lt;/b&gt;プログラムは短いバナーメッセージを表示し、SQLの入力を要求します。SQLステートメントを入力し（セミコロンで終了）、[Enter]を押すとSQLが実行されます。</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">起動時に、アプリケーションは最初に表示したいバージョンを決定します。versionIdは当然ながら時間の経過とともに増加し、通常は最新のバージョンを表示したいので、適切なクエリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">成功すると、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;が返され、新しい&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOBハンドル&lt;/a&gt;が* ppBlobに格納されます。それ以外の場合、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が返され、エラーコードがSQLITE_MISUSEでない限り、* ppBlobはNULLに設定されます。つまり、APIが誤用されていない限り、この関数が返した後、* ppBlobで&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;を呼び出しても常に安全です。</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">成功すると、&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;が返され、新しい&lt;a href=&quot;blob&quot;&gt;BLOBハンドル&lt;/a&gt;が* ppBlobに格納されます。それ以外の場合、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が返され、エラーコードがSQLITE_MISUSEでない限り、* ppBlobはNULLに設定されます。つまり、APIが誤用されていない限り、この関数が返した後、* ppBlobで&lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;を呼び出しても常に安全です。</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">成功すると、&lt;b&gt;sqlite_compile&lt;/b&gt;は&lt;b&gt;SQLITE_OKを&lt;/b&gt;返します。それ以外の場合は、エラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_blob_read（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_blob_read（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">成功すると、sqlite3_blob_write（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。SQLITE_MISUSEが返されない限り、この関数は、&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;と&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;および関連する関数を介してアクセス可能な&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;エラーコードとメッセージを設定します。</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">成功すると、sqlite3_blob_write（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。SQLITE_MISUSEが返されない限り、この関数は、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;および関連する関数を介してアクセス可能な&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;エラーコードとメッセージを設定します。</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_prepare（）ファミリーのルーチンは&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを返し&lt;/a&gt;ます。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_prepare（）ファミリーのルーチンは&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKを返し&lt;/a&gt;ます。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">Macでは、このプラグマを設定することができます。</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">一方、サーバーを使用するデータベースエンジンは、クライアントアプリケーションのバグからより良い保護を提供することができます。また、サーバは単一の永続的なプロセスであるため、データベースへのアクセスをより正確に制御することができ、より細かい粒度のロックとより良い同時実行が可能になります。</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">一方、サーバーを使用するデータベースエンジンは、クライアントアプリケーションのバグからより良い保護を提供することができます。また、サーバは単一の永続的なプロセスであるため、データベースへのアクセスをより正確に制御することができ、より細かなロックとより良い同時実行が可能になります。</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">一方、RBUバキュームは通常のSQLite VACUUMよりも多くのCPUを使用します。このため、RBU VACUUMは、同じ条件下ではSQLite VACUUMよりも大幅に遅くなることがよくあります。</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">一方で、テーブルのドロップはあまり一般的な操作ではないので、SQLiteがもう少し時間がかかっても、それは大きな問題とは思われません。</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">一方、副問い合わせの結果を複数回スキャンしなければならない場合(例えば、ジョインの中の1つのテーブルだけであるため)、副問い合わせを複数回計算しないようにするために、副問い合わせの結果全体を記憶するために過渡的なテーブルを使用する方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">一方、WALファイルのサイズが大きくなると、各リーダーがWALファイルの内容をチェックしなければならず、チェックに要する時間はWALファイルのサイズに比例するため、読み取り性能が低下します。wal-indexはWALファイル内のコンテンツをより速く見つけるのに役立ちますが、WALファイルのサイズが大きくなるとパフォーマンスは低下します。したがって、良好な読み取り性能を維持するためには、一定の間隔でチェックポイントを実行してWALファイルのサイズを抑えることが重要です。</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">スタック表示では、ほとんどのエントリは、そのスタックエントリのデータ型を示すプレフィックスで表示されます。整数は「 &lt;code&gt;i:&lt;/code&gt; 」で始まります。浮動小数点値は「 &lt;code&gt;r:&lt;/code&gt; 」で始まります。 （「r」は「実数」を表します。）文字列は「 &lt;code&gt;s:&lt;/code&gt; 」、「 &lt;code&gt;t:&lt;/code&gt; 」、「 &lt;code&gt;e:&lt;/code&gt; 」または「 &lt;code&gt;z:&lt;/code&gt; 」で始まります。文字列プレフィックスの違いは、メモリの割り当て方法が原因です。 z：文字列は、&lt;b&gt;malloc（）&lt;/b&gt;から取得したメモリに格納されます。 t：文字列は静的に割り当てられます。 e：文字列は短命です。他のすべての文字列にはs：プレフィックスがあります。これは観察者であるあなたに何の違いもありません、ただし、z：文字列を渡す必要があるため、VDBEにとって非常に重要です。&lt;b&gt;&lt;/b&gt;メモリリークを回避するためにポップされたときの&lt;b&gt;free（）&lt;/b&gt;。文字列値の最初の10文字だけが表示され、バイナリ値（MakeRecord命令の結果など）は文字列として扱われることに注意してください。VDBEスタックに格納できる他の唯一のデータ型はNULLで、接頭辞なしで単に「 &lt;code&gt;NULL&lt;/code&gt; 」として表示されます。整数が整数と文字列の両方としてスタックに配置されている場合、その接頭辞は &quot; &lt;code&gt;si:&lt;/code&gt; &quot;です。</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">unix システム (または cygwin や mingw+msys を使用している Windows)では、このコマンドは通常次のようになります。</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">unixでは、データベースファイルへのシンボリックリンクが開かれた場合、対応するジャーナルファイルはシンボリックリンク名ではなく実際のファイル名に基づいています。</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">unix ライクなシステムでは、ディレクトリは以下の順序で検索されます。</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">Windowsのみで、すべての「 &lt;code&gt;\&lt;/code&gt; 」文字を「 &lt;code&gt;/&lt;/code&gt; 」に変換します。</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">Windowsのみで、ファイル名がドライブ文字で始まる場合は、単一の「 &lt;code&gt;/&lt;/code&gt; 」文字を先頭に追加します。</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">一度は</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">VFSが登録されたら、決して変更しないでください。動作の変更が必要な場合は、新しいVFSを登録する必要があります。アプリケーションは、おそらく、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;を使用して古いVFSを特定し、古いVFSのコピーを新しい&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトに作成し、新しいVFSに必要な変更を加え、古いVFSの登録を解除し、新しいVFSを場所。登録を解除した後でも、既存のデータベース接続は古いVFSを使用し続けますが、新しいデータベース接続は新しいVFSを使用します。</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">接続がテーブルロックを取得すると、現在のトランザクション(読み取りまたは書き込み)が終了するまで解放されません。</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">プロセスが排他的ロックを取得すると、データベースファイルへの書き込みが許可されます。その後、ロールバック・ジャーナルからページの元の内容を読み取り、その内容をデータベース・ファイルの元の場所に書き戻します。ロールバックジャーナルのヘッダには、中断されたトランザクションが開始される前のデータベースファイルの元のサイズが記録されていることを思い出してください。SQLiteはこの情報を使用して、不完全なトランザクションが原因でデータベースが大きくなった場合に、データベースファイルを元のサイズに戻すために切り詰めます。このステップの終了時には、データベースは同じサイズになり、中断されたトランザクションの開始前と同じ情報が含まれているはずです。</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">テーブルがセッションオブジェクトにアタッチされると、セッションオブジェクトは、テーブルに挿入されたすべての新しい行の主キーの値を記録します。また、削除された行や更新された行の元の主キーやその他の列の値も記録されます。それぞれのユニークな主キー値に対して、データが記録されるのは1回だけです。</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">トランザクションがオープンされると、データベース接続からデータを読み込むのは簡単な操作です。データベースファイル上で開いているファイルハンドルの xRead()メソッドを使用して、必要なデータベースファイルのページを一度に一つずつ読み込みます。SQLite は部分的なページを読み込むことはなく、常に必要なページごとに xRead()を 1 回だけ呼び出します。</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">仮想テーブルが作成されると、上記の例外を除き、特定の仮想テーブルの実装によって強制される他のテーブルと同じように使用できます。仮想テーブルは、通常の&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;構文を使用して破棄されます。</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">繰り返しになりますが、実用的な実装ではこの構造体をサブクラス化してプライベートフィールドを追加することになるでしょう。</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">繰り返しになりますが、SQL文は同じバイトコードを生成するので、全く同じ方法で全く同じ仕事をします。しかし、2つ目の形式では、クエリパラメータをWHERE句に分散させるのではなく、1つの行の値にまとめることで、人間が読みやすくなっています。</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">すべてのロールバックジャーナルファイルがディスクにフラッシュされると、データベースファイルの更新を開始しても安全です。変更を書き込む前に、すべてのデータベースファイルの排他的ロックを取得しなければなりません。すべての変更が書き込まれた後は、電源障害やオペレーティングシステムのクラッシュが発生した場合でも変更を保存できるように、変更をディスクにフラッシュすることが重要です。</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">SQLite データベースがオープンされると、そのデータベースは</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">一度データベースに設定したエンコーディングは変更できません。</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">排他的なロックがかかっていれば、他のプロセスがデータベースファイルから読み込んでいないことがわかり、データベースファイルに変更を書き込むことは安全です。通常、これらの変更はオペレーティングシステムのディスクキャッシュの範囲内でしか行われず、大容量ストレージには到達しません。</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">変換が行われ、どちらの値もNULLでなければ、値が比較されます。両方の値がblobの場合は,比較の結果を決定するためにmemcmp()が使用されます。両方の値がテキストの場合は,P4で指定された適切な照合関数が比較のために使用されます.P4 が指定されていない場合は、memcmp()がテキスト文字列の比較に使用されます。両方の値が数値の場合、数値比較が使用されます。2つの値が異なるタイプのものであれば、数値は文字列よりも小さく、文字列はブロブよりも小さいとみなされます。</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">すべての準備が整ったら、「 &lt;code&gt;fossil commit&lt;/code&gt; 」コマンドを実行して変更をチェックインします。これにより、上図の円（4）が作成されます。</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">1つは、それぞれのスライドを別々に格納するという概念に快適になったら、それはプレゼンテーションのバージョン管理をサポートするための小さなステップです。次のスキーマを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">一度埋め込んだ後、FTS5テーブルの内容に対してフルテキストクエリを実行するには、3つの方法があります。</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">パージされるダーティなページが書き込み可能になると、それは単にデータベースファイルに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">FROM句からの入力データがWHERE句式(あれば)でフィルタリングされると、単純なSELECTの結果行のセットが計算されます。これがどのように行われるかは、単純なSELECTが集約クエリか非集約クエリか、GROUP BY句が指定されているかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">プロジェクトリポジトリを作成したら、プロジェクトのソースコードをすべて保管しておきたいディレクトリに移動して、プロジェクトのオープンチェックアウトを作成し、タイピングを行います。</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">spellfix1 拡張モジュールを読み込むと、spellfix1 仮想テーブルのインスタンスがこのように作成されます。</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">テストプログラムが生成されると、テストを実行するために引数なしで実行されます。進捗情報とエラー診断は、標準出力に表示されます。(標準出力チャネルを持たない組み込み機器の場合は、コンパイル時のオプションを使用して、代替の出力を設定することができます)。プログラムは、エラーがない場合はゼロを返し、問題が検出された場合はゼロ以外を返します。</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">仮想テーブルが作成されると、以下のように問い合わせができます。</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">特定のバージョンを見つけたら、そのバージョンのハイパーリンクをクリックして、「チェックイン情報ページ」を見てください。その後、「Tarball」リンクまたは「ZIPアーカイブ」リンクをクリックして、完全なソースツリーをダウンロードしてください。</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">このクエリへのアプローチの1つは、WHERE句のfruit = 'Orange'用語を使用してオレンジを扱うすべての行を検索し、カリフォルニア以外の州からの行をすべて拒否することによってそれらの行をフィルター処理することです。このプロセスは、上の&lt;a href=&quot;#fig7&quot;&gt;図7に&lt;/a&gt;示されています。これは、ほとんどの場合、完全に妥当なアプローチです。はい、データベースエンジンはフロリダのオレンジ色の行に対して追加のバイナリ検索を実行する必要があったため、後で拒否されたため、期待したほど効率的ではありませんでしたが、多くのアプリケーションでは十分に効率的です。</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">モジュール名の後にカンマ区切りの引数を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">「.eqp on」コマンドを使用して、&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;を自動EXPLAIN QUERY PLANモードに設定することもできます。</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">また、セーブポイントをトランザクションのタイムラインにおける「マーク」と考えることもできます。このビューでは、SAVEPOINTコマンドは新しいマークを作成し、ROLLBACK TOコマンドはタイムラインを指定されたマークの直後のポイントに巻き戻し、RELEASEコマンドは実際にデータベースに変更を加えることなくタイムラインからマークを消去します。</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">このようなプラグマを使って、WALモードから明示的に切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">OR-by-UNIONテクニックを利用して、WHERE句がANDで結ばれた用語を持つクエリで、ユニオンの代わりにインターセクト演算子を使用することで、複数のインデックスを使用することができることがわかります。多くのSQLデータベースエンジンはこれを実行します。しかし、単一のインデックスを使用した場合のパフォーマンスの向上はわずかであるため、現在のところSQLiteではこのテクニックは実装されていません。しかし、将来のバージョンの SQLite は AND-by-INTERSECT をサポートするように拡張されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">仮想テーブルにトリガーを作成することはできません。</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">仮想テーブルに追加のインデックスを作成することはできません。（仮想テーブルはインデックスを持つことができますが、仮想テーブルの実装に組み込む必要があります。インデックスは、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントを使用して個別に追加することはできません。）</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">一般的なツールを使って OpenDocument プレゼンテーションの内容を閲覧、変更、抽出することは簡単にはできません。OpenDocument ドキュメントを閲覧・編集する唯一の合理的な方法は、OpenDocument を読み書きするために特別に設計されたアプリケーショ ンを使って開くことです(読み方:LibreOffice やその従兄弟の一つ)。状況はもっと悪いかもしれません。プレゼンテーションから個々の画像を抽出して表示するには、単に「zip」アーカイバツールを使用します。しかし、それはスライドからテキストを抽出しようとすると合理的ではありません。すべてのコンテンツは、単一の ³&quot;context.xml³&quot;ファイルに格納されていることを覚えておいてください。そのファイルはXMLなので、テキストファイルです。しかし、それは通常のテキストエディタで管理できるテキストファイルではありません。上のプレゼンテーションの例では、content.xmlファイルはちょうど2行で構成されています。ファイルの1行目は、ただの</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">仮想テーブルに対して&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;コマンドを実行することはできません。</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Next命令とListRead命令の違いの一つは、「モノ」の考え方です。Next命令の「モノ」はデータベースファイル内のレコードです。&quot;ListReadの「もの」は、リスト内の整数キーです。もう一つの違いは、次の &quot;もの &quot;がない場合に、ジャンプするかフォールスルーするかということです。この場合、Nextはスルーし、ListReadはジャンプします。後に、同じ原理で動作する他のループ命令(NextIdxとSortNext)を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">この一例は、2013-08-30年に&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCSの&lt;/a&gt;正規リポジトリで発生しました。そのイベントでは、ファイル記述子2（標準エラー）が&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）の&lt;/a&gt;前に誤って閉じられていたため（おそらく&lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;によって）、リポジトリデータベースファイルに使用されるファイル記述子は2でした。その後、アプリケーションのバグによりassert（ ）ステートメントでwrite（2、...）を呼び出してエラーメッセージを出力します。しかし、ファイル記述子2がデータベースファイルに接続されたため、エラーメッセージがデータベースの一部を上書きしました。この種の問題を防ぐために、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;バージョン3.8.1&lt;/a&gt;（2013-10-17）以降では、データベースファイルに小さい番号のファイル記述子を使用することを拒否しています。（&lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTORを&lt;/a&gt;参照してください 詳細については）。</target>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">SQLiteの型なしの例外として、型がINTEGER PRIMARY KEYであるカラムがあります。(そして、&quot;INT &quot;ではなく &quot;INTEGER &quot;を使用しなければなりません。INT PRIMARY KEY型のカラムは、他のカラムと同様に型無しです)。INTEGER PRIMARY KEY カラムは 32 ビット符号付き整数を含まなければなりません。整数以外のデータを挿入しようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">上記の意味するところは、1つのセッション内で変更が行われた後に変更が解除された場合(例えば、行が挿入された後に再び削除された場合など)、セッションモジュールは変更を全く報告しないということです。あるいは、同じセッション内で行が複数回更新された場合、すべての更新はチェンジセットやパッチセットブロブ内の1つの更新にまとめられます。</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">マルチ・ギガバイトのデスクトップの時代には、文書全体をメモリに読み込んでもいいのではないかという議論があるかもしれません。しかし、それは大丈夫ではありません。まず、使用されるメモリの量は、ディスク上の(圧縮された)ファイルサイズをはるかに超えています。そのため、50MBのプレゼンテーションには200MB以上のRAMが必要になるかもしれません。一度に一つの文書を編集するだけならまだ問題ありません。しかし、トークに取り組んでいるとき、この著者は通常、10または15の異なるプレゼンテーションをすべて同時にアップしているでしょう(過去のプレゼンテーションからのスライドのコピー/貼り付けを容易にするために)ので、メモリのギガバイトが必要です。それに加えて、開いているWebブラウザやデスクトップアプリケーションをいくつか追加すると、突然ディスクが回転し、マシンが入れ替わるようになります。そして、ちょうど単一のドキュメントを持っていても、Ubuntuで改装された安価なChromebookで作業するときに問題となっています.少ないメモリを使うのは常に良いことです。</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">一つは、他の提供する場合があります&lt;a href=&quot;compile&quot;&gt;コンパイル時のオプション&lt;/a&gt;など&lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt;や&lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt;全文検索のため、&lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; R *ツリー検索エンジンの拡張のために、&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1を&lt;/a&gt;含めるように&lt;a href=&quot;json1&quot;&gt;JSON SQL関数&lt;/a&gt;、または&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTABを&lt;/a&gt;するために&lt;a href=&quot;dbstat&quot;&gt;仮想テーブルdbstat&lt;/a&gt;。で余分な解説を見るために&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;リスト、追加&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTSを&lt;/a&gt;オプション。 UNIXシステムで、ホストマシンがusleep（）システムコールをサポートしている場合は、-DHAVE_USLEEP = 1を追加します。 -DHAVE_READLINEおよび-lreadlineおよび-lncursesライブラリを追加して、コマンドライン編集サポートを取得します。一部のコンパイラ最適化スイッチを指定することもできます。 （SQLite Webサイトからダウンロードできるプリコンパイル済みCLIは「-Os」を使用します。）ここには無数の可能なバリエーションがあります。フル機能のシェルをコンパイルするコマンドは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">コンテンツをより小さな断片に分割することの小さな欠点は、短いテキストでは圧縮がうまく機能しないため、ドキュメントのサイズが大きくなる可能性があるということです。しかし、文書スペースの大部分は画像の保存に使用されているため、テキストコンテンツの圧縮効率が少し低下してもほとんど気にならないでしょう。</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">10進数10桁のASCII文字のうちの1つ、または</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">52文字の大文字と小文字のASCII文字のうちの1つ、または</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">SQLiteの&lt;a href=&quot;different&quot;&gt;特徴の&lt;/a&gt; 1つは、データベースが単一のディスクファイルで構成されることです。データベースの移動やバックアップは、単一のファイルをコピーするのと同じくらい簡単なので、SQLiteの使用が簡単になります。また、SQLiteを&lt;a href=&quot;whentouse#appfileformat&quot;&gt;アプリケーションファイル形式&lt;/a&gt;として使用するのにも適しています。しかし、完全なデータベースは単一のディスクファイルに保持されますが、SQLiteはデータベースの処理中に多くの一時ファイルを利用します。</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">ALLまたはDISTINCTキーワードのいずれかが、単純なSELECTステートメントのSELECTキーワードの後に​​続く場合があります。単純なSELECTがSELECT ALLの場合、結果行のセット全体がSELECTによって返されます。 ALLもDISTINCTも存在しない場合、動作はALLが指定されたかのようになります。単純なSELECTがSELECT DISTINCTの場合、結果の行のセットから重複する行が削除されてから返されます。重複行を検出するために、2つのNULL値は等しいと見なされます。&lt;a href=&quot;datatype3#colrules&quot;&gt;通常の規則は、&lt;/a&gt;テキスト値を比較するための照合順序を選択するために適用されます。</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">プロジェクトの一部としてコードジェネレーターツールをホスティングする利点の1つは、プロジェクト全体の特定のニーズに対応するためにツールを最適化できることです。Lemonはこの効果の恩恵を受けています。長年にわたり、Lemon パーサージェネレータは拡張され、SQLiteに新しい機能とパフォーマンスの向上を提供するために強化されてきました。SQLiteで使用するために特別に設計されたLemonの具体的な機能強化には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">VFSインターフェースの興味深い機能の1つは、SQLiteが複数のVFSを同時にサポートできることです。各&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;を使用して接続が最初に開かれるときに、その使用のために単一のVFSを選択する必要があります。ただし、プロセスに複数の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が含まれている場合、それぞれが異なるVFSを選択できます。 VFSは、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;インターフェイスを使用して実行時に追加できます。</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Fossilが提供する多くのレポートの1つは、単一のブランチへの変更のタイムラインで、そのブランチに出入りするすべてのマージを示しています。このようなレポートの典型的な例については、&lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http：//www.sqlite.org/src/timeline？nd＆n = 200＆r = trunk&lt;/a&gt;を参照してください。このようなレポートの生成には、通常数ミリ秒しかかかりません。しかし、NGQPにアップグレードした後、この1つのレポートがリポジトリのトランクに10秒近くかかっていることに気付きました。</target>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">SQLiteがシステムクラッシュや停電全体でトランザクションをアトミックにするために行うことの1つは、データベースを変更する前に、すべての変更をロールバックジャーナルファイルに書き込むことです。 TCLテストハーネスには、これが正しく行われていることを確認するのに役立つ代替の&lt;a href=&quot;vfs&quot;&gt;OSバックエンド&lt;/a&gt;実装が含まれています。 「ジャーナルテストVFS」は、データベースファイルとロールバックジャーナルの間のすべてのディスクI / Oトラフィックを監視し、最初に書き込まれてロールバックジャーナルに同期されていないものがデータベースファイルに書き込まれていないことを確認します。不一致が見つかった場合、アサーションエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">テーブルの1つ以上のインデックスが現在分析されてい&lt;em&gt;ないか&lt;/em&gt;、前回のANALYZEの実行以降、テーブルの行数が25倍以上増加しています。</target>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">ディスク上に作成されてから(どのような接続でも)、現在のwalファイルに1つ以上のトランザクションが書き込まれていなければなりません。これは、最初に開いた直後に wal ファイルがない wal モードのデータベースでスナップショットを撮影することはできないことを意味します。少なくとも1つのトランザクションが最初に書き込まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">1つの解決策は、データベーススキーマにSQL外部キー制約を追加して</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">この問題の1つの解決策は、SQLiteを変更して、最適なパスを徹底的に検索することです。しかし、徹底的な検索にはKに比例した時間が必要です。（Kは結合内のテーブルの数です）したがって、10方向結合を超えると、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;を実行する時間が非常に長くなります。</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">全表スキャンを回避するための1つの方法は、ROWID（または同等の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;）によるルックアップを行うことです。桃の価格を調べるには、ROWIDが4のエントリをクエリします。</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">GitとFossilの両方の1人のユーザーが&lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;HNで書き込みます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">SQLiteで使用されている検証手法の1つは、テストスイート全体を2回実行し、1回目は最適化をオンにしたまま、2回目は最適化をオフにして、2回とも同じ出力が得られることを検証するというものです。これは、最適化がエラーを発生させないことを示しています。</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">1つの非常に単純なスキームは、各結果ドキュメント内のユーザー検索語のインスタンスの数をカウントすることです。用語のインスタンスが多数含まれているドキュメントは、各用語のインスタンスが少ないドキュメントよりも関連性が高いと見なされます。 FTSアプリケーションでは、各結果の項インスタンスの数は、&lt;a href=&quot;fts3#offsets&quot;&gt;オフセット&lt;/a&gt;関数の戻り値の整数の数を数えることで決定できます。次の例は、ユーザーが入力したクエリに対して最も関連性の高い10個の結果を取得するために使用できるクエリを示しています。</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">この問題を回避する一つの方法は、sqlite3_step()呼び出しで返される拡張エラーコードをチェックすることです。ブロッキング接続がある場合、拡張エラーコードはSQLITE_LOCKED_SHAREDCACHEに設定されます。そうでなければ、特別な &quot;DROP TABLE/INDEX &quot;の場合、拡張エラーコードはSQLITE_LOCKEDだけになります。</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">FindFrame(P,M)を計算する一つの方法は、M番目のエントリから始まり、最初のエントリに向かって遡っていくaPgno配列をスキャンし、aPgno[J]==PでJを返すというものです。このようなアルゴリズムは機能し、ページ番号Pの最新のフレームをWALファイル全体から探すよりも高速です。</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">インポスターテーブルを作成する1つの方法は、sqlite_masterテーブルを直接編集して、テーブルを記述する新しい行を挿入することです。例えば、スキーマが次のようなものだとします。</target>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">シェルスクリプトでsqlite3を使う一つの方法は、&quot;echo &quot;や &quot;cat &quot;を使ってファイルに一連のコマンドを生成し、生成されたコマンドファイルから入力をリダイレクトしながらsqlite3を起動することです。これはうまく動作し、多くの状況で適切です。しかし、追加の利便性として、sqlite3は単一のSQLコマンドをデータベース名の後の第二引数としてコマンドラインに入力することができます。sqlite3プログラムが2つの引数で起動されると、2番目の引数は処理のためにSQLiteライブラリに渡され、クエリ結果はリストモードで標準出力に印刷され、プログラムは終了します。この仕組みは、&quot;awk &quot;のようなプログラムと組み合わせてsqlite3を使いやすくするためのものです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">R*Treeインデックスを使用しなくても、以下のより単純なクエリを使用して同じ答えを得ることができます。</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">ワンステップクエリ実行インタフェース</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">オンラインバックアップAPI</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">オンラインバックアップAPI。</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">オンラインバックアップオブジェクト</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">ここではCPUサイクルカウントのみを測定しています。CPUサイクルカウントはエネルギー消費量の良いプロキシですが、実際のタイミングとの相関性はあまり必要ありません。I/Oを行っていた時間はCPUサイクルカウントには反映されておらず、多くのSQLite使用シナリオではI/O時間が主に使用されています。</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">一度に1つのデータベース接続に1つのオーソライザーだけを配置することができます。sqlite3_set_authorizerの各呼び出しは前の呼び出しを上書きします。NULLコールバックをインストールすることでオーサライザを無効にします。オーサライザはデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに一度に定義できる進行ハンドラは1つだけです。新しい進捗ハンドラを設定すると、古いハンドラがキャンセルされます。パラメータXをNULLに設定すると、進捗ハンドラが無効になります。Nを1未満の値に設定すると、進行状況ハンドラーも無効になります。</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに一度に定義できる進行ハンドラは1つだけです。新しい進捗ハンドラを設定すると、古いハンドラがキャンセルされます。パラメータXをNULLに設定すると、進捗ハンドラが無効になります。Nを1未満の値に設定すると、進行状況ハンドラーも無効になります。</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT、UPDATE、またはDELETEステートメントによって直接行われた変更のみが考慮され&lt;a href=&quot;../lang_createtrigger&quot;&gt;ます。トリガー&lt;/a&gt;、&lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;外部キーアクション、&lt;/a&gt;または&lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt;制約の解決によって引き起こされた補助的な変更はカウントされません。</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT、UPDATE、またはDELETEステートメントによって直接行われた変更のみが考慮され&lt;a href=&quot;lang_createtrigger&quot;&gt;ます。トリガー&lt;/a&gt;、&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外部キーアクション、&lt;/a&gt;または&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;制約の解決によって引き起こされた補助的な変更はカウントされません。</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">インデックスのa列とb列だけが使用可能です。c列は制約を受けておらず、インデックスが使用可能な列の集合に隙間がないため、d列は使用できません。</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">インデックスの a,b,c 列だけが使用可能です。d列はcの右側にあり、cは不等式によってのみ制約されるため、使用できません。</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">2つ以上の接続されたデータベースがすべて変更され、&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;がOFFに設定されておらず、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;がOFF、MEMORY、またはWALに設定されていない場合にのみ、&lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;マスタージャーナル&lt;/a&gt;ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">サイズがしきい値を超えた場合にのみ、&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;ステートメントジャーナル&lt;/a&gt;ファイルを作成します。それ以外の場合、ジャーナルはメモリに保持され、I / Oは発生しません。しきい値は、コンパイル時に&lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt;を使用して、または開始時に&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;）を使用して構成できます。</target>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">WHERE句が真と評価されるテーブルの行のみがインデックスに含まれます。WHERE句式の評価値がNULLまたはFalseの場合、それらの行はインデックスから除外されます。</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">一致する言語の語彙の用語のみが検索されます。したがって、同じテーブルに複数の言語からのエントリを含めることができ、要求された言語のみが使用されます。デフォルトのlangidは0です。</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">SQLite の場合、&quot;ll &quot;長の修飾子だけが違いを生むことがあります。そして、C 言語のインターフェイスを使用しているときだけ違いがあります。</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">ALTER TABLEコマンドのRENAME TABLE、ADD COLUMN、RENAME COLUMNのみサポートしています。DROP COLUMN、ALTER COLUMN、ADD CONSTRAINTなどの他の種類のALTER TABLE操作は省略されています。</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">AND演算子の暗黙のバージョンだけがサポートされています。標準的なクエリ構文クエリの一部として文字列 &quot;AND &quot;を指定すると、用語 &quot;and &quot;を含む文書の集合に対する用語クエリとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">SQLiteを使用するために必要なのは、1.0節で説明した3つのコアルーチンのみです。しかし、有用なインターフェースを提供する他の多くの関数があります。これらの拡張ルーチンは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">COLLATEが正しい場合にのみ、ORDERS-ON-EXPRESSIONSを使用してORDER BYまたはGROUP BYを最適化します。チケット&lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">オペコード名</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">オプコード定義</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">インクリメンタルI/O用のBLOBを開く</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">クエリ対象のテーブルにカーソルを開きます。</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">カーソルP2と同じ一時テーブルを指す新しいカーソルP1を開きます。P2カーソルは、前の&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;オペコードによって開かれている必要があります。一時カーソルのみを複製できます。</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">トランジェントテーブルに新規カーソルP1をオープンします。メインデータベースが読み取り専用であっても、カーソルは常に読み書きで開かれます。エフェメラルテーブルはカーソルを閉じると自動的に削除されます。</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">1行のデータを含む偽のテーブルを指す新しいカーソルを開きます。その1行の内容は、メモリレジスタP2の内容です。つまり、カーソルP1は、レジスタP2に含まれるMEM_Blobの内容のエイリアスになります。</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">データベースファイルで、ルートページがP2であるデータベーステーブルの読み取り専用カーソルを開きます。データベースファイルはP3によって決定されます。P3 == 0はメインデータベースを意味し、P3 == 1は一時テーブルに使用されるデータベースを意味し、P3&amp;gt; 1は対応する接続​​データベースを使用することを意味します。新しいカーソルにP1の識別子を与えます。P1値は連続している必要はありませんが、すべてのP1値は小さい整数である必要があります。P1が負になるのはエラーです。</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">ルートページがP2であるテーブルまたはインデックス上にP1という名前の読み書きカーソルをオープンします(OPFLAG_P2ISREGビットがP5にセットされている場合は、そのルートページがレジスタP2に保持されています-以下を参照)。</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">sqlite3rbu_open(T,A,S)関数を使用してRBUハンドルを開きます。</target>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">ファイル「/home/fred/data.db」を開きます。posixのアドバイザリロックの代わりにドットファイルを使用する特殊なVFS「unix-dotfile」を使用します。</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">読み取り専用のアクセスのために、カレントディレクトリにあるファイル &quot;data.db &quot;を開きます。デフォルトで共有キャッシュモードが有効になっているかどうかに関わらず、プライベートキャッシュを使用します。</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">データベースファイル「/home/fred/data.db」を開きます。</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">データベースファイルを開き、SHAREDロックを取得します。SHARED ロックが取得できない場合は、直ちに失敗して SQLITE_BUSY を返します。</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">カレントディレクトリにある「data.db」というファイルを開きます。</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">2つのカーソルを開き、1つは問い合わせ先の2つのテーブルにそれぞれ1つずつ。</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">パラメータP4で指定されたセーブポイントをオープン、リリース、またはロールバックします。新規セーブポイントを開くには、P1==0 (SAVEPOINT_BEGIN)を設定します。既存のセーブポイントを解放(コミット)するには、P1==1 (SAVEPOINT_RELEASE)を設定します。既存のセーブポイントをロールバックするには、P1==2 (SAVEPOINT_ROLLBACK)を設定します。</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">オープンクローズコールバック</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">新しいデータベース接続を開く</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">新しい接続を開く</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">読み取り専用のトランザクションを開く</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">接続を開く。</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">新しいデータベース接続を開くには、2つのステップがあります。</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">読み取り専用のトランザクションを開く。</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">読み書き可能なトランザクションをオープンします。</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">ステートメント取引を開く。</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">オペランドP1は0x7fffffff、P2は正でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">最適化：&lt;a href=&quot;expridx&quot;&gt;式&lt;/a&gt;にインデックスがあるテーブルで&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;を実行するとき、更新されるテーブルの列を参照していない場合は、式のインデックスを更新しないでください。</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">sqlite_mprintf()ルーチンの最適化。</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof（）&lt;/a&gt;および&lt;a href=&quot;lang_corefunc#length&quot;&gt;length（）&lt;/a&gt; SQL関数を最適化して、ディスクからのデータベースコンテンツの不要な読み取りを回避します。</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">オプティマイザーは、整数の主キーでソートするORDER BY句を満たすためにインデックスを使用することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">オプティマイザの強化：LIKE演算子のRHSでのバインディングが変更されたとき、または&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2で&lt;/a&gt;範囲制約が変更されたときに、&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が自動的に再コンパイルされます。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">オプション1。</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">オプション2</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">オプションの制限と ORDER BY 条項</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">オプションのLIMITとORDER BY句</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">データベース接続が共通のキャッシュを共有している場合のREAD UNCOMMITTED隔離(デフォルトのSERIALIZABLE隔離レベルの代わりに)とテーブルレベルのロックをオプションで指定できます。</target>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">オプションで、テーブルのPRIMARY KEY。シングルカラムとコンポジット(複数カラム)の両方の主キーがサポートされています。</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">&lt;b&gt;sqlite3&lt;/b&gt;コマンドが理解できるオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">または、これらの同一のクエリを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">またはMSVCを搭載したWindows上で。</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">または最適化</target>
        </trans-unit>
        <trans-unit id="fbfd8b5435e1bb1225c27564f4e61467d6052b3a" translate="yes" xml:space="preserve">
          <source>Or perhaps the application would rather use the most recent checkinTime:</source>
          <target state="translated">あるいは、アプリケーションは最新のcheckinTimeを使用したいのかもしれません。</target>
        </trans-unit>
        <trans-unit id="2a55f1def49ba2cf28edd04aebe0ae914d6adc01" translate="yes" xml:space="preserve">
          <source>Or this:</source>
          <target state="translated">それともこれかな</target>
        </trans-unit>
        <trans-unit id="4adffe1f4f67467b27dd86bae1fcc140644a1e80" translate="yes" xml:space="preserve">
          <source>Or to be extra safe with a database and to force SQLite to assume the database lacks powersafe overwrite, open it using</source>
          <target state="translated">また、データベースの安全性を高めるために、SQLiteにデータベースの上書きを強制的に行わせるには、以下のようにしてデータベースを開きます。</target>
        </trans-unit>
        <trans-unit id="beb6e4abd1b3ea2eadafe45050288632422b5468" translate="yes" xml:space="preserve">
          <source>Or,</source>
          <target state="translated">Or,</target>
        </trans-unit>
        <trans-unit id="66d567cd524d8ab999d4e199670d77fab66ce1bc" translate="yes" xml:space="preserve">
          <source>Or, from the SQLite shell tool (the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function reads the contents of a file from the file-system and returns it as a blob):</source>
          <target state="translated">または、SQLiteシェルツールから（&lt;a href=&quot;cli#fileio&quot;&gt;readfile（）&lt;/a&gt;関数はファイルシステムからファイルの内容を読み取り、blobとして返します）：</target>
        </trans-unit>
        <trans-unit id="5555ca89e43c2c41b68ce29dd846f696f04f9021" translate="yes" xml:space="preserve">
          <source>Or, if argument zTab is NULL, then changes are recorded for all tables in the database. If additional tables are added to the database (by executing &quot;CREATE TABLE&quot; statements) after this call is made, changes for the new tables are also recorded.</source>
          <target state="translated">あるいは、引数zTabがNULLの場合、データベース内のすべてのテーブルに対して変更が記録されます。この呼び出しの後に(CREATE TABLE文を実行して)追加のテーブルがデータベースに追加された場合、新しいテーブルの変更も記録されます。</target>
        </trans-unit>
        <trans-unit id="0aca97133f8a0b1812de40afe8dc2efdb01e49c8" translate="yes" xml:space="preserve">
          <source>Or, if double-quoted string literals are disabled by default, but need to be selectively enabled for some historical database connections, that can be done using the same C-code as shown above except with the third parameter changed from 0 to 1.</source>
          <target state="translated">あるいは、二重引用符で囲まれた文字列リテラルがデフォルトでは無効になっているが、過去のデータベース接続のために選択的に有効にする必要がある場合、3番目のパラメータを0から1に変更する以外は、上記と同じCコードを使用して行うことができます。</target>
        </trans-unit>
        <trans-unit id="322edc10740abf86eb6c1728491b5451dec39f1d" translate="yes" xml:space="preserve">
          <source>Or, if sqlite3.c is compiled using some other build system, by arranging for the SQLITE_ENABLE_FTS5 pre-processor symbol to be defined.</source>
          <target state="translated">あるいは、sqlite3.cが他のビルドシステムを使ってコンパイルされている場合、SQLITE_ENABLE_FTS5プリプロセッサシンボルが定義されているように手配してください。</target>
        </trans-unit>
        <trans-unit id="658f77f8eef94489e4209dc1e50f66504ceb72eb" translate="yes" xml:space="preserve">
          <source>Or, if the argument attached to the REINDEX identifies a specific database table, then all indices attached to the database table are rebuilt. If it identifies a specific database index, then just that index is recreated.</source>
          <target state="translated">または、REINDEXに付けられた引数が特定のデータベース・テーブルを特定する場合、データベース・テーブルに付けられたすべてのインデックスが再構築されます。特定のデータベースインデックスを特定した場合は、そのインデックスだけが再構築されます。</target>
        </trans-unit>
        <trans-unit id="60a5aae7483ffe81235af01c0cffa5d4ff23cd22" translate="yes" xml:space="preserve">
          <source>Or, if the table is also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, then the following apply:</source>
          <target state="translated">または、テーブルが&lt;a href=&quot;fts5#contentless_tables&quot;&gt;コンテンツレステーブル&lt;/a&gt;でもある場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="aa1077574bb502a8689f667cb965b8e30b1c1e85" translate="yes" xml:space="preserve">
          <source>Or, if using the autoconf build system, pass the --enable-session option to the configure script.</source>
          <target state="translated">または、autoconf ビルドシステムを使用している場合は、configure スクリプトに --enable-session オプションを渡します。</target>
        </trans-unit>
        <trans-unit id="0ff802a22b003329b02ab696a2c315faad2a0e85" translate="yes" xml:space="preserve">
          <source>Or, multiple presentations could be stored within the same document.</source>
          <target state="translated">あるいは、複数のプレゼンテーションを同一ドキュメント内に保存することもできます。</target>
        </trans-unit>
        <trans-unit id="d354f2e196d0e9cdbbdd8e5133631fe7bd7c69f7" translate="yes" xml:space="preserve">
          <source>Or, the same content can be read using:</source>
          <target state="translated">または、同じ内容を使って読むことができます。</target>
        </trans-unit>
        <trans-unit id="e7aee41fb363d46e588ad49a1b5591b283e863a6" translate="yes" xml:space="preserve">
          <source>Or, to list all changes to one particular account ($xyz) in order of decreasing magnitude, one can write:</source>
          <target state="translated">あるいは、ある特定のアカウント($xyz)へのすべての変更を小さい順にリストアップするには、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="8a1681e612a2025087b703fdf1f8f617e506b053" translate="yes" xml:space="preserve">
          <source>Oracle</source>
          <target state="translated">Oracle</target>
        </trans-unit>
        <trans-unit id="6e8727d6e68eed5d20f3fa889a8e8b2bd24438db" translate="yes" xml:space="preserve">
          <source>Orders of magnitude performance improvement for &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; on very large tables.</source>
          <target state="translated">非常に大きなテーブルでの&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;の桁違いのパフォーマンス向上。</target>
        </trans-unit>
        <trans-unit id="6ce3fb54d989f83f97843b164388df9c55d52716" translate="yes" xml:space="preserve">
          <source>Ordinary Common Table Expressions</source>
          <target state="translated">通常の共通表式</target>
        </trans-unit>
        <trans-unit id="628b6d597a836775d3c57cc85ac20362e62df83f" translate="yes" xml:space="preserve">
          <source>Ordinary SQL statements are free-form, and can be spread across multiple lines, and can have whitespace and comments anywhere. Dot-commands are more restrictive:</source>
          <target state="translated">通常のSQL文は自由形式で、複数の行にまたがることができ、どこでも空白とコメントを持つことができます。ドットコマンドはより制限があります。</target>
        </trans-unit>
        <trans-unit id="410efca163172750b4e7d07d3df715195f75df04" translate="yes" xml:space="preserve">
          <source>Ordinary common table expressions</source>
          <target state="translated">通常の一般的なテーブル表現</target>
        </trans-unit>
        <trans-unit id="d3bfeb484e7ad7fe55b8281bb0d45da13e3151eb" translate="yes" xml:space="preserve">
          <source>Original content of the page prior to the start of the transaction</source>
          <target state="translated">取引開始前のページのオリジナル内容</target>
        </trans-unit>
        <trans-unit id="220b92a9851d65e3f5763bc585c592d7a14215e7" translate="yes" xml:space="preserve">
          <source>Other Issues</source>
          <target state="translated">その他の問題</target>
        </trans-unit>
        <trans-unit id="286c105cf7e1fc8242c5f069e4037b0e5e35102f" translate="yes" xml:space="preserve">
          <source>Other SQL database engines tend to store data as a large collection of files. Often these files are in a standard location that only the database engine itself can access. This makes the data more secure, but also makes it harder to access. Some SQL database engines provide the option of writing directly to disk and bypassing the filesystem all together. This provides added performance, but at the cost of considerable setup and maintenance complexity.</source>
          <target state="translated">他のSQLデータベースエンジンは、データを大きなファイルの集合体として保存する傾向があります。多くの場合、これらのファイルはデータベースエンジン自身だけがアクセスできる標準的な場所にあります。これによりデータはより安全になりますが、アクセスが難しくなります。SQLデータベースエンジンの中には、ディスクに直接書き込んでファイルシステムをバイパスするオプションを提供しているものもあります。これはパフォーマンスを向上させますが、セットアップやメンテナンスの複雑さを犠牲にしています。</target>
        </trans-unit>
        <trans-unit id="5210f14e159e526b00e7b67ae5e00a7489e472f8" translate="yes" xml:space="preserve">
          <source>Other and more complex extensions can be found in subfolders under &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext/&lt;/a&gt; other than ext/misc/.</source>
          <target state="translated">その他、より複雑な拡張は、下のサブフォルダに見つけることができ&lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;内線/&lt;/a&gt;内線/ miscの/以外。</target>
        </trans-unit>
        <trans-unit id="a5885d7d219a9dd314e80ea53c10a7870f48702f" translate="yes" xml:space="preserve">
          <source>Other compile-time options such as using -O3 instead of -Os or using &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; and/or some of the other &lt;a href=&quot;compile#rcmd&quot;&gt;recommended compile-time options&lt;/a&gt; might help SQLite to run even faster relative to direct filesystem reads.</source>
          <target state="translated">このよう-Osの代わりに-O3を使用して、または使用などの他のコンパイル時のオプション&lt;a href=&quot;compile#threadsafe&quot;&gt;0 = -DSQLITE_THREADSAFE&lt;/a&gt;および/または他のいくつかの&lt;a href=&quot;compile#rcmd&quot;&gt;推奨コンパイル時のオプションは、&lt;/a&gt; SQLiteのは、ファイルシステムが読み込み指示し、さらに高速相対実行するために役立つかもしれないが。</target>
        </trans-unit>
        <trans-unit id="68a8c532629b4cb41be7b1e40786ac6ad241781e" translate="yes" xml:space="preserve">
          <source>Other database engines may run great once you get them going. But doing the initial installation and configuration can often be intimidating.</source>
          <target state="translated">他のデータベースエンジンは、一度起動してしまえば素晴らしい動作をするかもしれません。しかし、最初のインストールと設定を行うことは、しばしば威圧的になることがあります。</target>
        </trans-unit>
        <trans-unit id="0d3a3415efe071d534d2ab15cd7fe976055daeb3" translate="yes" xml:space="preserve">
          <source>Other entries in the cost table specific transforms for particular characters. The cost of specific transforms should be less than the default costs, or else the default costs will take precedence and the specific transforms will never be used.</source>
          <target state="translated">特定のキ ャ ラ ク タ に対す る 特定の変換を コ ス ト テーブル内の他の項目。そうでなければ、デフォルトのコストが優先され、特定の変換は決して使われません。</target>
        </trans-unit>
        <trans-unit id="cae24656c6711756dea7bb8cd35f3afb8c810eb8" translate="yes" xml:space="preserve">
          <source>Other experimental memory allocators might be added in future releases of SQLite. One may anticipate that these will be called memsys7, memsys8, and so forth.</source>
          <target state="translated">SQLite の将来のリリースでは、他の実験的なメモリアロケータが追加されるかもしれません。これらは memsys7 や memsys8 などと呼ばれるようになると予想されます。</target>
        </trans-unit>
        <trans-unit id="10c1a85e8f6e1ba9ad67291c0e509d27f0146a7c" translate="yes" xml:space="preserve">
          <source>Other important bug fixes</source>
          <target state="translated">その他の重要なバグ修正</target>
        </trans-unit>
        <trans-unit id="eafff73d48037ade49167d838ce6e1b6a891fb16" translate="yes" xml:space="preserve">
          <source>Other information fields of the sqlite3_rtree_query_info structure are available for use by the xQueryFunc callback, if desired. The iRowid field is the rowid (the first of the 3 to 11 columns in the R*Tree) for the element being considered. iRowid is only valid for leaves. The eParentWithin and rParentScore values are copies of the eWithin and rScore values from the containing subtree of the current row. The anQueue field is an array of mxLevel+1 unsigned integers that tell the current number of elements in the priority queue at each level.</source>
          <target state="translated">sqlite3_rtree_query_info構造体の他の情報フィールドは、必要に応じてxQueryFuncコールバックで使用することができます。iRowidフィールドは、考慮される要素のrowid(R*Treeの3~11列の最初の列)です。eParentWithin値とrParentScore値は、現在の行のサブツリーのeWithin値とrScore値のコピーです。anQueueフィールドは、各レベルでの優先度キューの現在の要素数を示すmxLevel+1の符号なし整数の配列です。</target>
        </trans-unit>
        <trans-unit id="ac116740090073aa7d395dd931c8587b7e5ed819" translate="yes" xml:space="preserve">
          <source>Other kinds of constraints may be used and will work, but other constraints will be checked individually for each row and will not be optimized (at least not initially). All constraint checking is completely automatic regardless of whether or not optimization occurs. The optimization referred to in this bullet point is a performance consideration only. The same result is obtained regardless of whether or not the query is optimized.</source>
          <target state="translated">他の種類の制約を使用しても動作しますが、他の制約は行ごとに個別にチェックされ、最適化は行われません(少なくとも最初は行われません)。最適化が行われるかどうかに関わらず、すべての制約チェックは完全に自動で行われます。この箇条書きで言及されている最適化は、性能のみを考慮したものです。クエリが最適化されているかどうかに関わらず、同じ結果が得られます。</target>
        </trans-unit>
        <trans-unit id="808f70785d1ef92ea5c6148eaa9481e6d0e14aa1" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;constlist&quot;&gt;定数&lt;/a&gt;と&lt;a href=&quot;funclist&quot;&gt;関数&lt;/a&gt;および&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="254b17e4c2182837b7ef0fdd5b3824e226f2c5a8" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;constlist&quot;&gt;定数&lt;/a&gt;と&lt;a href=&quot;funclist&quot;&gt;関数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f2e591c11c09005f92f16a4e53401bee7662b02" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;constlist&quot;&gt;定数&lt;/a&gt;と&lt;a href=&quot;objlist&quot;&gt;オブジェクト&lt;/a&gt;、および&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="710d410006003e6c96fa23b1a96739384d30f239" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt;.</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;constlist&quot;&gt;定数&lt;/a&gt;と&lt;a href=&quot;objlist&quot;&gt;オブジェクト&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc0c16f3fd55dac69e3748a6c043c6447d6ab575" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;objlist&quot;&gt;オブジェクト&lt;/a&gt;と&lt;a href=&quot;funclist&quot;&gt;関数&lt;/a&gt;および&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce8676972cf44ad111328d5252187ad79820f8b7" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;objlist&quot;&gt;オブジェクト&lt;/a&gt;と&lt;a href=&quot;funclist&quot;&gt;関数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e05129b6c75ff832aa70dbb2deb9f7c3bddb6dc" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes</source>
          <target state="translated">その他のマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="d4fc03a4fb1eb22ede8954ef99eea86a034ae6d2" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements</source>
          <target state="translated">その他のマイナーなバグ修正とドキュメントの強化</target>
        </trans-unit>
        <trans-unit id="890b3d475caba8d5bd7557f9c475d8af3c752a15" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements.</source>
          <target state="translated">その他のマイナーなバグ修正とドキュメントの強化。</target>
        </trans-unit>
        <trans-unit id="aa1b8c87b3d167a75e9df291742b29d3051fb50c" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance enhancements.</source>
          <target state="translated">その他、細かなバグ修正とパフォーマンスの向上。</target>
        </trans-unit>
        <trans-unit id="0fa68e95547b847335553befa0f2cb7b67624587" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance optimizations.</source>
          <target state="translated">その他、マイナーなバグフィックスとパフォーマンスの最適化。</target>
        </trans-unit>
        <trans-unit id="1057a4540e5ed3386909678e9ca548cf6300a507" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes in preparation for the first stable release of version 3.3</source>
          <target state="translated">バージョン3.3の最初の安定版リリースに向けて、その他のマイナーなバグ修正を行いました。</target>
        </trans-unit>
        <trans-unit id="f58ff693cc659b1eb66fa3445ac112f3a975e0d7" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes.</source>
          <target state="translated">その他、細かなバグ修正。</target>
        </trans-unit>
        <trans-unit id="3d1e22329a4cb1219246e265a7a252a723c9d5fa" translate="yes" xml:space="preserve">
          <source>Other minor changes and enhancements.</source>
          <target state="translated">その他、細かい変更や機能強化を行っています。</target>
        </trans-unit>
        <trans-unit id="deee6da4efcaf54f2a7bee650d4c13bb508dfa45" translate="yes" xml:space="preserve">
          <source>Other minor documentation and makefile changes and bug fixes.</source>
          <target state="translated">その他の細かいドキュメントとmakefileの変更とバグ修正。</target>
        </trans-unit>
        <trans-unit id="031aa8e8c99846cb30787089a75b424566d207ca" translate="yes" xml:space="preserve">
          <source>Other minor tweaks to improve the quality of &lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; code.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt;コードの品質を改善するためのその他のマイナーな調整。</target>
        </trans-unit>
        <trans-unit id="8b05e7277715773ceabf87f5e50fad5de6b24dd9" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes</source>
          <target state="translated">その他の雑多なバグ修正</target>
        </trans-unit>
        <trans-unit id="5d73e7d5d87f0b601b3cbf8f19cc97602a0f29c4" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes.</source>
          <target state="translated">その他雑なバグ修正。</target>
        </trans-unit>
        <trans-unit id="4b8124041770cac5d89ae555b4ac03153c37ffc1" translate="yes" xml:space="preserve">
          <source>Other miscellaneous enhancements such as loop unrolling.</source>
          <target state="translated">その他、ループ解除などの雑な強化。</target>
        </trans-unit>
        <trans-unit id="6f62eac50d6703d3917c9f2154f9f77dce98abcd" translate="yes" xml:space="preserve">
          <source>Other miscellaneous micro-optimizations for improved performance and reduced memory usage.</source>
          <target state="translated">その他、性能向上やメモリ使用量削減のための雑多なマイクロ最適化。</target>
        </trans-unit>
        <trans-unit id="26485a453cc99f6d07c9ad5f2979b799b10596af" translate="yes" xml:space="preserve">
          <source>Other miscellaneous minor bug fixes.</source>
          <target state="translated">その他、雑な細かいバグ修正。</target>
        </trans-unit>
        <trans-unit id="583fac43540a1c8647f7a52c63c6d87ee3c57112" translate="yes" xml:space="preserve">
          <source>Other miscellaneous performance enhancements.</source>
          <target state="translated">その他雑な性能強化。</target>
        </trans-unit>
        <trans-unit id="d5335cc4f60749bd941dc9764ef3c6855a7a176b" translate="yes" xml:space="preserve">
          <source>Other more familiar database engines run great once you get them going. But doing the initial installation and configuration can be intimidatingly complex.</source>
          <target state="translated">他のより馴染みのあるデータベースエンジンは、一度起動すると素晴らしい動作をします。しかし、最初のインストールと設定を行うことは、威圧的に複雑になることがあります。</target>
        </trans-unit>
        <trans-unit id="453575f6d5ccd906017a354a3747a73c275dcbf4" translate="yes" xml:space="preserve">
          <source>Other pages that talk about Fossil and Git include:</source>
          <target state="translated">他にも、FossilとGitについて語っているページがあります。</target>
        </trans-unit>
        <trans-unit id="1691c79ed589685ad615d8d10ce5d4a24f7887ad" translate="yes" xml:space="preserve">
          <source>Other performance improvements. Uses about &lt;a href=&quot;cpu&quot;&gt;6.5% fewer CPU cycles&lt;/a&gt;.</source>
          <target state="translated">その他のパフォーマンスの改善。&lt;a href=&quot;cpu&quot;&gt;CPUサイクル&lt;/a&gt;を約6.5％削減します。</target>
        </trans-unit>
        <trans-unit id="53a9f15c17fc6f690db9ec48e6c595c7787f86a9" translate="yes" xml:space="preserve">
          <source>Other performance optimizations:</source>
          <target state="translated">その他のパフォーマンスの最適化。</target>
        </trans-unit>
        <trans-unit id="a62bf7250068b9b0c4a25d2045a53dbb9795b912" translate="yes" xml:space="preserve">
          <source>Other programming languages sometimes claim to be &quot;as fast as C&quot;. But no other language claims to be faster than C for general-purpose programming, because none are.</source>
          <target state="translated">他のプログラミング言語は「Cと同じくらい速い」と主張することがあります。しかし、汎用プログラミングにおいてCよりも速いと主張する言語は他にはありません。</target>
        </trans-unit>
        <trans-unit id="b724fba24bcbd81609e47345dfce9dfa38bb53b6" translate="yes" xml:space="preserve">
          <source>Other similar tree-display routines include:</source>
          <target state="translated">他の類似したツリー表示ルーチンには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="eb0b09bd0abc9cbcebf776931eb89745e9f2f6c6" translate="yes" xml:space="preserve">
          <source>Other small bug fixes and optimizations.</source>
          <target state="translated">その他の小さなバグ修正と最適化。</target>
        </trans-unit>
        <trans-unit id="ce257a3574985ec3c0e88eff4d14f53603f86d62" translate="yes" xml:space="preserve">
          <source>Other systems sometimes use assert(X) in a way that is similar to the use of ALWAYS(X) or NEVER(X) in SQLite. Developers will add an assert(X) as a &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;tacit acknowledgement that they do not fully believe that X is always true&lt;/a&gt;. We believe that this use of assert(X) is wrong and violates the intent and purpose of having assert(X) available in C in the first place. An assert(X) should not be seen as a safety-net or top-rope used to guard against mistakes. Nor is assert(X) appropriate for defense-in-depth. An ALWAYS(X) or NEVER(X) macro, or something similar, should be used in those cases because ALWAYS(X) or NEVER(X) will be followed by code to actually deal with the problem when the programmers reasoning turns out to be wrong. Since the code that follows ALWAYS(X) or NEVER(X) is untested, it should be something very simple, like a &quot;return&quot; statement, that is easily verified by inspection.</source>
          <target state="translated">他のシステムでは、SQLiteでのALWAYS（X）またはNEVER（X）の使用と同様の方法でassert（X）を使用することがあります。開発者は&lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;、Xが常に真であると完全には信じていない&lt;/a&gt;という暗黙の了解として、assert（X）を追加します。このassert（X）の使用は誤りであり、最初にCでassert（X）を使用できるようにする意図と目的に違反すると私たちは考えています。assert（X）は、ミスを防ぐために使用されるセーフティネットまたはトップロープと見なされるべきではありません。また、assert（X）は多層防御に適していません。ALWAYS（X）またはNEVER（X）マクロ、または類似の何かがこれらのケースで使用されるべきです間違っている。ALWAYS（X）またはNEVER（X）に続くコードはテストされていないため、「return」ステートメントのように、検査によって簡単に検証できる非常に単純なコードにする必要があります。</target>
        </trans-unit>
        <trans-unit id="34d2c9c7d77d063050411b9cf0d5ad05916eb325" translate="yes" xml:space="preserve">
          <source>Otherwise, an expression has no affinity.</source>
          <target state="translated">そうでなければ、式は親和性を持たない。</target>
        </trans-unit>
        <trans-unit id="6917a7f5da3062b0cb87b819a1b98dde64d2060e" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">それ以外の場合、エラーが発生しなければ、&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（）&lt;/a&gt;はSQLITE_OKを返します。</target>
        </trans-unit>
        <trans-unit id="63ffff1a975b81be129a4faecffea464b53159fd" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">それ以外の場合、エラーが発生しなければ、&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（）&lt;/a&gt;はSQLITE_OKを返します。</target>
        </trans-unit>
        <trans-unit id="f4554128dd35917d0080717168dbd2c249f00b56" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is a column or an alias of an expression that is a column, then the default collation sequence for the column is used.</source>
          <target state="translated">そうでなければ、ORDER BY式が列または列である式のエイリアスである場合、列のデフォルトの照合順序が使用されます。</target>
        </trans-unit>
        <trans-unit id="7e53078a08397e14f15e969e1f704be9f2cd8b70" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is an alias to an expression that has been assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the collation sequence assigned to the aliased expression is used.</source>
          <target state="translated">それ以外の場合、ORDER BY式が、後&lt;a href=&quot;lang_expr#collateop&quot;&gt;置COLLATE演算子&lt;/a&gt;を使用して照合シーケンスが割り当てられた式のエイリアスである場合、エイリアスされた式に割り当てられた照合シーケンスが使用されます。</target>
        </trans-unit>
        <trans-unit id="16e19790e123dd698bb68d8acfc3c250ddf0f26c" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is any other expression, it is evaluated and the returned value used to order the output rows. If the SELECT statement is a simple SELECT, then an ORDER BY may contain any arbitrary expressions. However, if the SELECT is a compound SELECT, then ORDER BY expressions that are not aliases to output columns must be exactly the same as an expression used as an output column.</source>
          <target state="translated">そうでなければ、ORDER BY式が他の式である場合、それが評価され、返された値が出力行の順序付けに使用されます。SELECT文が単純なSELECTの場合、ORDER BYは任意の式を含むことができます。しかし、SELECTが複合SELECTである場合、出力列へのエイリアスではないORDER BY式は、出力列として使用される式と全く同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="74d7943e809a432b89e323d15537e7de75d402f8" translate="yes" xml:space="preserve">
          <source>Otherwise, no affinity is applied and both operands are compared as is.</source>
          <target state="translated">そうでなければ、アフィニティは適用されず、両方のオペランドがそのまま比較されます。</target>
        </trans-unit>
        <trans-unit id="ace2ae60f4f3efb9070beb6a2fed407ad7cd8e65" translate="yes" xml:space="preserve">
          <source>Otherwise, r[P2] is set to the sum of r[P1] and r[P3].</source>
          <target state="translated">そうでなければ、r[P2]は、r[P1]とr[P3]の和に設定される。</target>
        </trans-unit>
        <trans-unit id="c9d8794c47ac5fbe000cffe629c489a9791ed713" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collation sequence is used.</source>
          <target state="translated">それ以外の場合は、&lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;照合シーケンスが使用されます。</target>
        </trans-unit>
        <trans-unit id="35b896906bdef712969f9e7297c680f9a2e53cd3" translate="yes" xml:space="preserve">
          <source>Otherwise, the BINARY collating function is used for comparison.</source>
          <target state="translated">それ以外の場合は、BINARY照合機能を使用して比較を行います。</target>
        </trans-unit>
        <trans-unit id="638ab872140702484af1c059aebc57de13dbd98b" translate="yes" xml:space="preserve">
          <source>Otherwise, the affinity is NUMERIC.</source>
          <target state="translated">そうでなければ、親和性はNUMERICです。</target>
        </trans-unit>
        <trans-unit id="cfc6f8803bf4c712ac864728c4305aa6942d9a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value inserted into this field is the file contents for a regular file, or the target of a symbolic link.</source>
          <target state="translated">そうでなければ、このフィールドに挿入される値は、通常のファイルのファイル内容、またはシンボリックリンクの対象となります。</target>
        </trans-unit>
        <trans-unit id="cb91e52cc1b3ca8f3f684e2966f8d4c11f3cb0b5" translate="yes" xml:space="preserve">
          <source>Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2.</source>
          <target state="translated">そうでなければ、このAPIは、P1がP2よりも古いスナップショットを参照している場合は負の値を、2つのハンドルが同じデータベースのスナップショットを参照している場合は0を、P1がP2よりも新しいスナップショットを参照している場合は正の値を返します。</target>
        </trans-unit>
        <trans-unit id="afebc4d098577eaf408f5312d05f2e55f910ee39" translate="yes" xml:space="preserve">
          <source>Our goal is to make the content you store in SQLite today as easily accessible to your grandchildren as it is to you.</source>
          <target state="translated">私たちの目標は、今日のSQLiteに保存しているコンテンツを、お孫さんにも簡単にアクセスできるようにすることです。</target>
        </trans-unit>
        <trans-unit id="3edd7f9a4b0d8d87dc9885a06cb59a66ad8766a5" translate="yes" xml:space="preserve">
          <source>Out of memory (OOM) error conditions generate error logging events with the SQLITE_NOMEM error code and a message that says how many bytes of memory were requested by the failed allocation.</source>
          <target state="translated">Out of memory (OOM)エラー状態は、SQLITE_NOMEM エラーコードと、割り当てに失敗して要求されたメモリのバイト数を示すメッセージを含むエラーロギングイベントを生成します。</target>
        </trans-unit>
        <trans-unit id="3eb43b3eb70e7d12a47e5820876f3c296dc05bc2" translate="yes" xml:space="preserve">
          <source>Out-of-memory tests</source>
          <target state="translated">記憶喪失テスト</target>
        </trans-unit>
        <trans-unit id="c1bf191f6ccc359ad8a3c05c295f7fe8cef84ae3" translate="yes" xml:space="preserve">
          <source>Outlandish Recursive Query Examples</source>
          <target state="translated">突飛な再帰的クエリの例</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="1bd1112bbbb687e4d808e79cb404cc3ec423a23a" translate="yes" xml:space="preserve">
          <source>Output Change</source>
          <target state="translated">出力変化</target>
        </trans-unit>
        <trans-unit id="0c51e370c031f37870509dc46422ce61ca6e1f16" translate="yes" xml:space="preserve">
          <source>Output columns from the index_info pragma are as follows:</source>
          <target state="translated">index_infoプラグマから出力されるカラムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8383ea0f1fb51fe84444b17104e0dd18b8f3f3b4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_list pragma are as follows:</source>
          <target state="translated">index_listプラグマからの出力カラムは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="bc6e58f2bacd5891df7b631d05c18328e75e62f4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_xinfo pragma are as follows:</source>
          <target state="translated">index_xinfoプラグマからの出力カラムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="d1088854d972e4ceb1796db8756ad3486790779d" translate="yes" xml:space="preserve">
          <source>Output infinity as 1e999 in the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;の「.dump」コマンドで無限大を1e999として出力します。</target>
        </trans-unit>
        <trans-unit id="17e008cf652984308f7573376fc6932528a013cf" translate="yes" xml:space="preserve">
          <source>Output rows can be returned to the application as each small sort completes, and well before the table scan is complete.</source>
          <target state="translated">出力行は、各スモールソートが完了するたびに、テーブルスキャンが完了する前にアプリケーションに返すことができます。</target>
        </trans-unit>
        <trans-unit id="b785807667b898e4c7f09b3ee44afccba51a9945" translate="yes" xml:space="preserve">
          <source>Outputs an SQL script to create an RBU database which, if used to update database t1.db, patches it so that its contents are identical to that of database t2.db.</source>
          <target state="translated">RBUデータベースを作成するSQLスクリプトを出力し、データベースt1.dbの更新に使用された場合、その内容がデータベースt2.dbと同じになるようにパッチを当てます。</target>
        </trans-unit>
        <trans-unit id="25a352aa2e3e3671bf4d083fdd886df3d305e826" translate="yes" xml:space="preserve">
          <source>Over 100 separate source files are concatenated into a single large files of C-code named &quot;sqlite3.c&quot; and called &quot;the amalgamation&quot;. The amalgamation contains everything an application needs to embed SQLite. The amalgamation file is more than 220,000 lines long and over 7.5 megabytes in size (as of 2018-11-24).</source>
          <target state="translated">100以上の別々のソースファイルは、&quot;sqlite3.c &quot;という名前のCコードの1つの大きなファイルに連結され、&quot;アマルガム &quot;と呼ばれています。アマルガムには、アプリケーションがSQLiteを埋め込むために必要なすべてのものが含まれています。アマルガムファイルの長さは22万行以上、サイズは7.5メガバイトを超えています(2018-11-24現在)。</target>
        </trans-unit>
        <trans-unit id="6f2a6be035cf5a02d68b5e9127156e17d6b333b6" translate="yes" xml:space="preserve">
          <source>Overflow page</source>
          <target state="translated">オーバーフローページ</target>
        </trans-unit>
        <trans-unit id="26c78f2170e31758038f3bb0a52b3d4d222f938f" translate="yes" xml:space="preserve">
          <source>Overload A Function For A Virtual Table</source>
          <target state="translated">仮想テーブルの関数をオーバーロード</target>
        </trans-unit>
        <trans-unit id="007c99e63ddccff493d60c3cf9732ab7365f22fb" translate="yes" xml:space="preserve">
          <source>Override other operating system interfaces such as calls to obtain Zulu or local time.</source>
          <target state="translated">Zulu やローカルタイムを取得するための呼び出しなど、他のオペレーティングシステムのインターフェイスをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="46880b89366d47b3659d0ee6bf4c167da19b6968" translate="yes" xml:space="preserve">
          <source>Overview Documents</source>
          <target state="translated">概要資料</target>
        </trans-unit>
        <trans-unit id="04e78b5fd19361d42f0880283437d8302448583e" translate="yes" xml:space="preserve">
          <source>Overwrite if already exists?</source>
          <target state="translated">既に存在する場合は上書きしますか?</target>
        </trans-unit>
        <trans-unit id="9ada09a735411e9de190da46810d6bab2f578abd" translate="yes" xml:space="preserve">
          <source>Overwriting a database file with another without also deleting any hot journal associated with the original database.</source>
          <target state="translated">元のデータベースに関連付けられたホットジャーナルを削除せずに、データベースファイルを別のものに上書きします。</target>
        </trans-unit>
        <trans-unit id="bcfd518ec9aac14be70cb40d43cadb15da01978e" translate="yes" xml:space="preserve">
          <source>Overwritting a journal file with a different journal file.</source>
          <target state="translated">ジャーナルファイルを別のジャーナルファイルに上書きします。</target>
        </trans-unit>
        <trans-unit id="f6202fa6f9727ecd28cda41b586c4f17db3f9662" translate="yes" xml:space="preserve">
          <source>P (cost: 7.71)</source>
          <target state="translated">P(コスト:7.71</target>
        </trans-unit>
        <trans-unit id="80d8eec7d81f7a0324484c1ac454ead7da895c4f" translate="yes" xml:space="preserve">
          <source>P1 can be either an ordinary table or a virtual table. There used to be a separate OP_VRowid opcode for use with virtual tables, but this one opcode now works for both table types.</source>
          <target state="translated">P1 は通常のテーブルでも仮想テーブルでもどちらでも構いません。以前は仮想テーブルで使用するためのOP_VRowidオプコードが別個にありましたが、このオプコードは両方のテーブルタイプで動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="84bf22352f6da5dd236d64694b38dd6696254f42" translate="yes" xml:space="preserve">
          <source>P1 contains the address of the memory cell that contains the first memory cell in an array of values used as arguments to the sub-program. P2 contains the address to jump to if the sub-program throws an IGNORE exception using the RAISE() function. Register P3 contains the address of a memory cell in this (the parent) VM that is used to allocate the memory required by the sub-vdbe at runtime.</source>
          <target state="translated">P1には、サブプログラムの引数として使用される値の配列の最初のメモリセルを含むメモリセルのアドレスが含まれています。P2 には、サブプログラムが RAISE()関数を使用して IGNORE 例外をスローした場合にジャンプするアドレスが格納されています。レジスタP3には、実行時にサブvdbeが必要とするメモリを割り当てるために使用される、この(親の)VM内のメモリセルのアドレスが格納されています。</target>
        </trans-unit>
        <trans-unit id="bbb7c16489d0b290a1227473f0d5f4da2b7691cc" translate="yes" xml:space="preserve">
          <source>P1 is a 32-bit bitmask indicating whether or not each argument to the function was determined to be constant at compile time. If the first argument was constant then bit 0 of P1 is set. This is used to determine whether meta data associated with a user function argument using the sqlite3_set_auxdata() API may be safely retained until the next invocation of this opcode.</source>
          <target state="translated">P1は、コンパイル時に関数の各引数が定数であると判断されたかどうかを示す32ビットのビットマスクです。最初の引数が定数であった場合、P1のビット0が設定されます。これは、sqlite3_set_auxdata()APIを使用したユーザ関数の引数に関連付けられたメタデータが、このオペコードの次の呼び出しまで安全に保持されるかどうかを判断するために使用されます。</target>
        </trans-unit>
        <trans-unit id="ce2db3e033bf07aaa2aac0e6df082aac39175194" translate="yes" xml:space="preserve">
          <source>P1 is a boolean flag. If it is set to true and the xUpdate call is successful, then the value returned by sqlite3_last_insert_rowid() is set to the value of the rowid for the row just inserted.</source>
          <target state="translated">P1はブール値のフラグです。これがtrueに設定され、xUpdate呼び出しが成功した場合、sqlite3_last_insert_rowid()によって返される値は、挿入されたばかりの行のrowidの値に設定されます。</target>
        </trans-unit>
        <trans-unit id="ab3846ffb469791c7c875a7d6e64699955c09eb4" translate="yes" xml:space="preserve">
          <source>P1 is a cursor opened using &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;. P2 is an address to jump to if the filtered result set is empty.</source>
          <target state="translated">P1は&lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;を使用して開かれたカーソルです。P2は、フィルタリングされた結果セットが空の場合にジャンプするアドレスです。</target>
        </trans-unit>
        <trans-unit id="99e16bb5285cdf74213efcd911112d0254cc888f" translate="yes" xml:space="preserve">
          <source>P1 is a register in the root frame of this VM (the root frame is different from the current frame if this instruction is being executed within a sub-program). Set the value of register P1 to the maximum of its current value and the value in register P2.</source>
          <target state="translated">P1は、このVMのルートフレーム内のレジスタです(この命令がサブプログラム内で実行されている場合、ルートフレームはカレントフレームとは異なります)。レジスタP1の値を、現在の値とレジスタP2の値の最大値に設定します。</target>
        </trans-unit>
        <trans-unit id="17a3ab4e084c4ae225f4e64b76426d06344fe074" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. If the sequence counter is currently zero, jump to P2. Regardless of whether or not the jump is taken, increment the the sequence value.</source>
          <target state="translated">P1はソーターカーソルです。シーケンスカウンタが現在0の場合、P2にジャンプします。ジャンプの有無に関わらず、シーケンス値をインクリメントします。</target>
        </trans-unit>
        <trans-unit id="f9ac2a8e79b4d0f70e9cfe08c3c644453f11b20b" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. This instruction compares a prefix of the record blob in register P3 against a prefix of the entry that the sorter cursor currently points to. Only the first P4 fields of r[P3] and the sorter record are compared.</source>
          <target state="translated">P1 はソーターカーソルです。この命令は、レジスタP3のレコードブロブの接頭辞と、ソーターカーソルが現在指しているエントリの接頭辞を比較します。r[P3]とソーターレコードの最初のP4フィールドのみが比較されます。</target>
        </trans-unit>
        <trans-unit id="d14bcdd4246c685563dd290988090774223c445f" translate="yes" xml:space="preserve">
          <source>P1 is an open index cursor and P3 is a cursor on the corresponding table. This opcode does a deferred seek of the P3 table cursor to the row that corresponds to the current row of P1.</source>
          <target state="translated">P1はオープンインデックスカーソルであり、P3は対応するテーブル上のカーソルである。このオペコードは、P1の現在の行に対応する行へのP3テーブルカーソルの遅延シークを行う。</target>
        </trans-unit>
        <trans-unit id="86c484d0a40d444e4dc0b4d443a06296772d4391" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). If register P3 does not contain an integer or if P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1はSQLテーブルbtree(整数キーを持つ)上で開いているカーソルのインデックスです。レジスタP3が整数を含まない場合、またはP1がrowid P3を持つレコードを含まない場合、直ちにP2にジャンプします。または、P2が0の場合は、SQLITE_CORRUPTエラーを発生させます。P1に行番号P3のレコードが含まれている場合、カーソルはそのレコードを指したままにして次の命令に進みます。</target>
        </trans-unit>
        <trans-unit id="be17250db9325023bb6814cabfbf543abfa5ba67" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). P3 is an integer rowid. If P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1はSQLテーブルbtree(整数のキーを持つ)で開いているカーソルのインデックスです。P3は整数の行番号です。P1に行番号P3のレコードが含まれていない場合、直ちにP2にジャンプします。または、P2が0の場合、SQLITE_CORRUPTエラーを発生させます。P1に行番号P3を持つレコードが含まれている場合、カーソルはそのレコードを指したままにして次の命令に進みます。</target>
        </trans-unit>
        <trans-unit id="35a6c564ff4d581152e9a1f876d9eb72d2af48f4" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database file on which the transaction is started. Index 0 is the main database file and index 1 is the file used for temporary tables. Indices of 2 or more are used for attached databases.</source>
          <target state="translated">P1は、トランザクションが開始されるデータベースファイルのインデックスである。インデックス0はメインデータベースファイル、インデックス1はテンポラリテーブルに使用されるファイルである。2以上のインデックスは、アタッチされたデータベースに使用されます。</target>
        </trans-unit>
        <trans-unit id="b9198f15e439eca54714083fc1fc6d108cc42915" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database in sqlite3.aDb[] of the database on which the lock is acquired. A readlock is obtained if P3==0 or a write lock if P3==1.</source>
          <target state="translated">P1はロックを取得したデータベースのsqlite3.aDb[]内のデータベースのインデックスです。P3==0ならリードロック、P3==1ならライトロックを取得します。</target>
        </trans-unit>
        <trans-unit id="1fcd6d3417638283143894ac28a56d5766856870" translate="yes" xml:space="preserve">
          <source>P1 is the memory location that is the accumulator for an aggregate or window function. Execute the finalizer function for an aggregate and store the result in P1.</source>
          <target state="translated">P1 は集約関数やウィンドウ関数のアキュムレータとなるメモリ位置です。集計のファイナライザ関数を実行し、その結果をP1に格納します。</target>
        </trans-unit>
        <trans-unit id="9564a9171b616f080f45aeeeeb50a759cf2543a9" translate="yes" xml:space="preserve">
          <source>P1 is the result code returned by sqlite3_exec(), sqlite3_reset(), or sqlite3_finalize(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. If P1!=0 then P2 will determine whether or not to rollback the current transaction. Do not rollback if P2==OE_Fail. Do the rollback if P2==OE_Rollback. If P2==OE_Abort, then back out all changes that have occurred during this execution of the VDBE, but do not rollback the transaction.</source>
          <target state="translated">P1はsqlite3_exec()、sqlite3_reset()、またはsqlite3_finalize()によって返される結果コードです。通常の停止では、これはSQLITE_OK (0)でなければなりません。エラーの場合は、他の値を指定することができます。P1!=0の場合、P2は現在のトランザクションをロールバックするかどうかを決定します。P2==OE_Failの場合はロールバックしません。P2==OE_Rollbackの場合はロールバックを行います。P2==OE_Abortならば、このVDBEの実行中に発生した全ての変更をバックアウトするが、トランザクションはロールバックしない。</target>
        </trans-unit>
        <trans-unit id="05f5c83f3b169019c8e82a0eaf11fb45a16518b4" translate="yes" xml:space="preserve">
          <source>P1 must be a valid b-tree cursor. P2 must be a boolean value, either 0 or 1.</source>
          <target state="translated">P1は有効なb-treeカーソルでなければなりません。P2はブール値、0または1でなければなりません。</target>
        </trans-unit>
        <trans-unit id="05f600aab9b18602c22139c66a31c7458bbfad3f" translate="yes" xml:space="preserve">
          <source>P1 must not be pseudo-table. It has to be a real table with multiple rows.</source>
          <target state="translated">P1は疑似テーブルであってはなりません。複数の行を持つ本物のテーブルでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f93c0802a39924cff1b00e9015e9aa33f54938f7" translate="yes" xml:space="preserve">
          <source>P2 contains the root-page of the table to lock.</source>
          <target state="translated">P2にはロックするテーブルのルートページが含まれています。</target>
        </trans-unit>
        <trans-unit id="9ce77455e05f3264d5bb123f4f714e82dd11c666" translate="yes" xml:space="preserve">
          <source>P2 is a register that holds the name of a virtual table in database P1. Call the xCreate method for that table.</source>
          <target state="translated">P2はデータベースP1内の仮想テーブルの名前を保持するレジスタです。そのテーブルのxCreateメソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="be0d49dbe18b5a0cf012a9f8a24be16667dd4219" translate="yes" xml:space="preserve">
          <source>P2 is the column number for the argument to the sqlite_offset() function. This opcode does not use P2 itself, but the P2 value is used by the code generator. The P1, P2, and P3 operands to this opcode are the same as for &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;.</source>
          <target state="translated">P2は、sqlite_offset（）関数への引数の列番号です。このオペコードはP2自体を使用しませんが、P2値はコードジェネレーターによって使用されます。このオペコードのP1、P2、およびP3オペランドは、&lt;a href=&quot;opcode#Column&quot;&gt;Columnの場合&lt;/a&gt;と同じです。</target>
        </trans-unit>
        <trans-unit id="b9b9294fefdd80f907d449f8b026a50941891877" translate="yes" xml:space="preserve">
          <source>P2 is the number of arguments that the step function takes and P4 is a pointer to the FuncDef for this function. The P2 argument is not used by this opcode. It is only there to disambiguate functions that can take varying numbers of arguments. The P4 argument is only needed for the case where the step function was not previously called.</source>
          <target state="translated">P2はステップ関数が取る引数の数、P4はこの関数のFuncDefへのポインタです。P2 引数はこのオペコードでは使用されません。これは、様々な数の引数を取ることができる関数を区別するためだけに存在します。P4 引数は、ステップ関数が以前に呼び出されなかった場合にのみ必要です。</target>
        </trans-unit>
        <trans-unit id="3bd7cc65ffe04a6cbb96320f3dfb05bef13a6003" translate="yes" xml:space="preserve">
          <source>P2 is the number of columns in the ephemeral table. The cursor points to a BTree table if P4==0 and to a BTree index if P4 is not 0. If P4 is not NULL, it points to a KeyInfo structure that defines the format of keys in the index.</source>
          <target state="translated">P2はエフェメラルテーブルのカラム数です。カーソルは、P4==0の場合はBTreeテーブルを指し、P4が0でない場合はBTreeインデックスを指します。P4がNULLでない場合は、インデックスのキーの形式を定義するKeyInfo構造体を指します。</target>
        </trans-unit>
        <trans-unit id="d43bd5b8560de02b50e24570db7ff928128725ba" translate="yes" xml:space="preserve">
          <source>P2=='A' &amp;rarr; BLOB</source>
          <target state="translated">P2 == 'A'&amp;rarr;BLOB</target>
        </trans-unit>
        <trans-unit id="549df038ddec37fc17c85e7dccfd3d0f7eac490b" translate="yes" xml:space="preserve">
          <source>P2=='B' &amp;rarr; TEXT</source>
          <target state="translated">P2 == 'B'&amp;rarr;TEXT</target>
        </trans-unit>
        <trans-unit id="3eb880697f1f955293bf5968bad5752ba9e6c36d" translate="yes" xml:space="preserve">
          <source>P2=='C' &amp;rarr; NUMERIC</source>
          <target state="translated">P2 == 'C'&amp;rarr;数値</target>
        </trans-unit>
        <trans-unit id="11082965a2f3470ce5a9187e0cfe05f51096d4b9" translate="yes" xml:space="preserve">
          <source>P2=='D' &amp;rarr; INTEGER</source>
          <target state="translated">P2 == 'D'&amp;rarr;INTEGER</target>
        </trans-unit>
        <trans-unit id="8d3f310a6285b7cb02844a9cd70fd245db85edd2" translate="yes" xml:space="preserve">
          <source>P2=='E' &amp;rarr; REAL</source>
          <target state="translated">P2 == 'E'&amp;rarr;REAL</target>
        </trans-unit>
        <trans-unit id="12d088ae7e89df349fe37f3d37cf8b1ca4c09b3a" translate="yes" xml:space="preserve">
          <source>P3 = P2 || P1</source>
          <target state="translated">P3=P2 || P1</target>
        </trans-unit>
        <trans-unit id="3a22c873357ee7f56f10d2e038f148e48353f460" translate="yes" xml:space="preserve">
          <source>P3 is the number of fields in the records that will be stored by the pseudo-table.</source>
          <target state="translated">P3は、疑似テーブルが格納するレコードのフィールド数である。</target>
        </trans-unit>
        <trans-unit id="fa5df0db7433454e4380316b1e3b9bfe2adbea6f" translate="yes" xml:space="preserve">
          <source>P4 contains a pointer to the name of the table being locked. This is only used to generate an error message if the lock cannot be obtained.</source>
          <target state="translated">P4には、ロックされているテーブル名へのポインタが含まれています。これは、ロックを取得できなかった場合のエラーメッセージを生成するためにのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="3f5b2dbcd76db7494d70506eccc181bd880869ce" translate="yes" xml:space="preserve">
          <source>P4 is a KeyInfo structure that defines collating sequences and sort orders for the comparison. The permutation applies to registers only. The KeyInfo elements are used sequentially.</source>
          <target state="translated">P4 は、比較のための照合シーケンスとソート順序を定義する KeyInfo 構造体です。並べ替えはレジスタのみに適用されます。KeyInfo要素は順次使用されます。</target>
        </trans-unit>
        <trans-unit id="6e63a14f434c9d816b03aebb21b25ccfa99f1b42" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit floating point value. Write that value into register P2.</source>
          <target state="translated">P4は64ビット浮動小数点値へのポインタです。その値をレジスタP2に書き込む。</target>
        </trans-unit>
        <trans-unit id="006b4d737b2fe81d322403675fc01054f9eaddfd" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit integer value. Write that value into register P2.</source>
          <target state="translated">P4は64ビット整数値へのポインタです。その値をレジスタP2に書き込む。</target>
        </trans-unit>
        <trans-unit id="93432616419a7361a72b061b65e02339a1738910" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a CollSeq object. If the next call to a user function or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will be returned. This is used by the built-in min(), max() and nullif() functions.</source>
          <target state="translated">P4はCollSeqオブジェクトへのポインタです。ユーザ関数や集約の次の呼び出しがsqlite3GetFuncCollSeq()を呼び出すと、この照合シーケンスが返されます。これは組み込みのmin(),max(),nullif()関数で使用されます。</target>
        </trans-unit>
        <trans-unit id="d80240e61957d32e7437d69346afb9ca3c15eca9" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. P1 is a cursor number. This opcode opens a cursor to the virtual table and stores that cursor in P1.</source>
          <target state="translated">P4は仮想テーブルオブジェクト、sqlite3_vtab構造体へのポインタです。P1はカーソル番号です。このオペコードは仮想テーブルへのカーソルをオープンし、そのカーソルをP1に格納します。</target>
        </trans-unit>
        <trans-unit id="0dbffabc54d98d6801900e6ab537de5e2bcdd805" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xRename method. The value in register P1 is passed as the zName argument to the xRename method.</source>
          <target state="translated">P4は仮想テーブルオブジェクト(sqlite3_vtab構造体)へのポインタです。このオペコードは対応するxRenameメソッドを呼び出します。レジスタP1の値はxRenameメソッドの引数zNameとして渡されます。</target>
        </trans-unit>
        <trans-unit id="8c184e85a48a476ce012fdb53452bec6f0cb31bc" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xUpdate method. P2 values are contiguous memory cells starting at P3 to pass to the xUpdate invocation. The value in register (P3+P2-1) corresponds to the p2th element of the argv array passed to xUpdate.</source>
          <target state="translated">P4は仮想テーブルオブジェクト(sqlite3_vtab構造体)へのポインタです。このオペコードは対応するxUpdateメソッドを呼び出します。P2の値は、xUpdate呼び出しに渡すP3から始まる連続したメモリセルです。レジスタ(P3+P2-1)の値は、xUpdateに渡されるargv配列のp2番目の要素に対応します。</target>
        </trans-unit>
        <trans-unit id="ad1bbf355e84d3c7a49f4b2d106cdd6317b07ee3" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to the VM containing the trigger program.</source>
          <target state="translated">P4は、トリガプログラムを含むVMへのポインタです。</target>
        </trans-unit>
        <trans-unit id="f47594ef27452803fbd06eb33f15569fa2ff24ae" translate="yes" xml:space="preserve">
          <source>P4 is a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th memory cell in the range.</source>
          <target state="translated">P4は、P2文字の長さの文字列である。文字列のn番目の文字は、範囲内のn番目のメモリセルに使用すべきカラム親和性を示す。</target>
        </trans-unit>
        <trans-unit id="990f075b203cf5ad046ffef4a8c3f52f5d8e8021" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreeNext().</source>
          <target state="translated">P4は常にP4_ADVANCE型です。関数ポインタはsqlite3BtreeNext()を指します。</target>
        </trans-unit>
        <trans-unit id="33ef9db58085779c3fa7810a9ac7b841027b65e6" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreePrevious().</source>
          <target state="translated">P4は常にP4_ADVANCE型です。関数ポインタはsqlite3BtreePrevious()を指します。</target>
        </trans-unit>
        <trans-unit id="d1b9c8ecf53ced9f246c4b6e555cd6111c1ca23e" translate="yes" xml:space="preserve">
          <source>P4 is either NULL or a string that was generated by the xBestIndex method of the module. The interpretation of the P4 string is left to the module implementation.</source>
          <target state="translated">P4はNULLか、モジュールのxBestIndexメソッドによって生成された文字列です。P4文字列の解釈はモジュールの実装に委ねられています。</target>
        </trans-unit>
        <trans-unit id="c28c1dcafe0312975199fcb1fcfbb17e24dd7d0c" translate="yes" xml:space="preserve">
          <source>P4 is the name of a virtual table in database P1. Call the xDestroy method of that table.</source>
          <target state="translated">P4はデータベースP1の仮想テーブルの名前です。そのテーブルのxDestroyメソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="b1c200e3bc2517ade0a0775a576b9a6ce0d06b98" translate="yes" xml:space="preserve">
          <source>P4 may be a pointer to an sqlite3_vtab structure. If so, call the xBegin method for that table.</source>
          <target state="translated">P4はsqlite3_vtab構造体へのポインタかもしれません。その場合は、そのテーブルのxBeginメソッドを呼び出してください。</target>
        </trans-unit>
        <trans-unit id="946a7239230e3ec0a9c66885447aaf26ad8bc930" translate="yes" xml:space="preserve">
          <source>P4 may be a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th field of the index key.</source>
          <target state="translated">P4は、P2文字の長さの文字列であってもよい。文字列のN番目の文字は、インデックスキーのN番目のフィールドに使用すべきカラムの親和性を示す。</target>
        </trans-unit>
        <trans-unit id="69adfac261137322671a1ca5cef4f8a650bcfbae" translate="yes" xml:space="preserve">
          <source>P4 may be an array of integers (type P4_INTARRAY) containing one entry for each column in the P3 table. If array entry a(i) is non-zero, then reading column a(i)-1 from cursor P3 is equivalent to performing the deferred seek and then reading column i from P1. This information is stored in P3 and used to redirect reads against P3 over to P1, thus possibly avoiding the need to seek and read cursor P3.</source>
          <target state="translated">P4は、P3テーブルの各列に1つのエントリを含む整数の配列(P4_INTARRAY型)である。配列エントリa(i)が0でない場合、カーソルP3から列a(i)-1を読み出すことは、遅延シークを実行してからP1から列iを読み出すことと等価である。この情報はP3に格納され、P3からの読み取りをP1にリダイレクトするために使用され、カーソルP3をシークして読み出す必要性を回避することができます。</target>
        </trans-unit>
        <trans-unit id="2b3aae431e84b9e296011557b13fc95c59d8a3fe" translate="yes" xml:space="preserve">
          <source>P4 points to a blob of data P1 bytes long. Store this blob in register P2.</source>
          <target state="translated">P4 は、P1 バイト長のデータのブロブを指します。このブロブをレジスタP2に格納します。</target>
        </trans-unit>
        <trans-unit id="5f1f77c01d77787acda0ee06f04f3dd3dab581c9" translate="yes" xml:space="preserve">
          <source>P4 points to a nul terminated UTF-8 string. This opcode is transformed into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode before it is executed for the first time. During this transformation, the length of string P4 is computed and stored as the P1 parameter.</source>
          <target state="translated">P4は、nulで終了するUTF-8文字列を指します。このオペコードは、初めて実行される前に&lt;a href=&quot;opcode#String&quot;&gt;文字列&lt;/a&gt;オペコードに変換されます。この変換中に、文字列P4の長さが計算され、P1パラメータとして保存されます。</target>
        </trans-unit>
        <trans-unit id="8c8ae2d7e0dfc4268ff56cfc9e2e47a67fc1ddaf" translate="yes" xml:space="preserve">
          <source>P5 is a value between 0 and 4, inclusive, that modifies the P4 string.</source>
          <target state="translated">P5は、P4の文字列を変更する0から4の間の値です。</target>
        </trans-unit>
        <trans-unit id="e03c8fcb835da321a7966f8a1cfc9fb80046f7b0" translate="yes" xml:space="preserve">
          <source>P5 is the error actions (OE_Replace, OE_Fail, OE_Ignore, etc) to apply in the case of a constraint failure on an insert or update.</source>
          <target state="translated">P5は、挿入や更新で制約に失敗した場合に適用するエラーアクション(OE_Replace、OE_Fail、OE_Ignoreなど)です。</target>
        </trans-unit>
        <trans-unit id="d23183b7ef6b3cfee6722e9cab664f9eba24c080" translate="yes" xml:space="preserve">
          <source>PARTITION</source>
          <target state="translated">PARTITION</target>
        </trans-unit>
        <trans-unit id="7c423f3264effc4f744de4e6255ff034137bcc1e" translate="yes" xml:space="preserve">
          <source>PASSIVE</source>
          <target state="translated">PASSIVE</target>
        </trans-unit>
        <trans-unit id="418f304013689ba52fc7c27eebb7dcb9d2ced563" translate="yes" xml:space="preserve">
          <source>PDF - Portable Document Format from Adobe</source>
          <target state="translated">PDF-Adobeのポータブルドキュメント形式</target>
        </trans-unit>
        <trans-unit id="0a7b38b716933a39c0bca66f229cd6d52f0c1271" translate="yes" xml:space="preserve">
          <source>PENDING</source>
          <target state="translated">PENDING</target>
        </trans-unit>
        <trans-unit id="5a61e634ec49d3919b83a13434809a009040ffa1" translate="yes" xml:space="preserve">
          <source>PLAN</source>
          <target state="translated">PLAN</target>
        </trans-unit>
        <trans-unit id="4b01f0d6c5bf45bcaa85e117787de16b76894b18" translate="yes" xml:space="preserve">
          <source>POSIX locking style. This is the default locking style and the style used by other (non Mac OS X) Unixes. Locks are obtained and released using the fcntl() system call.</source>
          <target state="translated">POSIXのロックスタイル。これはデフォルトのロックスタイルであり、他の (Mac OS X 以外の)Unix で使用されているスタイルです。ロックは fcntl()システムコールを使って取得・解放されます。</target>
        </trans-unit>
        <trans-unit id="304e41f1b7440f605b6d901a3f56679fe5127675" translate="yes" xml:space="preserve">
          <source>PPT - Microsoft PowerPoint presentations</source>
          <target state="translated">PPT-Microsoft PowerPointプレゼンテーション</target>
        </trans-unit>
        <trans-unit id="eb3b3e1144fc0ba039acb3375dbf811550aeb6d8" translate="yes" xml:space="preserve">
          <source>PRAGMA</source>
          <target state="translated">PRAGMA</target>
        </trans-unit>
        <trans-unit id="2031386335ef51b174ad3b83ba1c813522943aeb" translate="yes" xml:space="preserve">
          <source>PRAGMA Statements</source>
          <target state="translated">PRAGMA ステートメント</target>
        </trans-unit>
        <trans-unit id="dd8e7015522cfd4dcf823317fdfa144e1ffa8793" translate="yes" xml:space="preserve">
          <source>PRAGMA application_id</source>
          <target state="translated">PRAGMAアプリケーションID</target>
        </trans-unit>
        <trans-unit id="4272fe5aa2578d44c85ef586cbdb481255d6ef40" translate="yes" xml:space="preserve">
          <source>PRAGMA auto_vacuum</source>
          <target state="translated">PRAGMA自動バキューム</target>
        </trans-unit>
        <trans-unit id="ecdb75c7d78bb2d218243fd805db4a0952130227" translate="yes" xml:space="preserve">
          <source>PRAGMA automatic_index</source>
          <target state="translated">プラーグマ自動インデックス</target>
        </trans-unit>
        <trans-unit id="06f21794e50e9014cbc68dddc08b0afe728a2339" translate="yes" xml:space="preserve">
          <source>PRAGMA busy_timeout</source>
          <target state="translated">PRAGMAビジータイムアウト</target>
        </trans-unit>
        <trans-unit id="0079a2a1c563d3a80935f663efd9c2f3f214bd31" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_size</source>
          <target state="translated">PRAGMA cache_size</target>
        </trans-unit>
        <trans-unit id="53830be86cc01d9861a99c96b4baf9389520d439" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_spill</source>
          <target state="translated">PRAGMA cache_spill</target>
        </trans-unit>
        <trans-unit id="c62c55dc2230d9ef14955c77928155e6ec4c7ae3" translate="yes" xml:space="preserve">
          <source>PRAGMA case_sensitive_like</source>
          <target state="translated">PRAGMA case_sensitive_like</target>
        </trans-unit>
        <trans-unit id="629aac38c33c9e2128ff55cc2623e94247525dd5" translate="yes" xml:space="preserve">
          <source>PRAGMA cell_size_check</source>
          <target state="translated">PRAGMA cell_size_check</target>
        </trans-unit>
        <trans-unit id="f7a6fea31875d2709fc8636382fa71e3e405a8bd" translate="yes" xml:space="preserve">
          <source>PRAGMA checkpoint_fullfsync</source>
          <target state="translated">PRAGMAチェックポイント_fullfsync</target>
        </trans-unit>
        <trans-unit id="c3bb771e91f755dbbaf486313dfb86863abb68c6" translate="yes" xml:space="preserve">
          <source>PRAGMA collation_list</source>
          <target state="translated">PRAGMA照合リスト</target>
        </trans-unit>
        <trans-unit id="03029df867e6189d3cb8be071de311b5adc094ca" translate="yes" xml:space="preserve">
          <source>PRAGMA command syntax</source>
          <target state="translated">PRAGMA コマンド構文</target>
        </trans-unit>
        <trans-unit id="41b472d1fbef46bb9f050319914604b6fc2ba68d" translate="yes" xml:space="preserve">
          <source>PRAGMA compile_options</source>
          <target state="translated">PRAGMA compile_options</target>
        </trans-unit>
        <trans-unit id="c654b246f7037e0f8929e3e045a813d87f20921d" translate="yes" xml:space="preserve">
          <source>PRAGMA count_changes</source>
          <target state="translated">PRAGMA count_changes</target>
        </trans-unit>
        <trans-unit id="e558ad585b01cc3a4aa52bb53490182d9eacc4e8" translate="yes" xml:space="preserve">
          <source>PRAGMA data_store_directory</source>
          <target state="translated">PRAGMAデータストアディレクトリ</target>
        </trans-unit>
        <trans-unit id="9a7e5a694b84807a56ec0b72b64b9c9c84d92f92" translate="yes" xml:space="preserve">
          <source>PRAGMA data_version</source>
          <target state="translated">プラーグマデータバージョン</target>
        </trans-unit>
        <trans-unit id="71f193736d432d273c489df59218224a1bd26bb0" translate="yes" xml:space="preserve">
          <source>PRAGMA database_list</source>
          <target state="translated">PRAGMA データベースリスト</target>
        </trans-unit>
        <trans-unit id="d2b0abac3ff561286d0f244f1229dbe0d7c413ba" translate="yes" xml:space="preserve">
          <source>PRAGMA default_cache_size</source>
          <target state="translated">PRAGMA default_cache_size</target>
        </trans-unit>
        <trans-unit id="baa9b0985d524aa3c28f49ac66dec16e57647a96" translate="yes" xml:space="preserve">
          <source>PRAGMA defer_foreign_keys</source>
          <target state="translated">PRAGMA defer_foreign_keys</target>
        </trans-unit>
        <trans-unit id="5a13b54115c31e192bafba5863e3b69f614ae8e0" translate="yes" xml:space="preserve">
          <source>PRAGMA empty_result_callbacks</source>
          <target state="translated">PRAGMA empty_result_callbacks</target>
        </trans-unit>
        <trans-unit id="464f0c2fc86d3a8263fffd42239b50d53989d1da" translate="yes" xml:space="preserve">
          <source>PRAGMA encoding</source>
          <target state="translated">プラーグマ符号化方式</target>
        </trans-unit>
        <trans-unit id="5a35e091ec7521a831d067bdc90ecb017a359b26" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_check</source>
          <target state="translated">PRAGMA foreign_key_check</target>
        </trans-unit>
        <trans-unit id="4f9cabaf50d87f897238e4cfca01cbf9a956476a" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_list</source>
          <target state="translated">PRAGMA外国語キーリスト</target>
        </trans-unit>
        <trans-unit id="c26430dedacc940c37179bc2ab043a40726e60aa" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_keys</source>
          <target state="translated">PRAGMA foreign_keys</target>
        </trans-unit>
        <trans-unit id="f6f4d8a618687004328fc80c2fe129e8548fb446" translate="yes" xml:space="preserve">
          <source>PRAGMA freelist_count</source>
          <target state="translated">PRAGMA freelist_count</target>
        </trans-unit>
        <trans-unit id="a1a0446b52b0c9481ab686d03b259ad5f54f8cce" translate="yes" xml:space="preserve">
          <source>PRAGMA full_column_names</source>
          <target state="translated">PRAGMA full_column_names</target>
        </trans-unit>
        <trans-unit id="19952a9490a74b7cefcba8ae3ffcd4c6cd36c908" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync</source>
          <target state="translated">PRAGMA fullfsync</target>
        </trans-unit>
        <trans-unit id="9b4ca9a487733d7c417ae8784f57aa1ed11b34f0" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync=ON;</source>
          <target state="translated">PRAGMA fullfsync=ON。</target>
        </trans-unit>
        <trans-unit id="327858b59b9cfef735d94d93f6b85bcef5690111" translate="yes" xml:space="preserve">
          <source>PRAGMA function</source>
          <target state="translated">プラーグマ機能</target>
        </trans-unit>
        <trans-unit id="2a0bacb7b9cc513abddcbbe743f428bab68dfa8c" translate="yes" xml:space="preserve">
          <source>PRAGMA function_list</source>
          <target state="translated">プラーグマ関数リスト</target>
        </trans-unit>
        <trans-unit id="e837cb07b592292e4ed84f750d66cb314f82a9c5" translate="yes" xml:space="preserve">
          <source>PRAGMA functions</source>
          <target state="translated">PRAGMA機能</target>
        </trans-unit>
        <trans-unit id="f7e42e33fd73efd0a92d36f4ff6b3819913f9bc4" translate="yes" xml:space="preserve">
          <source>PRAGMA ignore_check_constraints</source>
          <target state="translated">PRAGMA ignore_check_constraints</target>
        </trans-unit>
        <trans-unit id="cd58bb64e6b2a173c5b581b0cb503c85da1dbd24" translate="yes" xml:space="preserve">
          <source>PRAGMA incremental_vacuum</source>
          <target state="translated">PRAGMA incremental_vacuum</target>
        </trans-unit>
        <trans-unit id="652aaaf1f9e0a84122b69d9954ec064ee9d02a48" translate="yes" xml:space="preserve">
          <source>PRAGMA index_info</source>
          <target state="translated">PRAGMA index_info</target>
        </trans-unit>
        <trans-unit id="125af8cf007c5ae9f4a12bfd4e392de5088aeebd" translate="yes" xml:space="preserve">
          <source>PRAGMA index_list</source>
          <target state="translated">プラーグマインデックスリスト</target>
        </trans-unit>
        <trans-unit id="2da953925bb8a4bec48afa57978cfa755a68b864" translate="yes" xml:space="preserve">
          <source>PRAGMA index_xinfo</source>
          <target state="translated">PRAGMA index_xinfo</target>
        </trans-unit>
        <trans-unit id="a0a681b89ba9014d636bfe01c90f033d409952e9" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check</source>
          <target state="translated">プラーグマ完全性検査</target>
        </trans-unit>
        <trans-unit id="47cd2260e4aae51e91f7618b4491c7a57dbd31aa" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command for to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA integer_checkは、&lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt;エラーを検出しません。&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;コマンドを使用して、FOREIGN KEY制約のエラーを見つけます。</target>
        </trans-unit>
        <trans-unit id="0e40c9bb92f26ef5f07d9f3367463e8597505eee" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_mode</source>
          <target state="translated">PRAGMAログモード</target>
        </trans-unit>
        <trans-unit id="0dc7949f2c37427da3286461ab0d99c192b23454" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_size_limit</source>
          <target state="translated">PRAGMA journal_size_limit</target>
        </trans-unit>
        <trans-unit id="1d1d61ff55f21546bb199472fc5fb09c63e7801f" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_alter_table</source>
          <target state="translated">PRAGMA legacy_alter_table</target>
        </trans-unit>
        <trans-unit id="1d7e28dc08cc03a9bb08dd39291f00ea3a00d6ce" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_file_format</source>
          <target state="translated">PRAGMA legacy_file_format</target>
        </trans-unit>
        <trans-unit id="e05eb926ae67395e18a7ff48872e6bf6de93826e" translate="yes" xml:space="preserve">
          <source>PRAGMA locking_mode</source>
          <target state="translated">PRAGMAロックモード</target>
        </trans-unit>
        <trans-unit id="a71f8b9f21a1c76ece9dc64397bce57f203e4519" translate="yes" xml:space="preserve">
          <source>PRAGMA max_page_count</source>
          <target state="translated">PRAGMA max_page_count</target>
        </trans-unit>
        <trans-unit id="3aba9ed125640a69838f81731ba34ebdf094d76a" translate="yes" xml:space="preserve">
          <source>PRAGMA mmap_size</source>
          <target state="translated">PRAGMA mmap_size</target>
        </trans-unit>
        <trans-unit id="c29ccc2a4945dfe06f8af7b8b574f07e8a513dc7" translate="yes" xml:space="preserve">
          <source>PRAGMA module_list</source>
          <target state="translated">PRAGMAモジュールリスト</target>
        </trans-unit>
        <trans-unit id="ed5cd9ca526909b51a8497a39931b7a730a4b534" translate="yes" xml:space="preserve">
          <source>PRAGMA optimize</source>
          <target state="translated">PRAGMA最適化</target>
        </trans-unit>
        <trans-unit id="9618d59586d55b1fe7cf6403a08d5878deeff0b2" translate="yes" xml:space="preserve">
          <source>PRAGMA page_count</source>
          <target state="translated">PRAGMAページカウント</target>
        </trans-unit>
        <trans-unit id="73b1778335144273f1b55bbda71292b3236c2f7c" translate="yes" xml:space="preserve">
          <source>PRAGMA page_size</source>
          <target state="translated">PRAGMAページサイズ</target>
        </trans-unit>
        <trans-unit id="0c33d6f9f55335baef42453f3966f2ae2790fe21" translate="yes" xml:space="preserve">
          <source>PRAGMA parser_trace</source>
          <target state="translated">PRAGMA parser_trace</target>
        </trans-unit>
        <trans-unit id="987c5140e9a3de6520e0e9a5de928a2bd5f2af7c" translate="yes" xml:space="preserve">
          <source>PRAGMA synchronous=FULL;</source>
          <target state="translated">PRAGMA synchronous=FULL。</target>
        </trans-unit>
        <trans-unit id="c40b0db1ea40d45cf9c01804a3ada577b8b752ae" translate="yes" xml:space="preserve">
          <source>PRAGMA temp_store_directory = ''</source>
          <target state="translated">PRAGMA temp_store_directory=''</target>
        </trans-unit>
        <trans-unit id="0662bf3087347b5b0ecf25fecad0c21f9bfb340d" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_addoptrace</source>
          <target state="translated">PRAGMA vdbe_addoptrace</target>
        </trans-unit>
        <trans-unit id="ed607acfa6bacfc2bc133e1d2e829c3c31c8a51c" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_debug</source>
          <target state="translated">PRAGMA vdbe_debug</target>
        </trans-unit>
        <trans-unit id="f5251eb4d3acd0707857877ee684d1bef0e741e2" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_listing</source>
          <target state="translated">PRAGMA vdbe_listing</target>
        </trans-unit>
        <trans-unit id="319d369f27e5d322702e5eca965b605f26e48c8b" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_trace</source>
          <target state="translated">PRAGMA vdbe_trace</target>
        </trans-unit>
        <trans-unit id="f0a71878598fa251896a1bb5f07402743f02c1c6" translate="yes" xml:space="preserve">
          <source>PRAGMAs that return results and that have no side-effects can be accessed from ordinary &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. For each participating PRAGMA, the corresponding table-valued function has the same name as the PRAGMA with a 7-character &quot;pragma_&quot; prefix. The PRAGMA argument and schema, if any, are passed as arguments to the table-valued function.</source>
          <target state="translated">結果を返し、副作用がないPRAGMAには、通常の&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントから&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;としてアクセスできます。参加している各PRAGMAについて、対応するテーブル値関数は、7文字の &quot;pragma_&quot;接頭辞が付いたPRAGMAと同じ名前を持っています。 PRAGMA引数とスキーマ（存在する場合）は、引数としてテーブル値関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="f5e246fc197bcab96dcc71246fd51e046d154a6b" translate="yes" xml:space="preserve">
          <source>PRECEDING</source>
          <target state="translated">PRECEDING</target>
        </trans-unit>
        <trans-unit id="ed15de08f42371953d12d6c433f3d7a83e50d659" translate="yes" xml:space="preserve">
          <source>PRIMARY</source>
          <target state="translated">PRIMARY</target>
        </trans-unit>
        <trans-unit id="5d81ed20f739b911f425c9e71391691185dad6d3" translate="yes" xml:space="preserve">
          <source>PRIMARY KEY constraint</source>
          <target state="translated">PRIMARY KEY 制約</target>
        </trans-unit>
        <trans-unit id="fcdd367db6d48a1ca9ffb0132d54992dd930544d" translate="yes" xml:space="preserve">
          <source>Page 1 and the Expected Page Size</source>
          <target state="translated">1ページ目と期待されるページサイズ</target>
        </trans-unit>
        <trans-unit id="e0da1c304b873d5c4bfe7eb2116e8b2b93162178" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;sqlite_master&quot; (or &quot;sqlite_temp_master&quot; in the case of a TEMP database) which stores the complete database schema. The structure of the sqlite_master table is as if it had been created using the following SQL:</source>
          <target state="translated">データベースファイルの1ページ目は、完全なデータベーススキーマを格納する &quot;sqlite_master&quot;(TEMPデータベースの場合は &quot;sqlite_temp_master&quot;)という名前の特別なテーブルを保持するテーブルb-treeのルートページです。sqlite_masterテーブルの構造は、以下のSQLを使用して作成されたかのようになっています。</target>
        </trans-unit>
        <trans-unit id="bb98169c72c2e0218852294c4088a714e55ae813" translate="yes" xml:space="preserve">
          <source>Page Cache</source>
          <target state="translated">ページキャッシュ</target>
        </trans-unit>
        <trans-unit id="111e3d8b941451e6256ee0ce1fa5b2560f773697" translate="yes" xml:space="preserve">
          <source>Page Cache Algorithms</source>
          <target state="translated">ページキャッシュアルゴリズム</target>
        </trans-unit>
        <trans-unit id="51e73b0787f74035c32eccb9bca14aa82436008b" translate="yes" xml:space="preserve">
          <source>Page Cache Configuration</source>
          <target state="translated">ページキャッシュの構成</target>
        </trans-unit>
        <trans-unit id="91dcdd907d00efb6c274aa541e77d89ded5b848c" translate="yes" xml:space="preserve">
          <source>Page cache memory allocations that overflow into the general-purpose memory allocator.</source>
          <target state="translated">汎用メモリアロケータにオーバーフローするページキャッシュメモリの割り当て。</target>
        </trans-unit>
        <trans-unit id="8b08ca42225d56c2d889ece253767100d76e7c2a" translate="yes" xml:space="preserve">
          <source>Page number</source>
          <target state="translated">ページ数</target>
        </trans-unit>
        <trans-unit id="ad392683af791420db4e7324c20464059ce3492a" translate="yes" xml:space="preserve">
          <source>Page number of first overflow page</source>
          <target state="translated">最初のオーバーフローページのページ番号</target>
        </trans-unit>
        <trans-unit id="6e528c19af566e5c19716241accd44732b15c3f1" translate="yes" xml:space="preserve">
          <source>Page number of left child</source>
          <target state="translated">左の子のページ番号</target>
        </trans-unit>
        <trans-unit id="1d20e1ca269b0f7a9ac2bdd34ee817b875d0828b" translate="yes" xml:space="preserve">
          <source>Page number of the first freelist trunk page.</source>
          <target state="translated">フリーリストの最初のトランクのページ番号です。</target>
        </trans-unit>
        <trans-unit id="2f6078feea4fe70e006a40f0bbe8960bf8454aee" translate="yes" xml:space="preserve">
          <source>Pagecache memory allocator</source>
          <target state="translated">ページキャッシュメモリアロケータ</target>
        </trans-unit>
        <trans-unit id="7a89afd5ef39a4cff0b861ab314756ac6e516da0" translate="yes" xml:space="preserve">
          <source>Pagecount</source>
          <target state="translated">Pagecount</target>
        </trans-unit>
        <trans-unit id="2a084ba7d77808cea5a5f8f9c1ab34ab55b7585a" translate="yes" xml:space="preserve">
          <source>Pager and btree subsystems removed. These will be used in a follow-on SQL server library named &quot;SQLus&quot;.</source>
          <target state="translated">ページャーとbtreeサブシステムが削除されました。これらは &quot;SQLus&quot; という名前の後続の SQL サーバーライブラリで使用されます。</target>
        </trans-unit>
        <trans-unit id="d03660f900d198f933a03da740944dbf17018900" translate="yes" xml:space="preserve">
          <source>Pager subsystem added but not yet used.</source>
          <target state="translated">ページャーサブシステムを追加しましたが、まだ使用していません。</target>
        </trans-unit>
        <trans-unit id="70384aa891f4780133eb9e575d0bd72469e20f4e" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 2147483646 (2&lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 140,737,488,224,256 bytes (about 140 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">ページは、最大ページ数が2147483646（2である1から始まる番号が付けられている&lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2）。最小サイズのSQLiteデータベースは、単一の512バイトページです。データベースの最大サイズは、ページあたり65536バイトの2147483646ページ、または140,737,488,224,256バイト（約140テラバイト）です。通常、SQLiteは、独自の内部サイズ制限に達する前に、基盤となるファイルシステムまたはディスクハードウェアの最大ファイルサイズ制限に達します。</target>
        </trans-unit>
        <trans-unit id="0f332eeefd007bb0043ccb46738196508c6a602b" translate="yes" xml:space="preserve">
          <source>Param</source>
          <target state="translated">Param</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="8b81f4321a39e53a61cf8fbe1b4d654902c2cd89" translate="yes" xml:space="preserve">
          <source>Parameter P4 may point to a Table structure, or may be NULL. If it is not NULL, then the update-hook (sqlite3.xUpdateCallback) is invoked following a successful insert.</source>
          <target state="translated">パラメータP4はテーブル構造体を指すか、NULLです。NULLでない場合、挿入に成功した後に更新フック(sqlite3.xUpdateCallback)が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a5652d036064588f8b6a1cd35001bca04abb6577" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">パラメータzDbは、データベースを含むファイル名ではなく、データベースのシンボル名です。接続されているデータベースの場合、これは&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントのASキーワードの後に​​表示される名前です。メインデータベースファイルの場合、データベース名は「メイン」です。TEMPテーブルの場合、データベース名は「temp」です。</target>
        </trans-unit>
        <trans-unit id="6b3dbfca494676dd202b93efd1413416a69fb138" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">パラメータzDbは、データベースを含むファイル名ではなく、データベースのシンボル名です。接続されているデータベースの場合、これは&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントのASキーワードの後に​​表示される名前です。メインデータベースファイルの場合、データベース名は「メイン」です。TEMPテーブルの場合、データベース名は「temp」です。</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="799e97b7e20fea27a8af5b85f72a1e45ff70f20e" translate="yes" xml:space="preserve">
          <source>Parameters can be either named or unnamed. An unnamed parameter is a single question mark (&quot;?&quot;). Named parameters are a &quot;?&quot; followed immediately by a number (ex: &quot;?15&quot; or &quot;?123&quot;) or one of the characters &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; followed by an alphanumeric name (ex: &quot;$var1&quot;, &quot;:xyz&quot;, &quot;@bingo&quot;).</source>
          <target state="translated">パラメータには名前を付けることも、名前を付けないこともできます。名前のないパラメータは、単一のクエスチョンマーク(&quot;?&quot;)です。名前付きパラメータは、&quot;? &quot;の後に数字 (例:&quot;?15&quot; や &quot;?123&quot;)、または &quot;$&quot;、&quot;:&quot;、&quot;@&quot; のいずれかの文字の後に英数字の名前 (例:&quot;$var1&quot;,&quot;:xyz&quot;,&quot;@bingo&quot;)を付けたものです。</target>
        </trans-unit>
        <trans-unit id="8cba5f18115ee2b196f01cd67b537bb6b53bf7ec" translate="yes" xml:space="preserve">
          <source>Parameters that are not assigned values using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; are treated as NULL. The &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; interface can be used to translate a symbolic parameter name into its equivalent numeric index.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;を使用して値が割り当てられていないパラメーターは、NULLとして扱われます。&lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt;インタフェースは、それに相当する数値インデックスにシンボリックパラメータ名を変換するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="4de5d1891af8779fc1d212b882aca704731f9909" translate="yes" xml:space="preserve">
          <source>Parent and child keys must have the same cardinality. In SQLite, if any of the child key columns (in this case songartist and songalbum) are NULL, then there is no requirement for a corresponding row in the parent table.</source>
          <target state="translated">親キーと子キーは同じカーディナリティを持たなければなりません。SQLite では、子キーのカラム (この場合は songartist と songalbum)のいずれかが NULL であれば、親テーブルに対応する行は必要ありません。</target>
        </trans-unit>
        <trans-unit id="f4093b4053e6e304b33edcd1e545c7ac44407405" translate="yes" xml:space="preserve">
          <source>Parent table</source>
          <target state="translated">親テーブル</target>
        </trans-unit>
        <trans-unit id="4e28259727cc9bea774f5aa837a0a46e7e8f6e3d" translate="yes" xml:space="preserve">
          <source>Parentheses around the column name are ignored. Hence if X and Y.Z are column names, then (X) and (Y.Z) are also considered column names and have the affinity of the corresponding columns.</source>
          <target state="translated">カラム名の周りの括弧は無視されます。したがって、XとY.Zがカラム名である場合、(X)と(Y.Z)もカラム名とみなされ、対応するカラムの親和性を持つことになります。</target>
        </trans-unit>
        <trans-unit id="e9b3806832484c8806fbc046fab28912aa2aa64c" translate="yes" xml:space="preserve">
          <source>Parenthesis are not supported.</source>
          <target state="translated">括弧はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="75d39bc816f04be94a422f23dd0120a1ebf6cf81" translate="yes" xml:space="preserve">
          <source>Parenthesis may be used to group expressions in order to modify operator precedence in the usual ways. For example:</source>
          <target state="translated">括弧は、通常の方法で演算子の優先順位を変更するために式をグループ化するために使用することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a5d92895b79471a4a9fa3ce0a6ffdf64945a6880" translate="yes" xml:space="preserve">
          <source>Parse (but do not implement) foreign keys.</source>
          <target state="translated">外部キーをパースします(実装はしません)。</target>
        </trans-unit>
        <trans-unit id="c98796aa2add46f2617d36d2c94c638a1c0df012" translate="yes" xml:space="preserve">
          <source>ParseSchema</source>
          <target state="translated">ParseSchema</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="e5dde1d1ec704f9acd81aeb949908d6d48dedf9c" translate="yes" xml:space="preserve">
          <source>Parser detects and reports automaton stack overflow.</source>
          <target state="translated">パーサはオートマトンスタックのオーバーフローを検出して報告します。</target>
        </trans-unit>
        <trans-unit id="de7186ac205c0a4d05d1b7e13d0477c901e264d5" translate="yes" xml:space="preserve">
          <source>Parsing Ambiguity</source>
          <target state="translated">曖昧さの解析</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">部分インデックス</target>
        </trans-unit>
        <trans-unit id="b83a6d7f720f864139ebf6cd22707c1309f4af67" translate="yes" xml:space="preserve">
          <source>Partial index causes assertion fault on UPDATE OR REPLACE. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</source>
          <target state="translated">部分インデックスにより、UPDATE OR REPLACEでアサーションエラーが発生します。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92e7c6c4dccd56837450920de775aa91130dc6eb" translate="yes" xml:space="preserve">
          <source>Partial indexes</source>
          <target state="translated">部分インデックス</target>
        </trans-unit>
        <trans-unit id="a6b00209f988aae401d1637e4d3a48cf480b87b9" translate="yes" xml:space="preserve">
          <source>Partial indexes have been supported in SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26).</source>
          <target state="translated">部分インデックスは、&lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;バージョン3.8.0&lt;/a&gt;（2013-08-26）以降、SQLiteでサポートされています。</target>
        </trans-unit>
        <trans-unit id="2c653f2abbb32f0888ba48000a6d19c0a678be3c" translate="yes" xml:space="preserve">
          <source>Partial sorting by index</source>
          <target state="translated">インデックスによる部分ソート</target>
        </trans-unit>
        <trans-unit id="8e7b279371a7a0621eac24aac6019fdbd06fb946" translate="yes" xml:space="preserve">
          <source>Partially or fully disable the use of mutexes using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;、および&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;を使用して、ミューテックスの使用を部分的または完全に無効にします。</target>
        </trans-unit>
        <trans-unit id="322d75c78f20c6c69dad6d4668258bee1cff55cf" translate="yes" xml:space="preserve">
          <source>Pass information about !=, IS, IS NOT, NOT NULL, and IS NULL constraints into the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of virtual tables.</source>
          <target state="translated">！=、IS、IS NOT、NOT NULL、およびIS NULL制約に関する情報を仮想テーブルの&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;メソッドに渡します。</target>
        </trans-unit>
        <trans-unit id="87139427c07163b54b934cac2e589a5477f5abd2" translate="yes" xml:space="preserve">
          <source>Passing around pointers as if they were integers or BLOBs is easy, effective, and works well in an environment where the application components are all friendly toward one another. However, passing pointers as integers and BLOBs allows hostile SQL text to forge invalid pointers that can carry out mischief.</source>
          <target state="translated">ポインタをあたかも整数やBLOBであるかのように渡すことは簡単で効果的で、アプリケーションのコンポーネントが互いに友好的な環境ではうまく機能します。しかし、ポインタを整数やBLOBのように渡すと、敵対的なSQLテキストが不正なポインタを偽造し、悪事を働く可能性があります。</target>
        </trans-unit>
        <trans-unit id="3138de58b357feeff45cc3442a6fef1e07764789" translate="yes" xml:space="preserve">
          <source>Passing zero to this function disables the session. Passing a value greater than zero enables it. Passing a value less than zero is a no-op, and may be used to query the current state of the session.</source>
          <target state="translated">この関数にゼロを渡すと、セッションは無効になります。ゼロよりも大きい値を渡すとセッションが有効になります。ゼロよりも小さい値を渡すと無効化され、セッションの現在の状態を問い合わせるために使用されます。</target>
        </trans-unit>
        <trans-unit id="590be09d7533f1bdecea251bf8fa20c21692381c" translate="yes" xml:space="preserve">
          <source>Patch releases may or may not have a release checklist, depending on the issue. This is a judgement call by the project leader.</source>
          <target state="translated">パッチリリースには、課題によってリリースチェックリストがある場合とない場合があります。これはプロジェクトリーダーの判断によるものです。</target>
        </trans-unit>
        <trans-unit id="6943c09e1bab506ed4d4e77bf277765f2ba43e9d" translate="yes" xml:space="preserve">
          <source>Patches from Christian Werner to improve ODBC compatibility and to fix a bug in the round() function.</source>
          <target state="translated">Christian Werner からのパッチで、ODBC の互換性を改善し、round()関数のバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="c30415eacc6a59446974b716eff56cf28219815d" translate="yes" xml:space="preserve">
          <source>Payload</source>
          <target state="translated">Payload</target>
        </trans-unit>
        <trans-unit id="2cd642b895a9277d90f1edb51ac2e97d29897374" translate="yes" xml:space="preserve">
          <source>Payload, either table b-tree data or index b-tree keys, is always in the &quot;record format&quot;. The record format defines a sequence of values corresponding to columns in a table or index. The record format specifies the number of columns, the datatype of each column, and the content of each column.</source>
          <target state="translated">ペイロードは、テーブルの b-tree データまたはインデックスの b-tree キーのいずれかであり、常に「レコード形式」である。レコードフォーマットは、テーブルまたはインデックスのカラムに対応する一連の値を定義する。レコードフォーマットは、列の数、各列のデータ型、各列の内容を指定する。</target>
        </trans-unit>
        <trans-unit id="e74a4343f3025ea9dd8df608f45f6bce992f0d7e" translate="yes" xml:space="preserve">
          <source>Pending statements no longer block &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. Instead, the pending statement will return SQLITE_ABORT upon next access after the ROLLBACK.</source>
          <target state="translated">保留中のステートメントは&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACKを&lt;/a&gt;ブロックしなくなりました。代わりに、保留中のステートメントは、ROLLBACK後の次のアクセス時にSQLITE_ABORTを返します。</target>
        </trans-unit>
        <trans-unit id="4737507de6ca940161ab97310c9c1d96280bacd6" translate="yes" xml:space="preserve">
          <source>People often wonder why SQLite does not use the &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; version control system like everybody else. This article attempts to answer that question. Also, in &lt;a href=&quot;#getthecode&quot;&gt;section 3&lt;/a&gt;, this article provides hints to Git users about how they can easily access the SQLite source code.</source>
          <target state="translated">SQLiteが他の皆のように&lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt;バージョン管理システムを使用しないのはなぜかと不思議に思う人がよくいます。この記事はその質問に答えようとしています。また、この記事では、&lt;a href=&quot;#getthecode&quot;&gt;セクション3で&lt;/a&gt;、GitユーザーがSQLiteソースコードに簡単にアクセスする方法についてヒントを提供しています。</target>
        </trans-unit>
        <trans-unit id="a859905b933e3207fdf46d957c4ccc640fdf48ae" translate="yes" xml:space="preserve">
          <source>People who understand SQL can employ the &lt;a href=&quot;cli&quot;&gt;sqlite3 command-line shell&lt;/a&gt; (or various third-party SQLite access programs) to analyze large datasets. Raw data can be imported from CSV files, then that data can be sliced and diced to generate a myriad of summary reports. More complex analysis can be done using simple scripts written in Tcl or Python (both of which come with SQLite built-in) or in R or other languages using readily available adaptors. Possible uses include website log analysis, sports statistics analysis, compilation of programming metrics, and analysis of experimental results. Many bioinformatics researchers use SQLite in this way.</source>
          <target state="translated">SQLを理解している人は、&lt;a href=&quot;cli&quot;&gt;sqlite3コマンドラインシェル&lt;/a&gt;（またはさまざまなサードパーティのSQLiteアクセスプログラム）を使用して、大規模なデータセットを分析できます。生データをCSVファイルからインポートしてから、そのデータをスライスおよびダイシングして、無数のサマリーレポートを生成できます。より複雑な分析は、TclまたはPython（どちらもSQLiteが組み込まれています）またはRまたは他の言語で簡単に利用できるアダプターを使用して記述された単純なスクリプトを使用して実行できます。可能な用途には、ウェブサイトのログ分析、スポーツ統計分析、プログラミング指標の編集、実験結果の分析などがあります。多くのバイオインフォマティクス研究者は、このようにSQLiteを使用しています。</target>
        </trans-unit>
        <trans-unit id="deda64204144c5cb8a53d34e5d28a353e9faf513" translate="yes" xml:space="preserve">
          <source>Perform a single step of the incremental vacuum procedure on the P1 database. If the vacuum has finished, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">P1データベース上でインクリメンタルバキュームプロシージャの1ステップを実行します。バキュームが終了したら、命令P2にジャンプします。それ以外の場合は、次の命令にフォールスルーします。</target>
        </trans-unit>
        <trans-unit id="54eef71ea08bf2a0291b4730516048fec290cbbf" translate="yes" xml:space="preserve">
          <source>Perform any required foreign key actions,</source>
          <target state="translated">必要な外部キーアクションを実行します。</target>
        </trans-unit>
        <trans-unit id="94e7748396990532238f46b792b6a833a4e68178" translate="yes" xml:space="preserve">
          <source>Perform some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; operations in a single pass instead of in two passes.</source>
          <target state="translated">2つのパスではなく、1つのパスでいくつかの&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;操作を実行します。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b4045b439e29414aaf2009ad15f476795f21a79" translate="yes" xml:space="preserve">
          <source>Performance Related Assumptions</source>
          <target state="translated">パフォーマンス関連の前提条件</target>
        </trans-unit>
        <trans-unit id="5539b01935cddeb466afb8949c00cacfd4174474" translate="yes" xml:space="preserve">
          <source>Performance can be improved and the size reduced by enabling &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt;, &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS=0&lt;/a&gt;, &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1&lt;/a&gt;, &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;, &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH=0&lt;/a&gt;, &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt;, &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;, &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;, and &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;. All these options together result in about a 3.5% performance increase and a 3.0% size reduction.</source>
          <target state="translated">性能を向上させることができ、サイズが有効に減少&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt;、&lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS = 0&lt;/a&gt;、&lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS = 1&lt;/a&gt;、&lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;、&lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH = 0&lt;/a&gt;、&lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPEを&lt;/a&gt;、&lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;、&lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;、&lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;、及び&lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;。これらすべてのオプションを組み合わせると、パフォーマンスが約3.5％向上し、サイズが3.0％削減されます。</target>
        </trans-unit>
        <trans-unit id="1860a0dfdb81986d4ea2f6eb535ec453b85d5fe2" translate="yes" xml:space="preserve">
          <source>Performance does not always increase with memory-mapped I/O. In fact, it is possible to construct test cases where performance is reduced by the use of memory-mapped I/O.</source>
          <target state="translated">メモリマップドI/Oを使用しても性能が常に向上するわけではありません。実際、メモリマップドI/Oを使用することで性能が低下するテストケースを構築することができます。</target>
        </trans-unit>
        <trans-unit id="61bd66ed39fd686f0ca14a86562254f51520b57c" translate="yes" xml:space="preserve">
          <source>Performance enhancement: Reengineer the internal routines used to interpret and render variable-length integers.</source>
          <target state="translated">パフォーマンスの向上。可変長整数の解釈およびレンダリングに使用される内部ルーチンをリエンジニアリングしました。</target>
        </trans-unit>
        <trans-unit id="cea233e3b9eddbf52457c8a5a182ae23ce06f170" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;-generated parser</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;Lemonで&lt;/a&gt;生成されたパーサーのパフォーマンス強化</target>
        </trans-unit>
        <trans-unit id="c2ed78164f58cda3689de3af94b6683e701f4012" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the VDBE, especially to the OP_Column opcode.</source>
          <target state="translated">VDBEにおけるパフォーマンスの向上、特にOP_Columnオペコードの強化。</target>
        </trans-unit>
        <trans-unit id="3e83f7e02f169f16c4ce4c1bf1daf1d4f6a2d0dd" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the parser.</source>
          <target state="translated">パーサーのパフォーマンスを向上させました。</target>
        </trans-unit>
        <trans-unit id="1553d9684987d03c293eb61361d1bad6eb661140" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the sorter used by ORDER BY and CREATE INDEX.</source>
          <target state="translated">ORDER BYとCREATE INDEXで使用されるソーターのパフォーマンスが強化されました。</target>
        </trans-unit>
        <trans-unit id="d07c917b16f3c5d3172eade92a68d5375afe8a41" translate="yes" xml:space="preserve">
          <source>Performance enhancements on some corner cases of COUNT(*).</source>
          <target state="translated">COUNT(*)のいくつかのコーナーケースでのパフォーマンスの向上。</target>
        </trans-unit>
        <trans-unit id="2136335adf2e68388f67bd194f29e528095a22d7" translate="yes" xml:space="preserve">
          <source>Performance enhancements through reductions in disk I/O:</source>
          <target state="translated">ディスクI/Oの削減による性能向上</target>
        </trans-unit>
        <trans-unit id="f10f9c4b246cd76bbc82d16d809b97086003c9dc" translate="yes" xml:space="preserve">
          <source>Performance enhancements to tree balancing logic in the B-Tree layer.</source>
          <target state="translated">B-Tree レイヤのツリーバランシングロジックのパフォーマンスが強化されました。</target>
        </trans-unit>
        <trans-unit id="c1957e5fe4e4a95d607424db9c544dbfb2c9f147" translate="yes" xml:space="preserve">
          <source>Performance enhancements.</source>
          <target state="translated">パフォーマンスの強化。</target>
        </trans-unit>
        <trans-unit id="fd543174849447437d626cec826158c9d3d9aa89" translate="yes" xml:space="preserve">
          <source>Performance improvement: Constant subexpressions are factored out of loops.</source>
          <target state="translated">パフォーマンスの向上。定数の副表現はループの外で処理されます。</target>
        </trans-unit>
        <trans-unit id="6267206177784b60f0b03bc62ec213be82afcde6" translate="yes" xml:space="preserve">
          <source>Performance improvement: Results of OP_Column are reused rather than issuing multiple OP_Column opcodes.</source>
          <target state="translated">パフォーマンスの向上。複数のOP_Columnオペコードを発行するのではなく、OP_Columnの結果を再利用するようになりました。</target>
        </trans-unit>
        <trans-unit id="865a67eeabea312b0a75ae22ab67eb186cfe013a" translate="yes" xml:space="preserve">
          <source>Performance improvement: The OP_IdxDelete opcode uses unpacked records, obviating the need for one OP_MakeRecord opcode call for each index record deleted.</source>
          <target state="translated">パフォーマンスの向上。OP_IdxDelete オプトコードはアンパックされたレコードを使用し、削除されたインデックスレコードごとにOP_MakeRecord オプトコードを1回呼び出す必要がなくなりました。</target>
        </trans-unit>
        <trans-unit id="78e2db7e7f2b2267a1830af4b4a2ed0ba33c683b" translate="yes" xml:space="preserve">
          <source>Performance improvements for &quot;count(*)&quot; queries.</source>
          <target state="translated">count(*)クエリのパフォーマンスの向上。</target>
        </trans-unit>
        <trans-unit id="6efb6a4d8f17dc824c346d05f15cd7b2b88dcf5d" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;.</source>
          <target state="translated">以下のためのパフォーマンスの向上&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;、&lt;a href=&quot;lang_createindex&quot;&gt;INDEX、CREATE&lt;/a&gt;、&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;、および&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_checkを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7ba2d57a08f2fc705e0114aa7d1ce0a8358e340" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;, especially in cases where the number of free pages is greater than what will fit on a single trunk page of the freelist.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuumの&lt;/a&gt;パフォーマンスの向上。特に、フリーページの数が、フリーリストの単一のトランクページに収まる数よりも多い場合。</target>
        </trans-unit>
        <trans-unit id="ca9c11fd98f734889e089bb0e89c4f23dda7fe58" translate="yes" xml:space="preserve">
          <source>Performance improvements in the LEMON-generated parser.</source>
          <target state="translated">LEMON生成パーサの性能向上。</target>
        </trans-unit>
        <trans-unit id="a14e5b6d4c4866ac4384c7883a92dffe274c0fdc" translate="yes" xml:space="preserve">
          <source>Performance improvements in the parser, pager, and WHERE clause code generator.</source>
          <target state="translated">パーサ、ページャー、WHERE句コード生成器の性能向上。</target>
        </trans-unit>
        <trans-unit id="4775771a833741ba344ee91f202aad2d4ccd4444" translate="yes" xml:space="preserve">
          <source>Performance improvements in the query optimizer.</source>
          <target state="translated">クエリオプティマイザの性能向上。</target>
        </trans-unit>
        <trans-unit id="db2c756a058cad6c443215c62bd837d8ebcd7c86" translate="yes" xml:space="preserve">
          <source>Performance improvements. The library is now much faster.</source>
          <target state="translated">パフォーマンスの向上。ライブラリが大幅に高速化されました。</target>
        </trans-unit>
        <trans-unit id="7776d02639084ffcec06b8eee5d8080752868819" translate="yes" xml:space="preserve">
          <source>Performance measurements are done with a single compiler (gcc 5.4.0), optimization setting (-Os), and on a single platform (Ubuntu 16.04 LTS on x64). The performance of other compilers and processors may vary.</source>
          <target state="translated">性能測定は、単一のコンパイラ(gcc 5.4.0)、最適化設定(-Os)、単一のプラットフォーム(Ubuntu 16.04 LTS on x64)で行っています。他のコンパイラやプロセッサの性能は異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="4313721e53c3870801c269d394561df5830ac670" translate="yes" xml:space="preserve">
          <source>Performance optimizations targeting a specific use case from a single high-profile user of SQLite. A 12% reduction in the number of CPU operations is achieved (as measured by Valgrind). Actual performance improvements in practice may vary depending on workload. Changes include:</source>
          <target state="translated">SQLiteの注目度の高い1人のユーザーから、特定のユースケースを対象としたパフォーマンスの最適化。CPU 操作数を 12% 削減しました(Valgrind で測定)。実際のパフォーマンス向上はワークロードによって異なる場合があります。変更点は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="aafc19be49f715a88d989d3b462949b02cf65924" translate="yes" xml:space="preserve">
          <source>Performance problems can often be resolved, even late in the development cycle, using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, avoiding costly redesign, rewrite, and retest efforts.</source>
          <target state="translated">多くの場合、パフォーマンスの問題は、開発サイクルの後半でも&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;を使用して解決でき、コストのかかる再設計、再書き込み、再テストの作業を回避できます。</target>
        </trans-unit>
        <trans-unit id="80d748ed593bda4d15f97528a4a48c139940ad2c" translate="yes" xml:space="preserve">
          <source>Performance was measured by running speedtest1 using cachegrind and observing the &quot;I refs&quot; output.</source>
          <target state="translated">パフォーマンスは、cachegrind を使用して speedtest1 を実行し、&quot;I refs&quot; 出力を観察することで測定されました。</target>
        </trans-unit>
        <trans-unit id="fd932d13fa7bed8f3a51946f0c1cded4ce734cc8" translate="yes" xml:space="preserve">
          <source>Performance was measured using the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; utility program, which attempts to mimic a typical workload for SQLite. Options to the test runs are:</source>
          <target state="translated">パフォーマンスは、&lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedite1.c&lt;/a&gt;ユーティリティプログラムを使用して測定されました。このプログラムは、SQLiteの典型的なワークロードを模倣しようとします。テスト実行のオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="306df6900907956d3250e5c6b9116143f3e59d56" translate="yes" xml:space="preserve">
          <source>Perhaps you are referring to the following statement from SQL92:</source>
          <target state="translated">おそらく、SQL92の以下の文を参照しているのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="dc174949d4e077b47c1979929b03d9b696ed5987" translate="yes" xml:space="preserve">
          <source>Permit SELECT statements without a FROM clause.</source>
          <target state="translated">FROM句なしのSELECT文を許可します。</target>
        </trans-unit>
        <trans-unit id="6cbfe59727ef5993727b847bb5705e98e92cb339" translate="yes" xml:space="preserve">
          <source>Permutation</source>
          <target state="translated">Permutation</target>
        </trans-unit>
        <trans-unit id="4fce736ea498cc616300b0a192c1d1da1b783f4c" translate="yes" xml:space="preserve">
          <source>Permuted Title Index</source>
          <target state="translated">パーミュレートされたタイトルインデックス</target>
        </trans-unit>
        <trans-unit id="d33cf936053187794d74699260279a0a85c60b95" translate="yes" xml:space="preserve">
          <source>Persistent loadable extensions</source>
          <target state="translated">永続的にロード可能な拡張機能</target>
        </trans-unit>
        <trans-unit id="cda60e78224642430ac8ecc50f20cf5762fbe57b" translate="yes" xml:space="preserve">
          <source>Phrase and NEAR queries may not span multiple columns within a row.</source>
          <target state="translated">フレーズおよびNEARクエリは、行内の複数の列にまたがることができません。</target>
        </trans-unit>
        <trans-unit id="8867fcbca825b3aa1d7306421a378db86e201e5f" translate="yes" xml:space="preserve">
          <source>Phrase queries</source>
          <target state="translated">フレーズクエリ</target>
        </trans-unit>
        <trans-unit id="a363180d8d104ea58876b6a7416ecc65d37a83bd" translate="yes" xml:space="preserve">
          <source>Phrase queries are not available.</source>
          <target state="translated">フレーズクエリは利用できません。</target>
        </trans-unit>
        <trans-unit id="c2d36c2214269a55cf08fe15db0efb7f6b50dc52" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may also be connected by &lt;b&gt;implicit AND operators&lt;/b&gt;. For simplicity, these are not shown in the BNF grammar above. Essentially, any sequence of phrases or NEAR groups (including those restricted to matching specified columns) separated only by whitespace are handled as if there were an implicit AND operator between each pair of phrases or NEAR groups. Implicit AND operators are never inserted after or before an expression enclosed in parenthesis. For example:</source>
          <target state="translated">句とNEARグループは、&lt;b&gt;暗黙のAND演算子で&lt;/b&gt;接続することもできます。簡単にするために、これらは上記のBNF文法には示されていません。基本的に、空白でのみ区切られたフレーズまたはNEARグループのシーケンス（指定された列の一致に限定されたものを含む）は、フレーズまたはNEARグループの各ペア間に暗黙のAND演算子が存在するかのように処理されます。暗黙のAND演算子は、括弧で囲まれた式の前後に挿入されることはありません。例えば：</target>
        </trans-unit>
        <trans-unit id="c324bfc69bd8b1bd8095017021f5a91e3ea40b2c" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may be arranged into expressions using &lt;b&gt;boolean operators&lt;/b&gt;. In order of precedence, from highest (tightest grouping) to lowest (loosest grouping), the operators are:</source>
          <target state="translated">句とNEARグループは、&lt;b&gt;ブール演算子&lt;/b&gt;を使用して式に配置できます。優先順位の高い順に、最も高い（最もタイトなグループ化）から最も低い（最もルーズなグループ化）まで、演算子は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3ae7ce4ac376e04456d5e49b6ed2413b1a3d558b" translate="yes" xml:space="preserve">
          <source>Picking the nested order of the various loops</source>
          <target state="translated">様々なループの入れ子になった順番をピックする</target>
        </trans-unit>
        <trans-unit id="e6557cb061d60a980305721118e117b8668196a9" translate="yes" xml:space="preserve">
          <source>Picking the nesting order is generally the more challenging problem. Once the nesting order of the join is established, the choice of indexes for each loop is normally obvious.</source>
          <target state="translated">入れ子の順番を選ぶことは、一般的にはより困難な問題です。結合の入れ子順序が確立されると、各ループのインデックスの選択は通常、明らかになります。</target>
        </trans-unit>
        <trans-unit id="48838d5eebf4e016bae8e0582e9b79166631f842" translate="yes" xml:space="preserve">
          <source>Pinning (reading) a database page.</source>
          <target state="translated">データベースのページをピン留め(読み込み)します。</target>
        </trans-unit>
        <trans-unit id="e786fb34d40222929b9ef3bd84afa78c0fc799e8" translate="yes" xml:space="preserve">
          <source>Plays better with virus scanners on Windows</source>
          <target state="translated">Windows上のウイルススキャナーとの相性が良い</target>
        </trans-unit>
        <trans-unit id="0ba6acad031749dfc1ea19f37cf3cf3ba6821875" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">ポインタがから返されたという事実に特に注意を払ってください&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;、または&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16（）&lt;/a&gt;へのその後の呼び出しによって無効化することができます&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;、または&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ae91e82ac5caaf87714c26921fb437ec0209ebd" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">ポインタがから返されたという事実に特に注意を払ってください&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob（） &lt;/a&gt;、&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;、または&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16（）&lt;/a&gt;へのその後の呼び出しによって無効化することができます&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes（） &lt;/a&gt;、&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16（） &lt;/a&gt;、&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;、または&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82e80b8ed5a5ef5a7f7f84502fd344efe74ab819" translate="yes" xml:space="preserve">
          <source>Plug some memory leaks that use to occur if malloc() failed. We have been and continue to be memory leak free as long as malloc() works.</source>
          <target state="translated">malloc()が失敗した場合に発生していたメモリリークを塞ぎます。malloc()が動作する限り、メモリリークはありません。</target>
        </trans-unit>
        <trans-unit id="9885c5aa124b354814a6a44123b3e909495fe046" translate="yes" xml:space="preserve">
          <source>Pointer Passing Interfaces</source>
          <target state="translated">ポインタパッシングインタフェース</target>
        </trans-unit>
        <trans-unit id="59e3eae717dea15b934265a0c37302cf590a5714" translate="yes" xml:space="preserve">
          <source>Pointer leak</source>
          <target state="translated">ポインターリーク</target>
        </trans-unit>
        <trans-unit id="893d8abe3b1d2dc513b4dcba9c2db9ee48da24a6" translate="yes" xml:space="preserve">
          <source>Pointer map or ptrmap pages are extra pages inserted into the database to make the operation of &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes more efficient. Other page types in the database typically have pointers from parent to child. For example, an interior b-tree page contains pointers to its child b-tree pages and an overflow chain has a pointer from earlier to later links in the chain. A ptrmap page contains linkage information going in the opposite direction, from child to parent.</source>
          <target state="translated">ポインターマップまたはptrmapページは、&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;および&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt;モードの操作をより効率的にするためにデータベースに挿入される追加のページです。データベースの他のページタイプには、通常、親から子へのポインタがあります。たとえば、内部のBツリーページには、その子Bツリーページへのポインタが含まれており、オーバーフローチェーンには、チェーン内の前のリンクから後のリンクへのポインタがあります。ptrmapページには、子から親へと反対方向に進むリンク情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="d9fb370b0a40e2e2f19446936bcadb07206247ac" translate="yes" xml:space="preserve">
          <source>Pointer types</source>
          <target state="translated">ポインタ型</target>
        </trans-unit>
        <trans-unit id="1091e0ac6927998f6cf6d184bfe2c9b9dcea6870" translate="yes" xml:space="preserve">
          <source>Pointer types are static strings, which ideally should be string literals embedded directly in the SQLite API call, not parameters passed in from other functions. Consideration was given to using integer values as the pointer type, but static strings provides a much larger name space which reduces the chance of accidental type-name collisions between unrelated extensions.</source>
          <target state="translated">ポインタ型は静的文字列であり、理想的には SQLite API の呼び出しに直接埋め込まれた文字列リテラルであるべきであり、他の関数から渡されたパラメータではありません。ポインタ型として整数値を使用することも検討されましたが、静的文字列の方が名前空間が広くなるため、無関係な拡張モジュール間で型名の衝突が起こる可能性が低くなります。</target>
        </trans-unit>
        <trans-unit id="3b1d288532e92abf21814dda987180d6353e6315" translate="yes" xml:space="preserve">
          <source>Pointer values generated by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; cannot be read by pure SQL. Hence, it is not possible for SQL to leak the value of pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;と&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;によって生成されたポインター値は、純粋なSQLでは読み取ることができません。したがって、SQLがポインターの値をリークすることはありません。</target>
        </trans-unit>
        <trans-unit id="362edd7f45230e1071baa348e5b8aa0beef2dc87" translate="yes" xml:space="preserve">
          <source>Pointer values must flow directly from their producer into their consumer, with no intermediate operators or functions. Any transformation of a pointer value destroys the pointer and transforms the value into an ordinary SQL NULL.</source>
          <target state="translated">ポインタ値は、中間演算子や関数を介さずに、生成者から消費者へ直接流れなければなりません。ポインタ値の変換は、ポインタを破棄し、値を通常のSQL NULLに変換します。</target>
        </trans-unit>
        <trans-unit id="d40a766f8bf600e29b3ebb06afc3c66d8eb2275c" translate="yes" xml:space="preserve">
          <source>Pointer values read by &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; cannot be generated by pure SQL. Hence, it is not possible for SQL to forge pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;によって読み取られたポインター値は、純粋なSQLでは生成できません。したがって、SQLがポインターを偽造することはできません。</target>
        </trans-unit>
        <trans-unit id="074017050c52f59774a49045cefb3a8e55469503" translate="yes" xml:space="preserve">
          <source>Pointers should &lt;u&gt;never&lt;/u&gt; be exchanged by encoding them as some other SQL datatype, such as integers or BLOBs. Instead, use the interfaces designed to facilitate secure pointer passing: &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">ポインターは、整数やBLOBなどの他のSQLデータ型としてエンコードして交換する&lt;u&gt;ことは&lt;/u&gt;できませ&lt;u&gt;ん&lt;/u&gt;。代わりに、安全なポインターの受け渡しを容易にするために設計されたインターフェース&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;、&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）を使用してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3758fcfa626c0aaafd8e85f7ec0b94d37eb1b41f" translate="yes" xml:space="preserve">
          <source>Porting SQLite To New Operating Systems</source>
          <target state="translated">新しいオペレーティングシステムへのSQLiteの移植</target>
        </trans-unit>
        <trans-unit id="492619cf72b9410d05b5a1fac306af0804a5c47b" translate="yes" xml:space="preserve">
          <source>Position cursor P1 at the end of the btree for the purpose of appending a new entry onto the btree.</source>
          <target state="translated">カーソルP1をbtreeの末尾に配置し、btreeに新しいエントリを追加する。</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="a6c78fee1df30606dfc4f598f623eca0d1354255" translate="yes" xml:space="preserve">
          <source>PostgreSQL:</source>
          <target state="translated">PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="957feaeb06e5a65656c3283c9c7193ebcf008b45" translate="yes" xml:space="preserve">
          <source>Postpone I/O associated with TEMP files for as long as possible, with the hope that the I/O can ultimately be avoided completely.</source>
          <target state="translated">TEMPファイルに関連するI/Oは、最終的にI/Oが完全に回避されることを期待して、できるだけ長く延期します。</target>
        </trans-unit>
        <trans-unit id="1bdd037a51c3dae4c27aa3b443867933947439ca" translate="yes" xml:space="preserve">
          <source>Powersafe Overwrite</source>
          <target state="translated">パワーズセーフ上書き</target>
        </trans-unit>
        <trans-unit id="10329807f69720bd141eb1a12685730b2cfaf4cd" translate="yes" xml:space="preserve">
          <source>Pragma list</source>
          <target state="translated">プラグマリスト</target>
        </trans-unit>
        <trans-unit id="c984aa3372c91f167c3b8d4c0c9f9715c82d4221" translate="yes" xml:space="preserve">
          <source>Pragma statements supported by SQLite</source>
          <target state="translated">SQLite でサポートされているプラグマ文</target>
        </trans-unit>
        <trans-unit id="4a80a5f45da767ce7271bd5ac307890ba0ff78a6" translate="yes" xml:space="preserve">
          <source>Pragmas whose names are &lt;s&gt;struck through&lt;/s&gt; are deprecated. Do not use them. They exist for historical compatibility.</source>
          <target state="translated">名前がされているプラグマ&lt;s&gt;によって打た&lt;/s&gt;廃止されました。使用しないでください。これらは、歴史的な互換性のために存在しています。</target>
        </trans-unit>
        <trans-unit id="36fd60583248a73e8dcb8aeb3b04450519f9ddea" translate="yes" xml:space="preserve">
          <source>Pray for your enemies in the love of Christ.</source>
          <target state="translated">キリストの愛のうちに敵のために祈りましょう。</target>
        </trans-unit>
        <trans-unit id="1d437b581e9dcd72eb07665e29677b9a7ea18988" translate="yes" xml:space="preserve">
          <source>Prefer nothing more than the love of Christ.</source>
          <target state="translated">キリストの愛以上のものはありません。</target>
        </trans-unit>
        <trans-unit id="6b85b242b16c8eaf303d30b62e8918e8c764ab9e" translate="yes" xml:space="preserve">
          <source>Prefix indexes may be used to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; in two cases. If the query is for a prefix of N bytes, then a prefix index created with &quot;prefix=N&quot; provides the best optimization. Or, if no &quot;prefix=N&quot; index is available, a &quot;prefix=N+1&quot; index may be used instead. Using a &quot;prefix=N+1&quot; index is less efficient than a &quot;prefix=N&quot; index, but is better than no prefix index at all.</source>
          <target state="translated">プレフィックスインデックスは、2つのケースで&lt;a href=&quot;fts3#termprefix&quot;&gt;プレフィックスクエリ&lt;/a&gt;を最適化するために使用できます。クエリがNバイトのプレフィックスに対するものである場合、「prefix = N」で作成されたプレフィックスインデックスが最適化を提供します。または、「prefix = N」インデックスが使用できない場合は、代わりに「prefix = N + 1」インデックスを使用できます。&quot;prefix = N + 1&quot;インデックスを使用することは、 &quot;prefix = N&quot;インデックスより効率的ではありませんが、プレフィックスインデックスをまったく使用しないよりは優れています。</target>
        </trans-unit>
        <trans-unit id="f58acbef3b4f1545b36db43fdb7aa3248226ddc3" translate="yes" xml:space="preserve">
          <source>Prefix query</source>
          <target state="translated">プレフィックスクエリ</target>
        </trans-unit>
        <trans-unit id="d876a9e47626f4666efcfc69bdf4c50fcc426b9e" translate="yes" xml:space="preserve">
          <source>Prefix search in FTS3 is much more efficient.</source>
          <target state="translated">FTS3でのプレフィックス検索は、より効率的になりました。</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="f3d20f83dbeeb1d79306958dea533c43146bb29c" translate="yes" xml:space="preserve">
          <source>Prepare Flags</source>
          <target state="translated">国旗の準備</target>
        </trans-unit>
        <trans-unit id="d5f65540d8f04f5669bf0a7783fb7256d5f3309f" translate="yes" xml:space="preserve">
          <source>Prepared Statement Object</source>
          <target state="translated">準備されたステートメントオブジェクト</target>
        </trans-unit>
        <trans-unit id="d84580c0a3c076e6a6095c0d8c0427ccdaa13d1e" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status</source>
          <target state="translated">作成されたステートメントのスキャン状況</target>
        </trans-unit>
        <trans-unit id="1037ef270384cfd9be096004017447826d2cb2f5" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status Opcodes</source>
          <target state="translated">準備されたステートメントスキャンの状態のオプコード</target>
        </trans-unit>
        <trans-unit id="2f5da103100b3440f26c60eb3e05807f62717d70" translate="yes" xml:space="preserve">
          <source>Prepared Statement Status</source>
          <target state="translated">作成されたステートメントの状況</target>
        </trans-unit>
        <trans-unit id="213d6f218c41a8dc480fb564c77564038e40e839" translate="yes" xml:space="preserve">
          <source>Prepend as many &quot;0&quot; characters to numeric substitutions as necessary to expand the value out to the specified width. If the width field is omitted, then this flag is a no-op.</source>
          <target state="translated">指定された幅に値を展開するために、必要なだけ多くの &quot;0 &quot;文字を数値置換にプリペンドします。幅フィールドが省略された場合、このフラグは無効となります。</target>
        </trans-unit>
        <trans-unit id="07ea5425dab39a1ce6090bfaba72b208d8a2bb32" translate="yes" xml:space="preserve">
          <source>Prepend the &quot;&lt;code&gt;file:&lt;/code&gt;&quot; scheme.</source>
          <target state="translated">「 &lt;code&gt;file:&lt;/code&gt; 」スキームを付加します。</target>
        </trans-unit>
        <trans-unit id="b5b2c6aa0c741177b3341a9cac682f0503cc7181" translate="yes" xml:space="preserve">
          <source>Pretend that the single row just extracted is the only row in the recursive table and run the recursive-select, adding all results to the queue.</source>
          <target state="translated">先ほど抽出した単一の行が再帰テーブルの唯一の行であると仮定して、すべての結果をキューに追加して再帰的選択を実行します。</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="d011a785f80d4ac2978260fd4baeb9a488339607" translate="yes" xml:space="preserve">
          <source>Prevent journal file overflows on huge transactions.</source>
          <target state="translated">膨大なトランザクションでのジャーナルファイルのオーバーフローを防止します。</target>
        </trans-unit>
        <trans-unit id="15aff2aaf0be53526cd90b44a8f7faa67462af63" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">主な場所：&lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/docsrc</target>
        </trans-unit>
        <trans-unit id="bb559fe38e423e3bb19de0649fe3fd5b6b237723" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</source>
          <target state="translated">主な場所：&lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/sqllogictest</target>
        </trans-unit>
        <trans-unit id="40da77fe99b4c2e0002b4b5a88b9bdf5b5ffd788" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">主な場所：&lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/src</target>
        </trans-unit>
        <trans-unit id="72c44b5ab0d08449343e1c11f7db59a0baee6a06" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">主な場所：&lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/th3</target>
        </trans-unit>
        <trans-unit id="284d8db03255f327420e4917415f7de011fcda53" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</source>
          <target state="translated">主な場所：&lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/th3private</target>
        </trans-unit>
        <trans-unit id="12c6ce30d8dde9c30a0548e43a1a65f2399c3ac8" translate="yes" xml:space="preserve">
          <source>Primary result code symbolic names are of the form &quot;SQLITE_XXXXXX&quot; where XXXXXX is a sequence of uppercase alphabetic characters. Extended result code names are of the form &quot;SQLITE_XXXXXX_YYYYYYY&quot; where the XXXXXX part is the corresponding primary result code and the YYYYYYY is an extension that further classifies the result code.</source>
          <target state="translated">一次結果コードのシンボリック名は、&quot;SQLITE_XXXXXXXX &quot;という形式で、XXXXXXはアルファベット大文字のシーケンスです。拡張結果コード名は &quot;SQLITE_XXXXXXXX_YYYYY &quot;の形式で、XXXXXX の部分は対応する一次結果コードであり、YYYYYY は結果コードをさらに分類する拡張コードです。</target>
        </trans-unit>
        <trans-unit id="4fda803b9a957798a3e6c9099105e126c5e73e36" translate="yes" xml:space="preserve">
          <source>Primary versus extended result codes</source>
          <target state="translated">一次結果コードと拡張結果コード</target>
        </trans-unit>
        <trans-unit id="3b2d52029dad08f51a816bff4a2b1ace042995a8" translate="yes" xml:space="preserve">
          <source>Print the offending SQL statement when an error occurs.</source>
          <target state="translated">エラーが発生した場合、問題のある SQL 文を表示します。</target>
        </trans-unit>
        <trans-unit id="93863d358af110c5080e64cc1cfc5d8749e0490f" translate="yes" xml:space="preserve">
          <source>Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), SQLite always used the &quot;Nearest Neighbor&quot; or &quot;NN&quot; heuristic when searching for the best query plan. The NN heuristic makes a single traversal of the graph, always choosing the lowest-cost arc as the next step. The NN heuristic works surprisingly well in most cases. And NN is fast, so that SQLite is able to quickly find good plans for even large 64-way joins. In contrast, other SQL database engines that do more extensive searching tend to bog down when the number of tables in a join goes above 10 or 15.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;バージョン3.8.0&lt;/a&gt;（2013-08-26）より前のSQLiteでは、最適なクエリプランを検索するときに、常に「最近傍」または「NN」ヒューリスティックを使用していました。NNヒューリスティックは、グラフを1回トラバースし、次のステップとして常に最低コストのアークを選択します。ほとんどの場合、NNヒューリスティックは驚くほどうまく機能します。また、NNは高速であるため、SQLiteは、大規模な64方向結合についても適切な計画をすばやく見つけることができます。対照的に、より広範な検索を行う他のSQLデータベースエンジンは、結合内のテーブルの数が10または15を超えると、パフォーマンスが低下する傾向があります。</target>
        </trans-unit>
        <trans-unit id="0cbead769cfd094dac2d1d702814135203e88038" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.20.0 (2017-08-01) all date/time functions were always considered non-deterministic. The ability for date/time functions to be deterministic sometimes and non-deterministic at other times, depending on their arguments, was added for the 3.20.0 release.</source>
          <target state="translated">SQLite 3.20.0 (2017-08-01)より前は、すべての date/time 関数は常に非決定論的とみなされていました。3.20.0 リリースでは、引数に応じて date/time 関数が決定論的になることもあれば、非決定論的になることもあるという機能が追加されました。</target>
        </trans-unit>
        <trans-unit id="6c7f8cc84bc5292827563b13ba75248881d97140" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.7.15 (2012-12-12), a subquery in the FROM clause would be either flattened into the outer query, or else the subquery would be run to completion before the outer query started, the result set from the subquery would be stored in a transient table, and then the transient table would be used in the outer query. Newer versions of SQLite have a third option, which is to implement the subquery using a co-routine.</source>
          <target state="translated">SQLite 3.7.15 (2012-12-12)より前のバージョンでは、FROM句の副問い合わせは外部の問い合わせに平坦化されるか、外部の問い合わせが開始される前に副問い合わせが完了するまで実行され、副問い合わせの結果セットが過渡的なテーブルに格納され、その後、過渡的なテーブルが外部の問い合わせで使用されていました。新しいバージョンのSQLiteには3つ目のオプションがあり、それはcoroutineを使用して副問い合わせを実装することです。</target>
        </trans-unit>
        <trans-unit id="a720aafd2afa8c2c385472fc2e648bd2ccdf321e" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the arguments to fts3_tokenzer() could be literal strings or BLOBs. They did not have to be &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. But that could lead to security problems in the event of an SQL injection. Hence, the legacy behavior is now disabled by default. But the old legacy behavior can be enabled, for backwards compatibility in applications that really need it, by calling &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0).</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;バージョン3.11.0&lt;/a&gt;（2016-02-15）より前のバージョンでは、fts3_tokenzer（）への引数はリテラル文字列またはBLOBでした。それらは&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメータである&lt;/a&gt;必要はありませんでした。しかし、SQLインジェクションが発生すると、セキュリティ上の問題が発生する可能性があります。そのため、従来の動作はデフォルトで無効になっています。ただし、&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;、1,0）を呼び出すことで、以前の動作を有効にして、本当に必要なアプリケーションの下位互換性を保つことができます。</target>
        </trans-unit>
        <trans-unit id="51d8edb11a84377ed9b294770763b3964473b7ee" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10), the virtual table mechanism assumes that each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; kept its own copy of the database schema. Hence, the virtual table mechanism could not be used in a database that has &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; enabled. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface would return an error if &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; is enabled. That restriction was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;バージョン3.6.17&lt;/a&gt;（2009-08-10）より前のバージョンでは、仮想テーブルメカニズムは、各&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が独自のデータベーススキーマのコピーを保持していると想定していました。したがって、仮想テーブルメカニズムは、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモードが&lt;/a&gt;有効になっているデータベースでは使用できませんでした。&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;場合のインタフェースはエラーを返します&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモードが&lt;/a&gt;有効になっています。この制限はSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;バージョン3.6.17&lt;/a&gt;から緩和されました。</target>
        </trans-unit>
        <trans-unit id="33d0fd70a8f55e9f98c0c7adf04301e981d0c322" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), recursive triggers were not supported. The behavior of SQLite was always as if this pragma was set to OFF. Support for recursive triggers was added in version 3.6.18 but was initially turned OFF by default, for compatibility. Recursive triggers may be turned on by default in future versions of SQLite.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;バージョン3.6.18&lt;/a&gt;（2009-09-11）より前は、再帰トリガーはサポートされていませんでした。 SQLiteの動作は、このプラグマがOFFに設定されているかのようでした。再帰トリガーのサポートはバージョン3.6.18で追加されましたが、互換性のためにデフォルトでデフォルトでオフにされました。 SQLiteの将来のバージョンでは、再帰トリガーがデフォルトでオンになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a28758e140ed243892fd7015e84c9739d352fdbe" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), triggers were not recursive and so this limit was meaningless. Beginning with version 3.6.18, recursive triggers were supported but had to be explicitly enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2009-09-11), recursive triggers are enabled by default but can be manually disabled using &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;. The SQLITE_MAX_TRIGGER_DEPTH is only meaningful if recursive triggers are enabled.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;バージョン3.6.18&lt;/a&gt;（2009-09-11）より前は、トリガーは再帰的ではなかったため、この制限は意味がありませんでした。バージョン3.6.18以降、再帰トリガーがサポートされていましたが、&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;ステートメントを使用して明示的に有効にする必要がありました。始まる&lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;バージョン3.7.0&lt;/a&gt;（2009-09-11）、再帰的なトリガはデフォルトで有効になっていますが、手動で使用して無効にすることができ&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;プラグマRECURSIVE_TRIGGERSを&lt;/a&gt;。SQLITE_MAX_TRIGGER_DEPTHは、再帰トリガーが有効になっている場合にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="534f30ad3bfba01b49cf3bf01218d9cf22140413" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.17.0, the session extension only worked with &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;, not &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. As of 3.17.0, both rowid and WITHOUT ROWID tables are supported.</source>
          <target state="translated">SQLiteバージョン3.17.0に先立ち、セッション延長はわずかで働いた&lt;a href=&quot;rowidtable&quot;&gt;ROWIDのテーブル&lt;/a&gt;ではない、&lt;a href=&quot;withoutrowid&quot;&gt;ROWIDのWITHOUT&lt;/a&gt;テーブル。3.17.0以降、ROWIDテーブルとWITHOUT ROWIDテーブルの両方がサポートされています。</target>
        </trans-unit>
        <trans-unit id="8ca3ddf5fd526ae6f9a1aaa722828cf40f2bf92a" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.3.14, a sector size of 512 bytes was assumed in all cases. There was a compile-time option to change this but the code had never been tested with a larger value. The 512 byte sector assumption seemed reasonable since until very recently all disk drives used a 512 byte sector internally. However, there has recently been a push to increase the sector size of disks to 4096 bytes. Also the sector size for flash memory is usually larger than 512 bytes. For these reasons, versions of SQLite beginning with 3.3.14 have a method in the OS interface layer that interrogates the underlying filesystem to find the true sector size. As currently implemented (version 3.5.0) this method still returns a hard-coded value of 512 bytes, since there is no standard way of discovering the true sector size on either Unix or Windows. But the method is available for embedded device manufacturers to tweak according to their own needs. And we have left open the possibility of filling in a more meaningful implementation on Unix and Windows in the future.</source>
          <target state="translated">SQLite バージョン 3.3.14 より前のバージョンでは、すべてのケースで 512 バイトのセクタサイズが想定されていました。これを変更するコンパイル時のオプションがありましたが、コードはこれより大きな値でテストされたことがありませんでした。最近まですべてのディスクドライブは内部的に 512 バイトのセクタを使用していたので、512 バイトのセクタを仮定するのは妥当なように思えました。しかし、最近ではディスクのセクタサイズを4096バイトに拡大する動きがあります。また、フラッシュメモリのセクタサイズは通常 512 バイトよりも大きくなっています。これらの理由から、3.3.14 以降のバージョンの SQLite では、OS インターフェイス層にメソッドが用意されており、ファイルシステムを照会して本当のセクタサイズを見つけることができるようになっています。現在実装されている(バージョン3.5.0)このメソッドは、UnixやWindowsには真のセクタサイズを発見する標準的な方法がないため、まだ512バイトのハードコードされた値を返します。しかし、この方法は組み込み機器メーカーが独自のニーズに応じて調整できるようになっています。そして、将来的にはUnixやWindows上でより意味のある実装を行う可能性を残しています。</target>
        </trans-unit>
        <trans-unit id="d9c2ee7b5aac6da179c8f578b8285aa5c54f4524" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">SQLiteバージョン3.7.10より前は、SQLiteで使用されるUTF-8エンコーディングと特定のWindowsインストールで使用されるファイル名エンコーディング間でファイル名を変換するときに、Windows OSインターフェースレイヤーがシステムのmalloc（）とfree（）を直接呼び出しました。メモリ割り当てエラーが検出されましたが、それらは&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;ではなく&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;またはSQLITE_IOERRとして報告され&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;ました&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91089ffc77affdb7ae59f739dbaf9014a293f340" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">SQLiteバージョン3.7.10より前は、SQLiteで使用されるUTF-8エンコーディングと特定のWindowsインストールで使用されるファイル名エンコーディング間でファイル名を変換するときに、Windows OSインターフェースレイヤーがシステムのmalloc（）とfree（）を直接呼び出しました。メモリ割り当てエラーが検出されましたが、それらは&lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_NOMEM&lt;/a&gt;ではなく&lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;またはSQLITE_IOERRとして報告され&lt;a href=&quot;../rescode#nomem&quot;&gt;ました&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f00bebae92fba462c0a2ff1a68401159dfc1bce" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.8.2 (2013-12-06), casting a REAL value greater than +9223372036854775807.0 into an integer resulted in the most negative integer, -9223372036854775808. This behavior was meant to emulate the behavior of x86/x64 hardware when doing the equivalent cast.</source>
          <target state="translated">SQLite バージョン 3.8.2 (2013-12-06)より前のバージョンでは、+9223372036854775807.0 より大きい REAL 値を整数にキャストすると、最も負の整数である -9223372036854775808 が得られました。この動作は、x86/x64ハードウェアで同等のキャストを行う際の動作をエミュレートすることを意図していました。</target>
        </trans-unit>
        <trans-unit id="a1634472b77cd282aba3425a6cf5a2a4d268772c" translate="yes" xml:space="preserve">
          <source>Prior to each check-in to the SQLite source tree, developers typically run a subset (called &quot;veryquick&quot;) of the Tcl tests consisting of about 248.5 thousand test cases. The veryquick tests include most tests other than the anomaly, fuzz, and soak tests. The idea behind the veryquick tests are that they are sufficient to catch most errors, but also run in only a few minutes instead of a few hours.</source>
          <target state="translated">SQLite のソースツリーにチェックインする前に、開発者は通常、約 248.5 千のテストケースからなる Tcl テストのサブセット (veryquick と呼ばれる)を実行します。veryquickテストには、アノマリー、ファズ、ソークテスト以外のほとんどのテストが含まれています。veryquickテストの背後にある考えは、ほとんどのエラーをキャッチするのに十分であると同時に、数時間ではなく数分で実行されるということです。</target>
        </trans-unit>
        <trans-unit id="ce5fd27df1123f4d155915fc1d5725287e09a7ea" translate="yes" xml:space="preserve">
          <source>Prior to making any changes to the database file, SQLite first creates a separate rollback journal file and writes into the rollback journal the original content of the database pages that are to be altered. The idea behind the rollback journal is that it contains all information needed to restore the database back to its original state.</source>
          <target state="translated">データベース ファイルに変更を加える前に、SQLite は最初に別のロールバック ジャーナル ファイルを作成し、変更するデータベース ページの元の内容をロールバック ジャーナルに書き込みます。ロールバック ジャーナルには、データベースを元の状態に戻すために必要なすべての情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="5e201518d0d186ad7cdf7483565006fe761fd040" translate="yes" xml:space="preserve">
          <source>Prior to making changes to the database file itself, we must obtain an exclusive lock on the database file. Obtaining an exclusive lock is really a two-step process. First SQLite obtains a &quot;pending&quot; lock. Then it escalates the pending lock to an exclusive lock.</source>
          <target state="translated">データベースファイル自体に変更を加える前に、データベースファイルの排他的なロックを取得しなければなりません。排他的なロックを取得するには、実際には2段階のプロセスがあります。最初にSQLiteは「保留中」のロックを取得します。次に、保留中のロックを排他的なロックにエスカレートします。</target>
        </trans-unit>
        <trans-unit id="3f85c53dbe23e0808bcb91d75d8ad07e4c7bc69c" translate="yes" xml:space="preserve">
          <source>Prior to version 3.26.0 (2018-12-01), FOREIGN KEY references to a table that is renamed were only edited if the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt;, or in other words if &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; were begin enforced. With &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;, FOREIGN KEY constraints would not be changed when the table that the foreign key referred to (the &quot;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent table&lt;/a&gt;&quot;) was renamed. Beginning with version 3.26.0, FOREIGN KEY constraints are always converted when a table is renamed, unless the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; setting is engaged. The following table summaries the difference:</source>
          <target state="translated">バージョン3.26.0（2018-12-01）より前は、名前が変更されたテーブルへのFOREIGN KEY参照は、&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ONの&lt;/a&gt;場合、つまり&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約&lt;/a&gt;が適用され始めた場合にのみ編集されました。&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;プラグマFOREIGN_KEYS = OFF&lt;/a&gt;外部キーが（「に言及するテーブルと、FOREIGN KEY制約を変更することはないだろう&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;、親テーブルが&lt;/a&gt;」）と改名されました。バージョン3.26.0以降、&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table = ON&lt;/a&gt;設定が有効になっていない限り、テーブルの名前が変更されると、FOREIGN KEY制約は常に変換されます。次の表は、違いをまとめたものです。</target>
        </trans-unit>
        <trans-unit id="5f15493198f102fc11171baf7abf0e0dbb2b1e4b" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; function would try to reclaim memory from all database connections in the same thread as the sqlite3_release_memory() call. Beginning with version 3.5.0, the sqlite3_release_memory() function will attempt to reclaim memory from all database connections in all threads.</source>
          <target state="translated">バージョン3.5.0より前は、&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;関数は、sqlite3_release_memory（）呼び出しと同じスレッド内のすべてのデータベース接続からメモリを再利用しようとしました。バージョン3.5.0以降、sqlite3_release_memory（）関数は、すべてのスレッドのすべてのデータベース接続からメモリを再利用しようとします。</target>
        </trans-unit>
        <trans-unit id="4167592bfe9ab2523a8fde6561d95f830a107410" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; set an upper bound on heap memory usage for all database connections within a single thread. Each thread could have its own heap limit. Beginning in version 3.5.0, there is a single heap limit for the entire process. This seems more restrictive (one limit as opposed to many) but in practice it is what most users want.</source>
          <target state="translated">バージョン3.5.0より前の&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（）&lt;/a&gt;は、単一スレッド内のすべてのデータベース接続のヒープメモリ使用量の上限を設定していました。各スレッドには独自のヒープ制限を設定できます。バージョン3.5.0以降では、プロセス全体に対して単一のヒープ制限があります。これはより制限的です（多くの制限ではなく1つの制限）が、実際にはほとんどのユーザーが望んでいます。</target>
        </trans-unit>
        <trans-unit id="fc681e809e94e340265ecee10f223e6915cced6a" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0, the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API would enable and disable the shared cache feature for all connections within a single thread - the same thread from which the sqlite3_enable_shared_cache() routine was called. Database connections that used the shared cache were restricted to running in the same thread in which they were opened. Beginning with version 3.5.0, the sqlite3_enable_shared_cache() applies to all database connections in all threads within the process. Now database connections running in separate threads can share a cache. And database connections that use shared cache can migrate from one thread to another.</source>
          <target state="translated">バージョン3.5.0より前は、&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt; APIは、単一のスレッド（sqlite3_enable_shared_cache（）ルーチンが呼び出されたのと同じスレッド）内のすべての接続の共有キャッシュ機能を有効または無効にしていました。共有キャッシュを使用したデータベース接続は、それらが開かれたのと同じスレッドでの実行に制限されていました。バージョン3.5.0以降、sqlite3_enable_shared_cache（）はプロセス内のすべてのスレッドのすべてのデータベース接続に適用されます。別のスレッドで実行されているデータベース接続がキャッシュを共有できるようになりました。また、共有キャッシュを使用するデータベース接続は、あるスレッドから別のスレッドに移行できます。</target>
        </trans-unit>
        <trans-unit id="d828632471991da7903c0c2be934633680ad57e8" translate="yes" xml:space="preserve">
          <source>Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.</source>
          <target state="translated">プロセスAはデータベースに書き込もうとします。しかし、プロセスAがデータベースから読み込んだ後にプロセスBがデータベースファイルを変更したため、プロセスAのデータベースコンテンツのビューは現在では時代遅れになっています。そのため、プロセスAはSQLITE_BUSY_SNAPSHOTエラーを取得します。</target>
        </trans-unit>
        <trans-unit id="6588c47b29127d1f98a87c238369e743b0e77d94" translate="yes" xml:space="preserve">
          <source>Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.</source>
          <target state="translated">プロセスAは、データベース上の読み取りトランザクションを開始し、1つ以上のSELECT文を実行します。プロセスAはトランザクションをオープンしたままにします。</target>
        </trans-unit>
        <trans-unit id="7e082f5417cd4ab89e9c56b231bce953e66b35a9" translate="yes" xml:space="preserve">
          <source>Process B updates the database, changing values previous read by process A.</source>
          <target state="translated">プロセスBは、プロセスAによって以前に読み込まれた値を変更してデータベースを更新します。</target>
        </trans-unit>
        <trans-unit id="ee0914d299e6e7430a22ed0faafffc12d302d567" translate="yes" xml:space="preserve">
          <source>Productize and officially support the group_concat() SQL function.</source>
          <target state="translated">SQL関数group_concat()をプロダクト化し、正式にサポートします。</target>
        </trans-unit>
        <trans-unit id="9257f2cbe973bd89967c512a0ab4ef3a71be8dcc" translate="yes" xml:space="preserve">
          <source>Profile guided optimization (PGO) is not helpful with SQLite. PGO results in binaries that are about 1% larger and about 0.33% slower.</source>
          <target state="translated">プロファイルガイド付き最適化 (PGO)は SQLite では役に立ちません。PGOの結果、バイナリは約1%大きくなり、約0.33%遅くなります。</target>
        </trans-unit>
        <trans-unit id="b46994e8cc3c2683acbfd969c84c88b83b02d9c0" translate="yes" xml:space="preserve">
          <source>Profiling indicates that for most systems and in most circumstances SQLite spends most of its time doing disk I/O. It follows then that anything we can do to reduce the amount of disk I/O will likely have a large positive impact on the performance of SQLite. This section describes some of the techniques used by SQLite to try to reduce the amount of disk I/O to a minimum while still preserving atomic commit.</source>
          <target state="translated">プロファイリングによると、ほとんどのシステムで、またほとんどの状況で、SQLiteはディスクI/Oの実行にほとんどの時間を費やしていることがわかります。したがって、ディスク I/O の量を減らすためにできることは何でも、SQLite のパフォーマンスに大きなプラスの影響を与えることになります。この節では、アトミックコミットを維持しつつディスクI/Oの量を最小限に抑えるためにSQLiteで使用されている技術のいくつかを説明します。</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="6bc5295aed74aa8af8bf9a74f722f2706e580d3c" translate="yes" xml:space="preserve">
          <source>Programmers are cautioned not to use the two exceptions described in the previous bullets. We emphasize that they exist only so that old and ill-formed SQL statements will run correctly. Future versions of SQLite might raise errors instead of accepting the malformed statements covered by the exceptions above.</source>
          <target state="translated">プログラマーは、前の箇条書きで説明した2つの例外を使用しないように注意してください。これらの例外は、古くて形の悪い SQL 文が正しく実行されるためだけに存在することを強調しています。将来のバージョンのSQLiteでは、上記の例外でカバーされている不正な形式の文を受け入れる代わりにエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="442f2f1b223aedc9d27d672e9d91f49a3b27fb5b" translate="yes" xml:space="preserve">
          <source>Programmers can force SQLite to use a particular loop nesting order for a join by using the CROSS JOIN operator instead of just JOIN, INNER JOIN, NATURAL JOIN, or a &quot;,&quot; join. Though CROSS JOINs are commutative in theory, SQLite chooses to never reorder the tables in a CROSS JOIN. Hence, the left table of a CROSS JOIN will always be in an outer loop relative to the right table.</source>
          <target state="translated">プログラマーは、JOIN、INNER JOIN、NATURAL JOIN、または&quot;,&quot;結合の代わりにCROSS JOIN演算子を使用することで、SQLiteが結合に特定のループの入れ子順序を使用するように強制することができます。理論的にはCROSS JOINは可換的ですが、SQLiteはCROSS JOINの中でテーブルの並び替えを行わないことを選択しています。そのため、CROSS JOINの左テーブルは常に右テーブルからの相対的な外部ループ内にあります。</target>
        </trans-unit>
        <trans-unit id="9ecd00ed19c9aa2f215c5b5e8453037ffd17fc89" translate="yes" xml:space="preserve">
          <source>Programming Interfaces</source>
          <target state="translated">プログラミングインタフェース</target>
        </trans-unit>
        <trans-unit id="1c8b4bfbf1e2ec54cc62ffa3332992d5ae9a4350" translate="yes" xml:space="preserve">
          <source>Programming Loadable Extensions</source>
          <target state="translated">ロード可能な拡張機能のプログラミング</target>
        </trans-unit>
        <trans-unit id="19ca1fa808a68639f1670f7213bf267471fdbd20" translate="yes" xml:space="preserve">
          <source>Programs contain a single instance of this opcode as the very first opcode.</source>
          <target state="translated">プログラムは、このオペコードの単一のインスタンスを最初のオペコードとして含みます。</target>
        </trans-unit>
        <trans-unit id="1b341d69d9619d4d85640d6150737c146812b7c0" translate="yes" xml:space="preserve">
          <source>Provide &lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA functions&lt;/a&gt; for &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;.</source>
          <target state="translated">提供&lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA機能を&lt;/a&gt;ため&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;、&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;、および&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;プラグマforeign_key_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a4632572329984193ba91894b49406924b5a89d" translate="yes" xml:space="preserve">
          <source>Provide a hint to cursor P1 that it only needs to return rows that satisfy the Expr in P4. TK_REGISTER terms in the P4 expression refer to values currently held in registers. TK_COLUMN terms in the P4 expression refer to columns in the b-tree to which cursor P1 is pointing.</source>
          <target state="translated">カーソルP1に、P4のExprを満たす行を返すだけでよいというヒントを与えます。P4式のTK_REGISTER項は、現在レジスタに保持されている値を参照します。P4式中のTK_COLUMN項は、カーソルP1が指し示すb-treeの列を参照します。</target>
        </trans-unit>
        <trans-unit id="054ee0d871e7b20122b3ff23a8374fbfb871d9ca" translate="yes" xml:space="preserve">
          <source>Provide an appropriate error message when the sqlite_master table contains a CREATE TABLE AS statement. Formerly this caused either an assertion fault or null pointer dereference. Problem found by OSSFuzz on the GDAL project. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</source>
          <target state="translated">sqlite_masterテーブルにCREATE TABLE ASステートメントが含まれている場合は、適切なエラーメッセージを提供します。以前は、これによりアサーションエラーまたはnullポインター逆参照が発生していました。OSSFuzzがGDALプロジェクトで発見した問題。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c2fd3e74c8200bf8ab45d458d069a0c702c0cd7" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; flag for &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and use it to limit &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; misuse by &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3（）に&lt;/a&gt;&lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt;フラグを提供し、それを使用して&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;、&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;、および&lt;a href=&quot;rtree&quot;&gt;R-Tree拡張&lt;/a&gt;による&lt;a href=&quot;malloc#lookaside&quot;&gt;メモリの&lt;/a&gt;誤用を制限します。</target>
        </trans-unit>
        <trans-unit id="0788f21345510b44c97d1a7ea9db2e84d27c5ed1" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function that returns the byte offset into the database file to the beginning of the record holding value X, when compiling with &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;.</source>
          <target state="translated">提供&lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset（X）&lt;/a&gt;でコンパイルするとき、記録保持値Xの先頭にデータベースファイルへのバイトオフセットを返すSQL関数&lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNCを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcb01e4e57cfae253305eca2f9007587c22f7fb2" translate="yes" xml:space="preserve">
          <source>Provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64（）&lt;/a&gt;および&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;インターフェースへのSQLアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="c78b408cda5c2c489b9c5ef105dac2382d881e16" translate="yes" xml:space="preserve">
          <source>Provides information about all files in a single check-in in the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. This virtual table is not part of the SQLite project but is included because it provides an example of how to use virtual tables and because it is used to help version control the SQLite sources.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossilバージョン管理システムの&lt;/a&gt; 1回のチェックインですべてのファイルに関する情報を提供します。この仮想テーブルはSQLiteプロジェクトの一部ではありませんが、仮想テーブルの使用方法の例を提供し、SQLiteソースのバージョン管理を支援するために使用されるため、含まれています。</target>
        </trans-unit>
        <trans-unit id="3126f48ce2a68ae1473f8364444a7e563e9968c3" translate="yes" xml:space="preserve">
          <source>Provides information about the purpose and use of each page in a database file. Used in the implementation of the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; utility program.</source>
          <target state="translated">データベースファイルの各ページの目的と使用に関する情報を提供します。&lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt;ユーティリティプログラムの実装で使用されます。</target>
        </trans-unit>
        <trans-unit id="bfec143c19b8a7da8ef2986bfdff976c6539b3dc" translate="yes" xml:space="preserve">
          <source>Pseudo-Random Number Generator</source>
          <target state="translated">擬似乱数発生器</target>
        </trans-unit>
        <trans-unit id="52a406d334528b19ea259feaeb009e7160aeac5f" translate="yes" xml:space="preserve">
          <source>Ptrmap pages must exist in any database file which has a non-zero largest root b-tree page value at offset 52 in the database header. If the largest root b-tree page value is zero, then the database must not contain ptrmap pages.</source>
          <target state="translated">Ptrmapページは、データベースヘッダのオフセット52にある最大のルートb-treeページ値が0ではないデータベースファイルに存在しなければならない。最大ルートb-treeページ値が0の場合、データベースにはptrmapページは含まれていないはずです。</target>
        </trans-unit>
        <trans-unit id="73f66c4bb296f02b5e558e94e1ebb8671640db19" translate="yes" xml:space="preserve">
          <source>Purging a Dirty Page</source>
          <target state="translated">汚いページをパージする</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="865ca2a73367e4e56f98cc35dd0cc7fe25f8e129" translate="yes" xml:space="preserve">
          <source>Push the next &quot;thing&quot; onto the stack and fall through OR jump to P2, depending on whether or not there is a next &quot;thing&quot; to push.</source>
          <target state="translated">次の「もの」があるかどうかによって、次の「もの」をスタックに押し付けて落下したり、P2にジャンプしたりします。</target>
        </trans-unit>
        <trans-unit id="0555ed5711adce7afcbd2d3235114460d585953d" translate="yes" xml:space="preserve">
          <source>Put all identifier names inside double-quotes. This is the official SQL way to escape identifier names.</source>
          <target state="translated">すべての識別子名をダブルクォートで囲みます。これは、識別子名をエスケープする公式のSQLの方法です。</target>
        </trans-unit>
        <trans-unit id="73eb67d0cb954e65c543496b0577de68b482cb5a" translate="yes" xml:space="preserve">
          <source>Put identifier names inside [...]. This is not standard SQL, but it is what SQL Server does and so lots of programmers use this technique.</source>
          <target state="translated">識別子名を[....]の中に入れます。これは標準SQLではありませんが、SQL Serverが行うことなので、多くのプログラマがこのテクニックを使用しています。</target>
        </trans-unit>
        <trans-unit id="e8b5818c3fdaa2a399fa24163289f33ef9912b79" translate="yes" xml:space="preserve">
          <source>Put the macro &quot;&lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt;&quot; on a line by itself right after the &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; line.</source>
          <target state="translated">「 &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; 」行の直後の行にマクロ「 &lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt; 」を単独で配置します。</target>
        </trans-unit>
        <trans-unit id="36dc5ec2a56fbc19dcd1aa69b72dba8e93123b26" translate="yes" xml:space="preserve">
          <source>Put your hope in God.</source>
          <target state="translated">神に希望を託してください。</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="4ae694911c3fee4e1df954bf5e225e075d582d11" translate="yes" xml:space="preserve">
          <source>QUERY</source>
          <target state="translated">QUERY</target>
        </trans-unit>
        <trans-unit id="ebdfba68a60db859050a346ba6621b2d1c232869" translate="yes" xml:space="preserve">
          <source>Quality Management</source>
          <target state="translated">品質管理</target>
        </trans-unit>
        <trans-unit id="3dd6362242ec4d8e950fc308f0c9c5371ac3e523" translate="yes" xml:space="preserve">
          <source>Quality assurance in SQLite is done using &lt;a href=&quot;testing#coverage&quot;&gt;full-coverage testing&lt;/a&gt;, not by compiler warnings or other static code analysis tools. In other words, we verify that SQLite actually gets the correct answer, not that it merely satisfies stylistic constraints. Most of the SQLite code base is devoted purely to testing. The SQLite test suite runs tens of thousands of separate test cases and many of those test cases are parameterized so that hundreds of millions of tests involving billions of SQL statements are run and evaluated for correctness prior to every release. The developers use code coverage tools to verify that all paths through the code are tested. Whenever a bug is found in SQLite, new test cases are written to exhibit the bug so that the bug cannot recur undetected in the future.</source>
          <target state="translated">SQLiteの品質保証は、コンパイラ警告やその他の静的コード分析ツールではなく、&lt;a href=&quot;testing#coverage&quot;&gt;フルカバレッジテスト&lt;/a&gt;を使用して行われます。言い換えれば、SQLiteが文体上の制約を満たすだけではなく、実際に正しい答えが得られることを確認します。 SQLiteコードベースのほとんどは、純粋にテスト専用です。 SQLiteテストスイートは数万の個別のテストケースを実行し、それらのテストケースの多くはパラメーター化されているため、リリースごとに数十億のSQLステートメントを含む数億のテストが実行され、正確性が評価されます。開発者はコードカバレッジツールを使用して、コードのすべてのパスがテストされていることを確認します。 SQLiteでバグが見つかった場合はいつでも、新しいテストケースが作成され、バグが検出されないため、将来バグが検出されないまま再発することはありません。</target>
        </trans-unit>
        <trans-unit id="96ecb898d9fd59826f9555c415e65eadb6f74ead" translate="yes" xml:space="preserve">
          <source>Quality management documents tend to expand into binders full of incomprehensible jargon that nobody reads. This document strives to break that pattern by being concise and useful.</source>
          <target state="translated">品質管理文書は、誰も読まないような分かりにくい専門用語で埋め尽くされたバインダーの中に膨れ上がる傾向があります。この文書は、簡潔で有用なものであることによって、そのパターンを打破することを目指しています。</target>
        </trans-unit>
        <trans-unit id="61b1d96663c5eb21b3f12fad273403f6ef48c73d" translate="yes" xml:space="preserve">
          <source>Queries (and also DELETE and UPDATE statements) in which the WHERE clause contains a bare geopoly_overlap() or geopoly_within() function make use of the underlying R*Tree data structures for a fast lookup that only has to examine a subset of the rows in the table. The number of rows examines depends, of course, on the size of the $query_polygon. Large $query_polygons will normally need to look at more rows than small ones.</source>
          <target state="translated">WHERE句に裸のgeopoly_overlap()またはgeopoly_within()関数が含まれているクエリ(およびDELETEやUPDATE文も)は、テーブル内の行のサブセットを調べるだけの高速な検索のために、基礎となるR*Treeデータ構造を利用しています。検査する行の数は、もちろん$query_polygonのサイズに依存します。大きな $query_polygon は通常、小さなものよりも多くの行を調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="5877d4b4dd805510713fc8b0f7324db5905fcfac" translate="yes" xml:space="preserve">
          <source>Queries Against A Graph</source>
          <target state="translated">グラフに対するクエリ</target>
        </trans-unit>
        <trans-unit id="83b570c5458fbacf6723ef9304ccc7570ee10af8" translate="yes" xml:space="preserve">
          <source>Queries against the rowid of a geopoly table are also very quick, even for tables with a vast number of rows. However, none of the auxiliary data columns are indexes, and so queries against the auxiliary data columns will involve a full table scan.</source>
          <target state="translated">ジオポリテーブルのrowidに対するクエリは、膨大な行数を持つテーブルに対しても、非常に迅速に実行されます。しかし、補助データ列はどれもインデックスではないので、補助データ列に対するクエリはテーブル全体をスキャンしなければなりません。</target>
        </trans-unit>
        <trans-unit id="e655d8b919b6556f1f0ce40faccc63fe0ee22962" translate="yes" xml:space="preserve">
          <source>Queries of the form: &quot;SELECT max(x), y FROM table&quot; returns the value of y on the same row that contains the maximum x value.</source>
          <target state="translated">形式のクエリ。&quot;SELECT max(x),y FROM table &quot;は、最大のxの値を含む同じ行のyの値を返します。</target>
        </trans-unit>
        <trans-unit id="e4ff6a5e7ac06c745f7d49496f70f4a140defd99" translate="yes" xml:space="preserve">
          <source>Queries that contain a single MIN() or MAX() aggregate function whose argument is the left-most column of an index might be satisfied by doing a single index lookup rather than by scanning the entire table. Examples:</source>
          <target state="translated">インデックスの左端のカラムを引数とする単一のMIN()またはMAX()集約関数を含むクエリは、テーブル全体をスキャンするのではなく、単一のインデックス検索を行うことで満たすことができるかもしれません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="29a6a39bdba4fd39660625514af2f1cb40b3edcf" translate="yes" xml:space="preserve">
          <source>Queries that contain subqueries must sometime evaluate the subqueries separately and store the results in a temporary table, then use the content of the temporary table to evaluate the outer query. We call this &quot;materializing&quot; the subquery. The query optimizer in SQLite attempts to avoid materializing, but sometimes it is not easily avoidable. The temporary tables created by materialization are each stored in their own separate temporary file, which is automatically deleted at the conclusion of the query. The size of these temporary tables depends on the amount of data in the materialization of the subquery, of course.</source>
          <target state="translated">副問い合わせを含む問い合わせは、いつかは副問い合わせを別々に評価して一時的なテーブルに結果を格納し、一時的なテーブルの内容を使って外側の問い合わせを評価しなければなりません。これを副問い合わせの「マテリアライズ」と呼びます。SQLiteのクエリオプティマイザはマテリアライズを回避しようとしますが、簡単には回避できないこともあります。マテリアライズによって作成されたテンポラリテーブルは、それぞれ別個のテンポラリファイルに格納され、クエリの終了時に自動的に削除されます。これらの一時テーブルのサイズは、もちろん副問い合わせのマテリアライズのデータ量に依存します。</target>
        </trans-unit>
        <trans-unit id="cfbd9457ec43caaedb5b89c759265cf2be427fe5" translate="yes" xml:space="preserve">
          <source>Queries that use ORDER BY and LIMIT now try to avoid computing rows that cannot possibly come in under the LIMIT. This can greatly improve performance of ORDER BY LIMIT queries, especially when the LIMIT is small relative to the number of unrestricted output rows.</source>
          <target state="translated">ORDER BYとLIMITを使用するクエリは、LIMITの下に来る可能性のある行の計算を避けようとします。これにより、ORDER BY LIMITクエリのパフォーマンスを大幅に向上させることができ、特にLIMITが無制限の出力行数に比べて小さい場合に有効です。</target>
        </trans-unit>
        <trans-unit id="e885c97cd0eb73037d91afe0e25f71733d813af5" translate="yes" xml:space="preserve">
          <source>Query Language Understood by SQLite</source>
          <target state="translated">SQLiteで理解できるクエリ言語</target>
        </trans-unit>
        <trans-unit id="3d4f16fd1d91b47c556b84948dabe05573437a3d" translate="yes" xml:space="preserve">
          <source>Query Planner</source>
          <target state="translated">クエリプランナー</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">クエリプランニング</target>
        </trans-unit>
        <trans-unit id="625af40606e435d60c7571eb3eaed21802aa70ee" translate="yes" xml:space="preserve">
          <source>Query Progress Callbacks</source>
          <target state="translated">クエリ プログレス コールバック</target>
        </trans-unit>
        <trans-unit id="4af542248ab5d4cfc6f1e9df7245e3bb184ea082" translate="yes" xml:space="preserve">
          <source>Query The EXPLAIN Setting For A Prepared Statement</source>
          <target state="translated">準備されたステートメントのEXPLAIN設定を問い合わせる</target>
        </trans-unit>
        <trans-unit id="27930b82a7c3d467781ad3b52e0b1d9894281ffa" translate="yes" xml:space="preserve">
          <source>Query flattener</source>
          <target state="translated">クエリフラットナー</target>
        </trans-unit>
        <trans-unit id="e60fdc9ba7fb5d86546748b364cd1dfbde0107e1" translate="yes" xml:space="preserve">
          <source>Query flattening is an important optimization when views are used as each use of a view is translated into a subquery.</source>
          <target state="translated">クエリのフラット化は、ビューの各使用がサブクエリに変換されるため、ビューを使用する際の重要な最適化です。</target>
        </trans-unit>
        <trans-unit id="bfee3391ed2fb89e3470d4d2a93c4c710274a3ef" translate="yes" xml:space="preserve">
          <source>Query for the details of phrase match iIdx within the current row. Phrase matches are numbered starting from zero, so the iIdx argument should be greater than or equal to zero and smaller than the value output by xInstCount().</source>
          <target state="translated">現在の行内のフレーズマッチ iIdx の詳細を取得します。フレーズマッチの番号はゼロから始まるので、iIdx 引数はゼロ以上で xInstCount()が出力する値よりも小さくなければなりません。</target>
        </trans-unit>
        <trans-unit id="3a7dd1ac6b04f70fb3ec3bd5dfe2b333de122f27" translate="yes" xml:space="preserve">
          <source>Query optimizer enhancements:</source>
          <target state="translated">クエリオプティマイザの機能強化。</target>
        </trans-unit>
        <trans-unit id="a2c73363a91970f8d7d0f3ba2033b2b1141c7659" translate="yes" xml:space="preserve">
          <source>Query optimizer improvements:</source>
          <target state="translated">クエリオプティマイザの改善。</target>
        </trans-unit>
        <trans-unit id="d0fbdef4345ce05f423c29e77346a76ae1183a9c" translate="yes" xml:space="preserve">
          <source>Query or change the count-changes flag. Normally, when the count-changes flag is not set, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements return no data. When count-changes is set, each of these commands returns a single row of data consisting of one integer value - the number of rows inserted, modified or deleted by the command. The returned change count does not include any insertions, modifications or deletions performed by triggers, any changes made automatically by &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;, or updates caused by an &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt;.</source>
          <target state="translated">count-changesフラグを照会または変更します。通常、カウント変更フラグが設定されていない場合、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントはデータを返しません。 count-changesが設定されている場合、これらの各コマンドは、1つの整数値（コマンドによって挿入、変更、または削除された行の数）で構成されるデータの単一行を返します。返された変更カウントには、トリガーによって実行された挿入、変更、削除、&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外部キーアクション&lt;/a&gt;によって自動的に行われた変更、&lt;a href=&quot;lang_upsert&quot;&gt;アップサート&lt;/a&gt;によって発生した更新は含まれません。</target>
        </trans-unit>
        <trans-unit id="9a7df9605f2eec87d8f2db2efd84251b953fcfd6" translate="yes" xml:space="preserve">
          <source>Query or change the empty-result-callbacks flag.</source>
          <target state="translated">empty-result-callbacks フラグをクエリまたは変更します。</target>
        </trans-unit>
        <trans-unit id="4386c302fe03b8bf430568c307ba9f2bfa451ec8" translate="yes" xml:space="preserve">
          <source>Query or change the full_column_names flag. This flag together with the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; flag determine the way SQLite assigns names to result columns of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Result columns are named by applying the following rules in order:</source>
          <target state="translated">full_column_namesフラグを照会または変更します。このフラグと&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt;フラグは、SQLiteが&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの結果の列に名前を割り当てる方法を決定します。結果列には、次のルールを順番に適用することによって名前が付けられます。</target>
        </trans-unit>
        <trans-unit id="6ea33a7feb73dab172e527ce6afcb51892e3e546" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag for &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations. If this flag is set, then the F_FULLFSYNC syncing method is used during checkpoint operations on systems that support F_FULLFSYNC. The default value of the checkpoint_fullfsync flag is off. Only Mac OS-X supports F_FULLFSYNC.</source>
          <target state="translated">&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;操作のfullfsyncフラグを照会または変更します。このフラグが設定されている場合、F_FULLFSYNCをサポートするシステムでのチェックポイント操作中に、F_FULLFSYNC同期メソッドが使用されます。checkpoint_fullfsyncフラグのデフォルト値はオフです。Mac OS-XのみがF_FULLFSYNCをサポートします。</target>
        </trans-unit>
        <trans-unit id="563bc8c4477c1c2b886876e5894cd59e0001b35e" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag. This flag determines whether or not the F_FULLFSYNC syncing method is used on systems that support it. The default value of the fullfsync flag is off. Only Mac OS X supports F_FULLFSYNC.</source>
          <target state="translated">fullfsync フラグを取得または変更します。このフラグは、F_FULLFSYNC 同期方式をサポートするシステムで使用するかどうかを決定します。fullfsync フラグのデフォルト値は off です。Mac OS X のみが F_FULLFSYNC をサポートしています。</target>
        </trans-unit>
        <trans-unit id="77df4b91f1e34f39b185a6ee7e54e82d58dfa005" translate="yes" xml:space="preserve">
          <source>Query or change the maximum number of bytes that are set aside for memory-mapped I/O on a single database. The first form (without an argument) queries the current limit. The second form (with a numeric argument) sets the limit for the specified database, or for all databases if the optional database name is omitted. In the second form, if the database name is omitted, the limit that is set becomes the default limit for all databases that are added to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements.</source>
          <target state="translated">単一のデータベースでメモリマップI / Oのために確保されている最大バイト数を照会または変更します。最初の形式（引数なし）は、現在の制限を照会します。 2番目の形式（数値引数付き）は、指定されたデータベース、またはオプションのデータベース名が省略されている場合はすべてのデータベースに制限を設定します。 2番目の形式では、データベース名を省略した場合、設定された制限が、後続の&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントによって&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続に&lt;/a&gt;追加されるすべてのデータベースのデフォルトの制限になります。</target>
        </trans-unit>
        <trans-unit id="5b3761ba731b4ca68bda2cd1e8fe9ffa86d5d2f0" translate="yes" xml:space="preserve">
          <source>Query or change the secure-delete setting. When secure_delete is on, SQLite overwrites deleted content with zeros. The default setting for secure_delete is determined by the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option and is normally off. The off setting for secure_delete improves performance by reducing the number of CPU cycles and the amount of disk I/O. Applications that wish to avoid leaving forensic traces after content is deleted or updated should enable the secure_delete pragma prior to performing the delete or update, or else run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; after the delete or update.</source>
          <target state="translated">セキュア削除設定を照会または変更します。 secure_deleteがオンの場合、SQLiteは削除されたコンテンツをゼロで上書きします。 secure_deleteのデフォルト設定は、&lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt;コンパイル時オプションによって決定され、通常はオフです。 secure_deleteをオフに設定すると、CPUサイクル数とディスクI / Oの量が減少するため、パフォーマンスが向上します。コンテンツが削除または更新された後にフォレンシックトレースを残したくないアプリケーションは、削除または更新を実行する前にsecure_deleteプラグマを有効にするか、削除または更新後に&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="de56ca3e30c1c074a1fd98f6d3fdce5680f699b3" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;&lt;b&gt;temp_store&lt;/b&gt;&quot; parameter. When temp_store is DEFAULT (0), the compile-time C preprocessor macro &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; is used to determine where temporary tables and indices are stored. When temp_store is MEMORY (2) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are kept in as if they were pure &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; memory. When temp_store is FILE (1) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are stored in a file. The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt; pragma can be used to specify the directory containing temporary files when &lt;b&gt;FILE&lt;/b&gt; is specified. When the temp_store setting is changed, all existing temporary tables, indices, triggers, and views are immediately deleted.</source>
          <target state="translated">「&lt;b&gt;temp_store&lt;/b&gt;」パラメーターの設定を照会または変更します。 temp_storeがDEFAULT（0）の場合、コンパイル時のCプリプロセッサマクロ&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;を使用して、一時テーブルとインデックスが格納される場所を決定します。 temp_storeがMEMORY（2）の場合、&lt;a href=&quot;inmemorydb#temp_db&quot;&gt;一時テーブル&lt;/a&gt;とインデックスは、純粋な&lt;a href=&quot;inmemorydb&quot;&gt;インメモリデータベース&lt;/a&gt;メモリであるかのように保持されます。 temp_storeがFILE（1）の場合、&lt;a href=&quot;inmemorydb#temp_db&quot;&gt;一時テーブル&lt;/a&gt;とインデックスはファイルに保存されます。&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt;プラグマは時に一時ファイルを含むディレクトリを指定するために使用することができ&lt;b&gt;FILEが&lt;/b&gt;指定されています。 temp_store設定が変更されると、すべての既存の一時テーブル、インデックス、トリガー、およびビューがすぐに削除されます。</target>
        </trans-unit>
        <trans-unit id="0eb005d9ab4e0804f12c87dee002073b411d274d" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;synchronous&quot; flag. The first (query) form will return the synchronous setting as an integer. The second form changes the synchronous setting. The meanings of the various synchronous settings are as follows:</source>
          <target state="translated">synchronous&quot; フラグの設定を問い合わせたり変更したりします。最初の (クエリ)形式は同期設定を整数で返します。2 番目のフォームは同期設定を変更します。様々な同期設定の意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8dcfcd54b0505cd09f50244da9bbd756766eef81" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;busy timeout&lt;/a&gt;. This pragma is an alternative to the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; C-language interface which is made available as a pragma for use with language bindings that do not provide direct access to &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;ビジータイムアウトの&lt;/a&gt;設定を照会または変更します。このプラグマは、に代替され&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;への直接アクセスを提供していない言語バインディングと共に使用するためのプラグマとして利用可能にされるC言語インターフェース&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeoutを（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a6f0cf05490ce574881ff5675cbd192d91cf992" translate="yes" xml:space="preserve">
          <source>Query or change the short-column-names flag. This flag affects the way SQLite names columns of data returned by &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. See the &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; pragma for full details.</source>
          <target state="translated">short-column-namesフラグを照会または変更します。このフラグは、SQLiteが&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントによって返されるデータの列に名前を付ける方法に影響します。詳細については、&lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt;プラグマを参照してください。</target>
        </trans-unit>
        <trans-unit id="c472dc3fc7ff36d8acee51946b1687ac08bd59fe" translate="yes" xml:space="preserve">
          <source>Query or change the suggested maximum number of database disk pages that SQLite will hold in memory at once per open database file. Whether or not this suggestion is honored is at the discretion of the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;Application Defined Page Cache&lt;/a&gt;. The default page cache that is built into SQLite honors the request, however alternative application-defined page cache implementations may choose to interpret the suggested cache size in different ways or to ignore it all together. The default suggested cache size is -2000, which means the cache size is limited to 2048000 bytes of memory. The default suggested cache size can be altered using the &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; compile-time options. The TEMP database has a default suggested cache size of 0 pages.</source>
          <target state="translated">SQLiteが開いているデータベースファイルごとに一度にメモリに保持するデータベースディスクページの推奨最大数を照会または変更します。この提案を尊重するかどうかは、&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;アプリケーション定義のページキャッシュの&lt;/a&gt;裁量に任されています。 SQLiteに組み込まれているデフォルトのページキャッシュは要求を受け入れますが、代替のアプリケーション定義のページキャッシュ実装は、提案されたキャッシュサイズをさまざまな方法で解釈するか、すべて一緒に無視するかを選択できます。デフォルトの推奨キャッシュサイズは-2000です。つまり、キャッシュサイズはメモリの2048000バイトに制限されます。デフォルトの推奨キャッシュサイズは、&lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt;コンパイル時オプションを使用して変更できます。 TEMPデータベースのデフォルトの推奨キャッシュサイズは0ページです。</target>
        </trans-unit>
        <trans-unit id="38317b0c0d1df51bd83790ce312ba13da0c5ed05" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable, which windows operating-system interface backends use to determine where to store database files specified using a relative pathname.</source>
          <target state="translated">&lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;グローバル変数の値を照会または変更します。これは、Windowsオペレーティングシステムインターフェイスのバックエンドが、相対パス名を使用して指定されたデータベースファイルを保存する場所を決定するために使用します。</target>
        </trans-unit>
        <trans-unit id="f61590ed5a58a97ecca18f3fbb40bf0ae63fb037" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,...) limit for the current database connection. This limit sets an upper bound on the number of auxiliary threads that a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is allowed to launch to assist with a query. The default limit is 0 unless it is changed using the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option. When the limit is zero, that means no auxiliary threads will be launched.</source>
          <target state="translated">現在のデータベース接続の&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;、...）制限の値を照会または変更します。この制限は、&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;がクエリを支援するために起動できる補助スレッドの数の上限を設定します。&lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt;コンパイル時オプションを使用して変更しない限り、デフォルトの制限は0です。制限がゼロの場合、それは補助スレッドが起動されないことを意味します。</target>
        </trans-unit>
        <trans-unit id="4ad35fae3f5b98f4ef0cd9485074046877d96539" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable, which many operating-system interface backends use to determine where to store &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices.</source>
          <target state="translated">&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;グローバル変数の値をクエリまたは変更します。これは、多くのオペレーティングシステムインターフェイスバックエンドが、&lt;a href=&quot;inmemorydb#temp_db&quot;&gt;一時テーブル&lt;/a&gt;とインデックスを格納する場所を決定するために使用します。</target>
        </trans-unit>
        <trans-unit id="5866fac6602f3e40c19df259ea318d2b63caf2bd" translate="yes" xml:space="preserve">
          <source>Query or set the auto-vacuum status in the database.</source>
          <target state="translated">データベースの自動バキュームの状態を照会または設定します。</target>
        </trans-unit>
        <trans-unit id="3cc5d0ecc46bacf93e04d7b7978224221ecdf262" translate="yes" xml:space="preserve">
          <source>Query or set the maximum number of pages in the database file. Both forms of the pragma return the maximum page count. The second form attempts to modify the maximum page count. The maximum page count cannot be reduced below the current database size.</source>
          <target state="translated">データベースファイルの最大ページ数を問い合わせるか設定します。どちらの形式のプラグマも最大ページ数を返します。2 番目の形式は、最大ページ数の変更を試みます。最大ページ数を現在のデータベースサイズ以下に減らすことはできません。</target>
        </trans-unit>
        <trans-unit id="3b4e54fcf1e120591a5a6535bff6e2b69b86d7df" translate="yes" xml:space="preserve">
          <source>Query or set the page size of the database. The page size must be a power of two between 512 and 65536 inclusive.</source>
          <target state="translated">データベースのページサイズを問い合わせるか設定します。ページサイズは 512 から 65536 の間の 2 の累乗でなければなりません。</target>
        </trans-unit>
        <trans-unit id="627a1950bccb0926f06969a3db2d136c3cabdca5" translate="yes" xml:space="preserve">
          <source>Query planner checklist</source>
          <target state="translated">クエリプランナーのチェックリスト</target>
        </trans-unit>
        <trans-unit id="e93c39912e396551e04ed9b46c1ea823e2d8b3bb" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - automatic transient indices are created when doing so reduces the estimated query time.</source>
          <target state="translated">クエリプランナの機能強化-クエリプランナの機能強化により、見積クエリ時間が短縮された場合に、自動的にトランジェントインデックスが作成されるようになりました。</target>
        </trans-unit>
        <trans-unit id="15e2bd2467aae946e711f6cc5ade007f83eb3c87" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - the ORDER BY becomes a no-op if the query also contains a GROUP BY clause that forces the correct output order.</source>
          <target state="translated">クエリプランナーの強化-クエリに正しい出力順序を強制するGROUP BY句が含まれている場合、ORDER BYは無効になります。</target>
        </trans-unit>
        <trans-unit id="26786d5880615e168b7819292d8f2bd689ef42b3" translate="yes" xml:space="preserve">
          <source>Query planner enhancement: Use the transitive property of constraints to move constraints into the outer loops of a join whenever possible, thereby reducing the amount of work that needs to occur in inner loops.</source>
          <target state="translated">クエリプランナの強化。可能な限り制約を結合の外側ループに移動させるために、制約の遷移特性を使用して、内側ループで発生する作業量を削減します。</target>
        </trans-unit>
        <trans-unit id="736e85cef8966360d93b45933c07771905d6a0b9" translate="yes" xml:space="preserve">
          <source>Query planner enhancements.</source>
          <target state="translated">クエリプランナーの機能強化。</target>
        </trans-unit>
        <trans-unit id="c7e16cd25b99db12dc36d4eb42e08d056acec1b1" translate="yes" xml:space="preserve">
          <source>Query planner enhancements:</source>
          <target state="translated">クエリプランナーの機能強化。</target>
        </trans-unit>
        <trans-unit id="b2b452d242e61d8f7480bffaae127bf001921fa3" translate="yes" xml:space="preserve">
          <source>Query planner stability guarantee</source>
          <target state="translated">クエリプランナーの安定性保証</target>
        </trans-unit>
        <trans-unit id="ca5891ff28346fccc5150a605b02b68689910ebb" translate="yes" xml:space="preserve">
          <source>Query planners are what make SQL database engines so amazingly useful and powerful. (This is true of all SQL database engines, not just SQLite.) The query planner frees the programmer from the chore of selecting a particular query plan, and thereby allows the programmer to focus more mental energy on higher-level application issues and on providing more value to the end user. For simple queries where the choice of query plan is obvious, this is convenient but not hugely important. But as applications and schemas and queries grow more complex, a clever query planner can greatly speed and simplify the work of application development. There is amazing power in being about to tell the database engine what content is desired, and then let the database engine figure out the best way to retrieve that content.</source>
          <target state="translated">クエリプランナはSQLデータベースエンジンを驚くほど便利で強力なものにしています(これはSQLiteに限らず、すべてのSQLデータベースエンジンに言えることです)。(これはSQLiteに限らず、すべてのSQLデータベースエンジンに言えることです。)クエリプランナを使用することで、プログラマは特定のクエリプランを選択するという煩雑な作業から解放され、それによってプログラマはより高いレベルのアプリケーションの問題に精神的なエネルギーを集中させ、エンドユーザにより多くの価値を提供することができるようになります。クエリプランの選択が明白な単純なクエリの場合、これは便利ですが、それほど重要ではありません。しかし、アプリケーションやスキーマ、クエリが複雑になってくると、巧妙なクエリプランナーは、アプリケーション開発の作業を大幅にスピードアップし、単純化することができます。どのようなコンテンツが必要なのかをデータベースエンジンに伝え、そのコンテンツを取得するための最良の方法をデータベースエンジンに考えさせることには、驚くべき力があります。</target>
        </trans-unit>
        <trans-unit id="9ee854629ae78a2199bdb56da8e286e6006b5d8d" translate="yes" xml:space="preserve">
          <source>Query results are returned as a list of column values. If a query requests 2 columns and there are 3 rows matching the query, then the returned list will contain 6 elements. For example:</source>
          <target state="translated">クエリの結果は、カラムの値のリストとして返されます。クエリが 2 カラムを要求し、クエリにマッチする行が 3 行ある場合、返されるリストには 6 つの要素が含まれます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="50cb7820ab431080267a59361b01e9af99b0f2f7" translate="yes" xml:space="preserve">
          <source>Query, set, or clear READ UNCOMMITTED isolation. The default isolation level for SQLite is SERIALIZABLE. Any process or thread can select READ UNCOMMITTED isolation, but SERIALIZABLE will still be used except between connections that share a common page and schema cache. Cache sharing is enabled using the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API. Cache sharing is disabled by default.</source>
          <target state="translated">READ UNCOMMITTED分離を照会、設定、またはクリアします。SQLiteのデフォルトの分離レベルはSERIALIZABLEです。どのプロセスまたはスレッドもREAD UNCOMMITTED分離を選択できますが、共通のページとスキーマキャッシュを共有する接続間を除いて、SERIALIZABLEは引き続き使用されます。キャッシュ共有は、&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt; API を使用して有効にします。キャッシュ共有はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="0366bdd9a4ae5e944fbf6092ddc8900d9aeaaed5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; capability.</source>
          <target state="translated">&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス&lt;/a&gt;機能を照会、設定、またはクリアします。</target>
        </trans-unit>
        <trans-unit id="14ccb18dde2fc34367c93b804727ccf1143765e5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約の適用を&lt;/a&gt;照会、設定、またはクリアします。</target>
        </trans-unit>
        <trans-unit id="160bfb7a8121ce10fe672d852b6ba0dcf536c5e1" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the recursive trigger capability.</source>
          <target state="translated">再帰的トリガ機能をクエリ、設定、またはクリアします。</target>
        </trans-unit>
        <trans-unit id="bf0ed56a136cbe5ffad095931c71813d09f0273f" translate="yes" xml:space="preserve">
          <source>Questions and confusion quickly arose on the &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about the purpose behind these new interfaces, why they were introduced, and what problem they solve. This essay attempts to answer those questions and clear up the confusion.</source>
          <target state="translated">これらの新しいインターフェイスの背後にある目的、それらが導入された理由、およびそれらが解決する問題についての質問と混乱が&lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;メーリングリストで&lt;/a&gt;すぐに発生しました。このエッセイは、それらの質問に答えて混乱を解消しようと試みます。</target>
        </trans-unit>
        <trans-unit id="6fb0e0d11a03f78b5ecb2f7f8b42ef10b6e101e0" translate="yes" xml:space="preserve">
          <source>Questions like these (and countless others) can be answered without having to uncompress or extract any content.</source>
          <target state="translated">このような質問には(他にも数え切れないほどの)、コンテンツを解凍したり抽出したりしなくても答えることができます。</target>
        </trans-unit>
        <trans-unit id="09a7d1d2da3256534f8a2a26b3d747dbae8b2a14" translate="yes" xml:space="preserve">
          <source>Quirks, Caveats, and Gotchas In SQLite</source>
          <target state="translated">SQLite の奇妙な点、洞窟、ガッチャ</target>
        </trans-unit>
        <trans-unit id="9432058147a91a2c4afeff95adc17f4930b4c6b9" translate="yes" xml:space="preserve">
          <source>R (cost: 3.56)</source>
          <target state="translated">R(コスト:3.56</target>
        </trans-unit>
        <trans-unit id="37abd4d23bc413fb5db77feee86f46ad0b861e2d" translate="yes" xml:space="preserve">
          <source>R*Tree Module</source>
          <target state="translated">R*ツリーモジュール</target>
        </trans-unit>
        <trans-unit id="43ea99300f03323c6239855a57c58f91be6c0d63" translate="yes" xml:space="preserve">
          <source>R-N1 (cost: 7.03)</source>
          <target state="translated">R-N1(コスト:7.03</target>
        </trans-unit>
        <trans-unit id="00f923142bbc27eb285a9f64b857d908b86719d8" translate="yes" xml:space="preserve">
          <source>R-N1-C (cost: 13.43)</source>
          <target state="translated">R-N1-C(コスト:13.43</target>
        </trans-unit>
        <trans-unit id="f743ed80cd4af3e3dd6aaa0242ee69bf26b480c0" translate="yes" xml:space="preserve">
          <source>R-N1-N2 (cost: 12.55)</source>
          <target state="translated">R-N1-N2(コスト:12.55</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
