<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="c687d1b70c080536289366ba8155bc643fc72076" translate="yes" xml:space="preserve">
          <source>Exclusive intervals and infinity</source>
          <target state="translated">排他的な間隔と無限大</target>
        </trans-unit>
        <trans-unit id="8e788d736a6e3a42271b3b6edc6a324f07e11667" translate="yes" xml:space="preserve">
          <source>Executed scripts are guaranteed to be in the script cache of a given execution of a Redis instance forever. This means that if an &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is performed against a Redis instance all the subsequent &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; calls will succeed.</source>
          <target state="translated">実行されたスクリプトは、Redisインスタンスの特定の実行のスクリプトキャッシュに永久に存在することが保証されています。つまり、Redisインスタンスに対して&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;が実行されると、後続のすべての&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;呼び出しが成功します。</target>
        </trans-unit>
        <trans-unit id="446763d77e17832a47ad829663f2f4ba29ce76f7" translate="yes" xml:space="preserve">
          <source>Executes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">以前にキューに入れられたすべてのコマンドを&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;トランザクション&lt;/a&gt;で実行し、接続状態を通常に戻します。</target>
        </trans-unit>
        <trans-unit id="d80b1a46f6734fb75c0119610c9901aef0c08607" translate="yes" xml:space="preserve">
          <source>Executing a Lua Script with Redis 2.6 or newer.</source>
          <target state="translated">Redis 2.6以降でLuaスクリプトを実行します。</target>
        </trans-unit>
        <trans-unit id="e1a9d983dc0912bcd36f098a1b8c4b6851a2ccbc" translate="yes" xml:space="preserve">
          <source>Expire accuracy</source>
          <target state="translated">期限切れ精度</target>
        </trans-unit>
        <trans-unit id="5bbbfc0dcb3f1ea6203152c364bf711f30071354" translate="yes" xml:space="preserve">
          <source>Expires and persistence</source>
          <target state="translated">期限切れと執着</target>
        </trans-unit>
        <trans-unit id="ceae3e065a822da58b9dd577a4a2215264628a2c" translate="yes" xml:space="preserve">
          <source>FLUSHALL</source>
          <target state="translated">FLUSHALL</target>
        </trans-unit>
        <trans-unit id="a1dc7fedbb3161c8d2db024cd3ee46e2af26f812" translate="yes" xml:space="preserve">
          <source>FLUSHALL  [ASYNC]   Remove all keys from all databases</source>
          <target state="translated">FLUSHALL [ASYNC]すべてのデータベースからすべてのキーを削除します。</target>
        </trans-unit>
        <trans-unit id="10bb3c2c2d36018ba538d533264f2171634a8d95" translate="yes" xml:space="preserve">
          <source>FLUSHDB</source>
          <target state="translated">FLUSHDB</target>
        </trans-unit>
        <trans-unit id="b40b961b1c26ac58fbd9ac2f12f0c446fb2897d9" translate="yes" xml:space="preserve">
          <source>FLUSHDB  [ASYNC]   Remove all keys from the current database</source>
          <target state="translated">FLUSHDB [ASYNC]現在のデータベースからすべてのキーを削除します。</target>
        </trans-unit>
        <trans-unit id="a5f0b2c20a29e7587597abea3e79fa609ca01e4c" translate="yes" xml:space="preserve">
          <source>FORCE option: manual failover when the master is down</source>
          <target state="translated">FORCEオプション:マスターがダウンしているときに手動でフェイルオーバーを行う</target>
        </trans-unit>
        <trans-unit id="4a0878bdd16e36ba72b474afe51ae9c582fef6d5" translate="yes" xml:space="preserve">
          <source>Fetching a single entry from a stream, providing the ID of the entry to fetch two times: as start and end of the query interval.</source>
          <target state="translated">ストリームから単一のエントリを取得します。取得するエントリのIDを、クエリ間隔の開始と終了の2回に分けて指定します。</target>
        </trans-unit>
        <trans-unit id="d11485369737f36370f75a3ff43b46d72effc624" translate="yes" xml:space="preserve">
          <source>Fetching data from a stream via a consumer group, and not acknowledging such data, has the effect of creating &lt;em&gt;pending entries&lt;/em&gt;. This is well explained in the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command, and even better in our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command will immediately remove the pending entry from the Pending Entry List (PEL) since once a message is successfully processed, there is no longer need for the consumer group to track it and to remember the current owner of the message.</source>
          <target state="translated">コンシューマグループを介してストリームからデータをフェッチし、そのようなデータを確認しないと、&lt;em&gt;保留中のエントリ&lt;/em&gt;が作成さ&lt;em&gt;れます&lt;/em&gt;。これは&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;コマンドで十分に説明されており、&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streamsの紹介で&lt;/a&gt;さらに詳しく説明されています。&lt;a href=&quot;xack&quot;&gt;XACKの&lt;/a&gt;メッセージが正常に処理されると、それを追跡すると、メッセージの現在の所有者を覚えておくことが、消費者のグループのために、もはや必要がないため、コマンドはすぐに保留エントリーリスト（PEL）から保留中のエントリを削除します。</target>
        </trans-unit>
        <trans-unit id="13b9c9d38a4b96f103ca63910ffc56743e00fd12" translate="yes" xml:space="preserve">
          <source>Fetching single items</source>
          <target state="translated">単一アイテムの取得</target>
        </trans-unit>
        <trans-unit id="8330be22b4e169fe5141dfbcacb82dc81724e13f" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommnad:</source>
          <target state="translated">最後に、 &lt;code&gt;HELP&lt;/code&gt; サブコマンドを使用して、ユーザーが正確な構文を思い出せない場合に、コマンドからヘルプを取得することができます。</target>
        </trans-unit>
        <trans-unit id="5388f4a7abea666722d4311743c9d3e1d5bfc3b1" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get the list of every consumer in a specific consumer group:</source>
          <target state="translated">最後に、特定の消費者グループのすべての消費者のリストを取得することができます。</target>
        </trans-unit>
        <trans-unit id="7cbe1b741345fc3839fb4d58149e9dd7af6c272a" translate="yes" xml:space="preserve">
          <source>Finally it is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">最後に、特定の所有者を持つメッセージを見るために、コマンドに追加の引数を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="58b2c6378bac42febc100a9e0341d2094c29e52e" translate="yes" xml:space="preserve">
          <source>Finally it possible to set the next message to deliver using the &lt;code&gt;SETID&lt;/code&gt; subcommand. Normally the next ID is set when the consumer is created, as the last argument of &lt;code&gt;XGROUP CREATE&lt;/code&gt;. However using this form the next ID can be modified later without deleting and creating the consumer group again. For instance if you want the consumers in a consumer group to re-process all the messages in a stream, you may want to set its next ID to 0:</source>
          <target state="translated">最後に、 &lt;code&gt;SETID&lt;/code&gt; サブコマンドを使用して、配信する次のメッセージを設定することができます。通常、次のIDは、コンシューマーの作成時に &lt;code&gt;XGROUP CREATE&lt;/code&gt; の最後の引数として設定されます。ただし、このフォームを使用すると、コンシューマーグループを削除して再度作成しなくても、後で次のIDを変更できます。たとえば、コンシューマグループのコンシューマにストリーム内のすべてのメッセージを再処理させたい場合は、次のIDを0に設定できます。</target>
        </trans-unit>
        <trans-unit id="8081b937f79256e42e7fd856b20cf39a90419c3e" translate="yes" xml:space="preserve">
          <source>Finally to get some help if you don't remember the syntax, use the HELP subcommand:</source>
          <target state="translated">最後に、構文を覚えていない場合にヘルプを得るには、HELPサブコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="fc63c9b0ba92886f08fc9cdd2dca430983266b7e" translate="yes" xml:space="preserve">
          <source>First Key in Argument List</source>
          <target state="translated">引数リストの最初のキー</target>
        </trans-unit>
        <trans-unit id="a8e315abf463cfb1c344b54fca5c387403cc9c5a" translate="yes" xml:space="preserve">
          <source>First replica of master for slot range</source>
          <target state="translated">スロットレンジ用マスターの初レプリカ</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="4e0b6894626b05a7f879581f17814069cc8b9e6d" translate="yes" xml:space="preserve">
          <source>Flush the Append Only File if AOF is enabled.</source>
          <target state="translated">AOFが有効な場合は、Append Only Fileをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="3b424754326ab3315277697bc94804652181fadd" translate="yes" xml:space="preserve">
          <source>Flush the Lua scripts cache.</source>
          <target state="translated">Lua スクリプトのキャッシュをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="f6bb844e2e06d69091cb567be5df64888a2d1098" translate="yes" xml:space="preserve">
          <source>Flushes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;トランザクション&lt;/a&gt;で以前にキューに入れられたすべてのコマンドをフラッシュし、接続状態を通常に戻します。</target>
        </trans-unit>
        <trans-unit id="8c64c01f5213c6c086d3f83c900e781d98a8b4d5" translate="yes" xml:space="preserve">
          <source>Flushes all the previously watched keys for a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;トランザクションの&lt;/a&gt;以前に監視されたすべてのキーをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="e859a22c051906372e6ed21806faadd4fdf27b1c" translate="yes" xml:space="preserve">
          <source>For Redis 2.6 what happens is that the command performing multiple pushes is executed, and &lt;em&gt;only after&lt;/em&gt; the execution of the command the blocked clients are served. Consider this sequence of commands.</source>
          <target state="translated">Redis 2.6では、複数のプッシュを実行するコマンドが実行され、コマンドの実行&lt;em&gt;後&lt;/em&gt;に&lt;em&gt;のみ&lt;/em&gt;、ブロックされたクライアントにサービスが提供されます。この一連のコマンドを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="c9543ba9d8e4550fc68513216cde163b99c314dc" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;WEIGHTS&lt;/code&gt; and &lt;code&gt;AGGREGATE&lt;/code&gt; options, see &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;WEIGHTS&lt;/code&gt; および &lt;code&gt;AGGREGATE&lt;/code&gt; オプションの説明については、&lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTOREを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9618151d729f751e6074523159514ecdfdb57ef1" translate="yes" xml:space="preserve">
          <source>For an introduction to HyperLogLog data structure check the &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; command page.</source>
          <target state="translated">HyperLogLogデータ構造の概要については、&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;コマンドページを確認してください。</target>
        </trans-unit>
        <trans-unit id="6fcc6360d01cc6597619a76bd12e34dfa8c068d5" translate="yes" xml:space="preserve">
          <source>For an introduction to sorted sets, see the data types page on &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted sets&lt;/a&gt;.</source>
          <target state="translated">ソートされたセットの概要については、上のデータ・タイプ・ページを参照してください&lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;ソートされたセット&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e36005d4ed916277f75df55af354619d0ef5d5b" translate="yes" xml:space="preserve">
          <source>For each command type, the following line is added:</source>
          <target state="translated">コマンドの種類ごとに、以下の行を追加します。</target>
        </trans-unit>
        <trans-unit id="e6d8b4b7b9b4f1b118134e1b85eed9b0b1555262" translate="yes" xml:space="preserve">
          <source>For each consumer group listed the command also shows the number of consumers known in that group and the pending messages (delivered but not yet acknowledged) in that group.</source>
          <target state="translated">リストされた各コンシューマ・グループに対して、コマンドはそのグループ内の既知のコンシューマの数と、そのグループ内の保留中のメッセージ(配信されたがまだ確認されていない)も表示します。</target>
        </trans-unit>
        <trans-unit id="2f01796f139a1dd83db65e8858f0ea9b62d77fdf" translate="yes" xml:space="preserve">
          <source>For each database, the following line is added:</source>
          <target state="translated">各データベースに対して、以下の行を追加します。</target>
        </trans-unit>
        <trans-unit id="0553e67e4dc3e5df5405dbaf017a41c48cd92358" translate="yes" xml:space="preserve">
          <source>For each replica, the following line is added:</source>
          <target state="translated">各レプリカについて、以下の行を追加します。</target>
        </trans-unit>
        <trans-unit id="4121db15148ef3ce1e89f4557d512e7c05a4cd89" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;field&lt;/code&gt; that does not exist in the hash, a &lt;code&gt;nil&lt;/code&gt; value is returned. Because non-existing keys are treated as empty hashes, running &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; against a non-existing &lt;code&gt;key&lt;/code&gt; will return a list of &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">ハッシュに存在しないすべての &lt;code&gt;field&lt;/code&gt; について、 &lt;code&gt;nil&lt;/code&gt; 値が返されます。非既存のキーが動作して、空のハッシュとして扱われるので&lt;a href=&quot;hmget&quot;&gt;HMGETを&lt;/a&gt;非既存のに対して &lt;code&gt;key&lt;/code&gt; のリストを返します &lt;code&gt;nil&lt;/code&gt; の値を。</target>
        </trans-unit>
        <trans-unit id="910c18521d782016253b4584c3c1718149e1c25d" translate="yes" xml:space="preserve">
          <source>For example a common problem when implementing Markov chains and other algorithms is to select an element at random from a set, but different elements may have different weights that change how likely it is they are picked.</source>
          <target state="translated">例えば、マルコフ連鎖や他のアルゴリズムを実装する際によくある問題は、集合からランダムに要素を選択することですが、要素ごとに異なる重みがあり、それによって選択される可能性が変化します。</target>
        </trans-unit>
        <trans-unit id="00e8032c1c0863c866e402146d15139ddaca7eea" translate="yes" xml:space="preserve">
          <source>For example in order to take the count of all the unique search queries performed in a day, a program needs to call &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; every time a query is processed. The estimated number of unique queries can be retrieved with &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; at any time.</source>
          <target state="translated">たとえば、1日に実行されたすべての一意の検索クエリの数を取得するには、クエリが処理されるたびにプログラムが&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;を呼び出す必要があります。一意のクエリの推定数は、&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;を使用していつでも取得できます。</target>
        </trans-unit>
        <trans-unit id="862ca7fa622c308433f665edc841f44e39e5d232" translate="yes" xml:space="preserve">
          <source>For example the following command assigns slots 1 2 3 to the node receiving the command:</source>
          <target state="translated">例えば、以下のコマンドは、コマンドを受信したノードにスロット1、2、3を割り当てます。</target>
        </trans-unit>
        <trans-unit id="b525686b0a28b28e11781b09afa87dd48c9db63b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 8 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">例えば、以下のコマンドは、ビットオフセット 100 で 8 ビット符号付き整数をインクリメントし、ビットオフセット 0 で 4 ビット符号なし整数の値を取得します。</target>
        </trans-unit>
        <trans-unit id="a97e5209e5c4a8fe8fdeedf84b0123aa8fa78b8b" translate="yes" xml:space="preserve">
          <source>For example the following command will trim the stream to exactly the latest 1000 items:</source>
          <target state="translated">例えば、以下のコマンドは、ストリームを最新の1000項目に正確にトリミングします。</target>
        </trans-unit>
        <trans-unit id="bb5422e2190f7f64ad2cf5faf5279a8730064c02" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; will remove the last two occurrences of &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in the list stored at &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; は、listに格納されている &lt;code&gt;list&lt;/code&gt; 内の &lt;code&gt;&quot;hello&quot;&lt;/code&gt; の最後の2つの出現を削除します。</target>
        </trans-unit>
        <trans-unit id="b555dc3155500027017fa2a4b40d9e13b0289813" translate="yes" xml:space="preserve">
          <source>For example, if I have two streams &lt;code&gt;mystream&lt;/code&gt; and &lt;code&gt;writers&lt;/code&gt;, and I want to read data from both the streams starting from the first element they contain, I could call &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; like in the following example.</source>
          <target state="translated">たとえば、 &lt;code&gt;mystream&lt;/code&gt; と &lt;code&gt;writers&lt;/code&gt; の 2つのストリームがあり、両方のストリームに含まれる最初の要素からデータを読み取る場合、次の例のように&lt;a href=&quot;xread&quot;&gt;XREADを&lt;/a&gt;呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="d36a4d27e7c4e26652f2b3ff43e697bb99cdbe49" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; will modify the list stored at &lt;code&gt;foobar&lt;/code&gt; so that only the first three elements of the list will remain.</source>
          <target state="translated">例： &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; は、 &lt;code&gt;foobar&lt;/code&gt; 保存されているリストを変更して、リストの最初の3つの要素のみが残るようにします。</target>
        </trans-unit>
        <trans-unit id="aac3daaf191be281b6ccb464e390234af5058fcd" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">例：リスト &lt;code&gt;a,b,c&lt;/code&gt; 保持する &lt;code&gt;source&lt;/code&gt; と、リスト &lt;code&gt;x,y,z&lt;/code&gt; 保持する &lt;code&gt;destination&lt;/code&gt; を検討してください。&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;を実行 &lt;code&gt;a,b&lt;/code&gt; &lt;code&gt;source&lt;/code&gt; はa、bを保持し、 &lt;code&gt;destination&lt;/code&gt; &lt;code&gt;c,x,y,z&lt;/code&gt; 保持します。</target>
        </trans-unit>
        <trans-unit id="b9a6b3077ebbc22869bdfb44c11c89f9170d1471" translate="yes" xml:space="preserve">
          <source>For expires to work well, the computer time must be taken stable. If you move an RDB file from two computers with a big desync in their clocks, funny things may happen (like all the keys loaded to be expired at loading time).</source>
          <target state="translated">期限切れがうまく機能するためには、コンピュータの時間が安定していなければならない。2台のコンピュータの時計が大きく同期している状態でRDBファイルを移動すると、おかしなことが起こるかもしれません (ロードされたすべてのキーがロード時に期限切れになっているような)。</target>
        </trans-unit>
        <trans-unit id="f28bf0b4c581b256fa3b954009c5dc47ca8cc986" translate="yes" xml:space="preserve">
          <source>For further information about Redis streams please check our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams document&lt;/a&gt;.</source>
          <target state="translated">Redisストリームの詳細については、Redisストリームの&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;紹介ドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="9419f194b12efba96ec9e9a8a47640ef77051d15" translate="yes" xml:space="preserve">
          <source>For instance an application with a persistent connection to Redis can be sure that if a script was sent once it is still in memory, so EVALSHA can be used against those scripts in a pipeline without the chance of an error being generated due to an unknown script (we'll see this problem in detail later).</source>
          <target state="translated">例えば、Redisへの持続的な接続を持つアプリケーションでは、スクリプトが一度送信されたものがまだメモリに残っていることを確認することができるので、未知のスクリプトが原因でエラーが発生することなく、パイプライン内のスクリプトに対してEVALSHAを使用することができます(この問題については後で詳しく説明します)。</target>
        </trans-unit>
        <trans-unit id="dc915bb7cfa9bbec54b9f20262e4f69d0c2936e5" translate="yes" xml:space="preserve">
          <source>For instance in the above example, the last items that we received for the stream &lt;code&gt;mystream&lt;/code&gt; has ID &lt;code&gt;1526999352406-0&lt;/code&gt;, while for the stream &lt;code&gt;writers&lt;/code&gt; has the ID &lt;code&gt;1526985685298-0&lt;/code&gt;.</source>
          <target state="translated">上記の例では例えば、我々は、ストリームのために受信した最後の項目 &lt;code&gt;mystream&lt;/code&gt; は ID持っ &lt;code&gt;1526999352406-0&lt;/code&gt; 、ストリームのためながら、 &lt;code&gt;writers&lt;/code&gt; ID持っ &lt;code&gt;1526985685298-0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abfec42c58b79c70de1796787342d5de058e9f11" translate="yes" xml:space="preserve">
          <source>For instance what in &lt;code&gt;redis.conf&lt;/code&gt; looks like:</source>
          <target state="translated">たとえば、 &lt;code&gt;redis.conf&lt;/code&gt; の内容は次のようになります。</target>
        </trans-unit>
        <trans-unit id="310775bb715bff8a1231237bf82d220b152e2252" translate="yes" xml:space="preserve">
          <source>For instance when Redis is used in order to implement a queue, producers and consumers of messages may want to set the name of the connection according to their role.</source>
          <target state="translated">例えば、キューを実装するためにRedisを使用する場合、メッセージの生成者と消費者は、それぞれの役割に応じて接続の名前を設定したいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="4d1d2a650d31219d2da12b4e4c6aaa52db811850" translate="yes" xml:space="preserve">
          <source>For most commands the first key is position 1. Position 0 is always the command name itself.</source>
          <target state="translated">ほとんどのコマンドでは、最初のキーの位置は 1 です。位置 0 は常にコマンド名そのものです。</target>
        </trans-unit>
        <trans-unit id="f3b735d69f1d53bb920c323089af35c7960cd5bc" translate="yes" xml:space="preserve">
          <source>For nested data types, the optional &lt;code&gt;SAMPLES&lt;/code&gt; option can be provided, where &lt;code&gt;count&lt;/code&gt; is the number of sampled nested values. By default, this option is set to &lt;code&gt;5&lt;/code&gt;. To sample the all of the nested values, use &lt;code&gt;SAMPLES 0&lt;/code&gt;.</source>
          <target state="translated">ネストされたデータ型の場合、オプションの &lt;code&gt;SAMPLES&lt;/code&gt; オプションを指定できます。ここで、 &lt;code&gt;count&lt;/code&gt; は、サンプリングされたネストされた値の数です。デフォルトでは、このオプションは &lt;code&gt;5&lt;/code&gt; に設定されています。ネストされたすべての値をサンプリングするには、 &lt;code&gt;SAMPLES 0&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="29cc98c67031f5feb4c8c0734d6bcf119180ebd0" translate="yes" xml:space="preserve">
          <source>For real-time metrics and statistics involving large inputs a good approach is to use a replica (with read-only option disabled) where the bit-wise operations are performed to avoid blocking the master instance.</source>
          <target state="translated">大規模な入力を含むリアルタイムのメトリクスや統計情報については、マスター・インスタンスをブロックしないようにビット単位の演算を行うレプリカ(読み取り専用オプションを無効にした状態)を使用するのが良いアプローチです。</target>
        </trans-unit>
        <trans-unit id="86c11a7ed67c320eacf7f860ba9da8b316757034" translate="yes" xml:space="preserve">
          <source>For security concerns, certain special administration commands like &lt;code&gt;CONFIG&lt;/code&gt; are not logged into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; output.</source>
          <target state="translated">セキュリティ上の理由から、 &lt;code&gt;CONFIG&lt;/code&gt; などの特定の特別な管理コマンドは&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;出力にログインしません。</target>
        </trans-unit>
        <trans-unit id="1d4a1b4aeeb486fd399846319b2294f91ddedb8b" translate="yes" xml:space="preserve">
          <source>For this reason, Redis 3.2 introduces a new command that only works when script effects replication is enabled, and is able to control the scripting replication engine. The command is called &lt;code&gt;redis.set_repl()&lt;/code&gt; and fails raising an error if called when script effects replication is disabled.</source>
          <target state="translated">このため、Redis 3.2には、スクリプトエフェクトレプリケーションが有効になっている場合にのみ機能し、スクリプトレプリケーションエンジンを制御できる新しいコマンドが導入されています。コマンドは &lt;code&gt;redis.set_repl()&lt;/code&gt; と呼ばれ、スクリプトがレプリケーションを無効にしているときに呼び出された場合、エラーが発生して失敗します。</target>
        </trans-unit>
        <trans-unit id="51865baeeba9dd27720c605912d3014b8edbbb78" translate="yes" xml:space="preserve">
          <source>Forces a node to save the &lt;code&gt;nodes.conf&lt;/code&gt; configuration on disk. Before to return the command calls &lt;code&gt;fsync(2)&lt;/code&gt; in order to make sure the configuration is flushed on the computer disk.</source>
          <target state="translated">ノードに &lt;code&gt;nodes.conf&lt;/code&gt; 設定を強制的にディスクに保存させます。コマンドを返す前に、設定がコンピュータディスクにフラッシュされていることを確認するために、 &lt;code&gt;fsync(2)&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="620cbfd5798a03238a582c36dc6180b1d68a8181" translate="yes" xml:space="preserve">
          <source>Fortunately, it's possible to avoid this issue using the following algorithm. Let's see how C4, our sane client, uses the good algorithm:</source>
          <target state="translated">幸いなことに、次のアルゴリズムを使えば、この問題を回避することができます。正気のクライアントであるC4がどのように良いアルゴリズムを使っているか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e02d5afefc425c600d8eecdd85f79d3604e46010" translate="yes" xml:space="preserve">
          <source>From the point of view of the syntax, the commands are almost the same, however &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;&lt;em&gt;requires&lt;/em&gt; a special and mandatory option:</source>
          <target state="translated">構文の観点からは、コマンドはほとんど同じですが、&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUPに&lt;/a&gt;&lt;em&gt;は&lt;/em&gt;特別で必須のオプション&lt;em&gt;が必要&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="86f3ae974780a50a7664a8c324379a24cfdab877" translate="yes" xml:space="preserve">
          <source>Fun fact: Reddit's 2017 April fools' project &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r/place&lt;/a&gt; was &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;built using the Redis BITFIELD command&lt;/a&gt; in order to take an in-memory representation of the collaborative canvas.</source>
          <target state="translated">&lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;面白い&lt;/a&gt;事実：Redditの2017エイプリルフールのプロジェクト&lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r / place&lt;/a&gt;は、コラボレーションキャンバスのメモリ内表現を取得するために、Redis BITFIELDコマンドを使用して構築されました。</target>
        </trans-unit>
        <trans-unit id="29ad85263278e1f788abee93dcd93c6b5f400940" translate="yes" xml:space="preserve">
          <source>GEOADD</source>
          <target state="translated">GEOADD</target>
        </trans-unit>
        <trans-unit id="fe36dd170b2d009a6fb9b3209da995c6be0a8014" translate="yes" xml:space="preserve">
          <source>GEOADD  key longitude latitude member [longitude latitude member ...]   Add one or more geospatial items in the geospatial index represented using a sorted set</source>
          <target state="translated">GEOADD キー経度緯度メンバー [経度緯度メンバー ...]ソートされた集合を用いて表現された地理空間インデックスに、1つ以上の地理空間項目を追加する。</target>
        </trans-unit>
        <trans-unit id="9aee98cec79ef9607b17d14a98e26344f2559e24" translate="yes" xml:space="preserve">
          <source>GEODIST</source>
          <target state="translated">GEODIST</target>
        </trans-unit>
        <trans-unit id="0a8e4fd28c6ceedcd2cf757094650298262be7f7" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [unit]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">GEODIST key member1 member2 [unit]地理空間インデックスの2つのメンバ間の距離を返します。</target>
        </trans-unit>
        <trans-unit id="d944f228d17ba584e232ef6b37a2330565210913" translate="yes" xml:space="preserve">
          <source>GEOHASH</source>
          <target state="translated">GEOHASH</target>
        </trans-unit>
        <trans-unit id="15d5ff901e592f20465c4a81d62cdf535660ac71" translate="yes" xml:space="preserve">
          <source>GEOHASH  key member [member ...]   Returns members of a geospatial index as standard geohash strings</source>
          <target state="translated">GEOHASH key member [member ....]地理空間インデックスのメンバーを標準のジオハッシュ文字列として返します。</target>
        </trans-unit>
        <trans-unit id="567f488d82e3265931365c2760b37b40e268471e" translate="yes" xml:space="preserve">
          <source>GEOPOS</source>
          <target state="translated">GEOPOS</target>
        </trans-unit>
        <trans-unit id="681795a057130a9988e5c024a1915dc60c2ecb58" translate="yes" xml:space="preserve">
          <source>GEOPOS  key member [member ...]   Returns longitude and latitude of members of a geospatial index</source>
          <target state="translated">GEOPOS key member [member ....]地理空間インデックスのメンバーの経度と緯度を返す。</target>
        </trans-unit>
        <trans-unit id="f883ad1ea5b9628a7c035af52696e8e216f48428" translate="yes" xml:space="preserve">
          <source>GEORADIUS</source>
          <target state="translated">GEORADIUS</target>
        </trans-unit>
        <trans-unit id="78a8e700f33e02c64280e94efe97493736549c5c" translate="yes" xml:space="preserve">
          <source>GEORADIUS  key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point</source>
          <target state="translated">GEORADIUS キー経度緯度半径 m|km|ft|mi [WITHCOORD][WITHDIST][WITHHASH][COUNT count][ASC|DESC][STORE key][STOREDIST key]地理空間インデックスを表すソートされたセットを取得し、点からの最大距離に一致するメンバーを取得します。</target>
        </trans-unit>
        <trans-unit id="ae4c6b87ec31f7b6af274155550a43bc379afb42" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER</source>
          <target state="translated">GEORADIUSBYMEMBER</target>
        </trans-unit>
        <trans-unit id="cf98dab16a680969ed5a7c59dd91c064dd5ffd22" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER  key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member</source>
          <target state="translated">GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD][WITHDIST][WITHHASH][COUNT count][ASC|DESC][STORE key][STOREDIST key]地理空間インデックスを表すソートされた集合に問い合わせて、メンバーからの最大距離に一致するメンバーを取得します。</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="7d7f9a21ff2fe871d6f138989249c29532bb7fdc" translate="yes" xml:space="preserve">
          <source>GET  key   Get the value of a key</source>
          <target state="translated">GET key キーの値を取得します。</target>
        </trans-unit>
        <trans-unit id="ef9841e66f1ceb2a8ca3c4b61209bfb1ccb07d46" translate="yes" xml:space="preserve">
          <source>GETBIT</source>
          <target state="translated">GETBIT</target>
        </trans-unit>
        <trans-unit id="c67560b598b48f8d8597f643fcac2a09acec11dd" translate="yes" xml:space="preserve">
          <source>GETBIT  key offset   Returns the bit value at offset in the string value stored at key</source>
          <target state="translated">GETBIT key offset key に格納されている文字列値の offset のビット値を返します。</target>
        </trans-unit>
        <trans-unit id="171dc01acd21b14b16885f344959333f303f7868" translate="yes" xml:space="preserve">
          <source>GETRANGE</source>
          <target state="translated">GETRANGE</target>
        </trans-unit>
        <trans-unit id="120d6e3c8bea25d9ffe941d0b9d148464db210c6" translate="yes" xml:space="preserve">
          <source>GETRANGE  key start end   Get a substring of the string stored at a key</source>
          <target state="translated">GETRANGE key start end キーに格納されている文字列の部分文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="6a4472582074006f8a0d04a695a91bfb64d3f211" translate="yes" xml:space="preserve">
          <source>GETSET</source>
          <target state="translated">GETSET</target>
        </trans-unit>
        <trans-unit id="ea14ecdc443c7b2197bfb8f599d84d9e3ddc91a9" translate="yes" xml:space="preserve">
          <source>GETSET  key value   Set the string value of a key and return its old value</source>
          <target state="translated">GETSET キーの値 キーの文字列値を設定し、その古い値を返します。</target>
        </trans-unit>
        <trans-unit id="0f33bfb55b7c38358e7fef810b5a8c3a19e508c9" translate="yes" xml:space="preserve">
          <source>Generate a new &lt;code&gt;configEpoch&lt;/code&gt; unilaterally, just taking the current greatest epoch available and incrementing it if its local configuration epoch is not already the greatest.</source>
          <target state="translated">新しい &lt;code&gt;configEpoch&lt;/code&gt; を一方的に生成し、現在利用可能な最大のエポックを取得し、ローカル構成エポックがまだ最大でない場合は、それを増分します。</target>
        </trans-unit>
        <trans-unit id="8770e1d00765da154add27070eb66b76abb639e9" translate="yes" xml:space="preserve">
          <source>Geo</source>
          <target state="translated">Geo</target>
        </trans-unit>
        <trans-unit id="00754e7ec718eca2346352874423afcfcd99de6c" translate="yes" xml:space="preserve">
          <source>Geohash string properties</source>
          <target state="translated">ジオハッシュ文字列プロパティ</target>
        </trans-unit>
        <trans-unit id="fcba9fe6c6b3ee7a7679d8a80f01c177efafb91f" translate="yes" xml:space="preserve">
          <source>Get keys from the source node with &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; command and move them into the destination node using the &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt;コマンドを使用してソースノードからキーを取得し、&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;コマンドを使用してそれらを宛先ノードに移動します。</target>
        </trans-unit>
        <trans-unit id="09aec2d48c2bf33e9f4de1efe0b69e4c3361c2f6" translate="yes" xml:space="preserve">
          <source>Get the value of &lt;code&gt;key&lt;/code&gt;. If the key does not exist the special value &lt;code&gt;nil&lt;/code&gt; is returned. An error is returned if the value stored at &lt;code&gt;key&lt;/code&gt; is not a string, because &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; only handles string values.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; の値を取得します。キーが存在しない場合は、特別な値 &lt;code&gt;nil&lt;/code&gt; が返されます。&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;は文字列値のみを処理するため、 &lt;code&gt;key&lt;/code&gt; に格納されている値が文字列でない場合はエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="4f07c68cfde1cce4484071399ec3dcac10ef3226" translate="yes" xml:space="preserve">
          <source>Given a list of SHA1 digests as arguments this command returns an array of 1 or 0, where 1 means the specific SHA1 is recognized as a script already present in the scripting cache, while 0 means that a script with this SHA1 was never seen before (or at least never seen after the latest SCRIPT FLUSH command).</source>
          <target state="translated">引数として SHA1 ダイジェストのリストが与えられると、このコマンドは 1 または 0 の配列を返します。1 は特定の SHA1 がスクリプトキャッシュに既に存在するスクリプトとして認識されていることを意味し、0 はこの SHA1 を持つスクリプトが以前に見られたことがないことを意味します (少なくとも最新の SCRIPT FLUSH コマンドの後には見られたことがない)。</target>
        </trans-unit>
        <trans-unit id="5e47705fe8d80f510ddf59025f5bedac0bd2d833" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, it is often useful to obtain back the coordinates of specified members. When the geospatial index is populated via &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; the coordinates are converted into a 52 bit geohash, so the coordinates returned may not be exactly the ones used in order to add the elements, but small errors may be introduced.</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;コマンドを使用して入力された、地理空間インデックスを表すソートされたセットが与えられた場合、指定されたメンバーの座標を取得することはしばしば役立ちます。地理空間インデックスが&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;を介して入力されると、座標は52ビットのジオハッシュに変換されるため、返される座標は要素を追加するために使用されたものとは正確に一致しない場合がありますが、小さなエラーが発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="1a98977aea8887ddd5a1edb60251e403b53795ab" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, the command returns the distance between the two specified members in the specified unit.</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;コマンドを使用して入力された、地理空間インデックスを表すソートされたセットを指定すると、コマンドは、指定された単位内の指定された2つのメンバー間の距離を返します。</target>
        </trans-unit>
        <trans-unit id="f45f257965d0c26e93bb5789953aca2dc751ef9e" translate="yes" xml:space="preserve">
          <source>Global variables protection</source>
          <target state="translated">グローバル変数の保護</target>
        </trans-unit>
        <trans-unit id="15d1555c45e5fc58578080840f0c6368a6d6cb11" translate="yes" xml:space="preserve">
          <source>Guarantee of termination</source>
          <target state="translated">終了の保証</target>
        </trans-unit>
        <trans-unit id="5205aa5d3ee9c438b38044d5999ac4ba4201f832" translate="yes" xml:space="preserve">
          <source>HDEL</source>
          <target state="translated">HDEL</target>
        </trans-unit>
        <trans-unit id="f0d9eb5c49197bfd6feeb0c9d7b482f5e211f201" translate="yes" xml:space="preserve">
          <source>HDEL  key field [field ...]   Delete one or more hash fields</source>
          <target state="translated">HDEL キーフィールド [フィールド ....]1 つ以上のハッシュフィールドを削除します。</target>
        </trans-unit>
        <trans-unit id="b48dcfbcf4eca1611582a1cc8baa82d9d2fa2960" translate="yes" xml:space="preserve">
          <source>HEXISTS</source>
          <target state="translated">HEXISTS</target>
        </trans-unit>
        <trans-unit id="a807653048c48da53e448a2b285039ef0573aae8" translate="yes" xml:space="preserve">
          <source>HEXISTS  key field   Determine if a hash field exists</source>
          <target state="translated">HEXISTS キーフィールド ハッシュフィールドが存在するかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="2aa481a50927484124964b6f73bac3881de47ff3" translate="yes" xml:space="preserve">
          <source>HGET</source>
          <target state="translated">HGET</target>
        </trans-unit>
        <trans-unit id="53e1681d3979ea38127102b70459b3a4ea647f65" translate="yes" xml:space="preserve">
          <source>HGET  key field   Get the value of a hash field</source>
          <target state="translated">HGET キーフィールド ハッシュフィールドの値を取得します。</target>
        </trans-unit>
        <trans-unit id="0949fe15e4d07355cc1f8bdf2d7d0a3bc27e0498" translate="yes" xml:space="preserve">
          <source>HGETALL</source>
          <target state="translated">HGETALL</target>
        </trans-unit>
        <trans-unit id="a9f2d8c36ab9a92512a3abf304cf22c78a10d32a" translate="yes" xml:space="preserve">
          <source>HGETALL  key   Get all the fields and values in a hash</source>
          <target state="translated">HGETALL key ハッシュ内のすべてのフィールドと値を取得します。</target>
        </trans-unit>
        <trans-unit id="bec3f40ebfc071338931e9ec346c383954f688e2" translate="yes" xml:space="preserve">
          <source>HINCRBY</source>
          <target state="translated">HINCRBY</target>
        </trans-unit>
        <trans-unit id="85ba7d4ce6a861db6587eaef82d0c559a1acad5a" translate="yes" xml:space="preserve">
          <source>HINCRBY  key field increment   Increment the integer value of a hash field by the given number</source>
          <target state="translated">HINCRBY キーフィールドのインクリメント ハッシュフィールドの整数値を指定した数だけ増加させます。</target>
        </trans-unit>
        <trans-unit id="a93522c3800a73e9eb332f7f840625aacdc296f3" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT</source>
          <target state="translated">HINCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="b074f9cd10320d76be5375524c56b4c4f5083f25" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT  key field increment   Increment the float value of a hash field by the given amount</source>
          <target state="translated">HINCRBYFLOAT キーフィールドのインクリメント ハッシュフィールドの float 値を指定した量だけ増加させます。</target>
        </trans-unit>
        <trans-unit id="a857392e173da21b13e4d3e033f1d7d6aadde58a" translate="yes" xml:space="preserve">
          <source>HKEYS</source>
          <target state="translated">HKEYS</target>
        </trans-unit>
        <trans-unit id="4880894873a3e4a3dcf54bf74bebf960afb44a7c" translate="yes" xml:space="preserve">
          <source>HKEYS  key   Get all the fields in a hash</source>
          <target state="translated">HKEYS key ハッシュ内のすべてのフィールドを取得します。</target>
        </trans-unit>
        <trans-unit id="4d36dfb03a6ecdea21a171dc0c30adebe8d01184" translate="yes" xml:space="preserve">
          <source>HLEN</source>
          <target state="translated">HLEN</target>
        </trans-unit>
        <trans-unit id="bcfcea9d003f5af07b2bb8099e2b496b1e9e832a" translate="yes" xml:space="preserve">
          <source>HLEN  key   Get the number of fields in a hash</source>
          <target state="translated">HLEN key ハッシュ内のフィールド数を取得します。</target>
        </trans-unit>
        <trans-unit id="480987a6e9c4e7cd1d65f5ffad4b88a1132f2c6f" translate="yes" xml:space="preserve">
          <source>HMGET</source>
          <target state="translated">HMGET</target>
        </trans-unit>
        <trans-unit id="5b7367a8f047e6e2ad4600495794ba1f6c7d8f47" translate="yes" xml:space="preserve">
          <source>HMGET  key field [field ...]   Get the values of all the given hash fields</source>
          <target state="translated">HMGET キーフィールド [フィールド ....]与えられたすべてのハッシュフィールドの値を取得します。</target>
        </trans-unit>
        <trans-unit id="fb5089ab3a0516d344f9de817ed332775e142279" translate="yes" xml:space="preserve">
          <source>HMSET</source>
          <target state="translated">HMSET</target>
        </trans-unit>
        <trans-unit id="b9ce7bb49b575eba9a143cb12bd3a727345953bd" translate="yes" xml:space="preserve">
          <source>HMSET  key field value [field value ...]   Set multiple hash fields to multiple values</source>
          <target state="translated">HMSET キーフィールド値 [フィールド値 ...]複数のハッシュフィールドを複数の値に設定する</target>
        </trans-unit>
        <trans-unit id="f36a969e90bd023793807636ddb180dde5956fd7" translate="yes" xml:space="preserve">
          <source>HSCAN</source>
          <target state="translated">HSCAN</target>
        </trans-unit>
        <trans-unit id="1f717593e9570c814ba25178e664e1d1c164122d" translate="yes" xml:space="preserve">
          <source>HSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate hash fields and associated values</source>
          <target state="translated">HSCAN キーカーソル [MATCH パターン][COUNT カウント]ハッシュフィールドと関連する値の反復処理を増加させます。</target>
        </trans-unit>
        <trans-unit id="00cee6cf2b7799f7538096724dbd92d41cec6aeb" translate="yes" xml:space="preserve">
          <source>HSET</source>
          <target state="translated">HSET</target>
        </trans-unit>
        <trans-unit id="665396b991835984fc7e3e34cd2fe5312ecf417d" translate="yes" xml:space="preserve">
          <source>HSET  key field value   Set the string value of a hash field</source>
          <target state="translated">HSET キーフィールド値 ハッシュフィールドの文字列値を設定します。</target>
        </trans-unit>
        <trans-unit id="f08f81142bc45f390db40acaf0af8de40d5f8df0" translate="yes" xml:space="preserve">
          <source>HSETNX</source>
          <target state="translated">HSETNX</target>
        </trans-unit>
        <trans-unit id="8f0805bb5892aca6c147d761f188dcc8c135168b" translate="yes" xml:space="preserve">
          <source>HSETNX  key field value   Set the value of a hash field, only if the field does not exist</source>
          <target state="translated">HSETNX キーフィールド値 ハッシュフィールドの値を設定する。</target>
        </trans-unit>
        <trans-unit id="653e2c00767d7da99a4ad249e0220683a0f21927" translate="yes" xml:space="preserve">
          <source>HSTRLEN</source>
          <target state="translated">HSTRLEN</target>
        </trans-unit>
        <trans-unit id="bb8103389cfdcecf46656f06573ed3513c20d29d" translate="yes" xml:space="preserve">
          <source>HSTRLEN  key field   Get the length of the value of a hash field</source>
          <target state="translated">HSTRLEN キーフィールド ハッシュフィールドの値の長さを取得します。</target>
        </trans-unit>
        <trans-unit id="75c2a102095c5cfb3745c7635997fd6d46e1ed99" translate="yes" xml:space="preserve">
          <source>HVALS</source>
          <target state="translated">HVALS</target>
        </trans-unit>
        <trans-unit id="2cf3758bf2c3fcb0cf4699e1fad2c529e7f60c18" translate="yes" xml:space="preserve">
          <source>HVALS  key   Get all the values in a hash</source>
          <target state="translated">HVALS キー ハッシュ内のすべての値を取得します。</target>
        </trans-unit>
        <trans-unit id="1679a916ecf39377920740d5654170e7e20f04f9" translate="yes" xml:space="preserve">
          <source>Handling deadlocks</source>
          <target state="translated">デッドロックの処理</target>
        </trans-unit>
        <trans-unit id="17348a159bc90f6828002f9fa69a3bdc1006ad33" translate="yes" xml:space="preserve">
          <source>Handling of strings with different lengths</source>
          <target state="translated">長さの異なる文字列の取り扱い</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="abef659c43351c90fc57bd2f1f2ca21c74a56b5c" translate="yes" xml:space="preserve">
          <source>Hashes can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is a special encoding used for small hashes.</source>
          <target state="translated">ハッシュは、次のように符号化することができる &lt;code&gt;ziplist&lt;/code&gt; または &lt;code&gt;hashtable&lt;/code&gt; 。 &lt;code&gt;ziplist&lt;/code&gt; は、小さなハッシュのために使用される特殊なエンコーディングです。</target>
        </trans-unit>
        <trans-unit id="a9f98aceea4b6640fde4f0db2b67c8b62670525a" translate="yes" xml:space="preserve">
          <source>Helper functions to return Redis types</source>
          <target state="translated">Redisの型を返すためのヘルパー関数</target>
        </trans-unit>
        <trans-unit id="71f2a2c44b12e8d025ffdb0ba44d167f2eb32dc5" translate="yes" xml:space="preserve">
          <source>Here are a few conversion examples:</source>
          <target state="translated">ここでは、いくつかの変換例を紹介します。</target>
        </trans-unit>
        <trans-unit id="bd16d98ee220a06318e7c2f0edf89d89e391fb27" translate="yes" xml:space="preserve">
          <source>Here is the description of fields for Redis &amp;gt;= 2.4.</source>
          <target state="translated">Redis&amp;gt; = 2.4のフィールドの説明を次に示します。</target>
        </trans-unit>
        <trans-unit id="1953d7d107ad4ade79603b02cdb1e8adc699e514" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;clients&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;クライアント&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="aa545dc398491c6907d2041f2ded31d190284a9f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;cpu&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;CPU&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d3d5c7888fb0526434ccb545db7ed9e893e48b61" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;memory&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;メモリ&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d1e56b526c805770cba7347f8a39b9426d10e67e" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;persistence&lt;/strong&gt; section:</source>
          <target state="translated">以下は、&lt;strong&gt;永続性&lt;/strong&gt;セクションのすべてのフィールドの意味です。</target>
        </trans-unit>
        <trans-unit id="799881fdedd2437b9e8155aa33f7576cc6d468a1" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;replication&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;レプリケーション&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0d613b28b44d140ea4afd266be689c2f86ce192d" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;server&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;サーバー&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9700349259df5577664d69e8579a5af99e65c52f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;stats&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;stats&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4bd3033708ea4b8a6d1fbb504db04260b3b5e786" translate="yes" xml:space="preserve">
          <source>Here is the meaning of the fields:</source>
          <target state="translated">畑の意味はここにあります。</target>
        </trans-unit>
        <trans-unit id="4d96106a2b4866d88034cf3cbc99a16013a0e36c" translate="yes" xml:space="preserve">
          <source>Hint: it is possible to switch to a different key based on the current Unix time, in this way it is possible to have just a relatively small amount of samples per key, to avoid dealing with very big keys, and to make this pattern more friendly to be distributed across many Redis instances.</source>
          <target state="translated">ヒント:現在のUnixの時刻に基づいて別のキーに切り替えることが可能です。この方法では、キーごとに比較的少量のサンプルを持つことができ、非常に大きなキーを扱うのを避け、このパターンを多くのRedisインスタンスに分散させやすくすることができます。</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="b51e386256184dc34229a5ca92a34accb7024327" translate="yes" xml:space="preserve">
          <source>How Redis expires keys</source>
          <target state="translated">Redisはどのようにキーを期限切れにするか</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">どうやって使うのか?</target>
        </trans-unit>
        <trans-unit id="88559343d1f8627b05ed905092ec3f856b6418a7" translate="yes" xml:space="preserve">
          <source>How expires are handled in the replication link and AOF file</source>
          <target state="translated">レプリケーションリンクとAOFファイルでの期限切れの処理方法</target>
        </trans-unit>
        <trans-unit id="a8dbfaf95083e1d6e63da157f09e95d8c10fa20f" translate="yes" xml:space="preserve">
          <source>How multiple clients blocked on a single stream are served</source>
          <target state="translated">1つのストリームでブロックされた複数のクライアントがどのようにしてサービスを提供するか</target>
        </trans-unit>
        <trans-unit id="d5868df09b7eeb0561970a8e423e96c9ad849dbe" translate="yes" xml:space="preserve">
          <source>How to specify intervals</source>
          <target state="translated">インターバルの指定方法</target>
        </trans-unit>
        <trans-unit id="7a00a1128dbff721f5566b479531909bd1900b68" translate="yes" xml:space="preserve">
          <source>However because &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has very little state associated (just the cursor) it has the following drawbacks:</source>
          <target state="translated">ただし、&lt;a href=&quot;scan&quot;&gt;SCANに&lt;/a&gt;はほとんど関連付けられていない状態（カーソルのみ）があるため、次の欠点があります。</target>
        </trans-unit>
        <trans-unit id="d5314787731edc5f7c64fb20d0e8d7d8aa980d1c" translate="yes" xml:space="preserve">
          <source>However if the offset is prefixed with a &lt;code&gt;#&lt;/code&gt; character, the specified offset is multiplied by the integer type width, so for example:</source>
          <target state="translated">ただし、オフセットの前に &lt;code&gt;#&lt;/code&gt; 文字を付けると、指定したオフセットに整数型の幅が乗算されます。たとえば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f5cfa667464e115c28334f27e6f622c0e6fc2a1c" translate="yes" xml:space="preserve">
          <source>However in this context the obtained queue is not &lt;em&gt;reliable&lt;/em&gt; as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</source>
          <target state="translated">ただし、このコンテキストでは、取得されたキューは&lt;em&gt;信頼性&lt;/em&gt;がありません。たとえば、ネットワークに問題がある場合や、メッセージを受信した直後にコンシューマーがクラッシュしたが、まだ処理中である場合などは、メッセージが失われる可能&lt;em&gt;性&lt;/em&gt;があります。</target>
        </trans-unit>
        <trans-unit id="32db1099030ce3f6b2493101785b95bdd63b63e3" translate="yes" xml:space="preserve">
          <source>However it returns OK to the caller ASAP, so the &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; command execution is not paused by itself.</source>
          <target state="translated">ただし、呼び出し元にOKをすぐに返すため、&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;コマンドの実行はそれ自体で一時停止されません。</target>
        </trans-unit>
        <trans-unit id="5ebc54eeb70e7c4776f4ca626c28b6528713adcd" translate="yes" xml:space="preserve">
          <source>However node hash slots can be in a special state, used in order to communicate errors after a node restart (mismatch between the keys in the AOF/RDB file, and the node hash slots configuration), or when there is a resharding operation in progress. This two states are &lt;strong&gt;importing&lt;/strong&gt; and &lt;strong&gt;migrating&lt;/strong&gt;.</source>
          <target state="translated">ただし、ノードハッシュスロットは、ノードの再起動後（AOF / RDBファイルのキーとノードハッシュスロット構成の不一致）、またはリシャーディング操作が進行中の場合にエラーを通知するために使用される特別な状態になる可能性があります。 。この2つの状態は&lt;strong&gt;インポート&lt;/strong&gt;と&lt;strong&gt;移行&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="74506a394d8d9a9db887f0b3d8806ba4f46848f4" translate="yes" xml:space="preserve">
          <source>However note that with streams this is not a problem: stream entries are not removed from the stream when clients are served, so every client waiting will be served as soon as an &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command provides data to the stream.</source>
          <target state="translated">ただし、ストリームの場合、これは問題ではないことに注意してください。クライアントにサービスが提供されてもストリームエントリはストリームから削除されないため、&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;コマンドがストリームにデータを提供するとすぐに、待機しているすべてのクライアントにサービスが提供されます。</target>
        </trans-unit>
        <trans-unit id="5d5d9fa16c29cdab06e0b69ea5b8063d64e64fa1" translate="yes" xml:space="preserve">
          <source>However note that:</source>
          <target state="translated">しかし、それに注意してください。</target>
        </trans-unit>
        <trans-unit id="c2edee6acbd228e132336d8defe53364f46f07e4" translate="yes" xml:space="preserve">
          <source>However once the data structures are bigger and are promoted to use real hash tables, the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of commands will resort to the normal behavior. Note that since this special behavior of returning all the elements is true only for small aggregates, it has no effects on the command complexity or latency. However the exact limits to get converted into real hash tables are &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;user configurable&lt;/a&gt;, so the maximum number of elements you can see returned in a single call depends on how big an aggregate data type could be and still use the packed representation.</source>
          <target state="translated">ただし、データ構造が大きくなり、実際のハッシュテーブルを使用するようにプロモートされると、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;ファミリーのコマンドは通常の動作に頼ります。すべての要素を返すというこの特別な動作は小さな集合体にのみ当てはまるため、コマンドの複雑さや待ち時間には影響しません。ただし、実際のハッシュテーブルに変換するための正確な制限は&lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;ユーザーが設定&lt;/a&gt;できるため、1回の呼び出しで返される要素の最大数は、集約データ型がどれほど大きくても、パックされた表現を使用できるかによって異なります。</target>
        </trans-unit>
        <trans-unit id="b21c3d5072091035e19308ba188163eb9b4582ee" translate="yes" xml:space="preserve">
          <source>However starting with Redis 2.8.12 or greater, the command accepts the following form:</source>
          <target state="translated">ただし、Redis 2.8.12 以降では、コマンドは以下の形式を受け付けます。</target>
        </trans-unit>
        <trans-unit id="3d9349e56b3bf2d47d692509fd1873664bc86e71" translate="yes" xml:space="preserve">
          <source>However the command cannot simply drop the node from the internal node table of the node receiving the command, it also implements a ban-list, not allowing the same node to be added again as a side effect of processing the &lt;em&gt;gossip section&lt;/em&gt; of the heartbeat packets received from other nodes.</source>
          <target state="translated">ただし、コマンドは、コマンドを受信するノードの内部ノードテーブルからノードを単に削除することはできません。禁止リストも実装しているため、ハートビートパケットの&lt;em&gt;ゴシップセクション&lt;/em&gt;の処理の副作用として同じノードを再度追加することはできません。他のノードから受信した。</target>
        </trans-unit>
        <trans-unit id="77d71597c94f649040209c65345b9adb784d1ada" translate="yes" xml:space="preserve">
          <source>However the number of returned elements is reasonable, that is, in practical terms SCAN may return a maximum number of elements in the order of a few tens of elements when iterating a large collection, or may return all the elements of the collection in a single call when the iterated collection is small enough to be internally represented as an encoded data structure (this happens for small sets, hashes and sorted sets).</source>
          <target state="translated">しかし、返される要素の数は合理的です。現実的には、SCANは大きなコレクションを反復処理する際には、数十個の要素の順番で最大の要素数を返します。また、反復処理されたコレクションが内部的に符号化されたデータ構造として表現されるほど小さい場合には、1回の呼び出しでコレクションのすべての要素を返すかもしれません(これは小さな集合、ハッシュ、ソートされた集合で起こります)。</target>
        </trans-unit>
        <trans-unit id="4a9bd4d796e3f1d19b335cd4b8d1d2f3544974af" translate="yes" xml:space="preserve">
          <source>However the user can apply a transformation to the encoded string so that the first part of the element inserted in the sorted set will compare as the user requires for the specific application. For example if I want to add strings that will be compared in a case-insensitive way, but I still want to retrieve the real case when querying, I can add strings in the following way:</source>
          <target state="translated">しかし、ユーザーはエンコードされた文字列に変換を適用して、ソートされたセットに挿入された要素の最初の部分が、ユーザーが特定のアプリケーションで必要とするように比較されるようにすることができます。例えば、大文字小文字を区別しない方法で比較される文字列を追加したいが、クエリの際には実在の大文字小文字を取得したい場合、次のように文字列を追加することができます。</target>
        </trans-unit>
        <trans-unit id="794f44a2bce77c8dc3d6e6888d73f15fd3089fde" translate="yes" xml:space="preserve">
          <source>However the user is still able to write commands with random behavior using the following simple trick. Imagine I want to write a Redis script that will populate a list with N random integers.</source>
          <target state="translated">しかし、以下の簡単なトリックを使えば、ユーザはランダムな動作をするコマンドを書くことができます。N個の乱数整数でリストを生成するRedisスクリプトを書きたいと想像してみてください。</target>
        </trans-unit>
        <trans-unit id="fb5b52cca56c4cdd87edf1dfc660cd981c3a9505" translate="yes" xml:space="preserve">
          <source>However there is a way for the user to tune the order of magnitude of the number of returned elements per call using the &lt;strong&gt;COUNT&lt;/strong&gt; option.</source>
          <target state="translated">ただし、&lt;strong&gt;COUNT&lt;/strong&gt;オプションを使用して、呼び出しごとに返される要素の数の桁をユーザーが調整する方法があります。</target>
        </trans-unit>
        <trans-unit id="7f8f1c30670b30342c4d809208def1afc1fbfd2c" translate="yes" xml:space="preserve">
          <source>However there is an exception to this rule, and it is when a new cluster is created from scratch. Redis Cluster &lt;em&gt;config epoch collision resolution&lt;/em&gt; algorithm can deal with new nodes all configured with the same configuration at startup, but this process is slow and should be the exception, only to make sure that whatever happens, two more nodes eventually always move away from the state of having the same configuration epoch.</source>
          <target state="translated">ただし、このルールには例外があり、新しいクラスターが最初から作成される場合です。Redisクラスター構成&lt;em&gt;エポック衝突解決&lt;/em&gt;アルゴリズムは、起動時にすべて同じ構成で構成された新しいノードを処理できますが、このプロセスは遅く、例外になるはずです。何が起こっても、最終的に2つのノードが常に状態から離れることを確認するためです。同じ構成エポックを持つこと。</target>
        </trans-unit>
        <trans-unit id="142631746a79e235cfed163ccdfe702d6be0326c" translate="yes" xml:space="preserve">
          <source>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</source>
          <target state="translated">しかし、これは遅いスクリプトを実行するのは良い考えではないということでもあります。スクリプトのオーバーヘッドは非常に低いので、高速なスクリプトを作成することは難しくありませんが、低速なスクリプトを使用する場合は、スクリプトが実行されている間は他のクライアントがコマンドを実行できないことに注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="0a33083c754611907b7f894af6eb43aadc3e4c17" translate="yes" xml:space="preserve">
          <source>However this is a useful feature since, sometimes, we need to execute certain commands only in the master in order to create, for example, intermediate values.</source>
          <target state="translated">しかし、これは便利な機能です。</target>
        </trans-unit>
        <trans-unit id="d0af8abe6ce309a54e5c3abb2294351b6406b863" translate="yes" xml:space="preserve">
          <source>However this is just a best-effort attempt so it is possible to still lose a write synchronously replicated to multiple replicas.</source>
          <target state="translated">しかし、これはベストエフォートの試みに過ぎないので、複数のレプリカに同期的に複製された書き込みを失う可能性があります。</target>
        </trans-unit>
        <trans-unit id="ddd90e4937b6a5514534f2c76508301017283476" translate="yes" xml:space="preserve">
          <source>However trying to execute it again results into an error since the slots are already assigned:</source>
          <target state="translated">しかし、再度実行しようとすると、スロットが既に割り当てられているため、エラーになります。</target>
        </trans-unit>
        <trans-unit id="8abb1412bd4f6007eadde6067935f55706c8b96f" translate="yes" xml:space="preserve">
          <source>However using &lt;strong&gt;FORCE&lt;/strong&gt; we still need the majority of masters to be available in order to authorize the failover and generate a new configuration epoch for the replica that is going to become master.</source>
          <target state="translated">ただし、&lt;strong&gt;FORCE&lt;/strong&gt;を使用する場合は、フェイルオーバーを承認し、マスターになるレプリカの新しい構成エポックを生成するために、大部分のマスターを使用可能にする必要があります。</target>
        </trans-unit>
        <trans-unit id="f7eb54420a392ba9d9fb195f48555b2f9849c4e4" translate="yes" xml:space="preserve">
          <source>However while blocking commands like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; are able to provide all the elements that are part of a Set in a given moment, The SCAN family of commands only offer limited guarantees about the returned elements since the collection that we incrementally iterate can change during the iteration process.</source>
          <target state="translated">ただし、&lt;a href=&quot;smembers&quot;&gt;SMEMBERSの&lt;/a&gt;ようなブロッキングコマンドは、特定の瞬間にセットの一部であるすべての要素を提供できますが、SCANファミリのコマンドは、反復処理するコレクションが反復プロセス中に変更される可能性があるため、返された要素について限られた保証しか提供しません。</target>
        </trans-unit>
        <trans-unit id="8368348c7a15aab35b99bad0b61100388ed947ac" translate="yes" xml:space="preserve">
          <source>However while the replicas connected to a master will not expire keys independently (but will wait for the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; coming from the master), they'll still take the full state of the expires existing in the dataset, so when a replica is elected to master it will be able to expire the keys independently, fully acting as a master.</source>
          <target state="translated">ただし、マスターに接続されたレプリカはキーを個別に期限切れにすることはありませんが（マスターからの&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;を待機します）、データセット内に存在する期限切れの完全な状態を取るため、レプリカがマスターに選択されます。キーを個別に期限切れにすることができ、完全にマスターとして機能します。</target>
        </trans-unit>
        <trans-unit id="e7564bd1b123b79267215f60720a7ba2c7d0f2a4" translate="yes" xml:space="preserve">
          <source>However, note that:</source>
          <target state="translated">ただし、その点には注意してください。</target>
        </trans-unit>
        <trans-unit id="ae8b2a13bc4ae56dbd4d97a2490048eefaa8824d" translate="yes" xml:space="preserve">
          <source>However, this behavior changes if you are looking for clear bits and specify a range with both &lt;strong&gt;start&lt;/strong&gt; and &lt;strong&gt;end&lt;/strong&gt;. If no clear bit is found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.</source>
          <target state="translated">ただし、クリアビットを探して&lt;strong&gt;start&lt;/strong&gt;と&lt;strong&gt;endの&lt;/strong&gt;両方で範囲を指定すると、この動作は変わります。指定された範囲にクリアビットが見つからない場合、ユーザーがクリア範囲を指定し、その範囲に0ビットがないため、関数は-1を返します。</target>
        </trans-unit>
        <trans-unit id="078d1434700af53deba94cb889757980e4b68051" translate="yes" xml:space="preserve">
          <source>Humans may use this command in order to check what is the hash slot, and then the associated Redis Cluster node, responsible for a given key.</source>
          <target state="translated">人間は、ハッシュスロットが何であるかを確認するために、このコマンドを使用することができ、その後、関連するRedisクラスタノードは、与えられたキーに責任があります。</target>
        </trans-unit>
        <trans-unit id="d68bb5655889a7436b2eff6315d03293170f63d0" translate="yes" xml:space="preserve">
          <source>HyperLogLog</source>
          <target state="translated">HyperLogLog</target>
        </trans-unit>
        <trans-unit id="58b5c100f0d44808f0dbfcc3722f78c2d81f1aaf" translate="yes" xml:space="preserve">
          <source>HyperLogLog representation</source>
          <target state="translated">ハイパーログログ表現</target>
        </trans-unit>
        <trans-unit id="28c10e9d5a5781ed8d9e57c706ceb5a1dd97ff5f" translate="yes" xml:space="preserve">
          <source>I can start with this small Ruby program:</source>
          <target state="translated">この小さなRubyのプログラムから始められます。</target>
        </trans-unit>
        <trans-unit id="5188851d79e499077ff8c17718081d6a2d5d7980" translate="yes" xml:space="preserve">
          <source>IDs are guaranteed to be always incremental: If you compare the ID of the entry just inserted it will be greater than any other past ID, so entries are totally ordered inside a stream. In order to guarantee this property, if the current top ID in the stream has a time greater than the current local time of the instance, the top entry time will be used instead, and the sequence part of the ID incremented. This may happen when, for instance, the local clock jumps backward, or if after a failover the new master has a different absolute time.</source>
          <target state="translated">ID は常にインクリメンタルであることが保証されています:挿入されたばかりのエントリの ID を比較すると、それは他の過去のどの ID よりも大きくなりますので、エントリはストリーム内で完全に順序付けられます。この特性を保証するために、ストリーム内の現在の先頭のIDの時刻がインスタンスの現在のローカル時刻よりも大きい場合、代わりに先頭のエントリの時刻が使用され、IDのシーケンス部分がインクリメントされます。これは、例えば、ローカルクロックが後方にジャンプした場合や、フェイルオーバー後に新しいマスターが異なる絶対時刻を持っている場合などに発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c0f8745b1bebe7ddae3a87f4efc1207e5b87a40b" translate="yes" xml:space="preserve">
          <source>IDs are specified by two numbers separated by a &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">IDは、 &lt;code&gt;-&lt;/code&gt; 文字で区切られた2つの数字で指定されます。</target>
        </trans-unit>
        <trans-unit id="70aab9650acd50b2b8e1776f69b86b88bbbe99e5" translate="yes" xml:space="preserve">
          <source>INCR</source>
          <target state="translated">INCR</target>
        </trans-unit>
        <trans-unit id="c59620ba3e9207aaf8fb1bf70e412a9caa358cb2" translate="yes" xml:space="preserve">
          <source>INCR  key   Increment the integer value of a key by one</source>
          <target state="translated">INCR key キーの整数値を 1 つインクリメントします。</target>
        </trans-unit>
        <trans-unit id="af14b6096425a1f909b7628ce8491716c2d581ba" translate="yes" xml:space="preserve">
          <source>INCRBY</source>
          <target state="translated">INCRBY</target>
        </trans-unit>
        <trans-unit id="9ab1bc6a3a0563b50a9e4bcb930106db12e2ae4e" translate="yes" xml:space="preserve">
          <source>INCRBY  key increment   Increment the integer value of a key by the given amount</source>
          <target state="translated">INCRBY key incrementment キーの整数値を指定した量だけ増加させます。</target>
        </trans-unit>
        <trans-unit id="769650b0192d046cb68b526ab27d41d927ea5cc8" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT</source>
          <target state="translated">INCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="2e3bba4aaf8bd64291b4999ea2633e1cde536fe3" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT  key increment   Increment the float value of a key by the given amount</source>
          <target state="translated">INCRBYFLOAT key incrementment キーの float 値を指定した量だけ増加させます。</target>
        </trans-unit>
        <trans-unit id="9c9cf999829193894067bbd9e1484756ab736ac0" translate="yes" xml:space="preserve">
          <source>INFO</source>
          <target state="translated">INFO</target>
        </trans-unit>
        <trans-unit id="42089cfb2067d721afeae473b5079898e863248e" translate="yes" xml:space="preserve">
          <source>INFO  [section]   Get information and statistics about the server</source>
          <target state="translated">INFO [セクション]サーバーに関する情報や統計情報を取得します。</target>
        </trans-unit>
        <trans-unit id="fc967bd2cc1b3485f1ee6c3bccb3832c0009ded5" translate="yes" xml:space="preserve">
          <source>Ideally, the &lt;code&gt;used_memory_rss&lt;/code&gt; value should be only slightly higher than &lt;code&gt;used_memory&lt;/code&gt;. When rss &amp;gt;&amp;gt; used, a large difference means there is memory fragmentation (internal or external), which can be evaluated by checking &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;. When used &amp;gt;&amp;gt; rss, it means part of Redis memory has been swapped off by the operating system: expect some significant latencies.</source>
          <target state="translated">理想的には、 &lt;code&gt;used_memory_rss&lt;/code&gt; の値は、used_memoryよりもわずかに高くなければなりませ &lt;code&gt;used_memory&lt;/code&gt; 。rss &amp;gt;&amp;gt;を使用する場合、大きな違いはメモリの断片化（内部または外部）が存在することを意味し、 &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; を確認することで評価できます。&amp;gt;&amp;gt; rssを使用すると、Redisメモリの一部がオペレーティングシステムによってスワップオフされたことを意味します。かなりのレイテンシが予想されます。</target>
        </trans-unit>
        <trans-unit id="73b4eda93b2219c5cea27cedcc70f71581e15c99" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; fails, no data gets lost as the old AOF will be untouched.</source>
          <target state="translated">場合&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOFが&lt;/a&gt;失敗した古いAOFがそのままであるように、データは失われません取得します。</target>
        </trans-unit>
        <trans-unit id="1d20f361447b1eebe4e4808ffc994e347a4065d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;0&lt;/code&gt; the key is already locked by some other client. We can either return to the caller if it's a non blocking lock, or enter a loop retrying to hold the lock until we succeed or some kind of timeout expires.</source>
          <target state="translated">&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;が &lt;code&gt;0&lt;/code&gt; を返す場合、キーは他のクライアントによってすでにロックされています。非ブロッキングロックの場合は呼び出し元に戻るか、ループに入ると、成功するか、ある種のタイムアウトが発生するまでロックの保持を再試行できます。</target>
        </trans-unit>
        <trans-unit id="b2860996021d578f69065139684f5cafa8d2519b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;1&lt;/code&gt; the client acquired the lock, setting the &lt;code&gt;lock.foo&lt;/code&gt; key to the Unix time at which the lock should no longer be considered valid. The client will later use &lt;code&gt;DEL lock.foo&lt;/code&gt; in order to release the lock.</source>
          <target state="translated">&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;が &lt;code&gt;1&lt;/code&gt; を返す場合、クライアントはロックを取得し、 &lt;code&gt;lock.foo&lt;/code&gt; キーを、ロックが有効であると見なされなくなったUnix時間に設定します。クライアントは後でロックを解放するために &lt;code&gt;DEL lock.foo&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a5eee6810815d94e86b03260de66be0feb7ce88c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; was used, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches all keys watched by the connection.</source>
          <target state="translated">&lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt;が使用された場合、&lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;は接続によって監視されているすべてのキーの監視を解除します。</target>
        </trans-unit>
        <trans-unit id="20ed44b2bda4227d511c46587683f47a00d993b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITHCOORD&lt;/code&gt;, &lt;code&gt;WITHDIST&lt;/code&gt; or &lt;code&gt;WITHHASH&lt;/code&gt; options are specified, the command returns an array of arrays, where each sub-array represents a single item.</source>
          <target state="translated">場合 &lt;code&gt;WITHCOORD&lt;/code&gt; 、 &lt;code&gt;WITHDIST&lt;/code&gt; 又は &lt;code&gt;WITHHASH&lt;/code&gt; オプションが指定され、コマンドは、各サブアレイは、単一のアイテムを表す配列の配列を返します。</target>
        </trans-unit>
        <trans-unit id="73dfe5f15062ceece61a6acc3449e57743eeff88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten.</source>
          <target state="translated">&lt;code&gt;destination&lt;/code&gt; すでに存在する場合は、上書きされます。</target>
        </trans-unit>
        <trans-unit id="ec00a71247f51a83461ff727be4fdc2a9b8eef53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; already exists and is a string, this command appends the &lt;code&gt;value&lt;/code&gt; at the end of the string. If &lt;code&gt;key&lt;/code&gt; does not exist it is created and set as an empty string, so &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; will be similar to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; in this special case.</source>
          <target state="translated">場合は &lt;code&gt;key&lt;/code&gt; すでに存在し、文字列で、このコマンドが追加され &lt;code&gt;value&lt;/code&gt; 文字列の末尾。場合は &lt;code&gt;key&lt;/code&gt; 存在しないので、それは、空の文字列として作成し、セットされた&lt;a href=&quot;append&quot;&gt;APPENDは&lt;/a&gt;のようになります。&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;この特殊なケースインチ</target>
        </trans-unit>
        <trans-unit id="f65de86e658742c07d7bc6102da39df199a9b701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist a nil bulk reply is returned.</source>
          <target state="translated">場合は &lt;code&gt;key&lt;/code&gt; 存在しない場合はnilバルク応答が返されます。</target>
        </trans-unit>
        <trans-unit id="bd4417fe5a7c2042f71015b09d46b92838be30fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.</source>
          <target state="translated">場合は &lt;code&gt;key&lt;/code&gt; 存在しないソートセットが空であるかのように、唯一のメンバーとして指定されたメンバーを持つ新しいソートセットは、作成されます。キーは存在するが、ソートされたセットを保持していない場合は、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="e64662be889ce64c17aaa1cc9189ce3256310f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;member&lt;/code&gt; ソートセットかに存在しない &lt;code&gt;key&lt;/code&gt; 、存在しない&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;バルクの文字列の返信&lt;/a&gt;： &lt;code&gt;nil&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="f23ea3c8266e3f5959aed27b93602e9cafb796f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">場合 &lt;code&gt;member&lt;/code&gt; ソートセットに存在しない場合、または &lt;code&gt;key&lt;/code&gt; 存在しない場合、 &lt;code&gt;nil&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="1e3e9eec1dfb85dde46f12f033df8c95cb570dc1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; exists in the sorted set, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the rank of &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;member&lt;/code&gt; がソートされたセットに存在する場合、&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;整数応答&lt;/a&gt;： &lt;code&gt;member&lt;/code&gt; のランク。</target>
        </trans-unit>
        <trans-unit id="b0602d8252b35c86b3177857f428ef2b6ebe2844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;password&lt;/code&gt; matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">パスワードが構成ファイルの &lt;code&gt;password&lt;/code&gt; 一致する場合、サーバーは &lt;code&gt;OK&lt;/code&gt; ステータスコードで応答し、コマンドの受け入れを開始します。そうでない場合、エラーが返され、クライアントは新しいパスワードを試す必要があります。</target>
        </trans-unit>
        <trans-unit id="d8a36f67086d264992352bae73959a976d08f592" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</source>
          <target state="translated">場合 &lt;code&gt;source&lt;/code&gt; 存在しない場合、値 &lt;code&gt;nil&lt;/code&gt; 返され、何も動作は行われません。場合は &lt;code&gt;source&lt;/code&gt; と &lt;code&gt;destination&lt;/code&gt; 同じであり、動作は、リストから最後の要素を除去し、リストの最初の要素としてそれを押すと同等であるので、リスト回転指令とみなすことができます。</target>
        </trans-unit>
        <trans-unit id="5b26bcfdadbb106d42a10a68f68adf4977b43380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ttl&lt;/code&gt; is 0 the key is created without any expire, otherwise the specified expire time (in milliseconds) is set.</source>
          <target state="translated">&lt;code&gt;ttl&lt;/code&gt; が0の場合、キーは有効期限なしで作成されます。それ以外の場合、指定された有効期限（ミリ秒単位）が設定されます。</target>
        </trans-unit>
        <trans-unit id="2c1e9f5fc6b657f9746f093601d0e06e3be8a993" translate="yes" xml:space="preserve">
          <source>If AOF is activated, these additional fields will be added:</source>
          <target state="translated">AOFを有効にすると、これらのフィールドが追加されます。</target>
        </trans-unit>
        <trans-unit id="52fb5f5179b2d79edc8c3b551f845f186e716372" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an OK code, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6.</source>
          <target state="translated">Redisの子がディスク上にスナップショットを作成している場合、AOFの書き換えが&lt;em&gt;スケジュールされます&lt;/em&gt;が、RDBファイルを生成する保存中の子が終了するまで開始されません。この場合、&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;はOKコードを返しますが、適切なメッセージが表示されます。Redis 2.6の時点で、&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;コマンドを見て、AOFの書き換えがスケジュールされているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="7fab76e64c7a99cf5ff09d3faf8bcf4e7b29c3b9" translate="yes" xml:space="preserve">
          <source>If a Redis server is already acting as replica, the command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">Redisサーバーがすでにレプリカとして機能している場合、&lt;a href=&quot;replicaof&quot;&gt;REPLICOF&lt;/a&gt; NO ONE コマンドはレプリケーションをオフにして、Redisサーバーをマスターにします。適切な形式の&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;ホスト名ポートは、サーバーを、指定されたホスト名とポートでリッスンする別のサーバーのレプリカにします。</target>
        </trans-unit>
        <trans-unit id="6bba5cc9a8544de84799044ff9489eaddadc2beb" translate="yes" xml:space="preserve">
          <source>If a SYNC operation is on-going, these additional fields are provided:</source>
          <target state="translated">SYNC 操作が進行中の場合、これらの追加フィールドが提供されます。</target>
        </trans-unit>
        <trans-unit id="b39dab88e7088d47355746e00cd5a3b16aea36b7" translate="yes" xml:space="preserve">
          <source>If a cluster instance has non-contiguous slots (e.g. 1-400,900,1800-6000) then master and replica IP/Port results will be duplicated for each top-level slot range reply.</source>
          <target state="translated">クラスタインスタンスが連続しないスロット(例:1-400,900,1800-6000)を持っている場合、マスターとレプリカのIP/ポートの結果は、各トップレベルのスロット範囲の応答に対して重複します。</target>
        </trans-unit>
        <trans-unit id="59220272c64271f85f1f97cc7691835ad64c2de3" translate="yes" xml:space="preserve">
          <source>If a command accepts an unlimited number of keys, the last key position is -1.</source>
          <target state="translated">コマンドが無制限の数のキーを受け付ける場合、最後のキー位置は-1となります。</target>
        </trans-unit>
        <trans-unit id="140a2742270e0d194dfebacb6a9c7a4820592aff" translate="yes" xml:space="preserve">
          <source>If a command accepts one key, the first key and last key positions is 1.</source>
          <target state="translated">コマンドが1つのキーを受け付ける場合、最初のキーと最後のキーの位置は1になります。</target>
        </trans-unit>
        <trans-unit id="c31655fb4face26cd02e88dd6486f34dd31bb51e" translate="yes" xml:space="preserve">
          <source>If a command accepts two keys (e.g. &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;, &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, ...) then the last key position is the location of the last key in the argument list.</source>
          <target state="translated">コマンドが2つのキー（例：&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;、&lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;、&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;、...）を受け入れる場合、最後のキーの位置は、引数リスト内の最後のキーの位置です。</target>
        </trans-unit>
        <trans-unit id="610d9883b3ed9e5bbf61e781dfb38f2ca5532e85" translate="yes" xml:space="preserve">
          <source>If a command is received about a key that does not exists, an &lt;code&gt;ASK&lt;/code&gt; redirection is emitted by the node, asking the client to retry only that specific query into &lt;code&gt;destination-node&lt;/code&gt;. In this case the client should not update its hash slot to node mapping.</source>
          <target state="translated">存在しないキーに関するコマンドが受信されると、ノードによって &lt;code&gt;ASK&lt;/code&gt; リダイレクションが発行され、特定のクエリのみを &lt;code&gt;destination-node&lt;/code&gt; に再試行するようクライアントに要求します。この場合、クライアントはハッシュスロットをノードマッピングに更新しないでください。</target>
        </trans-unit>
        <trans-unit id="adc3a75aac4d6b35ed7b12ce05235e4cc640c05b" translate="yes" xml:space="preserve">
          <source>If a command is received about an existing key, the command is processed as usually.</source>
          <target state="translated">既存のキーに関するコマンドを受信した場合は、通常通り処理されます。</target>
        </trans-unit>
        <trans-unit id="a64d2ec3bb10e34eb579070274923657d7138a2a" translate="yes" xml:space="preserve">
          <source>If a key is overwritten by &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, like in the case of an existing key &lt;code&gt;Key_A&lt;/code&gt; that is overwritten by a call like &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt;, it does not matter if the original &lt;code&gt;Key_A&lt;/code&gt; had a timeout associated or not, the new key &lt;code&gt;Key_A&lt;/code&gt; will inherit all the characteristics of &lt;code&gt;Key_B&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RENAME Key_B Key_A&lt;/code&gt; のような呼び出しによって上書きされる既存のキー &lt;code&gt;Key_A&lt;/code&gt; の場合のように、キーが&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;によって上書きされる場合、元の &lt;code&gt;Key_A&lt;/code&gt; にタイムアウトが関連付けられているかどうかに関係なく、新しいキー &lt;code&gt;Key_A&lt;/code&gt; はすべて継承します &lt;code&gt;Key_B&lt;/code&gt; の特性。</target>
        </trans-unit>
        <trans-unit id="0360f4a1e3e37b28bbc1c81856843472bd113d44" translate="yes" xml:space="preserve">
          <source>If a key is renamed with &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, the associated time to live is transferred to the new key name.</source>
          <target state="translated">キーの名前が&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;に変更された場合、関連付けられた存続時間が新しいキー名に転送されます。</target>
        </trans-unit>
        <trans-unit id="dba073505eef52f13e35c2d2b072e15bc497f1c3" translate="yes" xml:space="preserve">
          <source>If a load operation is on-going, these additional fields will be added:</source>
          <target state="translated">負荷操作が進行中の場合、これらの追加フィールドが追加されます。</target>
        </trans-unit>
        <trans-unit id="a8036cb18b462f0b09c70d787c53e11501cfbc97" translate="yes" xml:space="preserve">
          <source>If a node with unbound hash slots receives a heartbeat packet from another node that claims to be the owner of some of those hash slots, the association is established instantly. Moreover, if a heartbeat or update message is received with a configuration epoch greater than the node's own, the association is re-established.</source>
          <target state="translated">束縛されていないハッシュスロットを持つノードが、そのハッシュスロットの一部の所有者であると主張する別のノードからハートビートパケットを受信した場合、その関連付けは即座に確立されます。さらに、ハートビートまたは更新メッセージが、ノード自身の設定エポックよりも大きい設定エポックで受信された場合、アソシエーションは再確立されます。</target>
        </trans-unit>
        <trans-unit id="e6947348d36ca3b7d6ec64b0d3d493bff74f2cca" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">サーバーがすでにマスターのレプリカである場合、&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;ホスト名ポートは古いサーバーに対するレプリケーションを停止し、新しいサーバーに対する同期を開始して、古いデータセットを破棄します。</target>
        </trans-unit>
        <trans-unit id="8355cef42438c57bf29e119daff3edf69a2eafac" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">サーバーがすでにマスターのレプリカである場合、&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt;ホスト名ポートは古いサーバーに対するレプリケーションを停止し、新しいサーバーに対する同期を開始して、古いデータセットを破棄します。</target>
        </trans-unit>
        <trans-unit id="796f8c82d2cb3bc6674d519060d62df76a47b5cf" translate="yes" xml:space="preserve">
          <source>If an AOF rewrite is already in progress the command returns an error and no AOF rewrite will be scheduled for a later time.</source>
          <target state="translated">AOFの書き換えが既に進行中の場合はエラーを返し、後から書き換えは行われません。</target>
        </trans-unit>
        <trans-unit id="aa95f2ff011f2ee3af55365c22aa9caf33f28db8" translate="yes" xml:space="preserve">
          <source>If an option already exists in the old redis.conf file, it will be rewritten at the same position (line number).</source>
          <target state="translated">古いredis.confファイルに既にオプションが存在する場合は、同じ位置(行番号)に書き換えられます。</target>
        </trans-unit>
        <trans-unit id="4658daabd5c918d6c9d2de1223a7f5eb6d9fd842" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to a non-default value, it is appended at the end of the file.</source>
          <target state="translated">オプシ ョ ンが既に存在していないが、 それがデ フ ォル ト 以外の値に設定 さ れてい る 場合は、 それがフ ァ イ ルの末尾に追加 さ れます。</target>
        </trans-unit>
        <trans-unit id="e4228aca6b611c430e003ee894c91eb30a1b6cd7" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to its default value, it is not added by the rewrite process.</source>
          <target state="translated">既に存在していないオプションがデフォルト値に設定されている場合は、書き換え処理では追加されません。</target>
        </trans-unit>
        <trans-unit id="b63f671253761bdf3174af266654497deb63ef4b" translate="yes" xml:space="preserve">
          <source>If another client, for instance C5, was faster than C4 and acquired the lock with the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation, the C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation will return a non expired timestamp. C4 will simply restart from the first step. Note that even if C4 set the key a bit a few seconds in the future this is not a problem.</source>
          <target state="translated">別のクライアント（C5など）がC4より高速で、&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;操作でロックを取得した場合、C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;操作は期限切れでないタイムスタンプを返します。C4は最初のステップから再起動します。C4が数秒後にキーを少し設定しても、これは問題ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="37cf40db32d54ae3579f3237037ff5c92145f193" translate="yes" xml:space="preserve">
          <source>If at a given time a node has another node flagged with &lt;code&gt;PFAIL&lt;/code&gt;, and at the same time collected the majority of other master nodes &lt;em&gt;failure reports&lt;/em&gt; about this node (including itself if it is a master), then it elevates the failure state of the node from &lt;code&gt;PFAIL&lt;/code&gt; to &lt;code&gt;FAIL&lt;/code&gt;, and broadcasts a message forcing all the nodes that can be reached to flag the node as &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">ある時点で、ノードに &lt;code&gt;PFAIL&lt;/code&gt; のフラグが立てられた別のノードがあり、同時にこのノードに関する他のマスターノード&lt;em&gt;障害レポートの&lt;/em&gt;大部分（マスターの場合はそれ自体を含む）を収集すると、ノードの障害状態が上昇します。 &lt;code&gt;PFAIL&lt;/code&gt; から &lt;code&gt;FAIL&lt;/code&gt; にメッセージをブロードキャストし、到達可能なすべてのノードにノードに &lt;code&gt;FAIL&lt;/code&gt; のフラグを付けるように強制します。</target>
        </trans-unit>
        <trans-unit id="5f5470ee8997d2330c4f1d3cb52035e4a73f57ce" translate="yes" xml:space="preserve">
          <source>If count is bigger than the number of elements inside the Set, the command will only return the whole set without additional elements.</source>
          <target state="translated">countがセット内の要素数よりも大きい場合、このコマンドは追加の要素を含まないセット全体を返します。</target>
        </trans-unit>
        <trans-unit id="7166a4c2e9e0a7b189fdf30ab0234c6d47986ab4" translate="yes" xml:space="preserve">
          <source>If instead the message was already delivered to this consumer, and it is just re-fetching the same message again, then the &lt;em&gt;last delivery counter&lt;/em&gt; is updated to the current time, and the &lt;em&gt;number of deliveries&lt;/em&gt; is incremented by one. You can access those message properties using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">代わりに、メッセージがすでにこのコンシューマに配信されていて、同じメッセージを再度フェッチしているだけの場合、&lt;em&gt;最後の配信カウンタ&lt;/em&gt;が現在の時刻に更新され、&lt;em&gt;配信数が&lt;/em&gt; 1つ増えます。&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;コマンドを使用して、これらのメッセージプロパティにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="5eb7b53c8c56d77ba922276fcf8d6fc9a5555deb" translate="yes" xml:space="preserve">
          <source>If instead you want consumers to fetch the whole stream history, use zero as the starting ID for the consumer group:</source>
          <target state="translated">代わりに、コンシューマがストリームの履歴全体を取得したい場合は、コンシューマグループの開始IDとしてゼロを使用します。</target>
        </trans-unit>
        <trans-unit id="766551fe9e9ea8009a726c50e78e04cbf000fc57" translate="yes" xml:space="preserve">
          <source>If more than 25% of keys were expired, start again from step 1.</source>
          <target state="translated">鍵の有効期限が25%以上切れていた場合は、手順1からやり直してください。</target>
        </trans-unit>
        <trans-unit id="18ba579c412c6a80f5484abbbc6da80390ec5935" translate="yes" xml:space="preserve">
          <source>If multiple clients are blocked for the same key, the first client to be served is the one that was waiting for more time (the first that blocked for the key). Once a client is unblocked it does not retain any priority, when it blocks again with the next call to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; it will be served accordingly to the number of clients already blocked for the same key, that will all be served before it (from the first to the last that blocked).</source>
          <target state="translated">同じキーに対して複数のクライアントがブロックされている場合、サービスを受ける最初のクライアントは、より長い時間待っていたクライアントです（キーに対して最初にブロックされたクライアント）。クライアントがブロック解除されると、クライアントは優先度を保持せず、&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;への次の呼び出しで再びブロックすると、同じキーに対してすでにブロックされているクライアントの数に応じてサービスが提供されます。最後にブロックされた）。</target>
        </trans-unit>
        <trans-unit id="2d45448e42846cf1223f90529d7153a4f2ea7d57" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;pattern&lt;/code&gt; is specified, all the channels are listed, otherwise if pattern is specified only channels matching the specified glob-style pattern are listed.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; が指定されていない場合、すべてのチャネルがリストされます。それ以外の場合、パターンが指定されている場合、指定されたグロブスタイルのパターンに一致するチャネルのみがリストされます。</target>
        </trans-unit>
        <trans-unit id="ea2697ae6fd039b4a66dbcb2f98b8550bd0df116" translate="yes" xml:space="preserve">
          <source>If no reset type is specified, the default is &lt;strong&gt;soft&lt;/strong&gt;.</source>
          <target state="translated">リセットタイプが指定されていない場合、デフォルトは&lt;strong&gt;soft&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="7a5e1cf1e0228d3ddab066d68bd268b73f915f6a" translate="yes" xml:space="preserve">
          <source>If none of the specified keys exist, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; blocks the connection until another client performs an &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; or &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; operation against one of the keys.</source>
          <target state="translated">指定されたキーが存在しない場合、&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;は、別のクライアントが&lt;a href=&quot;lpush&quot;&gt;いずれ&lt;/a&gt;かのキーに対してLPUSHまたは&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;操作を実行するまで接続をブロックします。</target>
        </trans-unit>
        <trans-unit id="dfae9157f2f024976d442ab776949fdf1b2e1598" translate="yes" xml:space="preserve">
          <source>If one or both the members are missing, the command returns NULL.</source>
          <target state="translated">片方または両方のメンバが欠落している場合、コマンドは NULL を返します。</target>
        </trans-unit>
        <trans-unit id="4eccea0e4c99dbf5582f258e7eec112ee8e36e5c" translate="yes" xml:space="preserve">
          <source>If persistence is enabled this commands makes sure that Redis is switched off without the lost of any data. This is not guaranteed if the client uses simply &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; and then &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; because other clients may alter the DB data between the two commands.</source>
          <target state="translated">永続化が有効になっている場合、このコマンドにより、データを失うことなくRedisが確実にオフになります。他のクライアントが2つのコマンド間でDBデータを変更する可能性があるため、クライアントが単に&lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt;を使用してから&lt;a href=&quot;quit&quot;&gt;QUITを&lt;/a&gt;使用する場合、これは保証されません。</target>
        </trans-unit>
        <trans-unit id="3c4893d742c042232e8b2da1b66fa8109b95fc06" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; option is specified, the return value will be &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;:</source>
          <target state="translated">場合&lt;a href=&quot;incr&quot;&gt;INCRの&lt;/a&gt;オプションが指定され、戻り値は次のようになります&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;バルクの文字列の返信&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="48c94188363158a9ff98bf015f1ddfb2076ba94d" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;BLOCK&lt;/strong&gt; option is not used, the command is synchronous, and can be considered somewhat related to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;: it will return a range of items inside streams, however it has two fundamental differences compared to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; even if we just consider the synchronous usage:</source>
          <target state="translated">&lt;strong&gt;BLOCK&lt;/strong&gt;オプションが使用されていない場合、コマンドは同期的であり、&lt;a href=&quot;xrange&quot;&gt;XRANGEに&lt;/a&gt;いくらか関連していると見なすことができます。ストリーム内のアイテムの範囲を返しますが、同期の使用のみを考慮した場合でも、&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;と比較して2つの基本的な違いがあります。</target>
        </trans-unit>
        <trans-unit id="2a8ebc8cb8dd39729bf6fdaaa9469b8e9dd31c5f" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;FORCE&lt;/strong&gt; option is given, the replica does not perform any handshake with the master, that may be not reachable, but instead just starts a failover ASAP starting from point 4. This is useful when we want to start a manual failover while the master is no longer reachable.</source>
          <target state="translated">場合&lt;strong&gt;FORCEの&lt;/strong&gt;オプションが指定され、レプリカがマスターと任意のハンドシェイクを実行しない、それが到達可能ではないかもしれないが、その代わりただ、フェイルオーバーは、私たちがマスターしばらく手動フェールオーバーを開始したいときに便利である点4から始まるできるだけ早く開始します到達できなくなりました。</target>
        </trans-unit>
        <trans-unit id="fded77f647c95a1a86355a7eafad08fd193bd854" translate="yes" xml:space="preserve">
          <source>If the above condition happens using a Redis 2.6 server or greater, Client &lt;strong&gt;A&lt;/strong&gt; will be served with the &lt;code&gt;c&lt;/code&gt; element, because after the &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; command the list contains &lt;code&gt;c,b,a&lt;/code&gt;, so taking an element from the left means to return &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">上記の条件がRedis 2.6以降のサーバーで発生した場合、&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;コマンドの後にリストに &lt;code&gt;c,b,a&lt;/code&gt; が含まれるため、クライアント&lt;strong&gt;Aに&lt;/strong&gt;は &lt;code&gt;c&lt;/code&gt; 要素が提供されるため、左から要素を取得すると &lt;code&gt;c&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="dc531ff7f9715b58415dfa6813dab3cc7b073afd" translate="yes" xml:space="preserve">
          <source>If the approximated cardinality estimated by the HyperLogLog changed after executing the command, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; returns 1, otherwise 0 is returned. The command automatically creates an empty HyperLogLog structure (that is, a Redis String of a specified length and with a given encoding) if the specified key does not exist.</source>
          <target state="translated">コマンドの実行後に、HyperLogLogによって推定された近似カーディナリティーが変更された場合、&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;は1を返し、それ以外の場合は0を返します。指定されたキーが存在しない場合、コマンドは自動的に空のHyperLogLog構造（つまり、指定された長さと指定されたエンコーディングのRedis文字列）を作成します。</target>
        </trans-unit>
        <trans-unit id="2a7df869ee4ed74778e5142a4cec6fc019c36dbe" translate="yes" xml:space="preserve">
          <source>If the client is subscribed to a channel or a pattern, it will instead return a multi-bulk with a &quot;pong&quot; in the first position and an empty bulk in the second position, unless an argument is provided in which case it returns a copy of the argument.</source>
          <target state="translated">クライアントがチャンネルまたはパターンを購読している場合、代わりに、最初の位置に「ポン」を、2番目の位置に空のバルクを持つマルチバルクを返します。</target>
        </trans-unit>
        <trans-unit id="1e3b4ecb886491d18a97620613800a70a1d78a2c" translate="yes" xml:space="preserve">
          <source>If the client tries to blocks for multiple keys, but at least one key contains elements, the returned key / element pair is the first key from left to right that has one or more elements. In this case the client is not blocked. So for instance &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt;, assuming that both &lt;code&gt;key2&lt;/code&gt; and &lt;code&gt;key4&lt;/code&gt; are non-empty, will always return an element from &lt;code&gt;key2&lt;/code&gt;.</source>
          <target state="translated">クライアントが複数のキーをブロックしようとしたが、少なくとも1つのキーに要素が含まれている場合、返されるキー/要素のペアは、1つ以上の要素を持つ左から右への最初のキーです。この場合、クライアントはブロックされません。したがって、たとえば &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt; は、 &lt;code&gt;key2&lt;/code&gt; と &lt;code&gt;key4&lt;/code&gt; の両方が空でないと仮定すると、常に &lt;code&gt;key2&lt;/code&gt; から要素を返します。</target>
        </trans-unit>
        <trans-unit id="c4c4a551c5294109d275f4efb02ba586ea39cd4b" translate="yes" xml:space="preserve">
          <source>If the command contains multiple keys, in case none exist, the behavior is the same as point 2, if all exist, it is the same as point 1, however if only a partial number of keys exist, the command emits a &lt;code&gt;TRYAGAIN&lt;/code&gt; error in order for the keys interested to finish being migrated to the target node, so that the multi keys command can be executed.</source>
          <target state="translated">コマンドに複数のキーが含まれている場合、存在しない場合の動作はポイント2と同じです。すべてが存在する場合、ポイント1と同じですが、キーの一部しか存在しない場合、コマンドは &lt;code&gt;TRYAGAIN&lt;/code&gt; エラーを出力します。マルチキーコマンドを実行できるように、対象のキーがターゲットノードへの移行を完了するように順序付けます。</target>
        </trans-unit>
        <trans-unit id="b47c13f341545793a768bad91b706c8230117dd6" translate="yes" xml:space="preserve">
          <source>If the command is sent as part of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; transaction, the command does not block but instead just return ASAP the number of replicas that acknowledged the previous write commands.</source>
          <target state="translated">コマンドが&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;トランザクションの一部として送信される場合、コマンドはブロックせず、代わりに以前の書き込みコマンドを確認したレプリカの数をASAPに返します。</target>
        </trans-unit>
        <trans-unit id="b2647b206316067e60c5c58ad3dabbd5311d10db" translate="yes" xml:space="preserve">
          <source>If the command is successful the new incremented value is stored as the new value of the key (replacing the old one), and returned to the caller as a string.</source>
          <target state="translated">コマンドが成功した場合、新しいインクリメントされた値がキーの新しい値として保存され (古い値を置き換える)、文字列として呼び出し元に返されます。</target>
        </trans-unit>
        <trans-unit id="e13c77b4e4b0cd6a39fdb6c6dd3019929d6f047e" translate="yes" xml:space="preserve">
          <source>If the command succeeds the new replica will immediately try to contact its master in order to replicate from it.</source>
          <target state="translated">このコマンドが成功した場合、新しいレプリカはすぐにマスターに連絡して、レプリカを複製しようとします。</target>
        </trans-unit>
        <trans-unit id="58e50abae2f1a6949ff81b62d232f71c48c7e358" translate="yes" xml:space="preserve">
          <source>If the current hash slot owner is the node receiving the command, but for effect of the command the slot would be assigned to a different node, the command will return an error if there are still keys for that hash slot in the node receiving the command.</source>
          <target state="translated">現在のハッシュスロットの所有者がコマンドを受信しているノードで、コマンドの効果のためにスロットが別のノードに割り当てられている場合、コマンドを受信しているノードにそのハッシュスロットの鍵が残っている場合、コマンドはエラーを返します。</target>
        </trans-unit>
        <trans-unit id="b16a9421e847dd28010cba3e62963f9099073a99" translate="yes" xml:space="preserve">
          <source>If the elements in the sorted set have different scores, the returned elements are unspecified.</source>
          <target state="translated">ソートされた集合の要素のスコアが異なる場合、返される要素は不特定です。</target>
        </trans-unit>
        <trans-unit id="3481b2e7b6d800470df672a8874ad9a04f6afdca" translate="yes" xml:space="preserve">
          <source>If the instance is a replica, these additional fields are provided:</source>
          <target state="translated">インスタンスがレプリカの場合は、これらの追加フィールドが提供されます。</target>
        </trans-unit>
        <trans-unit id="a39168a871f5b0b2ac68a8345a687deba4b95089" translate="yes" xml:space="preserve">
          <source>If the link between master and replica is down, an additional field is provided:</source>
          <target state="translated">マスターとレプリカ間のリンクがダウンしている場合は、追加のフィールドが提供されます。</target>
        </trans-unit>
        <trans-unit id="5d43590cf68cfd82fc6f591b087a5f138a1a7c3f" translate="yes" xml:space="preserve">
          <source>If the message was never delivered to anyone, that is, if we are talking about a new message, then a PEL (Pending Entry List) is created.</source>
          <target state="translated">メッセージが誰にも配信されなかった場合、つまり新しいメッセージの話をしている場合は、PEL(Pending Entry List)が作成されます。</target>
        </trans-unit>
        <trans-unit id="638ffe7f713cb2cff80e46aae12ead14d0ec33c3" translate="yes" xml:space="preserve">
          <source>If the node is a replica it is turned into an (empty) master. Its dataset is flushed, so at the end the node will be an empty master.</source>
          <target state="translated">ノードがレプリカの場合、それは(空の)マスタになります。そのデータセットはフラッシュされるので、最後には空のマスターになります。</target>
        </trans-unit>
        <trans-unit id="1785c288c16b021950b10d9d886a7eae6f023094" translate="yes" xml:space="preserve">
          <source>If the node receiving the command is not already a replica, but is a master, the command will only succeed, and the node will be converted into a replica, only if the following additional conditions are met:</source>
          <target state="translated">コマンドを受け取ったノードが既にレプリカではなくマスターである場合、コマンドは成功し、以下の追加条件が満たされた場合にのみ、そのノードはレプリカに変換されます。</target>
        </trans-unit>
        <trans-unit id="0d7f2602b57e25d3482f6de95a393b6a52d114e4" translate="yes" xml:space="preserve">
          <source>If the object you try to inspect is missing, a null bulk reply is returned.</source>
          <target state="translated">検査しようとしたオブジェクトが見つからない場合は、NULLバルク応答が返されます。</target>
        </trans-unit>
        <trans-unit id="ed8b33783f226cf240802124131a6b3112f200a2" translate="yes" xml:space="preserve">
          <source>If the script already called write commands the only allowed command becomes &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; that stops the server without saving the current data set on disk (basically the server is aborted).</source>
          <target state="translated">スクリプトがすでに書き込みコマンドを呼び出している場合、許可される唯一のコマンドは &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; となり、現在のデータセットをディスクに保存せずにサーバーを停止します（基本的にサーバーは中止されます）。</target>
        </trans-unit>
        <trans-unit id="7d7312df2553f6628fdfae5411ba0776826d8dfb" translate="yes" xml:space="preserve">
          <source>If the script already performed write operations it can not be killed in this way because it would violate Lua script atomicity contract. In such a case only &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; is able to kill the script, killing the Redis process in an hard way preventing it to persist with half-written information.</source>
          <target state="translated">スクリプトがすでに書き込み操作を実行している場合は、Luaスクリプトの原子性規約に違反するため、この方法で強制終了することはできません。このような場合、スクリプトを &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; できるのはSHUTDOWN NOSAVEだけであり、Redisプロセスを強制的に強制終了して、半分書き込まれた情報が保持されないようにします。</target>
        </trans-unit>
        <trans-unit id="5aeedf1a85f8e143cfd4057ccfb92d5e01611feb" translate="yes" xml:space="preserve">
          <source>If the server does not remember a script with this SHA1 digest, a special error is returned telling the client to use &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; instead.</source>
          <target state="translated">サーバーがこのSHA1ダイジェストのスクリプトを覚えていない場合は、代わりに&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;を使用するようにクライアントに指示する特別なエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="8c526024cc2b0adff52463eae82153b3e7035275" translate="yes" xml:space="preserve">
          <source>If the server is configured with the &lt;code&gt;min-slaves-to-write&lt;/code&gt; (or starting with Redis 5 with the &lt;code&gt;min-replicas-to-write&lt;/code&gt;) directive, an additional field is provided:</source>
          <target state="translated">サーバーが &lt;code&gt;min-slaves-to-write&lt;/code&gt; ディレクティブで構成されている場合（またはRedis 5から &lt;code&gt;min-replicas-to-write&lt;/code&gt; を使用して開始されている場合）、追加のフィールドが提供されます。</target>
        </trans-unit>
        <trans-unit id="160c785d0bbfa994844826d34af71d6ba78bcac0" translate="yes" xml:space="preserve">
          <source>If the server still remembers a script with a matching SHA1 digest, the script is executed.</source>
          <target state="translated">一致する SHA1 ダイジェストを持つスクリプトをサーバがまだ記憶している場合、スクリプトが実行されます。</target>
        </trans-unit>
        <trans-unit id="a73ff8adff60cf3faa9396c7d82031cce8e1eee5" translate="yes" xml:space="preserve">
          <source>If the slot is in &lt;em&gt;migrating&lt;/em&gt; state, the state gets cleared when the slot is assigned to another node.</source>
          <target state="translated">スロットが&lt;em&gt;移行中の&lt;/em&gt;状態の場合、スロットが別のノードに割り当てられると、状態はクリアされます。</target>
        </trans-unit>
        <trans-unit id="4fb7824817ed0173726151921ede13e72a5a9bcf" translate="yes" xml:space="preserve">
          <source>If the slot was in &lt;em&gt;importing&lt;/em&gt; state in the node receiving the command, and the command assigns the slot to this node (which happens in the target node at the end of the resharding of a hash slot from one node to another), the command has the following side effects: A) the &lt;em&gt;importing&lt;/em&gt; state is cleared. B) If the node config epoch is not already the greatest of the cluster, it generates a new one and assigns the new config epoch to itself. This way its new hash slot ownership will win over any past configuration created by previous failovers or slot migrations.</source>
          <target state="translated">コマンドを受信するノードでスロットが&lt;em&gt;インポート&lt;/em&gt;状態であり、コマンドがこのノードにスロットを割り当てる場合（これは、あるノードから別のノードへのハッシュスロットの再シャーディングの最後にターゲットノードで発生します）、コマンドは次の副作用：A）&lt;em&gt;インポート&lt;/em&gt;状態がクリアされます。 B）ノード構成エポックがクラスターの最大のものではない場合、新しい構成エポックが生成され、それ自体に新しい構成エポックが割り当てられます。このようにして、新しいハッシュスロットの所有権は、以前のフェイルオーバーまたはスロットの移行によって作成された過去の構成よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="e8cd47d9356aab972b5f2bd3e87e1b06b6cacf48" translate="yes" xml:space="preserve">
          <source>If the source set does not exist or does not contain the specified element, no operation is performed and &lt;code&gt;0&lt;/code&gt; is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</source>
          <target state="translated">ソースセットが存在しないか、指定された要素が含まれていない場合、操作は実行されず、 &lt;code&gt;0&lt;/code&gt; が返されます。それ以外の場合、要素はソースセットから削除され、宛先セットに追加されます。指定された要素が宛先セットにすでに存在する場合、ソースセットからのみ削除されます。</target>
        </trans-unit>
        <trans-unit id="da52acca0f5817a572a7d2dfec4d48663d8d1b71" translate="yes" xml:space="preserve">
          <source>If the user inserts all the elements in a sorted set with the same score (for example 0), all the elements of the sorted set are sorted lexicographically, and range queries on elements are possible using the command &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Note: it is also possible to query sorted sets by range of scores using &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;).</source>
          <target state="translated">ユーザーが同じスコア（0など）のソート済みセットにすべての要素を挿入すると、ソート済みセットのすべての要素が辞書順にソートされ、&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;コマンドを使用して要素に対する範囲クエリが可能になります（注：&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;を使用して、スコアの範囲でソートされたセットをクエリします。</target>
        </trans-unit>
        <trans-unit id="bb5f5ae1336c1db943d20a454954235747a6d64e" translate="yes" xml:space="preserve">
          <source>If the user will be idle more than 60 seconds, the key will be deleted and only subsequent page views that have less than 60 seconds of difference will be recorded.</source>
          <target state="translated">ユーザーが60秒以上アイドル状態になると、そのキーは削除され、60秒未満の差がある後続のページビューのみが記録されます。</target>
        </trans-unit>
        <trans-unit id="dca107e1698238aa60bfb450d46b8e949be6578e" translate="yes" xml:space="preserve">
          <source>If there are no keys to migrate in the source instance &lt;code&gt;NOKEY&lt;/code&gt; is returned. Because missing keys are possible in normal conditions, from expiry for example, &lt;code&gt;NOKEY&lt;/code&gt; isn't an error.</source>
          <target state="translated">ソースインスタンスに移行するキーがない場合、 &lt;code&gt;NOKEY&lt;/code&gt; が返されます。たとえば、 &lt;code&gt;NOKEY&lt;/code&gt; などの通常の条件ではキーが欠落している可能性があるため、NOKEYはエラーではありません。</target>
        </trans-unit>
        <trans-unit id="65645be10cc140f75bd2c8251142687f4fa78461" translate="yes" xml:space="preserve">
          <source>If we generate a configuration epoch which happens to collide with another instance, eventually our configuration epoch, or the one of another instance with our same epoch, will be moved away using the &lt;em&gt;configuration epoch collision resolution algorithm&lt;/em&gt;.</source>
          <target state="translated">別のインスタンスと衝突する構成エポックを生成すると、最終的には構成エポック、または同じエポックを持つ別のインスタンスの1つが、&lt;em&gt;構成エポック衝突解決アルゴリズム&lt;/em&gt;を使用して移動され&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b6f79d56180a9ad1d3aeb8220feacf255be61da4" translate="yes" xml:space="preserve">
          <source>If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value &lt;code&gt;0xff&lt;/code&gt; the command &lt;code&gt;BITPOS key 0&lt;/code&gt; will return 24, since up to bit 23 all the bits are 1.</source>
          <target state="translated">クリアビット（ビット引数は0）を探し、文字列に1に設定されたビットのみが含まれている場合、関数は右側の文字列の一部ではない最初のビットを返します。したがって、文字列が値 &lt;code&gt;0xff&lt;/code&gt; に設定された3バイトの場合、ビット23まではすべてのビットが1であるため、コマンド &lt;code&gt;BITPOS key 0&lt;/code&gt; は24を返します。</target>
        </trans-unit>
        <trans-unit id="44b33ba5659f824ae39b000fc70d2cf7d6138c7b" translate="yes" xml:space="preserve">
          <source>If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.</source>
          <target state="translated">セットされたビット(ビットの引数が1)を探し、文字列が空か0バイトだけで構成されている場合は、-1が返されます。</target>
        </trans-unit>
        <trans-unit id="2012c008377fbb50737408462ade88dce859c2ba" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; or &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;, there's no need to manually call &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;または&lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;を呼び出す場合、手動で&lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;を呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="7adf0ee2bf057d6e4f3261ad571f6a13a6962d80" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want all the clients to get all the messages, you do not need a consumer group.</source>
          <target state="translated">ストリームと複数のクライアントを持っていて、すべてのクライアントがすべてのメッセージを取得したい場合は、消費者グループは必要ありません。</target>
        </trans-unit>
        <trans-unit id="560057ad39d223339741232ee3fcc91b0feb1edf" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;shareded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">ストリームと複数のクライアントがあり、ストリームをクライアント間で&lt;em&gt;分割&lt;/em&gt;または&lt;em&gt;共有し&lt;/em&gt;て、各クライアントがストリームに到着するメッセージのサブセットを取得できるようにする場合は、コンシューマーグループが必要です。</target>
        </trans-unit>
        <trans-unit id="b31dd57013b909fbb7b7346c7faa280640e4841b" translate="yes" xml:space="preserve">
          <source>If you like science fiction, think of time flowing at infinite speed inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block...</source>
          <target state="translated">SFが好きなら、&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;ブロック内で無限の速度で流れる時間を考えてみてください...</target>
        </trans-unit>
        <trans-unit id="c010cb9076ea01e47bb02d7ca64129ac264912a3" translate="yes" xml:space="preserve">
          <source>If you look for an &lt;code&gt;XGET&lt;/code&gt; command you'll be disappointed because &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; is effectively the way to go in order to fetch a single entry from a stream. All you have to do is to specify the ID two times in the arguments of XRANGE:</source>
          <target state="translated">あなたが探している場合 &lt;code&gt;XGET&lt;/code&gt; のコマンドので、あなたは失望するだろう&lt;a href=&quot;xrange&quot;&gt;XRANGEが&lt;/a&gt;効果的にストリームから単一のエントリをフェッチするために移動するための方法です。XRANGEの引数でIDを2回指定するだけです。</target>
        </trans-unit>
        <trans-unit id="9b173c7e7e26659d2dc21433cf73d902805a206a" translate="yes" xml:space="preserve">
          <source>If you request details about non-existing commands, their return position will be nil.</source>
          <target state="translated">存在しないコマンドの詳細を要求した場合、その戻り値はnilになります。</target>
        </trans-unit>
        <trans-unit id="12acfb0048a8a9bf03f38f7e388902128cc410f3" translate="yes" xml:space="preserve">
          <source>Imagine you have a web service and you are interested in the latest N pages &lt;em&gt;recently&lt;/em&gt; visited by your users, such that each adjacent page view was not performed more than 60 seconds after the previous. Conceptually you may consider this set of page views as a &lt;em&gt;Navigation session&lt;/em&gt; of your user, that may contain interesting information about what kind of products he or she is looking for currently, so that you can recommend related products.</source>
          <target state="translated">Webサービスがあり、ユーザーが&lt;em&gt;最近&lt;/em&gt;アクセスした最新のNページに関心があり、隣接する各ページの表示が前のページから60秒以上実行されなかったとします。概念的には、この一連のページビューをユーザーの&lt;em&gt;ナビゲーションセッション&lt;/em&gt;と見なすことができます。これには、ユーザーが現在探している製品の種類に関する興味深い情報が含まれているため、関連製品を推奨できます。</target>
        </trans-unit>
        <trans-unit id="3fb9a33bf9d1d9a11eb463de937edd8bbe41eff8" translate="yes" xml:space="preserve">
          <source>Imagine you have elements A, B and C with weights 1, 2 and 3. You compute the sum of the weights, which is 1+2+3 = 6</source>
          <target state="translated">重み1、2、3を持つ要素A、B、Cがあると想像してみてください。重みの合計を計算すると,1+2+3=6となります。</target>
        </trans-unit>
        <trans-unit id="28adac3b6124834ed39c280b45702edaf27ac85d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAITを&lt;/a&gt;実装します。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">実施内容</target>
        </trans-unit>
        <trans-unit id="11672e7162d8cdc131bd8b02c509dcb60a9d776d" translate="yes" xml:space="preserve">
          <source>Implementation details and notes</source>
          <target state="translated">実装内容と注意点</target>
        </trans-unit>
        <trans-unit id="cc7649d9b862b15149646b67450f76a9d95f07c8" translate="yes" xml:space="preserve">
          <source>Implementation details: MEET and PING packets</source>
          <target state="translated">実装の詳細。MEETパケットとPINGパケット</target>
        </trans-unit>
        <trans-unit id="c5a3d437892d8fb38c145f676153ba0009f546b9" translate="yes" xml:space="preserve">
          <source>Important: &lt;strong&gt;there is no need to use the same COUNT value&lt;/strong&gt; for every iteration. The caller is free to change the count from one iteration to the other as required, as long as the cursor passed in the next call is the one obtained in the previous call to the command.</source>
          <target state="translated">重要：反復ごとに&lt;strong&gt;同じCOUNT値を使用する必要はありません&lt;/strong&gt;。次の呼び出しで渡されたカーソルが前のコマンドの呼び出しで取得されたものである限り、呼び出し元は必要に応じて1つの反復から別の反復にカウントを自由に変更できます。</target>
        </trans-unit>
        <trans-unit id="b6980584e557c93bab34f4259447d38dd3a9c928" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are emitted in the &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output as follows:</source>
          <target state="translated">スロットのインポートと移行は、&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODESの&lt;/a&gt;出力で次のように行われます。</target>
        </trans-unit>
        <trans-unit id="50ac60eae9cbac9b1534be93c64ff4eb8e05e3df" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are provided as &lt;strong&gt;additional info&lt;/strong&gt;. If the node has a given hash slot assigned, it will be also a plain number in the list of hash slots, so clients that don't have a clue about hash slots migrations can just skip this special fields.</source>
          <target state="translated">&lt;strong&gt;追加情報&lt;/strong&gt;として、スロットのインポートと移行が提供されます。ノードに特定のハッシュスロットが割り当てられている場合、それはハッシュスロットのリストでもプレーンな番号になるため、ハッシュスロットの移行に関する手掛かりがないクライアントは、この特別なフィールドをスキップできます。</target>
        </trans-unit>
        <trans-unit id="e69ceca772f34d784aadd1c27595fdabe97b5262" translate="yes" xml:space="preserve">
          <source>In Redis 2.4 the expire might not be pin-point accurate, and it could be between zero to one seconds out.</source>
          <target state="translated">Redis 2.4では、期限切れはピンポイントで正確ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="404f7b7c02b7867c0901ee21294f6e2f5fef0d3c" translate="yes" xml:space="preserve">
          <source>In Redis 2.6 or older the command returns &lt;code&gt;-1&lt;/code&gt; if the key does not exist or if the key exist but has no associated expire.</source>
          <target state="translated">Redis 2.6以前では、キーが存在しない場合、またはキーは存在するが有効期限が関連付けられていない場合、コマンドは &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="8b69e0b775a7565070cf9c5f2db4bd807c015a5f" translate="yes" xml:space="preserve">
          <source>In Redis Cluster, each node keeps track of which master is serving a particular hash slot.</source>
          <target state="translated">Redis Clusterでは、各ノードはどのマスターが特定のハッシュスロットを提供しているかを追跡します。</target>
        </trans-unit>
        <trans-unit id="d0bdbf698aa8eaf887d7877ad1c2d9ea20b7520a" translate="yes" xml:space="preserve">
          <source>In Redis versions prior &lt;strong&gt;2.1.3&lt;/strong&gt; altering a key with an expire set using a command altering its value had the effect of removing the key entirely. This semantics was needed because of limitations in the replication layer that are now fixed.</source>
          <target state="translated">&lt;strong&gt;2.1.3&lt;/strong&gt;より前のバージョンのRedisでは、コマンドを使用して有効期限を設定してキーを変更し、その値を変更すると、キーが完全に削除されました。このセマンティクスは、現在修正されているレプリケーションレイヤーの制限のために必要でした。</target>
        </trans-unit>
        <trans-unit id="34f272b3296928896a7fa9c51b4f28ffa23b9540" translate="yes" xml:space="preserve">
          <source>In future versions of Redis it is possible that we'll trigger a node garbage collection in case a given macro-node reaches a given amount of deleted entries. Currently with the usage we anticipate for this data structure, it is not a good idea to add such complexity.</source>
          <target state="translated">Redisの将来のバージョンでは、マクロノードが削除されたエントリの量に達した場合に、ノードのガベージコレクションをトリガーする可能性があります。現在のところ、このデータ構造のために予想される使用方法では、このような複雑さを追加するのは良い考えではありません。</target>
        </trans-unit>
        <trans-unit id="420ffa2728e82649ac426218fc502611ceb5c012" translate="yes" xml:space="preserve">
          <source>In general what you should know is that setting the &lt;code&gt;appendonly&lt;/code&gt; parameter to &lt;code&gt;yes&lt;/code&gt; will start a background process to save the initial append-only file (obtained from the in memory data set), and will append all the subsequent commands on the append-only file, thus obtaining exactly the same effect of a Redis server that started with AOF turned on since the start.</source>
          <target state="translated">一般的に知っておくべきことは、 &lt;code&gt;appendonly&lt;/code&gt; パラメータを &lt;code&gt;yes&lt;/code&gt; に設定すると、バックグラウンドプロセスが開始され、最初の追加専用ファイル（メモリ内データセットから取得）が保存され、以降のすべてのコマンドが追加専用ファイルに追加されます。したがって、起動後にAOFをオンにして起動したRedisサーバーとまったく同じ効果が得られます。</target>
        </trans-unit>
        <trans-unit id="464e556758431df2768b0136fb61ecadb0a9af07" translate="yes" xml:space="preserve">
          <source>In its synchronous form, the command can get new data as long as there are more items available. However, at some point, we'll have to wait for producers of data to use &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; to push new entries inside the streams we are consuming. In order to avoid polling at a fixed or adaptive interval the command is able to block if it could not return any data, according to the specified streams and IDs, and automatically unblock once one of the requested keys accept data.</source>
          <target state="translated">同期形式では、使用可能な項目がまだある限り、コマンドは新しいデータを取得できます。ただし、ある時点で、データのプロデューサーが&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;を使用して、使用しているストリーム内に新しいエントリをプッシュするのを待つ必要があります。固定間隔または適応間隔でのポーリングを回避するために、コマンドは、指定されたストリームとIDに従ってデータを返せなかった場合にブロックし、要求されたキーの1つがデータを受け入れると自動的にブロックを解除できます。</target>
        </trans-unit>
        <trans-unit id="f71d43ee55e218973fa1e5cb6ebd10de6f4de1c3" translate="yes" xml:space="preserve">
          <source>In options where bytes or other quantities are specified, it is not possible to use the &lt;code&gt;redis.conf&lt;/code&gt; abbreviated form (&lt;code&gt;10k&lt;/code&gt;, &lt;code&gt;2gb&lt;/code&gt; ... and so forth), everything should be specified as a well-formed 64-bit integer, in the base unit of the configuration directive. However since Redis version 3.0 or greater, it is possible to use &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; with memory units for &lt;code&gt;maxmemory&lt;/code&gt;, client output buffers, and replication backlog size.</source>
          <target state="translated">バイトまたはその他の量が指定されているオプションでは、 &lt;code&gt;redis.conf&lt;/code&gt; の省略形（ &lt;code&gt;10k&lt;/code&gt; 、 &lt;code&gt;2gb&lt;/code&gt; など）を使用することはできません。すべてを整形式の64ビット整数として構成ディレクティブの基本単位。ただし、Redisバージョン3.0以降では、 &lt;code&gt;maxmemory&lt;/code&gt; 、クライアント出力バッファー、レプリケーションバックログサイズのメモリユニットで&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;を使用することが可能です。</target>
        </trans-unit>
        <trans-unit id="74befe185bf5845d0b7429c8d4ecaac4587e1561" translate="yes" xml:space="preserve">
          <source>In order to avoid these problems while avoiding the bandwidth penalty, Redis implements the &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command.</source>
          <target state="translated">帯域幅のペナルティを回避しながらこれらの問題を回避するために、Redisは&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;コマンドを実装しています。</target>
        </trans-unit>
        <trans-unit id="4e60382da8db79c78bf47f321f4d7ec3aa869b88" translate="yes" xml:space="preserve">
          <source>In order to block, the &lt;strong&gt;BLOCK&lt;/strong&gt; option is used, together with the number of milliseconds we want to block before timing out. Normally Redis blocking commands take timeouts in seconds, however this command takes a millisecond timeout, even if normally the server will have a timeout resolution near to 0.1 seconds. This time it is possible to block for a shorter time in certain use cases, and if the server internals will improve over time, it is possible that the resolution of timeouts will improve.</source>
          <target state="translated">ブロックするには、&lt;strong&gt;BLOCK&lt;/strong&gt;オプションと、タイムアウトする前にブロックするミリ秒数を使用します。通常、Redisブロッキングコマンドはタイムアウトを秒単位で取得しますが、通常、サーバーのタイムアウトが0.1秒に近い場合でも、このコマンドはミリ秒のタイムアウトを取得します。今回は、特定のユースケースでより短い時間ブロックすることが可能であり、サーバーの内部が時間とともに改善する場合、タイムアウトの解決が改善する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0040f93cb8c4b8bdab630ff12697ba1b0160ca64" translate="yes" xml:space="preserve">
          <source>In order to enable script effects replication, you need to issue the following Lua command before any write operated by the script:</source>
          <target state="translated">スクリプト効果のレプリケーションを有効にするには、スクリプトが操作する書き込みの前に以下のLuaコマンドを発行する必要があります。</target>
        </trans-unit>
        <trans-unit id="013756f6d564f805aee9f75f0b5914a1c30d7b5d" translate="yes" xml:space="preserve">
          <source>In order to enable this form, the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option is used, and the normal &lt;em&gt;key&lt;/em&gt; argument is set to an empty string. The actual key names will be provided after the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; argument itself, like in the following example:</source>
          <target state="translated">このフォームを有効にするには、&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;オプションを使用し、通常の&lt;em&gt;キー&lt;/em&gt;引数を空の文字列に設定します。実際のキー名は、次の例のように、&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;引数自体の後に提供されます。</target>
        </trans-unit>
        <trans-unit id="7e7cf3fffb86f4198755cdccfe390f7daca4376b" translate="yes" xml:space="preserve">
          <source>In order to enforce this behavior in scripts Redis does the following:</source>
          <target state="translated">この動作をスクリプトで強制するために、Redisは以下のようにしています。</target>
        </trans-unit>
        <trans-unit id="4210ec3e973c5d5ac271cc1ab7ffcffaa3f2c4da" translate="yes" xml:space="preserve">
          <source>In order to fix a broken cluster where certain slots are unassigned.</source>
          <target state="translated">特定のスロットが割り当てられていない壊れたクラスタを修正するために。</target>
        </trans-unit>
        <trans-unit id="4708216948f38c6f376d2b00aef53c77bfc810bd" translate="yes" xml:space="preserve">
          <source>In order to iterate a stream, we can proceed as follows. Let's assume that we want two elements per iteration. We start fetching the first two elements, which is trivial:</source>
          <target state="translated">ストリームの反復処理を行うには、以下のように進めます。反復ごとに2つの要素が必要な場合を想定してみましょう。最初の2つの要素の取得を開始しますが、これは些細なことです。</target>
        </trans-unit>
        <trans-unit id="93f82278196654b93d4f14013ea15fe416b7d299" translate="yes" xml:space="preserve">
          <source>In order to make it a pure function, but still be sure that every invocation of the script will result in different random elements, we can simply add an additional argument to the script that will be used in order to seed the Lua pseudo-random number generator. The new script is as follows:</source>
          <target state="translated">これを純粋な関数にしつつも、スクリプトを実行するたびに異なるランダム要素が得られるようにするために、スクリプトに追加の引数を追加するだけで、Lua擬似乱数発生器の種付けに使用することができます。新しいスクリプトは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5e754dbb6b6073549994be57928409b8a9518fbf" translate="yes" xml:space="preserve">
          <source>In order to make sure the redis.conf file is always consistent, that is, on errors or crashes you always end with the old file, or the new one, the rewrite is performed with a single &lt;code&gt;write(2)&lt;/code&gt; call that has enough content to be at least as big as the old file. Sometimes additional padding in the form of comments is added in order to make sure the resulting file is big enough, and later the file gets truncated to remove the padding at the end.</source>
          <target state="translated">redis.confファイルが常に一貫していることを確認するために、つまり、エラーまたはクラッシュが発生すると、常に古いファイルまたは新しいファイルで終了します。書き換えは、十分なコンテンツを持つ単一の &lt;code&gt;write(2)&lt;/code&gt; 呼び出しで実行されます。少なくとも古いファイルと同じ大きさになるようにします。結果のファイルが十分に大きいことを確認するために、コメント形式の追加のパディングが追加される場合があります。その後、ファイルが切り捨てられて、末尾のパディングが削除されます。</target>
        </trans-unit>
        <trans-unit id="45b71d9b591350682c94742bdef7ff99466f0e92" translate="yes" xml:space="preserve">
          <source>In order to make this locking algorithm more robust, a client holding a lock should always check the timeout didn't expire before unlocking the key with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; because client failures can be complex, not just crashing but also blocking a lot of time against some operations and trying to issue &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; after a lot of time (when the LOCK is already held by another client).</source>
          <target state="translated">このロックアルゴリズムをより堅牢にするために、ロックを保持しているクライアントは、&lt;a href=&quot;del&quot;&gt;DELで&lt;/a&gt;キーのロックを解除する前に、タイムアウトが期限切れになっていないことを常に確認する必要があります。そして、しばらくしてから&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;を発行しようとします（LOCKがすでに別のクライアントによって保持されている場合）。</target>
        </trans-unit>
        <trans-unit id="26d3078f4ebbdf0701299addb5fed6bbed540a2c" translate="yes" xml:space="preserve">
          <source>In order to obtain a correct behavior without sacrificing consistency, when a key expires, a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation is synthesized in both the AOF file and gains all the attached replicas nodes. This way the expiration process is centralized in the master instance, and there is no chance of consistency errors.</source>
          <target state="translated">一貫性を犠牲にすることなく正しい動作を実現するために、キーの有効期限が切れると、&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;操作がAOFファイルで合成され、接続されているすべてのレプリカノードを取得します。このようにして、有効期限プロセスはマスターインスタンスに集中化され、一貫性エラーの可能性はありません。</target>
        </trans-unit>
        <trans-unit id="40403839cd4ec5549ce4c8b0b88fe76bd596deee" translate="yes" xml:space="preserve">
          <source>In other words there is a one-to-one conversion between Lua and Redis types. The following table shows you all the conversions rules:</source>
          <target state="translated">つまり、LuaとRedisの型の間には一対一の変換があります。以下の表は、すべての変換ルールを示しています。</target>
        </trans-unit>
        <trans-unit id="73283192b40f30e6bf23bca973e203da21ec7a06" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should mainly used in order to, if needed, separate different keys belonging to the same application, and not in order to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">実用的には、Redisデータベースは主に、必要に応じて同じアプリケーションに属する異なる鍵を分離するために使用されるべきであり、1つのRedisインスタンスを関連性のない複数のアプリケーションに使用するために使用されるべきではありません。</target>
        </trans-unit>
        <trans-unit id="1cb1bb56f86e93948082da017865db052e971cd7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COUNT&lt;/code&gt; option documentation, we state that sometimes this family of commands may return all the elements of a Set, Hash or Sorted Set at once in a single call, regardless of the &lt;code&gt;COUNT&lt;/code&gt; option value. The reason why this happens is that the cursor-based iterator can be implemented, and is useful, only when the aggregate data type that we are scanning is represented as an hash table. However Redis uses a &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;memory optimization&lt;/a&gt; where small aggregate data types, until they reach a given amount of items or a given max size of single elements, are represented using a compact single-allocation packed encoding. When this is the case, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has no meaningful cursor to return, and must iterate the whole data structure at once, so the only sane behavior it has is to return everything in a call.</source>
          <target state="translated">では &lt;code&gt;COUNT&lt;/code&gt; の時々コマンドのこの家族は関係なく、単一の呼び出しで一度に設定し、ハッシュまたはソートセットのすべての要素を返すことがオプションのマニュアル、我々の状態 &lt;code&gt;COUNT&lt;/code&gt; のオプション値。これが発生する理由は、カーソルベースのイテレータを実装でき、スキャンする集計データ型がハッシュテーブルとして表される場合にのみ有用であるためです。ただし、Redisは&lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;メモリの最適化を&lt;/a&gt;使用して、特定のアイテム数または単一の要素の特定の最大サイズに達するまで、小さな集計データ型をコンパクトな単一割り当てのパックエンコーディングを使用して表現します。この場合、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 返す意味のあるカーソルはなく、一度にデータ構造全体を反復処理する必要があるため、呼び出しですべてを返すのが唯一の正常な動作です。</target>
        </trans-unit>
        <trans-unit id="8c0e05b70b67e4b92ac3373b78b09162115732be" translate="yes" xml:space="preserve">
          <source>In the above case the entry &lt;code&gt;1526985054069-0&lt;/code&gt; exists, otherwise the server would have sent us the next one. Using &lt;code&gt;COUNT&lt;/code&gt; is also the base in order to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; as an iterator.</source>
          <target state="translated">上記の場合、エントリ &lt;code&gt;1526985054069-0&lt;/code&gt; が存在します。それ以外の場合、サーバーは次のエントリを送信します。使用 &lt;code&gt;COUNT&lt;/code&gt; はまた、使用するために塩基である&lt;a href=&quot;xrange&quot;&gt;XRANGEを&lt;/a&gt;イテレータとして。</target>
        </trans-unit>
        <trans-unit id="f40be215733bf9374d8b827188eeddff85363cc0" translate="yes" xml:space="preserve">
          <source>In the above example of counting days, even after 10 years the application is online we still have just &lt;code&gt;365*10&lt;/code&gt; bits of data per user, that is just 456 bytes per user. With this amount of data &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; is still as fast as any other O(1) Redis command like &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; or &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;.</source>
          <target state="translated">上記の日数を数える例では、アプリケーションがオンラインになった後10年経過しても、ユーザーあたりのデータは &lt;code&gt;365*10&lt;/code&gt; ビットであり、ユーザーあたりのバイト数は456バイトです。このデータ量でも、&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;は、&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;や&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;などの他のO（1）Redisコマンドと同じくらい高速です。</target>
        </trans-unit>
        <trans-unit id="76a0365bc0972ed4321b2f354ddf621810b8b004" translate="yes" xml:space="preserve">
          <source>In the above example we claim the message with ID &lt;code&gt;1526569498055-0&lt;/code&gt;, only if the message is idle for at least one hour without the original consumer or some other consumer making progresses (acknowledging or claiming it), and assigns the ownership to the consumer &lt;code&gt;Alice&lt;/code&gt;.</source>
          <target state="translated">上記の例では、メッセージがID &lt;code&gt;1526569498055-0&lt;/code&gt; であると主張します。メッセージが少なくとも1時間アイドル状態で、元のコンシューマーまたは他のコンシューマーが進行（承認または主張）していない場合に限り、所有権をコンシューマー &lt;code&gt;Alice&lt;/code&gt; に割り当てます。。</target>
        </trans-unit>
        <trans-unit id="0bef89cf285951fc9b88c842b027336864d10794" translate="yes" xml:space="preserve">
          <source>In the above example you can see that the reported information are the number of elements of the stream, details about the radix tree representing the stream mostly useful for optimization and debugging tasks, the number of consumer groups associated with the stream, the last generated ID that may not be the same as the last entry ID in case some entry was deleted. Finally the full first and last entry in the stream are shown, in order to give some sense about what is the stream content.</source>
          <target state="translated">上記の例では、ストリームの要素数、ストリームを表す基底木の詳細、ストリームに関連付けられたコンシューマグループの数、最後に生成された ID (エントリが削除された場合には最後のエントリ ID と同じではない可能性があります)が報告されていることがわかります。最後に、ストリームの完全な最初のエントリと最後のエントリが表示され、ストリームの内容が何であるかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="5e1f5dbd04f5dc1db0a038c0d0e6f0ff4a4acd34" translate="yes" xml:space="preserve">
          <source>In the above locking algorithm there is a problem: what happens if a client fails, crashes, or is otherwise not able to release the lock? It's possible to detect this condition because the lock key contains a UNIX timestamp. If such a timestamp is equal to the current Unix time the lock is no longer valid.</source>
          <target state="translated">上記のロックアルゴリズムには問題があります:クライアントが失敗したり、クラッシュしたり、 ロックを解除できなかったりした場合はどうなるのでしょうか? ロックキーにはUNIXタイムスタンプが含まれているので、この状態を検出することができます。そのようなタイムスタンプが現在の Unix 時間と等しい場合、ロックはもはや有効ではありません。</target>
        </trans-unit>
        <trans-unit id="7063c49f04f76f5d83a38b2826e82b8706b19e78" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;, keys are every other position so the step value is 2. Compare with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; above where the step value is just 1.</source>
          <target state="translated">&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;の場合、キーは1つおきの位置にあるため、ステップ値は2です。ステップ値が1である上記の&lt;a href=&quot;mget&quot;&gt;MGETと&lt;/a&gt;比較してください。</target>
        </trans-unit>
        <trans-unit id="51cf6b9278dbdee20c8485961f1e557cd7119742" translate="yes" xml:space="preserve">
          <source>In the context of a node that has received a &lt;code&gt;DELSLOTS&lt;/code&gt; command and has consequently removed the associations for the passed hash slots, we say those hash slots are &lt;em&gt;unbound&lt;/em&gt;. Note that the existence of unbound hash slots occurs naturally when a node has not been configured to handle them (something that can be done with the &lt;code&gt;ADDSLOTS&lt;/code&gt; command) and if it has not received any information about who owns those hash slots (something that it can learn from heartbeat or update messages).</source>
          <target state="translated">&lt;code&gt;DELSLOTS&lt;/code&gt; コマンドを受信し、その結果、渡されたハッシュスロットの関連付けが削除されたノードのコンテキストでは、それらのハッシュスロットは&lt;em&gt;バインドされてい&lt;/em&gt;ませ&lt;em&gt;ん&lt;/em&gt;。バインドされていないハッシュスロットの存在は、ノードがそれらを処理するように構成されていない場合（ &lt;code&gt;ADDSLOTS&lt;/code&gt; コマンドで実行できるもの）、およびそれらのハッシュスロットの所有者に関する情報（受信可能なもの）を受信して​​いない場合に自然に発生します。ハートビートまたは更新メッセージから学ぶ）。</target>
        </trans-unit>
        <trans-unit id="0c3893e92cc9396f13c9f99b5e7ad611d2ac46c2" translate="yes" xml:space="preserve">
          <source>In the context of a stream consumer group, this command changes the ownership of a pending message, so that the new owner is the consumer specified as the command argument. Normally this is what happens:</source>
          <target state="translated">ストリーム・コンシューマ・グループのコンテキストでは、このコマンドは保留中のメッセージの所有者を変更し、新しい所有者はコマンド引数で指定されたコンシューマになります。通常はこのようになります。</target>
        </trans-unit>
        <trans-unit id="57bf1b4701a5c94880ee6e46bfe56ac8c7000db8" translate="yes" xml:space="preserve">
          <source>In the example above, the first call uses zero as a cursor, to start the iteration. The second call uses the cursor returned by the previous call as the first element of the reply, that is, 17.</source>
          <target state="translated">上の例では、最初の呼び出しではゼロをカーソルとして使用して反復を開始します。2回目の呼び出しでは、前の呼び出しで返されたカーソルを応答の最初の要素、つまり17として使用します。</target>
        </trans-unit>
        <trans-unit id="64f37e2cb3f5829eb3ba5c3a4f7f3eea2d872acc" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there are detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">拡張されたフォームでは、要約情報は表示されなくなり、代わりに保留中のエントリリストの各メッセージの詳細情報が表示されます。各メッセージに対して、4つの属性が返されます。</target>
        </trans-unit>
        <trans-unit id="bec3c889a89e0a9bff423ca26bc6e8f597b12b82" translate="yes" xml:space="preserve">
          <source>In the following example the first call to &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not use a timeout and asks for the write to reach 1 replica. It returns with success. In the second attempt instead we put a timeout, and ask for the replication of the write to two replicas. Since there is a single replica available, after one second &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; unblocks and returns 1, the number of replicas reached.</source>
          <target state="translated">次の例では、&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;への最初の呼び出しはタイムアウトを使用せず、1つのレプリカに到達するための書き込みを要求します。成功して帰ってきました。代わりに、2回目の試行でタイムアウトを設定し、2つのレプリカへの書き込みのレプリケーションを要求します。使用可能なレプリカが1つあるため、1秒の&lt;a href=&quot;wait&quot;&gt;WAITが&lt;/a&gt;ブロックを解除して1を返した後、レプリカの数に達しました。</target>
        </trans-unit>
        <trans-unit id="275502ca7bb30b2b024cd13d4001c3a1615096d6" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays with nils are handled:</source>
          <target state="translated">次の例では、nilsを持つfloatと配列がどのように処理されるかを見ることができます。</target>
        </trans-unit>
        <trans-unit id="67aa25f5afe2285456ce925944008c892a8bde6a" translate="yes" xml:space="preserve">
          <source>In the following example we'll show why the command must not just remove a given node from the nodes table, but also prevent it for being re-inserted again for some time.</source>
          <target state="translated">以下の例では、コマンドがノードテーブルから指定されたノードを削除するだけでなく、それがしばらくの間再挿入されないようにする必要がある理由を示します。</target>
        </trans-unit>
        <trans-unit id="1b27ba03d8db2c5155774200622adb0e3f3e2724" translate="yes" xml:space="preserve">
          <source>In the following example you can see how the encoding changes once Redis is no longer able to use the space saving encoding.</source>
          <target state="translated">以下の例では、Redisが省スペースエンコーディングを使用できなくなった後、エンコーディングがどのように変化するかを見ることができます。</target>
        </trans-unit>
        <trans-unit id="d52481dfbaf58234ade345bdada825c509d89e9a" translate="yes" xml:space="preserve">
          <source>In the specific case of the implementation of &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;, Redis remembers, for each client, the replication offset of the produced replication stream when a given write command was executed in the context of a given client. When &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; is called Redis checks if the specified number of replicas already acknowledged this offset or a greater one.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;の実装の特定のケースでは、Redisは各クライアントについて、特定のクライアントのコンテキストで特定の書き込みコマンドが実行されたときに生成されたレプリケーションストリームのレプリケーションオフセットを記憶しています。とき&lt;a href=&quot;wait&quot;&gt;WAITは、&lt;/a&gt;レプリカの指定された数は既にこのオフセット以上のものを認めた場合はRedisのチェックと呼ばれています。</target>
        </trans-unit>
        <trans-unit id="903ead95cd2a4a5b9cbb852a8e750aedc79fee51" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; will auto-complete the start interval with &lt;code&gt;-0&lt;/code&gt; and end interval with &lt;code&gt;-18446744073709551615&lt;/code&gt;, in order to return all the entries that were generated between a given millisecond and the end of the other specified millisecond. This also means that repeating the same millisecond two times, we get all the entries within such millisecond, because the sequence number range will be from zero to the maximum.</source>
          <target state="translated">この場合、&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;は、指定されたミリ秒から指定された他のミリ秒の終わりまでの間に生成されたすべてのエントリを返すために、開始間隔を &lt;code&gt;-0&lt;/code&gt; で、終了間隔を &lt;code&gt;-18446744073709551615&lt;/code&gt; で自動補完します。これは、同じミリ秒を2回繰り返すと、シーケンス番号の範囲がゼロから最大になるため、そのようなミリ秒以内にすべてのエントリを取得することも意味します。</target>
        </trans-unit>
        <trans-unit id="9a9dd8640d5d9c354f3497144f8f471bfe5130bf" translate="yes" xml:space="preserve">
          <source>In this form the command returns general information about the stream stored at the specified key.</source>
          <target state="translated">この形式では、コマンドは指定されたキーに格納されているストリームに関する一般的な情報を返します。</target>
        </trans-unit>
        <trans-unit id="d9dc316159e0ab75070b1301d7b7adb86e569cda" translate="yes" xml:space="preserve">
          <source>In this form we just get as output all the consumer groups associated with the stream:</source>
          <target state="translated">この形式では、ストリームに関連付けられたすべての消費者グループを出力として取得するだけです。</target>
        </trans-unit>
        <trans-unit id="ddaa9f098110e2f5ed979aa965f072762268f6b4" translate="yes" xml:space="preserve">
          <source>In this form, the command outputs the total number of pending messages for this consumer group, which is one, followed by the smallest and greatest ID among the pending messages, and then list every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</source>
          <target state="translated">本実施形態では、コマンドは、このコンシューマ・グループの保留メッセージの合計数を1とし、保留メッセージの中で最も小さいIDと最も大きいIDの後に、保留メッセージが少なくとも1つあるコンシューマ・グループ内の全てのコンシューマをリストアップし、それが持っている保留メッセージの数を出力する。</target>
        </trans-unit>
        <trans-unit id="7449f50cc271410bffecdb508cde8a6a6c5d9a68" translate="yes" xml:space="preserve">
          <source>In this particular case, running a single &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; client can reduce the throughput by more than 50%. Running more &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; clients will reduce throughput even more.</source>
          <target state="translated">この特定のケースでは、単一の&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;クライアントを実行すると、スループットが50％以上減少する可能性があります。より多くの&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;クライアントを実行すると、スループットがさらに低下します。</target>
        </trans-unit>
        <trans-unit id="9499b337b96eb666a58f2a5ab4a4329e2007a622" translate="yes" xml:space="preserve">
          <source>In this replication mode, while Lua scripts are executed, Redis collects all the commands executed by the Lua scripting engine that actually modify the dataset. When the script execution finishes, the sequence of commands that the script generated are wrapped into a MULTI / EXEC transaction and are sent to replicas and AOF.</source>
          <target state="translated">このレプリケーションモードでは、Luaスクリプトが実行されている間、RedisはLuaスクリプトエンジンが実行したコマンドのうち、実際にデータセットを修正するものをすべて収集します。スクリプトの実行が終了すると、スクリプトが生成した一連のコマンドはMULTI/EXECトランザクションにラップされ、レプリカやAOFに送信されます。</target>
        </trans-unit>
        <trans-unit id="ef44dcb3d65131c01d1f4f06af638521f8511b76" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing and ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">このようにして、サンプルのコンシューマコードは新しいメッセージのみをフェッチし、それらを処理して、&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;を介してそれらを確認します。ただし、上記のサンプルコードは、クラッシュ後の回復を処理しないため、完全ではありません。メッセージの処理中にクラッシュした場合、メッセージは保留中のエントリのリストに残るため、最初に&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;に0のIDを指定し、同じループを実行することで履歴にアクセスできます。 IDが0になると、応答は空のメッセージセットになります。保留中のすべてのメッセージを処理して確認したことがわかります。 &lt;code&gt;&amp;gt;&lt;/code&gt; をIDとして使用して、新しいメッセージを取得し、処理中のコンシューマーに再参加できます。新しいもの。</target>
        </trans-unit>
        <trans-unit id="0c6aff080ab580caca11c078c7c0fd0c074cc4b5" translate="yes" xml:space="preserve">
          <source>In this way when a node in migrating state generates an &lt;code&gt;ASK&lt;/code&gt; redirection, the client contacts the target node, sends &lt;code&gt;ASKING&lt;/code&gt;, and immediately after sends the command. This way commands about non-existing keys in the old node or keys already migrated to the target node are executed in the target node, so that:</source>
          <target state="translated">このようにして、移行状態のノードが &lt;code&gt;ASK&lt;/code&gt; リダイレクトを生成すると、クライアントはターゲットノードに接続し、 &lt;code&gt;ASKING&lt;/code&gt; を送信し、直後にコマンドを送信します。このようにして、古いノードに存在しないキーまたはターゲットノードに既に移行されたキーに関するコマンドがターゲットノードで実行され、次のようになります。</target>
        </trans-unit>
        <trans-unit id="8a4976fd385ad81414ef5f0b5eb1d542ebee200c" translate="yes" xml:space="preserve">
          <source>Incomplete IDs</source>
          <target state="translated">不完全なID</target>
        </trans-unit>
        <trans-unit id="d076531fdc3e2f8747b11778603627c7ff4c3c03" translate="yes" xml:space="preserve">
          <source>Increment the specified &lt;code&gt;field&lt;/code&gt; of a hash stored at &lt;code&gt;key&lt;/code&gt;, and representing a floating point number, by the specified &lt;code&gt;increment&lt;/code&gt;. If the increment value is negative, the result is to have the hash field value &lt;strong&gt;decremented&lt;/strong&gt; instead of incremented. If the field does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納され、浮動小数点数を表すハッシュの指定された &lt;code&gt;field&lt;/code&gt; を、指定された &lt;code&gt;increment&lt;/code&gt; だけ増分します。増分値が負の場合、結果はハッシュフィールド値が増分されるのではなく&lt;strong&gt;減分さ&lt;/strong&gt;れます。フィールドが存在しない場合は、操作を実行する前に &lt;code&gt;0&lt;/code&gt; に設定されます。次のいずれかの条件が発生すると、エラーが返されます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b2569a3073ebcb62549ecb7ec5a99e5e6f20a57" translate="yes" xml:space="preserve">
          <source>Increment the string representing a floating point number stored at &lt;code&gt;key&lt;/code&gt; by the specified &lt;code&gt;increment&lt;/code&gt;. By using a negative &lt;code&gt;increment&lt;/code&gt; value, the result is that the value stored at the key is decremented (by the obvious properties of addition). If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている浮動小数点数を表す文字列を、指定された &lt;code&gt;increment&lt;/code&gt; 。負の &lt;code&gt;increment&lt;/code&gt; を使用すると、キーに格納された値が（明らかな加算特性により）減ります。キーが存在しない場合は、操作を実行する前に &lt;code&gt;0&lt;/code&gt; に設定されます。次のいずれかの条件が発生すると、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="b0ab00f78f69567a82e2e724fbf2c011708c66b2" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; does not exist the value is set to &lt;code&gt;0&lt;/code&gt; before the operation is performed.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているハッシュの &lt;code&gt;field&lt;/code&gt; に格納されている数を &lt;code&gt;increment&lt;/code&gt; だけ増分します。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、ハッシュを保持する新しいキーが作成されます。場合は &lt;code&gt;field&lt;/code&gt; 値が存在しないに設定されて &lt;code&gt;0&lt;/code&gt; 操作が実行される前に。</target>
        </trans-unit>
        <trans-unit id="05fa8f17b5cc5360627e65f0e1bfbcb74f909616" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">格納されている番号インクリメント &lt;code&gt;key&lt;/code&gt; により &lt;code&gt;increment&lt;/code&gt; 。キーが存在しない場合は、操作を実行する前に &lt;code&gt;0&lt;/code&gt; に設定されます。キーに誤ったタイプの値が含まれている場合、または整数として表現できない文字列が含まれている場合は、エラーが返されます。この操作は64ビットの符号付き整数に制限されています。</target>
        </trans-unit>
        <trans-unit id="f9bd9898aaa3a2048914100ede9b89ccf7adc73a" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている数を1 増やします。キーが存在しない場合は、操作を実行する前に &lt;code&gt;0&lt;/code&gt; に設定されます。キーに誤ったタイプの値が含まれている場合、または整数として表現できない文字列が含まれている場合は、エラーが返されます。この操作は64ビットの符号付き整数に制限されています。</target>
        </trans-unit>
        <trans-unit id="b3b4497f3f9f641c1f07a98ba2294810e7c1c3a5" translate="yes" xml:space="preserve">
          <source>Increments the score of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, it is added with &lt;code&gt;increment&lt;/code&gt; as its score (as if its previous score was &lt;code&gt;0.0&lt;/code&gt;). If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified &lt;code&gt;member&lt;/code&gt; as its sole member is created.</source>
          <target state="translated">増分のスコア &lt;code&gt;member&lt;/code&gt; に格納されたソートセット内 &lt;code&gt;key&lt;/code&gt; によって &lt;code&gt;increment&lt;/code&gt; 。場合 &lt;code&gt;member&lt;/code&gt; ソートセットに存在しない、それが付加され &lt;code&gt;increment&lt;/code&gt; （以前のスコアであったかのようにそのスコアとして &lt;code&gt;0.0&lt;/code&gt; ）。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、指定された &lt;code&gt;member&lt;/code&gt; を唯一のメンバーとする新しいソートセットが作成されます。</target>
        </trans-unit>
        <trans-unit id="b9e98de9b6972c3697024196bb1cf498f5df1583" translate="yes" xml:space="preserve">
          <source>Information about slots propagation and warnings</source>
          <target state="translated">スロットの伝播と警告に関する情報</target>
        </trans-unit>
        <trans-unit id="df92aa3b0e06eb79bf7c8f7098db769523ac9333" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operations. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの先頭に、指定されたすべての値を挿入します。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、プッシュ操作を実行する前に空のリストとして作成されます。ときに &lt;code&gt;key&lt;/code&gt; リストではない値を保持し、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="d56f1eeeec0b6889ab12fc76a629d9cf4f377993" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operation. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの末尾に、指定されたすべての値を挿入します。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、プッシュ操作を実行する前に空のリストとして作成されます。ときに &lt;code&gt;key&lt;/code&gt; リストではない値を保持し、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="41914bb38b36cf790ad6dea5c850ff4f739bdf2f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの先頭に &lt;code&gt;value&lt;/code&gt; を挿入します。ただし、 &lt;code&gt;key&lt;/code&gt; がすでに存在し、リストを保持している場合のみです。反して&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;とき、何も操作は行われません &lt;code&gt;key&lt;/code&gt; まだ存在していません。</target>
        </trans-unit>
        <trans-unit id="483c4cdd37e1303cef072b494af9c173f5ba1e3a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの末尾に &lt;code&gt;value&lt;/code&gt; を挿入します。ただし、 &lt;code&gt;key&lt;/code&gt; が既に存在し、リストを保持している場合のみです。&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;とは逆に、 &lt;code&gt;key&lt;/code&gt; がまだ存在しない場合は何も実行されません。</target>
        </trans-unit>
        <trans-unit id="d817081530a979658954b262ec5b27debd913f6b" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 格納されているリストの &lt;code&gt;value&lt;/code&gt; を、参照値 &lt;code&gt;pivot&lt;/code&gt; 前または後に挿入します。</target>
        </trans-unit>
        <trans-unit id="0b2cd21b122572712ccbe21dcfb324c039d60a6f" translate="yes" xml:space="preserve">
          <source>Instead Redis 2.4 works in a different way: clients are served &lt;em&gt;in the context&lt;/em&gt; of the push operation, so as long as &lt;code&gt;LPUSH foo a b c&lt;/code&gt; starts pushing the first element to the list, it will be delivered to the Client &lt;strong&gt;A&lt;/strong&gt;, that will receive &lt;code&gt;a&lt;/code&gt; (the first element pushed).</source>
          <target state="translated">別の方法で代わりのRedis 2.4作品：クライアントが提供されている&lt;em&gt;文脈に&lt;/em&gt;そう限り、プッシュ操作の &lt;code&gt;LPUSH foo a b c&lt;/code&gt; 、リストの最初の要素をプッシュ開始し、それがクライアントに配信されます&lt;strong&gt;A&lt;/strong&gt;、受け取ることになります（プッシュされた最初の要素）。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="895d5878b1e7aebe2b652bf4030490cc648a385d" translate="yes" xml:space="preserve">
          <source>Instead of releasing the lock with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, send a script that only removes the key if the value matches.</source>
          <target state="translated">&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;でロックを解除する代わりに、値が一致した場合にのみキーを削除するスクリプトを送信します。</target>
        </trans-unit>
        <trans-unit id="e1fb6600644f1089e2f02671b1d169470ef167d3" translate="yes" xml:space="preserve">
          <source>Instead of setting a fixed string, set a non-guessable large random string, called token.</source>
          <target state="translated">固定文字列を設定する代わりに、トークンと呼ばれる推測不可能な大きなランダム文字列を設定します。</target>
        </trans-unit>
        <trans-unit id="7e8138295a5156481cc0eb58921ff5f1b45d907b" translate="yes" xml:space="preserve">
          <source>Instead, if the lock is expired because the Unix time at &lt;code&gt;lock.foo&lt;/code&gt; is older than the current Unix time, C4 tries to perform:</source>
          <target state="translated">代わりに、 &lt;code&gt;lock.foo&lt;/code&gt; のUnix時間が現在のUnix時間より古いためにロックが期限切れになった場合、C4は次のことを実行しようとします。</target>
        </trans-unit>
        <trans-unit id="9e41d77e11789212e3a04485592bea0019722472" translate="yes" xml:space="preserve">
          <source>Instruct Redis to start an &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; rewrite process. The rewrite will create a small optimized version of the current Append Only File.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;追加のみのファイルの&lt;/a&gt;書き換えプロセスを開始するようにRedisに指示します。書き換えにより、現在の追加専用ファイルの小さな最適化バージョンが作成されます。</target>
        </trans-unit>
        <trans-unit id="5d3a484e0575c563f1fd55a805b93fd40c42e60d" translate="yes" xml:space="preserve">
          <source>Integer reply</source>
          <target state="translated">整数応答</target>
        </trans-unit>
        <trans-unit id="b78aed63c34c1be3f06c6bc59978ffe5ffe055ac" translate="yes" xml:space="preserve">
          <source>Introduction to EVAL</source>
          <target state="translated">エバールの紹介</target>
        </trans-unit>
        <trans-unit id="698c191721344bee0279a531fba2023586cfe9e4" translate="yes" xml:space="preserve">
          <source>It can also take the following values:</source>
          <target state="translated">また、以下の値を取ることもできます。</target>
        </trans-unit>
        <trans-unit id="35178e7f69534d7802151005b608f5f33b33d650" translate="yes" xml:space="preserve">
          <source>It contains a 64-bit checksum that is used to make sure errors will be detected. The &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command makes sure to check the checksum before synthesizing a key using the serialized value.</source>
          <target state="translated">エラーが確実に検出されるようにするために使用される64ビットのチェックサムが含まれています。&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;コマンドは、シリアル化された値を使用してキーを合成する前にチェックサムを確認してくださいます。</target>
        </trans-unit>
        <trans-unit id="d3cca1eb042dc5b5456d254387aa0bc9411f0e98" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to understand that you should use the &lt;code&gt;$&lt;/code&gt; ID only for the first call to &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;. Later the ID should be the one of the last reported item in the stream, otherwise you could miss all the entries that are added in between.</source>
          <target state="translated">&lt;a href=&quot;xread&quot;&gt;XIDの&lt;/a&gt;最初の呼び出しにのみ &lt;code&gt;$&lt;/code&gt; ID を使用する必要があることを理解することは&lt;strong&gt;非常に重要&lt;/strong&gt;です。後で、IDはストリームで最後に報告された項目の1つになるはずです。そうしないと、間に追加されたすべてのエントリを見逃す可能性があります。</target>
        </trans-unit>
        <trans-unit id="80e58a0abe147b5052a4b292609ed6e990761a9f" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;GET&lt;/code&gt; the element itself using the special pattern &lt;code&gt;#&lt;/code&gt;:</source>
          <target state="translated">特別なパターン &lt;code&gt;#&lt;/code&gt; を使用して要素自体を &lt;code&gt;GET&lt;/code&gt; することもできます。</target>
        </trans-unit>
        <trans-unit id="344f6904cadbf67817bc580b98a14096a5ecb81b" translate="yes" xml:space="preserve">
          <source>It is important to note that step 3 is the only time when a Redis Cluster node will create a new config epoch without agreement from other nodes. This only happens when a manual configuration is operated. However it is impossible that this creates a non-transient setup where two nodes have the same config epoch, since Redis Cluster uses a config epoch collision resolution algorithm.</source>
          <target state="translated">重要なのは、ステップ3はRedis Clusterノードが他のノードからの同意なしに新しいコンフィグエポックを作成するときだけであるということです。これは手動設定が操作された場合にのみ発生します。しかし、Redis Clusterがコンフィグエポック衝突解決アルゴリズムを使用しているため、これが2つのノードが同じコンフィグエポックを持つ非過渡的なセットアップを作成することは不可能です。</target>
        </trans-unit>
        <trans-unit id="75e2007346bb90c5a30dbb62b43b72fa8d6f2346" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;MATCH&lt;/strong&gt; filter is applied after elements are retrieved from the collection, just before returning data to the client. This means that if the pattern matches very little elements inside the collection, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; will likely return no elements in most iterations. An example is shown below:</source>
          <target state="translated">&lt;strong&gt;MATCH&lt;/strong&gt;フィルターは、要素がコレクションから取得された後、データをクライアントに返す直前に適用されることに注意してください。これは、パターンがコレクション内の非常に小さな要素と一致する場合、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;はほとんどの反復で要素を返さない可能性が高いことを意味します。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="c6bd66f1e8688cc2dae7b39af1276712b3930256" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command is &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">このコマンドは、同じ範囲のIDを待機しているすべてのクライアントに&lt;em&gt;ファンアウト&lt;/em&gt;するため、ブロッキングリストのポップ操作を使用した場合とは異なり、すべてのコンシューマーがデータのコピーを取得することを理解することが重要です。</target>
        </trans-unit>
        <trans-unit id="c855a69b0dba328dc98ac3bd3b714e220d6e64d4" translate="yes" xml:space="preserve">
          <source>It is never repeated, so if &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; returns the same number, the caller can be sure that the underlying client did not disconnect and reconnect the connection, but it is still the same connection.</source>
          <target state="translated">これが繰り返されることはないため、&lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;が同じ番号を返す場合、呼び出し元は、基礎となるクライアントが接続を切断して再接続しなかったことを確認できますが、それでも同じ接続です。</target>
        </trans-unit>
        <trans-unit id="18c6232a5064b912687168695e794e952ea903ef" translate="yes" xml:space="preserve">
          <source>It is not possible for the key to get lost in the event of a timeout, but the client calling &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;, in the event of a timeout error, should check if the key is &lt;em&gt;also&lt;/em&gt; present in the target instance and act accordingly.</source>
          <target state="translated">タイムアウトが発生したときにキーが失われることはありませんが、タイムアウトエラーが発生した場合に&lt;a href=&quot;migrate&quot;&gt;MIGRATEを&lt;/a&gt;呼び出すクライアントは、キーがターゲットインスタンスに&lt;em&gt;も&lt;/em&gt;存在するかどうかを確認し、それに応じて動作する必要があります。</target>
        </trans-unit>
        <trans-unit id="7a383107db035b97cc0f3e4c5c6844b9b02c255f" translate="yes" xml:space="preserve">
          <source>It is possible for an infinite number of clients to iterate the same collection at the same time, as the full state of the iterator is in the cursor, that is obtained and returned to the client at every call. Server side no state is taken at all.</source>
          <target state="translated">イテレータの完全な状態はカーソルにあり、呼び出すたびに取得されてクライアントに返されるので、無限の数のクライアントが同時に同じコレクションを反復処理することが可能です。サーバ側では状態は一切取られません。</target>
        </trans-unit>
        <trans-unit id="a485e395caaea14094a0b8ec68e5e3e0a8915e73" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; using as argument a key that already has an existing expire set. In this case the time to live of a key is &lt;em&gt;updated&lt;/em&gt; to the new value. There are many useful applications for this, an example is documented in the &lt;em&gt;Navigation session&lt;/em&gt; pattern section below.</source>
          <target state="translated">すでに有効期限が設定されているキーを引数として使用して&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;を呼び出すことができます。この場合、キーの有効期間は新しい値に&lt;em&gt;更新さ&lt;/em&gt;れます。これには多くの便利なアプリケーションがあり、例は以下の&lt;em&gt;ナビゲーションセッション&lt;/em&gt;パターンセクションに記載されています。</target>
        </trans-unit>
        <trans-unit id="a7f5fb81c26b1abadccf00465e65f7fa65dea140" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; inside Lua scripts like with normal clients, However one subtle aspect of the behavior changes between Redis 2.8.11 and Redis 2.8.12. Before the 2.8.12 release the database selected by the Lua script was &lt;em&gt;transferred&lt;/em&gt; to the calling script as current database. Starting from Redis 2.8.12 the database selected by the Lua script only affects the execution of the script itself, but does not modify the database selected by the client calling the script.</source>
          <target state="translated">通常のクライアントと同様にLuaスクリプト内で&lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;を呼び出すことは可能ですが、Redis 2.8.11とRedis 2.8.12では動作の微妙な側面が1つ変更されています。2.8.12リリースの前に、Luaスクリプトによって選択されたデータベースは、現在のデータベースとして呼び出しスクリプトに&lt;em&gt;転送さ&lt;/em&gt;れました。Redis 2.8.12以降、Luaスクリプトによって選択されたデータベースはスクリプト自体の実行にのみ影響し、スクリプトを呼び出すクライアントによって選択されたデータベースは変更しません。</target>
        </trans-unit>
        <trans-unit id="0958a04d7552830b3684f48a6c436807896935c0" translate="yes" xml:space="preserve">
          <source>It is possible to call Redis commands from a Lua script using two different Lua functions:</source>
          <target state="translated">2つの異なるLua関数を使用して、LuaスクリプトからRedisコマンドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="b0a209f43840d7a1f6f04e02663cf8a792cab884" translate="yes" xml:space="preserve">
          <source>It is possible to entirely remove the connection name setting it to the empty string, that is not a valid connection name since it serves to this specific purpose.</source>
          <target state="translated">接続名を空の文字列に設定して完全に削除することも可能ですが、これはこの特定の目的のためのものなので、有効な接続名ではありません。</target>
        </trans-unit>
        <trans-unit id="db23050fd5ba19a3417f8b624df748886d949634" translate="yes" xml:space="preserve">
          <source>It is possible to get just the length of the slow log using the command &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;.</source>
          <target state="translated">コマンド&lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;を使用して、遅いログの長さだけを取得することが可能です。</target>
        </trans-unit>
        <trans-unit id="db19130f0bd00fca33ef9a77ffc0a1ce2466b31d" translate="yes" xml:space="preserve">
          <source>It is possible to give the command in the following special form in order to make it more efficient:</source>
          <target state="translated">以下のような特殊な形式でコマンドを与えることで、より効率的にコマンドを与えることができます。</target>
        </trans-unit>
        <trans-unit id="e24f1bfbfced0e2fc3e90a67dd138360e0226aa2" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option.</source>
          <target state="translated">&lt;strong&gt;MAXLEN&lt;/strong&gt;オプションを使用して、ストリームのサイズを最大要素数に制限することができます。</target>
        </trans-unit>
        <trans-unit id="ee2ff105ab5c2c719dd08acac18181138935047b" translate="yes" xml:space="preserve">
          <source>It is possible to make this system more robust modifying the unlock schema as follows:</source>
          <target state="translated">以下のようにアンロックスキーマを変更することで、このシステムをより強固なものにすることができます。</target>
        </trans-unit>
        <trans-unit id="493e108b328a9e96e14d97d5ac7db908da18cbb1" translate="yes" xml:space="preserve">
          <source>It is possible to modify the maximum time a script can be executed with millisecond precision, either via &lt;code&gt;redis.conf&lt;/code&gt; or using the CONFIG GET / CONFIG SET command. The configuration parameter affecting max execution time is called &lt;code&gt;lua-time-limit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;redis.conf&lt;/code&gt; またはCONFIG GET / CONFIG SETコマンドを使用して、スクリプトをミリ秒の精度で実行できる最大時間を変更できます。最大実行時間に影響を与える構成パラメーターは、 &lt;code&gt;lua-time-limit&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="16570d1ed8c0ba499d85c4796bacd5587bfbf468" translate="yes" xml:space="preserve">
          <source>It is possible to only iterate elements matching a given glob-style pattern, similarly to the behavior of the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; command that takes a pattern as only argument.</source>
          <target state="translated">パターンを唯一の引数として取る&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;コマンドの動作と同様に、特定のグロブスタイルのパターンに一致する要素のみを繰り返すことが可能です。</target>
        </trans-unit>
        <trans-unit id="4c90a5608f4fab2983bbd179b23cb40526ff6f3e" translate="yes" xml:space="preserve">
          <source>It is possible to pass the &lt;code&gt;WITHSCORES&lt;/code&gt; option in order to return the scores of the elements together with the elements. The returned list will contain &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; instead of &lt;code&gt;value1,...,valueN&lt;/code&gt;. Client libraries are free to return a more appropriate data type (suggestion: an array with (value, score) arrays/tuples).</source>
          <target state="translated">要素とともに要素のスコアを返すために、 &lt;code&gt;WITHSCORES&lt;/code&gt; オプションを渡すことができます。返されるリストには、 &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; 代わりに &lt;code&gt;value1,...,valueN&lt;/code&gt; score1、...、valueN、scoreNが含まれます。クライアントライブラリは、より適切なデータ型を自由に返すことができます（推奨：（値、スコア）配列/タプルを含む配列）。</target>
        </trans-unit>
        <trans-unit id="5fd91c3878c3497da37709cc86d8056d11e4d945" translate="yes" xml:space="preserve">
          <source>It is possible to provide multiple filters at the same time. The command will handle multiple filters via logical AND. For example:</source>
          <target state="translated">複数のフィルタを同時に提供することが可能です。コマンドは、論理 AND を介して複数のフィルタを処理します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1c3121b308c1fd1777b057f001ac070f1a4f6932" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;c&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;a&lt;/code&gt; as third element.</source>
          <target state="translated">コマンドの最後に複数の引数を指定するだけで、単一のコマンド呼び出しを使用して複数の要素をプッシュできます。要素は、左端の要素から右端の要素まで、リストの先頭に次々に挿入されます。したがって、たとえば、 &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; コマンドは、 &lt;code&gt;c&lt;/code&gt; を最初の要素、 &lt;code&gt;b&lt;/code&gt; を2番目の要素、 &lt;code&gt;a&lt;/code&gt; を3番目の要素として含むリストになります。</target>
        </trans-unit>
        <trans-unit id="f7c76d9bc80fdf12c410c3b35eb8ad68df167802" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;a&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;c&lt;/code&gt; as third element.</source>
          <target state="translated">コマンドの最後に複数の引数を指定するだけで、単一のコマンド呼び出しを使用して複数の要素をプッシュできます。要素は、左端の要素から右端の要素まで、リストの末尾に次々に挿入されます。だから、例えば、コマンド &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; 含むリストになり最初の要素として &lt;code&gt;b&lt;/code&gt; 第二要素とのような &lt;code&gt;c&lt;/code&gt; 第三元素として。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b01178931bb71c8630b481c710157203df1e465" translate="yes" xml:space="preserve">
          <source>It is possible to send &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; in a MULTI/EXEC block together with the &lt;code&gt;INFO replication&lt;/code&gt; command in order to get the current master offset at the time the clients are blocked. This way it is possible to wait for a specific offset in the replica side in order to make sure all the replication stream was processed.</source>
          <target state="translated">クライアントがブロックされているときに現在のマスターオフセットを取得するために、 &lt;code&gt;INFO replication&lt;/code&gt; コマンドと一緒にMULTI / EXECブロックで&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;を送信することが可能です。このようにして、すべてのレプリケーションストリームが処理されたことを確認するために、レプリカ側で特定のオフセットを待つことができます。</target>
        </trans-unit>
        <trans-unit id="0ec5055f100665a2489124e5d7125126bd09824c" translate="yes" xml:space="preserve">
          <source>It is possible to specify an optional modifier to alter the behavior of the command. Specifically:</source>
          <target state="translated">オプションの修飾子を指定して、コマンドの動作を変更することができます。具体的には</target>
        </trans-unit>
        <trans-unit id="45f8f96397f97e0b1f0e90886760fbff08204ef1" translate="yes" xml:space="preserve">
          <source>It is possible to switch persistence from RDB snapshotting to append-only file (and the other way around) using the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command. For more information about how to do that please check the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;コマンドを使用して、永続性をRDBスナップショットから追加専用ファイル（およびその逆）に切り替えることができます。その方法の詳細については、&lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;永続化ページ&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="7e2a6138f902bc8b4bcfbc90caefbe979c90132a" translate="yes" xml:space="preserve">
          <source>It is possible to terminate a script that executes only read-only commands using the &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; command. This does not violate the scripting semantic as no data was yet written to the dataset by the script.</source>
          <target state="translated">&lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt;コマンドを使用して、読み取り専用コマンドのみを実行するスクリプトを終了することができます。スクリプトによってデータセットにまだデータが書き込まれていないため、これはスクリプトのセマンティクスに違反しません。</target>
        </trans-unit>
        <trans-unit id="e71c9ce4c62f0cde3cb804acf308d1e98fe95b09" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; and &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; together at every page view to have a counter counting only the latest N page views separated by less than the specified amount of seconds.</source>
          <target state="translated">すべてのページビューで&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;と&lt;a href=&quot;expire&quot;&gt;EXPIREを&lt;/a&gt;一緒に使用して、指定された秒数未満で区切られた最新のNページビューのみをカウントするカウンターを使用することができます。</target>
        </trans-unit>
        <trans-unit id="2dd681e578f9014910b8ac5ae0c3612f0ad14944" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;BY&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; options against hash fields with the following syntax:</source>
          <target state="translated">次の構文を使用して、ハッシュフィールドに対して &lt;code&gt;BY&lt;/code&gt; および &lt;code&gt;GET&lt;/code&gt; オプションを使用できます。</target>
        </trans-unit>
        <trans-unit id="b7c843f5e285c955a784fb3560240c16b6f9efa9" translate="yes" xml:space="preserve">
          <source>It is possible to use them in &lt;code&gt;geohash.org&lt;/code&gt; URLs such as &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt;. This is an &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;example of such URL&lt;/a&gt;.</source>
          <target state="translated">これらを &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt; などの &lt;code&gt;geohash.org&lt;/code&gt; URLで使用できます。これはその&lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;ようなURLの例です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b30cb831388a0a49ee8acf0fd13e74a7abc3ab8f" translate="yes" xml:space="preserve">
          <source>It is possible to write to the Redis log file from Lua scripts using the &lt;code&gt;redis.log&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;redis.log&lt;/code&gt; 関数を使用して、LuaスクリプトからRedisログファイルに書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="dee99c37f02de301ed26c2711bf105931901e4b7" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the highest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">これは、与えられたソートされたセットのいずれからもポップするメンバーがいない場合に接続をブロックするためのブロッキングバージョンです。最も高いスコアを持つメンバーは、最初にソートされた空でないセットからポップされ、与えられたキーが与えられた順にチェックされます。</target>
        </trans-unit>
        <trans-unit id="b7063c25aabd8a7e88f52a969b68eec3fd17473b" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the lowest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">これは、与えられたソートされたセットのいずれからもポップするメンバーがいない場合に接続をブロックするためのブロッキングバージョンです。スコアが最も低いメンバーは、最初にソートされた空でないセットからポップされ、与えられたキーが与えられた順にチェックされます。</target>
        </trans-unit>
        <trans-unit id="164013c6ace79ff08b57e9e952d3d8fc12045787" translate="yes" xml:space="preserve">
          <source>It just assumes that the Earth is a sphere, since the used distance formula is the Haversine formula. This formula is only an approximation when applied to the Earth, which is not a perfect sphere. The introduced errors are not an issue when used in the context of social network sites that need to query by radius and most other applications. However in the worst case the error may be up to 0.5%, so you may want to consider other systems for error-critical applications.</source>
          <target state="translated">使用されている距離の公式はハベルサインの公式なので、地球が球体であると仮定しているだけです。この式は、完全な球体ではない地球に適用した場合の近似値にすぎません。導入された誤差は、半径による問い合わせが必要なソーシャルネットワークサイトや他のほとんどのアプリケーションのコンテキストで使用する場合には問題ありません。しかし、最悪の場合、誤差は0.5%までになる可能性がありますので、誤差が重要なアプリケーションでは他のシステムを検討した方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="886b0ba44681d142ee0340c1b1c340fb49ca65a9" translate="yes" xml:space="preserve">
          <source>It starts accepting commands again from other clients, but will reply with a BUSY error to all the clients sending normal commands. The only allowed commands in this status are &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; and &lt;code&gt;SHUTDOWN
NOSAVE&lt;/code&gt;.</source>
          <target state="translated">他のクライアントからのコマンドの受け入れを再開しますが、通常のコマンドを送信するすべてのクライアントにBUSYエラーで応答します。このステータスで許可されるコマンドは、&lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt;と &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c9c449f7e951338dc4ce45209e7239b6180f2387" translate="yes" xml:space="preserve">
          <source>It stops processing all the pending commands from normal and pub/sub clients. However interactions with replicas will continue normally.</source>
          <target state="translated">通常のクライアントや pub/sub クライアントからの保留中のコマンドの処理をすべて停止します。ただし、レプリカとのインタラクションは通常通り継続されます。</target>
        </trans-unit>
        <trans-unit id="de49d1f951abef9774a1080b68edfd084cab6b36" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="translated">他のいくつかの機能をサポートしています： &lt;code&gt;bit.tobit&lt;/code&gt; 、 &lt;code&gt;bit.tohex&lt;/code&gt; 、 &lt;code&gt;bit.bnot&lt;/code&gt; 、 &lt;code&gt;bit.band&lt;/code&gt; 、 &lt;code&gt;bit.bor&lt;/code&gt; 、 &lt;code&gt;bit.bxor&lt;/code&gt; 、 &lt;code&gt;bit.lshift&lt;/code&gt; 、 &lt;code&gt;bit.rshift&lt;/code&gt; 、 &lt;code&gt;bit.arshift&lt;/code&gt; 、 &lt;code&gt;bit.rol&lt;/code&gt; 、 &lt;code&gt;bit.ror&lt;/code&gt; 、 &lt;code&gt;bit.bswap&lt;/code&gt; 。使用可能なすべての関数は、&lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOpのドキュメントに&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="aa6a033ac7293343a89e1b83064df26de033f26b" translate="yes" xml:space="preserve">
          <source>Iteratating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">ストリームを段階的に反復し、反復ごとに数個のアイテムのみを返します。ただし、意味的には&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;ファミリーの関数よりもはるかに堅牢です。</target>
        </trans-unit>
        <trans-unit id="3fa52c04afc758e80cafb88b8a1109903b053dfb" translate="yes" xml:space="preserve">
          <source>Iterating a stream</source>
          <target state="translated">ストリームの反復処理</target>
        </trans-unit>
        <trans-unit id="6cb66fccc1c9fe8583ef2426d5ce548dc6f7ff69" translate="yes" xml:space="preserve">
          <source>Iterating with XREVRANGE</source>
          <target state="translated">XREVRANGEを使った反復処理</target>
        </trans-unit>
        <trans-unit id="4794d4e58656f4a052385045d3fd4b0331ebddea" translate="yes" xml:space="preserve">
          <source>Iteration of a Hash value.</source>
          <target state="translated">ハッシュ値の繰り返し。</target>
        </trans-unit>
        <trans-unit id="ac97fd8044e211b8965191abd3e1372d4a6075d6" translate="yes" xml:space="preserve">
          <source>KEYS</source>
          <target state="translated">KEYS</target>
        </trans-unit>
        <trans-unit id="d4d3343d1b4f35172b9d4fabff52e12ab9514f83" translate="yes" xml:space="preserve">
          <source>KEYS  pattern   Find all keys matching the given pattern</source>
          <target state="translated">KEYS パターン 指定されたパターンに一致するすべてのキーを検索します。</target>
        </trans-unit>
        <trans-unit id="8001eeb819fd035ff21dae0c64b60f000bfc9daa" translate="yes" xml:space="preserve">
          <source>Key step count allows us to find key positions in commands like &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; where the format is &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt;.</source>
          <target state="translated">キーステップカウントを使用すると、&lt;a href=&quot;mset&quot;&gt;MSETの&lt;/a&gt;ようなコマンドのキー位置を見つけることができます。形式は &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="5e0969e73b8800b103eeedd8f6bcdbbbf0f4fa78" translate="yes" xml:space="preserve">
          <source>Keys are checked in the order that they are given. Let's say that the key &lt;code&gt;list1&lt;/code&gt; doesn't exist and &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; hold non-empty lists. Consider the following command:</source>
          <target state="translated">キーは与えられた順にチェックされます。レッツは、キーと言う &lt;code&gt;list1&lt;/code&gt; 存在せず、 &lt;code&gt;list2&lt;/code&gt; と &lt;code&gt;list3&lt;/code&gt; 非空のリストを保持します。次のコマンドを検討してください。</target>
        </trans-unit>
        <trans-unit id="393be168e99116be87234133e2763b06336c48c1" translate="yes" xml:space="preserve">
          <source>Keys expiring information is stored as absolute Unix timestamps (in milliseconds in case of Redis version 2.6 or greater). This means that the time is flowing even when the Redis instance is not active.</source>
          <target state="translated">キーの有効期限の情報は、Unixの絶対的なタイムスタンプ(Redisバージョン2.6以上の場合はミリ秒単位)として保存されます。これは、Redisインスタンスがアクティブでなくても時間が流れていることを意味します。</target>
        </trans-unit>
        <trans-unit id="d3023dfa16df6ad208cc7d5460854b58da1edb26" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets.</source>
          <target state="translated">存在しないキーは空のセットとみなされます。</target>
        </trans-unit>
        <trans-unit id="d71481abd644158f5a9fbc5c9cecdf74dc0540c6" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets. With one of the keys being an empty set, the resulting set is also empty (since set intersection with an empty set always results in an empty set).</source>
          <target state="translated">存在しないキーは空集合とみなされます。キーの1つが空集合である場合、結果として得られる集合も空になります(空集合との集合の交点は常に空集合になるので)。</target>
        </trans-unit>
        <trans-unit id="a78a3a71051e865654da3b71a5c55513e9449b8a" translate="yes" xml:space="preserve">
          <source>Keys with an expire</source>
          <target state="translated">有効期限のあるキー</target>
        </trans-unit>
        <trans-unit id="7bcef127a442604057181ff7e89e6774cfcbdec1" translate="yes" xml:space="preserve">
          <source>Keyspace hits</source>
          <target state="translated">キースペースのヒット</target>
        </trans-unit>
        <trans-unit id="0ecc36a9eabb580bee92d3334fc963c0e285c8f2" translate="yes" xml:space="preserve">
          <source>Keyspace misses</source>
          <target state="translated">キースペースを逃す</target>
        </trans-unit>
        <trans-unit id="18937f1c4a4cfb92babe800429a63d572cde1150" translate="yes" xml:space="preserve">
          <source>Kills the currently executing Lua script, assuming no write operation was yet performed by the script.</source>
          <target state="translated">現在実行中の Lua スクリプトをキルします。</target>
        </trans-unit>
        <trans-unit id="a452e11c491a60de5436b1999a469cdaa66c0c00" translate="yes" xml:space="preserve">
          <source>LASTSAVE</source>
          <target state="translated">LASTSAVE</target>
        </trans-unit>
        <trans-unit id="fb2ee42881d40ddc3d3aec1d41500b08e5d25e19" translate="yes" xml:space="preserve">
          <source>LASTSAVE   Get the UNIX time stamp of the last successful save to disk</source>
          <target state="translated">LASTSAVE 最後にディスクへの保存に成功したときの UNIX タイムスタンプを取得します。</target>
        </trans-unit>
        <trans-unit id="b9ffd63c8ba805a842d4d3d2465da47916360545" translate="yes" xml:space="preserve">
          <source>LDB can be enabled in one of two modes: asynchronous or synchronous. In asynchronous mode the server creates a forked debugging session that does not block and all changes to the data are &lt;strong&gt;rolled back&lt;/strong&gt; after the session finishes, so debugging can be restarted using the same initial state. The alternative synchronous debug mode blocks the server while the debugging session is active and retains all changes to the data set once it ends.</source>
          <target state="translated">LDBは、非同期または同期の2つのモードのいずれかで有効にできます。非同期モードでは、サーバーはブロックしない分岐したデバッグセッションを作成し、セッションの終了後にデータへのすべての変更が&lt;strong&gt;ロールバックさ&lt;/strong&gt;れるため、同じ初期状態を使用してデバッグを再開できます。代替の同期デバッグモードでは、デバッグセッションがアクティブである間はサーバーがブロックされ、終了するとデータセットに対するすべての変更が保持されます。</target>
        </trans-unit>
        <trans-unit id="14d2c13614325f3af7fa95efeb5dd818bb2ab0d1" translate="yes" xml:space="preserve">
          <source>LINDEX</source>
          <target state="translated">LINDEX</target>
        </trans-unit>
        <trans-unit id="a2dedc00417f0b7b29562ddaa4e03af088097cdb" translate="yes" xml:space="preserve">
          <source>LINDEX  key index   Get an element from a list by its index</source>
          <target state="translated">LINDEX キーインデックス リストの要素をインデックスで取得します。</target>
        </trans-unit>
        <trans-unit id="40088c47225008784271c2935753b4ae98fd6ec7" translate="yes" xml:space="preserve">
          <source>LINSERT</source>
          <target state="translated">LINSERT</target>
        </trans-unit>
        <trans-unit id="ca09700aae0c450ed6c327c789e3e1e3fef9f931" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot value   Insert an element before or after another element in a list</source>
          <target state="translated">LINSERT キー BEFORE|AFTER ピボット値 リスト内の別の要素の前または後に要素を挿入する</target>
        </trans-unit>
        <trans-unit id="19ce1639e2d6248a60334eca45396c2f1f706007" translate="yes" xml:space="preserve">
          <source>LLEN</source>
          <target state="translated">LLEN</target>
        </trans-unit>
        <trans-unit id="defc92ee8b39130b63cdf033e9edada00210e4f3" translate="yes" xml:space="preserve">
          <source>LLEN  key   Get the length of a list</source>
          <target state="translated">LLEN key リストの長さを取得します。</target>
        </trans-unit>
        <trans-unit id="6f58be63c72a45daadb6f09041398ad98c6ac9a7" translate="yes" xml:space="preserve">
          <source>LPOP</source>
          <target state="translated">LPOP</target>
        </trans-unit>
        <trans-unit id="c0a0f50764c15280585040d66db05c7ea7d4701a" translate="yes" xml:space="preserve">
          <source>LPOP  key   Remove and get the first element in a list</source>
          <target state="translated">LPOP キー リストの最初の要素を削除して取得します。</target>
        </trans-unit>
        <trans-unit id="4f49fc76e42ddd892d0dbf761cab7456fba6707a" translate="yes" xml:space="preserve">
          <source>LPUSH</source>
          <target state="translated">LPUSH</target>
        </trans-unit>
        <trans-unit id="a3260ebe55f682088cc638c2329d0a5d2a5f9c43" translate="yes" xml:space="preserve">
          <source>LPUSH  key value [value ...]   Prepend one or multiple values to a list</source>
          <target state="translated">LPUSH キー値 [value ...]1 つまたは複数の値をリストに追加します。</target>
        </trans-unit>
        <trans-unit id="73023347f78efa6f33e2849831f260102f26f9dc" translate="yes" xml:space="preserve">
          <source>LPUSHX</source>
          <target state="translated">LPUSHX</target>
        </trans-unit>
        <trans-unit id="11960d83f4ba3a64c1274bec7eeaf405b1c4abbe" translate="yes" xml:space="preserve">
          <source>LPUSHX  key value   Prepend a value to a list, only if the list exists</source>
          <target state="translated">LPUSHX キー値 リストが存在する場合にのみ、値をリストに前置します。</target>
        </trans-unit>
        <trans-unit id="3b47c23e3107b92100b9303bb9ab3d1a9ccc56bd" translate="yes" xml:space="preserve">
          <source>LRANGE</source>
          <target state="translated">LRANGE</target>
        </trans-unit>
        <trans-unit id="326594fa342712e825205a5b864121b10bd2f5cf" translate="yes" xml:space="preserve">
          <source>LRANGE  key start stop   Get a range of elements from a list</source>
          <target state="translated">LRANGE キー start stop リストから要素の範囲を取得します。</target>
        </trans-unit>
        <trans-unit id="abfc25d80dc9a80384bd4c9697b510b323ecc45b" translate="yes" xml:space="preserve">
          <source>LREM</source>
          <target state="translated">LREM</target>
        </trans-unit>
        <trans-unit id="f0b649e2191175bc6abf8bc7b2d0b6ec6fbf904d" translate="yes" xml:space="preserve">
          <source>LREM  key count value   Remove elements from a list</source>
          <target state="translated">LREM キーカウント値 リストから要素を削除する</target>
        </trans-unit>
        <trans-unit id="70e8f03d6f4f36a9430ac8c4d4a1515597b0b252" translate="yes" xml:space="preserve">
          <source>LSET</source>
          <target state="translated">LSET</target>
        </trans-unit>
        <trans-unit id="4f03203283df161a2d6f2abf4d29626d32823249" translate="yes" xml:space="preserve">
          <source>LSET  key index value   Set the value of an element in a list by its index</source>
          <target state="translated">LSET key index value リスト内の要素の値をインデックスで設定します。</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="6c5b375830efe50dd05881b52f80e2aa747afced" translate="yes" xml:space="preserve">
          <source>LTRIM  key start stop   Trim a list to the specified range</source>
          <target state="translated">LTRIM キー start stop リストを指定した範囲にトリミングします。</target>
        </trans-unit>
        <trans-unit id="de6a27da313b316346ea7dcf9f866c5fcdaff765" translate="yes" xml:space="preserve">
          <source>Last Key in Argument List</source>
          <target state="translated">引数リストの最後のキー</target>
        </trans-unit>
        <trans-unit id="d4e1040fdde9172717ea80a7cdcb3b316461fb75" translate="yes" xml:space="preserve">
          <source>Later it will be trivial to know the number of single days the user visited the web site simply calling the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command against the bitmap.</source>
          <target state="translated">後で、ユーザーがビットマップに対して&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;コマンドを呼び出すだけでWebサイトにアクセスした日数を知るのは簡単です。</target>
        </trans-unit>
        <trans-unit id="6167261c71ec337f0f15b900208ad184a4f7b0c9" translate="yes" xml:space="preserve">
          <source>Latest fork(2) time</source>
          <target state="translated">最新のフォーク(2)の時間</target>
        </trans-unit>
        <trans-unit id="0122f9d36a5bc7edfbaa17dc0a7b017882cfb3ae" translate="yes" xml:space="preserve">
          <source>Let's assume we have four nodes, A, B, C and D. In order to end with just a three nodes cluster A, B, C we may follow these steps:</source>
          <target state="translated">4つのノード、A,B,C,Dを持っていると仮定してみましょう。</target>
        </trans-unit>
        <trans-unit id="2f5c5e27076a7756eeef955cec8a1510af3fb9c4" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.</source>
          <target state="translated">クリエイティブ・コモンズ 表示-継承ライセンス4.0の下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="98cf5d780c53575d17f1d32cf3823650dcaa6c52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; this command returns the remaining time to live of a key that has an expire set, with the sole difference that &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; returns the amount of remaining time in seconds while &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; returns it in milliseconds.</source>
          <target state="translated">&lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt;と同様に、このコマンドは、有効期限が設定されているキーの残りの有効期間を返します。唯一の違いは、&lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt;は残り時間を秒単位で返し、&lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt;はミリ秒単位で返します。</target>
        </trans-unit>
        <trans-unit id="199ff2ec8051414c46a22a354ba2c4bf9f64de93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; this command can be used in order to iterate the whole stream content, however note that in this case, the next command calls should use the ID of the last entry, with the sequence number decremneted by one. However if the sequence number is already 0, the time part of the ID should be decremented by 1, and the sequence part should be set to the maxium possible sequence number, that is, 18446744073709551615, or could be omitted at all, and the command will automatically assume it to be such a number (see &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; for more info about incomplete IDs).</source>
          <target state="translated">同様&lt;a href=&quot;xrange&quot;&gt;XRANGEは&lt;/a&gt;、このコマンドは、この場合には、次のコマンド呼び出しが1でdecremnetedシーケンス番号と、最後のエントリのIDを使用する必要があることに注意してください、全体のストリームコンテンツを反復するために使用することができます。ただし、シーケンス番号がすでに0の場合、IDの時間部分を1だけ減らし、シーケンス部分を最大可能なシーケンス番号、つまり18446744073709551615に設定するか、まったく省略して、コマンドは自動的にそのような数であると想定します（不完全なIDの詳細については、&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="7a5a0a2011829340fa32a8f044e479cef542a701" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command can be used in a blocking way. There are no differences in this regard.</source>
          <target state="translated">&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;と同様に、&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;コマンドはブロックする方法で使用できます。この点で違いはありません。</target>
        </trans-unit>
        <trans-unit id="964c6e379f4b517ab54346bbc59cea679f55f58d" translate="yes" xml:space="preserve">
          <source>Like for the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; command start and end can contain negative values in order to index bytes starting from the end of the string, where -1 is the last byte, -2 is the penultimate, and so forth.</source>
          <target state="translated">&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;コマンドの場合と同様に、文字列の最後からバイトをインデックスするために、startおよびendに負の値を含めることができます。-1は最後のバイト、-2は最後から2番目のバイトなどです。</target>
        </trans-unit>
        <trans-unit id="ce45b8148c6f69841bc195d50623329ea61f3da8" translate="yes" xml:space="preserve">
          <source>Lines can contain a section name (starting with a # character) or a property. All the properties are in the form of &lt;code&gt;field:value&lt;/code&gt; terminated by &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">行には、セクション名（＃文字で始まる）またはプロパティを含めることができます。すべてのプロパティは、 &lt;code&gt;\r\n&lt;/code&gt; 終了する &lt;code&gt;field:value&lt;/code&gt; の形式です。</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="899acbf6050de7813479a962bcb80b73089f0f38" translate="yes" xml:space="preserve">
          <source>Lists can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;linkedlist&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is the special representation that is used to save space for small lists.</source>
          <target state="translated">リストは &lt;code&gt;ziplist&lt;/code&gt; または &lt;code&gt;linkedlist&lt;/code&gt; としてエンコードできます。 &lt;code&gt;ziplist&lt;/code&gt; は小さなリストのためのスペースを節約するために使用される特殊な表現です。</target>
        </trans-unit>
        <trans-unit id="db5be7f471516f84344dd104ba9b8aa174ce8d02" translate="yes" xml:space="preserve">
          <source>Lists the currently &lt;em&gt;active channels&lt;/em&gt;. An active channel is a Pub/Sub channel with one or more subscribers (not including clients subscribed to patterns).</source>
          <target state="translated">現在&lt;em&gt;アクティブなチャネルを&lt;/em&gt;一覧表示&lt;em&gt;します&lt;/em&gt;。アクティブチャネルは、1つ以上のサブスクライバー（パターンにサブスクライブしているクライアントは含まない）を持つPub / Subチャネルです。</target>
        </trans-unit>
        <trans-unit id="dcea1d44bcfef24039b8c1d6348290fc06d43c9a" translate="yes" xml:space="preserve">
          <source>Load a script into the scripts cache, without executing it. After the specified command is loaded into the script cache it will be callable using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; with the correct SHA1 digest of the script, exactly like after the first successful invocation of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">スクリプトを実行せずにスクリプトキャッシュにロードします。指定されたコマンドがスクリプトキャッシュにロードされた後、最初に&lt;a href=&quot;eval&quot;&gt;EVALが&lt;/a&gt;正常に呼び出された後とまったく同じように、スクリプトの正しいSHA1ダイジェストで&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;を使用して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="bcd47c9d2232eb759e90bf52905602d787217e6e" translate="yes" xml:space="preserve">
          <source>Lua boolean false -&amp;gt; Redis Nil bulk reply.</source>
          <target state="translated">Lua boolean false-&amp;gt; Redis Nil一括返信。</target>
        </trans-unit>
        <trans-unit id="197815ca05866b7c30c1048b9d86321ee4ce6238" translate="yes" xml:space="preserve">
          <source>Lua boolean true -&amp;gt; Redis integer reply with value of 1.</source>
          <target state="translated">Lua boolean true-&amp;gt;値1のRedis整数応答。</target>
        </trans-unit>
        <trans-unit id="02dda41ef75370280dc992551fadb03b88d21b1f" translate="yes" xml:space="preserve">
          <source>Lua does not export commands to access the system time or other external state.</source>
          <target state="translated">Luaでは、システム時刻などの外部状態にアクセスするためのコマンドをエクスポートしません。</target>
        </trans-unit>
        <trans-unit id="738b234f859993680828647d652f6de5655b0815" translate="yes" xml:space="preserve">
          <source>Lua has a single numerical type, Lua numbers. There is no distinction between integers and floats. So we always convert Lua numbers into integer replies, removing the decimal part of the number if any. &lt;strong&gt;If you want to return a float from Lua you should return it as a string&lt;/strong&gt;, exactly like Redis itself does (see for instance the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command).</source>
          <target state="translated">Luaには、Lua番号という単一の数値タイプがあります。整数と浮動小数点数の区別はありません。したがって、常にLuaの数値を整数の応答に変換し、小数部がある場合はそれを削除します。&lt;strong&gt;Luaから浮動小数点数を返したい場合は&lt;/strong&gt;、Redis自体が行うのとまったく同じように、&lt;strong&gt;それを文字列として返す必要&lt;/strong&gt;があります（たとえば、&lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt;コマンドを参照）。</target>
        </trans-unit>
        <trans-unit id="7c212b1d165a2bdadf01bf8c01c306a9c3e780aa" translate="yes" xml:space="preserve">
          <source>Lua number -&amp;gt; Redis integer reply (the number is converted into an integer)</source>
          <target state="translated">Lua番号-&amp;gt; Redis整数応答（数値は整数に変換されます）</target>
        </trans-unit>
        <trans-unit id="0fcb79bd3680efc38fab49be15ad5a556da29a6c" translate="yes" xml:space="preserve">
          <source>Lua pseudo random number generation functions &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; are modified in order to always have the same seed every time a new script is executed. This means that calling &lt;code&gt;math.random&lt;/code&gt; will always generate the same sequence of numbers every time a script is executed if &lt;code&gt;math.randomseed&lt;/code&gt; is not used.</source>
          <target state="translated">Lua擬似乱数生成関数 &lt;code&gt;math.random&lt;/code&gt; および &lt;code&gt;math.randomseed&lt;/code&gt; は、新しいスクリプトが実行されるたびに常に同じシードを持つように変更されています。呼び出すことをこの手段 &lt;code&gt;math.random&lt;/code&gt; は常に同じ数列にあればスクリプトが実行されるたびに発生します &lt;code&gt;math.randomseed&lt;/code&gt; が使用されていませんが。</target>
        </trans-unit>
        <trans-unit id="e026038d7a23da497563d39bf562be4e8b076af8" translate="yes" xml:space="preserve">
          <source>Lua scripts can return a value that is converted from the Lua type to the Redis protocol using a set of conversion rules.</source>
          <target state="translated">Luaスクリプトは、一連の変換ルールを使用して、Lua型からRedisプロトコルに変換された値を返すことができます。</target>
        </trans-unit>
        <trans-unit id="eec8779958c6af77259f2bed4f2206965d44330b" translate="yes" xml:space="preserve">
          <source>Lua string -&amp;gt; Redis bulk reply</source>
          <target state="translated">Lua文字列-&amp;gt; Redis一括返信</target>
        </trans-unit>
        <trans-unit id="0b78d29489185b7463559dbd5991d9b98e6ea241" translate="yes" xml:space="preserve">
          <source>Lua table (array) -&amp;gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any)</source>
          <target state="translated">Luaテーブル（配列）-&amp;gt; Redisマルチバルク応答（もしあれば、Lua配列内の最初のnilに切り捨てられます）</target>
        </trans-unit>
        <trans-unit id="92dffb8e404af7ee6cc40117a693313890548b7f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;err&lt;/code&gt; field -&amp;gt; Redis error reply</source>
          <target state="translated">1つの &lt;code&gt;err&lt;/code&gt; フィールドを持つLuaテーブル-&amp;gt; Redisエラー応答</target>
        </trans-unit>
        <trans-unit id="860f10116eaffeabf918bd97496952f6a8568b86" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;ok&lt;/code&gt; field -&amp;gt; Redis status reply</source>
          <target state="translated">単一の &lt;code&gt;ok&lt;/code&gt; フィールドを持つLuaテーブル-&amp;gt; Redisステータスの応答</target>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="5f530d724793deebbb2b735aad30cfb0c16904b5" translate="yes" xml:space="preserve">
          <source>MEMORY DOCTOR   Outputs memory problems report</source>
          <target state="translated">メモリ問題のレポートを出力するMEMORY DOCTOR</target>
        </trans-unit>
        <trans-unit id="f41c78df06ee10a6b220b355855965b8d5802f0d" translate="yes" xml:space="preserve">
          <source>MEMORY HELP   Show helpful text about the different subcommands</source>
          <target state="translated">MEMORY HELP 様々なサブコマンドについての有用なテキストを表示します。</target>
        </trans-unit>
        <trans-unit id="c46a26bce66617f3cb9ccdc83db737a6115fdc5d" translate="yes" xml:space="preserve">
          <source>MEMORY MALLOC-STATS   Show allocator internal stats</source>
          <target state="translated">MEMORY MALLOC-STATS アロケータの内部統計を表示します。</target>
        </trans-unit>
        <trans-unit id="eb96d4965b5bb6522ee6573db44c8a6e1ce6edba" translate="yes" xml:space="preserve">
          <source>MEMORY PURGE   Ask the allocator to release memory</source>
          <target state="translated">MEMORY PURGE アロケータにメモリの解放を求める</target>
        </trans-unit>
        <trans-unit id="d3303c80cf9ee1aa6f783b72419ffa190e2a905d" translate="yes" xml:space="preserve">
          <source>MEMORY STATS   Show memory usage details</source>
          <target state="translated">MEMORY STATS メモリ使用量の詳細を表示</target>
        </trans-unit>
        <trans-unit id="de9aed5605340cafa3f173e741e4bc7253d17f99" translate="yes" xml:space="preserve">
          <source>MEMORY USAGE  key [SAMPLES count]   Estimate the memory usage of a key</source>
          <target state="translated">MEMORY USAGE key [SAMPLES count]キーのメモリ使用量を推定する</target>
        </trans-unit>
        <trans-unit id="eb4b445b699787b561e4b67d4f6b08a7ef32cf55" translate="yes" xml:space="preserve">
          <source>MGET</source>
          <target state="translated">MGET</target>
        </trans-unit>
        <trans-unit id="ffbcf2b819692d7b52978ca1ef1e227536a082fe" translate="yes" xml:space="preserve">
          <source>MGET  key [key ...]   Get the values of all the given keys</source>
          <target state="translated">MGET key [key ....]与えられたすべてのキーの値を取得します。</target>
        </trans-unit>
        <trans-unit id="883beaf0f91aca7f9ebc4802e0bab2501cbbc8ea" translate="yes" xml:space="preserve">
          <source>MIGRATE</source>
          <target state="translated">MIGRATE</target>
        </trans-unit>
        <trans-unit id="2f0b2cdf3b3d88df6ed56ef5576fa5ec1a8aa5b1" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">MIGRATE ホストポートキー|&quot;&quot; destination-db タイムアウト [COPY][REPLACE][KEYS キー [キー ...]Redisインスタンスから別のインスタンスにキーをアトミックに転送します。</target>
        </trans-unit>
        <trans-unit id="6da5b5979c630adef5abc39370410d7de4a1b8ef" translate="yes" xml:space="preserve">
          <source>MONITOR</source>
          <target state="translated">MONITOR</target>
        </trans-unit>
        <trans-unit id="55d4d86d6d24375e297cf38db11a4bacd4febc84" translate="yes" xml:space="preserve">
          <source>MONITOR   Listen for all requests received by the server in real time</source>
          <target state="translated">MONITOR サーバーが受信したすべてのリクエストをリアルタイムでリッスンします。</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="001d5d6407276cba944eda42b69684ebbbae5d55" translate="yes" xml:space="preserve">
          <source>MOVE  key db   Move a key to another database</source>
          <target state="translated">MOVE key db キーを別のデータベースに移動します。</target>
        </trans-unit>
        <trans-unit id="4a4d41a590643b6020afed2c32a7fa4d49b49601" translate="yes" xml:space="preserve">
          <source>MSET</source>
          <target state="translated">MSET</target>
        </trans-unit>
        <trans-unit id="9a5861cd64b36ffe83c01382e80e50105a256980" translate="yes" xml:space="preserve">
          <source>MSET  key value [key value ...]   Set multiple keys to multiple values</source>
          <target state="translated">MSET キー値 [キー値 ...]複数のキーを複数の値に設定します。</target>
        </trans-unit>
        <trans-unit id="f7daca0dd0ee4f7979861ac9b4fb059852d07494" translate="yes" xml:space="preserve">
          <source>MSETNX</source>
          <target state="translated">MSETNX</target>
        </trans-unit>
        <trans-unit id="48498dbffef6df5e6474fe5db88a9722de54676a" translate="yes" xml:space="preserve">
          <source>MSETNX  key value [key value ...]   Set multiple keys to multiple values, only if none of the keys exist</source>
          <target state="translated">MSETNX キー値 [キー値 ...]キーが存在しない場合のみ、複数のキーを複数の値に設定します。</target>
        </trans-unit>
        <trans-unit id="73cadb41b45514de9061a72461b466eafd7a01b0" translate="yes" xml:space="preserve">
          <source>MULTI</source>
          <target state="translated">MULTI</target>
        </trans-unit>
        <trans-unit id="bb76d99632737ac9f4ecd1c2218ac5cae7373df0" translate="yes" xml:space="preserve">
          <source>MULTI   Mark the start of a transaction block</source>
          <target state="translated">MULTI トランザクションブロックの開始をマークする</target>
        </trans-unit>
        <trans-unit id="5162c1f5fa963969d600908fd5531f9515bcd0ad" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; command to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt;コマンドを手動で発行して、 &lt;code&gt;telnet&lt;/code&gt; 経由で実行されている&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;ストリームを停止します。</target>
        </trans-unit>
        <trans-unit id="195fbe53b32ee6173d85e3798809ae2267b7bfce" translate="yes" xml:space="preserve">
          <source>Marks the given keys to be watched for conditional execution of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;トランザクションの&lt;/a&gt;条件付き実行を監視するために、指定されたキーをマークします。</target>
        </trans-unit>
        <trans-unit id="c8683729a7a727945cae9baf35f4c55f1439a9ae" translate="yes" xml:space="preserve">
          <source>Marks the start of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; block. Subsequent commands will be queued for atomic execution using &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;トランザクション&lt;/a&gt;ブロックの開始をマークします。後続のコマンドは、&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;を使用したアトミック実行のためにキューに入れられます。</target>
        </trans-unit>
        <trans-unit id="f713e2ee906af8b74a13e92b2e0d07f7715b2d2e" translate="yes" xml:space="preserve">
          <source>Master for slot range represented as nested IP/Port array</source>
          <target state="translated">ネストされたIP/ポート配列で表されるスロット範囲のマスター</target>
        </trans-unit>
        <trans-unit id="826539552e055ad1bd8dd2263cef37308d024f80" translate="yes" xml:space="preserve">
          <source>Master output</source>
          <target state="translated">マスター出力</target>
        </trans-unit>
        <trans-unit id="3a00e4f9797b4c734ae7a585f001ffa257119f27" translate="yes" xml:space="preserve">
          <source>Meaning of the flags (field number 3):</source>
          <target state="translated">フラグ(フィールド番号3)の意味。</target>
        </trans-unit>
        <trans-unit id="716383f923909d0c089205fcba00d4705b3601a5" translate="yes" xml:space="preserve">
          <source>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of the observed Sets of the source HyperLogLog structures.</source>
          <target state="translated">複数のHyperLogLogの値を、元のHyperLog構造体の観測されたSetの和のカーディナリティに近い一意の値にマージします。</target>
        </trans-unit>
        <trans-unit id="d48699ea9bf170ea49610c0892198d522150833b" translate="yes" xml:space="preserve">
          <source>Migrating multiple keys with a single command call</source>
          <target state="translated">単一のコマンドコールによる複数のキーの移行</target>
        </trans-unit>
        <trans-unit id="1dc9fdcdad40a742a94a677f3b78a05f4ed5e6b5" translate="yes" xml:space="preserve">
          <source>Migration and importing slots are only added to the node flagged as &lt;code&gt;myself&lt;/code&gt;. This information is local to a node, for its own slots.</source>
          <target state="translated">移行およびインポートスロットは、 &lt;code&gt;myself&lt;/code&gt; フラグが付けられたノードにのみ追加されます。この情報は、独自のスロットについて、ノードに対してローカルです。</target>
        </trans-unit>
        <trans-unit id="bf4ac897fe1476ddf0632fbae3fd4061b3a77806" translate="yes" xml:space="preserve">
          <source>More details about the Redis HyperLogLog implementation can be found in &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;this blog post&lt;/a&gt;. The source code of the implementation in the &lt;code&gt;hyperloglog.c&lt;/code&gt; file is also easy to read and understand, and includes a full specification for the exact encoding used for the sparse and dense representations.</source>
          <target state="translated">Redis HyperLogLog実装の詳細については、&lt;a href=&quot;http://antirez.com/news/75&quot;&gt;このブログ投稿を&lt;/a&gt;ご覧ください。 &lt;code&gt;hyperloglog.c&lt;/code&gt; ファイル内の実装のソースコードも読みやすく、理解しやすく、疎および密表現に使用される正確なエンコーディングの完全な仕様が含まれています。</target>
        </trans-unit>
        <trans-unit id="66fbce4faebab20f5ca1d3b33c08e967f22406cb" translate="yes" xml:space="preserve">
          <source>More information about the Current Epoch and Config Epoch variables are available in the Redis Cluster specification document.</source>
          <target state="translated">Current EpochとConfig Epoch変数についての詳細は、Redis Clusterの仕様書に記載されています。</target>
        </trans-unit>
        <trans-unit id="76f5a5481231f7dff85e48d6a0993bd209662a44" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; does not need to be reciprocal. If I send the command to A in order to join B, I don't need to also send it to B in order to join A.</source>
          <target state="translated">さらに、&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;は相互である必要はありません。Bに参加するためにコマンドをAに送信した場合、Aに参加するためにコマンドをBにも送信する必要はありません。</target>
        </trans-unit>
        <trans-unit id="8993f2e40360ac488b5303cad3bacad41d3a08f1" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message. In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">さらに、副作用として、&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;はメッセージの配信試行回数を増やします。このようにして、たとえばコンシューマがメッセージを処理しようとしてクラッシュしたために何らかの理由で処理できないメッセージは、より大きなカウンタを持ち始め、システム内で検出できます。</target>
        </trans-unit>
        <trans-unit id="6330fc6bbcd49c1766a676116e26172a91d38595" translate="yes" xml:space="preserve">
          <source>Moreover, if you are new to streams, we recommend to read our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. Make sure to understand the concept of consumer group in the introduction so that following how this command works will be simpler.</source>
          <target state="translated">さらに、ストリーム&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;に慣れてい&lt;/a&gt;ない場合は、Redis Streamsの紹介を読むことをお勧めします。このコマンドがどのように機能するかを簡単に理解できるように、はじめにコンシューマグループの概念を必ず理解してください。</target>
        </trans-unit>
        <trans-unit id="fde66fa86f8517d887e54616bf1fb31656fc7f81" translate="yes" xml:space="preserve">
          <source>Motivations</source>
          <target state="translated">Motivations</target>
        </trans-unit>
        <trans-unit id="eaf7a15ddfb6c5c306f486c8bf293512f163a845" translate="yes" xml:space="preserve">
          <source>Movable Keys</source>
          <target state="translated">可動キー</target>
        </trans-unit>
        <trans-unit id="f77b47b8d13d94af9785e089c536b9963ca2c823" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;key&lt;/code&gt; from the currently selected database (see &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;) to the specified destination database. When &lt;code&gt;key&lt;/code&gt; already exists in the destination database, or it does not exist in the source database, it does nothing. It is possible to use &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; as a locking primitive because of this.</source>
          <target state="translated">現在選択されているデータベース（&lt;a href=&quot;select&quot;&gt;SELECTを&lt;/a&gt;参照）から指定された宛先データベースに &lt;code&gt;key&lt;/code&gt; を移動します。 &lt;code&gt;key&lt;/code&gt; が宛先データベースにすでに存在する場合、またはソースデータベースに存在しない場合、何もしません。このため、&lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt;をロックプリミティブとして使用できます。</target>
        </trans-unit>
        <trans-unit id="17c083c9f9d68a5d0169cd11d9c0c04115759b24" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;member&lt;/code&gt; from the set at &lt;code&gt;source&lt;/code&gt; to the set at &lt;code&gt;destination&lt;/code&gt;. This operation is atomic. In every given moment the element will appear to be a member of &lt;code&gt;source&lt;/code&gt;&lt;strong&gt;or&lt;/strong&gt;&lt;code&gt;destination&lt;/code&gt; for other clients.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; のセットから &lt;code&gt;destination&lt;/code&gt; セットに &lt;code&gt;member&lt;/code&gt; を移動します。この操作はアトミックです。常に、要素は他のクライアントの &lt;code&gt;source&lt;/code&gt; &lt;strong&gt;または&lt;/strong&gt; &lt;code&gt;destination&lt;/code&gt; メンバーであるように見えます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95a91b78dd0ce912aadce361711a043cae9a887e" translate="yes" xml:space="preserve">
          <source>Multiple parallel iterations</source>
          <target state="translated">複数の並列反復</target>
        </trans-unit>
        <trans-unit id="f492964822aab7cec6aa84fefaffe8fba8b6cd36" translate="yes" xml:space="preserve">
          <source>Nested Result Array</source>
          <target state="translated">入れ子になった結果の配列</target>
        </trans-unit>
        <trans-unit id="fdc70576104b358de95d88f0255666aac631aff0" translate="yes" xml:space="preserve">
          <source>New fields are regularly added for debugging purpose. Some could be removed in the future. A version safe Redis client using this command should parse the output accordingly (i.e. handling gracefully missing fields, skipping unknown fields).</source>
          <target state="translated">新しいフィールドはデバッグのために定期的に追加されます。いくつかは将来的に削除される可能性があります。このコマンドを使用するバージョンセーフの Redis クライアントは、出力をそれに応じて解析しなければなりません (つまり、フィールドの欠落を優雅に処理したり、未知のフィールドをスキップしたりすること)。</target>
        </trans-unit>
        <trans-unit id="861e51e24f78632f52937df883ebeed5a0766d52" translate="yes" xml:space="preserve">
          <source>New keys are always created in the target node. During a hash slot migration we'll have to move only old keys, not new ones.</source>
          <target state="translated">新しい鍵は常にターゲットノードに作成されます。ハッシュスロットの移行の際には、新しい鍵ではなく古い鍵だけを移動させなければなりません。</target>
        </trans-unit>
        <trans-unit id="97bfa87b383568ddb64d92c09cf59316bbb313bd" translate="yes" xml:space="preserve">
          <source>No repeated elements are returned.</source>
          <target state="translated">繰り返し要素は返されません。</target>
        </trans-unit>
        <trans-unit id="75e932f04e490ddd2c64a4420d419573bd058eac" translate="yes" xml:space="preserve">
          <source>Nodes in &lt;code&gt;PFAIL&lt;/code&gt; state are provided in gossip sections of heartbeat packets.</source>
          <target state="translated">&lt;code&gt;PFAIL&lt;/code&gt; 状態のノードは、ハートビートパケットのゴシップセクションで提供されます。</target>
        </trans-unit>
        <trans-unit id="c02697f1f51c2f137246d46e8911c8e7f53e6636" translate="yes" xml:space="preserve">
          <source>Non existing elements are reported as NULL elements of the array.</source>
          <target state="translated">存在しない要素は、配列のNULL要素として報告されます。</target>
        </trans-unit>
        <trans-unit id="5dfb2fbf84cf8de01a0c2542d485d2207dc976ae" translate="yes" xml:space="preserve">
          <source>Non used lines are blanked. For instance if you used to have multiple &lt;code&gt;save&lt;/code&gt; directives, but the current configuration has fewer or none as you disabled RDB persistence, all the lines will be blanked.</source>
          <target state="translated">使用されていない行は空白になります。たとえば、以前は複数の &lt;code&gt;save&lt;/code&gt; ディレクティブがあったが、RDBの永続性を無効にしたために現在の構成が少ないかまったくない場合、すべての行が空白になります。</target>
        </trans-unit>
        <trans-unit id="de44f50198c0734dcccb5b1c5d4825eb72c13aba" translate="yes" xml:space="preserve">
          <source>Non-blocking behavior</source>
          <target state="translated">ノンブロッキング動作</target>
        </trans-unit>
        <trans-unit id="5cbfa62b0d0a8a33923d06127db99370a393ad0d" translate="yes" xml:space="preserve">
          <source>Non-blocking usage</source>
          <target state="translated">ノンブロッキングの使い方</target>
        </trans-unit>
        <trans-unit id="bcbbb0c35f64190eb100cd6befa838fbd5037874" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings, so the command will return zero.</source>
          <target state="translated">存在しないキーは空文字列として扱われるので、コマンドは0を返します。</target>
        </trans-unit>
        <trans-unit id="46b493cea7b65b3003ea2e423707591849b0ee78" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings.</source>
          <target state="translated">存在しないキーは空の文字列として扱われます。</target>
        </trans-unit>
        <trans-unit id="9a60acaa61d5a344489afdd9e5311dbf8888aa00" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; is simply used in order to get range of items where the score is the indexed integer key, however it is possible to do less obvious things with the command.</source>
          <target state="translated">通常、&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;は、スコアがインデックス付き整数キーであるアイテムの範囲を取得するために単純に使用されますが、コマンドを使用してあまり明確でないことを行うことができます。</target>
        </trans-unit>
        <trans-unit id="4dba9f7be4e65fcc1fd8d86533e96e912932e110" translate="yes" xml:space="preserve">
          <source>Normally Redis keys are created without an associated time to live. The key will simply live forever, unless it is removed by the user in an explicit way, for instance using the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; command.</source>
          <target state="translated">通常、Redisキーは、有効期間が関連付けられていない状態で作成されます。たとえば、&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;コマンドを使用するなど、ユーザーが明示的な方法で削除しない限り、キーは永久に存続します。</target>
        </trans-unit>
        <trans-unit id="488e099ce2d3130dde9348d7a491fea120dffc25" translate="yes" xml:space="preserve">
          <source>Normally Redis represents positions of elements using a variation of the Geohash technique where positions are encoded using 52 bit integers. The encoding is also different compared to the standard because the initial min and max coordinates used during the encoding and decoding process are different. This command however &lt;strong&gt;returns a standard Geohash&lt;/strong&gt; in the form of a string as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia article&lt;/a&gt; and compatible with the &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; web site.</source>
          <target state="translated">通常、Redisは、位置が52ビット整数を使用してエンコードされるGeohash技術のバリエーションを使用して、要素の位置を表します。エンコードおよびデコードプロセス中に使用される初期の最小および最大座標が異なるため、エンコードも標準とは異なります。ただし&lt;strong&gt;、&lt;/strong&gt;このコマンドは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipediaの記事に&lt;/a&gt;記載されている&lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; Webサイトと互換性の&lt;strong&gt;ある標準のGeohash&lt;/strong&gt;を文字列の形式で&lt;strong&gt;返します&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="48fbc2c3360b2ccdab702dc73f1af3fdad88932d" translate="yes" xml:space="preserve">
          <source>Normally hash slots associated to a given node are in one of the following formats, as already explained above:</source>
          <target state="translated">通常、与えられたノードに関連付けられたハッシュスロットは、上で説明したように、以下の形式のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="20da22f8d3c73a214f41394b1c9a9c08c0230154" translate="yes" xml:space="preserve">
          <source>Normally if there is an AOF child process performing an AOF rewrite, Redis will simply kill it and exit. However there are two conditions where it is unsafe to do so, and the &lt;strong&gt;SHUTDOWN&lt;/strong&gt; command will be refused with an error instead. This happens when:</source>
          <target state="translated">通常、AOF書き換えを実行するAOF子プロセスがある場合、Redisは単にそれを強制終了して終了します。ただし、これを行うのが安全ではない状況が2つあり、代わりに&lt;strong&gt;SHUTDOWN&lt;/strong&gt;コマンドがエラーで拒否されます。これは次の場合に発生します：</target>
        </trans-unit>
        <trans-unit id="f552eaf00c55408f0aa996335bcd91c4da8dcdb7" translate="yes" xml:space="preserve">
          <source>Normally replica nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use replicas in order to scale reads using the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command.</source>
          <target state="translated">通常、レプリカノードは、指定されたコマンドに関連するハッシュスロットの信頼できるマスターにクライアントをリダイレクトしますが、クライアントは&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;コマンドを使用して読み取りをスケーリングするためにレプリカを使用できます。</target>
        </trans-unit>
        <trans-unit id="0b040d0fd81d55e920e28d6b8b43687a96fedfb9" translate="yes" xml:space="preserve">
          <source>Normally replicating scripts instead of the effects of the scripts makes sense, however not in all the cases. So starting with Redis 3.2, the scripting engine is able to, alternatively, replicate the sequence of write commands resulting from the script execution, instead of replication the script itself. See the next section for more information. In this section we'll assume that scripts are replicated by sending the whole script. Let's call this replication mode &lt;strong&gt;whole scripts replication&lt;/strong&gt;.</source>
          <target state="translated">通常、スクリプトの効果の代わりにスクリプトを複製することには意味がありますが、すべての場合に当てはまるわけではありません。そのため、Redis 3.2以降では、スクリプトエンジンは、スクリプト自体を複製する代わりに、スクリプトの実行結果である書き込みコマンドのシーケンスを複製することができます。詳細については、次のセクションを参照してください。このセクションでは、スクリプト全体を送信することによってスクリプトが複製されると想定します。このレプリケーションモードを&lt;strong&gt;スクリプト全体を&lt;/strong&gt;レプリケーションと呼びましょう。</target>
        </trans-unit>
        <trans-unit id="de2018dd71c22fe4b55fd2f381e3bcbd8ea7b844" translate="yes" xml:space="preserve">
          <source>Normally you may think at a Redis stream as an append-only data structure, however Redis streams are represented in memory, so we are able to also delete entries. This may be useful, for instance, in order to comply with certain privacy policies.</source>
          <target state="translated">通常、Redisのストリームは追加のみのデータ構造と考えるかもしれませんが、Redisのストリームはメモリで表現されているので、エントリを削除することもできます。これは、例えば、特定のプライバシーポリシーに準拠するために便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="675cc42aab3b45855f7e4f48b1a8a2f9ea1abcdc" translate="yes" xml:space="preserve">
          <source>Normally you use the command like that in order to get new messages and process them. In pseudo-code:</source>
          <target state="translated">通常は、新しいメッセージを取得して処理するために、このようなコマンドを使用します。疑似コードで</target>
        </trans-unit>
        <trans-unit id="92faf092f64b7750013de7ad70293bed4c22e467" translate="yes" xml:space="preserve">
          <source>Note for Lua newbies: in order to avoid using global variables in your scripts simply declare every variable you are going to use using the &lt;em&gt;local&lt;/em&gt; keyword.</source>
          <target state="translated">Luaの初心者への注意：スクリプトでグローバル変数を使用しないようにするには、使用するすべての変数を&lt;em&gt;local&lt;/em&gt;キーワードを使用して宣言するだけです。</target>
        </trans-unit>
        <trans-unit id="386ff54d1c33b65d55947a3bc043df349ed6b50a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; all work very similarly, so this documentation covers all the four commands. However an obvious difference is that in the case of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; the first argument is the name of the key holding the Set, Hash or Sorted Set value. The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command does not need any key name argument as it iterates keys in the current database, so the iterated object is the database itself.</source>
          <target state="translated">なお、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;、&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;、&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;と&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;すべての作業は非常に同様に、このドキュメントはすべての4つのコマンドをカバーしていて。ただし、明らかな違いは、&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;、&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;、および&lt;a href=&quot;zscan&quot;&gt;ZSCANの場合&lt;/a&gt;、最初の引数はSet、Hash、またはSorted Setの値を保持するキーの名前であることです。&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;それは現在のデータベースにキーを反復して反復オブジェクトがデータベースそのものであるので、このコマンドは、任意のキー名の引数を必要としません。</target>
        </trans-unit>
        <trans-unit id="b8af6b6330cf6687e8cc50e67b81c7d7beffd113" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not make Redis a strongly consistent store: while synchronous replication is part of a replicated state machine, it is not the only thing needed. However in the context of Sentinel or Redis Cluster failover, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; improves the real world data safety.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;はRedisを強い整合性のあるストアにするわけではないことに注意してください。同期複製は複製された状態マシンの一部ですが、必要なのはそれだけではありません。ただし、SentinelまたはRedisクラスターのフェイルオーバーのコンテキストでは、&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;は実際のデータの安全性を向上させます。</target>
        </trans-unit>
        <trans-unit id="196f50bc6a6ac776d1991175d0001fae97125b81" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; is also available since Redis 3.2.10 and Redis 4.0.0 in order to provide a read-only command that can be used in replicas. See the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; page for more information.</source>
          <target state="translated">&lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; は、レプリカで使用できる読み取り専用コマンドを提供するために、Redis 3.2.10およびRedis 4.0.0以降でも使用できることに注意してください。詳細は&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;ページをご覧ください。</target>
        </trans-unit>
        <trans-unit id="7f4713a8dfe3582f9f0fc3ed836bf0396dfbd617" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;TAKEOVER violates the last-failover-wins principle&lt;/strong&gt; of Redis Cluster, since the configuration epoch generated by the replica violates the normal generation of configuration epochs in several ways:</source>
          <target state="translated">&lt;strong&gt;TAKEOVER&lt;/strong&gt;はRedisクラスター&lt;strong&gt;のlast-failover-wins原則&lt;/strong&gt;に&lt;strong&gt;違反して&lt;/strong&gt;いることに注意してください。レプリカによって生成された構成エポックは、いくつかの点で構成エポックの通常の生成に違反しています。</target>
        </trans-unit>
        <trans-unit id="b1e5f99b4ded8ce6be23a9f6f9872d3e5595ab46" translate="yes" xml:space="preserve">
          <source>Note that Redis Cluster needs to form a full mesh (each node is connected with each other node), but in order to create a cluster, there is no need to send all the &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; commands needed to form the full mesh. What matter is to send enough &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; messages so that each node can reach each other node through a &lt;em&gt;chain of known nodes&lt;/em&gt;. Thanks to the exchange of gossip information in heartbeat packets, the missing links will be created.</source>
          <target state="translated">Redisクラスターはフルメッシュを形成する必要があります（各ノードは他のノードに接続されています）が、クラスターを作成するために、フルメッシュを形成するために必要なすべての&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;コマンドを送信する必要はありません。重要なのは、各ノードが&lt;em&gt;既知のノードのチェーンを&lt;/em&gt;介して他のノードに到達できるように、十分な&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;メッセージを送信することです。ハートビートパケットのゴシップ情報の交換のおかげで、ミッシングリンクが作成されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17fc5decb8a235b9d4881b1185aa05ef897a69aa" translate="yes" xml:space="preserve">
          <source>Note that bit positions are returned always as absolute values starting from bit zero even when &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are used to specify a range.</source>
          <target state="translated">&lt;em&gt;開始&lt;/em&gt;と&lt;em&gt;終了&lt;/em&gt;を使用して範囲を指定した場合でも、ビット位置は常にビット0から始まる絶対値として返されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d47127e4277fb6af8f1ec3e041d7aadf84ff3fe6" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;/&lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; with a non-positive timeout or &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;/&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; with a time in the past will result in the key being &lt;a href=&quot;del&quot;&gt;deleted&lt;/a&gt; rather than expired (accordingly, the emitted &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;key event&lt;/a&gt; will be &lt;code&gt;del&lt;/code&gt;, not &lt;code&gt;expired&lt;/code&gt;).</source>
          <target state="translated">（注）呼び出しがその&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; / &lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt;非正タイムアウトまたは有する&lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; / &lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt;キーであることになり、過去の時間は&lt;a href=&quot;del&quot;&gt;削除&lt;/a&gt;（従って、放出された有効期限が切れたのではなく、&lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;キーイベントが&lt;/a&gt;あろう &lt;code&gt;del&lt;/code&gt; ない、 &lt;code&gt;expired&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="134cdffcc8cc8242a1731baa707e6b6f212bd203" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;OVERFLOW&lt;/code&gt; statement only affects the &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; commands that follow it in the list of subcommands, up to the next &lt;code&gt;OVERFLOW&lt;/code&gt; statement.</source>
          <target state="translated">各 &lt;code&gt;OVERFLOW&lt;/code&gt; ステートメントは、次の &lt;code&gt;OVERFLOW&lt;/code&gt; ステートメントまで、サブコマンドのリストでそれに続く&lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt;コマンドにのみ影響することに注意してください。</target>
        </trans-unit>
        <trans-unit id="c59e6cb007a017cde6a0590f3fe3a6903d02fdbc" translate="yes" xml:space="preserve">
          <source>Note that for correctly implementing this pattern it is important to avoid multiple clients rebuilding the cache at the same time. Some kind of locking is needed here (for instance using &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;).</source>
          <target state="translated">このパターンを正しく実装するには、複数のクライアントが同時にキャッシュを再構築しないようにすることが重要です。ここでは何らかのロックが必要です（たとえば、&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;を使用）。</target>
        </trans-unit>
        <trans-unit id="ab5932614de576b14cea0fbf3d424f67389687d0" translate="yes" xml:space="preserve">
          <source>Note that for the same reason a Lua script or a &lt;code&gt;MULTI/EXEC&lt;/code&gt; block may push elements into a list and afterward &lt;strong&gt;delete the list&lt;/strong&gt;. In this case the blocked clients will not be served at all and will continue to be blocked as long as no data is present on the list after the execution of a single command, transaction, or script.</source>
          <target state="translated">同じ理由で、Luaスクリプトまたは &lt;code&gt;MULTI/EXEC&lt;/code&gt; ブロックが要素をリストにプッシュし、後でリストを&lt;strong&gt;削除する&lt;/strong&gt;場合があることに注意してください。この場合、ブロックされたクライアントはまったく提供されず、単一のコマンド、トランザクション、またはスクリプトの実行後にリストにデータが存在しない限り、ブロックされ続けます。</target>
        </trans-unit>
        <trans-unit id="fcc828a00ba6196c133772751828406df7944657" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">特定のマスターノードでレプリカが追加、移動、または削除され、構成の更新をまだ受け取っていないノードに&lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt;を要求すると、古い情報が表示される場合があることに注意してください。ただし、最終的に（ネットワークパーティションがない場合は数秒で）、すべてのノードが特定のマスターに関連付けられたノードのセットについて合意します。</target>
        </trans-unit>
        <trans-unit id="21094e1f69e7fc1828b555fe35532f052b5ac245" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">特定のマスターノードでレプリカが追加、移動、または削除され、構成の更新をまだ受信していないノードに&lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt;を要求すると、古い情報が表示される場合があることに注意してください。ただし、最終的に（ネットワークパーティションがない場合は数秒で）、すべてのノードが特定のマスターに関連付けられたノードのセットについて合意します。</target>
        </trans-unit>
        <trans-unit id="92bc3cdf3318fb930ded8c852b6a00267accad1a" translate="yes" xml:space="preserve">
          <source>Note that if you have a list of numbers from 0 to 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; will return 11 elements, that is, the rightmost item is included. This &lt;strong&gt;may or may not&lt;/strong&gt; be consistent with behavior of range-related functions in your programming language of choice (think Ruby's &lt;code&gt;Range.new&lt;/code&gt;, &lt;code&gt;Array#slice&lt;/code&gt; or Python's &lt;code&gt;range()&lt;/code&gt; function).</source>
          <target state="translated">0から100までの数値のリストがある場合、 &lt;code&gt;LRANGE list 0 10&lt;/code&gt; は11個の要素を返します。つまり、右端の項目が含まれます。これ&lt;strong&gt;は&lt;/strong&gt;、選択したプログラミング言語の範囲関連関数の動作と一致する&lt;strong&gt;場合&lt;/strong&gt;と一致し&lt;strong&gt;ない場合があり&lt;/strong&gt;ます（Rubyの &lt;code&gt;Range.new&lt;/code&gt; 、 &lt;code&gt;Array#slice&lt;/code&gt; 、またはPythonの &lt;code&gt;range()&lt;/code&gt; 関数と考えてください）。</target>
        </trans-unit>
        <trans-unit id="b145f3c9b171e7c40ecd23d7161660cea0ebde1c" translate="yes" xml:space="preserve">
          <source>Note that it is valid to call this command without channels. In this case it will just return an empty list.</source>
          <target state="translated">チャンネルなしでこのコマンドを呼び出すことが有効であることに注意してください。この場合、空のリストを返すだけです。</target>
        </trans-unit>
        <trans-unit id="7cbc0087feeeb4b8394154849c8ec33aeb518c13" translate="yes" xml:space="preserve">
          <source>Note that non-existing keys are treated like empty lists, so when &lt;code&gt;key&lt;/code&gt; does not exist, the command will always return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">存在しない &lt;code&gt;key&lt;/code&gt; は空のリストのように扱われるため、キーが存在しない場合、コマンドは常に &lt;code&gt;0&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e83de8fca6610aa183e7aad22115791cd55bc9fb" translate="yes" xml:space="preserve">
          <source>Note that normally clients willing to fetch the map between Cluster hash slots and node addresses should use &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; instead. &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;, that provides more information, should be used for administrative tasks, debugging, and configuration inspections. It is also used by &lt;code&gt;redis-trib&lt;/code&gt; in order to manage a cluster.</source>
          <target state="translated">通常、クラスターハッシュスロットとノードアドレスの間でマップをフェッチするクライアントは、代わりに&lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt;を使用する必要があることに注意してください。詳細情報を提供する&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODESは&lt;/a&gt;、管理タスク、デバッグ、および構成の検査に使用する必要があります。また、クラスターを管理するために &lt;code&gt;redis-trib&lt;/code&gt; によって使用されます。</target>
        </trans-unit>
        <trans-unit id="1f6b2fdffdf326f5f641aa170f10beb1a26d5924" translate="yes" xml:space="preserve">
          <source>Note that once a node assigns a set of slots to itself, it will start propagating this information in heartbeat packet headers. However the other nodes will accept the information only if they have the slot as not already bound with another node, or if the configuration epoch of the node advertising the new hash slot, is greater than the node currently listed in the table.</source>
          <target state="translated">ノードがスロットのセットを自分自身に割り当てると、その情報はハートビートパケットヘッダで伝搬を開始することに注意してください。しかし、他のノードは、スロットが他のノードとまだバインドされていない場合、または、新しいハッシュスロットを広告するノードのコンフィグレーションエポックが、現在テーブルにリストされているノードよりも大きい場合にのみ、情報を受け入れます。</target>
        </trans-unit>
        <trans-unit id="34efcb15ecc544550f9bd4f238eeb1c37bfe6eb5" translate="yes" xml:space="preserve">
          <source>Note that the command implements the full hashing algorithm, including support for &lt;strong&gt;hash tags&lt;/strong&gt;, that is the special property of Redis Cluster key hashing algorithm, of hashing just what is between &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; if such a pattern is found inside the key name, in order to force multiple keys to be handled by the same node.</source>
          <target state="translated">コマンドは、&lt;strong&gt;ハッシュタグの&lt;/strong&gt;サポートを含む完全なハッシュアルゴリズムを実装することに注意してください。これは、Redisクラスターのキーハッシュアルゴリズムの特別なプロパティであり、このようなパターンがキー名の中に見つかった場合、 &lt;code&gt;{&lt;/code&gt; と &lt;code&gt;}&lt;/code&gt; の間にあるものだけをハッシュします。複数のキーを同じノードで処理するように強制します。</target>
        </trans-unit>
        <trans-unit id="44319adff6c7cf60df65ef2f592ee1b07d9db575" translate="yes" xml:space="preserve">
          <source>Note that the format does not have any space, so &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output format is plain CSV with space as separator even when this special slots are emitted. However a complete parser for the format should be able to handle them.</source>
          <target state="translated">この形式にはスペースがないため、&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODESの&lt;/a&gt;出力形式は、この特別なスロットが発行された場合でも、区切り文字としてスペースを含むプレーンCSVであることに注意してください。ただし、形式の完全なパーサーはそれらを処理できる必要があります。</target>
        </trans-unit>
        <trans-unit id="6cf3d39f27c1b799248d5e59a73b1a5b0f086afd" translate="yes" xml:space="preserve">
          <source>Note that the maximum offset that you can set is 2&lt;sup&gt;29&lt;/sup&gt; -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.</source>
          <target state="translated">Redis文字列は512メガバイトに制限されているため、設定できる最大オフセットは2 &lt;sup&gt;29&lt;/sup&gt; -1（536870911）であることに注意してください。このサイズを超えて拡張する必要がある場合は、複数のキーを使用できます。</target>
        </trans-unit>
        <trans-unit id="365b9132d09f3318597589e9536ca42a38461cb4" translate="yes" xml:space="preserve">
          <source>Note that the message is claimed only if its idle time is greater the minimum idle time we specify when calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. Because as a side effect &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will also reset the idle time (since this is a new attempt at processing the message), two consumers trying to claim a message at the same time will never both succeed: only one will successfully claim the message. This avoids that we process a given message multiple times in a trivial way (yet multiple processing is possible and unavoidable in the general case).</source>
          <target state="translated">メッセージが要求されるのは、そのアイドル時間が、&lt;a href=&quot;xclaim&quot;&gt;XCLAIMを&lt;/a&gt;呼び出すときに指定する最小アイドル時間より大きい場合のみであることに注意してください。副作用として&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;はアイドル時間もリセットするため（これはメッセージを処理するための新しい試みであるため）、同時にメッセージを要求しようとする2つのコンシューマーは両方が成功することはなく、1つだけがメッセージを正常に要求します。これにより、特定のメッセージを簡単な方法で複数回処理することが回避されます（ただし、一般的なケースでは、複数の処理が可能であり、不可避です）。</target>
        </trans-unit>
        <trans-unit id="581b6da11286a19b84f5dbf7d26c9c4e1e18433c" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for SPOP, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">このコマンドは、返された要素の一様な分布を保証する必要がある場合には適していないことに注意してください。SPOP に使用されるアルゴリズムの詳細については、Knuth サンプリングと Floyd サンプリングの両方のアルゴリズムを参照してください。</target>
        </trans-unit>
        <trans-unit id="7aae41763fe9b0bc6731024cb063283c77ec4608" translate="yes" xml:space="preserve">
          <source>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</source>
          <target state="translated">このワーカーの実装は、メッセージが失われた場合でも、アイテムはキューに残っており、次の繰り返しで処理されるため、些細なことでもスケーラブルで信頼性が高いことに注意してください。</target>
        </trans-unit>
        <trans-unit id="de6800f82ca82bf510c822b7935a67d6ca2bf21c" translate="yes" xml:space="preserve">
          <source>Note that we have a race here, but it is not a problem: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; may return false but the key may be created by another client before we create it inside the &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. However this race will just miss an API call under rare conditions, so the rate limiting will still work correctly.</source>
          <target state="translated">ここでは競合があることに注意してください。ただし、問題はありません&lt;a href=&quot;exists&quot;&gt;。EXISTS&lt;/a&gt;はfalseを返す場合がありますが、&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;ブロック内にキーを作成する前に、別のクライアントによってキーが作成される場合があります。ただし、このレースはまれな状況でAPI呼び出しを逃すだけなので、レート制限は引き続き正しく機能します。</target>
        </trans-unit>
        <trans-unit id="290162572eb7adbad822a4117dca945c127babde" translate="yes" xml:space="preserve">
          <source>Note that you need a recent version of redis-cli in order to read the slow log output, since it uses some features of the protocol that were not formerly implemented in redis-cli (deeply nested multi bulk replies).</source>
          <target state="translated">遅いログ出力を読むためには、redis-cli の最新バージョンが必要になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">そのことに注意してください。</target>
        </trans-unit>
        <trans-unit id="851be398fabf2219f9c3aa64609a72f0559cc785" translate="yes" xml:space="preserve">
          <source>Note the used of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; in order to make sure that we'll both increment and set the expire at every API call.</source>
          <target state="translated">&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;および&lt;a href=&quot;exec&quot;&gt;EXECの&lt;/a&gt;使用に注意してください。これは、すべてのAPI呼び出しでインクリメントと期限切れの両方を確実に行うためです。</target>
        </trans-unit>
        <trans-unit id="0ab5850865b49bbe39f155ec6e364488933508f0" translate="yes" xml:space="preserve">
          <source>Note this rule is not enforced in order to provide the user with opportunities to abuse the Redis single instance configuration, at the cost of writing scripts not compatible with Redis Cluster.</source>
          <target state="translated">このルールは、Redisクラスタと互換性のないスクリプトを書くことを犠牲にして、ユーザにRedisのシングルインスタンス設定を悪用する機会を提供するために施行されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9dfbcfbbaf119bccc3c44b098de0573996677b97" translate="yes" xml:space="preserve">
          <source>Note: A Redis instance that is configured for not persisting on disk (no AOF configured, nor &quot;save&quot; directive) will not dump the RDB file on &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;, as usually you don't want Redis instances used only for caching to block on when shutting down.</source>
          <target state="translated">注：ディスクに永続化しないように構成されている（AOFが構成されていない、または「保存」ディレクティブがない）Redisインスタンスは、&lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;でRDBファイルをダンプしません。シャットダウンしています。</target>
        </trans-unit>
        <trans-unit id="40e3fa9c72775db4fd05d5cf7a3a493e93afca05" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">注：&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;コマンドオプションは&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;、&lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;、&lt;a href=&quot;psetex&quot;&gt;PSETEXを&lt;/a&gt;置き換えることができるため、Redisの将来のバージョンでは、これらの3つのコマンドが非推奨になり、最終的に削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="3d6762a6aa2cf0aca37a59f773d7789ef284a403" translate="yes" xml:space="preserve">
          <source>Note: an important part of this behavior is that the PRNG that Redis implements as &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; is guaranteed to have the same output regardless of the architecture of the system running Redis. 32-bit, 64-bit, big-endian and little-endian systems will all produce the same output.</source>
          <target state="translated">注：この動作の重要な部分は、Redisが &lt;code&gt;math.random&lt;/code&gt; および &lt;code&gt;math.randomseed&lt;/code&gt; として実装するPRNGが、Redisを実行しているシステムのアーキテクチャーに関係なく、同じ出力を持つことが保証されていることです。32ビット、64ビット、ビッグエンディアン、リトルエンディアンのシステムはすべて同じ出力を生成します。</target>
        </trans-unit>
        <trans-unit id="19d14832252be8ae1106f6c63fb642cd3e9e2df4" translate="yes" xml:space="preserve">
          <source>Note: as a side effect of calling this function, it is possible that the HyperLogLog is modified, since the last 8 bytes encode the latest computed cardinality for caching purposes. So &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; is technically a write command.</source>
          <target state="translated">注：この関数を呼び出すことの副作用として、最後の8バイトがキャッシュのために計算された最新のカーディナリティをエンコードするため、HyperLogLogが変更される可能性があります。したがって、&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;は技術的には書き込みコマンドです。</target>
        </trans-unit>
        <trans-unit id="ca716680732d1d3e7b5dc5d38bf23aaa2688e964" translate="yes" xml:space="preserve">
          <source>Note: as you can see Lua arrays are returned as Redis multi bulk replies, that is a Redis return type that your client library will likely convert into an Array type in your programming language.</source>
          <target state="translated">注意:Luaの配列はRedisのマルチバルクリプライとして返されますが、これはRedisのリターン型であり、クライアントライブラリがプログラミング言語でArray型に変換する可能性が高いです。</target>
        </trans-unit>
        <trans-unit id="a094e9a0339a167054eac3028e87a3e324531dab" translate="yes" xml:space="preserve">
          <source>Note: of course as usually it is not guaranteed that the error text remains the same, however the error code will remain &lt;code&gt;-UNBLOCKED&lt;/code&gt;.</source>
          <target state="translated">注：もちろん、通常はエラーテキストが同じであるとは限りませんが、エラーコードは &lt;code&gt;-UNBLOCKED&lt;/code&gt; のままです。</target>
        </trans-unit>
        <trans-unit id="3ba013a44d25a035abd0e8ad87d8b610e34b72b2" translate="yes" xml:space="preserve">
          <source>Note: the command has a complexity of just O(log(N)) because it uses elements ranks (see &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt;) to get an idea of the range. Because of this there is no need to do a work proportional to the size of the range.</source>
          <target state="translated">注：このコマンドは、要素のランク（&lt;a href=&quot;zrank&quot;&gt;ZRANKを&lt;/a&gt;参照）を使用して範囲の概念を取得するため、O（log（N））の複雑さしかありません。このため、範囲のサイズに比例した作業を行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="a4cf334aa22d4d43d68ebc7afbb42dd9e08a0e09" translate="yes" xml:space="preserve">
          <source>Note: we use the &lt;strong&gt;COUNT&lt;/strong&gt; option in the example, so that for each stream the call will return at maximum two elements per stream.</source>
          <target state="translated">注：この例では&lt;strong&gt;COUNT&lt;/strong&gt;オプションを使用しているため、ストリームごとに、ストリームごとに最大2つの要素で呼び出しが返されます。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="5a4574a1a3d9728a0a89d6b1668d9c8dc4ec0634" translate="yes" xml:space="preserve">
          <source>Notes on published config epochs</source>
          <target state="translated">公開されている設定エポックに関する注意事項</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="20be3b7a30a9bb9f7caa52a82e339d86765a7b3b" translate="yes" xml:space="preserve">
          <source>Number of commands processed</source>
          <target state="translated">処理されたコマンド数</target>
        </trans-unit>
        <trans-unit id="6567d67fead3b983bf0dd26e46b199bad4736caf" translate="yes" xml:space="preserve">
          <source>Number of connections received</source>
          <target state="translated">受信した接続数</target>
        </trans-unit>
        <trans-unit id="c0e73dd590dc420faea4c4ac9906ba30e0259e37" translate="yes" xml:space="preserve">
          <source>Number of elements returned at every SCAN call</source>
          <target state="translated">SCAN 呼び出しごとに返される要素の数</target>
        </trans-unit>
        <trans-unit id="f4702f3357a94e0b51c79789087a3eb454b1e296" translate="yes" xml:space="preserve">
          <source>Number of expired keys</source>
          <target state="translated">有効期限切れの鍵の数</target>
        </trans-unit>
        <trans-unit id="8e0e833a8bbaf63a540fadb74be8461319161578" translate="yes" xml:space="preserve">
          <source>Number of rejected connections</source>
          <target state="translated">拒否された接続数</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="9d8ec388e13faad9823f64e9acce4e1451d4eabf" translate="yes" xml:space="preserve">
          <source>OBJECT  subcommand [arguments [arguments ...]]   Inspect the internals of Redis objects</source>
          <target state="translated">OBJECTサブコマンド [引数 [引数 ....]Redisオブジェクトの内部を検査する</target>
        </trans-unit>
        <trans-unit id="77ba3ba2dc482ece5e336da9db6f45f553748e64" translate="yes" xml:space="preserve">
          <source>Objects can be encoded in different ways:</source>
          <target state="translated">オブジェクトは、さまざまな方法でエンコードすることができます。</target>
        </trans-unit>
        <trans-unit id="179e9e8b9188e3e0f2e120735c4089249f586f43" translate="yes" xml:space="preserve">
          <source>Obtaining the current length of the slow log</source>
          <target state="translated">スローログの現在の長さの取得</target>
        </trans-unit>
        <trans-unit id="5f6babf24c9404230c05a01781cf0ff83f2a099c" translate="yes" xml:space="preserve">
          <source>Of course it is also possible to use any other valid ID. If the specified consumer group already exists, the command returns a &lt;code&gt;-BUSYGROUP&lt;/code&gt; error. Otherwise the operation is performed and OK is returned. There are no hard limits to the number of consumer groups you can associate to a given stream.</source>
          <target state="translated">もちろん、他の有効なIDを使用することもできます。指定したコンシューマグループが既に存在する場合、コマンドは &lt;code&gt;-BUSYGROUP&lt;/code&gt; エラーを返します。それ以外の場合、操作が実行され、OKが返されます。特定のストリームに関連付けることができるコンシューマグループの数に厳しい制限はありません。</target>
        </trans-unit>
        <trans-unit id="ff1bb1ff7a105fafca313a10f02e72dc891fbcf4" translate="yes" xml:space="preserve">
          <source>Of course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</source>
          <target state="translated">もちろん、二度とアクセスできないような期限切れの鍵もあるので、これだけでは十分ではない。これらの鍵はいずれにせよ有効期限が切れているはずなので、Redisは定期的に有効期限が設定されている鍵の中からランダムにいくつかの鍵をテストします。すでに有効期限が切れている鍵はすべて鍵空間から削除される。</target>
        </trans-unit>
        <trans-unit id="e1291438828df902dd44c789d43575a9bce5c968" translate="yes" xml:space="preserve">
          <source>On the other hand, defining commands using a special command or via &lt;code&gt;redis.conf&lt;/code&gt; would be a problem for a few reasons:</source>
          <target state="translated">一方、特別なコマンドまたは &lt;code&gt;redis.conf&lt;/code&gt; を使用してコマンドを定義すると、いくつかの理由で問題が発生します。</target>
        </trans-unit>
        <trans-unit id="9bcf11babeeb88215faca3f25a089c7e21ce30f5" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;succesfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">コンシューマーがメッセージの処理に&lt;em&gt;成功し&lt;/em&gt;たら、&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;を呼び出して、そのようなメッセージが再度処理されないようにする必要があります。また、副作用として、このメッセージに関するPELエントリも消去され、Redisサーバーからメモリが解放されます。</target>
        </trans-unit>
        <trans-unit id="452b455cbf1a2a31d7d4b5005050bf4551fb3def" translate="yes" xml:space="preserve">
          <source>Once a node is turned into the replica of another master node, there is no need to inform the other cluster nodes about the change: heartbeat packets exchanged between nodes will propagate the new configuration automatically.</source>
          <target state="translated">ノードが他のマスターノードのレプリカになった後は、他のクラスタノードに変更を通知する必要はありません。ノード間で交換されたハートビートパケットが自動的に新しい構成を伝搬します。</target>
        </trans-unit>
        <trans-unit id="24b95a3638ec064976a3c5a5f6794040d2c4ed0b" translate="yes" xml:space="preserve">
          <source>Once new data is present on one of the lists, the client returns with the name of the key unblocking it and the popped value.</source>
          <target state="translated">リストのいずれかに新しいデータが存在すると、クライアントはブロックを解除したキーの名前とポップされた値を返します。</target>
        </trans-unit>
        <trans-unit id="dd41998567cd1f4f810cbadee2b74617b57a32fa" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; and &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; commands.</source>
          <target state="translated">クライアントがサブスクライブ状態になると、追加の&lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;、&lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;、&lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;、および&lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;コマンドを除いて、他のコマンドを発行することは想定されていません。</target>
        </trans-unit>
        <trans-unit id="c4b215656d61ce9a1a4991539bbd4f84ece9f512" translate="yes" xml:space="preserve">
          <source>Once we get some replies, the next call will be something like:</source>
          <target state="translated">いくつか返事が来たら、次はこんな感じで電話がかかってきます。</target>
        </trans-unit>
        <trans-unit id="9de09a5350a4d4653c094b67b0dba8689a762e24" translate="yes" xml:space="preserve">
          <source>One client connection per line (separated by LF)</source>
          <target state="translated">1行に1つのクライアント接続(LFで区切られています</target>
        </trans-unit>
        <trans-unit id="81d95091e8731132a88b7f9f02a3169be5e6b187" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgement of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">コンシューマグループの保証の1つは、特定のコンシューマは配信されたメッセージの履歴しか表示できないため、メッセージの所有者は1人だけであることです。ただし、一部のコンシューマで回復不可能な障害が発生した場合に、他のコンシューマが&lt;em&gt;メッセージを要求&lt;/em&gt;できるようにする&lt;em&gt;メッセージ要求&lt;/em&gt;と呼ばれる特別な機能があります。そのようなセマンティクスを実装するために、コンシューマーグループは、&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;コマンドを介して、コンシューマーによって正常に処理されたメッセージの明示的な確認応答を必要とします。これは、ストリームが各メッセージを処理している各コンシューマグループを追跡するために必要です。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="daa479a36fbba3ff638d59ae19308e8976bd5ac3" translate="yes" xml:space="preserve">
          <source>Orders of bits</source>
          <target state="translated">ビットの次数</target>
        </trans-unit>
        <trans-unit id="dcfd7c36726b3d9723cbd1a8981b89247967a629" translate="yes" xml:space="preserve">
          <source>Other consumers may inspect the list of pending messages, that are stale for quite some time, using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command. In order to continue processing such messages, they use &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; to acquire the ownership of the message and continue.</source>
          <target state="translated">他のコンシューマは、&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;コマンドを使用して、しばらくの間古くなっている保留中のメッセージのリストを検査する場合があります。このようなメッセージの処理を続行するために、&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;を使用してメッセージの所有権を取得し、続行します。</target>
        </trans-unit>
        <trans-unit id="3c2a27c636dc79870e309393531406e960ec4e18" translate="yes" xml:space="preserve">
          <source>Our previous example returns just the sorted IDs. In some cases, it is more useful to get the actual objects instead of their IDs (&lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;). Retrieving external keys based on the elements in a list, set or sorted set can be done with the following command:</source>
          <target state="translated">前の例では、ソートされたIDのみを返します。場合によっては、ID（ &lt;code&gt;object_1&lt;/code&gt; 、 &lt;code&gt;object_2&lt;/code&gt; 、および &lt;code&gt;object_3&lt;/code&gt; ）ではなく実際のオブジェクトを取得する方が便利です。リスト、セット、またはソート済みセットの要素に基づいて外部キーを取得するには、次のコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="e9c8427bc7498ec3380d38f116037bdd3bcddf6e" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the actual end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">範囲外のインデックスはエラーを生成しません。 &lt;code&gt;start&lt;/code&gt; がリストの最後より大きい場合、空のリストが返されます。 &lt;code&gt;stop&lt;/code&gt; がリストの実際の末尾よりも大きい場合、Redisはストップをリストの最後の要素のように扱います。</target>
        </trans-unit>
        <trans-unit id="c0a3cb19e89ec7bd7c87e53355299d0f62cc91cc" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the largest index in the sorted set, or &lt;code&gt;start &amp;gt;
stop&lt;/code&gt;, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the end of the sorted set Redis will treat it like it is the last element of the sorted set.</source>
          <target state="translated">範囲外のインデックスはエラーを生成しません。 &lt;code&gt;start&lt;/code&gt; がソートされたセットの最大のインデックスより大きい場合、または &lt;code&gt;start &amp;gt; stop&lt;/code&gt; 場合、空のリストが返されます。場合は &lt;code&gt;stop&lt;/code&gt; ソートセットのRedisの端部よりも大きくなって、それはソートセットの最後の要素であるようにそれを扱います。</target>
        </trans-unit>
        <trans-unit id="3dc054b880cd4ad0a83857995e10c362ec4b2504" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error: if &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, or &lt;code&gt;start &amp;gt; end&lt;/code&gt;, the result will be an empty list (which causes &lt;code&gt;key&lt;/code&gt; to be removed). If &lt;code&gt;end&lt;/code&gt; is larger than the end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">範囲外のインデックスはエラーを生成しません： &lt;code&gt;start&lt;/code&gt; がリストの最後より大きいか、 &lt;code&gt;start &amp;gt; end&lt;/code&gt; 場合、結果は空のリストになり &lt;code&gt;key&lt;/code&gt; （これによりキーが削除されます）。 &lt;code&gt;end&lt;/code&gt; がリストの最後より大きい場合、Redisはリストの最後の要素のように扱います。</target>
        </trans-unit>
        <trans-unit id="c4e6b6c77c67abd27de260eb5ce674860a95ad42" translate="yes" xml:space="preserve">
          <source>Out-of-range indexes</source>
          <target state="translated">範囲外のインデックス</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">出力形式</target>
        </trans-unit>
        <trans-unit id="275395efd6e79fdbe55cb36a4ebb4892dbdd5c40" translate="yes" xml:space="preserve">
          <source>Output of the command on replicas</source>
          <target state="translated">レプリカに関するコマンドの出力</target>
        </trans-unit>
        <trans-unit id="5ea9a43450142f5e1cfd51ca7b6956f8a9dbb82d" translate="yes" xml:space="preserve">
          <source>Overflow control</source>
          <target state="translated">オーバーフロー制御</target>
        </trans-unit>
        <trans-unit id="36fd64a953472994b938bbb13337305e87d9a9eb" translate="yes" xml:space="preserve">
          <source>Overwrites part of the string stored at &lt;em&gt;key&lt;/em&gt;, starting at the specified offset, for the entire length of &lt;em&gt;value&lt;/em&gt;. If the offset is larger than the current length of the string at &lt;em&gt;key&lt;/em&gt;, the string is padded with zero-bytes to make &lt;em&gt;offset&lt;/em&gt; fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set &lt;em&gt;value&lt;/em&gt; at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;key&lt;/em&gt;に格納されている文字列の一部を、指定されたオフセットから始めて、&lt;em&gt;valueの&lt;/em&gt;長さ全体を上書きし&lt;em&gt;ます&lt;/em&gt;。オフセットが&lt;em&gt;key&lt;/em&gt;の文字列の現在の長さより大きい場合、文字列はゼロバイトで埋められ、&lt;em&gt;オフセットに&lt;/em&gt;適合します。存在しないキーは空の文字列と見なされるため、このコマンドは、&lt;em&gt;オフセットに&lt;/em&gt;&lt;em&gt;値&lt;/em&gt;を設定できる十分な大きさの文字列を保持していることを確認します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34512fba1d256a361565532a3535096429399084" translate="yes" xml:space="preserve">
          <source>PERSIST</source>
          <target state="translated">PERSIST</target>
        </trans-unit>
        <trans-unit id="ae51373f050f6d2b0e0edfdd08e69fc1968bdf20" translate="yes" xml:space="preserve">
          <source>PERSIST  key   Remove the expiration from a key</source>
          <target state="translated">PERSIST キー キーの有効期限を削除する</target>
        </trans-unit>
        <trans-unit id="7fa59fa06dcb2c9dc1b2b2bd46df7f33912c57b3" translate="yes" xml:space="preserve">
          <source>PEXPIRE</source>
          <target state="translated">PEXPIRE</target>
        </trans-unit>
        <trans-unit id="77a946764b4ffdf95c5ae217ca7f9cec5340bdc1" translate="yes" xml:space="preserve">
          <source>PEXPIRE  key milliseconds   Set a key's time to live in milliseconds</source>
          <target state="translated">PEXPIRE key milliseconds キーのライブ時間をミリ秒単位で設定します。</target>
        </trans-unit>
        <trans-unit id="e609e3af460df9737d7d964f8bfec75a3773bde7" translate="yes" xml:space="preserve">
          <source>PEXPIREAT</source>
          <target state="translated">PEXPIREAT</target>
        </trans-unit>
        <trans-unit id="12d0e8f2d7d7718d124f2a5d583dfa8315ee3c0c" translate="yes" xml:space="preserve">
          <source>PEXPIREAT  key milliseconds-timestamp   Set the expiration for a key as a UNIX timestamp specified in milliseconds</source>
          <target state="translated">PEXPIREAT key milliseconds-timestamp 鍵の有効期限をミリ秒単位で指定したUNIXタイムスタンプとして設定します。</target>
        </trans-unit>
        <trans-unit id="fc7a17907dc63d1312607f17460e9eb6e7871f9d" translate="yes" xml:space="preserve">
          <source>PFADD</source>
          <target state="translated">PFADD</target>
        </trans-unit>
        <trans-unit id="e4e9e83ebacf78fb8cf3124d42502528b53d06ca" translate="yes" xml:space="preserve">
          <source>PFADD  key element [element ...]   Adds the specified elements to the specified HyperLogLog.</source>
          <target state="translated">PFADD key element [element ...]指定されたHyperLogに指定された要素を追加します。</target>
        </trans-unit>
        <trans-unit id="274e92a9d4138573a0f107d2e57b9d0b46e7ac01" translate="yes" xml:space="preserve">
          <source>PFCOUNT</source>
          <target state="translated">PFCOUNT</target>
        </trans-unit>
        <trans-unit id="f81913b01d976cbaac4ade6c06f6bf299ee86214" translate="yes" xml:space="preserve">
          <source>PFCOUNT  key [key ...]   Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</source>
          <target state="translated">PFCOUNT key [key ...]key(s)でHyperLogLogが観測した集合の近似カーディナリティを返します。</target>
        </trans-unit>
        <trans-unit id="62f6ef6fa6924abe295c8c766f2b3e89d6d074fc" translate="yes" xml:space="preserve">
          <source>PFMERGE</source>
          <target state="translated">PFMERGE</target>
        </trans-unit>
        <trans-unit id="2ad005659587e94338ccd67e31dbc3fac2cb1536" translate="yes" xml:space="preserve">
          <source>PFMERGE  destkey sourcekey [sourcekey ...]   Merge N different HyperLogLogs into a single one.</source>
          <target state="translated">PFMERGE destkey sourcekey [sourcekey ...]N個の異なるHyperLogを1つに統合します。</target>
        </trans-unit>
        <trans-unit id="0b1786a083a9087f0db36b08c1ff81a58930fbc2" translate="yes" xml:space="preserve">
          <source>PING</source>
          <target state="translated">PING</target>
        </trans-unit>
        <trans-unit id="45dae0d4784e1c9ea33d8d88f448f7989ea29500" translate="yes" xml:space="preserve">
          <source>PING  [message]   Ping the server</source>
          <target state="translated">PING [メッセージ]サーバーにpingを送信します。</target>
        </trans-unit>
        <trans-unit id="81efb783fc237efd685a1393fa9f947dd8abda5a" translate="yes" xml:space="preserve">
          <source>PSETEX</source>
          <target state="translated">PSETEX</target>
        </trans-unit>
        <trans-unit id="d7c40d1ee18ffeabe6099f89603c950454eb0276" translate="yes" xml:space="preserve">
          <source>PSETEX  key milliseconds value   Set the value and expiration in milliseconds of a key</source>
          <target state="translated">キーの値と有効期限をミリ秒単位で設定します。</target>
        </trans-unit>
        <trans-unit id="9e7e79c8d02bde08c4e705066bd533ffa7218538" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE</source>
          <target state="translated">PSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="71ae64e5df443252e78a1d1f929289a8311a1ef4" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE  pattern [pattern ...]   Listen for messages published to channels matching the given patterns</source>
          <target state="translated">PSUBSCRIBE パターン [pattern ....]与えられたパターンにマッチするチャンネルに公開されたメッセージを聞く</target>
        </trans-unit>
        <trans-unit id="7b8bdca458042e425d2902f59f800419aed5c8b1" translate="yes" xml:space="preserve">
          <source>PTTL</source>
          <target state="translated">PTTL</target>
        </trans-unit>
        <trans-unit id="05bf8ee07e7053cfaf8f62c038f0255fadf89afe" translate="yes" xml:space="preserve">
          <source>PTTL  key   Get the time to live for a key in milliseconds</source>
          <target state="translated">PTTL キー キーのライブ時間をミリ秒単位で取得します。</target>
        </trans-unit>
        <trans-unit id="ff0fc30c743813f924dff4b751315af42d5ab08b" translate="yes" xml:space="preserve">
          <source>PUBLISH</source>
          <target state="translated">PUBLISH</target>
        </trans-unit>
        <trans-unit id="46e845a027f7bb36580703fc200d9108559fa747" translate="yes" xml:space="preserve">
          <source>PUBLISH  channel message   Post a message to a channel</source>
          <target state="translated">PUBLISH チャンネルメッセージ チャンネルにメッセージを投稿する</target>
        </trans-unit>
        <trans-unit id="9487f50e961af3141e0c7833372d9b2c28cfa2a4" translate="yes" xml:space="preserve">
          <source>PUBSUB</source>
          <target state="translated">PUBSUB</target>
        </trans-unit>
        <trans-unit id="acad4a3c05b50f5f04a99427d2a3cdbb983fb0b9" translate="yes" xml:space="preserve">
          <source>PUBSUB  subcommand [argument [argument ...]]   Inspect the state of the Pub/Sub subsystem</source>
          <target state="translated">PUBSUBサブコマンド [引数 [引数 ...]PUB/SUBサブシステムの状態を検査する</target>
        </trans-unit>
        <trans-unit id="ca024e3f958c6b7f4c7fa3671697866707cfa352" translate="yes" xml:space="preserve">
          <source>PUBSUB CHANNELS [pattern]</source>
          <target state="translated">サブチャンネル[パターン]</target>
        </trans-unit>
        <trans-unit id="56e20f63e75d465369356d3ab7aa54f42d22cbb4" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE</source>
          <target state="translated">PUNSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="e54d89cca768ad85f7527ac0169fa1af2910b1cf" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE  [pattern [pattern ...]]   Stop listening for messages posted to channels matching the given patterns</source>
          <target state="translated">PUNSUBSCRIBE [パターン [パターン ...]指定されたパターンにマッチするチャンネルに投稿されたメッセージのリスニングを停止します。</target>
        </trans-unit>
        <trans-unit id="df3251b7546bede28dd0b0e82a26302f58157038" translate="yes" xml:space="preserve">
          <source>Passing keys and arguments as additional &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; arguments is also very useful in this context as the script string remains constant and can be efficiently cached by Redis.</source>
          <target state="translated">キーと引数を追加の&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;引数として渡すことも、スクリプト文字列が一定のままであり、Redisによって効率的にキャッシュできるため、このコンテキストでは非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="19999dd613b36fb0786e599a84893b1e8a156a95" translate="yes" xml:space="preserve">
          <source>Pattern: Circular list</source>
          <target state="translated">パターン。サーキュラーリスト</target>
        </trans-unit>
        <trans-unit id="4d81f3aa2a2c95fc4a2b98f51dce59a3bb00d586" translate="yes" xml:space="preserve">
          <source>Pattern: Counter</source>
          <target state="translated">パターン。カウンター</target>
        </trans-unit>
        <trans-unit id="73ea3bc6eae64663018b769f7c415b912584ee38" translate="yes" xml:space="preserve">
          <source>Pattern: Event notification</source>
          <target state="translated">パターン。イベント通知</target>
        </trans-unit>
        <trans-unit id="9ff13cc43cfbf608a403dd95aced2e1c0f9fa96b" translate="yes" xml:space="preserve">
          <source>Pattern: Navigation session</source>
          <target state="translated">パターン。ナビゲーションセッション</target>
        </trans-unit>
        <trans-unit id="a7fd682d147cfd39262ca78719007b5177407a15" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter</source>
          <target state="translated">パターン。レートリミッター</target>
        </trans-unit>
        <trans-unit id="527a190ff3f82d3d4bdfebea8586b0d301a67e3d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 1</source>
          <target state="translated">パターン。レートリミッター1</target>
        </trans-unit>
        <trans-unit id="d037a3f2c416c91b7789e304c06bd5786301383d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 2</source>
          <target state="translated">パターン。レートリミッター2</target>
        </trans-unit>
        <trans-unit id="18e48daae4954154a5de8c81ecf51283e080aacd" translate="yes" xml:space="preserve">
          <source>Pattern: Reliable queue</source>
          <target state="translated">パターン。信頼性の高いキュー</target>
        </trans-unit>
        <trans-unit id="bc4ebd36f01622a36d608ba3197fe5c6b53d07d7" translate="yes" xml:space="preserve">
          <source>Pattern: Time series</source>
          <target state="translated">パターン 時系列</target>
        </trans-unit>
        <trans-unit id="6aa9774204b5b0358a99c12a75b97dace59e135d" translate="yes" xml:space="preserve">
          <source>Pattern: real time metrics using bitmaps</source>
          <target state="translated">パターン:ビットマップを使ったリアルタイムのメトリクス</target>
        </trans-unit>
        <trans-unit id="387aa2d6e23537ab60fac1801379d3a3550c02d6" translate="yes" xml:space="preserve">
          <source>Pattern: real-time metrics using bitmaps</source>
          <target state="translated">パターン:ビットマップを使ったリアルタイムメトリクス</target>
        </trans-unit>
        <trans-unit id="d8f113cb1df36820baa76cc50b4089ad6af9aea4" translate="yes" xml:space="preserve">
          <source>Pattern: weighted random selection of an element</source>
          <target state="translated">パターン:要素の重み付きランダム選択</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="65bb2cda328eeb96caf6c6dce99ad10ccece742e" translate="yes" xml:space="preserve">
          <source>Pause the clients using &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;を使用してクライアントを一時停止する</target>
        </trans-unit>
        <trans-unit id="172162ae29287e5e829be8811d680119905ff86b" translate="yes" xml:space="preserve">
          <source>Perform a bitwise operation between multiple keys (containing string values) and store the result in the destination key.</source>
          <target state="translated">複数のキー(文字列値を含む)間でビット演算を行い、その結果を宛先キーに格納します。</target>
        </trans-unit>
        <trans-unit id="1627d1d0d50fdeb9a3dce196f5de79d8f43842c0" translate="yes" xml:space="preserve">
          <source>Perform a blocking SAVE if at least one &lt;strong&gt;save point&lt;/strong&gt; is configured.</source>
          <target state="translated">少なくとも1つの&lt;strong&gt;セーブポイント&lt;/strong&gt;が構成されている場合は、ブロッキングSAVEを実行します。</target>
        </trans-unit>
        <trans-unit id="c05e233359dba5b59b70fc0039c9fb4fdb4976d0" translate="yes" xml:space="preserve">
          <source>Perform a partial resynchronization after a disconnection.</source>
          <target state="translated">切断後に部分的な再同期を実行します。</target>
        </trans-unit>
        <trans-unit id="9d05c962f81bccc17939e7dff46bacb302dd37a2" translate="yes" xml:space="preserve">
          <source>Perform the SHA1 of the input string.</source>
          <target state="translated">入力文字列のSHA1を実行します。</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">パフォーマンスの考慮事項</target>
        </trans-unit>
        <trans-unit id="c5453c00c8e4c4429dffd7c57ff9e409df17e57a" translate="yes" xml:space="preserve">
          <source>Performances</source>
          <target state="translated">Performances</target>
        </trans-unit>
        <trans-unit id="98a191010a72a819b496571f1515f19fc5db230c" translate="yes" xml:space="preserve">
          <source>Please check the example below and the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; documentation for more information about the command and its options.</source>
          <target state="translated">コマンドとそのオプションの詳細については、以下の例と&lt;a href=&quot;georadius&quot;&gt;GEORADIUSの&lt;/a&gt;ドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="2adb7fe266cd87cc96a429b9dce43b2d62d33470" translate="yes" xml:space="preserve">
          <source>Please for the specific semantics of the command refer to the documentation of &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;.</source>
          <target state="translated">コマンドの具体的なセマンティクスについては、&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d37ebc2f4f2d1c9e1508f49167dd6105a3aa57b4" translate="yes" xml:space="preserve">
          <source>Please note depending on the version of Redis some of the fields have been added or removed. A robust client application should therefore parse the result of this command by skipping unknown properties, and gracefully handle missing fields.</source>
          <target state="translated">Redisのバージョンによっては、いくつかのフィールドが追加されたり削除されたりしていることに注意してください。したがって、堅牢なクライアントアプリケーションは、未知のプロパティをスキップしてこのコマンドの結果を解析し、欠落しているフィールドを優雅に処理しなければなりません。</target>
        </trans-unit>
        <trans-unit id="cf36c5202e34a4a67ab38d9f9bd7222bda763dfd" translate="yes" xml:space="preserve">
          <source>Please note that before reading this page, if you are new to streams, we recommend to read &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;our introduction to Redis Streams&lt;/a&gt;.</source>
          <target state="translated">このページを読む前に、ストリーム&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;に慣れてい&lt;/a&gt;ない場合は、Redis Streamsの概要を読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="95e0253f33057b2f70a061e11de2d3d4a685d9c7" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; documentation for detailed information about Redis Lua scripting.</source>
          <target state="translated">Redis Luaスクリプトの詳細については、&lt;a href=&quot;eval&quot;&gt;EVALの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="67fc81a1bc0292fa12fdf63856d1ae3a69b0523a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence documentation&lt;/a&gt; for detailed information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;永続性のドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7a135ffdb71c43178f876e40f960bf45f1a29237" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;ドキュメントのパターンの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="aed6d393dd61d1ba31957e351636ff901b0e6fa8" translate="yes" xml:space="preserve">
          <source>Posts a message to the given channel.</source>
          <target state="translated">指定されたチャンネルにメッセージを投稿します。</target>
        </trans-unit>
        <trans-unit id="f815dfb4f6f438e54dc2f0a16193e4c96d3c1109" translate="yes" xml:space="preserve">
          <source>Practically speaking, for the client it is much better to simply assume that in the context of a given connection, cached scripts are guaranteed to be there unless an administrator explicitly called the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command.</source>
          <target state="translated">実際には、クライアントにとって、特定の接続のコンテキストでは、管理者が明示的に&lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt;コマンドを呼び出さない限り、キャッシュされたスクリプトが存在することが保証されていると単純に想定する方がはるかに優れています。</target>
        </trans-unit>
        <trans-unit id="4d21fc376a96084ebb73d4e8b35c0a4c4be845e0" translate="yes" xml:space="preserve">
          <source>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, or &lt;code&gt;sentinel&lt;/code&gt;. The command also returns additional information about the state of the replication (if the role is master or slave) or the list of monitored master names (if the role is sentinel).</source>
          <target state="translated">インスタンスが現在 &lt;code&gt;master&lt;/code&gt; 、 &lt;code&gt;slave&lt;/code&gt; 、または &lt;code&gt;sentinel&lt;/code&gt; であるかどうかを返すことにより、レプリケーションのコンテキストでのRedisインスタンスの役割に関する情報を提供します。このコマンドは、レプリケーションの状態に関する追加情報（役割がマスターまたはスレーブの場合）または監視対象のマスター名のリスト（役割が標識の場合）も返します。</target>
        </trans-unit>
        <trans-unit id="7ca91750d60fd45e80636934b3d1f1da26ffd9f9" translate="yes" xml:space="preserve">
          <source>Pub/Sub</source>
          <target state="translated">Pub/Sub</target>
        </trans-unit>
        <trans-unit id="5860c8458788e44e7636fa364548e067049a0d7b" translate="yes" xml:space="preserve">
          <source>QUIT</source>
          <target state="translated">QUIT</target>
        </trans-unit>
        <trans-unit id="7471799996c7de46c4ffa444365596fb514b6f5a" translate="yes" xml:space="preserve">
          <source>QUIT   Close the connection</source>
          <target state="translated">QUIT 接続を閉じる</target>
        </trans-unit>
        <trans-unit id="baa5d3184c0cc0ce5e007af06198524a4d26548f" translate="yes" xml:space="preserve">
          <source>Quit the server.</source>
          <target state="translated">サーバーを終了します。</target>
        </trans-unit>
        <trans-unit id="94386a96dc3f69665a14e74fb2942d92163c5d74" translate="yes" xml:space="preserve">
          <source>RANDOMKEY</source>
          <target state="translated">RANDOMKEY</target>
        </trans-unit>
        <trans-unit id="338552ba06825ef4f555f3d5ff79d40557c925de" translate="yes" xml:space="preserve">
          <source>RANDOMKEY   Return a random key from the keyspace</source>
          <target state="translated">RANDOMKEY 鍵空間からランダムなキーを返します。</target>
        </trans-unit>
        <trans-unit id="90a97e888676c2d0f3b14c8b4a5ca16d360880bc" translate="yes" xml:space="preserve">
          <source>READONLY</source>
          <target state="translated">READONLY</target>
        </trans-unit>
        <trans-unit id="21d1a8e094bd428debefea84e6dd96322d4c6011" translate="yes" xml:space="preserve">
          <source>READONLY   Enables read queries for a connection to a cluster replica node</source>
          <target state="translated">READONLY クラスタ・レプリカ・ノードへの接続に対する読み取りクエリを有効にします。</target>
        </trans-unit>
        <trans-unit id="5305e8529d963d471cecc6faf967cedff2ea7494" translate="yes" xml:space="preserve">
          <source>READWRITE</source>
          <target state="translated">READWRITE</target>
        </trans-unit>
        <trans-unit id="2ae19352a72e6e879b7c82d353a544f20f6b355b" translate="yes" xml:space="preserve">
          <source>READWRITE   Disables read queries for a connection to a cluster replica node</source>
          <target state="translated">READWRITE クラスタ・レプリカ・ノードへの接続に対する読み取りクエリを無効にします。</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="434016433de8ed51fc6a3df25c58d49e8397ca2e" translate="yes" xml:space="preserve">
          <source>RENAME  key newkey   Rename a key</source>
          <target state="translated">RENAME key newkey キーの名前を変更します。</target>
        </trans-unit>
        <trans-unit id="eb9b6064a90c47e23a80adefc9b43f4215668dbe" translate="yes" xml:space="preserve">
          <source>RENAMENX</source>
          <target state="translated">RENAMENX</target>
        </trans-unit>
        <trans-unit id="e1288934ac4d4000f51ff88bf791420487a34758" translate="yes" xml:space="preserve">
          <source>RENAMENX  key newkey   Rename a key, only if the new key does not exist</source>
          <target state="translated">RENAMENX key newkey キーの名前を変更します。</target>
        </trans-unit>
        <trans-unit id="12c92fcd35c554e1970345d0c852363a2bfff485" translate="yes" xml:space="preserve">
          <source>REPLICAOF</source>
          <target state="translated">REPLICAOF</target>
        </trans-unit>
        <trans-unit id="81253c78d1304948f92fc2d7488335ba2280cd3f" translate="yes" xml:space="preserve">
          <source>REPLICAOF  host port   Make the server a replica of another instance, or promote it as master.</source>
          <target state="translated">REPLICAOF ホストポート サーバを別のインスタンスのレプリカにするか、マスタとして昇格させます。</target>
        </trans-unit>
        <trans-unit id="6a8135bcdb582d28d5425eef52faf6ac80eefb26" translate="yes" xml:space="preserve">
          <source>RESTORE</source>
          <target state="translated">RESTORE</target>
        </trans-unit>
        <trans-unit id="693be3f2ba1e3d54a77f2bd81f59053740c9352a" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTORE key ttl serialized-value [REPLACE]以前にDUMPを使用して取得した、与えられたシリアライズされた値を使用してキーを作成します。</target>
        </trans-unit>
        <trans-unit id="1631070e7f0b44982ae66b11640654e7ec5dc4bd" translate="yes" xml:space="preserve">
          <source>ROLE</source>
          <target state="translated">ROLE</target>
        </trans-unit>
        <trans-unit id="5b2e8afa66ad35a6843b32ab5ca521321ed80e09" translate="yes" xml:space="preserve">
          <source>ROLE   Return the role of the instance in the context of replication</source>
          <target state="translated">ROLE レプリケーションのコンテキストにおけるインスタンスのロールを返します。</target>
        </trans-unit>
        <trans-unit id="b7ce3009275f8c79b50c7f42dcb85f259fc1334f" translate="yes" xml:space="preserve">
          <source>RPOP</source>
          <target state="translated">RPOP</target>
        </trans-unit>
        <trans-unit id="daae95751cd7b3b0d6286ba595f17b95a4dbf14d" translate="yes" xml:space="preserve">
          <source>RPOP  key   Remove and get the last element in a list</source>
          <target state="translated">RPOPキー リストの最後の要素を削除して取得する</target>
        </trans-unit>
        <trans-unit id="5fc91e22c7eda82f26217a9a276a557189795a83" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH</source>
          <target state="translated">RPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="9b4f14c63b639db09e2a8cbabb9aee76bf074fd7" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH  source destination   Remove the last element in a list, prepend it to another list and return it</source>
          <target state="translated">RPOPLPUSH ソース デスティネーション リストの最後の要素を削除し、別のリストに前置して返す</target>
        </trans-unit>
        <trans-unit id="b9d73dc860be3da3eb63b95dc888be66d34c596b" translate="yes" xml:space="preserve">
          <source>RPUSH</source>
          <target state="translated">RPUSH</target>
        </trans-unit>
        <trans-unit id="cc9293df01dd3379605fef72d334681379153757" translate="yes" xml:space="preserve">
          <source>RPUSH  key value [value ...]   Append one or multiple values to a list</source>
          <target state="translated">RPUSH キー値 [value ....]1つまたは複数の値をリストに追加します。</target>
        </trans-unit>
        <trans-unit id="a2fe5b491151e540de6422c6e85592df5f204dc3" translate="yes" xml:space="preserve">
          <source>RPUSHX</source>
          <target state="translated">RPUSHX</target>
        </trans-unit>
        <trans-unit id="61d6ff5cbc32d5fc0ed38bfb10b34d14916d1c00" translate="yes" xml:space="preserve">
          <source>RPUSHX  key value   Append a value to a list, only if the list exists</source>
          <target state="translated">RPUSHX キー値 リストが存在する場合にのみ、リストに値を追加します。</target>
        </trans-unit>
        <trans-unit id="a31a9b75b6318e8c48bf5d454b96698ee608da57" translate="yes" xml:space="preserve">
          <source>Range of integer scores that can be expressed precisely</source>
          <target state="translated">正確に表現できる整数スコアの範囲</target>
        </trans-unit>
        <trans-unit id="df8903174eb3eac863f1253076caa8171702cb53" translate="yes" xml:space="preserve">
          <source>Range: 3900-4000</source>
          <target state="translated">範囲。3900-4000</target>
        </trans-unit>
        <trans-unit id="e1d33f7270a253d76d9b6fe1deb9155ecce0ca42" translate="yes" xml:space="preserve">
          <source>Read data from one or multiple streams, only returning entries with an ID greater than the last received ID reported by the caller. This command has an option to block if items are not available, in a similar fashion to &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; and others.</source>
          <target state="translated">1つまたは複数のストリームからデータを読み取り、呼び出し元から報告された最後に受信したIDより大きいIDを持つエントリのみを返します。このコマンドには、&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;や&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;などと同様に、アイテムが利用できない場合にブロックするオプションがあります。</target>
        </trans-unit>
        <trans-unit id="58ccdcefd173a8269ea376346a634ff6e968e57b" translate="yes" xml:space="preserve">
          <source>Read only variants</source>
          <target state="translated">読み取りバリアントのみ</target>
        </trans-unit>
        <trans-unit id="b8590ac877c85f2030d4921db5e93ead78595a0f" translate="yes" xml:space="preserve">
          <source>Read queries against a Redis Cluster slave node are disabled by default, but you can use the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command to change this behavior on a per- connection basis. The &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; command resets the readonly mode flag of a connection back to readwrite.</source>
          <target state="translated">Redisクラスタースレーブノードに対する読み取りクエリはデフォルトで無効になっていますが、&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;コマンドを使用して、この動作を接続ごとに変更できます。&lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt;コマンドは、読み書きに接続裏面の読み取り専用モードフラグをリセットします。</target>
        </trans-unit>
        <trans-unit id="9ec77fdefc87d676b3e9acb9a7b04ded405da8e4" translate="yes" xml:space="preserve">
          <source>Reading application code, the complete semantics might not be clear since the application calls commands defined server side.</source>
          <target state="translated">アプリケーションのコードを読むと、サーバ側で定義されたコマンドを呼び出しているため、完全なセマンティクスが不明瞭になることがあります。</target>
        </trans-unit>
        <trans-unit id="116cec955773e978e0eecf1499a10199d4278c99" translate="yes" xml:space="preserve">
          <source>Reading the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams introduction&lt;/a&gt; is highly suggested in order to understand more about the streams overall behavior and semantics.</source>
          <target state="translated">ストリーム全体の動作とセマンティクスについて理解を深めるために、&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redisストリーム&lt;/a&gt;の概要を読むことを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="88951d0701502f598feecc55f4d3172c32a2db31" translate="yes" xml:space="preserve">
          <source>Reading the slow log</source>
          <target state="translated">遅いログを読む</target>
        </trans-unit>
        <trans-unit id="a87de541283ca3bc3c0a398706ee3346da0564e3" translate="yes" xml:space="preserve">
          <source>Recent versions of Redis Sentinel (Redis 2.8.12 or greater) use CLIENT KILL in order to kill clients when an instance is reconfigured, in order to force clients to perform the handshake with one Sentinel again and update its configuration.</source>
          <target state="translated">Redis Sentinelの最近のバージョン(Redis 2.8.12以上)では、インスタンスが再構成されたときにクライアントを殺すためにCLIENT KILLを使用します。</target>
        </trans-unit>
        <trans-unit id="68c1dff2ef06724a3eb5f0a503f24117784a62d1" translate="yes" xml:space="preserve">
          <source>Reconfigure clients to connect with the new master.</source>
          <target state="translated">新しいマスターに接続するためにクライアントを再設定します。</target>
        </trans-unit>
        <trans-unit id="24071b57a13027c01339027dcccb98218f052a8f" translate="yes" xml:space="preserve">
          <source>Redis</source>
          <target state="translated">Redis</target>
        </trans-unit>
        <trans-unit id="64fb7fd6108bc6be312c9ee1e4ae786b08c32a13" translate="yes" xml:space="preserve">
          <source>Redis 3.2 introduced an optional &lt;code&gt;count&lt;/code&gt; argument that can be passed to &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; in order to retrieve multiple elements in a single call.</source>
          <target state="translated">Redis 3.2では、1回の呼び出しで複数の要素を取得するために&lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;に渡すことができるオプションの &lt;code&gt;count&lt;/code&gt; 引数が導入されました。</target>
        </trans-unit>
        <trans-unit id="09da59c00f13190142c29bd0fc09b7580fb99363" translate="yes" xml:space="preserve">
          <source>Redis Cluster live resharding explained</source>
          <target state="translated">Redisクラスタのライブreshardingは説明されています</target>
        </trans-unit>
        <trans-unit id="8be0343488efef207b0826c15486c08f81f5710d" translate="yes" xml:space="preserve">
          <source>Redis HyperLogLogs are represented using a double representation: the &lt;em&gt;sparse&lt;/em&gt; representation suitable for HLLs counting a small number of elements (resulting in a small number of registers set to non-zero value), and a &lt;em&gt;dense&lt;/em&gt; representation suitable for higher cardinalities. Redis automatically switches from the sparse to the dense representation when needed.</source>
          <target state="translated">Redis HyperLogLogsは、2つの表現を使用して表されます。HLLが少数の要素をカウントするのに適した&lt;em&gt;疎な&lt;/em&gt;表現（結果として、少数のレジスタがゼロ以外の値に設定される）と、より高いカーディナリティに適した&lt;em&gt;密な&lt;/em&gt;表現。Redisは必要に応じて、自動的に疎表現から密表現に切り替えます。</target>
        </trans-unit>
        <trans-unit id="2e645ecd73ea1ffa136575150e55a17bbdaf4a35" translate="yes" xml:space="preserve">
          <source>Redis Nil bulk reply and Nil multi bulk reply -&amp;gt; Lua false boolean type</source>
          <target state="translated">Redis Nilバルク応答およびNilマルチバルク応答-&amp;gt; Lua falseブール型</target>
        </trans-unit>
        <trans-unit id="12deb2b7b17fe48280b9acc8ac6e268a2fccdfc8" translate="yes" xml:space="preserve">
          <source>Redis bulk reply -&amp;gt; Lua string</source>
          <target state="translated">Redis一括返信-&amp;gt; Lua文字列</target>
        </trans-unit>
        <trans-unit id="28c992585f8b92e96ef7862e17fbc69b72429ffe" translate="yes" xml:space="preserve">
          <source>Redis commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements.</source>
          <target state="translated">&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt;（Redisセットは&lt;em&gt;順序付けされていない&lt;/em&gt;ため）などのランダムな順序で要素を返す可能性のあるRedisコマンドは、Luaから呼び出されたときに異なる動作をし、Luaスクリプトにデータを返す前にサイレント辞書式ソートフィルターを実行します。したがって、 &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; は常にSet要素を同じ順序で返しますが、通常のクライアントから呼び出された同じコマンドは、キーにまったく同じ要素が含まれている場合でも異なる結果を返すことがあります。</target>
        </trans-unit>
        <trans-unit id="9030a22b56473e440d80783adf7755f42e3cd798" translate="yes" xml:space="preserve">
          <source>Redis commands usually accept one key, two keys, or an unlimited number of keys.</source>
          <target state="translated">Redisコマンドは通常、1つのキー、2つのキー、または無制限の数のキーを受け入れます。</target>
        </trans-unit>
        <trans-unit id="4798309557a5e9b4d97ab42c59e238806f00fa04" translate="yes" xml:space="preserve">
          <source>Redis different selectable databases are a form of namespacing: all the databases are anyway persisted together in the same RDB / AOF file. However different databases can have keys having the same name, and there are commands available like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; that work on specific databases.</source>
          <target state="translated">Redisの異なる選択可能なデータベースは名前空間の形式です。すべてのデータベースは、とにかく同じRDB / AOFファイルに一緒に永続化されます。ただし、異なるデータベースに同じ名前のキーを&lt;a href=&quot;flushdb&quot;&gt;含める&lt;/a&gt;ことができ、特定のデータベースで機能するFLUSHDB、&lt;a href=&quot;swapdb&quot;&gt;SWAPDB、&lt;/a&gt;または&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;などのコマンドを使用できます。</target>
        </trans-unit>
        <trans-unit id="a48311c837dbe1e0c3cec8f3114d4df2e8c16385" translate="yes" xml:space="preserve">
          <source>Redis error reply -&amp;gt; Lua table with a single &lt;code&gt;err&lt;/code&gt; field containing the error</source>
          <target state="translated">Redisエラー応答-&amp;gt; エラーを含む単一の &lt;code&gt;err&lt;/code&gt; フィールドを持つLuaテーブル</target>
        </trans-unit>
        <trans-unit id="562ad79eb5fcdcd97d8a0283855bce99c0023855" translate="yes" xml:space="preserve">
          <source>Redis integer reply -&amp;gt; Lua number</source>
          <target state="translated">Redis整数応答-&amp;gt; Lua番号</target>
        </trans-unit>
        <trans-unit id="53c0959152bcf66e99f3ab4d98ebaba488b539de" translate="yes" xml:space="preserve">
          <source>Redis is UTF-8 aware, assuming you correctly set the &lt;code&gt;!LC_COLLATE&lt;/code&gt; environment variable.</source>
          <target state="translated">RedisはUTF &lt;code&gt;!LC_COLLATE&lt;/code&gt; 対応しており、！LC_COLLATE環境変数が正しく設定されていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="ac11208b3186492fddcf23ffb985bed2f4b921dd" translate="yes" xml:space="preserve">
          <source>Redis is now able to delete keys in the background in a different thread without blocking the server. An &lt;code&gt;ASYNC&lt;/code&gt; option was added to &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; in order to let the entire dataset or a single database to be freed asynchronously.</source>
          <target state="translated">Redisは、サーバーをブロックすることなく、別のスレッドのバックグラウンドでキーを削除できるようになりました。 &lt;code&gt;ASYNC&lt;/code&gt; のオプションがに追加された&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;と&lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;データセット全体または非同期的に解放される単一のデータベースをもらうために。</target>
        </trans-unit>
        <trans-unit id="f26191bd07f5d296d686b49ddf0fea28de008280" translate="yes" xml:space="preserve">
          <source>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (using polling), or &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; if the client is better served by a blocking operation.</source>
          <target state="translated">Redisは、バックグラウンドジョブやその他の種類のメッセージングタスクの処理を実装するメッセージングサーバーとしてよく使用されます。単純な形式のキューは、プロデューサー側のリストに値をプッシュして取得され、コンシューマー側で&lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt;（ポーリングを使用）を使用してこの値を待機するか、クライアントがブロッキング操作でより適切にサービスを提供している場合は&lt;a href=&quot;brpop&quot;&gt;BRPOPを取得&lt;/a&gt;します。</target>
        </trans-unit>
        <trans-unit id="42a27bac8c1f348420272658d3c655887b07c3ba" translate="yes" xml:space="preserve">
          <source>Redis keys are expired in two ways: a passive way, and an active way.</source>
          <target state="translated">Redisの鍵の有効期限は、受動的な方法と能動的な方法の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="ea38abb16e6fc53c1055d716b8dafffc97128c14" translate="yes" xml:space="preserve">
          <source>Redis logs that a script is running too long.</source>
          <target state="translated">Redisはスクリプトの実行時間が長すぎることをログに記録します。</target>
        </trans-unit>
        <trans-unit id="5ada15ccb812ae3dfe260cac4cea16ab388a5061" translate="yes" xml:space="preserve">
          <source>Redis multi bulk reply -&amp;gt; Lua table (may have other Redis data types nested)</source>
          <target state="translated">Redisマルチバルク返信-&amp;gt; Luaテーブル（他のRedisデータ型がネストされている場合があります）</target>
        </trans-unit>
        <trans-unit id="cb910cc16645a1fbd760219098ebcbf7bc9f050c" translate="yes" xml:space="preserve">
          <source>Redis offers a SCRIPT command that can be used in order to control the scripting subsystem. SCRIPT currently accepts three different commands:</source>
          <target state="translated">Redisはスクリプトサブシステムを制御するために使用できるSCRIPTコマンドを提供しています。SCRIPTは現在3つの異なるコマンドを受け付けています。</target>
        </trans-unit>
        <trans-unit id="0ab17f17e02f188a1bdf8cac0d6180f82fee1717" translate="yes" xml:space="preserve">
          <source>Redis return values are converted into Lua data types when Lua calls a Redis command using &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;pcall()&lt;/code&gt;. Similarly, Lua data types are converted into the Redis protocol when calling a Redis command and when a Lua script returns a value, so that scripts can control what &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will return to the client.</source>
          <target state="translated">Luaが &lt;code&gt;call()&lt;/code&gt; または &lt;code&gt;pcall()&lt;/code&gt; を使用してRedisコマンドを呼び出すと、Redisの戻り値がLuaデータ型に変換されます。同様に、Luaデータ型は、Redisコマンドを呼び出すとき、およびLuaスクリプトが値を返すときにRedisプロトコルに変換されるので、スクリプトは&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;がクライアントに返す内容を制御できます。</target>
        </trans-unit>
        <trans-unit id="0fa967ae24b949a1700795759c8cdfe062988a8a" translate="yes" xml:space="preserve">
          <source>Redis scripts are not allowed to create global variables, in order to avoid leaking data into the Lua state. If a script needs to maintain state between calls (a pretty uncommon need) it should use Redis keys instead.</source>
          <target state="translated">Redisスクリプトでは、Luaの状態にデータが漏れることを避けるため、グローバル変数を作成することはできません。呼び出しの間に状態を維持する必要がある場合は、代わりにRedisキーを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e62135b0922f82850c893085d4cd08cc6fd7ccb4" translate="yes" xml:space="preserve">
          <source>Redis slow log overview</source>
          <target state="translated">Redisの遅いログの概要</target>
        </trans-unit>
        <trans-unit id="add967db3e0dd55b3522bf60d87afa3192a4838a" translate="yes" xml:space="preserve">
          <source>Redis sorted sets use a &lt;em&gt;double 64-bit floating point number&lt;/em&gt; to represent the score. In all the architectures we support, this is represented as an &lt;strong&gt;IEEE 754 floating point number&lt;/strong&gt;, that is able to represent precisely integer numbers between &lt;code&gt;-(2^53)&lt;/code&gt; and &lt;code&gt;+(2^53)&lt;/code&gt; included. In more practical terms, all the integers between -9007199254740992 and 9007199254740992 are perfectly representable. Larger integers, or fractions, are internally represented in exponential form, so it is possible that you get only an approximation of the decimal number, or of the very big integer, that you set as score.</source>
          <target state="translated">Redisソートセットは、スコアを表すために&lt;em&gt;64ビットの浮動小数点数&lt;/em&gt;を使用します。私たちがサポートするすべてのアーキテクチャでは、これは&lt;strong&gt;IEEE 754浮動小数点数&lt;/strong&gt;として表され、含まれる &lt;code&gt;-(2^53)&lt;/code&gt; から &lt;code&gt;+(2^53)&lt;/code&gt; までの整数を正確に表すことができます。より実際的には、-9007199254740992から9007199254740992までの整数はすべて完全に表現可能です。大きい整数、または分数は内部的に指数形式で表されるため、スコアとして設定した10進数または非常に大きな整数の概算のみが得られる可能性があります。</target>
        </trans-unit>
        <trans-unit id="738a4a620b4c28b97c15ca1b2edd5526cb23af29" translate="yes" xml:space="preserve">
          <source>Redis status reply -&amp;gt; Lua table with a single &lt;code&gt;ok&lt;/code&gt; field containing the status</source>
          <target state="translated">Redisステータス応答-&amp;gt; ステータスを含む単一の &lt;code&gt;ok&lt;/code&gt; フィールドを持つLuaテーブル</target>
        </trans-unit>
        <trans-unit id="db935d0902ab47146d7cddc707ae23f8dbd30e13" translate="yes" xml:space="preserve">
          <source>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</source>
          <target state="translated">Redis は整数を整数表現で保存するので、実際に整数を保持する文字列値の場合、整数の文字列表現を保存するためのオーバーヘッドはありません。</target>
        </trans-unit>
        <trans-unit id="b6955638f080137455ca2315a3e774bacb29e670" translate="yes" xml:space="preserve">
          <source>Redis streams are represented in a way that makes them memory efficient: a radix tree is used in order to index macro-nodes that pack linearly tens of stream entries. Normally what happens when you delete an entry from a stream is that the entry is not &lt;em&gt;really&lt;/em&gt; evicted, it just gets marked as deleted.</source>
          <target state="translated">Redisストリームは、メモリを効率的にする方法で表現されます。基数ツリーは、数十のストリームエントリを線形にパックするマクロノードにインデックスを付けるために使用されます。通常、ストリームからエントリを削除すると、エントリは&lt;em&gt;実際に&lt;/em&gt;は削除されず、削除済みとしてマークされます。</target>
        </trans-unit>
        <trans-unit id="fa7af6984c788798f4aee1b72f3fb15136c972f4" translate="yes" xml:space="preserve">
          <source>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</source>
          <target state="translated">Redisは同じLuaインタープリターを使用してすべてのコマンドを実行します。また、Redisは、スクリプトがアトミックな方法で実行されることを保証します。スクリプトの実行中は、他のスクリプトやRedisコマンドは実行されません。このセマンティクスは、&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXECの&lt;/a&gt;セマンティクスに似ています。他のすべてのクライアントの観点から見ると、スクリプトの効果はまだ表示されていないか、すでに完了しています。</target>
        </trans-unit>
        <trans-unit id="315e6feef25876fa664b37d723e94c657b1c8f6a" translate="yes" xml:space="preserve">
          <source>Redis will block the script with an error if a script calls a Redis command able to alter the data set &lt;strong&gt;after&lt;/strong&gt; a Redis &lt;em&gt;random&lt;/em&gt; command like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;. This means that if a script is read-only and does not modify the data set it is free to call those commands. Note that a &lt;em&gt;random command&lt;/em&gt; does not necessarily mean a command that uses random numbers: any non-deterministic command is considered a random command (the best example in this regard is the &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command).</source>
          <target state="translated">スクリプトが&lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;、&lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;、&lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;などのRedis &lt;em&gt;ランダム&lt;/em&gt;コマンドの&lt;strong&gt;後で&lt;/strong&gt;データセットを変更できるRedisコマンドを呼び出すと、Redisはエラーでスクリプトをブロックします。つまり、スクリプトが読み取り専用でデータセットを変更しない場合は、それらのコマンドを自由に呼び出すことができます。&lt;em&gt;ランダムコマンド&lt;/em&gt;は必ずしも乱数を使用するコマンドを意味するわけではないことに注意してください。非決定的コマンドはランダムコマンドと見なされます（この点での最良の例は&lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;コマンドです）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d65bbb9c212a9d98ffb329def918b64ef3d8889" translate="yes" xml:space="preserve">
          <source>Refreshing expires</source>
          <target state="translated">リフレッシングの有効期限</target>
        </trans-unit>
        <trans-unit id="26ca731c99535195e55e64ad25c62f00fdbd2a4c" translate="yes" xml:space="preserve">
          <source>Reliable queues</source>
          <target state="translated">信頼性の高いテール</target>
        </trans-unit>
        <trans-unit id="ea59d67e277c60b336a409408ff4d775b8225584" translate="yes" xml:space="preserve">
          <source>Remove a specific consumer from a consumer group.</source>
          <target state="translated">特定の消費者を消費者グループから削除します。</target>
        </trans-unit>
        <trans-unit id="ce4d2a865a5a06124187f3a0d8a5354cd701d61f" translate="yes" xml:space="preserve">
          <source>Remove the existing timeout on &lt;code&gt;key&lt;/code&gt;, turning the key from &lt;em&gt;volatile&lt;/em&gt; (a key with an expire set) to &lt;em&gt;persistent&lt;/em&gt; (a key that will never expire as no timeout is associated).</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; の既存のタイムアウトを削除し、キーを&lt;em&gt;揮発性&lt;/em&gt;（有効期限が設定されたキー）から&lt;em&gt;永続的&lt;/em&gt;（タイムアウトが関連付けられていないため期限切れにならないキー）に変更します。</target>
        </trans-unit>
        <trans-unit id="c1d260f4e3da83fa28a692c23e66ed0cb15dd796" translate="yes" xml:space="preserve">
          <source>Remove the specified members from the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are not a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty set and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているセットから指定されたメンバーを削除します。このセットのメンバーではない指定されたメンバーは無視されます。場合は &lt;code&gt;key&lt;/code&gt; 存在しない、それが空集合として扱われ、このコマンドが返す &lt;code&gt;0&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="de0b8cb5dfcd4da1251a55ebacec477902ab7fa1" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (inclusive).</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; &lt;code&gt;max&lt;/code&gt; から最大値（両端を含む）までのスコアを持つ &lt;code&gt;key&lt;/code&gt; 格納されているソート済みセットのすべての要素を削除します。</target>
        </trans-unit>
        <trans-unit id="cbb3fc019bde7aa5a4f4696386c7635ab2172c17" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with rank between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt; -based indexes with &lt;code&gt;0&lt;/code&gt; being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score. For example: &lt;code&gt;-1&lt;/code&gt; is the element with the highest score, &lt;code&gt;-2&lt;/code&gt; the element with the second highest score and so forth.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; の間のランクで &lt;code&gt;key&lt;/code&gt; に格納されているソート済みセットのすべての要素を削除します。 &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; はどちらも &lt;code&gt;0&lt;/code&gt; ベースのインデックスで、 &lt;code&gt;0&lt;/code&gt; が最低のスコアの要素です。これらのインデックスは負の数にすることができ、スコアが最も高い要素から始まるオフセットを示します。たとえば、 &lt;code&gt;-1&lt;/code&gt; は最も高いスコアの要素、 &lt;code&gt;-2&lt;/code&gt; は2番目に高いスコアの要素などです。</target>
        </trans-unit>
        <trans-unit id="da37c36034834387a9dd7fbda191a975ebb105b0" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random elements from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; の設定値ストアから1つ以上のランダム要素を削除して返します。</target>
        </trans-unit>
        <trans-unit id="870ac46dca2c1a6689064e1cced801af5e158f69" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの最初の要素を削除して返します。</target>
        </trans-unit>
        <trans-unit id="ec2ce52901cbc45793a1c6bb41b722b9057d2bc4" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの最後の要素を削除して返します。</target>
        </trans-unit>
        <trans-unit id="52acb45013cdb2a41dc580913c01c50bd6ebca86" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the highest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソートされたセットの中で最高のスコアを持つ最大 &lt;code&gt;count&lt;/code&gt; メンバーを削除して返します。</target>
        </trans-unit>
        <trans-unit id="ac48e8c652eae033a19d95a11cb8d9dbd5e35dab" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the lowest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソートされたセットでスコアが最も低いメンバーを最大で &lt;code&gt;count&lt;/code&gt; 個削除して返します。</target>
        </trans-unit>
        <trans-unit id="7c6ffaff6ffe08c9f43baab9718f030d2162d111" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;value&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストから、 &lt;code&gt;value&lt;/code&gt; に等しい要素の最初の &lt;code&gt;count&lt;/code&gt; 個の出現を削除します。 &lt;code&gt;count&lt;/code&gt; 引数は、次の方法での動作に影響を与えます：</target>
        </trans-unit>
        <trans-unit id="494ca7e2faa6bd5b36a369eb7746bb78fb3e96bc" translate="yes" xml:space="preserve">
          <source>Removes the specified entries from a stream, and returns the number of entries deleted, that may be different from the number of IDs passed to the command in case certain IDs do not exist.</source>
          <target state="translated">ストリームから指定されたエントリを削除し、削除したエントリの数を返します。</target>
        </trans-unit>
        <trans-unit id="594397839f7156989bc1b259c19072c5484f7bdc" translate="yes" xml:space="preserve">
          <source>Removes the specified fields from the hash stored at &lt;code&gt;key&lt;/code&gt;. Specified fields that do not exist within this hash are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty hash and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているハッシュから指定されたフィールドを削除します。このハッシュ内に存在しない指定されたフィールドは無視されます。場合は &lt;code&gt;key&lt;/code&gt; 存在しない、それが空のハッシュとして扱われ、このコマンドが返す &lt;code&gt;0&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="322e3109be94b3ac9ea4c2a44f232f96c6cd905a" translate="yes" xml:space="preserve">
          <source>Removes the specified keys. A key is ignored if it does not exist.</source>
          <target state="translated">指定されたキーを削除します。キーが存在しない場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="933e4f3eff042f249c190608a122f8e43bd494af" translate="yes" xml:space="preserve">
          <source>Removes the specified members from the sorted set stored at &lt;code&gt;key&lt;/code&gt;. Non existing members are ignored.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソート済みセットから指定されたメンバーを削除します。存在しないメンバーは無視されます。</target>
        </trans-unit>
        <trans-unit id="17baa9fe7f8ed0143fa7df75975e104465db4e59" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; does not yet exist. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">名前を変更し &lt;code&gt;key&lt;/code&gt; に &lt;code&gt;newkey&lt;/code&gt; 場合 &lt;code&gt;newkey&lt;/code&gt; まだ存在していません。 &lt;code&gt;key&lt;/code&gt; が存在しない場合はエラーを返します。</target>
        </trans-unit>
        <trans-unit id="0155259665636f6ceaaa0a0ebda67bb195d98a6d" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt;. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist. If &lt;code&gt;newkey&lt;/code&gt; already exists it is overwritten, when this happens &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; executes an implicit &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation, so if the deleted key contains a very big value it may cause high latency even if &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; itself is usually a constant-time operation.</source>
          <target state="translated">名前を変更し &lt;code&gt;key&lt;/code&gt; に &lt;code&gt;newkey&lt;/code&gt; 。 &lt;code&gt;key&lt;/code&gt; が存在しない場合はエラーを返します。 &lt;code&gt;newkey&lt;/code&gt; がすでに存在する場合、上書きされます。この場合、&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;は暗黙の&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;操作を実行するため、削除されたキーに非常に大きな値が含まれている場合、&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;自体が通常は一定時間の操作であっても、レイテンシが長くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="351fb2e9d60cd91bf6510354de71fa6c06419ab4" translate="yes" xml:space="preserve">
          <source>Replicas broadcast their master's config epochs (in order to get an &lt;code&gt;UPDATE&lt;/code&gt; message if they are found to be stale), so the real config epoch of the replica (which is meaningless more or less, since they don't serve hash slots) can be only obtained checking the node flagged as &lt;code&gt;myself&lt;/code&gt;, which is the entry of the node we are asking to generate &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output. The other replicas epochs reflect what they publish in heartbeat packets, which is, the configuration epoch of the masters they are currently replicating.</source>
          <target state="translated">レプリカはマスターの構成エポックをブロードキャストし（古くなっていることが判明した場合に &lt;code&gt;UPDATE&lt;/code&gt; メッセージを取得するため）、レプリカの実際の構成エポック（ハッシュスロットを提供しないため、多かれ少なかれ意味がない）にすることができます。&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;出力を生成するように要求しているノードのエントリである &lt;code&gt;myself&lt;/code&gt; のフラグが付けられたノードのチェックのみを取得しました。他のレプリカエポックは、ハートビートパケットで公開するもの、つまり現在複製しているマスターの構成エポックを反映しています。</target>
        </trans-unit>
        <trans-unit id="57ee014fca43ed90896705e17d43f35b06757596" translate="yes" xml:space="preserve">
          <source>Replicating commands instead of scripts</source>
          <target state="translated">スクリプトの代わりにコマンドを複製する</target>
        </trans-unit>
        <trans-unit id="054fb8240ac6c1ab20550a9e5b79d9d4cd6d1345" translate="yes" xml:space="preserve">
          <source>Request for authentication in a password-protected Redis server. Redis can be instructed to require a password before allowing clients to execute commands. This is done using the &lt;code&gt;requirepass&lt;/code&gt; directive in the configuration file.</source>
          <target state="translated">パスワードで保護されたRedisサーバーでの認証の要求。Redisは、クライアントにコマンドの実行を許可する前にパスワードを要求するように指示できます。これは、構成ファイルの &lt;code&gt;requirepass&lt;/code&gt; ディレクティブを使用して行われます。</target>
        </trans-unit>
        <trans-unit id="da1bb4a2fc17746f7a5baea5144086fae0563a1a" translate="yes" xml:space="preserve">
          <source>Reset a Redis Cluster node, in a more or less drastic way depending on the reset type, that can be &lt;strong&gt;hard&lt;/strong&gt; or &lt;strong&gt;soft&lt;/strong&gt;. Note that this command &lt;strong&gt;does not work for masters if they hold one or more keys&lt;/strong&gt;, in that case to completely reset a master node keys must be removed first, e.g. by using &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; first, and then &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;.</source>
          <target state="translated">Redisクラスターノードをリセットします。リセットタイプに応じて、&lt;strong&gt;ハード&lt;/strong&gt;または&lt;strong&gt;ソフトの&lt;/strong&gt;いずれかで、大幅に異なります。&lt;strong&gt;マスターが1つ以上のキーを保持&lt;/strong&gt;している場合、このコマンド&lt;strong&gt;はマスターに対しては機能しない&lt;/strong&gt;ことに注意してください。その場合、マスターノードのキーを完全にリセットするには、最初に&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;を使用し、次に&lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;などを使用して削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="5b45f167ccc9268d6db2b2030f5f33cd642304b9" translate="yes" xml:space="preserve">
          <source>Resets the statistics reported by Redis using the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;コマンドを使用してRedisによって報告された統計をリセットします。</target>
        </trans-unit>
        <trans-unit id="8b4926f937540a054f457674fa7da321fbd6a1f7" translate="yes" xml:space="preserve">
          <source>Resetting the slow log.</source>
          <target state="translated">遅いログをリセットします。</target>
        </trans-unit>
        <trans-unit id="401feffc58d082a7dc99bf3cdbc90af756748e94" translate="yes" xml:space="preserve">
          <source>Reshard all the hash slots from D to nodes A, B, C.</source>
          <target state="translated">DからノードA,B,Cへのすべてのハッシュスロットを再構築します。</target>
        </trans-unit>
        <trans-unit id="d71f5749e9e28d5922b96f1c26e811052165fc71" translate="yes" xml:space="preserve">
          <source>Retrieving external keys</source>
          <target state="translated">外部キーの取得</target>
        </trans-unit>
        <trans-unit id="6fc93fde5d23bf392c79a9f984537ca96d065420" translate="yes" xml:space="preserve">
          <source>Return a random key from the currently selected database.</source>
          <target state="translated">現在選択されているデータベースからランダムキーを返します。</target>
        </trans-unit>
        <trans-unit id="6fd47a35bf916d5d67439ea375fe4e2fb769d84c" translate="yes" xml:space="preserve">
          <source>Return the UNIX TIME of the last DB save executed with success. A client may check if a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command succeeded reading the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; value, then issuing a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command and checking at regular intervals every N seconds if &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; changed.</source>
          <target state="translated">正常に実行された最後のDB保存のUNIX TIMEを返します。場合、クライアントは確認することが&lt;a href=&quot;bgsave&quot;&gt;BGSAVEの&lt;/a&gt;コマンドが読んで成功した&lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt;、その後、値を発行&lt;a href=&quot;bgsave&quot;&gt;BGSAVEの&lt;/a&gt;コマンドをしている場合、一定の間隔N秒ごとにチェック&lt;a href=&quot;lastsave&quot;&gt;LASTSAVEを&lt;/a&gt;変更しました。</target>
        </trans-unit>
        <trans-unit id="7298f92c54146228ead6d1a31b40025056a03b02" translate="yes" xml:space="preserve">
          <source>Return the distance between two members in the geospatial index represented by the sorted set.</source>
          <target state="translated">ソートされた集合で表される地理空間インデックス内の2つのメンバー間の距離を返します。</target>
        </trans-unit>
        <trans-unit id="1bb126873153beb4e986e8428f3f0a902f06d1bc" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified with the center location and the maximum distance from the center (the radius).</source>
          <target state="translated">中心位置と中心からの最大距離（半径）で指定された領域の境界内にある、&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;を使用して地理空間情報が入力されたソート済みセットのメンバーを返します。</target>
        </trans-unit>
        <trans-unit id="a7ff116fa994743f4fb0646cce53a6396e097c89" translate="yes" xml:space="preserve">
          <source>Return the number of keys in the currently-selected database.</source>
          <target state="translated">現在選択されているデータベースのキーの数を返します。</target>
        </trans-unit>
        <trans-unit id="06398ca22b9ef82a3c94cf8b1160f8f9c766b74a" translate="yes" xml:space="preserve">
          <source>Return the position of the first bit set to 1 or 0 in a string.</source>
          <target state="translated">文字列の最初のビットが 1 または 0 に設定されている位置を返します。</target>
        </trans-unit>
        <trans-unit id="1d1482b5db471b056549fa1a5580198ec9701587" translate="yes" xml:space="preserve">
          <source>Return the positions (longitude,latitude) of all the specified members of the geospatial index represented by the sorted set at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;keyで&lt;/em&gt;ソートされたセットによって表される地理空間インデックスの指定されたすべてのメンバーの位置（経度、緯度）を返し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0492bdeb7afe890056ed3d150bcd3cc644b0be83" translate="yes" xml:space="preserve">
          <source>Return valid &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; strings representing the position of one or more elements in a sorted set value representing a geospatial index (where elements were added using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;).</source>
          <target state="translated">（要素が&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;を使用して追加された）空間インデックスを表すソートされたセット値内の1つ以上の要素の位置を表す有効な&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;文字列を返します。</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">戻り値</target>
        </trans-unit>
        <trans-unit id="864674bcd0783b3457690f475310b938e42a7db7" translate="yes" xml:space="preserve">
          <source>Returning a maximum number of entries</source>
          <target state="translated">最大エントリ数を返す</target>
        </trans-unit>
        <trans-unit id="8f278b9f0e4f851622b8ed184503714c9eb2b40b" translate="yes" xml:space="preserve">
          <source>Returning items in a specific time range. This is possible because Stream IDs are &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;related to time&lt;/a&gt;.</source>
          <target state="translated">特定の時間範囲のアイテムを返す。これは、ストリームIDが&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;時間に関連して&lt;/a&gt;いるために可能です。</target>
        </trans-unit>
        <trans-unit id="6fecab38b77030a1f63f2810d6747aa68c069f23" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about all Redis commands.</source>
          <target state="translated">すべてのRedisコマンドに関する詳細の&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列応答&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="fc344310aece8efa4afcb637dd3fdf8dc24fa45b" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about multiple Redis commands.</source>
          <target state="translated">複数のRedisコマンドに関する詳細の&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列応答&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="4a134a2f3cf379373d004a605091cb6cf69dedcb" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of keys from a full Redis command.</source>
          <target state="translated">完全なRedisコマンドからのキーの&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列応答&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="bce4982fceed9f9a0c759decc9c92ecb37cc9be2" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; of number of total commands in this Redis server.</source>
          <target state="translated">このRedisサーバー内の合計コマンド数の&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;整数応答&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="a915d042e7bc17cfcfeeccbd870dfc5af9c1ca16" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;PONG&lt;/code&gt; if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to test if a connection is still alive, or to measure latency.</source>
          <target state="translated">引数が指定されていない場合は &lt;code&gt;PONG&lt;/code&gt; を返し、それ以外の場合は引数のコピーを一括して返します。このコマンドは、接続がまだ生きているかどうかをテストしたり、待ち時間を測定したりするためによく使用されます。</target>
        </trans-unit>
        <trans-unit id="dd1b58db010b114867573670782f464e9b034412" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="a8491e8a1858fe4a13538635b038fd1bb846df79" translate="yes" xml:space="preserve">
          <source>Returns all field names in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に保存されているハッシュのすべてのフィールド名を返します。</target>
        </trans-unit>
        <trans-unit id="514836e0465ae87a7f738140eb4e2b3ae4475e1f" translate="yes" xml:space="preserve">
          <source>Returns all fields and values of the hash stored at &lt;code&gt;key&lt;/code&gt;. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に保存されているハッシュのすべてのフィールドと値を返します。戻り値では、すべてのフィールド名の後にその値が続くため、応答の長さはハッシュのサイズの2倍になります。</target>
        </trans-unit>
        <trans-unit id="e9924b464875fe91e2b89cf6f97649ff9ec1b5ce" translate="yes" xml:space="preserve">
          <source>Returns all keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; に一致するすべてのキーを返します。</target>
        </trans-unit>
        <trans-unit id="1ceba3296cc87483f6becfe1cdae897e811a1b1e" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; (including elements with score equal to &lt;code&gt;max&lt;/code&gt; or &lt;code&gt;min&lt;/code&gt;). In contrary to the default ordering of sorted sets, for this command the elements are considered to be ordered from high to low scores.</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; から &lt;code&gt;min&lt;/code&gt; までのスコア（ &lt;code&gt;key&lt;/code&gt; が &lt;code&gt;max&lt;/code&gt; または &lt;code&gt;min&lt;/code&gt; に等しい要素を含む）を持つキーでソートされたセットのすべての要素を返します。ソートされたセットのデフォルトの順序とは異なり、このコマンドでは、要素は高スコアから低スコアの順に並べられていると見なされます。</target>
        </trans-unit>
        <trans-unit id="6def9bec387c3e744963c6ac4b0bf7f4010504e6" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (including elements with score equal to &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt;). The elements are considered to be ordered from low to high scores.</source>
          <target state="translated">スコアが &lt;code&gt;min&lt;/code&gt; から &lt;code&gt;max&lt;/code&gt; までの &lt;code&gt;key&lt;/code&gt; でソートされたセットのすべての要素を返します（スコアが &lt;code&gt;min&lt;/code&gt; または &lt;code&gt;max&lt;/code&gt; に等しい要素を含みます）。要素は低いスコアから高いスコアの順に並べられていると見なされます。</target>
        </trans-unit>
        <trans-unit id="1925ffaf420a57d589c1888eb5b09007e4f1d203" translate="yes" xml:space="preserve">
          <source>Returns all the members of the set value stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている設定値のすべてのメンバーを返します。</target>
        </trans-unit>
        <trans-unit id="c11f5fe0471c6d472d362d6dbbf041c048b49125" translate="yes" xml:space="preserve">
          <source>Returns all values in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に保存されているハッシュのすべての値を返します。</target>
        </trans-unit>
        <trans-unit id="4792ce321c7a364f3dc2071cf137fcc522daf25d" translate="yes" xml:space="preserve">
          <source>Returns an integer identifying the hash slot the specified key hashes to. This command is mainly useful for debugging and testing, since it exposes via an API the underlying Redis implementation of the hashing algorithm. Example use cases for this command:</source>
          <target state="translated">指定したキーのハッシュ先のハッシュスロットを特定する整数値を返します。このコマンドは主にデバッグやテストに便利です。このコマンドの使用例。</target>
        </trans-unit>
        <trans-unit id="899ca03feedce83f7aa728b87a784b60bd95adf0" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;field&lt;/code&gt; is an existing field in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返した場合 &lt;code&gt;field&lt;/code&gt; で保存されたハッシュで既存のフィールドである &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e13b7a867bbaf0e4121d5da403d54edbe4a8b1f" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;key&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; が存在するかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="163373a24e8be296b7e7c88d0c4da2f59ceca677" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;member&lt;/code&gt; が &lt;code&gt;key&lt;/code&gt; に格納されているセットのメンバーであるかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="abd92cbd9d7d0b6e4392a36873fd8c21767b398a" translate="yes" xml:space="preserve">
          <source>Returns information about the existence of the scripts in the script cache.</source>
          <target state="translated">スクリプトキャッシュ内のスクリプトが存在するかどうかの情報を返します。</target>
        </trans-unit>
        <trans-unit id="13855077d7cb93a1fce1c3432c59e7e463ea29a6" translate="yes" xml:space="preserve">
          <source>Returns or stores the elements contained in the &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;list&lt;/a&gt;, &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;set&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted set&lt;/a&gt; at &lt;code&gt;key&lt;/code&gt;. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. This is &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; in its simplest form:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; の&lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;リスト&lt;/a&gt;、&lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;セット、&lt;/a&gt;または&lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;ソート済みセットに&lt;/a&gt;含まれる要素を返すか、格納します。デフォルトでは、ソートは数値であり、要素は倍精度浮動小数点数として解釈される値によって比較されます。これは、最も単純な形式の&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f68574957008d127438140f50ac56b278260cf09" translate="yes" xml:space="preserve">
          <source>Returns the bit value at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;keyに&lt;/em&gt;格納されている文字列値の&lt;em&gt;オフセット&lt;/em&gt;のビット値を返します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6d63c7c2388918da907438c78c891dff4a16999" translate="yes" xml:space="preserve">
          <source>Returns the element at index &lt;code&gt;index&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt;. The index is zero-based, so &lt;code&gt;0&lt;/code&gt; means the first element, &lt;code&gt;1&lt;/code&gt; the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, &lt;code&gt;-1&lt;/code&gt; means the last element, &lt;code&gt;-2&lt;/code&gt; means the penultimate and so forth.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストのインデックス &lt;code&gt;index&lt;/code&gt; の要素を返します。インデックスはゼロベースなので、 &lt;code&gt;0&lt;/code&gt; は最初の要素、 &lt;code&gt;1&lt;/code&gt; は2番目の要素、というように続きます。負のインデックスを使用して、リストの末尾から始まる要素を指定できます。ここで、 &lt;code&gt;-1&lt;/code&gt; は最後の要素を意味し、 &lt;code&gt;-2&lt;/code&gt; は最後から2番目の要素を意味します。</target>
        </trans-unit>
        <trans-unit id="669652a24b746680e968eb8d19e304712aaafbef" translate="yes" xml:space="preserve">
          <source>Returns the length of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is interpreted as an empty list and &lt;code&gt;0&lt;/code&gt; is returned. An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a list.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの長さを返します。場合は &lt;code&gt;key&lt;/code&gt; 存在しない、それは空のリストとして解釈され、 &lt;code&gt;0&lt;/code&gt; が返されます。 &lt;code&gt;key&lt;/code&gt; に格納されている値がリストでない場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="b1b9de7b079dd5e1ad7bef3504c123ad01db9ecc" translate="yes" xml:space="preserve">
          <source>Returns the length of the string value stored at &lt;code&gt;key&lt;/code&gt;. An error is returned when &lt;code&gt;key&lt;/code&gt; holds a non-string value.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている文字列値の長さを返します。 &lt;code&gt;key&lt;/code&gt; が文字列以外の値を保持している場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="5ca8167d0a845062b5e1c8307dc022d4e1bbe99c" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the difference between the first set and all the successive sets.</source>
          <target state="translated">最初の集合と連続するすべての集合との差から得られる集合のメンバを返します。</target>
        </trans-unit>
        <trans-unit id="65286cf35136f5258861b04a7983164ea5b463a3" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the intersection of all the given sets.</source>
          <target state="translated">与えられたすべての集合の交点から得られる集合のメンバを返します。</target>
        </trans-unit>
        <trans-unit id="473b41ab8be68badcb9ee743f59ebda61ccb6efd" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the union of all the given sets.</source>
          <target state="translated">与えられたすべての集合の和から得られる集合のメンバを返します。</target>
        </trans-unit>
        <trans-unit id="ae58574da7b69acb45d5608e905fbe416f5828a3" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">スコアが &lt;code&gt;min&lt;/code&gt; から &lt;code&gt;max&lt;/code&gt; の &lt;code&gt;key&lt;/code&gt; でソートされたセットの要素数を返します。</target>
        </trans-unit>
        <trans-unit id="4ba5a6e2cdf681a72b81189fc73dab62a38a2630" translate="yes" xml:space="preserve">
          <source>Returns the number of entries inside a stream. If the specified key does not exist the command returns zero, as if the stream was empty. However note that unlike other Redis types, zero-length streams are possible, so you should call &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; or &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; in order to check if a key exists or not.</source>
          <target state="translated">ストリーム内のエントリ数を返します。指定されたキーが存在しない場合、ストリームが空であるかのように、コマンドはゼロを返します。ただし、他のRedisタイプとは異なり、長さがゼロのストリームが可能であるため、キーが存在するかどうかを確認するには、&lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt;または&lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt;を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="05ec2c01f1e7966c86d566259fe9827a1ce5788e" translate="yes" xml:space="preserve">
          <source>Returns the number of fields contained in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュに含まれるフィールドの数を返します。</target>
        </trans-unit>
        <trans-unit id="cba9b6e741951a2ea3575443214cf403c194bc0f" translate="yes" xml:space="preserve">
          <source>Returns the number of keys in the specified Redis Cluster hash slot. The command only queries the local data set, so contacting a node that is not serving the specified hash slot will always result in a count of zero being returned.</source>
          <target state="translated">指定されたRedis Clusterハッシュスロット内のキーの数を返します。このコマンドはローカルデータセットのみを問い合わせますので、指定されたハッシュスロットを提供していないノードに問い合わせると、常にゼロのカウントが返されます。</target>
        </trans-unit>
        <trans-unit id="567352a29cfaef33a8cd3fcbcac829c78575fb62" translate="yes" xml:space="preserve">
          <source>Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.</source>
          <target state="translated">指定したチャンネルの加入者数(パターンに加入しているクライアントはカウントしない)を返します。</target>
        </trans-unit>
        <trans-unit id="56eb7af42eb7b4bb5b7efb363837228225fedb8e" translate="yes" xml:space="preserve">
          <source>Returns the number of subscriptions to patterns (that are performed using the &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; command). Note that this is not just the count of clients subscribed to patterns but the total number of patterns all the clients are subscribed to.</source>
          <target state="translated">（&lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;コマンドを使用して実行される）パターンへのサブスクリプションの数を返します。これは、パターンにサブスクライブしているクライアントの数だけでなく、すべてのクライアントがサブスクライブしているパターンの総数であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="029e626a83e98d1ddd2b45f2a08391faf674382c" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from high to low. The rank (or index) is 0-based, which means that the member with the highest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソート済みセットの &lt;code&gt;member&lt;/code&gt; のランクを返します。スコアは高いものから低いものへと並べられています。ランク（またはインデックス）は0ベースです。つまり、最高のスコアを持つメンバーのランクは &lt;code&gt;0&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="04ac6b8e04ac2d5fa91a42abbe270ab24969dcf8" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソート済みセット内の &lt;code&gt;member&lt;/code&gt; のランクを返します。スコアは低いものから高いものへと並べられています。ランク（またはインデックス）は0ベースです。つまり、スコアが最も低いメンバーのランクは &lt;code&gt;0&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="dac65708cc841972517b49f4a323aba557dd7743" translate="yes" xml:space="preserve">
          <source>Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.</source>
          <target state="translated">タイムアウトしたキーの残り時間を返します。このイントロスペクション機能により、Redisクライアントは与えられたキーが何秒でデータセットの一部であり続けるかをチェックすることができます。</target>
        </trans-unit>
        <trans-unit id="bdaf416765952fb3c543f080075ad7115471f130" translate="yes" xml:space="preserve">
          <source>Returns the score of &lt;code&gt;member&lt;/code&gt; in the sorted set at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; のソートされたセットの &lt;code&gt;member&lt;/code&gt; のスコアを返します。</target>
        </trans-unit>
        <trans-unit id="0525192497ba351f01f7c69505a721186043f122" translate="yes" xml:space="preserve">
          <source>Returns the set cardinality (number of elements) of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているセットのカーディナリティ（要素数）を返します。</target>
        </trans-unit>
        <trans-unit id="538e8ccb043255bf1866a8c948a35b08642708eb" translate="yes" xml:space="preserve">
          <source>Returns the sorted set cardinality (number of elements) of the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に保存されているソート済みセットのソート済みセットのカーディナリティ（要素数）を返します。</target>
        </trans-unit>
        <trans-unit id="aed5ad61cf2dae51ecb526ffeb96e8ae6f66dd61" translate="yes" xml:space="preserve">
          <source>Returns the specified elements of the list stored at &lt;code&gt;key&lt;/code&gt;. The offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, with &lt;code&gt;0&lt;/code&gt; being the first element of the list (the head of the list), &lt;code&gt;1&lt;/code&gt; being the next element and so on.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの指定された要素を返します。オフセットの &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; は0 から始まるインデックスで、 &lt;code&gt;0&lt;/code&gt; はリストの最初の要素（リストの先頭）、 &lt;code&gt;1&lt;/code&gt; は次の要素というようになります。</target>
        </trans-unit>
        <trans-unit id="165e254b16f95c82b554bb625de96b2c2d45635e" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the highest to the lowest score. Descending lexicographical order is used for elements with equal score.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソート済みセットの指定された範囲の要素を返します。要素は、最高から最低のスコアの順に並べられていると見なされます。降順の辞書式順序は、スコアが等しい要素に使用されます。</target>
        </trans-unit>
        <trans-unit id="c5f3848ec567b8c9da3f19a86ff736fd69145ae8" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているソート済みセットの指定された範囲の要素を返します。要素は最低スコアから最高スコアの順に並べられていると見なされます。辞書式順序は、スコアが等しい要素に使用されます。</target>
        </trans-unit>
        <trans-unit id="d28b315a7a61b9bf04b21fccdd6ae5bd4f8eb130" translate="yes" xml:space="preserve">
          <source>Returns the string length of the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;. If the &lt;code&gt;key&lt;/code&gt; or the &lt;code&gt;field&lt;/code&gt; do not exist, 0 is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュの &lt;code&gt;field&lt;/code&gt; に関連付けられた値の文字列長を返します。場合は &lt;code&gt;key&lt;/code&gt; または &lt;code&gt;field&lt;/code&gt; 存在しない、0が返されます。</target>
        </trans-unit>
        <trans-unit id="ffb4e3b3a6a5708cfdef83bd04363741160ed0a4" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt; and &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている値のタイプの文字列表現を返します。返される可能性のある異なるタイプは、 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;list&lt;/code&gt; 、 &lt;code&gt;set&lt;/code&gt; 、 &lt;code&gt;zset&lt;/code&gt; 、および &lt;code&gt;hash&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8a246620818088ec9a16f70b9fb4ae809aad9ad2" translate="yes" xml:space="preserve">
          <source>Returns the substring of the string value stored at &lt;code&gt;key&lt;/code&gt;, determined by the offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている文字列値の部分文字列を返します。これは、オフセットの &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;end&lt;/code&gt; によって決定されます（両方を含みます）。負のオフセットは、文字列の最後から始まるオフセットを提供するために使用できます。したがって、-1は最後の文字、-2は最後から2番目の文字などを意味します。</target>
        </trans-unit>
        <trans-unit id="ff8cb8f9712a465de8610b460278556869c01387" translate="yes" xml:space="preserve">
          <source>Returns the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュの &lt;code&gt;field&lt;/code&gt; に関連付けられた値を返します。</target>
        </trans-unit>
        <trans-unit id="6e8fea73a6efe9b1e714890adedb119e477e5b94" translate="yes" xml:space="preserve">
          <source>Returns the values associated with the specified &lt;code&gt;fields&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュの指定された &lt;code&gt;fields&lt;/code&gt; に関連付けられた値を返します。</target>
        </trans-unit>
        <trans-unit id="2a3f6c24ab0b5bf50119e41442adccdd069520b2" translate="yes" xml:space="preserve">
          <source>Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value &lt;code&gt;nil&lt;/code&gt; is returned. Because of this, the operation never fails.</source>
          <target state="translated">指定されたすべてのキーの値を返します。文字列値を保持しないか存在しないすべてのキーについて、特別な値 &lt;code&gt;nil&lt;/code&gt; が返されます。このため、操作が失敗することはありません。</target>
        </trans-unit>
        <trans-unit id="33fe03995fd835515d8b0c378391e0d80d6d96a2" translate="yes" xml:space="preserve">
          <source>Running the bitmap incrementally using the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;&lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; optional parameters, accumulating the results client-side, and optionally caching the result into a key.</source>
          <target state="translated">&lt;a href=&quot;bitcount&quot;&gt;BITCOUNTの&lt;/a&gt;&lt;em&gt;開始&lt;/em&gt;と&lt;em&gt;終了の&lt;/em&gt;オプションパラメータを使用してビットマップを段階的に実行し、結果をクライアント側に蓄積し、オプションで結果をキーにキャッシュします。</target>
        </trans-unit>
        <trans-unit id="afc896d0c818d9d81d1502addeeed94d978515cb" translate="yes" xml:space="preserve">
          <source>SADD</source>
          <target state="translated">SADD</target>
        </trans-unit>
        <trans-unit id="afe4d83e232611365cc3a02706eeee448267b671" translate="yes" xml:space="preserve">
          <source>SADD  key member [member ...]   Add one or more members to a set</source>
          <target state="translated">SADD key member [member ....]1つまたは複数のメンバーをセットに追加します。</target>
        </trans-unit>
        <trans-unit id="508156a39b09ccfe61cc81d984e9317e5e0d8eec" translate="yes" xml:space="preserve">
          <source>SAVE</source>
          <target state="translated">SAVE</target>
        </trans-unit>
        <trans-unit id="a806788f2be230df4e533ace9d23ff41f5ebd919" translate="yes" xml:space="preserve">
          <source>SAVE   Synchronously save the dataset to disk</source>
          <target state="translated">SAVE 同期的にデータセットをディスクに保存する</target>
        </trans-unit>
        <trans-unit id="65b4fd3a026ef6fa00d5747035f289ef54695f24" translate="yes" xml:space="preserve">
          <source>SAVE and NOSAVE modifiers</source>
          <target state="translated">SAVEとNOSAVEの修飾子</target>
        </trans-unit>
        <trans-unit id="c5a19955ea5dab3fd18ab68f367f98693df1b60b" translate="yes" xml:space="preserve">
          <source>SCAN</source>
          <target state="translated">SCAN</target>
        </trans-unit>
        <trans-unit id="f6a353aff0f0da25a0e7f7c1d96621ee0a75fe99" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count]   Incrementally iterate the keys space</source>
          <target state="translated">SCAN カーソル [MATCH パターン][COUNT カウント]キー空間をインクリメンタルに反復します。</target>
        </trans-unit>
        <trans-unit id="f904e681db7d6de1d40ec70145524cd0367d1bf0" translate="yes" xml:space="preserve">
          <source>SCAN basic usage</source>
          <target state="translated">SCAN基本使用法</target>
        </trans-unit>
        <trans-unit id="aa3b23325236e95772d7cd2d8a5db2f2530e669f" translate="yes" xml:space="preserve">
          <source>SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call.</source>
          <target state="translated">SCAN はカーソルベースのイテレータです。これは、コマンドを呼び出すたびに、サーバが更新されたカーソルを返し、ユーザが次の呼び出しでカーソルの引数として使用する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="0431790b7b638b530f089a6638b4b046bf245d05" translate="yes" xml:space="preserve">
          <source>SCARD</source>
          <target state="translated">SCARD</target>
        </trans-unit>
        <trans-unit id="45b0af77625a8e40fbd9c79a72bf85a01a682a2e" translate="yes" xml:space="preserve">
          <source>SCARD  key   Get the number of members in a set</source>
          <target state="translated">SCARD キー セット内のメンバー数を取得します。</target>
        </trans-unit>
        <trans-unit id="46ab5a918078b88865c34d46d45763f78a5cc2a8" translate="yes" xml:space="preserve">
          <source>SCRIPT</source>
          <target state="translated">SCRIPT</target>
        </trans-unit>
        <trans-unit id="942ec0d4567f537a05d81b40e79ed670c8098df1" translate="yes" xml:space="preserve">
          <source>SCRIPT DEBUG  YES|SYNC|NO   Set the debug mode for executed scripts.</source>
          <target state="translated">SCRIPT DEBUG YES|SYNC|NO 実行されるスクリプトのデバッグモードを設定します。</target>
        </trans-unit>
        <trans-unit id="d4f0300810cbd56a02078e94b26444e04a369df1" translate="yes" xml:space="preserve">
          <source>SCRIPT EXISTS  sha1 [sha1 ...]   Check existence of scripts in the script cache.</source>
          <target state="translated">SCRIPT EXISTS sha1 [sha1 ...]スクリプトキャッシュ内のスクリプトの存在を確認します。</target>
        </trans-unit>
        <trans-unit id="155351693709972a944322985f623357a60203d8" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH</source>
          <target state="translated">スクリプトフラッシュ</target>
        </trans-unit>
        <trans-unit id="ff5ac14542c8a5c4ff717c937c92483157332c48" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH   Remove all the scripts from the script cache.</source>
          <target state="translated">スクリプトのフラッシュ スクリプトキャッシュからすべてのスクリプトを削除します。</target>
        </trans-unit>
        <trans-unit id="5e2a68acdd358effce354e479fe828441291386c" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL</source>
          <target state="translated">スクリプトキル</target>
        </trans-unit>
        <trans-unit id="898216faf82d0e8094a40fff1a1d11316572b3a1" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL   Kill the script currently in execution.</source>
          <target state="translated">SCRIPT KILL 現在実行中のスクリプトをキルします。</target>
        </trans-unit>
        <trans-unit id="bf00a0ed4afe21cec9ac5006aa471a2c75ce80dd" translate="yes" xml:space="preserve">
          <source>SCRIPT LOAD  script   Load the specified Lua script into the script cache.</source>
          <target state="translated">SCRIPT LOAD script 指定した Lua スクリプトをスクリプトキャッシュにロードします。</target>
        </trans-unit>
        <trans-unit id="605e7c9dd422426230eae60c02acc7d7a5705884" translate="yes" xml:space="preserve">
          <source>SDIFF</source>
          <target state="translated">SDIFF</target>
        </trans-unit>
        <trans-unit id="18d8e0e316b86cf9a259f83877f9d4536e919048" translate="yes" xml:space="preserve">
          <source>SDIFF  key [key ...]   Subtract multiple sets</source>
          <target state="translated">SDIFF キー [key ....]複数セットを減算します。</target>
        </trans-unit>
        <trans-unit id="144b2bd3509fd63bb1b369b8c7665713eb587bd9" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE</source>
          <target state="translated">SDIFFSTORE</target>
        </trans-unit>
        <trans-unit id="de1820fefd3db78a9062bc31ca0bace599879b7b" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE  destination key [key ...]   Subtract multiple sets and store the resulting set in a key</source>
          <target state="translated">SDIFFSTORE 宛先キー [key ...]複数のセットを減算し、その結果をキーに格納します。</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="f439068c5eb4482362ce42c7382665b32a13512a" translate="yes" xml:space="preserve">
          <source>SELECT  index   Change the selected database for the current connection</source>
          <target state="translated">SELECT index 現在の接続で選択したデータベースを変更します。</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="91a720b839d692fc7a7e17565ac1e4963650fe98" translate="yes" xml:space="preserve">
          <source>SET  key value [expiration EX seconds|PX milliseconds] [NX|XX]   Set the string value of a key</source>
          <target state="translated">SET key value [expiration EX seconds|PX milliseconds][NX|XX]キーの文字列値を設定します。</target>
        </trans-unit>
        <trans-unit id="7df70cb863a3d3a5e4a199b5d8ef3c9851ce87bf" translate="yes" xml:space="preserve">
          <source>SETBIT</source>
          <target state="translated">SETBIT</target>
        </trans-unit>
        <trans-unit id="b66f69a03f672489d4ae1d69a757435c5b63bd51" translate="yes" xml:space="preserve">
          <source>SETBIT  key offset value   Sets or clears the bit at offset in the string value stored at key</source>
          <target state="translated">SETBIT キーオフセット値 キーに格納されている文字列値のオフセット時のビットを設定またはクリアします。</target>
        </trans-unit>
        <trans-unit id="c92872db8021ac60dd456ca7447fb52919f32143" translate="yes" xml:space="preserve">
          <source>SETEX</source>
          <target state="translated">SETEX</target>
        </trans-unit>
        <trans-unit id="0b5df1d3ddffe0fdbb568accc5d3c3dac5121afc" translate="yes" xml:space="preserve">
          <source>SETEX  key seconds value   Set the value and expiration of a key</source>
          <target state="translated">SETEX key seconds value キーの値と有効期限を設定します。</target>
        </trans-unit>
        <trans-unit id="1ace6531f1c27b916c1368f17e1a7ae87aa79f97" translate="yes" xml:space="preserve">
          <source>SETNX</source>
          <target state="translated">SETNX</target>
        </trans-unit>
        <trans-unit id="a50f293fa49f962b5d82c0bb86c82df413a498b7" translate="yes" xml:space="preserve">
          <source>SETNX  key value   Set the value of a key, only if the key does not exist</source>
          <target state="translated">SETNX key value キーが存在しない場合のみ、キーの値を設定する。</target>
        </trans-unit>
        <trans-unit id="c1d82383232438676e2182b69bf2797640b1fcd2" translate="yes" xml:space="preserve">
          <source>SETRANGE</source>
          <target state="translated">SETRANGE</target>
        </trans-unit>
        <trans-unit id="a2132f99e69e7919051651c2b4fc7de24734eba2" translate="yes" xml:space="preserve">
          <source>SETRANGE  key offset value   Overwrite part of a string at key starting at the specified offset</source>
          <target state="translated">SETRANGE キーオフセット値 指定されたオフセットから始まるキーの文字列の一部を上書きします。</target>
        </trans-unit>
        <trans-unit id="ec493147ec1b78adab002626ee80cc23772aded8" translate="yes" xml:space="preserve">
          <source>SHUTDOWN</source>
          <target state="translated">SHUTDOWN</target>
        </trans-unit>
        <trans-unit id="606e1ec5d1ea13b283de4e59cd16289518254c6c" translate="yes" xml:space="preserve">
          <source>SHUTDOWN  [NOSAVE|SAVE]   Synchronously save the dataset to disk and then shut down the server</source>
          <target state="translated">SHUTDOWN [NOSAVE|SAVE]同期的にデータセットをディスクに保存した後、サーバをシャットダウンします。</target>
        </trans-unit>
        <trans-unit id="c340be94a16bd060ccd24ece053ed10ff4cfb1a2" translate="yes" xml:space="preserve">
          <source>SINTER</source>
          <target state="translated">SINTER</target>
        </trans-unit>
        <trans-unit id="acc6f9a5a6867145ccd5835b170277c3127f8f60" translate="yes" xml:space="preserve">
          <source>SINTER  key [key ...]   Intersect multiple sets</source>
          <target state="translated">SINTER キー [キー ...]複数セットを交差させます。</target>
        </trans-unit>
        <trans-unit id="ae286ac2efddc7ffc6de81fb4eef82083c5d0d0a" translate="yes" xml:space="preserve">
          <source>SINTERSTORE</source>
          <target state="translated">SINTERSTORE</target>
        </trans-unit>
        <trans-unit id="3cc889bdb24445318099b6bfa98a849204bc5321" translate="yes" xml:space="preserve">
          <source>SINTERSTORE  destination key [key ...]   Intersect multiple sets and store the resulting set in a key</source>
          <target state="translated">SINTERSTORE デスティネーションキー [key ...]複数のセットを交差させ、結果として得られたセットをキーに格納します。</target>
        </trans-unit>
        <trans-unit id="8074903f43c428dec41033b139437bb9d7e46e61" translate="yes" xml:space="preserve">
          <source>SISMEMBER</source>
          <target state="translated">SISMEMBER</target>
        </trans-unit>
        <trans-unit id="2613d73d648b1f6845f55faac8664acb5e2e9af6" translate="yes" xml:space="preserve">
          <source>SISMEMBER  key member   Determine if a given value is a member of a set</source>
          <target state="translated">SISMEMBER キーメンバー 与えられた値が集合のメンバーであるかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="bb3731aa645af4f77072e934700ff033a81e173b" translate="yes" xml:space="preserve">
          <source>SLAVEOF</source>
          <target state="translated">SLAVEOF</target>
        </trans-unit>
        <trans-unit id="9bb4401fd3b09a14ad63da1fc4e0ebcc9c0ee189" translate="yes" xml:space="preserve">
          <source>SLAVEOF  host port   Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.</source>
          <target state="translated">SLAVEOF ホストポート サーバを別のインスタンスのレプリカにするか、マスタとして昇格させます。Redis 5 以降では非推奨。 代わりに REPLICAOF を使用してください。</target>
        </trans-unit>
        <trans-unit id="4078b703021998b0c963d9636d85d96b1ddfa618" translate="yes" xml:space="preserve">
          <source>SLOWLOG</source>
          <target state="translated">SLOWLOG</target>
        </trans-unit>
        <trans-unit id="acfcd934ccfd2203f5ccc3e824371c24109642b8" translate="yes" xml:space="preserve">
          <source>SLOWLOG  subcommand [argument]   Manages the Redis slow queries log</source>
          <target state="translated">SLOWLOGサブコマンド [引数]Redisの遅いクエリのログを管理します。</target>
        </trans-unit>
        <trans-unit id="e6687e28d8b75312f0ea51bc9520b394ec2a7a63" translate="yes" xml:space="preserve">
          <source>SMEMBERS</source>
          <target state="translated">SMEMBERS</target>
        </trans-unit>
        <trans-unit id="fe66421f332187f83010e275c4b51042858f5234" translate="yes" xml:space="preserve">
          <source>SMEMBERS  key   Get all the members in a set</source>
          <target state="translated">SMEMBERS キー セット内のすべてのメンバーを取得します。</target>
        </trans-unit>
        <trans-unit id="20f84dbd21a3d84899dade0a24ef5c6978f0403e" translate="yes" xml:space="preserve">
          <source>SMOVE</source>
          <target state="translated">SMOVE</target>
        </trans-unit>
        <trans-unit id="1f7888e464279456fc99ea1259b436e9ad0d4f64" translate="yes" xml:space="preserve">
          <source>SMOVE  source destination member   Move a member from one set to another</source>
          <target state="translated">SMOVE ソース・デスティネーション・メンバー あるセットから別のセットにメンバーを移動します。</target>
        </trans-unit>
        <trans-unit id="2434fe1de87e4949f51786cc87dd6a83c095a422" translate="yes" xml:space="preserve">
          <source>SORT</source>
          <target state="translated">SORT</target>
        </trans-unit>
        <trans-unit id="8e248ec645f54a08b3eb01462adb200f94f15d79" translate="yes" xml:space="preserve">
          <source>SORT  key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]   Sort the elements in a list, set or sorted set</source>
          <target state="translated">SORTキー [BYパターン][LIMITオフセットカウント][GETパターン [GETパターン ...]ASC|DESC][ALPHA][STORE destination][STORE destination]リスト、セット、ソートされたセットの要素をソートします。</target>
        </trans-unit>
        <trans-unit id="757f5e1ed1192585c3e7deb4986d7e204a0c8613" translate="yes" xml:space="preserve">
          <source>SPOP</source>
          <target state="translated">SPOP</target>
        </trans-unit>
        <trans-unit id="a1bcd919a884989656266471e065ce0ed9f3b014" translate="yes" xml:space="preserve">
          <source>SPOP  key [count]   Remove and return one or multiple random members from a set</source>
          <target state="translated">SPOP キー [count]セットから 1 つまたは複数のランダムなメンバーを削除して返します。</target>
        </trans-unit>
        <trans-unit id="fa889adf02f632d165c3f2d12d9b5ec8d781cbb2" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER</source>
          <target state="translated">SRANDMEMBER</target>
        </trans-unit>
        <trans-unit id="a3aa05de6787d8cb6b5fb2eeb41ce24756a254c7" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER  key [count]   Get one or multiple random members from a set</source>
          <target state="translated">SRANDMEMBER key [count]セットから1つまたは複数のランダムメンバーを取得します。</target>
        </trans-unit>
        <trans-unit id="a25d27e5f9def5c1d9e1a790c413156760a00937" translate="yes" xml:space="preserve">
          <source>SREM</source>
          <target state="translated">SREM</target>
        </trans-unit>
        <trans-unit id="68363946a4081440ca501f29c43f5fbe4f7eefc4" translate="yes" xml:space="preserve">
          <source>SREM  key member [member ...]   Remove one or more members from a set</source>
          <target state="translated">SREM キーメンバー [メンバー ...]セットから 1 つ以上のメンバーを削除する。</target>
        </trans-unit>
        <trans-unit id="39f084973b61a7bea28e4e94336a3c5a0bf9fee7" translate="yes" xml:space="preserve">
          <source>SSCAN</source>
          <target state="translated">SSCAN</target>
        </trans-unit>
        <trans-unit id="9c2bba696b7b86cd88c82a287899370d9f0e3bb5" translate="yes" xml:space="preserve">
          <source>SSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate Set elements</source>
          <target state="translated">SSCAN キーカーソル [MATCH パターン][COUNT カウント]インクリメンタル・イテレート セット要素</target>
        </trans-unit>
        <trans-unit id="c89c4cb21a1d403bb307b502f69a87f9e3b3a8ab" translate="yes" xml:space="preserve">
          <source>STRLEN</source>
          <target state="translated">STRLEN</target>
        </trans-unit>
        <trans-unit id="ba1403b52701f08d29eb084587b5d84ec8dde893" translate="yes" xml:space="preserve">
          <source>STRLEN  key   Get the length of the value stored in a key</source>
          <target state="translated">STRLEN key キーに格納されている値の長さを取得します。</target>
        </trans-unit>
        <trans-unit id="43a6e12318adbbee03f06872c109322b0f558e29" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE</source>
          <target state="translated">SUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="47236795c3b9acd1da0f66ecb88ffdd913189ac5" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE  channel [channel ...]   Listen for messages published to the given channels</source>
          <target state="translated">SUBSCRIBE channel [channel ...]指定されたチャンネルに公開されたメッセージを聞く</target>
        </trans-unit>
        <trans-unit id="a9a4bd3707fb7f204fddf46673a38114093dbb82" translate="yes" xml:space="preserve">
          <source>SUNION</source>
          <target state="translated">SUNION</target>
        </trans-unit>
        <trans-unit id="5b757c33f2f9e74b674645b6ccda3d80138ff877" translate="yes" xml:space="preserve">
          <source>SUNION  key [key ...]   Add multiple sets</source>
          <target state="translated">SUNION キー [キー ...]複数セット追加</target>
        </trans-unit>
        <trans-unit id="48b1035f133322c326cae720a6ee6ad1108226dc" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE</source>
          <target state="translated">SUNIONSTORE</target>
        </trans-unit>
        <trans-unit id="be4a84a92460ba7a99f970a1bd856700c5285869" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE  destination key [key ...]   Add multiple sets and store the resulting set in a key</source>
          <target state="translated">SUNIONSTORE 宛先キー [キー ...]複数のセットを追加し、その結果をキーに格納します。</target>
        </trans-unit>
        <trans-unit id="52e8b5aa51a1b6c9b46c6f4abe8b613e777665e4" translate="yes" xml:space="preserve">
          <source>SWAPDB</source>
          <target state="translated">SWAPDB</target>
        </trans-unit>
        <trans-unit id="b86537c7b961d4302819caedcc63376c729b2e03" translate="yes" xml:space="preserve">
          <source>SWAPDB  index index   Swaps two Redis databases</source>
          <target state="translated">SWAPDBインデックスインデックス 2つのRedisデータベースをスワップします。</target>
        </trans-unit>
        <trans-unit id="2f8d236566d2393cd3a112e7190d8837c8004cc2" translate="yes" xml:space="preserve">
          <source>SYNC</source>
          <target state="translated">SYNC</target>
        </trans-unit>
        <trans-unit id="7dade54cfe46a1450fe32e252c2fe2557e402641" translate="yes" xml:space="preserve">
          <source>SYNC   Internal command used for replication</source>
          <target state="translated">SYNC レプリケーションに使用される内部コマンド</target>
        </trans-unit>
        <trans-unit id="b54491fb2810da81b1ac818eeb380198be74decd" translate="yes" xml:space="preserve">
          <source>Same result format as &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; except you can specify which commands get returned.</source>
          <target state="translated">返されるコマンドを指定できることを除いて、&lt;a href=&quot;command&quot;&gt;COMMANDと&lt;/a&gt;同じ結果フォーマット。</target>
        </trans-unit>
        <trans-unit id="1cc201c6f067fb6b6182b441f2b6dc0f4b71649b" translate="yes" xml:space="preserve">
          <source>Sample Output (new version, includes IDs)</source>
          <target state="translated">サンプル出力(新バージョン、IDを含む</target>
        </trans-unit>
        <trans-unit id="fb0cb1b1aa0fcb98cea480e75b0d7dffc839cef1" translate="yes" xml:space="preserve">
          <source>Sample Output (old version)</source>
          <target state="translated">サンプル出力(旧バージョン</target>
        </trans-unit>
        <trans-unit id="7a614be0679e1660abb7ab566a46118d4e5207f9" translate="yes" xml:space="preserve">
          <source>Sandbox and maximum execution time</source>
          <target state="translated">サンドボックスと最大実行時間</target>
        </trans-unit>
        <trans-unit id="444bd4af75b503112dd46c6982e0bae0a08cf7c2" translate="yes" xml:space="preserve">
          <source>Save the DB in background. The OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits. A client may be able to check if the operation succeeded using the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; command.</source>
          <target state="translated">DBをバックグラウンドで保存します。OKコードがすぐに返されます。Redisはフォークし、親は引き続きクライアントにサービスを提供し、子はDBをディスクに保存して終了します。クライアントは、&lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt;コマンドを使用して操作が成功したかどうかを確認できる場合があります。</target>
        </trans-unit>
        <trans-unit id="6e73e4e94939b275e189527f28b962ac1035dc5b" translate="yes" xml:space="preserve">
          <source>Scan guarantees</source>
          <target state="translated">スキャン保証</target>
        </trans-unit>
        <trans-unit id="983987071368a426b6b0e610cd5b5142cb273380" translate="yes" xml:space="preserve">
          <source>Script cache semantics</source>
          <target state="translated">スクリプトキャッシュのセマンティクス</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">Scripting</target>
        </trans-unit>
        <trans-unit id="745fe7d4baa466214b942befb3f50f3311c89d23" translate="yes" xml:space="preserve">
          <source>Scripts are also subject to a maximum execution time (five seconds by default). This default timeout is huge since a script should usually run in under a millisecond. The limit is mostly to handle accidental infinite loops created during development.</source>
          <target state="translated">スクリプトには最大実行時間も設定されています (デフォルトでは 5 秒)。スクリプトは通常ミリ秒以下で実行されるはずなので、このデフォルトのタイムアウトは非常に大きなものです。この制限は主に、開発中に発生した不慮の無限ループを処理するためのものです。</target>
        </trans-unit>
        <trans-unit id="aef3e907fc9586fb823b51b6f43074de8b409561" translate="yes" xml:space="preserve">
          <source>Scripts as pure functions</source>
          <target state="translated">純粋な関数としてのスクリプト</target>
        </trans-unit>
        <trans-unit id="18ec3225e4d3fe66e7449672a6973e4c283e8bfa" translate="yes" xml:space="preserve">
          <source>Scripts should never try to access the external system, like the file system or any other system call. A script should only operate on Redis data and passed arguments.</source>
          <target state="translated">スクリプトは、ファイルシステムやその他のシステムコールのような外部システムにアクセスしようとしてはいけません。スクリプトは、Redis データと渡された引数のみを操作すべきです。</target>
        </trans-unit>
        <trans-unit id="96faa0a78d5b1890951d8f5b8b1cde571bd90423" translate="yes" xml:space="preserve">
          <source>Second replica</source>
          <target state="translated">セカンドレプリカ</target>
        </trans-unit>
        <trans-unit id="b5a6bb51bed42ec84477a8c64f567145dc6b3f5b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; for documentation.</source>
          <target state="translated">ドキュメントについては、&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="82b75cc42f6596f8de98cea0e684609b487d2473" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for extra information on increment/decrement operations.</source>
          <target state="translated">インクリメント/デクリメント操作の詳細については、&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="107b4f4ca6c2e49d71158688712e821a1f6afcf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; for more information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="54208184c8545cb10751d54f17912e96124fdcce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;hscan&quot;&gt;HSCANの&lt;/a&gt;ドキュメントについては、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c7350f489b2f884299284e290b37d7bb050416da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCANの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="23e07b46cb9a86395d17dec6e25da38c0a253bd8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCANの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="cf5419ddb7be58d105f864a1bb383d4d274d8979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).</source>
          <target state="translated">要素を最高スコアから最低スコアの順に並べる必要がある場合は&lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGEを&lt;/a&gt;参照してください（スコアが等しい要素の場合は辞書式の降順）。</target>
        </trans-unit>
        <trans-unit id="a4157bb7f9bac5025b0c70053cd9e97522de9f5f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command that returns the same information with milliseconds resolution (Only available in Redis 2.6 or greater).</source>
          <target state="translated">ミリ秒の分解能で同じ情報を返す&lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt;コマンドも参照してください（Redis 2.6以降でのみ使用可能）。</target>
        </trans-unit>
        <trans-unit id="3f65c6fd246f3e1cbd884a1abc8369fa9e3fec12" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being that it pops elements from the tail of a list instead of popping from the head.</source>
          <target state="translated">参照してください&lt;a href=&quot;blpop&quot;&gt;BLPOPのマニュアルを参照して&lt;/a&gt;いるので、正確なセマンティクスのため&lt;a href=&quot;brpop&quot;&gt;BRPOPは&lt;/a&gt;と同じです&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;唯一の違いは、それが代わりに頭から飛び出るのリストの末尾から要素をポップということで。</target>
        </trans-unit>
        <trans-unit id="98f2a156aa61e815ac476620027b033818a3853f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being the data structure being popped from.</source>
          <target state="translated">参照してください&lt;a href=&quot;blpop&quot;&gt;BLPOPのマニュアルを参照して&lt;/a&gt;いるので、正確なセマンティクスのため&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMINは&lt;/a&gt;同じです&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;唯一の違いはからポップされたデータ構造であることを。</target>
        </trans-unit>
        <trans-unit id="682db2e97701526e3ecf1f9201b3297eab6f9ec7" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is identical to &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; with the only difference being that it pops members with the highest scores instead of popping the ones with the lowest scores.</source>
          <target state="translated">参照してください&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMINのマニュアルを参照して&lt;/a&gt;いるので、正確な意味については&lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAXは&lt;/a&gt;同じです&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;唯一の違いは、それが代わりに最低のスコアを持つものをポップの最高得点を持つメンバーをポップということで。</target>
        </trans-unit>
        <trans-unit id="58bc20fb0dd298ffb8cf41a50998826b6c62ee0f" translate="yes" xml:space="preserve">
          <source>See the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot; for a interesting use cases.</source>
          <target state="translated">興味深いユースケースについては、「&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Redisビットマップを使用した高速で簡単なリアルタイムメトリック&lt;/a&gt;」という記事を参照してください。</target>
        </trans-unit>
        <trans-unit id="2b55d9f15b0ea2d72611a684c74d755e0354f5c5" translate="yes" xml:space="preserve">
          <source>Select the Redis logical database having the specified zero-based numeric index. New connections always use the database 0.</source>
          <target state="translated">指定されたゼロベースの数値インデックスを持つRedis論理データベースを選択します。新しい接続は常にデータベース0を使用します。</target>
        </trans-unit>
        <trans-unit id="19899928b5f8951aa558a826d2465808d72a01a5" translate="yes" xml:space="preserve">
          <source>Selective replication of commands</source>
          <target state="translated">コマンドの選択的複製</target>
        </trans-unit>
        <trans-unit id="49cedc3ef8c6db0043eba553132d30f3fe261b2a" translate="yes" xml:space="preserve">
          <source>Sentinel output</source>
          <target state="translated">センチネル出力</target>
        </trans-unit>
        <trans-unit id="23e75937982f844ac2efdda93d0cf6e15629e1a7" translate="yes" xml:space="preserve">
          <source>Serialization format</source>
          <target state="translated">シリアライズ形式</target>
        </trans-unit>
        <trans-unit id="7af4afd659e0dc29f7d2d75a3f48646f5eb4ec0b" translate="yes" xml:space="preserve">
          <source>Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command.</source>
          <target state="translated">キーに格納されている値をRedis固有の形式でシリアル化し、ユーザーに返します。&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;コマンドを使用して、戻り値を合成してRedisキーに戻すことができます。</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="c0ae85ee6d7ed57f6a577247b126ae67f64df433" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold string &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist. In that case, it is equal to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. When &lt;code&gt;key&lt;/code&gt; already holds a value, no operation is performed. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; is short for &quot;&lt;strong&gt;SET&lt;/strong&gt; if &lt;strong&gt;N&lt;/strong&gt;ot e&lt;strong&gt;X&lt;/strong&gt;ists&quot;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; が存在しない場合に文字列 &lt;code&gt;value&lt;/code&gt; を保持するように &lt;code&gt;key&lt;/code&gt; を設定します。その場合、それは&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;と同じです。ときに &lt;code&gt;key&lt;/code&gt; すでに値を保持し、何も操作は実行されません。&lt;a href=&quot;setnx&quot;&gt;SETNXは&lt;/a&gt; &quot;の略である&lt;strong&gt;SET&lt;/strong&gt;場合&lt;strong&gt;N&lt;/strong&gt; OT E &lt;strong&gt;X&lt;/strong&gt; ISTS&quot;。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68ffd036a56e1e5a5a24f70d86f4819eb308fad6" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt; and set &lt;code&gt;key&lt;/code&gt; to timeout after a given number of seconds. This command is equivalent to executing the following commands:</source>
          <target state="translated">文字列 &lt;code&gt;value&lt;/code&gt; を保持するように &lt;code&gt;key&lt;/code&gt; を設定し、指定された秒数後にタイムアウトするように &lt;code&gt;key&lt;/code&gt; を設定します。このコマンドは、次のコマンドを実行することと同等です。</target>
        </trans-unit>
        <trans-unit id="e17569ffaef1d28acdfd66d09de8af3c0b06dd1a" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation.</source>
          <target state="translated">文字列 &lt;code&gt;value&lt;/code&gt; を保持する &lt;code&gt;key&lt;/code&gt; を設定します。場合は &lt;code&gt;key&lt;/code&gt; すでに値を保持し、それは関係なく、そのタイプの、上書きされます。キーに関連付けられた以前の存続時間は、&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;操作が成功すると破棄されます。</target>
        </trans-unit>
        <trans-unit id="1f4c1e8e25a5de08761510d1ae33392ed98c3afb" translate="yes" xml:space="preserve">
          <source>Set a timeout on &lt;code&gt;key&lt;/code&gt;. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be &lt;em&gt;volatile&lt;/em&gt; in Redis terminology.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; タイムアウトを設定します。タイムアウトの期限が切れると、キーは自動的に削除されます。タイムアウトが関連付けられているキーは、Redisの用語では&lt;em&gt;揮発性&lt;/em&gt;であるとよく言われます。</target>
        </trans-unit>
        <trans-unit id="eaec93cdacc6eb6c55472f85e73e6fb3ad082dbe" translate="yes" xml:space="preserve">
          <source>Set the consumer group &lt;em&gt;last delivered ID&lt;/em&gt; to something else.</source>
          <target state="translated">コンシューマグループが&lt;em&gt;最後に配信したID&lt;/em&gt;を別の&lt;em&gt;ID&lt;/em&gt;に設定します。</target>
        </trans-unit>
        <trans-unit id="5d89ad31b7de012f12a03f34f4620f730e4db31a" translate="yes" xml:space="preserve">
          <source>Set the debug mode for subsequent scripts executed with &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;. Redis includes a complete Lua debugger, codename LDB, that can be used to make the task of writing complex scripts much simpler. In debug mode Redis acts as a remote debugging server and a client, such as &lt;code&gt;redis-cli&lt;/code&gt;, can execute scripts step by step, set breakpoints, inspect variables and more - for additional information about LDB refer to the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt; page.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVALで&lt;/a&gt;実行される後続のスクリプトのデバッグモードを設定します。Redisには、完全なLuaデバッガー、コードネームLDBが含まれています。これを使用して、複雑なスクリプトを作成するタスクをはるかに簡単にすることができます。デバッグモードでは、Redisはリモートデバッグサーバーとして機能し、 &lt;code&gt;redis-cli&lt;/code&gt; などのクライアントは、ステップバイステップでスクリプトを実行し、ブレークポイントを設定し、変数を検査します。LDBの詳細については、&lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Luaデバッガー&lt;/a&gt;ページを参照してください。</target>
        </trans-unit>
        <trans-unit id="6550b71f96cbf89e715fc6e575e8db9958a3525f" translate="yes" xml:space="preserve">
          <source>Set the destination node slot to &lt;em&gt;importing&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt; を使用して、宛先ノードスロットを&lt;em&gt;インポート&lt;/em&gt;状態に設定します。</target>
        </trans-unit>
        <trans-unit id="84c2dc8e1aa43a852766a49a5d96696d6e7e9329" translate="yes" xml:space="preserve">
          <source>Set the source node slot to &lt;em&gt;migrating&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; を使用して、ソースノードスロットを&lt;em&gt;移行&lt;/em&gt;状態に設定します。</target>
        </trans-unit>
        <trans-unit id="2ab262f44dfc9e1ee8adf98c1aa64de34434fa83" translate="yes" xml:space="preserve">
          <source>Sets</source>
          <target state="translated">Sets</target>
        </trans-unit>
        <trans-unit id="d9264103cd2db8160e2072438f28377ce6a9fc7b" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, only if &lt;code&gt;field&lt;/code&gt; does not yet exist. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists, this operation has no effect.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュの &lt;code&gt;field&lt;/code&gt; を &lt;code&gt;value&lt;/code&gt; に設定します（ &lt;code&gt;field&lt;/code&gt; がまだ存在しない場合のみ）。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、ハッシュを保持する新しいキーが作成されます。場合は &lt;code&gt;field&lt;/code&gt; すでに存在している、この操作は効果がありません。</target>
        </trans-unit>
        <trans-unit id="4067fd3c70d6275dbeb4b012c5dce8cf613a429a" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists in the hash, it is overwritten.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されたハッシュの &lt;code&gt;field&lt;/code&gt; を &lt;code&gt;value&lt;/code&gt; に設定します。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、ハッシュを保持する新しいキーが作成されます。 &lt;code&gt;field&lt;/code&gt; がハッシュにすでに存在する場合、それは上書きされます。</target>
        </trans-unit>
        <trans-unit id="e0c3c8b5846a6b7343db97e53a136456e18a31e2" translate="yes" xml:space="preserve">
          <source>Sets can be encoded as &lt;code&gt;intset&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;intset&lt;/code&gt; is a special encoding used for small sets composed solely of integers.</source>
          <target state="translated">セットはとしてエンコードすることができ &lt;code&gt;intset&lt;/code&gt; または &lt;code&gt;hashtable&lt;/code&gt; 。 &lt;code&gt;intset&lt;/code&gt; 、単に整数の小セットに使用される特別なエンコーディングです。</target>
        </trans-unit>
        <trans-unit id="e2de8a522a3c6c1fa9f2cb3110ab55a427778354" translate="yes" xml:space="preserve">
          <source>Sets or clears the bit at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;keyに&lt;/em&gt;格納されている文字列値の&lt;em&gt;オフセット&lt;/em&gt;のビットを設定またはクリアし&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e97dcc6f663f896d57a6785f5e028d865ad0719f" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; replaces existing values with new values, just as regular &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. See &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; if you don't want to overwrite existing values.</source>
          <target state="translated">指定されたキーをそれぞれの値に設定します。&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;は、通常の&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;と同様に、既存の値を新しい値で置き換えます。既存の値を上書きしたくない場合は、&lt;a href=&quot;msetnx&quot;&gt;MSETNXを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5a2c8ceb3bc610f26a67627aba4acc8339a9ce7d" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; will not perform any operation at all even if just a single key already exists.</source>
          <target state="translated">指定されたキーをそれぞれの値に設定します。&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt;は、単一のキーが既に存在する場合でも、何の操作も実行しません。</target>
        </trans-unit>
        <trans-unit id="8750c7a418a307afb7502f752e1bd4c1264fa761" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; のリスト要素を &lt;code&gt;value&lt;/code&gt; に設定します。詳細については &lt;code&gt;index&lt;/code&gt; 引数、参照&lt;a href=&quot;lindex&quot;&gt;LINDEXを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3acb8a6c67905faa893fe92726100c83a3b40b2e" translate="yes" xml:space="preserve">
          <source>Sets the specified fields to their respective values in the hash stored at &lt;code&gt;key&lt;/code&gt;. This command overwrites any specified fields already existing in the hash. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created.</source>
          <target state="translated">指定されたフィールドを、 &lt;code&gt;key&lt;/code&gt; に格納されているハッシュのそれぞれの値に設定します。このコマンドは、ハッシュに既に存在する指定されたフィールドを上書きします。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、ハッシュを保持する新しいキーが作成されます。</target>
        </trans-unit>
        <trans-unit id="66e4a6395d06dd6c9ac9889a54defa5d69368f6e" translate="yes" xml:space="preserve">
          <source>Similarly to get just the last element added into the stream it is enough to send:</source>
          <target state="translated">同様に、ストリームに追加された最後の要素だけを取得するには、それを送信するのに十分です。</target>
        </trans-unit>
        <trans-unit id="e66ca1aceaf1d95b66f61ef999386ba4322050ac" translate="yes" xml:space="preserve">
          <source>Simple string reply</source>
          <target state="translated">単純な文字列の返信</target>
        </trans-unit>
        <trans-unit id="d1d2334a81971315130c4fe2db94eeb5d843a482" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; and &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; have a &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; option they are technically flagged as writing commands in the Redis command table. For this reason read-only replicas will flag them, and Redis Cluster replicas will redirect them to the master instance even if the connection is in read only mode (See the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command of Redis Cluster).</source>
          <target state="translated">以来&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;と&lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBERを&lt;/a&gt;持っ &lt;code&gt;STORE&lt;/code&gt; と &lt;code&gt;STOREDIST&lt;/code&gt; オプションを彼らは技術的にRedisのコマンドテーブルにコマンドを書いとしてフラグ付けされています。このため、読み取り専用レプリカはフラグを立て、Redisクラスターレプリカは、接続が読み取り専用モードであってもマスターインスタンスにリダイレクトします（Redisクラスターの&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;コマンドを参照）。</target>
        </trans-unit>
        <trans-unit id="97d9bd95aec04226ad20ff34e75e5087d27999bb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; returns the number of replicas reached both in case of failure and success, the client should check that the returned value is equal or greater to the replication level it demanded.</source>
          <target state="translated">以来&lt;a href=&quot;wait&quot;&gt;WAITの&lt;/a&gt;リターンはレプリカの数が、失敗と成功の場合には、両方に達し、クライアントは、返される値は、それが要求複製レベル以上であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="d91e505ea765c9a82be96ae5534dfec641b36446" translate="yes" xml:space="preserve">
          <source>Since Redis 2.4 the AOF rewrite is automatically triggered by Redis, however the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; command can be used to trigger a rewrite at any time.</source>
          <target state="translated">Redis 2.4以降、AOF書き換えはRedisによって自動的にトリガーされますが、&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;コマンドを使用していつでも書き換えをトリガーできます。</target>
        </trans-unit>
        <trans-unit id="fea1afb4200834342d36841c2047774edeed20c3" translate="yes" xml:space="preserve">
          <source>Since Redis 2.6 the expire error is from 0 to 1 milliseconds.</source>
          <target state="translated">Redis 2.6以降、期限切れエラーは0から1ミリ秒になりました。</target>
        </trans-unit>
        <trans-unit id="c0dcf1f129fbdd5b581db58c1a230256a6836c37" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 it is possible to specify multiple keys instead of a single one. In such a case, it returns the total number of keys existing. Note that returning 1 or 0 for a single key is just a special case of the variadic usage, so the command is completely backward compatible.</source>
          <target state="translated">Redis 3.0.3以降、単一のキーではなく複数のキーを指定することが可能になりました。そのような場合、存在するキーの総数を返します。単一のキーに対して 1 や 0 を返すのは variadic の使用法の特殊なケースに過ぎないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f8bcf2ebedfce566d24835d3a2aba17bb7c2d1ca" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 the command accepts a variable number of keys and the return value is generalized:</source>
          <target state="translated">Redis 3.0.3以降、このコマンドは可変数のキーを受け付け、戻り値は一般化されています。</target>
        </trans-unit>
        <trans-unit id="e151485b203362c942ed95e59fd38510a0f0ba0d" translate="yes" xml:space="preserve">
          <source>Since Redis 3.2.10 / 4.0.0, this command also prevents keys to be evicted or expired during the time clients are paused. This way the dataset is guaranteed to be static not just from the point of view of clients not being able to write, but also from the point of view of internal operations.</source>
          <target state="translated">Redis 3.2.10/4.0.0.0以降では、このコマンドはクライアントが一時停止している間にキーが削除されたり、期限切れになったりするのを防ぐこともできます。このようにして、クライアントが書き込みできないという観点からだけでなく、内部操作の観点からも、データセットが静的であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="b23d8947d72fa1ab05d11117a996f014677a635b" translate="yes" xml:space="preserve">
          <source>Since in the second call the returned cursor is 0, the server signaled to the caller that the iteration finished, and the collection was completely explored. Starting an iteration with a cursor value of 0, and calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; until the returned cursor is 0 again is called a &lt;strong&gt;full iteration&lt;/strong&gt;.</source>
          <target state="translated">2番目の呼び出しで返されたカーソルは0であるため、サーバーは呼び出しが終了し、コレクションが完全に探索されたことを呼び出し元に通知しました。カーソル値0で反復を開始し、返されたカーソルが再び0になるまで&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;を呼び出すことを、&lt;strong&gt;完全反復&lt;/strong&gt;と呼び&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5ff6f2c9633e20e1d4f2fc7a23a6109e8917c9ab" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;increment&lt;/code&gt; argument is signed, both increment and decrement operations can be performed:</source>
          <target state="translated">以来 &lt;code&gt;increment&lt;/code&gt; 引数が署名され、両方のインクリメントとデクリメント操作を行うことができます。</target>
        </trans-unit>
        <trans-unit id="37a6aaafe1e5adca5e6fbd58e615c9ceed7c328a" translate="yes" xml:space="preserve">
          <source>Since the currently selected database is a property of the connection, clients should track the currently selected database and re-select it on reconnection. While there is no command in order to query the selected database in the current connection, the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; output shows, for each client, the currently selected database.</source>
          <target state="translated">現在選択されているデータベースは接続のプロパティであるため、クライアントは現在選択されているデータベースを追跡し、再接続時に再選択する必要があります。現在の接続で選択したデータベースを照会するコマンドはありませんが、&lt;a href=&quot;client-list&quot;&gt;CLIENT LISTの&lt;/a&gt;出力には、クライアントごとに現在選択されているデータベースが表示されます。</target>
        </trans-unit>
        <trans-unit id="52b5e60090730a6d250177de9e20295f9eac7ba4" translate="yes" xml:space="preserve">
          <source>Since the introduction of partial resynchronization with replicas (PSYNC feature) Redis replicas asynchronously ping their master with the offset they already processed in the replication stream. This is used in multiple ways:</source>
          <target state="translated">レプリカとの部分的な再同期化(PSYNC機能)が導入されて以来、Redisレプリカは、レプリケーションストリームで既に処理されたオフセットで非同期的にマスターにpingを行います。これは複数の方法で使用されます。</target>
        </trans-unit>
        <trans-unit id="22f6371320dc02af91620e9a2e69ac86d721aec2" translate="yes" xml:space="preserve">
          <source>Since there is no state server side, but the full state is captured by the cursor, the caller is free to terminate an iteration half-way without signaling this to the server in any way. An infinite number of iterations can be started and never terminated without any issue.</source>
          <target state="translated">状態サーバ側には状態が存在せず、カーソルによって完全な状態がキャプチャされるため、呼び出し元はサーバに何らのシグナルを送ることなく、反復を途中で終了させることができます。無限の数の反復が開始されても、問題なく終了することはありません。</target>
        </trans-unit>
        <trans-unit id="262e696e012026f3d4f6a8415b02d5a7c46227f9" translate="yes" xml:space="preserve">
          <source>Since these commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands like &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; or &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; that may block the server for a long time (even several seconds) when called against big collections of keys or elements.</source>
          <target state="translated">これらのコマンドはインクリメンタルな反復を可能にし、呼び出しごとに少数の要素のみを返すため、呼び出されたときにサーバーを長時間（数秒でも）ブロックする可能性がある&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;や&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt;などのコマンドの欠点なしで本番環境で使用できます。キーまたは要素の大きなコレクション。</target>
        </trans-unit>
        <trans-unit id="3c0c8d4b217b1b3c149a8290667da3e389e7ef26" translate="yes" xml:space="preserve">
          <source>Since this involves approximations, in order to avoid C is set to, like, 0.998 instead of 1, we just modify the above algorithm to make sure the last score is 1 (left as an exercise for the reader...).</source>
          <target state="translated">これには近似が含まれているので、Cが1ではなく0.998に設定されるのを避けるために、上のアルゴリズムを修正して、最後のスコアが1になるようにするだけです(読者のための演習として残しておきます...)。</target>
        </trans-unit>
        <trans-unit id="7872f5590df64a34d5d83302b83736d78de377e5" translate="yes" xml:space="preserve">
          <source>Since version 2.1.6, &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be exclusive, following the syntax of &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">バージョン2.1.6以降、&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;の構文に従って、 &lt;code&gt;min&lt;/code&gt; と &lt;code&gt;max&lt;/code&gt; を排他的にすることができます。</target>
        </trans-unit>
        <trans-unit id="1c1d2abc7675af0239fa910c466960e644589788" translate="yes" xml:space="preserve">
          <source>Single number: 3894</source>
          <target state="translated">単数:3894</target>
        </trans-unit>
        <trans-unit id="f4a53209e61b36ab81faa5f943fba8e855032018" translate="yes" xml:space="preserve">
          <source>Skip sorting the elements</source>
          <target state="translated">要素のソートをスキップ</target>
        </trans-unit>
        <trans-unit id="8eab09bbd450823e91103eb2aaa19c7c3697409f" translate="yes" xml:space="preserve">
          <source>So for example the command &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; will return each item in the following way:</source>
          <target state="translated">たとえば、コマンド &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; は、次のように各アイテムを返します。</target>
        </trans-unit>
        <trans-unit id="76d0f19de574ac1304a0b3b169f72caa92244d72" translate="yes" xml:space="preserve">
          <source>So for instance, to get all the elements from the higher ID to the lower ID one could use:</source>
          <target state="translated">そのため、例えば、高い方のIDから低い方のIDまでのすべての要素を取得するには、以下のような方法があります。</target>
        </trans-unit>
        <trans-unit id="605cfa3fd340ae3e5e756672779740b80a689628" translate="yes" xml:space="preserve">
          <source>So in order for a given node to accept another one into the list of nodes composing a Redis Cluster, there are only two ways:</source>
          <target state="translated">そのため、あるノードがRedisクラスタを構成するノードのリストに別のノードを受け入れるためには、2つの方法しかありません。</target>
        </trans-unit>
        <trans-unit id="2350b72b46e64aeb370c2cbfa4c601de95c3d620" translate="yes" xml:space="preserve">
          <source>So we start with a list of keys, and later continue with all the associated IDs, representing &lt;em&gt;the last ID we received for that stream&lt;/em&gt;, so that the call will serve us only greater IDs from the same stream.</source>
          <target state="translated">したがって、キーのリストから開始し、その後&lt;em&gt;、そのストリームに対して受け取った最後のIDを&lt;/em&gt;表すすべての関連IDに進み&lt;em&gt;ます&lt;/em&gt;。これにより、呼び出しは同じストリームからのより大きなIDのみを処理します。</target>
        </trans-unit>
        <trans-unit id="46ddca2244f21f2b27c1eb6025f1e694d4b8bea0" translate="yes" xml:space="preserve">
          <source>So what the command really does is:</source>
          <target state="translated">だから、コマンドが実際に何をするかというと</target>
        </trans-unit>
        <trans-unit id="f434d4f52b4b99882f1b83c63bcdd004df128d69" translate="yes" xml:space="preserve">
          <source>So, if we link node A with node B via &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;, and B with C, A and C will find their ways to handshake and create a link.</source>
          <target state="translated">したがって、&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;を介してノードAをノードBにリンクし、BをCにリンクすると、AとCはハンドシェイクしてリンクを作成する方法を見つけます。</target>
        </trans-unit>
        <trans-unit id="60790236df4f5916ea98a7288f81aafe33a99ab5" translate="yes" xml:space="preserve">
          <source>So, using &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt;, when a new cluster is created, we can assign a different progressive configuration epoch to each node before joining the cluster together.</source>
          <target state="translated">したがって、 &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt; を使用すると、新しいクラスターが作成されたときに、クラスターを結合する前に各ノードに異なるプログレッシブ構成エポックを割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="173217936882f8d5719c8defa86bf0d23eac51fe" translate="yes" xml:space="preserve">
          <source>Some Redis commands have no predetermined key locations. For those commands, flag &lt;code&gt;movablekeys&lt;/code&gt; is added to the command flags &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;. Your Redis Cluster client needs to parse commands marked &lt;code&gt;movablekeys&lt;/code&gt; to locate all relevant key positions.</source>
          <target state="translated">一部のRedisコマンドには、キーの場所が事前に定義されていません。これらのコマンドでは、フラグ &lt;code&gt;movablekeys&lt;/code&gt; がコマンドフラグの&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列応答に&lt;/a&gt;追加されます。Redisクラスタークライアントは、すべての関連するキーの位置を見つけるために、 &lt;code&gt;movablekeys&lt;/code&gt; とマークされたコマンドを解析する必要があります。</target>
        </trans-unit>
        <trans-unit id="ddceed7fe40007b57317ba7df983076bcd185123" translate="yes" xml:space="preserve">
          <source>Some consumer A reads a message via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; from a stream, in the context of that consumer group.</source>
          <target state="translated">一部のコンシューマーA は、そのコンシューマーグループのコンテキストで、ストリームから&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;を介してメッセージを読み取ります。</target>
        </trans-unit>
        <trans-unit id="28d440075fc880e5ff5b66c8a65009bc3be5acfb" translate="yes" xml:space="preserve">
          <source>Sometimes it can be useful for clients to completely disable replies from the Redis server. For example when the client sends fire and forget commands or performs a mass loading of data, or in caching contexts where new data is streamed constantly. In such contexts to use server time and bandwidth in order to send back replies to clients, which are going to be ignored, is considered wasteful.</source>
          <target state="translated">クライアントがRedisサーバからの返信を完全に無効にすることが有用な場合もあります。例えば、クライアントが fire and forget コマンドを送信したり、データの大量ロードを行ったり、新しいデータが常にストリーミングされるようなキャッシングのコンテキストでは、そのような場合には、サーバの時間と帯域幅を使用します。このような状況では、無視されそうな返信をクライアントに送り返すためにサーバの時間と帯域幅を使うのは無駄なことだと考えられます。</target>
        </trans-unit>
        <trans-unit id="43292f17e4e5fce7b6e4920a4500928789cc3b9d" translate="yes" xml:space="preserve">
          <source>Sometimes you want to sort elements using external keys as weights to compare instead of comparing the actual elements in the list, set or sorted set. Let's say the list &lt;code&gt;mylist&lt;/code&gt; contains the elements &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; representing unique IDs of objects stored in &lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;. When these objects have associated weights stored in &lt;code&gt;weight_1&lt;/code&gt;, &lt;code&gt;weight_2&lt;/code&gt; and &lt;code&gt;weight_3&lt;/code&gt;, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; can be instructed to use these weights to sort &lt;code&gt;mylist&lt;/code&gt; with the following statement:</source>
          <target state="translated">リスト、セット、またはソート済みセットの実際の要素を比較するのではなく、外部キーを重みとして使用して要素をソートしたい場合があります。リストを言ってみましょう &lt;code&gt;mylist&lt;/code&gt; 要素が含ま &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;2&lt;/code&gt; 及び &lt;code&gt;3&lt;/code&gt; に格納されているオブジェクトのユニークなIDを表す &lt;code&gt;object_1&lt;/code&gt; 、 &lt;code&gt;object_2&lt;/code&gt; と &lt;code&gt;object_3&lt;/code&gt; を。これらのオブジェクトに &lt;code&gt;weight_1&lt;/code&gt; 、 &lt;code&gt;weight_2&lt;/code&gt; 、および &lt;code&gt;weight_3&lt;/code&gt; に格納された重みが関連付けられている場合、次のステートメントでこれらの重みを使用して &lt;code&gt;mylist&lt;/code&gt; をソートするように&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;に指示できます。</target>
        </trans-unit>
        <trans-unit id="b2397d818d7562914c5b062b54f97e833db314f2" translate="yes" xml:space="preserve">
          <source>Sorted Sets</source>
          <target state="translated">ソートされたセット</target>
        </trans-unit>
        <trans-unit id="25ab5e6a0d5f2c9c6bc25d348c156dc61d5c8552" translate="yes" xml:space="preserve">
          <source>Sorted Sets can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;skiplist&lt;/code&gt; format. As for the List type small sorted sets can be specially encoded using &lt;code&gt;ziplist&lt;/code&gt;, while the &lt;code&gt;skiplist&lt;/code&gt; encoding is the one that works with sorted sets of any size.</source>
          <target state="translated">ソートされたセットは、 &lt;code&gt;ziplist&lt;/code&gt; または &lt;code&gt;skiplist&lt;/code&gt; 形式としてエンコードできます。リストタイプについては、小さいソートセットは &lt;code&gt;ziplist&lt;/code&gt; を使用して特別にエンコードできますが、 &lt;code&gt;skiplist&lt;/code&gt; エンコーディングは、任意のサイズのソートセットで機能します。</target>
        </trans-unit>
        <trans-unit id="86e387fe2a33fb39f76cfff98ea344b952f84a62" translate="yes" xml:space="preserve">
          <source>Sorted sets 101</source>
          <target state="translated">ソートされたセット101</target>
        </trans-unit>
        <trans-unit id="785f83ba9125723b72d2c573196ef8beabb345a8" translate="yes" xml:space="preserve">
          <source>Sorted sets are sorted by their score in an ascending way. The same element only exists a single time, no repeated elements are permitted. The score can be modified both by &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; that will update the element score, and as a side effect, its position on the sorted set, and by &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; that can be used in order to update the score relatively to its previous value.</source>
          <target state="translated">ソートされたセットは、スコアによって昇順でソートされます。同じ要素は1回だけ存在し、繰り返しの要素は許可されません。スコアは、要素のスコアを更新する&lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt;と副作用としてのソート済みセット上の位置、および以前の値と比較してスコアを更新するために使用できる&lt;a href=&quot;zincrby&quot;&gt;ZINCRBYの両方&lt;/a&gt;によって変更できます。</target>
        </trans-unit>
        <trans-unit id="2f2a07b6f7677455f1b32d657bbc8366bfa48bf3" translate="yes" xml:space="preserve">
          <source>Sorting by external keys</source>
          <target state="translated">外部キーによるソート</target>
        </trans-unit>
        <trans-unit id="614fb399b6728ae041f21780ab6202d98e11c79a" translate="yes" xml:space="preserve">
          <source>Special conditions not allowing the command execution</source>
          <target state="translated">コマンドの実行を許可しない特殊条件</target>
        </trans-unit>
        <trans-unit id="0869a917cb9ab140bb00f5d52e7332ad6727fd9a" translate="yes" xml:space="preserve">
          <source>Special slot entries</source>
          <target state="translated">特別なスロットのエントリー</target>
        </trans-unit>
        <trans-unit id="549c2b56d95e908566338d2fd5914a21fd08d936" translate="yes" xml:space="preserve">
          <source>Specifically if a given write is transferred to one or more replicas, it is more likely (but not guaranteed) that if the master fails, we'll be able to promote, during a failover, a replica that received the write: both Sentinel and Redis Cluster will do a best-effort attempt to promote the best replica among the set of available replicas.</source>
          <target state="translated">具体的には、ある書き込みが1つ以上のレプリカに転送された場合、マスターに障害が発生した場合、フェイルオーバー中に書き込みを受けたレプリカをプロモートできる可能性が高くなります (保証はされませんが)。</target>
        </trans-unit>
        <trans-unit id="d526406a65071e1fec15bd4174751e7a5bc387d7" translate="yes" xml:space="preserve">
          <source>Specifically this is what Redis does 10 times per second:</source>
          <target state="translated">具体的には、これがRedisが1秒間に10回行うことです。</target>
        </trans-unit>
        <trans-unit id="37ec7d989573caff7ef9f45953dba8d022709000" translate="yes" xml:space="preserve">
          <source>Specification of the behavior when count is passed</source>
          <target state="translated">カウントが渡されたときの動作の指定</target>
        </trans-unit>
        <trans-unit id="14c30af049c8842dbcbd1159d5db60d5f0981029" translate="yes" xml:space="preserve">
          <source>Specifying a Stream ID as an argument</source>
          <target state="translated">ストリームIDを引数に指定する</target>
        </trans-unit>
        <trans-unit id="1544a5bc78a2aee56854818668d14afd235ec6c9" translate="yes" xml:space="preserve">
          <source>Start slot range</source>
          <target state="translated">開始スロット範囲</target>
        </trans-unit>
        <trans-unit id="ee455845986f290115764586b0c8b62db6794d99" translate="yes" xml:space="preserve">
          <source>Starting from Redis version 2.6, when called with the additional &lt;code&gt;count&lt;/code&gt; argument, return an array of &lt;code&gt;count&lt;/code&gt;&lt;strong&gt;distinct elements&lt;/strong&gt; if &lt;code&gt;count&lt;/code&gt; is positive. If called with a negative &lt;code&gt;count&lt;/code&gt; the behavior changes and the command is allowed to return the &lt;strong&gt;same element multiple times&lt;/strong&gt;. In this case the number of returned elements is the absolute value of the specified &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Redisバージョン2.6以降、追加の &lt;code&gt;count&lt;/code&gt; 引数を指定して呼び出された場合、 &lt;code&gt;count&lt;/code&gt; が正の場合、 &lt;code&gt;count&lt;/code&gt; 個の&lt;strong&gt;異なる要素の&lt;/strong&gt;配列を返します。負の &lt;code&gt;count&lt;/code&gt; 呼び出されると、動作が変化し、コマンドは&lt;strong&gt;同じ要素を複数回&lt;/strong&gt;返すことができます。この場合、返される要素の数は、指定された &lt;code&gt;count&lt;/code&gt; 絶対値です。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83f9c28598d952311fc09fa54e334ed57a68832b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; supports a set of options that modify its behavior:</source>
          <target state="translated">Redis 2.6.12以降、&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;はその動作を変更する一連のオプションをサポートしています。</target>
        </trans-unit>
        <trans-unit id="f154b597ac1178d82fc4c50afc3e83d654688468" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.8 the return value in case of error changed:</source>
          <target state="translated">Redis 2.8からエラー時の戻り値が変更されました。</target>
        </trans-unit>
        <trans-unit id="cb9c10a639cbbf2b71b38cd0e777ffb915ed4e8b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.0.6 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; supports a new bulk-migration mode that uses pipelining in order to migrate multiple keys between instances without incurring in the round trip time latency and other overheads that there are when moving each key with a single &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; call.</source>
          <target state="translated">Redis 3.0.6以降、&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;は、パイプラインを使用する新しい一括移行モードをサポートしています。この一括移行モードでは、単一の&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;呼び出しで各キーを移動するときに発生するラウンドトリップ時間のレイテンシやその他のオーバーヘッドを発生させることなく、インスタンス間で複数のキーを移行します。</target>
        </trans-unit>
        <trans-unit id="6578980d36f8246047edd57af78a6f9934454cea" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, Redis has support for native Lua debugging. The Redis Lua debugger is a remote debugger consisting of a server, which is Redis itself, and a client, which is by default &lt;code&gt;redis-cli&lt;/code&gt;.</source>
          <target state="translated">Redis 3.2以降、RedisはネイティブLuaデバッグをサポートしています。Redis Luaデバッガーは、サーバー（Redis自体）とクライアント（デフォルトでは &lt;code&gt;redis-cli&lt;/code&gt; )で構成されるリモートデバッガーです。</target>
        </trans-unit>
        <trans-unit id="5b01b9bd2a097f98e87d6033b411073bab6691f7" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, it is possible to select an alternative replication method. Instead of replication whole scripts, we can just replicate single write commands generated by the script. We call this &lt;strong&gt;script effects replication&lt;/strong&gt;.</source>
          <target state="translated">Redis 3.2以降では、代替のレプリケーション方法を選択できます。スクリプト全体を複製する代わりに、スクリプトによって生成された単一の書き込みコマンドを複製することができます。この&lt;strong&gt;スクリプトをレプリケーション&lt;/strong&gt;と呼びます。</target>
        </trans-unit>
        <trans-unit id="1ffd355623442762e32037427cffdb34a18e3984" translate="yes" xml:space="preserve">
          <source>Step 4 does not technically need to use &lt;code&gt;SETSLOT&lt;/code&gt; in the nodes not involved in the resharding, since the configuration will eventually propagate itself, however it is a good idea to do so in order to stop nodes from pointing to the wrong node for the hash slot moved as soon as possible, resulting in less redirections to find the right node.</source>
          <target state="translated">ステップ4では、設定が最終的に自身を伝播するため、技術的には &lt;code&gt;SETSLOT&lt;/code&gt; に関与しないノードでSETSLOTを使用する必要はありませんが、ノードがハッシュスロットの間違ったノードを指すのを防ぐためにそうすることをお勧めしますできるだけ早く移動し、正しいノードを見つけるためのリダイレクトを減らしました。</target>
        </trans-unit>
        <trans-unit id="f75b76768d708a29fc0fb9becaf181931853bd99" translate="yes" xml:space="preserve">
          <source>Step Count</source>
          <target state="translated">ステップ数</target>
        </trans-unit>
        <trans-unit id="f7fa846d5511789adfec64aa9b8751f7351a0ca5" translate="yes" xml:space="preserve">
          <source>Stop all the clients.</source>
          <target state="translated">客を全員止めろ</target>
        </trans-unit>
        <trans-unit id="6cb759f69a54fcb63d47af649e368c12075f71be" translate="yes" xml:space="preserve">
          <source>Storing the result of a SORT operation</source>
          <target state="translated">SORT操作の結果を保存する</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="61c2b2148d7f362f23210527dbc1bd6b0437b131" translate="yes" xml:space="preserve">
          <source>Stream IDs are composed of two parts, a Unix millisecond time stamp and a sequence number for entries inserted in the same millisecond. It is possible to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; specifying just the first part of the ID, the millisecond time, like in the following example:</source>
          <target state="translated">ストリームIDは、Unixミリ秒のタイムスタンプと、同じミリ秒に挿入されたエントリのシーケンス番号の2つの部分で構成されています。次の例のように、&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;を使用して、IDの最初の部分であるミリ秒の時間のみを指定することができます。</target>
        </trans-unit>
        <trans-unit id="f7e700aeb9d8c3a456c6730300f1abde75268288" translate="yes" xml:space="preserve">
          <source>Streams are not auto-deleted once they have no entries inside (for instance after an &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; call), because the stream may have consumer groups associated with it.</source>
          <target state="translated">ストリームにエントリがない場合（&lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt;呼び出し後など）、ストリームにはコンシューマグループが関連付けられている可能性があるため、ストリームは自動削除されません。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="48c2711e04347f7b6d1ddd6b4a79296a8d2830ea" translate="yes" xml:space="preserve">
          <source>Strings are compared as binary array of bytes. Because of how the ASCII character set is specified, this means that usually this also have the effect of comparing normal ASCII characters in an obvious dictionary way. However this is not true if non plain ASCII strings are used (for example utf8 strings).</source>
          <target state="translated">文字列はバイトのバイナリ配列として比較されます。ASCII 文字セットがどのように指定されているかによって、通常は通常の ASCII 文字を辞書的に比較する効果があることを意味します。しかし、プレーンでないASCII文字列(例えばutf8文字列)が使用されている場合はこの限りではありません。</target>
        </trans-unit>
        <trans-unit id="2593368d27635cc5293b7e53f7145a56dff05dd8" translate="yes" xml:space="preserve">
          <source>Strings can be encoded as &lt;code&gt;raw&lt;/code&gt; (normal string encoding) or &lt;code&gt;int&lt;/code&gt; (strings representing integers in a 64 bit signed interval are encoded in this way in order to save space).</source>
          <target state="translated">文字列は、 &lt;code&gt;raw&lt;/code&gt; （通常の文字列エンコーディング）または &lt;code&gt;int&lt;/code&gt; （64ビットの符号付き間隔の整数を表す文字列は、スペースを節約するためにこの方法でエンコードされます）としてエンコードできます。</target>
        </trans-unit>
        <trans-unit id="d5294ece475c0dd1b0e5c4f6f621c1e0c0bf7039" translate="yes" xml:space="preserve">
          <source>Strings with a similar prefix are nearby, but the contrary is not true, it is possible that strings with different prefixes are nearby too.</source>
          <target state="translated">接頭辞が似ている文字列が近くにありますが、逆に接頭辞が違う文字列も近くにある可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f9d46e5fb83a7700b4c788a03b12a80a7e61e08" translate="yes" xml:space="preserve">
          <source>Subcommand &lt;code&gt;encoding&lt;/code&gt; returns a bulk reply.</source>
          <target state="translated">サブコマンドの &lt;code&gt;encoding&lt;/code&gt; は、バルク応答を返します。</target>
        </trans-unit>
        <trans-unit id="03e52fefcd721e1070e1756817dc5fb3908630a4" translate="yes" xml:space="preserve">
          <source>Subcommands &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;idletime&lt;/code&gt; return integers.</source>
          <target state="translated">サブコマンド &lt;code&gt;refcount&lt;/code&gt; および &lt;code&gt;idletime&lt;/code&gt; は整数を返します。</target>
        </trans-unit>
        <trans-unit id="9cdf88a718c3f491225fa1cc2fd76602c7208ad1" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the given patterns.</source>
          <target state="translated">クライアントを指定されたパターンにサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="481c5cf231fde7f8730860922d6f3194fc5f2170" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the specified channels.</source>
          <target state="translated">指定したチャンネルにクライアントをサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="4a47fd9934d349f948abbf361726590ff096c6b8" translate="yes" xml:space="preserve">
          <source>Summary form of XPENDING</source>
          <target state="translated">XPENDENDINGの概要</target>
        </trans-unit>
        <trans-unit id="dfe7ee6f8d575326187ecdb8ea7e6fb7cbf4ec35" translate="yes" xml:space="preserve">
          <source>Supported glob-style patterns:</source>
          <target state="translated">グロブスタイルのパターンをサポートしました。</target>
        </trans-unit>
        <trans-unit id="ced890cac00d712740bdc4d39c1db48f7483c499" translate="yes" xml:space="preserve">
          <source>Supported subcommands and integer types</source>
          <target state="translated">サポートされているサブコマンドと整数型</target>
        </trans-unit>
        <trans-unit id="b8398e47e81dab008569a234703960eb8bab2f11" translate="yes" xml:space="preserve">
          <source>TAKEOVER option: manual failover without cluster consensus</source>
          <target state="translated">TAKEOVERオプション:クラスタコンセンサスなしの手動フェイルオーバー</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="8696f7a4c64b4516c2d96434e8b7824957a37d2a" translate="yes" xml:space="preserve">
          <source>TIME   Return the current server time</source>
          <target state="translated">TIME 現在のサーバーの時刻を返します。</target>
        </trans-unit>
        <trans-unit id="c701f5f92060225c236ac0e6b3051e03bb0ad061" translate="yes" xml:space="preserve">
          <source>TOUCH</source>
          <target state="translated">TOUCH</target>
        </trans-unit>
        <trans-unit id="ad5ae533c502772151a704d28a2bece0e0f4ca1b" translate="yes" xml:space="preserve">
          <source>TOUCH  key [key ...]   Alters the last access time of a key(s). Returns the number of existing keys specified.</source>
          <target state="translated">TOUCH key [key ...]キーの最終アクセス時刻を変更します。指定した既存のキーの数を返します。</target>
        </trans-unit>
        <trans-unit id="878260dfb888c3312c119e6db2253c2aa207ae98" translate="yes" xml:space="preserve">
          <source>TTL</source>
          <target state="translated">TTL</target>
        </trans-unit>
        <trans-unit id="8ef7742bd419d3406904eb9723c6ce85d49c0f81" translate="yes" xml:space="preserve">
          <source>TTL  key   Get the time to live for a key</source>
          <target state="translated">TTLキー 鍵のために生きる時間を手に入れる</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="7d0cfb250d49bba162e019907ea71cfcab32d9f4" translate="yes" xml:space="preserve">
          <source>TYPE  key   Determine the type stored at key</source>
          <target state="translated">TYPE キー キーに格納されているタイプを決定します。</target>
        </trans-unit>
        <trans-unit id="5bbc08d2de04a7034dc9edbe2e20759367a5f82f" translate="yes" xml:space="preserve">
          <source>Taking a separated key that is incremented every time the bitmap is modified. This can be very efficient and atomic using a small Redis Lua script.</source>
          <target state="translated">分離されたキーを取り、ビットマップが変更されるたびにインクリメントされます。これは、小さなRedis Luaスクリプトを使用することで、非常に効率的でアトミックなものになります。</target>
        </trans-unit>
        <trans-unit id="8b5d4fb8b75675d300f4de7425675abc3149473f" translate="yes" xml:space="preserve">
          <source>Terminating iterations in the middle</source>
          <target state="translated">イテレーションを途中で終了させる</target>
        </trans-unit>
        <trans-unit id="8a78f0cb0822107a63b906522f8970fb02d3906a" translate="yes" xml:space="preserve">
          <source>Test 20 random keys from the set of keys with an associated expire.</source>
          <target state="translated">関連する期限切れの鍵のセットから20個のランダムな鍵をテストします。</target>
        </trans-unit>
        <trans-unit id="0c0c5f66ed89ad8b7f73f25128b137a4d67fcbb8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; and the analogous &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; commands, you can use Redis strings as a linear array with O(1) random access. This is a very fast and efficient storage in many real world use cases.</source>
          <target state="translated">&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt;と類似の&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;コマンドのおかげで、Redis文字列をO（1）ランダムアクセスの線形配列として使用できます。これは、多くの実際の使用例で非常に高速で効率的なストレージです。</target>
        </trans-unit>
        <trans-unit id="733be8ce43bb740e68f58527c40732d288c9eb0b" translate="yes" xml:space="preserve">
          <source>That said, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; can be used, and was historically used, as a locking primitive. For example, to acquire the lock of the key &lt;code&gt;foo&lt;/code&gt;, the client could try the following:</source>
          <target state="translated">そうは言っても、&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;はロックプリミティブとして使用でき、歴史的に使用されていました。たとえば、キー &lt;code&gt;foo&lt;/code&gt; のロックを取得するために、クライアントは次のことを試すことができます。</target>
        </trans-unit>
        <trans-unit id="77d6d135447dbf512e1ae2af8102405447c9f874" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; command can be used to create a very compact representation of a list of fixed-size samples, usually referred as &lt;em&gt;time series&lt;/em&gt;. Every time a new sample arrives we can store it using the command</source>
          <target state="translated">&lt;a href=&quot;append&quot;&gt;APPENDの&lt;/a&gt;コマンドは、固定サイズのサンプルのリストの非常にコンパクトな表現を作成するために使用することができ、通常と呼ば&lt;em&gt;時系列&lt;/em&gt;。新しいサンプルが到着するたびに、次のコマンドを使用して保存できます</target>
        </trans-unit>
        <trans-unit id="af3680004f1f3af89a74cfdd597524f1d5b57aa0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; command supports four bitwise operations: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;, &lt;strong&gt;XOR&lt;/strong&gt; and &lt;strong&gt;NOT&lt;/strong&gt;, thus the valid forms to call the command are:</source>
          <target state="translated">&lt;a href=&quot;bitop&quot;&gt;BITOPの&lt;/a&gt;コマンドは、4ビット単位の操作をサポートします。&lt;strong&gt;AND&lt;/strong&gt;、&lt;strong&gt;OR&lt;/strong&gt;、&lt;strong&gt;XOR&lt;/strong&gt;および&lt;strong&gt;NOT&lt;/strong&gt;、これコマンドを呼び出すための有効な形式は以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="4dd66d959585425a19858f722e901be8748f987c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; returns the name of the current connection as set by &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;. Since every new connection starts without an associated name, if no name was assigned a null bulk reply is returned.</source>
          <target state="translated">&lt;a href=&quot;client-getname&quot;&gt;クライアントGETNAMEは&lt;/a&gt;によって設定された現在の接続の名前を返す&lt;a href=&quot;client-setname&quot;&gt;クライアントSETNAMEを&lt;/a&gt;。新しい接続はすべて関連付けられた名前なしで開始されるため、名前が割り当てられていない場合は、nullバルク応答が返されます。</target>
        </trans-unit>
        <trans-unit id="77571e239b6c4924e5ae8625b133ece1b2fb165b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. Up to Redis 2.8.11 it was possible to close a connection only by client address, using the following form:</source>
          <target state="translated">&lt;a href=&quot;client-kill&quot;&gt;クライアントのKILL&lt;/a&gt;コマンドは、指定されたクライアント接続を閉じます。Redis 2.8.11までは、次の形式を使用して、クライアントアドレスによってのみ接続を閉じることができました。</target>
        </trans-unit>
        <trans-unit id="c0d7e72efd1901513aa26d76fc6efa880b0ffcd7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command returns information and statistics about the client connections server in a mostly human readable format.</source>
          <target state="translated">&lt;a href=&quot;client-list&quot;&gt;クライアントリストの&lt;/a&gt;コマンドは、主に人間が読める形式でクライアント接続サーバーに関する情報と統計を返します。</target>
        </trans-unit>
        <trans-unit id="99ea497bab9ec2eb991df932e164aeadc0d98009" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; command controls whether the server will reply the client's commands. The following modes are available:</source>
          <target state="translated">&lt;a href=&quot;client-reply&quot;&gt;クライアントREPLYの&lt;/a&gt;コマンドコントロールは、サーバーはクライアントのコマンドを返信しますか。次のモードを使用できます。</target>
        </trans-unit>
        <trans-unit id="66ef05bc81ce96b58454a695580464830edc9445" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command assigns a name to the current connection.</source>
          <target state="translated">&lt;a href=&quot;client-setname&quot;&gt;クライアントSETNAMEの&lt;/a&gt;コマンドは、現在の接続に名前を割り当てます。</target>
        </trans-unit>
        <trans-unit id="29ca3ac0a9d2f6b99b3b3cfed122170d73c27a26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command is an important piece used by Redis Cluster in order to migrate all the keys contained in one hash slot from one node to another. This is how the migration is orchestrated, with the help of other commands as well. We'll call the node that has the current ownership of the hash slot the &lt;code&gt;source&lt;/code&gt; node, and the node where we want to migrate the &lt;code&gt;destination&lt;/code&gt; node.</source>
          <target state="translated">&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTERのSETSLOTの&lt;/a&gt;コマンドは、1つのノードから別の1つのハッシュスロットに含まれるすべてのキーを移行するためにRedisのクラスタによって使用される重要な部分です。これは、他のコマンドを使用して移行を調整する方法です。ハッシュスロットの現在の所有権を持つノードを &lt;code&gt;source&lt;/code&gt; ノードと呼び、 &lt;code&gt;destination&lt;/code&gt; ノードを移行するノードと呼びます。</target>
        </trans-unit>
        <trans-unit id="9969254dbf9ad62d16ce54578a579c12bed90714" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; command is used to read the configuration parameters of a running Redis server. Not all the configuration parameters are supported in Redis 2.4, while Redis 2.6 can read the whole configuration of a server using this command.</source>
          <target state="translated">&lt;a href=&quot;config-get&quot;&gt;CONFIGのGETの&lt;/a&gt;コマンドが実行されているRedisのサーバーの構成パラメータを読み取るために使用されます。Redis 2.4ではすべての構成パラメーターがサポートされているわけではありませんが、Redis 2.6ではこのコマンドを使用してサーバーの構成全体を読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="b44e010365af8a822e0e64c895b3b9356396e69b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; command rewrites the &lt;code&gt;redis.conf&lt;/code&gt; file the server was started with, applying the minimal changes needed to make it reflect the configuration currently used by the server, which may be different compared to the original one because of the use of the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITEの&lt;/a&gt;コマンドが書き換えられ &lt;code&gt;redis.conf&lt;/code&gt; のための使用のオリジナルのものと比べて異なることがあり、それが現在のサーバで使用される設定を反映させるために必要な最小限の変更、適用し、サーバーがで開始されたファイルを&lt;a href=&quot;config-set&quot;&gt;CONFIG SETを&lt;/a&gt;コマンド。</target>
        </trans-unit>
        <trans-unit id="a94ff0d50f7b4db45f039a4dafafa3f4c9259a89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command is used in order to reconfigure the server at run time without the need to restart Redis. You can change both trivial parameters or switch from one to another persistence option using this command.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIGのSET&lt;/a&gt;コマンドはRedisのを再起動することなく、実行時にサーバーを再構成するために使用されています。このコマンドを使用して、両方の簡単なパラメーターを変更するか、1つの永続化オプションから別の永続化オプションに切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="166c68e394d8ab06f1a3bb76f56f32a612a6683d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command forces you to send the script body again and again. Redis does not need to recompile the script every time as it uses an internal caching mechanism, however paying the cost of the additional bandwidth may not be optimal in many contexts.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVALの&lt;/a&gt;コマンド部隊あなたは何度も何度もスクリプト本体を送信します。Redisは内部キャッシュメカニズムを使用するため、毎回スクリプトを再コンパイルする必要はありませんが、追加の帯域幅のコストを支払うことは、多くの状況で最適ではない場合があります。</target>
        </trans-unit>
        <trans-unit id="bd6411fae08a91e9b321232ed876a3d9070cad9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; family of commands is able to associate an expire to a given key, at the cost of some additional memory used by the key. When a key has an expire set, Redis will make sure to remove the key when the specified amount of time elapsed.</source>
          <target state="translated">コマンドの&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;ファミリーは、キーによって使用される追加のメモリを犠牲にして、特定のキーに有効期限を関連付けることができます。キーに有効期限が設定されている場合、Redisは指定された時間が経過するとキーを削除するようにします。</target>
        </trans-unit>
        <trans-unit id="ae44c019fde6841c16a68c04d38047f2e0f60739" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command returns information and statistics about the server in a format that is simple to parse by computers and easy to read by humans.</source>
          <target state="translated">&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;コンピュータで解析するシンプルで人間が読みやすい形式で、サーバーに関するコマンドが返す情報と統計。</target>
        </trans-unit>
        <trans-unit id="34c3a5fba12b1ed2508a72f81c29ed6c56b41d88" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; command reports about different memory-related issues that the Redis server experiences, and advises about possible remedies.</source>
          <target state="translated">&lt;a href=&quot;memory-doctor&quot;&gt;MEMORYドクター&lt;/a&gt;異なるメモリ関連の問題に関するコマンドのレポートは、Redisのサーバーの経験、とは、可能な救済策について助言こと。</target>
        </trans-unit>
        <trans-unit id="09f518db007c555b3fc51849cb715d5f37978149" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">&lt;a href=&quot;memory-help&quot;&gt;MEMORYヘルプ&lt;/a&gt;コマンドが異なるサブコマンドを記述する役立つテキストを返します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
