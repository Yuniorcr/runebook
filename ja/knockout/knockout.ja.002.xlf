<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="8f6eeb12ba06f0cf2cb646fe6069b9cdfdf92aea" translate="yes" xml:space="preserve">
          <source>The foreach binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item. This is especially useful for rendering lists or tables.</source>
          <target state="translated">foreach バインディングは、配列の各エントリに対してマークアップのセクションを複製し、そのマークアップの各コピーを対応する配列の項目にバインドします。これは、リストや表をレンダリングするときに特に便利です。</target>
        </trans-unit>
        <trans-unit id="9050b1bc9f4409b41e99062ebff1d7799e7e99bd" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s click event.</source>
          <target state="translated">要素のクリックイベントにバインドする関数。</target>
        </trans-unit>
        <trans-unit id="a9c17e8675f71dfc3ebda72d93dbff1f7d1f9956" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s submit event.</source>
          <target state="translated">要素の送信イベントにバインドする関数。</target>
        </trans-unit>
        <trans-unit id="8f7a07f601445346a49b60b0d4248c64175eae01" translate="yes" xml:space="preserve">
          <source>The hasFocus binding links a DOM element&amp;rsquo;s focus state with a viewmodel property. It is a two-way binding, so:</source>
          <target state="translated">hasFocusバインディングは、DOM要素のフォーカス状態をviewmodelプロパティにリンクします。これは双方向バインディングなので、次のようになります。</target>
        </trans-unit>
        <trans-unit id="05ab416911dfc8b9849c830b007486b93d0e2ffb" translate="yes" xml:space="preserve">
          <source>The html binding causes the associated DOM element to display the HTML specified by your parameter.</source>
          <target state="translated">html バインディングは、関連する DOM 要素にパラメータで指定された HTML を表示させます。</target>
        </trans-unit>
        <trans-unit id="2d7f5cb6c1b083bcb208b0a402a5e11e8bc45313" translate="yes" xml:space="preserve">
          <source>The if binding causes a section of markup to appear in your document (and to have its data-bind attributes applied), only if a specified expression evaluates to true (or a true-ish value such as a non-null object or nonempty string).</source>
          <target state="translated">if バインディングは、指定された式が真(または非 null オブジェクトや非空文字列などの真の値)と評価された場合にのみ、マークアップのセクションをドキュメントに表示させます(そして、そのデータバインド属性を適用させます)。</target>
        </trans-unit>
        <trans-unit id="d6048125b8510f2371496031c443eb75903bc261" translate="yes" xml:space="preserve">
          <source>The ifnot binding is exactly the same as &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;, except that it inverts the result of whatever expression you pass to it. For more details, see documentation for &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;.</source>
          <target state="translated">ifnotバインディングは&lt;a href=&quot;if-binding&quot;&gt;、if&lt;/a&gt;バインディングとまったく同じですが、渡した式の結果が反転される点が異なります。詳細については、&lt;a href=&quot;if-binding&quot;&gt;ifバインディングの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="7044aff700ff62379c0951bf28dff3be7f0d55a6" translate="yes" xml:space="preserve">
          <source>The ignore array you specify in the mapping options is combined with the default ignore array. You can manipulate this default array like this:</source>
          <target state="translated">マッピングオプションで指定した無視配列は、デフォルトの無視配列と結合されます。このデフォルト配列を次のように操作することができます。</target>
        </trans-unit>
        <trans-unit id="5eeaae6307cf68ec3980cc78a92bb6a6591a6d9f" translate="yes" xml:space="preserve">
          <source>The include array you specify in the mapping options is combined with the default include array, which by default only contains _destroy. You can manipulate this default array like this:</source>
          <target state="translated">マッピングオプションで指定したインクルード配列は、デフォルトのインクルード配列と結合されます。このデフォルトの配列を次のように操作することができます。</target>
        </trans-unit>
        <trans-unit id="b87740eb29c4e7b2de0e2d39f19f6cdb894afeb0" translate="yes" xml:space="preserve">
          <source>The index of the added array element</source>
          <target state="translated">追加された配列要素のインデックス</target>
        </trans-unit>
        <trans-unit id="153c8a10482991a921027e17eb883d2bb702edb1" translate="yes" xml:space="preserve">
          <source>The index of the moved array element</source>
          <target state="translated">移動された配列要素のインデックス</target>
        </trans-unit>
        <trans-unit id="29a08ceacbce3d40e8f8be71109fda7e68478a29" translate="yes" xml:space="preserve">
          <source>The index of the removed array element</source>
          <target state="translated">削除された配列要素のインデックス</target>
        </trans-unit>
        <trans-unit id="fb09d7316d9032eb6b50bdd38607e85a620a8ae9" translate="yes" xml:space="preserve">
          <source>The indexOf function returns the index of the first array item that equals your parameter. For example, myObservableArray.indexOf('Blah') will return the zero-based index of the first array entry that equals Blah, or the value -1 if no matching value was found.</source>
          <target state="translated">indexOf 関数は、パラメータに等しい最初の配列項目のインデックスを返します。例えば myObservableArray.indexOf('Brah')は、Brah に等しい最初の配列項目のゼロベースのインデックスを返します。</target>
        </trans-unit>
        <trans-unit id="69e9515a5f943cb16af4deed10ea470bb0ce01de" translate="yes" xml:space="preserve">
          <source>The inserted option element</source>
          <target state="translated">挿入されたオプション要素</target>
        </trans-unit>
        <trans-unit id="43d7b19d929050c04ef482f3719e22f56037aa52" translate="yes" xml:space="preserve">
          <source>The ko.ignoreDependencies function is available for scenarios where you want to execute code within a computed that should not contribute to that computed&amp;rsquo;s dependencies. This is often useful in a custom binding when you want to call code that may access observables, but you do not want to re-trigger the binding based on changes to those observables.</source>
          <target state="translated">ko.ignoreDependencies関数は、計算の依存関係に関与しない計算内でコードを実行するシナリオで使用できます。これは、オブザーバブルにアクセスする可能性のあるコードを呼び出したいが、オブザーバブルの変更に基づいてバインディングを再トリガーしたくない場合に、カスタムバインディングでしばしば役立ちます。</target>
        </trans-unit>
        <trans-unit id="2e70afc86097fdbd770f7db83c02acc1eb5189b8" translate="yes" xml:space="preserve">
          <source>The mapped observable array also exposes a mappedCreate function:</source>
          <target state="translated">マップされた観測可能な配列は、mappedCreate関数も公開しています。</target>
        </trans-unit>
        <trans-unit id="81bf44e52d770989f5c1e8f38818ebe340c1c206" translate="yes" xml:space="preserve">
          <source>The method option controls when notifications fire, and accepts the following values:</source>
          <target state="translated">メソッドオプションは、通知が発生するタイミングを制御し、以下の値を受け入れます。</target>
        </trans-unit>
        <trans-unit id="746cbdd45a1a4b3b4493f7c5d3603dfd8515ae49" translate="yes" xml:space="preserve">
          <source>The moved array element</source>
          <target state="translated">移動された配列要素</target>
        </trans-unit>
        <trans-unit id="a4d37fddd3510152eb42158703c05ddb3d9aef39" translate="yes" xml:space="preserve">
          <source>The object that you want to use as the context for binding descendant elements.</source>
          <target state="translated">子孫要素をバインドするためのコンテキストとして使用したいオブジェクト。</target>
        </trans-unit>
        <trans-unit id="cf7c2b7cc23dbce0f5f5998ff2b85f43ee703917" translate="yes" xml:space="preserve">
          <source>The observe array you specify in the mapping options is combined with the default observe array, which by default is empty. You can manipulate this default array like this:</source>
          <target state="translated">マッピングオプションで指定した observe 配列は、デフォルトの observe 配列と結合されます。このデフォルトの配列は次のように操作できます。</target>
        </trans-unit>
        <trans-unit id="40607abcaf26d4c21ed2b1d2dda932e347adb699" translate="yes" xml:space="preserve">
          <source>The only reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier.</source>
          <target state="translated">if の代わりに ifnot を使う唯一の理由は、単に好みの問題です:多くの開発者は、より整頓されて見えると感じています。</target>
        </trans-unit>
        <trans-unit id="6dd503e19f27964041b8e7f04ad17561a372b88b" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your create callback is a JavaScript object containing:</source>
          <target state="translated">create コールバックに与えられる options 引数には、JavaScript オブジェクトが含まれています。</target>
        </trans-unit>
        <trans-unit id="acc3ee61c9b4ee99cc1a57fa897a3b346a227831" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your update callback is a JavaScript object containing:</source>
          <target state="translated">update コールバックに与えられる options 引数は、JavaScript オブジェクトに含まれています。</target>
        </trans-unit>
        <trans-unit id="3f54901ff390f831f573f9eb13f6386cf4f2454e" translate="yes" xml:space="preserve">
          <source>The options binding controls what options should appear in a drop-down list (i.e., a &amp;lt;select&amp;gt; element) or multi-select list (e.g., &amp;lt;select size='6'&amp;gt;). This binding cannot be used with anything other than &amp;lt;select&amp;gt; elements.</source>
          <target state="translated">オプションバインディングは、ドロップダウンリスト（つまり、&amp;lt;select&amp;gt;要素）または複数選択リスト（たとえば、&amp;lt;select size = '6'&amp;gt;）に表示するオプションを制御します。このバインディングは、&amp;lt;select&amp;gt;要素以外では使用できません。</target>
        </trans-unit>
        <trans-unit id="162c8d94929e2437460193ade4632f67b6acd841" translate="yes" xml:space="preserve">
          <source>The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</source>
          <target state="translated">もう一つの巧妙なトリックは、宣言的バインディングが単純に計算された観測値として実装されていることです。つまり、もしバインディングが観測値の値を読んだ場合、そのバインディングはその観測値に依存するようになり、観測値が変化した場合にはバインディングが再評価されるようになります。</target>
        </trans-unit>
        <trans-unit id="d9c6da254c285296a2484119e3b32c7ea72d4244" translate="yes" xml:space="preserve">
          <source>The preceding view model code demonstrates the &lt;em&gt;single parameter syntax&lt;/em&gt; for initializing computed observables. See the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt; for the full list of available options.</source>
          <target state="translated">上記のビューモデルコードは、計算されたオブザーバブルを初期化するための&lt;em&gt;単一パラメーター構文&lt;/em&gt;を示してい&lt;em&gt;ます&lt;/em&gt;。使用可能なオプションの完全なリストについては、&lt;a href=&quot;computed-reference&quot;&gt;計算された観測可能なリファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1eba8a376d4e1fe3d6273f564007f1679bed7333" translate="yes" xml:space="preserve">
          <source>The problem is that this will cause &lt;em&gt;two&lt;/em&gt; Ajax requests: the first one will start when you update pageSize, and the second one will start immediately afterwards when you update pageIndex. This is a waste of bandwidth and server resources, and a source of unpredictable race conditions.</source>
          <target state="translated">問題は、これにより&lt;em&gt;2つの&lt;/em&gt; Ajaxリクエストが発生することです。最初のリクエストはpageSizeを更新したときに開始され、2番目のリクエストはpageIndexを更新した直後に開始されます。これは帯域幅とサーバーリソースの浪費であり、予測できない競合状態の原因となります。</target>
        </trans-unit>
        <trans-unit id="37cce1f32edc965597a382d568819abb832a7fd0" translate="yes" xml:space="preserve">
          <source>The quickest and most fun way to get started is by working through the &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;interactive tutorials&lt;/a&gt;. Once you&amp;rsquo;ve got to grips with the basics, explore the &lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;live examples&lt;/a&gt; and then have a go with it in your own project.</source>
          <target state="translated">始めるのに最も速くて楽しい方法は、&lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;インタラクティブなチュートリアルに&lt;/a&gt;取り組むことです。基本を理解してから、実際の&lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;例&lt;/a&gt;を調べて、自分のプロジェクトで実際に使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="ea006c24537a65a2ba624708630c7fc651c4642e" translate="yes" xml:space="preserve">
          <source>The rateLimit extender can be applied to any type of observable, including &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt; and &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;. The main use cases for rate-limiting are:</source>
          <target state="translated">rateLimitエクステンダーは、&lt;a href=&quot;observablearrays&quot;&gt;オブザーバブル配列&lt;/a&gt;や&lt;a href=&quot;computedobservables&quot;&gt;計算されたオブザーバブル&lt;/a&gt;など、あらゆるタイプのオブザーバブルに適用できます。レート制限の主な使用例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b7fb3e0a025185b71bc07f0984aae74db606ff1f" translate="yes" xml:space="preserve">
          <source>The reason you shouldn&amp;rsquo;t use a &lt;em&gt;pure&lt;/em&gt; computed if the evaluator has important side effects is simply that the evaluator will not run whenever the computed has no active subscribers (and so is sleeping). If it&amp;rsquo;s important for the evaluator to always run when dependencies change, use a &lt;a href=&quot;computedobservables&quot;&gt;regular computed&lt;/a&gt; instead.</source>
          <target state="translated">エバリュエーターに重要な副作用がある場合に&lt;em&gt;純粋な&lt;/em&gt;計算を使用するべきではない理由は、計算されたアクティブなサブスクライバーがない（およびスリープしている）ときは常にエバリュエーターが実行されないためです。依存関係が変更されたときに常にエバリュエーターを実行することが重要な場合は、代わりに&lt;a href=&quot;computedobservables&quot;&gt;通常の計算を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="43b68b7f8a261dc6fd71424b790107e7bba36eec" translate="yes" xml:space="preserve">
          <source>The removed array element</source>
          <target state="translated">削除された配列要素</target>
        </trans-unit>
        <trans-unit id="2b8edfced12b2275ac8a80e2f1255222d87df6ce" translate="yes" xml:space="preserve">
          <source>The rest of this page describes observableArray&amp;rsquo;s functions for reading and writing array information.</source>
          <target state="translated">このページの残りの部分では、配列情報を読み書きするためのobservableArrayの関数について説明します。</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">結果が出てきます。</target>
        </trans-unit>
        <trans-unit id="c8738ad7d358e2c69d84d24c2be85c7b85214872" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a constructor function, e.g.:</source>
          <target state="translated">返されるAMDモジュールオブジェクトは、ビューモデルで許可されている任意の形式にすることができます。つまり、コンストラクタ関数にすることができます。</target>
        </trans-unit>
        <trans-unit id="f55dc67e0ec57a14fa41387c5f86cbfbf87a4bdb" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a string of markup, e.g. fetched using &lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;require.js&amp;rsquo;s text plugin&lt;/a&gt;:</source>
          <target state="translated">返されるAMDモジュールオブジェクトは、viewmodelで許可されている任意の形式にすることができます。したがって、たとえば&lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;require.jsのテキストプラグイン&lt;/a&gt;を使用してフェッチした、マークアップの文字列にすることができます。</target>
        </trans-unit>
        <trans-unit id="97f1dd160bf2d7329f218a8a066037037fd32f5a" translate="yes" xml:space="preserve">
          <source>The second parameter to ko.computed (the bit where we passed this in the above example) defines the value of this when evaluating the computed observable. Without passing it in, it would not have been possible to refer to this.firstName() or this.lastName(). Experienced JavaScript coders will regard this as obvious, but if you&amp;rsquo;re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for this, but JavaScript does, because its functions themselves aren&amp;rsquo;t part of any object by default.)</source>
          <target state="translated">ko.computedの2番目のパラメーター（上記の例でこれを渡したビット）は、計算されたオブザーバブルを評価するときのこの値を定義します。これを渡さないと、this.firstName（）またはthis.lastName（）を参照することはできませんでした。経験豊富なJavaScriptプログラマーはこれを明白だと見なしますが、JavaScriptについてまだ理解している場合は、奇妙に思えるかもしれません。（C＃やJavaのような言語は、プログラマーがこれに値を設定することを決して期待していませんが、JavaScriptは、関数自体がデフォルトではオブジェクトの一部ではないため、そうします。）</target>
        </trans-unit>
        <trans-unit id="276174d892c3bad296aa46c527585e258f34f083" translate="yes" xml:space="preserve">
          <source>The selectedOptions binding controls which elements in a multi-select list are currently selected. This is intended to be used in conjunction with a &amp;lt;select&amp;gt; element and the options binding.</source>
          <target state="translated">selectedOptionsバインディングは、複数選択リストのどの要素が現在選択されているかを制御します。これは、&amp;lt;select&amp;gt;要素およびオプションバインディングと組み合わせて使用​​することを目的としています。</target>
        </trans-unit>
        <trans-unit id="8e064f117111b091febd6324a44a5d55fdf3a4a8" translate="yes" xml:space="preserve">
          <source>The server might return JSON data similar to the following:</source>
          <target state="translated">サーバーは以下のようなJSONデータを返すかもしれません。</target>
        </trans-unit>
        <trans-unit id="4b0df9758bfbf2068ff3ee480efe9e6ed9e4ab1a" translate="yes" xml:space="preserve">
          <source>The shorthand value can also be observable. In this case, if it changes, the component binding will &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;dispose&lt;/a&gt; the old component instance, and inject the newly-referenced component. Example:</source>
          <target state="translated">省略値も観察できる場合があります。それが変更された場合この場合は、結合成分は、あろう&lt;a href=&quot;#disposal-and-memory-management&quot;&gt;処分&lt;/a&gt;古いコンポーネントインスタンスを、新しく参照成分を注入します。例：</target>
        </trans-unit>
        <trans-unit id="049fd86ea4cbaee495bc01813f2e795073b4e49c" translate="yes" xml:space="preserve">
          <source>The slice function is the observableArray equivalent of the native JavaScript slice function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling myObservableArray.slice(...) is equivalent to calling the same method on the underlying array (i.e., myObservableArray().slice(...)).</source>
          <target state="translated">slice 関数はネイティブの JavaScript の slice 関数と同等の observableArray です (つまり、指定された開始インデックスから指定された終了インデックスまでの配列のエントリを返します)。myObservableArray.slice(...)を呼び出すことは、基になる配列に対して同じメソッドを呼び出すことと同じです (つまり、myObservableArray().slice(....)です)。</target>
        </trans-unit>
        <trans-unit id="51256b6bbeb757b7a3e53c454df3877ec1922f40" translate="yes" xml:space="preserve">
          <source>The standard method of defining a &lt;em&gt;pure&lt;/em&gt; computed observable is to use ko.pureComputed:</source>
          <target state="translated">&lt;em&gt;純粋に&lt;/em&gt;計算されたオブザーバブルを定義する標準的な方法は、ko.pureComputedを使用することです。</target>
        </trans-unit>
        <trans-unit id="47dbc61c148aa218c24d0f4919a72baba631be9b" translate="yes" xml:space="preserve">
          <source>The style binding adds or removes one or more style values to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative, or to set the width of a bar to match a numerical value that changes.</source>
          <target state="translated">スタイルバインディングは、関連する DOM 要素に 1 つ以上のスタイル値を追加または削除します。これは、ある値が負の値になったときに赤でハイライトしたり、変化する数値に合わせてバーの幅を設定したりするのに便利です。</target>
        </trans-unit>
        <trans-unit id="1ef276a741bad031dcded61f8068495eb09f16a8" translate="yes" xml:space="preserve">
          <source>The submit binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is submitted. Typically you will only want to use this on form elements.</source>
          <target state="translated">submit バインディングはイベントハンドラを追加し、関連する DOM 要素が送信されたときに選択した JavaScript 関数が呼び出されるようにします。通常、これを使いたいのはフォーム要素のみです。</target>
        </trans-unit>
        <trans-unit id="f2b3c41c3803b6fdf7bb3dcb97584e848e98e1cc" translate="yes" xml:space="preserve">
          <source>The subscribe function accepts three parameters: callback is the function that is called whenever the notification happens, target (optional) defines the value of this in the callback function, and event (optional; default is &quot;change&quot;) is the name of the event to receive notification for.</source>
          <target state="translated">subscribe関数は3つのパラメータを受け付けます:callbackは通知が発生するたびに呼び出される関数、target(オプション)はコールバック関数でこの値を定義します、そしてevent(オプション。デフォルトは &quot;change &quot;です)は通知を受け取るイベントの名前です。</target>
        </trans-unit>
        <trans-unit id="016b4f1bb0fd10e4b91ab01327aa8086f3b0e070" translate="yes" xml:space="preserve">
          <source>The subscribe function is how many parts of KO work internally. Most of the time you don&amp;rsquo;t need to use this, because the built-in bindings and templating system take care of managing subscriptions.</source>
          <target state="translated">サブスクライブ機能は、KOの内部でいくつの部分が機能するかです。組み込みのバインディングとテンプレートシステムがサブスクリプションの管理を処理するため、ほとんどの場合、これを使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="046a68fc34463623e0087f15d2cbe37f0a99e3bf" translate="yes" xml:space="preserve">
          <source>The syntax is more convenient. To call KO&amp;rsquo;s push method, just write myObservableArray.push(...). This is slightly nicer than calling the underlying array&amp;rsquo;s push method by writing myObservableArray().push(...).</source>
          <target state="translated">構文はより便利です。 KOのpushメソッドを呼び出すには、myObservableArray.push（...）と記述します。これは、myObservableArray（）。push（...）を記述して基になる配列のpushメソッドを呼び出すよりも少し優れています。</target>
        </trans-unit>
        <trans-unit id="bd48513a1e40433618e2382185d34142f3816b64" translate="yes" xml:space="preserve">
          <source>The template binding populates the associated DOM element with the results of rendering a template. Templates are a simple and convenient way to build sophisticated UI structures - possibly with repeating or nested blocks - as a function of your view model data.</source>
          <target state="translated">テンプレートバインディングは、関連する DOM 要素にテンプレートをレンダリングした結果を表示します。テンプレートは、洗練された UI 構造を構築するためのシンプルで便利な方法です。</target>
        </trans-unit>
        <trans-unit id="c4ef5b8434eccb8c5846957e191b2353bcb8c255" translate="yes" xml:space="preserve">
          <source>The templateConfig value is simply the template property from any componentConfig object. For example, it may contain &quot;some markup&quot; or {element:&quot;someId&quot;} or a custom format such as {loadFromUrl:&quot;someUrl.html&quot;}.</source>
          <target state="translated">templateConfigの値は、任意のcomponentConfigオブジェクトのテンプレート・プロパティです。例えば、&quot;some markup &quot;や{element:&quot;someId&quot;}を含んでいたり、{loadFromUrl:&quot;someUrl.html&quot;}のようなカスタムフォーマットを含んでいたりします。</target>
        </trans-unit>
        <trans-unit id="c0cfb1138db7edd7758273fad1e4a3a38ac65bd9" translate="yes" xml:space="preserve">
          <source>The text binding causes the associated DOM element to display the text value of your parameter.</source>
          <target state="translated">テキストバインディングは、関連する DOM 要素にパラメータのテキスト値を表示させます。</target>
        </trans-unit>
        <trans-unit id="583c97cdc5485ae99a9042d6a2aa5ca3bd365673" translate="yes" xml:space="preserve">
          <source>The textInput binding is specifically designed to handle a wide range of browser quirks, to provide consistent and immediate model updates even in response to unusual text entry methods.</source>
          <target state="translated">textInput バインディングは、さまざまなブラウザの癖を処理するように特別に設計されており、通常とは異なるテキスト入力方法に対応しても、一貫性のある即時のモデル更新を提供します。</target>
        </trans-unit>
        <trans-unit id="98c7d7411d6cd38a5fa10c5e758660c706e016b3" translate="yes" xml:space="preserve">
          <source>The textInput binding links a text box (&amp;lt;input&amp;gt;) or text area (&amp;lt;textarea&amp;gt;) with a viewmodel property, providing two-way updates between the viewmodel property and the element&amp;rsquo;s value. Unlike the value binding, textInput provides instant updates from the DOM for all types of user input, including autocomplete, drag-and-drop, and clipboard events.</source>
          <target state="translated">textInputバインディングは、テキストボックス（&amp;lt;input&amp;gt;）またはテキスト領域（&amp;lt;textarea&amp;gt;）をviewmodelプロパティにリンクし、viewmodelプロパティと要素の値の間の双方向の更新を提供します。値バインディングとは異なり、textInputは、オートコンプリート、ドラッグアンドドロップ、クリップボードイベントなど、すべてのタイプのユーザー入力をDOMから即座に更新します。</target>
        </trans-unit>
        <trans-unit id="c97b5f8151ffd9c3cb4b842df2c6ab37add94e04" translate="yes" xml:space="preserve">
          <source>The uniqueName binding ensures that the associated DOM element has a nonempty name attribute. If the DOM element did not have a name attribute, this binding gives it one and sets it to some unique string value.</source>
          <target state="translated">uniqueName バインディングは、関連付けられた DOM 要素が空でない name 属性を持つことを保証します。DOM 要素が name 属性を持たない場合、このバインディングはそれを与え、それをユニークな文字列の値に設定します。</target>
        </trans-unit>
        <trans-unit id="8ad9163f8b350f9acb1cee05eb1ef6108edde552" translate="yes" xml:space="preserve">
          <source>The value binding links the associated DOM element&amp;rsquo;s value with a property on your view model. This is typically useful with form elements such as &amp;lt;input&amp;gt;, &amp;lt;select&amp;gt; and &amp;lt;textarea&amp;gt;.</source>
          <target state="translated">値バインディングは、関連するDOM要素の値をビューモデルのプロパティにリンクします。これは通常、&amp;lt;input&amp;gt;、&amp;lt;select&amp;gt;、&amp;lt;textarea&amp;gt;などのフォーム要素で役立ちます。</target>
        </trans-unit>
        <trans-unit id="9387180a42aa7a17b48448a72d7472f68cb9f230" translate="yes" xml:space="preserve">
          <source>The value of the computed observable shouldn&amp;rsquo;t vary based on the number of evaluations or other &amp;ldquo;hidden&amp;rdquo; information. Its value should be based solely on the values of other observables in the application, which for the pure function definition, are considered its parameters.</source>
          <target state="translated">計算されたオブザーバブルの値は、評価の数やその他の「隠された」情報に基づいて変化してはなりません。その値は、アプリケーション内の他のオブザーバブルの値のみに基づいている必要があり、純粋な関数の定義では、そのパラメーターと見なされます。</target>
        </trans-unit>
        <trans-unit id="14eb51c71508d408d23b29aa7938c5e57a2a7c2e" translate="yes" xml:space="preserve">
          <source>The value you assign should be an array (or observable array). The &amp;lt;select&amp;gt; element will then display one item for each item in your array.</source>
          <target state="translated">割り当てる値は、配列（または監視可能な配列）である必要があります。&amp;lt;select&amp;gt;要素は、配列内のアイテムごとに1つのアイテムを表示します。</target>
        </trans-unit>
        <trans-unit id="fe79d0c6fc554a50ffe91a6318c3a95369cb8cac" translate="yes" xml:space="preserve">
          <source>The viewModelConfig value is simply the viewModel property from any componentConfig object. For example, it may be a constructor function, or a custom format such as {myViewModelType:'Something',options:{}}.</source>
          <target state="translated">viewModelConfig の値は、任意の componentConfig オブジェクトからの単純な viewModel プロパティです。例えば、コンストラクタ関数や {myViewModelType:'Something',options:{}}のようなカスタムフォーマットなどです。</target>
        </trans-unit>
        <trans-unit id="ff29c13e73c111a3106d90b4abd24a7404d96b9c" translate="yes" xml:space="preserve">
          <source>The visible binding causes the associated DOM element to become hidden or visible according to the value you pass to the binding.</source>
          <target state="translated">visible binding は、バインディングに渡した値に応じて、関連する DOM 要素を hidden または visible にします。</target>
        </trans-unit>
        <trans-unit id="3dcca4073da45812cd05022db33c86a1c7087f8e" translate="yes" xml:space="preserve">
          <source>The whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That&amp;rsquo;s what many of KO&amp;rsquo;s built-in bindings do internally. So, when you wrote data-bind=&quot;text: personName&quot;, the text binding registered itself to be notified when personName changes (assuming it&amp;rsquo;s an observable value, which it is now).</source>
          <target state="translated">オブザーバブルの重要なポイントは、オブザーバブルを監視できることです。つまり、他のコードは、変更を通知する必要があると言うことができます。これが、KOの組み込みバインディングの多くが内部で行うことです。そのため、data-bind = &quot;text：personName&quot;を記述した場合、personNameが変更されたときに通知されるようにテキストバインディング自体が登録されます（これは現在の観測可能な値であると想定しています）。</target>
        </trans-unit>
        <trans-unit id="08840010b83b1dfd4295b6784268bddb1bef073c" translate="yes" xml:space="preserve">
          <source>The with binding creates a new &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, so that descendant elements are bound in the context of a specified object.</source>
          <target state="translated">withバインディングは新しい&lt;a href=&quot;binding-context&quot;&gt;バインディングコンテキストを&lt;/a&gt;作成するため、子孫要素は指定されたオブジェクトのコンテキストでバインドされます。</target>
        </trans-unit>
        <trans-unit id="524ea84b41e8a5893953b0074485b90cf1eff52f" translate="yes" xml:space="preserve">
          <source>The with binding will dynamically add or remove descendant elements depending on whether the associated value is null/undefined or not</source>
          <target state="translated">with バインディングは、関連付けられた値が null/undefined かどうかに応じて、子孫要素を動的に追加または削除します。</target>
        </trans-unit>
        <trans-unit id="7e032d672f4e300f7eeb1bbf7504868ad1577af8" translate="yes" xml:space="preserve">
          <source>Then, with this componentConfig object, calls each of the registered loaders&amp;rsquo; loadComponent functions in turn, until the first one supplies a non-null template/createViewModel pair.</source>
          <target state="translated">次に、このcomponentConfigオブジェクトを使用して、最初の関数がnull以外のテンプレートとcreateViewModelのペアを提供するまで、登録されているローダーの各loadComponent関数を順番に呼び出します。</target>
        </trans-unit>
        <trans-unit id="af5fd56709b842c37eecfef0bd5fee58c13743cd" translate="yes" xml:space="preserve">
          <source>Then, you can use jQuery.tmpl syntax in your templates. For example,</source>
          <target state="translated">そして、テンプレートの中でjQuery.tmplの構文を使用します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1da7ec95f9f3bd6c9bcf839432044e2340b7b515" translate="yes" xml:space="preserve">
          <source>Then, your custom function will become available on all values of that type created from that point onwards.</source>
          <target state="translated">そうすると、その時点から作成されたその型のすべての値で、あなたのカスタム関数が利用可能になります。</target>
        </trans-unit>
        <trans-unit id="cd22bd8141f2da85ed82fbfb3975c4c5b8fe254b" translate="yes" xml:space="preserve">
          <source>There are two main ways of using templates:</source>
          <target state="translated">テンプレートの使い方は大きく分けて2つあります。</target>
        </trans-unit>
        <trans-unit id="88cee14671dcbec805136df550f741e76f165562" translate="yes" xml:space="preserve">
          <source>There are two ways to use the component binding:</source>
          <target state="translated">コンポーネントバインディングを使用する方法は2つあります。</target>
        </trans-unit>
        <trans-unit id="624acfe0a4456c96d3f7eb19804d2c53591e62dd" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a popular convention that avoids the need to track this altogether: if your viewmodel&amp;rsquo;s constructor copies a reference to this into a different variable (traditionally called self), you can then use self throughout your viewmodel and don&amp;rsquo;t have to worry about it being redefined to refer to something else. For example:</source>
          <target state="translated">これを完全に追跡する必要を回避する一般的な慣習があります：ビューモデルのコンストラクターがこれへの参照を別の変数（伝統的にselfと呼ばれます）にコピーする場合、ビューモデル全体でselfを使用でき、そのことを心配する必要はありません別のものを参照するように再定義されました。例えば：</target>
        </trans-unit>
        <trans-unit id="90d3a6cc255f075aee8c59ce311e982c597bc606" translate="yes" xml:space="preserve">
          <source>These examples show that the value can be just about any JavaScript expression. Even the comma is fine when it&amp;rsquo;s enclosed in braces, brackets, or parentheses. When the value is an object literal, the object&amp;rsquo;s property names must be valid JavaScript identifiers or be enclosed in quotes. If the binding value is an invalid expression or references an unknown variable, Knockout will output an error and stop processing bindings.</source>
          <target state="translated">これらの例は、値がほぼすべてのJavaScript式であることを示しています。中括弧、大括弧、または括弧で囲まれているコンマでも問題ありません。値がオブジェクトリテラルの場合、オブジェクトのプロパティ名は有効なJavaScript識別子であるか、引用符で囲む必要があります。バインディング値が無効な式であるか、不明な変数を参照している場合、Knockoutはエラーを出力し、バインディングの処理を停止します。</target>
        </trans-unit>
        <trans-unit id="1f3eb587b2006b4e40fc88eeb1c957f9aa6b49ff" translate="yes" xml:space="preserve">
          <source>These facilities are typically useful only in advanced scenarios, for example when your computed observable&amp;rsquo;s primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.</source>
          <target state="translated">これらの機能は通常、高度なシナリオでのみ役立ちます。たとえば、計算されたオブザーバブルの主な目的がそのエバリュエーター中に何らかの副作用をトリガーすることであり、最初の実行中にのみ、または少なくとも1つの依存関係（したがって、将来的に再評価される可能性があります）。ほとんどの計算されたプロパティは、それらが以前に評価されたかどうか、またはそれらがいくつの依存関係を持っているかを気にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="07ffcc399a3f0a54ad9c2648a23eb7d7ec9c57ef" translate="yes" xml:space="preserve">
          <source>These helper functions can be used in event handlers that are attached unobtrusively using something like jQuery&amp;rsquo;s bind or click. The above function could be attached to each link with a remove class like:</source>
          <target state="translated">これらのヘルパー関数は、jQueryのバインドやクリックなどを使用して控えめに接続されているイベントハンドラーで使用できます。上記の関数は、次のような削除クラスを使用して各リンクにアタッチできます。</target>
        </trans-unit>
        <trans-unit id="8797502eb386f1c824a0aa629bcaa04c161fe178" translate="yes" xml:space="preserve">
          <source>They are functionally equivalent to the regular ko.observableArray functions, but can do things based on the key of the object. For example, this would work:</source>
          <target state="translated">これらは通常の ko.observableArray 関数と機能的には同等ですが、オブジェクトのキーに基づいた処理を行うことができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="18962a789df3d7447e4daeeed751e58a433346fb" translate="yes" xml:space="preserve">
          <source>They work on all targeted browsers. (For example, the native JavaScript indexOf function doesn&amp;rsquo;t work on IE 8 or earlier, but KO&amp;rsquo;s indexOf works everywhere.)</source>
          <target state="translated">それらはすべてのターゲットブラウザで動作します。（たとえば、ネイティブJavaScript indexOf関数はIE 8以前では機能しませんが、KOのindexOfはどこでも機能します。）</target>
        </trans-unit>
        <trans-unit id="b23e367c7cba12e6cfcd6e2cb9f9d24753504d55" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;special list&amp;rdquo; example does nothing more than insert a heading above each list item. But the same technique can be used to create sophisticated grids, dialogs, tab sets, and so on, since all that is needed for such UI elements is common UI markup (e.g., to define the grid or dialog&amp;rsquo;s heading and borders) wrapped around arbitrary supplied markup.</source>
          <target state="translated">この「特別なリスト」の例では、各リスト項目の上に見出しを挿入するだけです。しかし、同じ手法を使用して、洗練されたグリッド、ダイアログ、タブセットなどを作成できます。そのようなUI要素に必要なのは、任意の周りにラップされた一般的なUIマークアップ（たとえば、グリッドまたはダイアログの見出しと境界線を定義する）だけだからです。提供されるマークアップ。</target>
        </trans-unit>
        <trans-unit id="5fac83af14640609f6eb7dbff17d1de27fd0b429" translate="yes" xml:space="preserve">
          <source>This ability is especially useful when paired with &lt;a href=&quot;binding-preprocessing&quot;&gt;binding preprocessing&lt;/a&gt;, which can assign a default value for a binding.</source>
          <target state="translated">この機能は、バインディングのデフォルト値を割り当てることができる&lt;a href=&quot;binding-preprocessing&quot;&gt;バインディング前処理&lt;/a&gt;と組み合わせると特に便利です。</target>
        </trans-unit>
        <trans-unit id="bcf4fe4f919e5f9a307b9e9f04eda05c1f8836ad" translate="yes" xml:space="preserve">
          <source>This allows for a very modern, &lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;WebComponents&lt;/a&gt;-like way to organize your code, while retaining support for even very old browsers (see &lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;custom elements and IE 6 to 8&lt;/a&gt;).</source>
          <target state="translated">これにより、非常に&lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;古いWeb&lt;/a&gt;ブラウザ（&lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;カスタム要素とIE 6〜8を&lt;/a&gt;参照）のサポートを維持しながら、コードを整理する非常に最新のWebComponentsのような方法が可能になります。</target>
        </trans-unit>
        <trans-unit id="1eb5e5d48d4ea01bc727416a9600946df475abd7" translate="yes" xml:space="preserve">
          <source>This automatically creates observable properties for each of the properties on data. Then, every time you receive new data from the server, you can update all the properties on viewModel in one step by calling the ko.mapping.fromJS function again:</source>
          <target state="translated">これにより、データ上のそれぞれのプロパティに対して観測可能なプロパティが自動的に作成されます。そして、サーバーから新しいデータを受け取るたびに、再度 ko.mapping.fromJS 関数を呼び出すことで、viewModel 上のすべてのプロパティをワンステップで更新することができます。</target>
        </trans-unit>
        <trans-unit id="50dfddf19ae9e5c9f7164b96b3b17f0f1a097c05" translate="yes" xml:space="preserve">
          <source>This contains a mix of observables, computed observables, observable arrays, and plain values. You can convert it to a JSON string suitable for sending to the server using ko.toJSON as follows:</source>
          <target state="translated">これには、観測値、計算された観測値、観測可能な配列、そしてプレーンな値が混在しています。以下のように ko.toJSON を使ってサーバに送信するのに適した JSON 文字列に変換することができます。</target>
        </trans-unit>
        <trans-unit id="6e7f5312e7a860e5c84608a61ebd0ff4a1fe6f16" translate="yes" xml:space="preserve">
          <source>This double-unwrapping would be ugly, inconvenient, and unexpected, so Knockout automatically sets up the generated computed property (params.myExpr) to unwrap its value for you. That is, the component can read params.myExpr() to get the value of whichever observable has been selected (observable1 or observable2), without the need for double-unwrapping.</source>
          <target state="translated">この二重アンラッピングは、不便で不便で予期せぬことなので、Knockoutは自動的に生成された計算プロパティ(params.myExpr)の値をアンラッピングするように設定しています。つまり、コンポーネントは params.myExpr()を読み込んで、選択されたオブザブル(observable1 または observable2)の値を取得することができます。</target>
        </trans-unit>
        <trans-unit id="835c1c20db465de114b6ecf00cf935dce609fbad" translate="yes" xml:space="preserve">
          <source>This easy to do: just add an additional parameter with name optionsCaption, with its value being a string to display. For example:</source>
          <target state="translated">これは簡単です:optionsCaption という名前の追加パラメータを追加し、その値には表示する文字列を指定します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0f6f4ddca2613356e2726599ab4684e2eaa1b28b" translate="yes" xml:space="preserve">
          <source>This example creates an extender that allows an observable to be marked as required. Instead of returning a new object, this extender simply adds additional sub-observables to the existing observable. Since observables are functions, they can actually have their own properties. However, when the view model is converted to JSON, the sub-observables will be dropped and we will simply be left with the value of our actual observable. This is a nice way to add additional functionality that is only relevant for the UI and does not need to be sent back to the server.</source>
          <target state="translated">この例では、必要に応じて観測可能なオブジェクトをマークできるようにするエクステンダーを作成します。このエクステンダーは新しいオブジェクトを返すのではなく、既存のobservableにサブobservableを追加するだけです。オブザーバブルは関数なので、実際にはそれ自身のプロパティを持つことができます。しかし、ビューモデルがJSONに変換されると、サブオブザーバブルは削除され、実際のオブザーバブルの値だけが残ることになります。これは、UIに関連する機能だけを追加して、サーバーに送信する必要のない機能を追加するための良い方法です。</target>
        </trans-unit>
        <trans-unit id="65ecaa594cf97a786d25b11561c62fb053ea502c" translate="yes" xml:space="preserve">
          <source>This example creates an extender that forces writes to an observable to be numeric rounded to a configurable level of precision. In this case, the extender will return a new writable computed observable that will sit in front of the real observable intercepting writes.</source>
          <target state="translated">この例では、observableへの書き込みを数値的に丸めて精度を設定できるようにするエクステンダーを作成しています。この場合、エクステンダーは新しい書き込み可能な計算されたobservableを返し、書き込みを傍受する実際のobservableの前に置かれます。</target>
        </trans-unit>
        <trans-unit id="7bc47da371a683aaa1120d6ec7b6e5389241143d" translate="yes" xml:space="preserve">
          <source>This example declares a component, and then injects two instances of it into a view. See the source code below.</source>
          <target state="translated">この例では、コンポーネントを宣言し、そのコンポーネントの 2 つのインスタンスをビューに注入しています。以下のソースコードを参照してください。</target>
        </trans-unit>
        <trans-unit id="579304ee7faef55eabaa909aa4e1dc99ece5d462" translate="yes" xml:space="preserve">
          <source>This example shows &amp;ldquo;add&amp;rdquo; and &amp;ldquo;remove&amp;rdquo; links on multiple levels of parents and children with a single handler attached unobtrusively for each type of link.</source>
          <target state="translated">この例は、リンクのタイプごとに単一のハンドラーが目立たないように接続された、複数レベルの親と子の「追加」および「削除」リンクを示しています。</target>
        </trans-unit>
        <trans-unit id="e7d030e3401c09158dec61fedd6b90ab7f45ab5c" translate="yes" xml:space="preserve">
          <source>This example shows that the if binding can dynamically add and remove sections of markup as observable values change.</source>
          <target state="translated">この例では、if バインディングが、観測可能な値の変化に応じてマークアップのセクションを動的に追加したり削除したりできることを示しています。</target>
        </trans-unit>
        <trans-unit id="969c85da8be854a1b6c00abcfd3856c63f7a00ff" translate="yes" xml:space="preserve">
          <source>This example simply displays a message if the textbox currently has focus, and uses a button to show that you can trigger focus programmatically.</source>
          <target state="translated">この例では、テキストボックスに現在フォーカスがある場合にメッセージを表示し、ボタンを使用してプログラムでフォーカスをトリガーできることを示しています。</target>
        </trans-unit>
        <trans-unit id="d2a7a601d44439dd914189703f94ab3cea4924d9" translate="yes" xml:space="preserve">
          <source>This example uses foreach to produce a read-only table with a row for each array entry.</source>
          <target state="translated">この例では、foreach を使用して、各配列エントリに対して行を持つ読み取り専用のテーブルを作成しています。</target>
        </trans-unit>
        <trans-unit id="d0a6677ca47c0e8f5d5df08e50b25d599f696a47" translate="yes" xml:space="preserve">
          <source>This functionality applies to errors in the following contexts:</source>
          <target state="translated">この機能は、以下のコンテキストでのエラーに適用されます。</target>
        </trans-unit>
        <trans-unit id="da0d1aeda4e842abb4270aaff5c44f9cf5e0cbec" translate="yes" xml:space="preserve">
          <source>This gives the same result as embedding an anonymous template directly inside the element to which you use foreach, i.e.:</source>
          <target state="translated">これは、foreachを使用する要素の中に匿名テンプレートを直接埋め込むのと同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="66096e1d294700a561ed7c38d1667f6e3e659ad9" translate="yes" xml:space="preserve">
          <source>This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object {id:1,name:'Alicw'} does not equal {id:1,name:'Alice'} it thinks that the &lt;em&gt;entire&lt;/em&gt; child needs to be removed and replaced by a new one.</source>
          <target state="translated">これは、デフォルトでは、マッピングプラグインが配列内の2つのオブジェクトを単に比較するために発生します。また、JavaScriptではオブジェクト{id：1、name： 'Alicw'}が{id：1、name： 'Alice'}と等しくないため&lt;em&gt;、&lt;/em&gt;子&lt;em&gt;全体を&lt;/em&gt;削除して新しい子に置き換える必要があると考えています。</target>
        </trans-unit>
        <trans-unit id="e2d595e57fa825c7d94c939731588cee9344439f" translate="yes" xml:space="preserve">
          <source>This has exactly the same result, without requiring the priceRating computed observable.</source>
          <target state="translated">これは、観測可能な計算されたpriceRatingを必要とせずに、全く同じ結果をもたらします。</target>
        </trans-unit>
        <trans-unit id="3077765de26211664ba2efe22cb2b9cd04fb4caa" translate="yes" xml:space="preserve">
          <source>This interactive example demonstrates that:</source>
          <target state="translated">このインタラクティブな例では、次のことを示しています。</target>
        </trans-unit>
        <trans-unit id="5643babfcf6893a24373debdbe07dfee55a51dd1" translate="yes" xml:space="preserve">
          <source>This is a limitation of the HTML specification and is outside the scope of what Knockout can control. HTML parsers, following the HTML specification, &lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;ignore any self-closing slashes&lt;/a&gt; (except on a small number of special &amp;ldquo;foreign elements&amp;rdquo;, which are hardcoded into the parser). HTML is not the same as XML.</source>
          <target state="translated">これはHTML仕様の制限であり、Knockoutが制御できる範囲外です。HTML仕様に従い、HTMLパーサーは&lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;自己終了スラッシュを無視します&lt;/a&gt;（パーサーにハードコードされている少数の特別な「外部要素」を除く）。HTMLはXMLと同じではありません。</target>
        </trans-unit>
        <trans-unit id="f78bc1ff46d4250e923789d55c729bf459efb257" translate="yes" xml:space="preserve">
          <source>This is an array representing all of the parent view models:</source>
          <target state="translated">これは、すべての親ビューモデルを表す配列です。</target>
        </trans-unit>
        <trans-unit id="74000dd6220d8d962de61f08d4444c669e765e23" translate="yes" xml:space="preserve">
          <source>This is how you can pass properties from a parent viewmodel to a child component. If the properties themselves are observable, then the parent viewmodel will be able to observe and react to any new values inserted into them by the child component.</source>
          <target state="translated">これは、親ビューモデルから子コンポーネントにプロパティを渡す方法です。プロパティ自体が観測可能であれば、親ビューモデルは子コンポーネントによってプロパティに挿入された新しい値を観測し、それに反応することができます。</target>
        </trans-unit>
        <trans-unit id="6a2bb49027f1ab6742f350a8ffba17b3b3c61fdd" translate="yes" xml:space="preserve">
          <source>This is mainly useful if you have multiple levels of nested foreach blocks, because it gives you an unambiguous way to refer to any named item declared at a higher level in the hierarchy. Here&amp;rsquo;s a complete example, showing how season can be referenced while rendering a month:</source>
          <target state="translated">階層の上位レベルで宣言された名前付きアイテムを参照する明確な方法を提供するため、ネストされたforeachブロックのレベルが複数ある場合、これは主に役立ちます。以下は完全な例で、月をレンダリングするときにシーズンを参照する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="8cfd1c39aecebfca1259dc459499bea32121ecc1" translate="yes" xml:space="preserve">
          <source>This is mainly useful when you&amp;rsquo;re fetching the markup from somewhere programmatically (e.g., &lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD - see below&lt;/a&gt;), or as a build system output that packages components for distribution, since it&amp;rsquo;s not very convenient to manually edit HTML as a JavaScript string literal.</source>
          <target state="translated">これは主に、プログラムでどこかからマークアップをフェッチする場合に便利です（たとえば、&lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD-下記を参照&lt;/a&gt;）、または配布用のコンポーネントをパッケージ化するビルドシステム出力として。HTMLをJavaScript文字列リテラルとして手動で編集するのはあまり便利ではないためです。</target>
        </trans-unit>
        <trans-unit id="456a8a825127f0754a6b3c29d2b3b6a2b87ce4f4" translate="yes" xml:space="preserve">
          <source>This is the element DOM object (for virtual elements, it will be the comment DOM object) of the current binding. This can be useful if a binding needs to access an attribute of the current element. Example:</source>
          <target state="translated">これは、現在のバインディングの要素 DOM オブジェクト(仮想要素の場合はコメント DOM オブジェクト)です。これは、バインディングが現在の要素の属性にアクセスする必要がある場合に便利です。例を示します。</target>
        </trans-unit>
        <trans-unit id="a03a71e0074cf075a1a1081583cac59ac61756fe" translate="yes" xml:space="preserve">
          <source>This is the exact opposite of the &lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; example, in that here the first and last names are not editable, but the combined full name is editable.</source>
          <target state="translated">これは、&lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello Worldの&lt;/a&gt;例の正反対です。ここでは、姓と名は編集できませんが、結合されたフルネームは編集できます。</target>
        </trans-unit>
        <trans-unit id="173aba90415cf038a5ca44929194616b39af11e1" translate="yes" xml:space="preserve">
          <source>This is the main view model object in the root context, i.e., the topmost parent context. It&amp;rsquo;s usually the object that was passed to ko.applyBindings. It is equivalent to $parents[$parents.length - 1].</source>
          <target state="translated">これは、ルートコンテキスト、つまり最上位の親コンテキストのメインビューモデルオブジェクトです。通常、ko.applyBindingsに渡されたオブジェクトです。$ parents [$ parents.length-1]と同等です。</target>
        </trans-unit>
        <trans-unit id="6240fa458446de4cb8e845cb681191b4719f6c7d" translate="yes" xml:space="preserve">
          <source>This is the mirror image of the enable binding. For more information, see &lt;a href=&quot;enable-binding&quot;&gt;documentation for the enable binding&lt;/a&gt;, because disable works in exactly the same way except that it negates whatever parameter you pass to it.</source>
          <target state="translated">これは、バインディングの有効化のミラーイメージです。詳細について&lt;a href=&quot;enable-binding&quot;&gt;は、enable bindingのドキュメントを&lt;/a&gt;ご覧ください。無効化は、渡したパラメーターを無効にすることを除いて、まったく同じように機能するためです。</target>
        </trans-unit>
        <trans-unit id="29889de6133ca2a7946ef92ef09c7a021e5d70d0" translate="yes" xml:space="preserve">
          <source>This is the raw view model value in the current context. Usually this will be the same as $data, but if the view model provided to Knockout is wrapped in an observable, $data will be the unwrapped view model, and $rawData will be the observable itself.</source>
          <target state="translated">これは、現在のコンテキストにおける生のビューモデルの値です。通常は $data と同じ値になりますが、Knockout に提供されるビューモデルがオブザーバブルでラップされている場合は、 $data がラップされていないビューモデル、$rawData がオブザーバブルそのものになります。</target>
        </trans-unit>
        <trans-unit id="aaaecc06d2965d5100af141ea778d358bd106f1b" translate="yes" xml:space="preserve">
          <source>This is the view model object in the current context. In the root context, $data and $root are equivalent. Inside a nested binding context, this parameter will be set to the current data item (e.g., inside a with: person binding, $data will be set to person). $data is useful when you want to reference the viewmodel itself, rather than a property on the viewmodel. Example:</source>
          <target state="translated">これは、現在のコンテキストにおけるビューモデルオブジェクトです。ルートコンテキストでは、$data と $root は同等です。入れ子になっているバインディングコンテキスト内では、このパラメータは現在のデータ項目に設定されます (例えば with:person バインディング内では、$data は person に設定されます)。dataは、ビューモデルのプロパティではなくビューモデル自体を参照したい場合に便利です。例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="1425847fb23b8c40942166dc9b9ab9eb5c03913c" translate="yes" xml:space="preserve">
          <source>This is the view model object in the parent context, the one immeditely outside the current context. In the root context, this is undefined. Example:</source>
          <target state="translated">これは、親コンテキスト内のビューモデルオブジェクトであり、現在のコンテキストの外にあるものです。ルートコンテキストでは、これは未定義です。例を示します。</target>
        </trans-unit>
        <trans-unit id="0a75f1ff617db05b67a63f53671406646513047f" translate="yes" xml:space="preserve">
          <source>This is the zero-based index of the current array entry being rendered by a foreach binding. Unlike the other binding context properties, $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="translated">これは、foreach バインディングによってレンダリングされる現在の配列エントリのゼロベースのインデックスです。他のバインディングコンテキストプロパティとは異なり、 $index は観測可能なプロパティであり、アイテムのインデックスが変更されるたびに更新されます (例えば、アイテムが配列に追加されたり削除されたりした場合)。</target>
        </trans-unit>
        <trans-unit id="c4b96d23cc0b80a5d0c6fab427a1e7b9868d5d79" translate="yes" xml:space="preserve">
          <source>This is useful if you want to build components that represent &amp;ldquo;container&amp;rdquo; UI elements, such as grids, lists, dialogs, or tab sets, which need to inject and bind arbitrary markup into a common structure. See &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;a complete example for custom elements&lt;/a&gt;, which also works without custom elements using the syntax shown above.</source>
          <target state="translated">これは、グリッド、リスト、ダイアログ、タブセットなど、任意のマークアップを挿入して共通の構造にバインドする必要がある「コンテナ」UI要素を表すコンポーネントを構築する場合に役立ちます。&lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;カスタム要素の完全な例を&lt;/a&gt;参照してください。これは、上記の構文を使用してカスタム要素なしでも機能します。</target>
        </trans-unit>
        <trans-unit id="5ba543ff4dde01f5c7ccc4e0eadd6fedd604bb14" translate="yes" xml:space="preserve">
          <source>This is useful if you&amp;rsquo;re building sophisticated forms in which editable elements appear dynamically, and you would like to control where the user should start typing, or respond to the location of the caret.</source>
          <target state="translated">これは、編集可能な要素が動的に表示される高度なフォームを作成していて、ユーザーが入力を開始する場所を制御したり、キャレットの位置に応答したりする場合に便利です。</target>
        </trans-unit>
        <trans-unit id="0fa03a3f15a0e8fbad9cff23f1c0c40a68b4b25f" translate="yes" xml:space="preserve">
          <source>This is useful, for example, if a component&amp;rsquo;s template includes one or more foreach blocks in which you wish to refer to some property or function on the component viewmodel rather than on the current data item.</source>
          <target state="translated">これは、たとえば、コンポーネントのテンプレートに1つ以上のforeachブロックが含まれていて、現在のデータアイテムではなく、コンポーネントビューモデルのプロパティまたは関数を参照する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="599fc1798895695cf0148c049103421a0f316ffe" translate="yes" xml:space="preserve">
          <source>This is very simple and elegant (and it&amp;rsquo;s trivial to add yet more observable query parameters that also trigger a refresh automatically whenever they change), but there is a potential efficiency problem. Suppose you add the following function to GridViewModel that changes both pageIndex and pageSize:</source>
          <target state="translated">これは非常にシンプルでエレガントです（変更可能なときに自動的に更新をトリガーするさらに監視可能なクエリパラメーターを追加するのは簡単です）が、潜在的な効率の問題があります。次の関数をGridViewModelに追加して、pageIndexとpageSizeの両方を変更するとします。</target>
        </trans-unit>
        <trans-unit id="9117d0ab32efbb0c3350f9f8bac13fc40074e4e2" translate="yes" xml:space="preserve">
          <source>This means that if giftWrap was defined with the initial state false (i.e., giftWrap: ko.observable(false)) then the associated DIV would initially be hidden, and then would slide into view when the user later checks the box.</source>
          <target state="translated">これは、giftWrapが初期状態False(すなわち、giftWrap:ko.observable(false))で定義されている場合、関連するDIVは、最初は隠されていて、後でユーザーがボックスをチェックしたときにスライドして表示されることを意味します。</target>
        </trans-unit>
        <trans-unit id="6a8c9ee94416efc36e3d0b09cb54b5b894dd20f1" translate="yes" xml:space="preserve">
          <source>This one is trickier. The expression itself, when evaluated, reads an observable. That observable&amp;rsquo;s value could change over time, so the expression result could change over time.</source>
          <target state="translated">これはトリッキーです。式自体は、評価されるとオブザーバブルを読み取ります。そのオブザーバブルの値は時間とともに変化する可能性があるため、式の結果は時間とともに変化する可能性があります。</target>
        </trans-unit>
        <trans-unit id="764cca70bf6bc3478b2f5d9c5e14adb25a24ed61" translate="yes" xml:space="preserve">
          <source>This pattern is beneficial for large applications, because it &lt;strong&gt;simplifies development&lt;/strong&gt; through clear organization and encapsulation, and helps to &lt;strong&gt;improve runtime performance&lt;/strong&gt; by incrementally loading your application code and templates as needed.</source>
          <target state="translated">このパターンは、明確な編成とカプセル化によって&lt;strong&gt;開発&lt;/strong&gt;を&lt;strong&gt;簡素&lt;/strong&gt;化し、必要に応じてアプリケーションコードとテンプレートを段階的にロードする&lt;strong&gt;ことでランタイムパフォーマンス&lt;/strong&gt;を&lt;strong&gt;向上させる&lt;/strong&gt;ため、大規模なアプリケーションに有益です。</target>
        </trans-unit>
        <trans-unit id="c49ec8a2f8904ae806b7933742cc5c46416eb94c" translate="yes" xml:space="preserve">
          <source>This phase always completes synchronously (constructors and factory functions are not allowed to be asynchronous), since it occurs &lt;em&gt;every time a component is instantiated&lt;/em&gt; and performance would be unacceptable if it involved waiting for network requests.</source>
          <target state="translated">このフェーズは常に同期的に完了します（コンストラクターとファクトリー関数を非同期にすることはできません）。これは&lt;em&gt;、コンポーネントがインスタンス化されるたび&lt;/em&gt;に発生し、ネットワークリクエストの待機が含まれる場合はパフォーマンスが許容できないためです。</target>
        </trans-unit>
        <trans-unit id="7cd17e2e83be7a02ac954b0879cc442249587320" translate="yes" xml:space="preserve">
          <source>This refers to the binding context object at the parent level. This is different from $parent, which refers to the &lt;em&gt;data&lt;/em&gt; (not binding context) at the parent level. This is useful, for example, if you need to access the index value of an outer foreach item from an inner context (usage: $parentContext.$index). This is undefined in the root context.</source>
          <target state="translated">これは、親レベルのバインディングコンテキストオブジェクトを参照します。これは、親レベルの&lt;em&gt;データ&lt;/em&gt;（バインディングコンテキストではない）を参照する$ parentとは異なります。これは、たとえば、内部コンテキストから外部foreachアイテムのインデックス値にアクセスする必要がある場合に役立ちます（使用法：$ parentContext。$ index）。これはルートコンテキストでは定義されていません。</target>
        </trans-unit>
        <trans-unit id="06c6933149d42721a432ae0308df0854c322572c" translate="yes" xml:space="preserve">
          <source>This refers to the current binding context object. This may be useful if you want to access properties of the context when they might also exist in the view model, or if you want to pass the context object to a helper function in your view model.</source>
          <target state="translated">これは、現在のバインディングコンテキストオブジェクトを参照します。これは、コンテキストのプロパティがビューモデル内にも存在する場合にアクセスしたい場合や、ビューモデル内のヘルパー関数にコンテキストオブジェクトを渡したい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="f387b998e8ac7a29ae76937857a5182d84c0d6a8" translate="yes" xml:space="preserve">
          <source>This returns a new computed value that provides a filtered view of the array, while leaving the original array unchanged. Because the filtered array is a computed observable, it will be re-evaluated whenever the underlying array changes.</source>
          <target state="translated">これは、元の配列を変更せずに、配列をフィルタリングして表示する新しい計算値を返します。フィルタリングされた配列は計算された観測値なので、元の配列が変更されるたびに再評価されます。</target>
        </trans-unit>
        <trans-unit id="e779749b0336c95080fa9bf6da2b3b0f50a52bf9" translate="yes" xml:space="preserve">
          <source>This should be a very unusual scenario, so normally you will not need to work with $raw.</source>
          <target state="translated">これは非常に珍しいシナリオのはずなので、通常は$rawで作業する必要はありません。</target>
        </trans-unit>
        <trans-unit id="01da6ff51ae4d2c3c90a4030485a45aed896a7b0" translate="yes" xml:space="preserve">
          <source>This should be an array (or an observable array). KO sets the element&amp;rsquo;s selected options to match the contents of the array. Any previous selection state will be overwritten.</source>
          <target state="translated">これは配列（または監視可能な配列）である必要があります。KOは、要素の選択されたオプションを配列の内容と一致するように設定します。以前の選択状態は上書きされます。</target>
        </trans-unit>
        <trans-unit id="88bbbc0277944375aa46b38dfa45e9ab615c5899" translate="yes" xml:space="preserve">
          <source>This simple logChange extender subscribes to the observable and uses the console to write any changes along with a configurable message.</source>
          <target state="translated">このシンプルな logChange エクステンダーはオブザーバブルをサブスクライブし、コンソールを使って設定可能なメッセージとともに変更を書き出します。</target>
        </trans-unit>
        <trans-unit id="c93d03a0497f4b6a9cf5527ffc5543496c0874f0" translate="yes" xml:space="preserve">
          <source>This technique is also possible when using components &lt;em&gt;without&lt;/em&gt; custom elements, i.e., &lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;passing markup when using the component binding directly&lt;/a&gt;.</source>
          <target state="translated">この手法は、カスタム要素の&lt;em&gt;ない&lt;/em&gt;コンポーネント&lt;em&gt;を&lt;/em&gt;使用する場合、つまり、&lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;コンポーネントバインディングを直接使用する場合にマークアップを渡す&lt;/a&gt;場合にも可能です。</target>
        </trans-unit>
        <trans-unit id="256c845485dd4d340fc02fc1d45ab4dd11c131f5" translate="yes" xml:space="preserve">
          <source>This updated withProperties binding could now be used in a nested way, with each level of nesting able to access the parent level via $parentContext:</source>
          <target state="translated">この更新された withProperties バインディングは、ネストされた方法で使用できるようになり、ネストされた各レベルは $parentContext を介して親レベルにアクセスできるようになりました。</target>
        </trans-unit>
        <trans-unit id="8d002804da1ead8e6117a2574e37ec65f769d881" translate="yes" xml:space="preserve">
          <source>This uses the &lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;brfs Browserify plugin&lt;/a&gt; to automatically inline the .html file, so you would need to build the script file using a command similar to:</source>
          <target state="translated">これは&lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;brfs Browserifyプラグイン&lt;/a&gt;を使用して.htmlファイルを自動的にインライン化するため、次のようなコマンドを使用してスクリプトファイルをビルドする必要があります。</target>
        </trans-unit>
        <trans-unit id="e7012cd7733550a283d385731119658ec9bb44e4" translate="yes" xml:space="preserve">
          <source>This way, every time the mapping plugin checks an item in the children array, it will only look at the id property to determine if an object was completely replaced or merely needs updating.</source>
          <target state="translated">この方法では、マッピングプラグインが子配列の項目をチェックするたびに、オブジェクトが完全に置き換えられたのか、単に更新が必要なだけなのかを判断するために id プロパティだけを見て判断します。</target>
        </trans-unit>
        <trans-unit id="a8568ff1255174753fee15506ea5b939e7eba400" translate="yes" xml:space="preserve">
          <source>This will add the provided callback function to the microtask queue. Knockout includes a fast task queue that runs tasks in FIFO order until the queue is empty. When the first task is scheduled, Knockout will schedule a flush event using the &lt;a href=&quot;#implementation&quot;&gt;browser&amp;rsquo;s microtask&lt;/a&gt; support if possible. This ensures that the first task and subsequent tasks behave similarly.</source>
          <target state="translated">これにより、提供されたコールバック関数がマイクロタスクキューに追加されます。ノックアウトには、キューが空になるまでFIFO順にタスクを実行する高速タスクキューが含まれています。最初のタスクがスケジュールされると、Knockoutは、&lt;a href=&quot;#implementation&quot;&gt;可能であればブラウザーのマイクロタスク&lt;/a&gt;サポートを使用してフラッシュイベントをスケジュールします。これにより、最初のタスクと後続のタスクが同じように動作することが保証されます。</target>
        </trans-unit>
        <trans-unit id="89fe8682d00eb2da96a5709d31b9029ffbcfc05d" translate="yes" xml:space="preserve">
          <source>This will alert Grahamfoo!.</source>
          <target state="translated">これでGrahamfoo!</target>
        </trans-unit>
        <trans-unit id="1e9d83f540d0f759264a50c1deaee9fadbc1b907" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitPositive when the currentProfit value is positive, otherwise it will apply the profitWarning CSS class.</source>
          <target state="translated">これは、currentProfitの値が正の場合にはprofitPositiveというCSSクラスが適用され、そうでない場合にはprofitWarningというCSSクラスが適用されます。</target>
        </trans-unit>
        <trans-unit id="f87913830792a93e929c5041e49a1ac864f3534e" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitWarning whenever the currentProfit value dips below zero, and remove that class whenever it goes above zero.</source>
          <target state="translated">これは、現在のProfitの値がゼロ以下になるとCSSのprofitWarningクラスを適用し、ゼロ以上になるとそのクラスを削除します。</target>
        </trans-unit>
        <trans-unit id="18e90989c33e17d16d78799aa4ba01332cd092cc" translate="yes" xml:space="preserve">
          <source>This will be the &lt;a href=&quot;observables&quot;&gt;ko.observable&lt;/a&gt; instance declared on the parent viewmodel as myObservable. It is not a wrapper &amp;mdash; it&amp;rsquo;s the actual same instance as referenced by the parent. So if the child viewmodel writes to this observable, the parent viewmodel will receive that change.</source>
          <target state="translated">これは、親ビューモデルでmyObservableとして宣言された&lt;a href=&quot;observables&quot;&gt;ko.observable&lt;/a&gt;インスタンスになります。これはラッパーではありません&amp;mdash;親によって参照される実際の同じインスタンスです。したがって、子ビューモデルがこのオブザーバブルに書き込む場合、親ビューモデルはその変更を受け取ります。</target>
        </trans-unit>
        <trans-unit id="2f67007f4b1a32d450aaea3739ae4efc22153a68" translate="yes" xml:space="preserve">
          <source>This will be the numeric value 2. It will not be an observable or computed value, since there are no observables involved.</source>
          <target state="translated">これは数値2になります。これは観測値や計算値ではありません。</target>
        </trans-unit>
        <trans-unit id="1c5ede0dd1910b9dd5251dfa29559d2f0637ba62" translate="yes" xml:space="preserve">
          <source>This will create an unmapped object containing only the properties of the mapped object that were part of your original JS object. So in other words, any properties or functions that you manually added to your view model are ignored. By default, the only exception to this rule is the _destroy property which will also be mapped back, because it is a property that Knockout may generate when you destroy an item from an ko.observableArray. See the &amp;ldquo;Advanced Usage&amp;rdquo; section for more details on how to configure this.</source>
          <target state="translated">これにより、元のJSオブジェクトの一部であった、マップされたオブジェクトのプロパティのみを含むマップされていないオブジェクトが作成されます。つまり、ビューモデルに手動で追加したプロパティや関数はすべて無視されます。デフォルトでは、このルールの唯一の例外は_destroyプロパティです。これは、ko.observableArrayからアイテムを破棄するときにKnockoutが生成する可能性があるプロパティでもあるため、マップされます。これを構成する方法の詳細については、「高度な使用法」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="9c3e13ac9f2224e44e42edef86d37eab2fe74fad" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s href attribute to year-end.html and the element&amp;rsquo;s title attribute to Report including final year-end statistics.</source>
          <target state="translated">これにより、要素のhref属性がyear-end.htmlに設定され、要素のtitle属性が最終的な年末の統計を含むReportに設定されます。</target>
        </trans-unit>
        <trans-unit id="b1010c547f79842589b0e311d7876305e18791c1" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s style.color property to red whenever the currentProfit value dips below zero, and to black whenever it goes above zero.</source>
          <target state="translated">これにより、currentProfit値がゼロを下回るたびに要素のstyle.colorプロパティが赤に設定され、ゼロを超えると黒に設定されます。</target>
        </trans-unit>
        <trans-unit id="39c0ebf1e1a352368a835454316aec61a6b25f3d" translate="yes" xml:space="preserve">
          <source>This works because {{each...}} and ${ ... } are jQuery.tmpl syntaxes. What&amp;rsquo;s more, it&amp;rsquo;s trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a data-bind=&quot;template: ...&quot; inside a template to render a nested one.</source>
          <target state="translated">これは、{{each ...}}と$ {...}がjQuery.tmpl構文であるため機能します。さらに、テンプレートをネストするのは簡単です。テンプレート内からdata-bind属性を使用できるため、テンプレート内にdata-bind = &quot;template：...&quot;を置くだけで、ネストされたものをレンダリングできます。</target>
        </trans-unit>
        <trans-unit id="4fdac77a92e4befc847d03ccedc3c0f29ee5e341" translate="yes" xml:space="preserve">
          <source>This works nicely with regular DOM elements. The following elements will be shuffled into a random order:</source>
          <target state="translated">これは通常の DOM 要素とうまく機能します。以下の要素はランダムな順序でシャッフルされます。</target>
        </trans-unit>
        <trans-unit id="6cea06b68ab89e21eb2eb393da04144cdf69163b" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'category', &lt;em&gt;not&lt;/em&gt; as: category), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="translated">ヒント：&lt;em&gt;文字列リテラル値&lt;/em&gt;をas（例：as： 'category'、&lt;em&gt;not&lt;/em&gt; as：category）に渡すことを忘れないでください。これは、既存の変数の値を読み取るのではなく、新しい変数に名前を付けるためです。</target>
        </trans-unit>
        <trans-unit id="d8500f75dd4919cdb81ed364100516eb992fda0f" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'season', &lt;em&gt;not&lt;/em&gt; as: season), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="translated">ヒント：既に存在する変数の値を読み取るのではなく、新しい変数に名前を付けるため、&lt;em&gt;文字列リテラル値&lt;/em&gt;をas に渡すことを忘れないでください（例：as： 'season'、as：season で&lt;em&gt;はない&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="4e7109024dd6bcf80fd3c4071c74f0ccac474646" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;read&lt;/strong&gt; the observable&amp;rsquo;s current value, just call the observable with no parameters. In this example, myViewModel.personName() will return 'Bob', and myViewModel.personAge() will return 123.</source>
          <target state="translated">オブザーバブルの現在の値を&lt;strong&gt;読み取るに&lt;/strong&gt;は、パラメーターなしでオブザーバブルを呼び出します。この例では、myViewModel.personName（）は「Bob」を返し、myViewModel.personAge（）は123を返します。</target>
        </trans-unit>
        <trans-unit id="1603a0143d3999d60952c967221acb25e519b499" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;write&lt;/strong&gt; a new value to the observable, call the observable and pass the new value as a parameter. For example, calling myViewModel.personName('Mary') will change the name value to 'Mary'.</source>
          <target state="translated">するには&lt;strong&gt;、書き込み&lt;/strong&gt;の観察可能に新しい値を、観測可能を呼び出し、パラメータとして新しい値を渡します。たとえば、myViewModel.personName（ 'Mary'）を呼び出すと、名前の値が「Mary」に変更されます。</target>
        </trans-unit>
        <trans-unit id="8c1dd52f53359b8999172932067a959e30b50bb9" translate="yes" xml:space="preserve">
          <source>To activate Knockout, add the following line to a &amp;lt;script&amp;gt; block:</source>
          <target state="translated">Knockoutをアクティブにするには、次の行を&amp;lt;script&amp;gt;ブロックに追加します。</target>
        </trans-unit>
        <trans-unit id="4bedfacc43fa04424dc2037d1ad45179e728cf82" translate="yes" xml:space="preserve">
          <source>To attach a custom function, add it to one of the following extensibility points:</source>
          <target state="translated">カスタム関数をアタッチするには、以下のいずれかの拡張ポイントに追加します。</target>
        </trans-unit>
        <trans-unit id="fc34fc8c1a8f61015e6ccf19b6048b726ab8b730" translate="yes" xml:space="preserve">
          <source>To check if a property is observable, computed, etc., use the following set of functions:</source>
          <target state="translated">プロパティが観測可能かどうか、計算可能かどうかなどを確認するには、以下の関数群を使用します。</target>
        </trans-unit>
        <trans-unit id="a6ca1b4a2f54eff18a5d64c54c19bfbc24f36608" translate="yes" xml:space="preserve">
          <source>To create a view model via the mapping plugin, replace the creation of viewModel in the code above with the ko.mapping.fromJS function:</source>
          <target state="translated">マッピングプラグインでビューモデルを作成するには、上記コードのviewModelの作成をko.mapping.fromJS関数に置き換えてください。</target>
        </trans-unit>
        <trans-unit id="9bca32773ffd1de2e683926bbbc0399c4ce35c07" translate="yes" xml:space="preserve">
          <source>To create a view model with KO, just declare any JavaScript object. For example,</source>
          <target state="translated">KOでビューモデルを作成するには、任意のJavaScriptオブジェクトを宣言するだけです。例えば</target>
        </trans-unit>
        <trans-unit id="ed5b10cf91ed48dc2161202d3dbba9996462cd34" translate="yes" xml:space="preserve">
          <source>To do this, attach a preprocess function to the binding handler:</source>
          <target state="translated">これを行うには、バインディングハンドラにプリプロセス関数をアタッチします。</target>
        </trans-unit>
        <trans-unit id="b6f315d7429f0172c8d46409834c17cc33ad391f" translate="yes" xml:space="preserve">
          <source>To do this, define a preprocessNode function on your binding provider:</source>
          <target state="translated">これを行うには、バインディング・プロバイダで preprocessNode 関数を定義します。</target>
        </trans-unit>
        <trans-unit id="8a2f9db2683d5e7dd55d32347c60ef3b9fd17aa7" translate="yes" xml:space="preserve">
          <source>To do this, simply return {controlsDescendantBindings:true} from your binding&amp;rsquo;s init function.</source>
          <target state="translated">これを行うには、バインディングのinit関数から{controlsDescendantBindings：true}を返すだけです。</target>
        </trans-unit>
        <trans-unit id="0d02d6d0b98e8e4132512edf37abb131f03195b9" translate="yes" xml:space="preserve">
          <source>To ensure that the child component can react to changes in the expression value, Knockout &lt;strong&gt;automatically upgrades this parameter to a computed property&lt;/strong&gt;. So, the child component will be able to read params.observableExpression() to get the current value, or use params.observableExpression.subscribe(...), etc.</source>
          <target state="translated">子コンポーネントが式の値の変更に確実に反応できるように、Knockoutは&lt;strong&gt;このパラメーターを自動的に計算されたプロパティにアップグレードします&lt;/strong&gt;。したがって、子コンポーネントはparams.observableExpression（）を読み取って現在の値を取得したり、params.observableExpression.subscribe（...）などを使用したりできます。</target>
        </trans-unit>
        <trans-unit id="b4a8d0a19e57da9771491cbbe8f1040202f3913f" translate="yes" xml:space="preserve">
          <source>To ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender:</source>
          <target state="translated">同じ値であっても、購読者に常に更新を通知するようにするには、notifyエクステンダーを使用することになります。</target>
        </trans-unit>
        <trans-unit id="a230b2caaad8521494456ece11667c71eb8c9cab" translate="yes" xml:space="preserve">
          <source>To get started, here&amp;rsquo;s a custom binding that randomises the order of DOM nodes:</source>
          <target state="translated">はじめに、DOMノードの順序をランダム化するカスタムバインディングを次に示します。</target>
        </trans-unit>
        <trans-unit id="7e12f7ef2adfbd28b0327ae040b9449ce8ae8c4a" translate="yes" xml:space="preserve">
          <source>To get started, you can register a component using ko.components.register (technically, registration is optional, but it&amp;rsquo;s the easiest way to get started). A component definition specifies a viewModel and template. For example:</source>
          <target state="translated">開始するには、ko.components.registerを使用してコンポーネントを登録できます（技術的には、登録はオプションですが、開始する最も簡単な方法です）。コンポーネント定義は、viewModelとテンプレートを指定します。例えば：</target>
        </trans-unit>
        <trans-unit id="34c9f670f8df2e29349796ad5b0233f8c05eff2a" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless control flow syntax&lt;/em&gt;, which is based on comment tags. For example,</source>
          <target state="translated">これを処理するために、コメントタグに基づく&lt;em&gt;コンテナレス制御フロー構文を&lt;/em&gt;使用できます。例えば、</target>
        </trans-unit>
        <trans-unit id="d18572193a45491f5f82b42ce11142e475501e50" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless syntax&lt;/em&gt;, which is based on comment tags.</source>
          <target state="translated">これを処理するには、コメントタグに基づく&lt;em&gt;コンテナレス構文を&lt;/em&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="344aafcd8749ab67bed4212faedd867ef9944e6c" translate="yes" xml:space="preserve">
          <source>To implement a naming convention, your custom component loader only needs to implement getConfig. For example:</source>
          <target state="translated">命名規約を実装するには、カスタムコンポーネントローダーは getConfig を実装する必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1e3b53d1cbf555a90afd50c492b3f2aa86042a55" translate="yes" xml:space="preserve">
          <source>To make it easy to serialize view model data, including observables and the like, Knockout includes two helper functions:</source>
          <target state="translated">観測値などのビューモデルデータを簡単にシリアライズできるように、Knockoutには2つのヘルパー関数が用意されています。</target>
        </trans-unit>
        <trans-unit id="a16e4b410b776f2eb11f1b98050f24b8ce7df16f" translate="yes" xml:space="preserve">
          <source>To register a binding, add it as a subproperty of ko.bindingHandlers:</source>
          <target state="translated">バインディングを登録するには、それを ko.bindingHandlers のサブプロパティとして追加します。</target>
        </trans-unit>
        <trans-unit id="9a050d6aedfdbef27779228a105257ebafded91d" translate="yes" xml:space="preserve">
          <source>To register a function to run when a node is removed, you can call ko.utils.domNodeDisposal.addDisposeCallback(node, callback). As an example, suppose you create a custom binding to instantiate a widget. When the element with the binding is removed, you may want to call the destroy method of the widget:</source>
          <target state="translated">ノードが削除されたときに実行する関数を登録するには、ko.utils.domNodeDisposal.addDisposeCallback(node,callback)を呼び出します。例として、ウィジェットのインスタンスを作成するためにカスタムバインディングを作成したとします。バインディングを持つ要素が削除されたときに、ウィジェットの destroy メソッドを呼び出したい場合があります。</target>
        </trans-unit>
        <trans-unit id="628e530a0cb918fd2a0dc463a561ba3eb6ded4c1" translate="yes" xml:space="preserve">
          <source>To register any event handlers so that, for example, when the user clicks on or modifies the DOM element, you can change the state of the associated observable</source>
          <target state="translated">イベントハンドラを登録して、例えばユーザーが DOM 要素をクリックしたり変更したりしたときに、関連するオブザーバブルの状態を変更できるようにするには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="e971fd083a8eb6c18b73f34e2fcf3c1be214c7ef" translate="yes" xml:space="preserve">
          <source>To see how you can bind the observableArray to a UI and let the user modify it, see &lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;the simple list example&lt;/a&gt;.</source>
          <target state="translated">observableArrayをUIにバインドしてユーザーに変更させる方法について&lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;は、簡単なリストの例を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="095a567dfb57127d79567d4bc52abc97f60ac311" translate="yes" xml:space="preserve">
          <source>To see this take effect, here&amp;rsquo;s a sample usage:</source>
          <target state="translated">これが有効になるのを確認するために、使用例を次に示します。</target>
        </trans-unit>
        <trans-unit id="3ae1228ed42dd51e2a79a4933915655e8327da14" translate="yes" xml:space="preserve">
          <source>To set any initial state for the DOM element</source>
          <target state="translated">DOM 要素の初期状態を設定するには</target>
        </trans-unit>
        <trans-unit id="9f816fffe2f0c1ef4a2672aecdb14944095d7a12" translate="yes" xml:space="preserve">
          <source>To solve this, you can specify which key the mapping plugin should use to determine if an object is new or old. You would set it up like this:</source>
          <target state="translated">これを解決するには、マッピングプラグインがオブジェクトが新しいか古いかを判断するために使用するキーを指定することができます。このように設定します。</target>
        </trans-unit>
        <trans-unit id="d875d374a5b560ee2a9072eedb09b31f34d14b2b" translate="yes" xml:space="preserve">
          <source>To summarise: KO doesn&amp;rsquo;t compete with jQuery or similar low-level DOM APIs. KO provides a complementary, high-level way to link a data model to a UI. KO itself doesn&amp;rsquo;t depend on jQuery, but you can certainly use jQuery at the same time, and indeed that&amp;rsquo;s often useful if you want things like animated transitions.</source>
          <target state="translated">要約すると、KOはjQueryまたは同様の低レベルDOM APIと競合しません。KOは、データモデルをUIにリンクするための補足的な高レベルの方法を提供します。KO自体はjQueryに依存していませんが、jQueryを同時に使用することは確かに可能であり、アニメーション化された遷移などが必要な場合は、実際に役立ちます。</target>
        </trans-unit>
        <trans-unit id="64c8953197898f78eeca558500a49ab49daef233" translate="yes" xml:space="preserve">
          <source>To supply a configuration, call callback(componentConfig), where componentConfig is any object that can be understood by the loadComponent function on your loader or any other loader. The default loader simply supplies whatever object was registered using ko.components.register.</source>
          <target state="translated">設定を提供するには callback(componentConfig)をコールします。componentConfig は、ローダーや他のローダーの loadComponent 関数で理解できる任意のオブジェクトです。デフォルトのローダは、単に ko.components.register を使用して登録されたオブジェクトを供給します。</target>
        </trans-unit>
        <trans-unit id="19095264c8ed4472bafe7730a63b6cf4ef5c336b" translate="yes" xml:space="preserve">
          <source>To supply a createViewModel function, call callback(yourCreateViewModelFunction). The createViewModel function must accept parameters (params, componentInfo) and must synchronously return a new viewmodel instance each time it is called.</source>
          <target state="translated">createViewModel 関数を提供するには、callback(yourCreateViewModelFunction)を呼び出します。createViewModel関数は、パラメータ(params、componentInfo)を受け取り、呼び出されるたびに新しいビューモデルのインスタンスを同期的に返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="1b5f93798c8c651e942c21326f558b5aa4d8d7c6" translate="yes" xml:space="preserve">
          <source>To supply a viewmodel/template pair, call callback(result), where result is an object with the following properties:</source>
          <target state="translated">ビューモデルとテンプレートのペアを提供するには callback(result)を呼び出します。</target>
        </trans-unit>
        <trans-unit id="4ead5da5921414482244d25f573f52e9a5b955e8" translate="yes" xml:space="preserve">
          <source>To supply an array of DOM nodes, call callback(domNodeArray).</source>
          <target state="translated">DOM ノードの配列を提供するには、callback(domNodeArray)を呼び出します。</target>
        </trans-unit>
        <trans-unit id="1724664ad5c98bc91fe046f856ef3cda6f3d6e51" translate="yes" xml:space="preserve">
          <source>To supply parameters to the component, pass an object with the following properties:</source>
          <target state="translated">コンポーネントにパラメータを供給するには、以下のプロパティを持つオブジェクトを渡します。</target>
        </trans-unit>
        <trans-unit id="478bbd64e518e9b998ff4a6cab53605b1ae49ad6" translate="yes" xml:space="preserve">
          <source>To write values to &lt;strong&gt;multiple observable properties&lt;/strong&gt; on a model object, you can use &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.personName('Mary').personAge(50) will change the name value to 'Mary' &lt;em&gt;and&lt;/em&gt; the age value to 50.</source>
          <target state="translated">モデルオブジェクトの&lt;strong&gt;複数の監視可能なプロパティ&lt;/strong&gt;に値を書き込むには、&lt;em&gt;チェーン構文&lt;/em&gt;を使用でき&lt;em&gt;ます&lt;/em&gt;。たとえば、myViewModel.personName（ 'Mary'）。personAge（50）は、名前の値を「Mary」&lt;em&gt;に&lt;/em&gt;、年齢の値を50に変更します。</target>
        </trans-unit>
        <trans-unit id="3a5865922af306bd8ae540e6e29d90f3c0fc25a0" translate="yes" xml:space="preserve">
          <source>Triggering UI-level validation using a library such as &lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation&lt;/a&gt;, using code similar to the following snippet: if ($(formElement).valid()) { /* do something */ }.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation&lt;/a&gt;などのライブラリを使用して、次のスニペットに似たコードを使用してUIレベルの検証をトリガーします：if（$（formElement）.valid（））{/ *何かを行う* /}。</target>
        </trans-unit>
        <trans-unit id="0969eb5b711519c18e0b6f0a6871c28056b8ba40" translate="yes" xml:space="preserve">
          <source>Try it out:</source>
          <target state="translated">試してみてください。</target>
        </trans-unit>
        <trans-unit id="4d46d56fedff8d9d8e85c637f94cca6486220b3d" translate="yes" xml:space="preserve">
          <source>Try it:</source>
          <target state="translated">試してみてください。</target>
        </trans-unit>
        <trans-unit id="eaf9d5be1a5edee29dc70627d1391050d53eaeb0" translate="yes" xml:space="preserve">
          <source>Two points to note about this example:</source>
          <target state="translated">この例の注意点は2つ。</target>
        </trans-unit>
        <trans-unit id="9142247f90c4a68927ee8f397af8554e56a791cf" translate="yes" xml:space="preserve">
          <source>Two things have happened here: name was changed from Scot to Scott and children[0].name was changed from Alicw to the typo-free Alice. You can update viewModel based on this new data:</source>
          <target state="translated">ここでは2つのことが起こりました:nameがScotからScottに変更され、children[0].nameがAlicwからタイプミスのないAliceに変更されました。この新しいデータに基づいてviewModelを更新することができます。</target>
        </trans-unit>
        <trans-unit id="4ec6595c029c891202be0000bd3de833e1a37085" translate="yes" xml:space="preserve">
          <source>Typically this is useful when values in your view model are actually strings of HTML markup that you want to render.</source>
          <target state="translated">通常、これはビューモデル内の値が実際にレンダリングしたいHTMLマークアップの文字列である場合に便利です。</target>
        </trans-unit>
        <trans-unit id="c44eb7cfce780337ba99afe9286699b6ff8a45d7" translate="yes" xml:space="preserve">
          <source>Typically this is useful with elements like &amp;lt;span&amp;gt; or &amp;lt;em&amp;gt; that traditionally display text, but technically you can use it with any element.</source>
          <target state="translated">通常、これは従来からテキストを表示する&amp;lt;span&amp;gt;や&amp;lt;em&amp;gt;などの要素で役立ちますが、技術的には任意の要素で使用できます。</target>
        </trans-unit>
        <trans-unit id="fe23c3213b817a535e503650eb3aed5e4ffa688e" translate="yes" xml:space="preserve">
          <source>Typically you&amp;rsquo;d only want to use optionsValue as a way of ensuring that KO can correctly retain selection when you update the set of available options. For example, if you&amp;rsquo;re repeatedly getting a list of &amp;ldquo;car&amp;rdquo; objects via Ajax calls and want to ensure that the selected car is preserved, you might need to set optionsValue to &quot;carId&quot; or whatever unique identifier each &amp;ldquo;car&amp;rdquo; object has, otherwise KO won&amp;rsquo;t necessarily know which of the previous &amp;ldquo;car&amp;rdquo; objects corresponds to which of the new ones.</source>
          <target state="translated">通常は、利用可能なオプションのセットを更新するときにKOが選択を正しく保持できるようにするための方法として、optionsValueのみを使用します。たとえば、Ajax呼び出しで繰り返し「車」オブジェクトのリストを取得していて、選択した車が保持されるようにしたい場合は、optionsValueを「carId」または各「車」オブジェクトが持つ一意の識別子に設定する必要がある場合があります。そうでなければ、KOは以前の「車」オブジェクトのどれが新しいもののどれに対応するかを必ずしも知るわけではありません。</target>
        </trans-unit>
        <trans-unit id="48d4528c74c77bb144c5416d7e9ba854d62bff55" translate="yes" xml:space="preserve">
          <source>Uniquely identifying objects using &amp;ldquo;keys&amp;rdquo;</source>
          <target state="translated">「キー」を使用してオブジェクトを一意に識別する</target>
        </trans-unit>
        <trans-unit id="035deff1cdf7cc31acdb9702441a6e450f6d339e" translate="yes" xml:space="preserve">
          <source>Unlike some more traditional programming languages however, the current iteration of JavaScript (ECMA-262) doesn&amp;rsquo;t provide developers with the means to import such modules of code in a clean, organized manner. It&amp;rsquo;s one of the concerns with specifications that haven&amp;rsquo;t required great thought until more recent years where the need for more organized JavaScript applications became apparent.</source>
          <target state="translated">ただし、一部の従来のプログラミング言語とは異なり、JavaScript（ECMA-262）の現在のイテレーションでは、開発者はこのようなコードのモジュールをクリーンで整理された方法でインポートすることができません。これは、より体系化されたJavaScriptアプリケーションの必要性が明らかになるようになった最近の年まで、十分な検討を必要としなかった仕様に関する懸念の1つです。</target>
        </trans-unit>
        <trans-unit id="28ef317e90976436c53e6fd9743c3a6007ec616a" translate="yes" xml:space="preserve">
          <source>Unmapping</source>
          <target state="translated">Unmapping</target>
        </trans-unit>
        <trans-unit id="00b5fe370c80c9fd15a6c4aaf4ed7a457fabe3fe" translate="yes" xml:space="preserve">
          <source>Updating View Model Data using JSON</source>
          <target state="translated">JSONを使用したビューモデルデータの更新</target>
        </trans-unit>
        <trans-unit id="882404f2cec0fb17f2287042b3e7158d2e826690" translate="yes" xml:space="preserve">
          <source>Use clearInterval(handle) to stop them, otherwise your viewmodel might be held in memory.</source>
          <target state="translated">そうしないと、ビューモデルがメモリに保持されてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="f18b7da089633a2ca0b4636635f86dba16e5da93" translate="yes" xml:space="preserve">
          <source>Using a computed observable</source>
          <target state="translated">計算された観測値を使用して</target>
        </trans-unit>
        <trans-unit id="acf1fb7bc54bfd69e0f891d41bdd8354fa0c478f" translate="yes" xml:space="preserve">
          <source>Using a computed observable to run a callback based on multiple observables.</source>
          <target state="translated">計算された観測値を使用して、複数の観測値に基づいてコールバックを実行します。</target>
        </trans-unit>
        <trans-unit id="c2a6531054ec097e5ed70a832394e057ca205e4a" translate="yes" xml:space="preserve">
          <source>Using custom elements</source>
          <target state="translated">カスタム要素の使用</target>
        </trans-unit>
        <trans-unit id="7461986ee1f28f48b4bff59743d52212ae099805" translate="yes" xml:space="preserve">
          <source>Using deferred updates ensures that computed observables and bindings are updated only after their dependencies are stable. Even if an observable might go through multiple intermediate values, only the latest value is used to update its dependencies. To facilitate this, all notifications become asynchronous, scheduled using the &lt;a href=&quot;microtasks&quot;&gt;Knockout microtask queue&lt;/a&gt;. This may sound very similar to &lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limiting&lt;/a&gt;, which also helps prevent extra notifications, but deferred updates can provide these benefits across an entire application without adding delays. Here&amp;rsquo;s how notification scheduling differs between the standard, deferred, and rate-limited modes:</source>
          <target state="translated">遅延更新を使用すると、計算されたオブザーバブルとバインディングが、依存関係が安定した後でのみ更新されます。オブザーバブルが複数の中間値を通過する場合でも、最新の値のみを使用してその依存関係を更新します。これを容易にするために、すべての通知が非同期になり、&lt;a href=&quot;microtasks&quot;&gt;Knockoutマイクロタスクキュー&lt;/a&gt;を使用してスケジュールされます。これは、&lt;a href=&quot;ratelimit-observable&quot;&gt;レート制限&lt;/a&gt;と非常に似ているように聞こえる場合があります。これも余分な通知の防止に役立ちますが、遅延更新により、遅延を追加することなく、アプリケーション全体にこれらの利点を提供できます。標準モード、遅延モード、およびレート制限モード間での通知スケジュールの違いは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d22dae89d982b72d6b6d2ac79e0ca3abf367c0e3" translate="yes" xml:space="preserve">
          <source>Using deferred updates for specific observables</source>
          <target state="translated">特定の観測値のための延期された更新の使用</target>
        </trans-unit>
        <trans-unit id="82500147d6fe068e5f3eac3c33aa845f26a5b095" translate="yes" xml:space="preserve">
          <source>Using extenders to augment observables</source>
          <target state="translated">エクステンダーを使って観測値を拡張する</target>
        </trans-unit>
        <trans-unit id="50d3aa10da781d57d5fb5f9b37232d95022250cb" translate="yes" xml:space="preserve">
          <source>Using the component binding</source>
          <target state="translated">コンポーネントバインディングの使用</target>
        </trans-unit>
        <trans-unit id="4fdbe03b68d1b5f0b1e0b8df84af814851a7626f" translate="yes" xml:space="preserve">
          <source>Using the computed context</source>
          <target state="translated">計算されたコンテキストの使用</target>
        </trans-unit>
        <trans-unit id="36cfba518908dc7ac80815a581dbac4dbfe3d45f" translate="yes" xml:space="preserve">
          <source>Using unobtrusive event handlers</source>
          <target state="translated">控えめなイベントハンドラの使用</target>
        </trans-unit>
        <trans-unit id="2a98028d793eefede53201a64728cbb7a99bc8be" translate="yes" xml:space="preserve">
          <source>Using valueAllowUnset with &amp;lt;select&amp;gt; elements</source>
          <target state="translated">&amp;lt;select&amp;gt;要素でのvalueAllowUnsetの使用</target>
        </trans-unit>
        <trans-unit id="a2fccbf4307cd999a23c6d6d0c8c15cd45251e9e" translate="yes" xml:space="preserve">
          <source>Viewmodels can be specified in any of the following forms:</source>
          <target state="translated">ビューモデルは、以下のいずれかの形式で指定することができます。</target>
        </trans-unit>
        <trans-unit id="67410bb1c50d4c83c27173e0489e96f063272dc6" translate="yes" xml:space="preserve">
          <source>Virtual Element APIs</source>
          <target state="translated">仮想要素API</target>
        </trans-unit>
        <trans-unit id="e406729e158e24dd87b8e698dcec51dd531fa16b" translate="yes" xml:space="preserve">
          <source>Virtual elements</source>
          <target state="translated">仮想要素</target>
        </trans-unit>
        <trans-unit id="350a4fbd76ca00bce2ade90d8477e5ed8a1a52e4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve borrowed the term from &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure functions&lt;/a&gt; because this feature is generally only applicable for computed observables whose evaluator is a &lt;em&gt;pure function&lt;/em&gt; as follows:</source>
          <target state="translated">この機能は通常、次のように評価者が&lt;em&gt;純関数&lt;/em&gt;である計算されたオブザーバブルにのみ適用できるため、&lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;純関数&lt;/a&gt;から用語を借りてきました。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35a6b726c72e0d5b8bef238a8458f1acc64e5a41" translate="yes" xml:space="preserve">
          <source>What if you&amp;rsquo;ve got an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; for firstName, and another for lastName, and you want to display the full name? That&amp;rsquo;s where &lt;em&gt;computed observables&lt;/em&gt; come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</source>
          <target state="translated">firstNameの&lt;a href=&quot;observables&quot;&gt;オブザーバブル&lt;/a&gt;とlastNameのオブザーバブルがあり、フルネームを表示したい場合はどうなりますか？そこに&lt;em&gt;計算されたオブザーバブル&lt;/em&gt;が入ります-これらは1つ以上の他のオブザーバブルに依存する関数であり、これらの依存関係のいずれかが変更されるたびに自動的に更新されます。</target>
        </trans-unit>
        <trans-unit id="d0955f26cb60a2b7c19f0ff4510ffa1f1f8a847e" translate="yes" xml:space="preserve">
          <source>What tends to be most useful in practice is creating AMD modules that have inline viewmodel classes, and explicitly take AMD dependencies on external template files.</source>
          <target state="translated">実際に最も便利なのは、インラインのビューモデルクラスを持つAMDモジュールを作成し、外部テンプレートファイルへのAMD依存性を明示的に取ることです。</target>
        </trans-unit>
        <trans-unit id="d0746929aa2438a6c079c324161ceff7bcbb2cda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;not&lt;/em&gt; to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="translated">&lt;em&gt;純粋に&lt;/em&gt;計算されたオブザーバブルを使用し&lt;em&gt;ない&lt;/em&gt;場合&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e688d2a76e0cc347828e115ec7ca0f7f8f898a8d" translate="yes" xml:space="preserve">
          <source>When a component binding injects a component,</source>
          <target state="translated">コンポーネントバインディングがコンポーネントを注入するとき</target>
        </trans-unit>
        <trans-unit id="49718b2901f95c68a1922d6b2983c5beec56f4c3" translate="yes" xml:space="preserve">
          <source>When a computed observable returns a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that a computed observable&amp;rsquo;s subscribers are always notified on an update, even if the value is the same. You would apply the extender like this:</source>
          <target state="translated">計算されたオブザーバブルがプリミティブ値（数値、文字列、ブール、またはnull）を返す場合、オブザーバブルの依存関係は通常、値が実際に変更された場合にのみ通知されます。ただし、組み込みの通知&lt;a href=&quot;extenders&quot;&gt;エクステンダー&lt;/a&gt;を使用して、値が同じであっても、計算されたオブザーバブルのサブスクライバーに常に更新が通知されるようにすることができます。次のようにエクステンダーを適用します。</target>
        </trans-unit>
        <trans-unit id="e830112947080dad24b739108f8a4da674f8a04f" translate="yes" xml:space="preserve">
          <source>When applied to a computed observable, the deferred extender will also avoid excess evaluation of the computed function. Using deferred updates ensures that any sequence of changes to dependencies in the current task will trigger just &lt;em&gt;one&lt;/em&gt; re-evaluation of the computed observable. For example:</source>
          <target state="translated">計算されたオブザーバブルに適用されると、据え置きエクステンダーは計算された関数の過剰な評価も回避します。遅延更新を使用すると、現在のタスクの依存関係に対する一連の変更によって、計算されたオブザーバブルの&lt;em&gt;1回&lt;/em&gt;だけの再評価がトリガーされます。例えば：</target>
        </trans-unit>
        <trans-unit id="240548473b5b8fba3f48d06580b1747a636e1733" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item the event refers to. For example,</source>
          <target state="translated">ハンドラーを呼び出すと、Knockoutは最初のパラメーターとして現在のモデル値を提供します。これは、コレクション内の各アイテムのUIをレンダリングしていて、イベントが参照するアイテムを知る必要がある場合に特に便利です。例えば、</target>
        </trans-unit>
        <trans-unit id="69391a30effde287dee34eb73d855395d87ce5a9" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item&amp;rsquo;s UI was clicked. For example,</source>
          <target state="translated">ハンドラーを呼び出すと、Knockoutは最初のパラメーターとして現在のモデル値を提供します。これは、コレクション内の各アイテムのUIをレンダリングしていて、どのアイテムのUIがクリックされたかを知る必要がある場合に特に便利です。例えば、</target>
        </trans-unit>
        <trans-unit id="fbadbc1c18a2eb0a89cdf0f66ab67f3c68470882" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will create observables based on the rules explained &lt;a href=&quot;#how-things-are-mapped&quot;&gt;above&lt;/a&gt;. If you want to force the mapping plugin to simply copy the property instead of making it observable, add its name to the &amp;ldquo;copy&amp;rdquo; array:</source>
          <target state="translated">ビューモデルをJSオブジェクトに変換すると、デフォルトで、マッピングプラグインは&lt;a href=&quot;#how-things-are-mapped&quot;&gt;上記で&lt;/a&gt;説明したルールに基づいてオブザーバブルを作成します。プロパティを監視可能にするのではなく、単にコピーするようにマッピングプラグインを強制したい場合は、その名前を「コピー」配列に追加します。</target>
        </trans-unit>
        <trans-unit id="34bc7212872348445dd0f0e3cd8734701a523ffe" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will only include properties that were part of your original view model, except it will also include the Knockout-generated _destroy property even if it was not part of your original object. However, you can choose to customize this array:</source>
          <target state="translated">ビューモデルを JS オブジェクトに変換する場合、デフォルトでは、マッピングプラグインは元のビューモデルの一部であったプロパティのみを含みますが、元のオブジェクトに含まれていなくても Knockout が生成した _destroy プロパティが含まれます。ただし、この配列をカスタマイズすることもできます。</target>
        </trans-unit>
        <trans-unit id="d17cbd8252177d3eecb0c97f654d8e466d16f693" translate="yes" xml:space="preserve">
          <source>When nesting foreach templates, it&amp;rsquo;s often useful to refer to items at higher levels in the hierarchy. One way to do this is to refer to $parent or other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables in your bindings.</source>
          <target state="translated">foreachテンプレートをネストする場合、階層の上位レベルにあるアイテムを参照すると便利な場合があります。これを行う1つの方法は、バインディングで$ parentまたは他の&lt;a href=&quot;binding-context&quot;&gt;バインディングコンテキスト&lt;/a&gt;変数を参照することです。</target>
        </trans-unit>
        <trans-unit id="0447c91d2a396145a22645b117ae8a779d972c73" translate="yes" xml:space="preserve">
          <source>When presenting the user with a list of selectable items, it is often useful to include a method to select or deselect all of the items. This can be represented quite intuitively with a boolean value that represents whether all items are selected. When set to true it will select all items, and when set to false it will deselect them.</source>
          <target state="translated">ユーザーに選択可能な項目のリストを提示するとき、すべての項目を選択または非選択にするメソッドを含めると便利なことがよくあります。これは、すべての項目が選択されているかどうかを表すブール値で直感的に表現できます。trueに設定するとすべての項目が選択され、falseに設定すると選択解除されます。</target>
        </trans-unit>
        <trans-unit id="fa06a171ee457055a05faa668013d2f40356d7d1" translate="yes" xml:space="preserve">
          <source>When removing an element, Knockout runs logic to clean up any data associated with the element. As part of this logic, Knockout calls jQuery&amp;rsquo;s cleanData method if jQuery is loaded in your page. In advanced scenarios, you may want to prevent or customize how this data is removed in your application. Knockout exposes a function, ko.utils.domNodeDisposal.cleanExternalData(node), that can be overridden to support custom logic. For example, to prevent cleanData from being called, an empty function could be used to replace the standard cleanExternalData implementation:</source>
          <target state="translated">要素を削除すると、Knockoutはロジックを実行して、要素に関連付けられているデータをクリーンアップします。このロジックの一部として、jQueryがページにロードされている場合、KnockoutはjQueryのcleanDataメソッドを呼び出します。高度なシナリオでは、アプリケーションでこのデータを削除する方法を防止またはカスタマイズすることができます。Knockoutは、カスタムロジックをサポートするためにオーバーライドできる関数k​​o.utils.domNodeDisposal.cleanExternalData（node）を公開します。たとえば、cleanDataが呼び出されないようにするには、空の関数を使用して、標準のcleanExternalData実装を置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="0d673da0804e0a4a38175c4dafe9330c0b8fbb10" translate="yes" xml:space="preserve">
          <source>When the computed observable is only used in your UI</source>
          <target state="translated">計算された観測値がUIでのみ使用される場合</target>
        </trans-unit>
        <trans-unit id="db6fb44d7f7d1f10f432541accee58dc638af22b" translate="yes" xml:space="preserve">
          <source>When the default loader&amp;rsquo;s loadComponent runs, it simultaneously:</source>
          <target state="translated">デフォルトのローダーのloadComponentを実行すると、同時に次のことが行われます。</target>
        </trans-unit>
        <trans-unit id="1aa25dca397cfdaf6f58c0b5c990ffd248e032ba" translate="yes" xml:space="preserve">
          <source>When the deferUpdates option is on, all observables, computed observables, and bindings will be set to use deferred updates and notifications. Enabling this feature at the start of creating a Knockout-based application means you do not need to worry about working around the intermediate-value problem, and so can facilitate a cleaner, purely reactive design. But you should take care when enabling deferred updates for an existing application because it will break code that depends on synchronous updates or on notification of intermediate values (although you may be able to &lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;work around these issues&lt;/a&gt;).</source>
          <target state="translated">deferUpdatesオプションがオンの場合、すべての監視可能オブジェクト、計算された監視可能オブジェクト、およびバインディングは、遅延更新と遅延通知を使用するように設定されます。Knockoutベースのアプリケーションの作成の最初にこの機能を有効にすると、中間値の問題を回避する必要がないため、よりクリーンで純粋に反応的な設計を促進できます。ただし、既存のアプリケーションの遅延更新を有効にする場合は注意が必要です。同期更新または中間値の通知に依存するコードが破損するためです（ただし&lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;、これらの問題を回避&lt;/a&gt;できる場合があります）。</target>
        </trans-unit>
        <trans-unit id="14350d5d7b6cb62c7f2e96ed3335bddec0681969" translate="yes" xml:space="preserve">
          <source>When the first task is scheduled (initially and after a previous flush event has finished), Knockout will schedule a flush event to process the microtask queue. If possible, it will try to use the browsers&amp;rsquo;s own microtask capabilities. In modern browsers, it will use a &lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;DOM mutation observer&lt;/a&gt;, and in older versions of Internet Explorer, it will use a &amp;lt;script&amp;gt; onreadystatechange event. These methods allow it to start processing the queue before any reflow or redrawing. In other browsers, it will revert to using setTimeout.</source>
          <target state="translated">最初のタスクがスケジュールされると（最初と前のフラッシュイベントが終了した後）、Knockoutはフラッシュタスクをスケジュールしてマイクロタスクキューを処理します。可能であれば、ブラウザ自体のマイクロタスク機能を使用しようとします。最近のブラウザーでは&lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;DOMミュー&lt;/a&gt;テーションオブザーバーを使用し、古いバージョンのInternet Explorerでは&amp;lt;script&amp;gt; onreadystatechangeイベントを使用します。これらのメソッドにより、リフローまたは再描画の前にキューの処理を開始できます。他のブラウザでは、setTimeoutの使用に戻ります。</target>
        </trans-unit>
        <trans-unit id="b4c02d5563dd9c10af0804c769590634547b5a72" translate="yes" xml:space="preserve">
          <source>When the options binding changes the set of options in your &amp;lt;select&amp;gt; element, KO will leave the user&amp;rsquo;s selection unchanged where possible. So, for a single-select drop-down list, the previously selected option value will still be selected, and for a multi-select list, all the previously selected option values will still be selected (unless, of course, you&amp;rsquo;ve removed one or more of those options).</source>
          <target state="translated">オプションバインディングが&amp;lt;select&amp;gt;要素のオプションセットを変更すると、KOは可能な限りユーザーの選択を変更しません。したがって、単一選択のドロップダウンリストの場合、以前に選択されたオプション値は引き続き選択され、複数選択リストの場合は、以前に選択されたすべてのオプション値が選択されたままになります（もちろん、これらのオプションの1つ以上）。</target>
        </trans-unit>
        <trans-unit id="d3b21cd263e89b964e6c3850344e09506b5dcfe3" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;false-like value&lt;/strong&gt; (e.g., the boolean value false, or the numeric value 0, or null, or undefined), the binding sets yourElement.style.display to none, causing it to be hidden. This takes priority over any display style you&amp;rsquo;ve defined using CSS.</source>
          <target state="translated">パラメータが&lt;strong&gt;falseのような値&lt;/strong&gt;（たとえば、ブール値false、数値0、null、または未定義）に解決されると、バインディングはyourElement.style.displayをnoneに設定し、非表示にします。これは、CSSを使用して定義した表示スタイルよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="424933b4a587b12800d5037b620d089e1310bebf" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;true-like value&lt;/strong&gt; (e.g., the boolean value true, or a non-null object or array), the binding removes the yourElement.style.display value, causing it to become visible.</source>
          <target state="translated">パラメータが&lt;strong&gt;trueのような値&lt;/strong&gt;（たとえば、ブール値true、またはnull以外のオブジェクトや配列）に解決されると、バインディングによってyourElement.style.display値が削除され、表示されます。</target>
        </trans-unit>
        <trans-unit id="f5648040a47d72bcccb395b1f9a5a715c4f582e4" translate="yes" xml:space="preserve">
          <source>When the user changes which radio button is selected, KO will set your model property to equal the value of the selected radio button. In the preceding example, clicking on the radio button with value=&quot;cherry&quot; would set viewModel.spamFlavor to be &quot;cherry&quot;.</source>
          <target state="translated">ユーザーが選択されているラジオボタンを変更すると、KO は選択されているラジオボタンの値と同じ値をモデルプロパティに設定します。前述の例では、value=&quot;cherry &quot;のラジオボタンをクリックすると、viewModel.spamFlavorが &quot;cherry &quot;に設定されます。</target>
        </trans-unit>
        <trans-unit id="af87db2ce5d35d81a05adcc1a10b76bb7ceb65d5" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will add or remove the value from the array accordingly.</source>
          <target state="translated">ユーザーがチェックボックスにチェックを入れたり外したりすると、KOはそれに応じて配列から値を追加したり削除したりします。</target>
        </trans-unit>
        <trans-unit id="7ed7961c716e1412d259d37491a6eb0f3e216a42" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will set your model property to true or false accordingly.</source>
          <target state="translated">ユーザーがチェックボックスにチェックを入れたり外したりすると、KOはそれに応じてモデルプロパティをtrueまたはfalseに設定します。</target>
        </trans-unit>
        <trans-unit id="a975d33ef8135e1f85ea96cb074a21a12a6b1e5a" translate="yes" xml:space="preserve">
          <source>When the user checks the associated form control, this updates the value on your view model. Likewise, when you update the value in your view model, this checks or unchecks the form control on screen.</source>
          <target state="translated">ユーザーが関連するフォームコントロールをチェックすると、ビューモデルの値が更新されます。同様に、ビューモデルの値を更新すると、画面上のフォームコントロールをチェックまたはアンチェックします。</target>
        </trans-unit>
        <trans-unit id="c0803213f1274b2a55d9b91b874c4a9d488ed496" translate="yes" xml:space="preserve">
          <source>When the user edits the value in the associated form control, it updates the value on your view model. Likewise, when you update the value in your view model, this updates the value of the form control on screen.</source>
          <target state="translated">ユーザーが関連するフォームコントロールの値を編集すると、ビューモデルの値が更新されます。同様に、ビューモデルの値を更新すると、画面上のフォームコントロールの値が更新されます。</target>
        </trans-unit>
        <trans-unit id="f0189caf134a5f34340d62bfc5c510d298e95ca3" translate="yes" xml:space="preserve">
          <source>When the user manually focuses or unfocuses the element, your value will be set to true or false accordingly.</source>
          <target state="translated">ユーザーが手動で要素にフォーカスを当てたり外したりすると、それに応じて値がtrueまたはfalseに設定されます。</target>
        </trans-unit>
        <trans-unit id="98cfccafa8cf961040d59d473116f98c49c5beb7" translate="yes" xml:space="preserve">
          <source>When the user selects or de-selects an item in the multi-select list, this adds or removes the corresponding value to an array on your view model. Likewise, assuming it&amp;rsquo;s an &lt;em&gt;observable&lt;/em&gt; array on your view model, then whenever you add or remove (e.g., via push or splice) items to this array, the corresponding items in the UI become selected or deselected. It&amp;rsquo;s a 2-way binding.</source>
          <target state="translated">ユーザーが複数選択リストの項目を選択または選択解除すると、対応する値がビューモデルの配列に追加または削除されます。同様に、それがビューモデルの&lt;em&gt;監視可能な&lt;/em&gt;配列であるとすると、この配列に項目を追加または削除（プッシュまたはスプライスなどを介して）するたびに、UIの対応する項目が選択または選択解除されます。これは双方向バインディングです。</target>
        </trans-unit>
        <trans-unit id="0074731e38b2821484d16af4acc4755105ba6332" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued deferred observables notify only when their value is actually different at the end of the current task. In other words, if a primitive-valued deferred observable is changed to a new value and then changed back to the original value, no notification will happen.</source>
          <target state="translated">観測可能な値がプリミティブ(数値、文字列、ブール値、ヌル値)である場合、その観測可能な値が以前と実際に異なる値に設定されたときにのみ、その観測可能な値の依存関係がデフォルトで通知されます。つまり、プリミティブ値を持つ遅延観測可能変数は、現在のタスクの終了時に値が実際に異なる場合にのみ通知されます。つまり、プリミティブ値を持つ繰延観測可能変数が新しい値に変更された後、元の値に戻った場合、通知は発生しません。</target>
        </trans-unit>
        <trans-unit id="73a77795bd66e1cb3b16bdd68e57f5a159e05b77" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued rate-limited observables notify only when their value is actually different at the end of the timeout period. In other words, if a primitive-valued rate-limited observable is changed to a new value and then changed back to the original value before the timeout period ends, no notification will happen.</source>
          <target state="translated">観測可能な値がプリミティブ(数値、文字列、ブール値、ヌル値)である場合、その観測可能な値が以前と実際に異なる値に設定されたときにのみ、その観測可能な値の依存関係がデフォルトで通知されます。つまり、プリミティブ値を持つレート制限付きの観測可能ファイルは、タイムアウト期間の終了時に値が実際に異なっている場合にのみ通知されます。つまり、タイムアウト期間が終了する前に、プリミティブ値のレート制限付き観測可能変数が新しい値に変更された後、元の値に変更された場合は、何も通知されません。</target>
        </trans-unit>
        <trans-unit id="09e87bae7a7069eae757161892afd1feaa3f86ad" translate="yes" xml:space="preserve">
          <source>When to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="translated">&lt;em&gt;純粋に&lt;/em&gt;計算されたオブザーバブルをいつ使用するか</target>
        </trans-unit>
        <trans-unit id="0d9cb52535c85c16c1cd6054161d9b5a42c19b24" translate="yes" xml:space="preserve">
          <source>When using KO, your view is simply your HTML document with declarative bindings to link it to the view model. Alternatively, you can use templates that generate HTML using data from your view model.</source>
          <target state="translated">KOを使用する場合、ビューは、ビューモデルにリンクする宣言的バインディングを持つHTMLドキュメントになります。あるいは、ビューモデルのデータを使用して HTML を生成するテンプレートを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="233388c234469b332e4372d743016356bcc6ddb1" translate="yes" xml:space="preserve">
          <source>When using rateLimit:</source>
          <target state="translated">rateLimitを使用する場合。</target>
        </trans-unit>
        <trans-unit id="cdd38baa0a09da7b54c34c1c8c1440db8b27182f" translate="yes" xml:space="preserve">
          <source>When we say an application is modular, we generally mean it&amp;rsquo;s composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, its quite easy to see how changes to one part of a system may affect another.</source>
          <target state="translated">アプリケーションがモジュール式であるとは、一般的に、モジュールに格納された、高度に分離された個別の機能のセットで構成されていることを意味します。おそらくご存知のとおり、疎結合を使用すると、可能な場合は依存関係を削除することにより、アプリの保守が容易になります。これを効率的に実装すると、システムのある部分の変更が別の部分にどのように影響するかを簡単に確認できます。</target>
        </trans-unit>
        <trans-unit id="6e729fad8dd8395be4b5dee56db32c21c2e12be4" translate="yes" xml:space="preserve">
          <source>When writing to an observable that contains a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that an observable&amp;rsquo;s subscribers are always notified on a write, even if the value is the same. You would apply the extender to an observable like this:</source>
          <target state="translated">プリミティブ値（数値、文字列、ブール値、またはnull）を含むオブザーバブルに書き込む場合、オブザーバブルの依存関係は通常、値が実際に変更された場合にのみ通知されます。ただし、組み込みの通知&lt;a href=&quot;extenders&quot;&gt;エクステンダー&lt;/a&gt;を使用して、値が同じであっても、オブザーバブルのサブスクライバーが常に書き込み時に通知されるようにすることができます。次のように、エクステンダーをオブザーバブルに適用します。</target>
        </trans-unit>
        <trans-unit id="72a073d3684319f9171f7c76ed59be1b723f8be1" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;add&lt;/strong&gt; array entries, foreach will render new copies of your template and insert them into the existing DOM</source>
          <target state="translated">配列エントリを&lt;strong&gt;追加すると&lt;/strong&gt;、foreachはテンプレートの新しいコピーをレンダリングし、既存のDOMに挿入します</target>
        </trans-unit>
        <trans-unit id="fac1b26f280d61f56ca4bfb78786061572d31924" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;delete&lt;/strong&gt; array entries, foreach will simply remove the corresponding DOM elements</source>
          <target state="translated">配列エントリを&lt;strong&gt;削除すると&lt;/strong&gt;、foreachは対応するDOM要素を単に削除します</target>
        </trans-unit>
        <trans-unit id="74f4836dcc40687d501d0a60aca7bfa37c93bc31" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;reorder&lt;/strong&gt; array entries (retaining the same object instances), foreach will typically just move the corresponding DOM elements into their new position</source>
          <target state="translated">配列エントリを&lt;strong&gt;並べ替えると&lt;/strong&gt;（同じオブジェクトインスタンスを保持）、foreachは通常、対応するDOM要素を新しい位置に移動するだけです。</target>
        </trans-unit>
        <trans-unit id="5e24e098b9af5a56adbd90dc77567f135eceb3a7" translate="yes" xml:space="preserve">
          <source>When you change the name value to 'Mary' by calling myViewModel.personName('Mary'), the text binding will automatically update the text contents of the associated DOM element. That&amp;rsquo;s how changes to the view model automatically propagate to the view.</source>
          <target state="translated">myViewModel.personName（ 'Mary'）を呼び出して名前の値を「Mary」に変更すると、テキストバインディングにより、関連するDOM要素のテキストコンテンツが自動的に更新されます。これにより、ビューモデルへの変更が自動的にビューに反映されます。</target>
        </trans-unit>
        <trans-unit id="7b233d0df811d63859dad5c6f37d404b45b3fb25" translate="yes" xml:space="preserve">
          <source>When you load a viewmodel or template via require declarations, e.g.,</source>
          <target state="translated">ビューモデルやテンプレートをrequire宣言でロードする場合、例えば</target>
        </trans-unit>
        <trans-unit id="cd8c8cbbd6da1bb5e72e94c4fe56cd77a45a9d91" translate="yes" xml:space="preserve">
          <source>When you modify the contents of your model array (by adding, moving, or deleting its entries), the foreach binding uses an efficient differencing algorithm to figure out what has changed, so it can then update the DOM to match. This means it can handle arbitrary combinations of simulaneous changes.</source>
          <target state="translated">モデル配列の内容を変更するとき(エントリの追加、移動、削除など)、foreach バインディングは効率的な差分アルゴリズムを使用して何が変更されたかを把握し、それに合わせて DOM を更新します。これは、任意の組み合わせのシミュレーション変更を扱うことができることを意味します。</target>
        </trans-unit>
        <trans-unit id="c3c82ab350bb2f560fd3b83e7250551b12fe5380" translate="yes" xml:space="preserve">
          <source>When you use the submit binding on a form, Knockout will prevent the browser&amp;rsquo;s default submit action for that form. In other words, the browser will call your handler function but will &lt;em&gt;not&lt;/em&gt; submit the form to the server. This is a useful default because when you use the submit binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the form as an interface to your view model, not as a regular HTML form. If you &lt;em&gt;do&lt;/em&gt; want to let the form submit like a normal HTML form, just return true from your submit handler.</source>
          <target state="translated">フォームで送信バインディングを使用すると、Knockoutはそのフォームに対するブラウザのデフォルトの送信アクションを防止します。つまり、ブラウザはハンドラ関数を呼び出しますが、フォームをサーバーに送信し&lt;em&gt;ません&lt;/em&gt;。これは、送信バインディングを使用する場合、通常、フォームを通常のHTMLフォームとしてではなく、ビューモデルへのインターフェースとして使用しているため、便利なデフォルトです。フォームを通常のHTMLフォームのように送信&lt;em&gt;し&lt;/em&gt;たい場合は、送信ハンドラからtrueを返すだけです。</target>
        </trans-unit>
        <trans-unit id="5099e034c651dd974110c8f683aaf6e9c35ee49c" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;any&lt;/em&gt; change subscribers, it is awake and &lt;strong&gt;&lt;em&gt;listening&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;listening&lt;/em&gt; state, it immediately subscribes to any dependencies. In this state, it operates just like a regular computed observable, as described in &lt;a href=&quot;computed-dependency-tracking&quot;&gt;how dependency tracking works&lt;/a&gt;.</source>
          <target state="translated">変更サブスクライバーが&lt;em&gt;存在&lt;/em&gt;するときはいつでも、それは目覚めて&lt;strong&gt;&lt;em&gt;いて聞いてい&lt;/em&gt;&lt;/strong&gt;ます。&lt;em&gt;リスニング&lt;/em&gt;状態に入ると、すぐに依存関係にサブスクライブします。この状態では、&lt;a href=&quot;computed-dependency-tracking&quot;&gt;依存関係の追跡のしくみで&lt;/a&gt;説明されているように、通常の計算されたオブザーバブルと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="027a73abac754e236b9d5e7c8cff74895b7e243f" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;no&lt;/em&gt; change subscribers, it is &lt;strong&gt;&lt;em&gt;sleeping&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;sleeping&lt;/em&gt; state, it disposes all subscriptions to its dependencies. During this state, it will not subscribe to any observables accessed in the evaluator function (although it does keep track of them). If the computed observable&amp;rsquo;s value is read while it is &lt;em&gt;sleeping&lt;/em&gt;, it is automatically re-evaluated if any of its dependencies have changed.</source>
          <target state="translated">変更サブスクライバーが&lt;em&gt;ない&lt;/em&gt;場合は常に&lt;strong&gt;&lt;em&gt;スリープ状態&lt;/em&gt;&lt;/strong&gt;です。&lt;em&gt;スリープ&lt;/em&gt;状態に入ると、すべてのサブスクリプションをその依存関係に破棄します。この状態の間、エバリュエーター関数でアクセスされたオブザーバブルにサブスクライブしません（ただし、それらを追跡します）。計算されたオブザーバブルの値が&lt;em&gt;スリープ&lt;/em&gt;中に読み取られた場合、その依存関係のいずれかが変更されているかどうかが自動的に再評価されます。</target>
        </trans-unit>
        <trans-unit id="c6f248d3a9bf144743685335ebbb7395f73f3d22" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified and a user transfers focus to another DOM node (i.e., on the change event), but you can also trigger updates based on other events by using the valueUpdate parameter described below.</source>
          <target state="translated">ユーザーが関連するフォームコントロールの値を編集するたびに、KO はビューモデルのプロパティを更新します。KOは、値が変更され、ユーザーが別のDOMノードにフォーカスを移したとき(つまり、変更イベントのとき)、常にビューモデルの更新を試みますが、以下に説明するvalueUpdateパラメータを使用して、他のイベントに基づいて更新をトリガーすることもできます。</target>
        </trans-unit>
        <trans-unit id="e5c65dd94ea67e2fad51961211d1569eac9051c0" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified by the user or any DOM events.</source>
          <target state="translated">ユーザーが関連するフォームコントロールの値を編集するたびに、KOはビューモデルのプロパティを更新します。KOは、ユーザーやDOMイベントによって値が変更された場合、常にビューモデルの更新を試みます。</target>
        </trans-unit>
        <trans-unit id="b90ce04fb0166e97a8840e6753fa79876c4f03da" translate="yes" xml:space="preserve">
          <source>Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</source>
          <target state="translated">計算されたオブザーバブルを宣言すると、KOは直ちにその評価関数を呼び出して初期値を取得します。</target>
        </trans-unit>
        <trans-unit id="1709d61d9bf5080cbac0848f20d050481e016f8d" translate="yes" xml:space="preserve">
          <source>Whenever you inject a &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;, Knockout fetches that component&amp;rsquo;s template and viewmodel using one or more &lt;em&gt;component loaders&lt;/em&gt;. The job of a component loader is to asynchronously supply a template/viewmodel pair for any given component name.</source>
          <target state="translated">あなたが注入たび&lt;a href=&quot;component-overview&quot;&gt;コンポーネント&lt;/a&gt;使用して&lt;a href=&quot;component-binding&quot;&gt;バインディングコンポーネント&lt;/a&gt;または&lt;a href=&quot;component-custom-elements&quot;&gt;カスタム要素を&lt;/a&gt;、ノックアウトは、そのコンポーネントのテンプレートとのviewmodelが1つの以上使用してフェッチ&lt;em&gt;コンポーネントローダーを&lt;/em&gt;。コンポーネントローダーの役割は、任意のコンポーネント名のテンプレートとビューモデルのペアを非同期で提供することです。</target>
        </trans-unit>
        <trans-unit id="7c9368d85e06a808f77b28f4f80f37db962b0bef" translate="yes" xml:space="preserve">
          <source>Whether or not the parameter is an observable array, KO will detect when the user selects or deselects an item in the multi-select list, and will update the array to match. This is how you can read which of the options is selected.</source>
          <target state="translated">パラメータが観測可能な配列であるかどうかに関わらず、ユーザがマルチセレクトリストの項目を選択または非選択にすると、KOはそれを検出し、一致するように配列を更新します。このようにして、どの選択肢が選択されているかを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="ff7601f5aa5d98b7725bc5ff59a4afe66d02b8ee" translate="yes" xml:space="preserve">
          <source>While result2 will be:</source>
          <target state="translated">結果2になりますが。</target>
        </trans-unit>
        <trans-unit id="deedac358e26a9b41a5c69e270deca1435272118" translate="yes" xml:space="preserve">
          <source>While the evaluator function is running, KO sets up a subscription to any observables (including other computed observables) that the evaluator reads. The subscription callback is set to cause the evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</source>
          <target state="translated">評価関数が実行されている間、KOは評価関数が読み込んだ観測値(他の計算された観測値を含む)にサブスクリプションを設定します。サブスクリプション・コールバックが設定されていると、評価器が再び実行され、プロセス全体がステップ1にループして戻ります(適用されなくなった古いサブスクリプションは破棄されます)。</target>
        </trans-unit>
        <trans-unit id="96bfb27bf17fe0044cc0631c47cb88836e206732" translate="yes" xml:space="preserve">
          <source>Whilst native solutions to these problems will be arriving in ES Harmony, the good news is that writing modular JavaScript has never been easier and you can start doing it today.</source>
          <target state="translated">これらの問題に対するネイティブソリューションがES Harmonyに登場する一方で、モジュール型JavaScriptの記述がかつてないほど簡単になり、今日からそれを始めることができるという朗報があります。</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5e0dfd97e23e633bf46dddf5920fffb9c6f7b27f" translate="yes" xml:space="preserve">
          <source>Why &amp;ldquo;pure&amp;rdquo;?</source>
          <target state="translated">なぜ「純粋」なのか？</target>
        </trans-unit>
        <trans-unit id="3713912b140d1bc73909fbeb997ac04de7b22784" translate="yes" xml:space="preserve">
          <source>Why not just put a click handler on the submit button?</source>
          <target state="translated">送信ボタンにクリックハンドラを付ければいいんじゃないの?</target>
        </trans-unit>
        <trans-unit id="6c9c00dce5a6b8f081befac104650345017434f1" translate="yes" xml:space="preserve">
          <source>Working with JSON strings</source>
          <target state="translated">JSON 文字列での作業</target>
        </trans-unit>
        <trans-unit id="3d63791dc040b8cd0707dc196c19e179ce90bb55" translate="yes" xml:space="preserve">
          <source>Writable computed observables</source>
          <target state="translated">書き込み可能な計算された観測値</target>
        </trans-unit>
        <trans-unit id="e5c7527fc9cce64616a1be5b3da7d5aeedc2fcd8" translate="yes" xml:space="preserve">
          <source>Writable computed observables are a powerful feature with a wide range of possible uses.</source>
          <target state="translated">書き込み可能な計算された観測値は、幅広い用途に使用できる強力な機能です。</target>
        </trans-unit>
        <trans-unit id="91aa11ff1c1ba1f14720abfd6158e9094fb52d2a" translate="yes" xml:space="preserve">
          <source>You are not limited to supplying configuration objects in any standard format. You can supply arbitrary objects as long as your loadComponent function understands them.</source>
          <target state="translated">設定オブジェクトを任意の標準形式で提供することに制限されているわけではありません。loadComponent 関数が理解できる限り、任意のオブジェクトを与えることができます。</target>
        </trans-unit>
        <trans-unit id="ee01c6f1c55a18105ff17707a47b82bb6d92c0a0" translate="yes" xml:space="preserve">
          <source>You can also customize how an object is updated by specifying an update callback. It will receive the object it is trying to update and an options object which is identical to the one used by the create callback. You should return the updated value.</source>
          <target state="translated">また、更新コールバックを指定してオブジェクトの更新方法をカスタマイズすることもできます。更新しようとしているオブジェクトと、create コールバックで使用したものと同じオプションオブジェクトを受け取ります。更新された値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="3d880f5ee3e205f53c33334d9f482d9e5a03043e" translate="yes" xml:space="preserve">
          <source>You can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its dispose function, e.g.:</source>
          <target state="translated">必要に応じてサブスクリプションを終了させることもできます。</target>
        </trans-unit>
        <trans-unit id="43f66180a0db996f97c6c83a8137770d9b5159f5" translate="yes" xml:space="preserve">
          <source>You can also use a JavaScript function or arbitrary JavaScript expression as the parameter value. If you do, KO will run your function/evaluate your expression, and use the result to determine whether to hide the element.</source>
          <target state="translated">パラメータ値としてJavaScriptの関数や任意のJavaScript式を使用することもできます。その場合、KOは関数を実行したり、式を評価したりして、その結果を使って要素を非表示にするかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="e50756d8b024dc4f5ab0d1482650d8b221903759" translate="yes" xml:space="preserve">
          <source>You can also use the value binding with a &amp;lt;select&amp;gt; element that does not use the options binding. In this case, you can choose to specify your &amp;lt;option&amp;gt; elements in markup or build them using the foreach or template bindings. You can even nest options within &amp;lt;optgroup&amp;gt; elements and Knockout will set the selected value appropriately.</source>
          <target state="translated">オプションバインディングを使用しない&amp;lt;select&amp;gt;要素で値バインディングを使用することもできます。この場合、マークアップで&amp;lt;option&amp;gt;要素を指定するか、foreachまたはテンプレートバインディングを使用してそれらを構築するかを選択できます。&amp;lt;optgroup&amp;gt;要素内でオプションをネストすることもでき、Knockoutは選択された値を適切に設定します。</target>
        </trans-unit>
        <trans-unit id="a9bd87c7ad551c644aec3e46f44aa15771ecde5d" translate="yes" xml:space="preserve">
          <source>You can combine multiple JS objects in one viewmodel by applying multiple ko.mapping.fromJS calls, e.g.:</source>
          <target state="translated">複数のJSオブジェクトを1つのビューモデルにまとめるには、複数のko.mapping.fromJS呼び出しを適用します。</target>
        </trans-unit>
        <trans-unit id="052f12c0432421aa4b5f276ed7c52cb3ffd99104" translate="yes" xml:space="preserve">
          <source>You can either put the script block at the bottom of your HTML document, or you can put it at the top and wrap the contents in a DOM-ready handler such as &lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;jQuery&amp;rsquo;s $ function&lt;/a&gt;.</source>
          <target state="translated">スクリプトブロックをHTMLドキュメントの下部に配置するか、スクリプトブロックを上部に配置して、&lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;jQueryの$関数&lt;/a&gt;などのDOM対応ハンドラーでコンテンツをラップすることができます。</target>
        </trans-unit>
        <trans-unit id="1dba98508f19715d131036a3aa6e81ae5ae8188c" translate="yes" xml:space="preserve">
          <source>You can even set multiple CSS classes based on the same condition by wrapping the names in quotes like:</source>
          <target state="translated">のように名前を引用符で囲むことで、同じ条件で複数のCSSクラスを設定することもできます。</target>
        </trans-unit>
        <trans-unit id="1ec2e8dcbd91bae1eafeddc57bddc053e1571e0f" translate="yes" xml:space="preserve">
          <source>You can find a good list of reserved words on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;Mozilla&amp;rsquo;s MDN page here&lt;/a&gt;.</source>
          <target state="translated">予約語の適切なリストは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;MozillaのMDNページ（こちら）にあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3cfbf0de916a9a332d3fb80ff672ea022cb01b5" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for interpreting data-bind attributes by providing a &lt;em&gt;binding preprocessor&lt;/em&gt; for a specific binding handler (such as click, visible, or any &lt;a href=&quot;custom-bindings&quot;&gt;custom binding handler&lt;/a&gt;).</source>
          <target state="translated">特定のバインディングハンドラー（クリック、可視、&lt;a href=&quot;custom-bindings&quot;&gt;カスタムバインディングハンドラーなど&lt;/a&gt;）の&lt;em&gt;バインディングプリプロセッサー&lt;/em&gt;を提供する&lt;em&gt;こと&lt;/em&gt;により、データバインド属性を解釈するためのKnockoutのロジックにフックできます。</target>
        </trans-unit>
        <trans-unit id="87fac0243102cb0636d3c50436c06c35c6bc14b1" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for traversing the DOM by providing a &lt;em&gt;node preprocessor&lt;/em&gt;. This is a function that Knockout will call once for each DOM node that it walks over, both when the UI is first bound, and later when any new DOM subtrees are injected (e.g., via a &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;ノードプリプロセッサを&lt;/em&gt;提供することで、DOMをトラバースするためのKnockoutのロジックにフックでき&lt;em&gt;ます&lt;/em&gt;。これは、UIが最初にバインドされたときと、後で新しいDOMサブツリーが挿入されたとき（たとえば&lt;a href=&quot;foreach-binding&quot;&gt;foreachバインディングを&lt;/a&gt;介して）の両方で、ウォークスルーするDOMノードごとに1回Knockoutが呼び出す関数です。</target>
        </trans-unit>
        <trans-unit id="3e4c6da9d3b1f66034b47e8dd672b13081d17170" translate="yes" xml:space="preserve">
          <source>You can map this to a view model without any problems:</source>
          <target state="translated">これをビューモデルにマッピングしても問題ありません。</target>
        </trans-unit>
        <trans-unit id="689af8b06e2b8d5ff8ae217915b9eefe6ba45a38" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing click: someObject.someFunction.</source>
          <target state="translated">任意のJavaScript関数を参照できます。ビューモデルの関数である必要はありません。click：someObject.someFunctionと記述することで、任意のオブジェクトの関数を参照できます。</target>
        </trans-unit>
        <trans-unit id="ef0d5d305918c213b70064faeb270cf5be19cc1a" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing event { mouseover: someObject.someFunction }.</source>
          <target state="translated">任意のJavaScript関数を参照できます。ビューモデルの関数である必要はありません。イベント{mouseover：someObject.someFunction}を記述することにより、任意のオブジェクトの関数を参照できます。</target>
        </trans-unit>
        <trans-unit id="d7731e4275a6724a076a102c99873fd04d12377b" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing submit: someObject.someFunction.</source>
          <target state="translated">任意のJavaScript関数を参照できます。ビューモデルの関数である必要はありません。submit：someObject.someFunctionと記述することで、任意のオブジェクトの関数を参照できます。</target>
        </trans-unit>
        <trans-unit id="a3bf8a9a01529e6b883f85d2f5580c56462d82cd" translate="yes" xml:space="preserve">
          <source>You can register a component as follows:</source>
          <target state="translated">以下のようにコンポーネントを登録することができます。</target>
        </trans-unit>
        <trans-unit id="dc66fcbdb568796cafb3b258bf02626926a8c07f" translate="yes" xml:space="preserve">
          <source>You can set multiple CSS classes at once. For example, if your view model has a property called isSevere,</source>
          <target state="translated">複数のCSSクラスを一度に設定することができます。例えば、ビューモデルにisSevereというプロパティがある場合。</target>
        </trans-unit>
        <trans-unit id="ee756fc2ba7ca22b5831bf756c710f284d654159" translate="yes" xml:space="preserve">
          <source>You can set multiple style values at once. For example, if your view model has a property called isSevere,</source>
          <target state="translated">一度に複数のスタイル値を設定することができます。例えば、ビューモデルに isSevere というプロパティがある場合。</target>
        </trans-unit>
        <trans-unit id="3dba377f14bffba8a5efad9ec37fc825bce450e7" translate="yes" xml:space="preserve">
          <source>You can then create a very simple &lt;em&gt;view&lt;/em&gt; of this view model using a declarative binding. For example, the following markup displays the personName value:</source>
          <target state="translated">その後、宣言バインディングを使用して、このビューモデルの非常に単純な&lt;em&gt;ビュー&lt;/em&gt;を作成できます。たとえば、次のマークアップはpersonName値を表示します。</target>
        </trans-unit>
        <trans-unit id="9f862efa038e8d26e7af75e8f1448e315ace30bd" translate="yes" xml:space="preserve">
          <source>You can use a writable computed observable exactly like a regular observable, with your own custom logic intercepting all reads and writes. Just like observables, you can write values to multiple observable or computed observable properties on a model object using &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.fullName('Joe Smith').age(50).</source>
          <target state="translated">すべての読み取りと書き込みをインターセプトする独自のカスタムロジックを使用して、通常の監視可能オブジェクトとまったく同じように、書き込み可能な計算された監視可能オブジェクトを使用できます。オブザーバブルと同様に、&lt;em&gt;チェーン構文&lt;/em&gt;を使用して、モデルオブジェクトの複数のオブザーバブルプロパティまたは計算されたオブザーバブルプロパティに値を書き込むことができ&lt;em&gt;ます&lt;/em&gt;。たとえば、myViewModel.fullName（ 'Joe Smith'）。age（50）などです。</target>
        </trans-unit>
        <trans-unit id="cc3db9cdadd161e89137b6c1f8b5ea73932af31f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;em&gt;pure&lt;/em&gt; feature for any computed observable that follows the &lt;a href=&quot;#pure-computed-function-defined&quot;&gt;&lt;em&gt;pure function&lt;/em&gt; guidelines&lt;/a&gt;. You&amp;rsquo;ll see the most benefit, though, when it is applied to application designs that involve persistent view models that are used and shared by temporary views and view models. Using &lt;em&gt;pure&lt;/em&gt; computed observables in a persistent view model provides computation performance benefits. Using them in temporary view models provides memory management benefits.</source>
          <target state="translated">&lt;a href=&quot;#pure-computed-function-defined&quot;&gt;&lt;em&gt;純粋な関数の&lt;/em&gt;&lt;/a&gt;ガイドラインに従う任意の計算されたオブザーバブルに&lt;em&gt;純粋な&lt;/em&gt;機能を使用できます。ただし、一時的なビューとビューモデルで使用および共有される永続的なビューモデルを含むアプリケーション設計に適用すると、最もメリットがあります。永続ビューモデルで&lt;em&gt;純粋に&lt;/em&gt;計算されたオブザーバブルを使用すると、計算パフォーマンスが向上します。一時ビューモデルでそれらを使用すると、メモリ管理の利点が得られます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="445598a09e09ab27b378c79e9f86d7333d1962c6" translate="yes" xml:space="preserve">
          <source>You can use the init callback as a place to register an event handler that will cause changes to the associated observable. For example,</source>
          <target state="translated">initコールバックは、関連するオブザーバブルに変更を加えるイベントハンドラを登録する場所として使うことができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c9980038705a45b71f8dc2def98206cccd1f4d42" translate="yes" xml:space="preserve">
          <source>You can use this technique if, for example, you want to control which subset of registered components may be used as custom elements.</source>
          <target state="translated">例えば、登録されたコンポーネントのどのサブセットをカスタム要素として使用するかを制御したい場合などに、このテクニックを使用することができます。</target>
        </trans-unit>
        <trans-unit id="661a6f45bdafd50b10c85ee0a3c036fc7df926c5" translate="yes" xml:space="preserve">
          <source>You could bind this view model to some HTML elements as follows:</source>
          <target state="translated">このビューモデルを以下のようにいくつかのHTML要素にバインドすることができます。</target>
        </trans-unit>
        <trans-unit id="c1d471328860434648aa8fa03313f486aae8251e" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to change the view at all - the same data-bind syntax will keep working. The difference is that it&amp;rsquo;s now capable of detecting changes, and when it does, it will update the view automatically.</source>
          <target state="translated">ビューをまったく変更する必要はありません。同じデータバインド構文が引き続き機能します。違いは、変更を検出できるようになり、検出すると自動的にビューが更新されることです。</target>
        </trans-unit>
        <trans-unit id="17a973a03dcc80b13d7dbe90df99ac6b1793924e" translate="yes" xml:space="preserve">
          <source>You might want to implement a custom component loader if you want to use naming conventions, rather than explicit registration, to load components. Or, if you want to use a third-party &amp;ldquo;loader&amp;rdquo; library to fetch component viewmodels or templates from external locations.</source>
          <target state="translated">明示的な登録ではなく命名規則を使用してコンポーネントをロードする場合は、カスタムコンポーネントローダーを実装することができます。または、サードパーティの「ローダー」ライブラリを使用して、コンポーネントのビューモデルまたはテンプレートを外部の場所からフェッチする場合。</target>
        </trans-unit>
        <trans-unit id="fee233d9fef0eab27974da7495e7c970d76709ab" translate="yes" xml:space="preserve">
          <source>You must use dispose to release any resources that aren&amp;rsquo;t inherently garbage-collectable. For example:</source>
          <target state="translated">本質的にガベージコレクションできないリソースを解放するには、disposeを使用する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="2d43cca43db2b101cb12f2e4c94e2a371e5bd69f" translate="yes" xml:space="preserve">
          <source>You must write &amp;lt;my-custom-element&amp;gt;&amp;lt;/my-custom-element&amp;gt;, and &lt;strong&gt;not&lt;/strong&gt; &amp;lt;my-custom-element /&amp;gt;. Otherwise, your custom element is not closed and subsequent elements will be parsed as child elements.</source>
          <target state="translated">&amp;lt;my-custom-element /&amp;gt;では&lt;strong&gt;なく&lt;/strong&gt;、&amp;lt;my-custom-element&amp;gt; &amp;lt;/ my-custom-element&amp;gt;と記述する必要があります。そうでない場合、カスタム要素は閉じられず、後続の要素は子要素として解析されます。</target>
        </trans-unit>
        <trans-unit id="d9251d769ce5e182a494a279bea207eec0172927" translate="yes" xml:space="preserve">
          <source>You only need two files for the component - a viewmodel (path/my-component.js) and a template (path/my-component.html) - which is a very natural arrangement during development.</source>
          <target state="translated">コンポーネントに必要なファイルはビューモデル(path/my-component.js)とテンプレート(path/my-component.html)の2つだけです。</target>
        </trans-unit>
        <trans-unit id="a29664b58fa5bfc4804c4fec44e01829983a68be" translate="yes" xml:space="preserve">
          <source>You should not use the &lt;em&gt;pure&lt;/em&gt; feature for a computed observable that is meant to perform an action when its dependencies change. Examples include:</source>
          <target state="translated">依存関係が変更されたときにアクションを実行することを目的とした計算対象オブザーバブルに&lt;em&gt;純粋な&lt;/em&gt;機能を使用しないでください。例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="350964aafaead15e0f900fd5cb4610606ba71f2c" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to attribute names, and the values correspond to the attribute values you wish to apply.</source>
          <target state="translated">プロパティ名が属性名に対応し、値が適用したい属性値に対応するJavaScriptオブジェクトを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="b0ebd1ec7d9cfc0718391b658886d523d78de173" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to event names, and the values correspond to the function that you want to bind to the event.</source>
          <target state="translated">プロパティ名がイベント名に対応し、値がイベントにバインドしたい関数に対応するJavaScriptオブジェクトを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="6e10e77115395251f2707e5c49667eb3dc1b1e89" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to style names, and the values correspond to the style values you wish to apply.</source>
          <target state="translated">プロパティ名がスタイル名に対応し、値が適用したいスタイルの値に対応するJavaScriptオブジェクトを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="f2431741ff9d62f8125af6f5b235418b67c42a31" translate="yes" xml:space="preserve">
          <source>You should supply an array (or observable array). For each item, KO will add an &amp;lt;option&amp;gt; to the associated &amp;lt;select&amp;gt; node. Any previous options will be removed.</source>
          <target state="translated">配列（または監視可能な配列）を指定する必要があります。各アイテムについて、KOは&amp;lt;option&amp;gt;を関連する&amp;lt;select&amp;gt;ノードに追加します。以前のオプションはすべて削除されます。</target>
        </trans-unit>
        <trans-unit id="b1f309b2b779d610009271c39ee65e9c095e6b65" translate="yes" xml:space="preserve">
          <source>You want to display the current server-time and the number of users on your web page. You could represent this information using the following view model:</source>
          <target state="translated">現在のサーバー時間とWebページのユーザー数を表示したいとします。この情報は、以下のビューモデルを使って表現することができます。</target>
        </trans-unit>
        <trans-unit id="ab0462be804f0902ece6db1caf383668c565a43e" translate="yes" xml:space="preserve">
          <source>You won&amp;rsquo;t need to use this often. It&amp;rsquo;s only useful in a few rare cases, e.g.:</source>
          <target state="translated">これを頻繁に使用する必要はありません。これは、次のようないくつかのまれなケースでのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="136d45b744ad9e632284ca13aec225df9d9d766f" translate="yes" xml:space="preserve">
          <source>You would have to do this for every variable you want to display on your page. If your data structures become more complex (e.g. they contain children or contain arrays) this becomes very cumbersome to handle manually. What the mapping plugin allows you to do is create a mapping from the regular JavaScript object (or JSON structure) to an observable view model.</source>
          <target state="translated">ページに表示したい変数ごとにこれを行う必要があります。データ構造が複雑になると (例えば、子を含んでいたり、配列を含んでいたり)、手動で処理するのが非常に面倒になります。マッピングプラグインを使うと、通常の JavaScript オブジェクト (または JSON 構造体)から観測可能なビューモデルへのマッピングを作成することができます。</target>
        </trans-unit>
        <trans-unit id="f9c1cd6deaf34424cd7538a83dcd4251f9037aed" translate="yes" xml:space="preserve">
          <source>You would use this extender by calling the extend function of an observable and passing an object that contains a logChange property.</source>
          <target state="translated">オブザーバブルのextend関数を呼び出し、logChangeプロパティを含むオブジェクトを渡すことで、このエクステンダーを使用します。</target>
        </trans-unit>
        <trans-unit id="6c472940368ffb2c6f5ef7385d23da07c065fb9d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to referencing variables - you can reference arbitrary expressions to control an element&amp;rsquo;s enabledness. For example,</source>
          <target state="translated">変数を参照するだけでなく、任意の式を参照して要素の有効性を制御できます。例えば、</target>
        </trans-unit>
        <trans-unit id="fa251b979a6c1805f4ab439f863653eaa0839791" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using &amp;lt;template&amp;gt; elements, but these are convenient (on browsers that support them) since they don&amp;rsquo;t get rendered on their own. Any other element type works too.</source>
          <target state="translated">&amp;lt;template&amp;gt;要素の使用に制限はありませんが、これらは独自にレンダリングされないため、（それらをサポートするブラウザー上で）便利です。他の要素タイプも機能します。</target>
        </trans-unit>
        <trans-unit id="2cf0cf7d70766bca9a0f4aed278bfa9447202bcb" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using the built-in bindings like click, value, and so on &amp;mdash; you can create your own ones. This is how to control how observables interact with DOM elements, and gives you a lot of flexibility to encapsulate sophisticated behaviors in an easy-to-reuse way.</source>
          <target state="translated">クリックや値などの組み込みバインディングを使用することに限定されず、独自のバインディングを作成できます。これは、オブザーバブルがDOM要素と相互作用する方法を制御する方法であり、高度な動作を簡単に再利用できる方法でカプセル化するための多くの柔軟性を提供します。</target>
        </trans-unit>
        <trans-unit id="e47fc623d74756db24366a5c57ef4b49ba356887" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve already seen how to use update so that, when an observable changes, you can update an associated DOM element. But what about events in the other direction? When the user performs some action on a DOM element, you might want to updated an associated observable.</source>
          <target state="translated">オブザーバブルが変更されたときに関連するDOM要素を更新できるように、更新を使用する方法についてはすでに説明しました。しかし、反対方向のイベントはどうでしょうか？ユーザーがDOM要素に対してなんらかのアクションを実行するときに、関連付けられたオブザーバブルを更新したい場合があります。</target>
        </trans-unit>
        <trans-unit id="4be6289caef2ba7111850de2b50105c34b7ea767" translate="yes" xml:space="preserve">
          <source>Your preprocess function must return the new string value to be parsed and passed to the binding, or return undefined to remove the binding.</source>
          <target state="translated">前処理関数は、解析してバインディングに渡す新しい文字列の値を返すか、バインディングを削除するにはundefinedを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="feacdda40c5240dc38595a9dd2636c7cd727afa1" translate="yes" xml:space="preserve">
          <source>Your view models &lt;em&gt;are&lt;/em&gt; JavaScript objects, so in a sense, you could just serialize them as JSON using any standard JSON serializer, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; (a native function in modern browsers), or the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library. However, your view models probably contain observables, computed observables, and observable arrays, which are implemented as JavaScript functions and therefore won&amp;rsquo;t always serialize cleanly without additional work on your behalf.</source>
          <target state="translated">ビューモデル&lt;em&gt;は&lt;/em&gt; JavaScriptオブジェクトであるため、ある意味では、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt;（最新のブラウザーのネイティブ関数）または&lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt;ライブラリなどの標準のJSON シリアライザーを使用して、JSONとしてシリアル化できます。ただし、ビューモデルには、オブザーバブル、計算されたオブザーバブル、およびオブザーバブル配列が含まれている可能性があります。これらは、JavaScript関数として実装されているため、ユーザーに代わって追加の作業を行わなければ、正常にシリアル化されるとは限りません。</target>
        </trans-unit>
        <trans-unit id="39cb2f1192f456b678052badfe6dfbc807f31fd4" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;computed observable&lt;/strong&gt; called selectedItems that returns an array of item objects corresponding to the selected indexes</source>
          <target state="translated">&lt;strong&gt;計算された観察可能な&lt;/strong&gt;アイテムの配列を返すと呼ばselectedItemsのは、選択されたインデックスに対応するオブジェクト</target>
        </trans-unit>
        <trans-unit id="c304f8e7203b72eac14ca40325fc8fce86a3be08" translate="yes" xml:space="preserve">
          <source>addBinding: a callback function you can optionally use to insert another binding on the current element. This requires two parameters, name and value. For example, inside your preprocess function, call addBinding('visible', 'acceptsTerms()'); to make Knockout behave as if the element had a visible: acceptsTerms() binding on it.</source>
          <target state="translated">addBinding:現在の要素に別のバインディングを挿入するためのコールバック関数です。これには name と value の 2 つのパラメータが必要です。たとえば、前処理関数の内部で addBinding('visible','acceptsTerms()');をコールすると、要素に visible:acceptsTerms()バインディングがあるかのように Knockout を動作させることができます。</target>
        </trans-unit>
        <trans-unit id="ca84e4058eedaa99100e4d5459ba5d30f2c5b8ab" translate="yes" xml:space="preserve">
          <source>afterAdd &amp;mdash; is like afterRender, except it is invoked only when new entries are added to your array (and &lt;em&gt;not&lt;/em&gt; when foreach first iterates over your array&amp;rsquo;s initial contents). A common use for afterAdd is to call a method such as jQuery&amp;rsquo;s $(domNode).fadeIn() so that you get animated transitions whenever items are added. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterAdd &amp;mdash; afterRenderに似ていますが、配列に新しいエントリが追加されたときにのみ呼び出されます（foreachが最初に配列の初期コンテンツを反復するときは呼び出され&lt;em&gt;ません&lt;/em&gt;）。afterAddの一般的な用途は、jQueryの$（domNode）.fadeIn（）などのメソッドを呼び出して、アイテムが追加されるたびにアニメーション化された遷移を取得することです。Knockoutは、コールバックに次のパラメーターを提供します。</target>
        </trans-unit>
        <trans-unit id="5875d6886a7574f1c5c1b075f6971a15d98841a2" translate="yes" xml:space="preserve">
          <source>afterMove &amp;mdash; is invoked after an array item has changed position in the array, and after foreach has updated the DOM to match. Note that afterMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterMove &amp;mdash;配列項目が配列内の位置を変更した後、およびforeachが一致するようにDOMを更新した後に呼び出されます。afterMoveは、インデックスが変更されたすべての配列要素に適用されるため、配列の先頭に新しい項目を挿入すると、インデックスの位置が1つ増えているため、他のすべての要素に対してコールバック（指定されている場合）が発生します。Knockoutは、コールバックに次のパラメーターを提供します。</target>
        </trans-unit>
        <trans-unit id="ebb1a50ce7bb74ee728f2eee95c47b413f5bd53d" translate="yes" xml:space="preserve">
          <source>afterRender &amp;mdash; is invoked each time the foreach block is duplicated and inserted into the document, both when foreach first initializes, and when new entries are added to the associated array later. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterRender &amp;mdash; foreachブロックが複製されてドキュメントに挿入されるたびに呼び出されます。これは、foreachが最初に初期化されたとき、および後で関連する配列に新しいエントリが追加されたときの両方です。Knockoutは、コールバックに次のパラメーターを提供します。</target>
        </trans-unit>
        <trans-unit id="e5870134ecf0c0be5c68beda1e34f16544cda8dc" translate="yes" xml:space="preserve">
          <source>afterRender, afterAdd, or beforeRemove &amp;mdash; callback functions to be invoked against the rendered DOM elements - see &lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;Note 4&lt;/a&gt;</source>
          <target state="translated">afterRender、afterAdd、またはbeforeRemove &amp;mdash;レンダリングされたDOM要素に対して呼び出されるコールバック関数- &lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;注4を&lt;/a&gt;参照</target>
        </trans-unit>
        <trans-unit id="b90203ff7ecbf7871ddb8178bb79cea83c9713d2" translate="yes" xml:space="preserve">
          <source>allBindings &amp;mdash; A JavaScript object that you can use to access all the model values bound to this DOM element. Call allBindings.get('name') to retrieve the value of the name binding (returns undefined if the binding doesn&amp;rsquo;t exist); or allBindings.has('name') to determine if the name binding is present for the current element.</source>
          <target state="translated">allBindings &amp;mdash;このDOM要素にバインドされたすべてのモデル値にアクセスするために使用できるJavaScriptオブジェクト。allBindings.get（ 'name'）を呼び出して名前バインディングの値を取得します（バインディングが存在しない場合はundefinedを返します）。またはallBindings.has（ 'name'）は、現在の要素に名前バインディングが存在するかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="0e42813294fc8d28f3ca0881b6187457d3cc1b1f" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;observable&lt;/strong&gt; called items representing a set of items</source>
          <target state="translated">&lt;strong&gt;観測可能な&lt;/strong&gt;アイテムのセットを表すと呼ばれるアイテム</target>
        </trans-unit>
        <trans-unit id="bc46cf26656d742bd5335bdf9b52eddf49a88381" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;computed observable&lt;/strong&gt; that returns true or false depending on whether any of selectedItems has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</source>
          <target state="translated">selectedItemsのいずれかに何らかのプロパティ（新規または未保存など）があるかどうかに応じてtrueまたはfalseを返す別の&lt;strong&gt;計算されたオブザーバブル&lt;/strong&gt;。ボタンなどの一部のUI要素は、この値に基づいて有効または無効になる場合があります。</target>
        </trans-unit>
        <trans-unit id="b76c357ba02c535d132081781d20a66952d6dcc1" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;observable&lt;/strong&gt; called selectedIndexes storing which item indexes have been &amp;lsquo;selected&amp;rsquo; by the user</source>
          <target state="translated">ユーザーが「選択」したアイテムインデックスを保存する、selectedIndexesという別の&lt;strong&gt;オブザーバブル&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd21690b8380b0841426a885d83cab1ab8325f45" translate="yes" xml:space="preserve">
          <source>as &amp;mdash; when used in conjunction with foreach, defines an alias for each item being rendered - see &lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;Note 3&lt;/a&gt; for details.</source>
          <target state="translated">as &amp;mdash; foreachと組み合わせて使用​​すると、レンダリングされる各アイテムのエイリアスを定義します-詳細については、&lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;注3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7a9500f82291e43e9cc92d2055245a5a38e892ea" translate="yes" xml:space="preserve">
          <source>asynchronous updates made as part of the textInput and value binding</source>
          <target state="translated">テキスト入力と値のバインディングの一部として行われる非同期更新</target>
        </trans-unit>
        <trans-unit id="90c55536df6492005a02b302ee99abb278abe315" translate="yes" xml:space="preserve">
          <source>attr binding</source>
          <target state="translated">アトリビューションバインディング</target>
        </trans-unit>
        <trans-unit id="8f5e3f66d7b1824f9fbcb9556a10b1149c3b377c" translate="yes" xml:space="preserve">
          <source>beforeMove &amp;mdash; is invoked when an array item has changed position in the array, but before the corresponding DOM nodes have been moved. Note that beforeMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. You could use beforeMove to store the original screen coordinates of the affected elements so that you can animate their movements in the afterMove callback. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">beforeMove &amp;mdash;配列アイテムが配列内の位置を変更したが、対応するDOMノードが移動する前に呼び出されます。beforeMoveは、インデックスが変更されたすべての配列要素に適用されるため、配列の先頭に新しい項目を挿入すると、インデックスの位置が1つ増えたため、他のすべての要素に対してコールバック（指定されている場合）が発生します。beforeMoveを使用して影響を受ける要素の元の画面座標を保存し、それらの動きをafterMoveコールバックでアニメーション化できます。Knockoutは、コールバックに次のパラメーターを提供します。</target>
        </trans-unit>
        <trans-unit id="3992daaa62b44af106b3c47484f57555aa0b6bb5" translate="yes" xml:space="preserve">
          <source>beforeRemove &amp;mdash; is invoked when an array item has been removed, but before the corresponding DOM nodes have been removed. If you specify a beforeRemove callback, then &lt;em&gt;it becomes your responsibility to remove the DOM nodes&lt;/em&gt;. The obvious use case here is calling something like jQuery&amp;rsquo;s $(domNode).fadeOut() to animate the removal of the corresponding DOM nodes &amp;mdash; in this case, Knockout cannot know how soon it is allowed to physically remove the DOM nodes (who knows how long your animation will take?), so it is up to you to remove them. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">beforeRemove &amp;mdash;配列アイテムが削除されたとき、対応するDOMノードが削除される前に呼び出されます。 beforeRemoveコールバックを指定した場合&lt;em&gt;、DOMノードを削除する必要があります&lt;/em&gt;。ここでの明らかな使用例は、jQueryの$（domNode）.fadeOut（）のようなものを呼び出して、対応するDOMノードの削除をアニメーション化することです。アニメーションには時間がかかりますか？）、削除するかどうかはあなた次第です。 Knockoutは、コールバックに次のパラメーターを提供します。</target>
        </trans-unit>
        <trans-unit id="2eb4c0b60f525fd135163b1ae9de765428f744e2" translate="yes" xml:space="preserve">
          <source>bindingContext &amp;mdash; An object that holds the &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; available to this element&amp;rsquo;s bindings. This object includes special properties including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.</source>
          <target state="translated">bindingContext &amp;mdash; この要素のバインディングで使用可能な&lt;a href=&quot;binding-context&quot;&gt;バインディングコンテキスト&lt;/a&gt;を保持するオブジェクト。このオブジェクトには、このコンテキストの祖先に対してバインドされているデータにアクセスするために使用できる$ parent、$ parents、$ rootなどの特別なプロパティが含まれています。</target>
        </trans-unit>
        <trans-unit id="381b31a682de37484b9fd0f593135748a0b77c19" translate="yes" xml:space="preserve">
          <source>checked binding</source>
          <target state="translated">チェックバインディング</target>
        </trans-unit>
        <trans-unit id="178f138000896f2d7e388a6b20ae521a0f454c9a" translate="yes" xml:space="preserve">
          <source>click binding</source>
          <target state="translated">クリックバインディング</target>
        </trans-unit>
        <trans-unit id="4a22520e4829f157bb92c323abde36645d85a42d" translate="yes" xml:space="preserve">
          <source>component binding</source>
          <target state="translated">コンポーネントバインディング</target>
        </trans-unit>
        <trans-unit id="74588c318ed3e1373d32a16c8b82217c6a9e2c33" translate="yes" xml:space="preserve">
          <source>component loading of a cached component when not configured for &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;synchronous loading&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;同期読み込み用に&lt;/a&gt;構成されていない場合のキャッシュされたコンポーネントのコンポーネント読み込み</target>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">context</target>
        </trans-unit>
        <trans-unit id="47c42e798ee874e6cfcd86804e9bec622c1878b5" translate="yes" xml:space="preserve">
          <source>createViewModel(params, componentInfo) - &lt;strong&gt;Optional.&lt;/strong&gt; A function that will later be called to supply a viewmodel object for each instance of this component</source>
          <target state="translated">createViewModel（params、componentInfo）- &lt;strong&gt;オプション。&lt;/strong&gt;このコンポーネントの各インスタンスのviewmodelオブジェクトを提供するために後で呼び出される関数</target>
        </trans-unit>
        <trans-unit id="df7b59f08733d6664f20aa71e5e0386fdb0dd586" translate="yes" xml:space="preserve">
          <source>css binding</source>
          <target state="translated">CSSバインディング</target>
        </trans-unit>
        <trans-unit id="26be54a22383463c792c869319f96dd9c12860d2" translate="yes" xml:space="preserve">
          <source>data &amp;mdash; an object to supply as the data for the template to render. If you omit this parameter, KO will look for a foreach parameter, or will fall back on using your current model object.</source>
          <target state="translated">data &amp;mdash;テンプレートがレンダリングするデータとして提供するオブジェクト。このパラメーターを省略すると、KOはforeachパラメーターを探すか、現在のモデルオブジェクトを使用してフォールバックします。</target>
        </trans-unit>
        <trans-unit id="2ace213c7cef8b5a242680b74c316a32b95cb054" translate="yes" xml:space="preserve">
          <source>data-bind syntax</source>
          <target state="translated">データバインド構文</target>
        </trans-unit>
        <trans-unit id="34bb93443083edc26cd67b3c2dc4fe14c3dbe694" translate="yes" xml:space="preserve">
          <source>data: The JavaScript object containing the data for this child</source>
          <target state="translated">データを使用しています。この子のデータを含む JavaScript オブジェクト</target>
        </trans-unit>
        <trans-unit id="37d53aab95d0d1b492e4799d7924de18059840ba" translate="yes" xml:space="preserve">
          <source>deferEvaluation &amp;mdash; Optional. If this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</source>
          <target state="translated">deferEvaluation &amp;mdash;オプション。このオプションがtrueの場合、計算されたオブザーバブルの値は、何かが実際にその値にアクセスするか、手動でサブスクライブするまで評価されません。デフォルトでは、計算されたオブザーバブルの値は、作成中にすぐに決定されます。</target>
        </trans-unit>
        <trans-unit id="b9fa8509278c6cb3f2826b8ba5d48e406bb348d7" translate="yes" xml:space="preserve">
          <source>destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</source>
          <target state="translated">destroy と destroyAll (注意:通常は Ruby on Rails 開発者のみに関連する)</target>
        </trans-unit>
        <trans-unit id="53a4c6ac425d3063b86bc1ab2c792b870176f0d5" translate="yes" xml:space="preserve">
          <source>destroy( function (someItem) { return someItem.age &amp;lt; 18; } ) &amp;mdash; Finds any objects in the array whose age property is less than 18, and gives those objects a special property called _destroy with value true.</source>
          <target state="translated">destroy（function（someItem）{return someItem.age &amp;lt;18;}）&amp;mdash; ageプロパティが18未満の配列内のオブジェクトを検索し、それらのオブジェクトに_destroyという名前の特別なプロパティをtrueに設定します。</target>
        </trans-unit>
        <trans-unit id="096f0b56c9676c58652a45daacde73ceec0b98f6" translate="yes" xml:space="preserve">
          <source>destroy( someItem ) &amp;mdash; Finds any objects in the array that equal someItem and gives them a special property called _destroy with value true.</source>
          <target state="translated">destroy（someItem）&amp;mdash; someItemと等しい配列内のすべてのオブジェクトを検索し、値がtrueの_destroyと呼ばれる特別なプロパティを提供します。</target>
        </trans-unit>
        <trans-unit id="fad302ca93de39a8152dfd801b6995ae49e76427" translate="yes" xml:space="preserve">
          <source>destroyAll( ['Chad', 132, undefined] ) &amp;mdash; Finds any objects in the array that equal 'Chad', 123, or undefined and gives them a special property called _destroy with value true.</source>
          <target state="translated">destroyAll（['Chad'、132、undefined]）&amp;mdash;「Chad」、123、またはundefinedと等しい配列内のオブジェクトを検索し、値がtrueの_destroyと呼ばれる特別なプロパティを提供します。</target>
        </trans-unit>
        <trans-unit id="0c040eb253b450db9af8ba7d1cc4c4ceed51a12c" translate="yes" xml:space="preserve">
          <source>destroyAll() &amp;mdash; Gives a special property called _destroy with value true to all objects in the array.</source>
          <target state="translated">destroyAll（）&amp;mdash;配列内のすべてのオブジェクトに値がtrueの_destroyと呼ばれる特別なプロパティを提供します。</target>
        </trans-unit>
        <trans-unit id="d92388626bd61574908cf24a5d84d7ffe24cba8a" translate="yes" xml:space="preserve">
          <source>disable binding</source>
          <target state="translated">バインドを無効にする</target>
        </trans-unit>
        <trans-unit id="04f99f5aa32d4e1d11f627b6330ddd81b87c9a84" translate="yes" xml:space="preserve">
          <source>dispose() &amp;mdash; Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won&amp;rsquo;t be cleaned.</source>
          <target state="translated">dispose（）&amp;mdash;計算されたオブザーバブルを手動で破棄し、依存関係へのすべてのサブスクリプションをクリアします。この関数は、計算されたオブザーバブルの更新を停止する場合や、クリーニングされないオブザーバブルに依存する計算されたオブザーバブルのメモリをクリーンアップする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="02ed7cabc21681b07d4278e4c14c20d3a17e8b0b" translate="yes" xml:space="preserve">
          <source>disposeWhen &amp;mdash; Optional. If given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A true-ish result will trigger disposal of the computed observable.</source>
          <target state="translated">disposeWhen &amp;mdash;オプション。指定されている場合、この関数は各再評価の前に実行され、計算されたオブザーバブルを破棄する必要があるかどうかを決定します。本当のような結果は、計算されたオブザーバブルの破棄をトリガーします。</target>
        </trans-unit>
        <trans-unit id="248f5cb9e1c627a7396078c4ffb6961606c2969b" translate="yes" xml:space="preserve">
          <source>disposeWhenNodeIsRemoved &amp;mdash; Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the template and control-flow bindings.</source>
          <target state="translated">disposeWhenNodeIsRemoved &amp;mdash;オプション。指定された場合、指定されたDOMノードがKOによって削除されたときに、計算されたオブザーバブルの破棄がトリガーされます。この機能は、テンプレートおよび制御フローバインディングによってノードが削除されたときに、バインディングで使用される計算されたオブザーバブルを破棄するために使用されます。</target>
        </trans-unit>
        <trans-unit id="ee8eb5a2c228591905a3602312f95d5295c4df85" translate="yes" xml:space="preserve">
          <source>element &amp;mdash; The DOM element involved in this binding</source>
          <target state="translated">element &amp;mdash;このバインディングに含まれるDOM要素</target>
        </trans-unit>
        <trans-unit id="4859f3f9258067e95015c5768146fc6fdd7df0af" translate="yes" xml:space="preserve">
          <source>enable binding</source>
          <target state="translated">イネーブルバインディング</target>
        </trans-unit>
        <trans-unit id="a254fc2b2604547861a201222e9abc1f8f487b17" translate="yes" xml:space="preserve">
          <source>evaluator &amp;mdash; A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="translated">evaluator &amp;mdash;計算されたオブザーバブルの現在の値を評価するために使用される関数。</target>
        </trans-unit>
        <trans-unit id="09016bc9005f501c49350459275e5548a714be1d" translate="yes" xml:space="preserve">
          <source>event binding</source>
          <target state="translated">イベントバインディング</target>
        </trans-unit>
        <trans-unit id="c3a2e9f3820a8e92022c44f759eb5cbd25a9a0ad" translate="yes" xml:space="preserve">
          <source>event handlers added by ko.utils.registerEventHandler including those bound by the event and click bindings</source>
          <target state="translated">ko.utils.registerEventHandler によって追加されたイベントハンドラ(イベントとクリックのバインディングによってバインドされたものを含む</target>
        </trans-unit>
        <trans-unit id="441a9b8c6e5fb83a5d5904e2015cace1348719af" translate="yes" xml:space="preserve">
          <source>extend(extenders) &amp;mdash; Applies the given &lt;a href=&quot;extenders&quot;&gt;extenders&lt;/a&gt; to the computed observable.</source>
          <target state="translated">extend（extenders）&amp;mdash;指定された&lt;a href=&quot;extenders&quot;&gt;エクステンダー&lt;/a&gt;を計算されたオブザーバブルに適用します。</target>
        </trans-unit>
        <trans-unit id="cd71042eef75a46bae679bea017b7d3dfcc8efba" translate="yes" xml:space="preserve">
          <source>foreach &amp;mdash; instructs KO to render the template in &amp;ldquo;foreach&amp;rdquo; mode - see &lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;Note 2&lt;/a&gt; for details.</source>
          <target state="translated">foreach &amp;mdash;「foreach」モードでテンプレートをレンダリングするようKOに指示します-詳細については&lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;注2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="23b634a4c77edfd882e83d6831db243e019ba4a5" translate="yes" xml:space="preserve">
          <source>foreach binding</source>
          <target state="translated">いちごとじ</target>
        </trans-unit>
        <trans-unit id="05900663008f6a8d4c17b3c024b26ac955efa734" translate="yes" xml:space="preserve">
          <source>getConfig(name, callback)</source>
          <target state="translated">getConfig(name,コールバック)</target>
        </trans-unit>
        <trans-unit id="c490db1820ff63fc6b9af3cb9e098588f2dbf1da" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the current number of dependencies of the computed observable.</source>
          <target state="translated">getDependenciesCount（）&amp;mdash;計算されたオブザーバブルの現在の依存関係の数を返します。</target>
        </trans-unit>
        <trans-unit id="84b6a1fc96c1619898d42781f47554a1b5f0de39" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the number of dependencies of the computed observable detected so far during the current evaluation.</source>
          <target state="translated">getDependenciesCount（）&amp;mdash;現在の評価中にこれまでに検出された計算されたオブザーバブルの依存関係の数を返します。</target>
        </trans-unit>
        <trans-unit id="92edb1e30abbee2fdc76356e034a41321e09a327" translate="yes" xml:space="preserve">
          <source>getSubscriptionsCount( [event] ) &amp;mdash; Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable. Optionally, pass an event name (like &quot;change&quot;) to return just the count of subscriptions for that event.</source>
          <target state="translated">getSubscriptionsCount（[event]）&amp;mdash;計算されたオブザーバブルの（他の計算されたオブザーバブルまたは手動サブスクリプションからの）サブスクリプションの現在の数を返します。必要に応じて、イベント名（「変更」など）を渡して、そのイベントのサブスクリプションの数だけを返します。</target>
        </trans-unit>
        <trans-unit id="e94c9d2e11930e54a96635c7830349bc8bbc5fc1" translate="yes" xml:space="preserve">
          <source>hasFocus binding</source>
          <target state="translated">焦点結合</target>
        </trans-unit>
        <trans-unit id="78501003a54e9c53d78d928bcf94cf00a9b15734" translate="yes" xml:space="preserve">
          <source>html binding</source>
          <target state="translated">htmlバインディング</target>
        </trans-unit>
        <trans-unit id="5767293ed1ea5a45170adafe80d616753ab89d4e" translate="yes" xml:space="preserve">
          <source>if &amp;mdash; if this parameter is provided, the template will only be rendered if the specified expression evaluates to true (or a true-ish value). This can be useful for preventing a null observable from being bound against a template before it is populated.</source>
          <target state="translated">if &amp;mdash;このパラメーターが指定されている場合、テンプレートは、指定された式がtrue（またはtrueっぽい値）と評価された場合にのみレンダリングされます。これは、nullオブザーバブルが入力される前にテンプレートにバインドされるのを防ぐのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="8595778a42da105c7c0cd044962a90ff2d28f8c7" translate="yes" xml:space="preserve">
          <source>if binding</source>
          <target state="translated">拘束力がある場合</target>
        </trans-unit>
        <trans-unit id="703e05e02465cf23455e0519cadf7b85a6baeca8" translate="yes" xml:space="preserve">
          <source>if plays a similar role to &lt;a href=&quot;visible-binding&quot;&gt;the visible binding&lt;/a&gt;. The difference is that, with visible, the contained markup always remains in the DOM and always has its data-bind attributes applied - the visible binding just uses CSS to toggle the container element&amp;rsquo;s visiblity. The if binding, however, physically adds or removes the contained markup in your DOM, and only applies bindings to descendants if the expression is true.</source>
          <target state="translated">&lt;a href=&quot;visible-binding&quot;&gt;目に見えるバインディング&lt;/a&gt;と同様の役割を果たす場合。違いは、可視の場合、含まれるマークアップは常にDOMに残り、常にデータバインド属性が適用されることです。可視のバインディングは、CSSを使用してコンテナー要素の可視性を切り替えるだけです。ただし、ifバインディングは、DOMに含まれるマークアップを物理的に追加または削除し、式がtrueの場合にのみバインディングを子孫に適用します。</target>
        </trans-unit>
        <trans-unit id="369832115815305bb53a2b29db05f53365aa632e" translate="yes" xml:space="preserve">
          <source>ifnot binding</source>
          <target state="translated">縛りがなければ</target>
        </trans-unit>
        <trans-unit id="a35568315c1ca43522c11c18e4a77538f03287b9" translate="yes" xml:space="preserve">
          <source>indexOf</source>
          <target state="translated">indexOf</target>
        </trans-unit>
        <trans-unit id="16c8e78fdbe507804a784e42208f919531155c8d" translate="yes" xml:space="preserve">
          <source>isActive() &amp;mdash; Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</source>
          <target state="translated">isActive（）&amp;mdash;計算されたオブザーバブルが将来更新されるかどうかを返します。依存関係がない場合、計算されたオブザーバブルは非アクティブです。</target>
        </trans-unit>
        <trans-unit id="213f712732355425bb5676b74b023984157a1fc1" translate="yes" xml:space="preserve">
          <source>isInitial() &amp;mdash; A function that returns true if called during the first ever evaluation of the current computed observable, or false otherwise. For &lt;em&gt;pure&lt;/em&gt; computed observables, isInitial() is always undefined.</source>
          <target state="translated">isInitial（）&amp;mdash;現在の計算されたオブザーバブルの最初の評価中に呼び出された場合はtrue、それ以外の場合はfalseを返す関数。以下のために&lt;em&gt;純粋な&lt;/em&gt;計算された観測、isInitial（）は常に定義されていません。</target>
        </trans-unit>
        <trans-unit id="87aad0bc78c46e535fc5dc0237fb0a38695c78b2" translate="yes" xml:space="preserve">
          <source>ko.bindingHandlers.&amp;lt;name&amp;gt;.preprocess(value, name, addBindingCallback)</source>
          <target state="translated">ko.bindingHandlers。&amp;lt;name&amp;gt; .preprocess（value、name、addBindingCallback）</target>
        </trans-unit>
        <trans-unit id="3c1d83117feab81eede2624f7c5f8381d8978da6" translate="yes" xml:space="preserve">
          <source>ko.bindingProvider.instance.preprocessNode(node)</source>
          <target state="translated">ko.bindingProvider.instance.preprocessNode(node)</target>
        </trans-unit>
        <trans-unit id="055225b66db9860a7fdc32f9d0f603bb832d0cfd" translate="yes" xml:space="preserve">
          <source>ko.components.clearCachedDefinition(name)</source>
          <target state="translated">ko.components.clearCachedDefinition(name)</target>
        </trans-unit>
        <trans-unit id="7a279b97657226354a93afb2f4ea4220ffc22e79" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.getConfig(name, callback)</source>
          <target state="translated">ko.components.defaultLoader.getConfig(name,callback)</target>
        </trans-unit>
        <trans-unit id="2459bd18ae1dc7e03d2b20bfd3bf5cb59b715afa" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadComponent(name, componentConfig, callback)</source>
          <target state="translated">ko.components.defaultLoader.loadComponent(name,componentConfig,callback)</target>
        </trans-unit>
        <trans-unit id="16b20060cf28c63034230aa98ea10ad5f2365b12" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadTemplate(name, templateConfig, callback)</source>
          <target state="translated">ko.components.defaultLoader.loadTemplate(name,templateConfig,callback)</target>
        </trans-unit>
        <trans-unit id="21a38533dd3c756e30cf34b8f8ccca46fa822259" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadViewModel(name, viewModelConfig, callback)</source>
          <target state="translated">ko.components.defaultLoader.loadViewModel(name,viewModelConfig,callback)</target>
        </trans-unit>
        <trans-unit id="329d6b1d29362063e6c26807624b008e42dc8a23" translate="yes" xml:space="preserve">
          <source>ko.components.get(name, callback)</source>
          <target state="translated">ko.components.get(name,callback)</target>
        </trans-unit>
        <trans-unit id="807267b5ea3ed18c0e6c441d7bbb7266de4efac9" translate="yes" xml:space="preserve">
          <source>ko.components.isRegistered(name)</source>
          <target state="translated">ko.components.isRegistered(name)</target>
        </trans-unit>
        <trans-unit id="465f62f6b74979963d9063914c13f8f93854ea91" translate="yes" xml:space="preserve">
          <source>ko.components.register(name, configuration)</source>
          <target state="translated">ko.components.register(name,configuration)</target>
        </trans-unit>
        <trans-unit id="aa5bff0c09be54c216270b110f420a227104f8f0" translate="yes" xml:space="preserve">
          <source>ko.components.unregister(name)</source>
          <target state="translated">ko.components.unregister(name)</target>
        </trans-unit>
        <trans-unit id="eb0d870a4e6ad5b29fe16fcf4f027a7e968ff00b" translate="yes" xml:space="preserve">
          <source>ko.computed properties continue to receive notifications from their dependencies until explicitly disposed.</source>
          <target state="translated">ko.computedプロパティは、明示的に破棄されるまで依存関係から通知を受け取り続けます。</target>
        </trans-unit>
        <trans-unit id="9e8f7511dca3b06e70c9faf4aba9d6016334a4e6" translate="yes" xml:space="preserve">
          <source>ko.computed( evaluator [, targetObject, options] ) &amp;mdash; This form supports the most common case of creating a computed observable.</source>
          <target state="translated">ko.computed（evaluator [、targetObject、options]）&amp;mdash;このフォームは、計算されたオブザーバブルを作成する最も一般的なケースをサポートします。</target>
        </trans-unit>
        <trans-unit id="b00774478c790a957ea39251a6fb67eafd152ac0" translate="yes" xml:space="preserve">
          <source>ko.computed( options ) &amp;mdash; This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties.</source>
          <target state="translated">ko.computed（options）&amp;mdash;計算されたオブザーバブルを作成するためのこの単一パラメーターフォームは、次のいずれかのプロパティを持つJavaScriptオブジェクトを受け入れます。</target>
        </trans-unit>
        <trans-unit id="f1c20d087a46710430ae7e74a8957062cb722070" translate="yes" xml:space="preserve">
          <source>ko.computed.fn</source>
          <target state="translated">ko.computed.fn</target>
        </trans-unit>
        <trans-unit id="d26d19c3de9ae466805a8d659a3c953c8c1d0530" translate="yes" xml:space="preserve">
          <source>ko.contextFor(element) - returns the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; that was available to the DOM element.</source>
          <target state="translated">ko.contextFor（element）-DOM要素で使用可能な&lt;a href=&quot;binding-context&quot;&gt;バインディングコンテキスト&lt;/a&gt;全体を返します。</target>
        </trans-unit>
        <trans-unit id="06265ae214e4c7ed0b5122f8c519271d97fbfb8c" translate="yes" xml:space="preserve">
          <source>ko.dataFor(element) - returns the data that was available for binding against the element</source>
          <target state="translated">ko.dataFor(element)-要素に対するバインディングに利用可能なデータを返す</target>
        </trans-unit>
        <trans-unit id="e5ab92cfd76820bc882d2a512801533d3821d30a" translate="yes" xml:space="preserve">
          <source>ko.isComputed &amp;mdash; returns true for all computed observables.</source>
          <target state="translated">ko.isComputed &amp;mdash;計算されたすべてのオブザーバブルに対してtrueを返します。</target>
        </trans-unit>
        <trans-unit id="ba0a8c1361fd16fa684b1945bb04a31e37a75289" translate="yes" xml:space="preserve">
          <source>ko.isObservable &amp;mdash; returns true for observables, observable arrays, and all computed observables.</source>
          <target state="translated">ko.isObservable &amp;mdash;オブザーバブル、オブザーバブル配列、およびすべての計算されたオブザーバブルに対してtrueを返します。</target>
        </trans-unit>
        <trans-unit id="2d026a183086e8ab18f0fea90633d888febdc550" translate="yes" xml:space="preserve">
          <source>ko.isObservable - returns true for observables, observable arrays, and all computed observables.</source>
          <target state="translated">ko.isObservable-観測値、観測可能な配列、そして計算されたすべての観測値に対して true を返します。</target>
        </trans-unit>
        <trans-unit id="33e63cd27e89b9898ebb8e10b0f17a0934ea8e48" translate="yes" xml:space="preserve">
          <source>ko.isPureComputed &amp;mdash; returns true for &lt;em&gt;pure&lt;/em&gt; computed observables.</source>
          <target state="translated">ko.isPureComputed &amp;mdash; &lt;em&gt;純粋に&lt;/em&gt;計算されたオブザーバブルに対してtrueを返します。</target>
        </trans-unit>
        <trans-unit id="0c4edd7fa41dfb49e265401fb4e953fe2f59d5fb" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable &amp;mdash; returns true for observables, observable arrays, and &lt;em&gt;writable&lt;/em&gt; computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="translated">ko.isWritableObservable &amp;mdash;オブザーバブル、オブザーバブル配列、および&lt;em&gt;書き込み可能な&lt;/em&gt;計算されたオブザーバブル（ko.isWriteableObservableとも呼ばれます）に対してtrueを返します。</target>
        </trans-unit>
        <trans-unit id="754ea921da81e0b6e8a76f19d21a38b2fd6b07b5" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable - returns true for observables, observable arrays, and writable computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="translated">ko.isWritableObservable-観測可能な変数、観測可能な配列、書き込み可能な計算された観測可能な変数に対して真を返します(別名 ko.isWriteableObservable)。</target>
        </trans-unit>
        <trans-unit id="e289a906e88ca4290e5d991a93f7c57b8c4684a6" translate="yes" xml:space="preserve">
          <source>ko.observable.fn</source>
          <target state="translated">ko.observable.fn</target>
        </trans-unit>
        <trans-unit id="dc9c8ae3fe7bb15035ebcb2f7a2ce4c354d592de" translate="yes" xml:space="preserve">
          <source>ko.observableArray.fn</source>
          <target state="translated">ko.observableArray.fn</target>
        </trans-unit>
        <trans-unit id="a6f5f5f281a8736bda725dd28aa8d5c4848f7ea9" translate="yes" xml:space="preserve">
          <source>ko.onError</source>
          <target state="translated">ko.onError</target>
        </trans-unit>
        <trans-unit id="106eda8827c7f9a29315d41770f83ea9dfec979e" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( evaluator [, targetObject] ) &amp;mdash; Constructs a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt; using the given evaluator function and optional object to use for this. Unlike ko.computed, this method doesn&amp;rsquo;t accept an options parameter.</source>
          <target state="translated">ko.pureComputed（evaluator [、targetObject]）&amp;mdash;これに使用する指定されたエバリュエーター関数とオプションのオブジェクトを使用して、&lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;純粋に&lt;/em&gt;計算されたオブザーバブル&lt;/a&gt;を構築します。ko.computedとは異なり、このメソッドはオプションパラメータを受け入れません。</target>
        </trans-unit>
        <trans-unit id="7562774ba1edf2db877045ee696268509d532ef8" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( options ) &amp;mdash; Constructs a &lt;em&gt;pure&lt;/em&gt; computed observable using an options object. This accepts the read, write, and owner options described above.</source>
          <target state="translated">ko.pureComputed（options）&amp;mdash; オプションオブジェクトを使用して、&lt;em&gt;純粋に&lt;/em&gt;計算されたオブザーバブルを構築します。これは、上記の読み取り、書き込み、所有者オプションを受け入れます。</target>
        </trans-unit>
        <trans-unit id="ee34b3491247fbedc6018f48a7b0649bf286403f" translate="yes" xml:space="preserve">
          <source>ko.subscribable.fn</source>
          <target state="translated">ko.subscribable.fn</target>
        </trans-unit>
        <trans-unit id="15a6aefd0151368becbda1d0ee853e26ef3e063b" translate="yes" xml:space="preserve">
          <source>ko.tasks.runEarly() &amp;mdash; Call this method to process the current microtask queue on demand, immediately, until it is empty. Besides library integration, you might use this method if you have code that schedules a number of tasks, but then needs to deal with the effects of those tasks synchronously.</source>
          <target state="translated">ko.tasks.runEarly（）&amp;mdash;このメソッドを呼び出して、現在のマイクロタスクキューが空になるまでオンデマンドですぐに処理します。ライブラリの統合に加えて、いくつかのタスクをスケジュールするコードがあるが、それらのタスクの影響を同期的に処理する必要がある場合は、この方法を使用できます。</target>
        </trans-unit>
        <trans-unit id="faa0c0987272811d4ff86131601c71626df34cea" translate="yes" xml:space="preserve">
          <source>ko.tasks.scheduler &amp;mdash; Override this method to redefine or augment how Knockout schedules the event to process and flush the queue. Knockout calls this method when the first task is scheduled, so it must schedule the event and return immediately. For example, if your application is running in Node.js, you might prefer to use process.nextTick for the flush event: ko.tasks.scheduler = process.nextTick;.</source>
          <target state="translated">ko.tasks.scheduler &amp;mdash;このメソッドをオーバーライドして、Knockoutがイベントをスケジュールしてキューを処理およびフラッシュする方法を再定義または拡張します。Knockoutは最初のタスクがスケジュールされたときにこのメソッドを呼び出すため、イベントをスケジュールしてすぐに戻る必要があります。たとえば、アプリケーションがNode.jsで実行されている場合、フラッシュイベントにprocess.nextTickを使用することをお勧めします：ko.tasks.scheduler = process.nextTick;。</target>
        </trans-unit>
        <trans-unit id="72f6e7831d1df86bc87ee07643b98cbfaffdbb89" translate="yes" xml:space="preserve">
          <source>ko.toJS &amp;mdash; this clones your view model&amp;rsquo;s object graph, substituting for each observable the current value of that observable, so you get a plain copy that contains only your data and no Knockout-related artifacts</source>
          <target state="translated">ko.toJS &amp;mdash;これはビューモデルのオブジェクトグラフを複製し、各オブザーバブルの現在の値を代入して、データのみを含み、ノックアウト関連のアーティファクトを含まないプレーンコピーを取得します。</target>
        </trans-unit>
        <trans-unit id="8f921b7a45abcec43b02a6601d9bdc280d40c78e" translate="yes" xml:space="preserve">
          <source>ko.toJSON &amp;mdash; this produces a JSON string representing your view model&amp;rsquo;s data. Internally, it simply calls ko.toJS on your view model, and then uses the browser&amp;rsquo;s native JSON serializer on the result. Note: for this to work on older browsers that have no native JSON serializer (e.g., IE 7 or earlier), you must also reference the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library.</source>
          <target state="translated">ko.toJSON &amp;mdash;これは、ビューモデルのデータを表すJSON文字列を生成します。内部的には、ビューモデルで単にko.toJSを呼び出し、結果に対してブラウザーのネイティブJSONシリアライザーを使用します。注：これがネイティブJSON &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;シリアライザーの&lt;/a&gt;ない古いブラウザー（IE 7以前など）で機能するためには、json2.jsライブラリーも参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="738a8193c3e783c17d50280b2acff5c17c5363ce" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.allowedBindings</source>
          <target state="translated">ko.virtualElements.allowedBindings</target>
        </trans-unit>
        <trans-unit id="3fc144ac6a03bb72f185dbc31fd3e60209cdccfc" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.emptyNode(containerElem)</source>
          <target state="translated">ko.virtualElements.emptyNode(containerElem)</target>
        </trans-unit>
        <trans-unit id="16cb1a0760097250c1d6a57cda17df82d6a63922" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.firstChild(containerElem)</source>
          <target state="translated">ko.virtualElements.firstChild(containerElem)</target>
        </trans-unit>
        <trans-unit id="06073de57d46544971ccb6059851d47ea1ab2fec" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.insertAfter(containerElem, nodeToInsert, insertAfter)</source>
          <target state="translated">ko.virtualElements.insertAfter(containerElem,nodeToInsert,insertAfter)</target>
        </trans-unit>
        <trans-unit id="f0630dc3ec6d4f13606bdea53863015c2cb27263" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.nextSibling(node)</source>
          <target state="translated">ko.virtualElements.nextSibling(node)</target>
        </trans-unit>
        <trans-unit id="fe4347781b95d863c9d53b169d5a53b5a49663ac" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.prepend(containerElem, nodeToPrepend)</source>
          <target state="translated">ko.virtualElements.prepend(containerElem,nodeToPrepend)</target>
        </trans-unit>
        <trans-unit id="e6c8f2823abd2f761611dc1d03bd6be1f6b71b8e" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.setDomNodeChildren(containerElem, arrayOfNodes)</source>
          <target state="translated">ko.virtualElements.setDomNodeChildren(containerElem,arrayOfNodes)</target>
        </trans-unit>
        <trans-unit id="53b7dfcb52da6b0ba4650716e4ca43082f5feafd" translate="yes" xml:space="preserve">
          <source>loadComponent(name, componentConfig, callback)</source>
          <target state="translated">loadComponent(name,componentConfig,callback)</target>
        </trans-unit>
        <trans-unit id="62e20634e40fa347d5ad134f972b15f2c990a759" translate="yes" xml:space="preserve">
          <source>loadTemplate(name, templateConfig, callback)</source>
          <target state="translated">loadTemplate(name,templateConfig,callback)</target>
        </trans-unit>
        <trans-unit id="41fe8394a06084fc87259bbd05c6e913daa937d7" translate="yes" xml:space="preserve">
          <source>loadViewModel(name, templateConfig, callback)</source>
          <target state="translated">loadViewModel(name,templateConfig,callback)</target>
        </trans-unit>
        <trans-unit id="7080dbc7436a18db36408fd6a408608eee003c46" translate="yes" xml:space="preserve">
          <source>mappedDestroy</source>
          <target state="translated">mappedDestroy</target>
        </trans-unit>
        <trans-unit id="5136c37aaef9493efe3b449744ba2f34d4cdcc8b" translate="yes" xml:space="preserve">
          <source>mappedDestroyAll</source>
          <target state="translated">mappedDestroyAll</target>
        </trans-unit>
        <trans-unit id="99002c7fb8b1dacc2772e98e37f191c8d33a1256" translate="yes" xml:space="preserve">
          <source>mappedIndexOf</source>
          <target state="translated">mappedIndexOf</target>
        </trans-unit>
        <trans-unit id="14d1111fd891b47dbe5304a5bf26024c52b381cc" translate="yes" xml:space="preserve">
          <source>mappedRemove</source>
          <target state="translated">mappedRemove</target>
        </trans-unit>
        <trans-unit id="2dca0f36f8e0c0920d22300deffb28e503aeabf5" translate="yes" xml:space="preserve">
          <source>mappedRemoveAll</source>
          <target state="translated">mappedRemoveAll</target>
        </trans-unit>
        <trans-unit id="8615a2284a082e7284f964e699021504000797a2" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the ID of an element that contains the template you wish to render - see &lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;Note 5&lt;/a&gt; for how to vary this programmatically.</source>
          <target state="translated">name &amp;mdash;レンダリングするテンプレートを含む要素のID-これをプログラムで変更する方法については、&lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;注5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="43ae5c03a40af9e524c7f17000f40eab0946953c" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the name of the component to inject. Again, this can be observable.</source>
          <target state="translated">name &amp;mdash;注入するコンポーネントの名前。これも観察できます。</target>
        </trans-unit>
        <trans-unit id="153b716a1c705fc7b577a6d6cc8234a6909f9cc0" translate="yes" xml:space="preserve">
          <source>name: the name of the binding (e.g., for yourBinding: 1 + 1, the name is &quot;yourBinding&quot; as a string).</source>
          <target state="translated">name:バインディングの名前(例:yourBinding:1+1の場合、文字列として &quot;yourBinding &quot;となります)。</target>
        </trans-unit>
        <trans-unit id="fd9f9671fef2600dc7d9a2e2f6ac58059c2cf1e5" translate="yes" xml:space="preserve">
          <source>nodes &amp;mdash; directly pass an array of DOM nodes to use as a template. This should be a non-observable array and note that the elements will be removed from their current parent if they have one. This option is ignored if you have also passed a nonempty value for name.</source>
          <target state="translated">ノード&amp;mdash;テンプレートとして使用するDOMノードの配列を直接渡します。これは監視不能な配列である必要があり、要素がある場合、要素は現在の親から削除されることに注意してください。nameに空でない値も渡した場合、このオプションは無視されます。</target>
        </trans-unit>
        <trans-unit id="ade2fb9bb0e21209a2280976a96721a3984afaaa" translate="yes" xml:space="preserve">
          <source>notifyAtFixedRate &amp;mdash; &lt;strong&gt;Default value if not otherwise specified&lt;/strong&gt;. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</source>
          <target state="translated">notifyAtFixedRate &amp;mdash; &lt;strong&gt;特に指定されていない場合のデフォルト値&lt;/strong&gt;。通知は、最初の変更からオブザーバブルへの指定された期間の後に発生します（最初または前回の通知以降）。</target>
        </trans-unit>
        <trans-unit id="bfc6c7b444c24d6b64a8361cd00dc9091107de87" translate="yes" xml:space="preserve">
          <source>notifyWhenChangesStop &amp;mdash; The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</source>
          <target state="translated">notifyWhenChangesStop &amp;mdash;指定された期間オブザーバブルに変更が発生しなかった後に通知が発生します。オブザーバブルが変更されるたびにそのタイマーはリセットされるため、オブザーバブルがタイムアウト期間よりも頻繁に頻繁に変更される場合、通知は発生しません。</target>
        </trans-unit>
        <trans-unit id="7cf7948331269132eb18cd16d74bca7c9656a62e" translate="yes" xml:space="preserve">
          <source>observable: If the property is an observable, this will be set to the actual observable</source>
          <target state="translated">観測可能なプロパティに設定されます。プロパティがobservableの場合、実際のobservableに設定されます。</target>
        </trans-unit>
        <trans-unit id="3a12abbdbb90d2aa3b8a8824637963734fe18f32" translate="yes" xml:space="preserve">
          <source>observableArray adds some more useful methods that aren&amp;rsquo;t found on JavaScript arrays by default:</source>
          <target state="translated">observableArrayは、デフォルトではJavaScript配列にはない便利なメソッドをいくつか追加します。</target>
        </trans-unit>
        <trans-unit id="c136e98248f5a0b1e7844aac2ff24bd91872be37" translate="yes" xml:space="preserve">
          <source>observableArray exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</source>
          <target state="translated">observableArrayは、配列の内容を変更したり、リスナーに通知するためのおなじみの関数のセットを公開しています。</target>
        </trans-unit>
        <trans-unit id="d313002d790cf1264f49478e1a7e27592448f033" translate="yes" xml:space="preserve">
          <source>observableExpression</source>
          <target state="translated">observableExpression</target>
        </trans-unit>
        <trans-unit id="6ae20630c651e48135794f920e43f6369bd29f8f" translate="yes" xml:space="preserve">
          <source>options &amp;mdash; An object with further properties for the computed observable. See the full list below.</source>
          <target state="translated">options &amp;mdash;計算されたオブザーバブルのその他のプロパティを持つオブジェクト。以下の完全なリストを参照してください。</target>
        </trans-unit>
        <trans-unit id="f6f3cb718d8232f8095093bcd8b8ef4c1e83a310" translate="yes" xml:space="preserve">
          <source>options binding</source>
          <target state="translated">オプションバインディング</target>
        </trans-unit>
        <trans-unit id="c200e46257cc25ebc5150d82eb3ee07b6e38447d" translate="yes" xml:space="preserve">
          <source>optionsAfterRender</source>
          <target state="translated">optionsAfterRender</target>
        </trans-unit>
        <trans-unit id="924bed9ee85f51893b937580ab61c608cdc93818" translate="yes" xml:space="preserve">
          <source>optionsCaption</source>
          <target state="translated">optionsCaption</target>
        </trans-unit>
        <trans-unit id="9dfa9e0a9830d2655b73d8d8deb5640b800c4037" translate="yes" xml:space="preserve">
          <source>optionsIncludeDestroyed</source>
          <target state="translated">optionsIncludeDestroyed</target>
        </trans-unit>
        <trans-unit id="8ae7670102147644c6634d485af1c1fc8805ccfb" translate="yes" xml:space="preserve">
          <source>optionsText</source>
          <target state="translated">optionsText</target>
        </trans-unit>
        <trans-unit id="0d2c0213a91bd297d264f544b41793b3cded6023" translate="yes" xml:space="preserve">
          <source>optionsValue</source>
          <target state="translated">optionsValue</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="98d78190e1c18c8409cc555525dba84fa833eb6e" translate="yes" xml:space="preserve">
          <source>owner &amp;mdash; Optional. If given, defines the value of this whenever KO invokes your read or write callbacks.</source>
          <target state="translated">所有者&amp;mdash;オプション。指定されている場合、KOが読み取りまたは書き込みコールバックを呼び出すたびに、この値を定義します。</target>
        </trans-unit>
        <trans-unit id="a07e95b0cdb77798a52385e0291f03fa5a033510" translate="yes" xml:space="preserve">
          <source>params &amp;mdash; an object that will be passed on to the component. Typically this is a key-value object containing multiple parameters, and is typically received by the component&amp;rsquo;s viewmodel constructor.</source>
          <target state="translated">params &amp;mdash;コンポーネントに渡されるオブジェクト。通常、これは複数のパラメーターを含むKey-Valueオブジェクトであり、通常、コンポーネントのviewmodelコンストラクターによって受信されます。</target>
        </trans-unit>
        <trans-unit id="29fca18badf74bcc82a52bdd8ab473f35ada2a92" translate="yes" xml:space="preserve">
          <source>parent: The parent object or array to which this child belongs</source>
          <target state="translated">parent:この子が属する親オブジェクトまたは配列。</target>
        </trans-unit>
        <trans-unit id="84e2aa7296151d313a34b5208e6160b57faaf939" translate="yes" xml:space="preserve">
          <source>peek() &amp;mdash; Returns the current value of the computed observable without creating a dependency (see the section on &lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt;).</source>
          <target state="translated">peek（）&amp;mdash;依存関係を作成せずに計算されたオブザーバブルの現在の値を返します（&lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt;のセクションを参照）。</target>
        </trans-unit>
        <trans-unit id="7eff74c13ae15cbc418dcf740fe5df3ce50f2c51" translate="yes" xml:space="preserve">
          <source>pop() &amp;mdash; Removes the last value from the array and returns it.</source>
          <target state="translated">pop（）&amp;mdash;配列から最後の値を削除して返します。</target>
        </trans-unit>
        <trans-unit id="1ca69cbe02c25699e6ece62ec814d7791c4911c3" translate="yes" xml:space="preserve">
          <source>pop, push, shift, unshift, reverse, sort, splice</source>
          <target state="translated">ポップ、プッシュ、シフト、アンシフト、リバース、ソート、スプライス</target>
        </trans-unit>
        <trans-unit id="416e762665dd122de1e192dd764a4872244dd057" translate="yes" xml:space="preserve">
          <source>preprocessing</source>
          <target state="translated">preprocessing</target>
        </trans-unit>
        <trans-unit id="4a6b2f0003c223ed4373d59b9044c43a3b0ec52d" translate="yes" xml:space="preserve">
          <source>pure &amp;mdash; Optional. If this option is true, the computed observable will be set up as a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt;. This option is an alternative to the ko.pureComputed constructor.</source>
          <target state="translated">純粋&amp;mdash;オプション。このオプションがtrueの場合、計算されたオブザーバブルは&lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;純粋な&lt;/em&gt;計算されたオブザーバブル&lt;/a&gt;として設定されます。このオプションは、ko.pureComputedコンストラクターの代替です。</target>
        </trans-unit>
        <trans-unit id="8f36b390db7ad00f023d03c9a8e1cd34da7cea23" translate="yes" xml:space="preserve">
          <source>push( value ) &amp;mdash; Adds a new item to the end of array.</source>
          <target state="translated">push（value）&amp;mdash;新しい項目を配列の最後に追加します。</target>
        </trans-unit>
        <trans-unit id="e21048ba125aebf005126df579aa7d684aaa1216" translate="yes" xml:space="preserve">
          <source>rateLimit supports two parameter formats:</source>
          <target state="translated">rateLimitは2つのパラメータ形式をサポートしています。</target>
        </trans-unit>
        <trans-unit id="4139be45f16ffa0fe5e84f6cade922de5f51c46f" translate="yes" xml:space="preserve">
          <source>read &amp;mdash; Required. A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="translated">読み取り&amp;mdash;必須。計算されたオブザーバブルの現在の値を評価するために使用される関数。</target>
        </trans-unit>
        <trans-unit id="e718caf79a7fe0cf6a87d95cc2a7797870e5f1cc" translate="yes" xml:space="preserve">
          <source>remove and removeAll</source>
          <target state="translated">削除して削除してください。</target>
        </trans-unit>
        <trans-unit id="96d8e0f211ec9e71e2ecd7b8f3e6fa85b82a0938" translate="yes" xml:space="preserve">
          <source>remove( function (item) { return item.age &amp;lt; 18; } ) &amp;mdash; Removes all values whose age property is less than 18, and returns them as an array.</source>
          <target state="translated">remove（function（item）{return item.age &amp;lt;18;}）&amp;mdash; ageプロパティが18未満のすべての値を削除し、配列として返します。</target>
        </trans-unit>
        <trans-unit id="8cb74b9b1b5503e58de979117dcb56a32521b991" translate="yes" xml:space="preserve">
          <source>remove( someItem ) &amp;mdash; Removes all values that equal someItem and returns them as an array.</source>
          <target state="translated">remove（someItem）&amp;mdash; someItemと等しいすべての値を削除し、配列として返します。</target>
        </trans-unit>
        <trans-unit id="5d5ddbae3af08573d9f04a58584e212e1b3b6b7e" translate="yes" xml:space="preserve">
          <source>removeAll( ['Chad', 132, undefined] ) &amp;mdash; Removes all values that equal 'Chad', 123, or undefined and returns them as an array.</source>
          <target state="translated">removeAll（['Chad'、132、undefined]）&amp;mdash; 'Chad'、123、またはundefinedに等しいすべての値を削除し、配列として返します。</target>
        </trans-unit>
        <trans-unit id="cc7eba478a0fbf207e7ee5a77ca70f0bbffef7c8" translate="yes" xml:space="preserve">
          <source>removeAll() &amp;mdash; Removes all values and returns them as an array.</source>
          <target state="translated">removeAll（）&amp;mdash;すべての値を削除し、それらを配列として返します。</target>
        </trans-unit>
        <trans-unit id="d0478604d4aea96fd3a393109a2b1037b3e927fd" translate="yes" xml:space="preserve">
          <source>reverse() &amp;mdash; Reverses the order of the array and returns the observableArray (not the underlying array).</source>
          <target state="translated">reverse（）&amp;mdash;配列の順序を逆にして、（基礎となる配列ではなく）observableArrayを返します。</target>
        </trans-unit>
        <trans-unit id="59f2d78389675b86fdc3ff8aa20480298ed96edf" translate="yes" xml:space="preserve">
          <source>scripts/appViewModel.js</source>
          <target state="translated">scripts/appViewModel.js</target>
        </trans-unit>
        <trans-unit id="3d86e3a05ce2d4beabae39286b9e1f21797e0cc4" translate="yes" xml:space="preserve">
          <source>scripts/init.js</source>
          <target state="translated">scripts/init.js</target>
        </trans-unit>
        <trans-unit id="8ca245bc231e1ea924af9ce333849af65afcced1" translate="yes" xml:space="preserve">
          <source>selectedOptions</source>
          <target state="translated">selectedOptions</target>
        </trans-unit>
        <trans-unit id="0cc4bc27e43d8c540c56bb29619529b32d7e1d78" translate="yes" xml:space="preserve">
          <source>selectedOptions binding</source>
          <target state="translated">せんたくオプションバインディング</target>
        </trans-unit>
        <trans-unit id="c1de595d71ffb6e5bfd55b59347f3a99defa5aa3" translate="yes" xml:space="preserve">
          <source>setInterval callbacks will continue to fire until explicitly cleared.</source>
          <target state="translated">setIntervalコールバックは、明示的にクリアされるまで実行され続けます。</target>
        </trans-unit>
        <trans-unit id="0e0977525af7bb738c2d7f294371eb114a5f9172" translate="yes" xml:space="preserve">
          <source>shift() &amp;mdash; Removes the first value from the array and returns it.</source>
          <target state="translated">shift（）&amp;mdash;配列から最初の値を削除して返します。</target>
        </trans-unit>
        <trans-unit id="88fbb170c082bb72bb147471c70547512b13611a" translate="yes" xml:space="preserve">
          <source>simpleExpression</source>
          <target state="translated">simpleExpression</target>
        </trans-unit>
        <trans-unit id="88f11ced9c5850c42b7ad4f6655dbd9d58dbd3c2" translate="yes" xml:space="preserve">
          <source>simpleObservable</source>
          <target state="translated">simpleObservable</target>
        </trans-unit>
        <trans-unit id="0a5228e66df38e2f27ca61b901edf86f7ef97fb8" translate="yes" xml:space="preserve">
          <source>slice</source>
          <target state="translated">slice</target>
        </trans-unit>
        <trans-unit id="56ab5e4c42113718cabb807a70d36218e826aaf4" translate="yes" xml:space="preserve">
          <source>sort() &amp;mdash; Sorts the array contents and returns the observableArray.</source>
          <target state="translated">sort（）&amp;mdash;配列の内容をソートして、observableArrayを返します。</target>
        </trans-unit>
        <trans-unit id="42b90ae0a8b7cade6771bd136b879de650e1c97a" translate="yes" xml:space="preserve">
          <source>splice() &amp;mdash; Removes and returns a given number of elements starting from a given index. For example, myObservableArray.splice(1, 3) removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</source>
          <target state="translated">splice（）&amp;mdash;指定されたインデックスから始まる指定された数の要素を削除して返します。たとえば、myObservableArray.splice（1、3）は、インデックス位置1から始まる3つの要素（つまり、2番目、3番目、4番目の要素）を削除し、それらを配列として返します。</target>
        </trans-unit>
        <trans-unit id="6253e860960f6bbaedffe4b667c89e216110d409" translate="yes" xml:space="preserve">
          <source>style binding</source>
          <target state="translated">スタイルバインディング</target>
        </trans-unit>
        <trans-unit id="8779e91de4557c0e390ed1fb33b2e709310a78a8" translate="yes" xml:space="preserve">
          <source>submit binding</source>
          <target state="translated">拘束力を与える</target>
        </trans-unit>
        <trans-unit id="820fbe076d0fd7d9855c3332a110247db7d06ef6" translate="yes" xml:space="preserve">
          <source>subscribe( callback [,callbackTarget, event] ) &amp;mdash; Registers a &lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;manual subscription&lt;/a&gt; to be notified of changes to the computed observable.</source>
          <target state="translated">subscribe（callback [、callbackTarget、event]）&amp;mdash; 計算されたオブザーバブルへの変更を通知する&lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;手動サブスクリプション&lt;/a&gt;を登録します。</target>
        </trans-unit>
        <trans-unit id="dafd82441d770fee53da532cf0cc778383385fe6" translate="yes" xml:space="preserve">
          <source>targetObject &amp;mdash; If given, defines the value of this whenever KO invokes your callback functions. See the section on &lt;a href=&quot;computedobservables#managing-this&quot;&gt;managing this&lt;/a&gt; for more information.</source>
          <target state="translated">targetObject &amp;mdash;指定された場合、KOがコールバック関数を呼び出すたびに、この値を定義します。詳細については、&lt;a href=&quot;computedobservables#managing-this&quot;&gt;これの管理&lt;/a&gt;に関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3c94ad78a19fe31d36596c68497f86eec7b1c3d9" translate="yes" xml:space="preserve">
          <source>template - &lt;strong&gt;Required.&lt;/strong&gt; An array of DOM nodes</source>
          <target state="translated">テンプレート- &lt;strong&gt;必須。&lt;/strong&gt;DOMノードの配列</target>
        </trans-unit>
        <trans-unit id="253d1a2eda05db9287d0590f7c3d7acab99953a0" translate="yes" xml:space="preserve">
          <source>template binding</source>
          <target state="translated">テンプレートバインディング</target>
        </trans-unit>
        <trans-unit id="6e4853d9a9512e127ea4b62e7f52af33fc271c3f" translate="yes" xml:space="preserve">
          <source>template is required, and can take any of &lt;a href=&quot;#specifying-a-template&quot;&gt;the template formats described below&lt;/a&gt;.</source>
          <target state="translated">テンプレートは必須であり、&lt;a href=&quot;#specifying-a-template&quot;&gt;以下で説明するテンプレート形式の&lt;/a&gt;いずれかを取ることができます。</target>
        </trans-unit>
        <trans-unit id="da65429399cce754285fdbcec2552149cb86a956" translate="yes" xml:space="preserve">
          <source>text binding</source>
          <target state="translated">テキストバインディング</target>
        </trans-unit>
        <trans-unit id="adf56df0f3eb83ef4e28a07bf6ef6a5225f02b82" translate="yes" xml:space="preserve">
          <source>textInput binding</source>
          <target state="translated">テキスト入力結合</target>
        </trans-unit>
        <trans-unit id="b2b2c593b67fd9c750a7b4dc7bc74905c48586e7" translate="yes" xml:space="preserve">
          <source>uniqueName binding</source>
          <target state="translated">ユニークネームバインディング</target>
        </trans-unit>
        <trans-unit id="c16c416b43e2a2e26766a7d93713d6642892d606" translate="yes" xml:space="preserve">
          <source>unshift( value ) &amp;mdash; Inserts a new item at the beginning of the array.</source>
          <target state="translated">unshift（value）&amp;mdash;配列の先頭に新しいアイテムを挿入します。</target>
        </trans-unit>
        <trans-unit id="69376c529d40f826b3d0595aee8c136c0af54867" translate="yes" xml:space="preserve">
          <source>value binding</source>
          <target state="translated">値縛り</target>
        </trans-unit>
        <trans-unit id="e7253474b4d3ffd33c594b51d8119d43a0bb6bba" translate="yes" xml:space="preserve">
          <source>value, by default, only updates your model when the user moves focus out of the text box. textInput updates your model immediately on each keystroke or other text entry mechanism (such as cutting or dragging text, which don&amp;rsquo;t necessarily raise any focus change events).</source>
          <target state="translated">値は、デフォルトでは、ユーザーがテキストボックスからフォーカスを移動したときにのみモデルを更新します。textInputは、キーストロークまたはその他のテキスト入力メカニズム（テキストの切り取りやドラッグなど、必ずしもフォーカス変更イベントを発生させる必要はない）が発生するとすぐにモデルを更新します。</target>
        </trans-unit>
        <trans-unit id="0315000a3f53e1c0a46b78819975a5d6ad678ede" translate="yes" xml:space="preserve">
          <source>value: the syntax associated with the binding value before Knockout attempts to parse it (e.g., for yourBinding: 1 + 1, the associated value is &quot;1 + 1&quot; as a string).</source>
          <target state="translated">value:Knockout が解析を試みる前のバインディング値に関連付けられた構文 (例:yourBinding:1+1 の場合、関連付けられた値は文字列として &quot;1+1&quot; となります)。</target>
        </trans-unit>
        <trans-unit id="4c6bf64e230167a81d331f0e53be657f29268a03" translate="yes" xml:space="preserve">
          <source>valueAccessor &amp;mdash; A JavaScript function that you can call to get the current model property that is involved in this binding. Call this without passing any parameters (i.e., call valueAccessor()) to get the current model property value. To easily accept both observable and plain values, call ko.unwrap on the returned value.</source>
          <target state="translated">valueAccessor &amp;mdash;このバインディングに関係する現在のモデルプロパティを取得するために呼び出すことができるJavaScript関数。現在のモデルプロパティ値を取得するには、パラメーターを渡さずにこれを呼び出します（つまり、valueAccessor（）を呼び出します）。監視可能な値とプレーンな値の両方を簡単に受け入れるには、戻り値でko.unwrapを呼び出します。</target>
        </trans-unit>
        <trans-unit id="09d6bee9bf5ab035edcf3bdb1c2d3ca252cab50d" translate="yes" xml:space="preserve">
          <source>valueAllowUnset</source>
          <target state="translated">valueAllowUnset</target>
        </trans-unit>
        <trans-unit id="3b9eeb08f6cc0027bfae1d6ae33f6eec82fa4980" translate="yes" xml:space="preserve">
          <source>valueUpdate</source>
          <target state="translated">valueUpdate</target>
        </trans-unit>
        <trans-unit id="85d24d98408f285817ccc63b116e75becf9bfb63" translate="yes" xml:space="preserve">
          <source>viewModel &amp;mdash; This parameter is deprecated in Knockout 3.x. Use bindingContext.$data or bindingContext.$rawData to access the view model instead.</source>
          <target state="translated">viewModel &amp;mdash;このパラメーターはKnockout 3.xでは非推奨です。代わりに、bindingContext。$ dataまたはbindingContext。$ rawDataを使用してビューモデルにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="7d9112700ef264af454bd57cf55fc6e70b23ecbc" translate="yes" xml:space="preserve">
          <source>viewModel is optional, and can take any of &lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;the viewModel formats described below&lt;/a&gt;.</source>
          <target state="translated">viewModelはオプションであり、&lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;以下で説明する&lt;/a&gt;任意のviewModel形式を取ることができます。</target>
        </trans-unit>
        <trans-unit id="7eea042fe202adb1f0ad66ed57626d9b9dcd238a" translate="yes" xml:space="preserve">
          <source>visible binding</source>
          <target state="translated">可視結合</target>
        </trans-unit>
        <trans-unit id="012cd28b54d4dcfd92ef8c4dccc2bb3476547a20" translate="yes" xml:space="preserve">
          <source>with binding</source>
          <target state="translated">縛り付き</target>
        </trans-unit>
        <trans-unit id="342fd4ebade4bf72ed7582148a5b0cdbca608bfe" translate="yes" xml:space="preserve">
          <source>write &amp;mdash; Optional. If given, makes the computed observable &lt;em&gt;writable&lt;/em&gt;. This is a function that receives values that other code is trying to write to your computed observable. It&amp;rsquo;s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</source>
          <target state="translated">書き込み&amp;mdash;オプション。指定された場合、計算された監視&lt;em&gt;可能を書き込み可能にし&lt;/em&gt;ます。これは、他のコードが計算されたオブザーバブルに書き込もうとしている値を受け取る関数です。受信した値を処理するカスタムロジックを提供するのは、通常、値をいくつかの基礎となる監視可能オブジェクトに書き込むことによります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
