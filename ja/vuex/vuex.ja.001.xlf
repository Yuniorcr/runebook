<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="vuex">
    <body>
      <group id="vuex">
        <trans-unit id="a9b529393c3179a77a9306c183468564863d0ff0" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;present Evan You</source>
          <target state="translated">&amp;copy;2015&amp;ndash;present Evan You</target>
        </trans-unit>
        <trans-unit id="3dbca386b3bf4c0c03ea3c64d065f726c26a64b7" translate="yes" xml:space="preserve">
          <source>1. Installation</source>
          <target state="translated">1.設置方法</target>
        </trans-unit>
        <trans-unit id="7644d763c0c7ace9ff19d36e4552b445a389efe0" translate="yes" xml:space="preserve">
          <source>10. Strict Mode</source>
          <target state="translated">10.厳格なモード</target>
        </trans-unit>
        <trans-unit id="290258555d6677c0ac84626e214aa009f8a85e64" translate="yes" xml:space="preserve">
          <source>11. Form Handling</source>
          <target state="translated">11.フォームの取り扱い</target>
        </trans-unit>
        <trans-unit id="4129c08ad5f758bb8883f75f714cc03d6b8724d7" translate="yes" xml:space="preserve">
          <source>12. Testing</source>
          <target state="translated">12.テスト</target>
        </trans-unit>
        <trans-unit id="528a3b9b2d03ca80ea557ac5c60aa567789512ff" translate="yes" xml:space="preserve">
          <source>13. Hot Reloading</source>
          <target state="translated">13.ホットリロード</target>
        </trans-unit>
        <trans-unit id="dbc8b357691409e9c4daf2c6428dbe68446dc47c" translate="yes" xml:space="preserve">
          <source>2. Getting Started</source>
          <target state="translated">2.はじめに</target>
        </trans-unit>
        <trans-unit id="999bcc9c65f419d4177fbc85fb43d8d53350ea26" translate="yes" xml:space="preserve">
          <source>3. State</source>
          <target state="translated">3.状態</target>
        </trans-unit>
        <trans-unit id="86901adbf99889e89f6fb5664ba644ee179d5895" translate="yes" xml:space="preserve">
          <source>4. Getters</source>
          <target state="translated">4.ゲッターズ</target>
        </trans-unit>
        <trans-unit id="f5dd21d6df4b83ebbdd0d793bd18c24ecafd3d6a" translate="yes" xml:space="preserve">
          <source>5. Mutations</source>
          <target state="translated">5.変異</target>
        </trans-unit>
        <trans-unit id="d2db7e791345bd3756bb20faaf9a14d8b1ca6e1d" translate="yes" xml:space="preserve">
          <source>6. Actions</source>
          <target state="translated">6.アクション</target>
        </trans-unit>
        <trans-unit id="311b202ab670d27bdcb3786803bee13f6ac0dd04" translate="yes" xml:space="preserve">
          <source>7. Modules</source>
          <target state="translated">7.モジュール</target>
        </trans-unit>
        <trans-unit id="5b2c110974e654cf654a583f99f4466b77ffad4a" translate="yes" xml:space="preserve">
          <source>8. Application Structure</source>
          <target state="translated">8.アプリケーションの構造</target>
        </trans-unit>
        <trans-unit id="35fca60c7ce35ec44954758baa9845c6764c93f3" translate="yes" xml:space="preserve">
          <source>9. Plugins</source>
          <target state="translated">9.プラグイン</target>
        </trans-unit>
        <trans-unit id="e491a21fa71516f2b26e081f14ece268b038b5c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt; provides NPM-based CDN links. The above link will always point to the latest release on NPM. You can also use a specific version/tag via URLs like &lt;code&gt;https://unpkg.com/vuex@2.0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt;は、NPMベースのCDNリンクを提供します。上記のリンクは常にNPMの最新リリースを指します。 &lt;code&gt;https://unpkg.com/vuex@2.0.0&lt;/code&gt; のようなURLを介して特定のバージョン/タグを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="140249cc0098c39ea9eee2f348b83aec84aeaea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;preserveState: true&lt;/code&gt; that allows to preserve the previous state. Useful with Server Side Rendering.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; は、 &lt;code&gt;preserveState: true&lt;/code&gt; を指定して、以前の状態を保持することができます。サーバー側レンダリングで役立ちます。</target>
        </trans-unit>
        <trans-unit id="93bc29b6324b7d1ed0dc681c2aa882c85b026c76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not enable strict mode when deploying for production!&lt;/strong&gt; Strict mode runs a synchronous deep watcher on the state tree for detecting inappropriate mutations, and it can be quite expensive when you make large amount of mutations to the state. Make sure to turn it off in production to avoid the performance cost.</source>
          <target state="translated">&lt;strong&gt;本番環境にデプロイするときは、厳密モードを有効にしないでください！&lt;/strong&gt;Strictモードは、状態ツリーで同期ディープウォッチャーを実行して不適切な変異を検出します。状態に対して大量の変異を行うと、非常にコストがかかる可能性があります。パフォーマンスコストを回避するために、本番環境では必ずオフにしてください。</target>
        </trans-unit>
        <trans-unit id="9f9016c15f9b85d16a456b0a8fed9e60d27f0c18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; We will be using ES2015 syntax for code examples for the rest of the docs. If you haven't picked it up, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;you should&lt;/a&gt;!</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;残りのドキュメントのコード例にはES2015構文を使用します。あなたがそれを拾っていないなら、&lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;あなたはすべき&lt;/a&gt;です！</target>
        </trans-unit>
        <trans-unit id="543738af7550fb2b326fb4aec1d84822e5d85d47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins that take state snapshots should be used only during development.&lt;/strong&gt; When using webpack or Browserify, we can let our build tools handle that for us:</source>
          <target state="translated">&lt;strong&gt;状態のスナップショットを取得するプラグインは、開発中にのみ使用する必要があります。&lt;/strong&gt;webpackまたはBrowserifyを使用する場合、ビルドツールで処理できます。</target>
        </trans-unit>
        <trans-unit id="152494aaef0de9abdd755c1e397ccd919faab73b" translate="yes" xml:space="preserve">
          <source>A more practical example of real-world actions would be an action to checkout a shopping cart, which involves &lt;strong&gt;calling an async API&lt;/strong&gt; and &lt;strong&gt;committing multiple mutations&lt;/strong&gt;:</source>
          <target state="translated">実際のアクションのより実用的な例は、ショッピングカートをチェックアウトするアクションです。これには&lt;strong&gt;、非同期APIの呼び出し&lt;/strong&gt;と&lt;strong&gt;複数の変更のコミット&lt;/strong&gt;が含まれ&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API リファレンス</target>
        </trans-unit>
        <trans-unit id="5f613656881e083dfef9e6ff61f4361ce0a8891f" translate="yes" xml:space="preserve">
          <source>Accessing Global Assets in Namespaced Modules</source>
          <target state="translated">名前空間モジュールでのグローバル資産へのアクセス</target>
        </trans-unit>
        <trans-unit id="0d5c235f81dfbc7a38598e493ee1ecf48d2948cf" translate="yes" xml:space="preserve">
          <source>Action handlers receive a context object which exposes the same set of methods/properties on the store instance, so you can call &lt;code&gt;context.commit&lt;/code&gt; to commit a mutation, or access the state and getters via &lt;code&gt;context.state&lt;/code&gt; and &lt;code&gt;context.getters&lt;/code&gt;. We can even call other actions with &lt;code&gt;context.dispatch&lt;/code&gt;. We will see why this context object is not the store instance itself when we introduce &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; later.</source>
          <target state="translated">アクションハンドラーは、ストアインスタンスの同じメソッド/プロパティのセットを公開するコンテキストオブジェクトを受け取るため、 &lt;code&gt;context.commit&lt;/code&gt; を呼び出して変更をコミットするか、 &lt;code&gt;context.state&lt;/code&gt; および &lt;code&gt;context.getters&lt;/code&gt; を介して状態とゲッターにアクセスできます。 &lt;code&gt;context.dispatch&lt;/code&gt; で他のアクションを呼び出すこともできます。後で&lt;a href=&quot;modules&quot;&gt;モジュール&lt;/a&gt;を紹介するときに、このコンテキストオブジェクトがストアインスタンス自体ではない理由を確認します。</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="fd2b38844159f4c8bd1a540f724142f21bcb2783" translate="yes" xml:space="preserve">
          <source>Actions are often asynchronous, so how do we know when an action is done? And more importantly, how can we compose multiple actions together to handle more complex async flows?</source>
          <target state="translated">アクションは非同期であることが多いので、どのようにしてアクションが完了したかを知ることができるのでしょうか?さらに重要なことは、より複雑な非同期フローを処理するために、複数のアクションをどのように組み合わせることができるかということです。</target>
        </trans-unit>
        <trans-unit id="eebbe3f939d0e7eb5a702bddfd2a09d58662a331" translate="yes" xml:space="preserve">
          <source>Actions are similar to mutations, the differences being that:</source>
          <target state="translated">行動は突然変異と似ていますが、違いはそれだけです。</target>
        </trans-unit>
        <trans-unit id="2fb7f3eefbb910c724298c1fe2f73e2dd2775642" translate="yes" xml:space="preserve">
          <source>Actions are triggered with the &lt;code&gt;store.dispatch&lt;/code&gt; method:</source>
          <target state="translated">アクションは、 &lt;code&gt;store.dispatch&lt;/code&gt; メソッドでトリガーされます。</target>
        </trans-unit>
        <trans-unit id="e0710bf63012535b6c8d8716b3dcac5cf1237306" translate="yes" xml:space="preserve">
          <source>Actions can be a bit more tricky because they may call out to external APIs. When testing actions, we usually need to do some level of mocking - for example, we can abstract the API calls into a service and mock that service inside our tests. In order to easily mock dependencies, we can use webpack and &lt;a href=&quot;https://github.com/plasticine/inject-loader&quot;&gt;inject-loader&lt;/a&gt; to bundle our test files.</source>
          <target state="translated">アクションは外部APIを呼び出す可能性があるため、少しトリッキーになる可能性があります。アクションをテストするときは、通常、ある程度のモックを行う必要があります。たとえば、API呼び出しをサービスに抽象化し、テスト内でそのサービスをモックすることができます。依存関係を簡単に模擬するために、webpackと&lt;a href=&quot;https://github.com/plasticine/inject-loader&quot;&gt;inject-loader&lt;/a&gt;を使用してテストファイルをバンドルできます。</target>
        </trans-unit>
        <trans-unit id="5b7eca18a813d34c8aa01e8ef07ee7519aaf8e37" translate="yes" xml:space="preserve">
          <source>Actions can contain arbitrary asynchronous operations.</source>
          <target state="translated">アクションは任意の非同期操作を含むことができます。</target>
        </trans-unit>
        <trans-unit id="20c41c87b2101245945eb4d510d08709af6ca47f" translate="yes" xml:space="preserve">
          <source>Actions from different views may need to mutate the same piece of state.</source>
          <target state="translated">異なるビューからのアクションは、同じ状態の部分を変異させる必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="cc658d581fafc63b17159bbd703e4b6ae9e6654d" translate="yes" xml:space="preserve">
          <source>Actions support the same payload format and object-style dispatch:</source>
          <target state="translated">アクションは、同じペイロード形式とオブジェクトスタイルのディスパッチをサポートしています。</target>
        </trans-unit>
        <trans-unit id="e6f1f5e24996a891b4012e435efadfe597fd76af" translate="yes" xml:space="preserve">
          <source>Admittedly, the above is quite a bit more verbose than &lt;code&gt;v-model&lt;/code&gt; + local state, and we lose some of the useful features from &lt;code&gt;v-model&lt;/code&gt; as well. An alternative approach is using a two-way computed property with a setter:</source>
          <target state="translated">確かに、上記のかなりより冗長よりも &lt;code&gt;v-model&lt;/code&gt; +ローカルの状態、そして私たちは、から便利な機能の一部を失う &lt;code&gt;v-model&lt;/code&gt; としても。別のアプローチは、セッターで双方向の計算されたプロパティを使用することです：</target>
        </trans-unit>
        <trans-unit id="1202f0740ed7d8ae90a711fe902caaa8f08e09b3" translate="yes" xml:space="preserve">
          <source>After &lt;a href=&quot;../installation&quot;&gt;installing&lt;/a&gt; Vuex, let's create a store. It is pretty straightforward - just provide an initial state object, and some mutations:</source>
          <target state="translated">後は&lt;a href=&quot;../installation&quot;&gt;インストール&lt;/a&gt; Vuexを、のは、ストアを作成してみましょう。それは非常に簡単です-初期状態オブジェクトといくつかの変更を提供するだけです：</target>
        </trans-unit>
        <trans-unit id="a38a6afdb72dbde1dead2d25ed43a801e44eeba7" translate="yes" xml:space="preserve">
          <source>Again, the reason we are committing a mutation instead of changing &lt;code&gt;store.state.count&lt;/code&gt; directly, is because we want to explicitly track it. This simple convention makes your intention more explicit, so that you can reason about state changes in your app better when reading the code. In addition, this gives us the opportunity to implement tools that can log every mutation, take state snapshots, or even perform time travel debugging.</source>
          <target state="translated">繰り返しますが、 &lt;code&gt;store.state.count&lt;/code&gt; を直接変更するのではなく、ミューテーションをコミットする理由は、明示的に追跡したいためです。この単純な規則により、意図がより明確になり、コードを読み取るときにアプリの状態変更をより適切に推論できるようになります。さらに、これにより、すべての変更をログに記録したり、状態のスナップショットを撮ったり、タイムトラベルデバッグを実行したりできるツールを実装する機会が得られます。</target>
        </trans-unit>
        <trans-unit id="321cdc14e97d2ee50f5d65dc4d313dcb119e79c0" translate="yes" xml:space="preserve">
          <source>Also, inside module getters, the root state will be exposed as their 3rd argument:</source>
          <target state="translated">また、モジュールゲッターの内部では、ルートの状態が第3引数として公開されます。</target>
        </trans-unit>
        <trans-unit id="2eee5b4fbbc1f54a27e6412f36e8fc0250ed0ca4" translate="yes" xml:space="preserve">
          <source>An alternative way to commit a mutation is by directly using an object that has a &lt;code&gt;type&lt;/code&gt; property:</source>
          <target state="translated">変異をコミットする別の方法は、 &lt;code&gt;type&lt;/code&gt; プロパティを持つオブジェクトを直接使用することです。</target>
        </trans-unit>
        <trans-unit id="c5bfc0baa5cb6ec7b1c1c279caffbe5d5b8218a2" translate="yes" xml:space="preserve">
          <source>An array of plugin functions to be applied to the store. The plugin simply receives the store as the only argument and can either listen to mutations (for outbound data persistence, logging, or debugging) or dispatch mutations (for inbound data e.g. websockets or observables).</source>
          <target state="translated">ストアに適用されるプラグイン関数の配列。プラグインは単にストアを唯一の引数として受け取り、突然変異 (アウトバウンドデータの永続化、ロギング、デバッグのため)をリッスンするか、突然変異 (ウェブソケットやオブザーバブルなどのインバウンドデータのため)をディスパッチすることができます。</target>
        </trans-unit>
        <trans-unit id="6b626f3c447742f2fad682725d05b28250d88b5f" translate="yes" xml:space="preserve">
          <source>An object containing sub modules to be merged into the store, in the shape of:</source>
          <target state="translated">ストアにマージするサブモジュールを含むオブジェクトを、形にしたもの。</target>
        </trans-unit>
        <trans-unit id="dc46a43c367676022711c845ac16cc5387d782f6" translate="yes" xml:space="preserve">
          <source>And also in another action:</source>
          <target state="translated">また、別のアクションでも</target>
        </trans-unit>
        <trans-unit id="4db792123502a659fd37a4ca852f43e15ee1ef57" translate="yes" xml:space="preserve">
          <source>And also receives a second &lt;code&gt;payload&lt;/code&gt; argument if there is one.</source>
          <target state="translated">また、2番目の &lt;code&gt;payload&lt;/code&gt; 引数がある場合は、それも受け取ります。</target>
        </trans-unit>
        <trans-unit id="6eb1eaafd8f229821b275541a054f723a80d42bf" translate="yes" xml:space="preserve">
          <source>And can be used like this:</source>
          <target state="translated">そして、このように使用することができます。</target>
        </trans-unit>
        <trans-unit id="fe2969186d8cff2f758236d5c540ae4e48a2d751" translate="yes" xml:space="preserve">
          <source>And here's the mutation handler:</source>
          <target state="translated">そして、これが突然変異ハンドラです。</target>
        </trans-unit>
        <trans-unit id="d71de8152541f4a1b7fda48b87f3fe315656e14c" translate="yes" xml:space="preserve">
          <source>Application Structure</source>
          <target state="translated">アプリケーションの構造</target>
        </trans-unit>
        <trans-unit id="2ba5dece67f8efdf3c81bb9be56daf28e8655190" translate="yes" xml:space="preserve">
          <source>Application-level state is centralized in the store.</source>
          <target state="translated">アプリケーションレベルの状態はストアに集中しています。</target>
        </trans-unit>
        <trans-unit id="84a169df16a0c175be12b4d7b1cd59df717591a1" translate="yes" xml:space="preserve">
          <source>As a reference, check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart&quot;&gt;Shopping Cart Example&lt;/a&gt;.</source>
          <target state="translated">参考として、&lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart&quot;&gt;ショッピングカートの例をご覧&lt;/a&gt;ください。</target>
        </trans-unit>
        <trans-unit id="90a44e426a7e60755b1c84d1d390da1cb4f500d2" translate="yes" xml:space="preserve">
          <source>As long as you follow these rules, it's up to you how to structure your project. If your store file gets too big, simply start splitting the actions, mutations and getters into separate files.</source>
          <target state="translated">これらのルールに従う限り、プロジェクトをどのように構成するかはあなた次第です。ストアファイルが大きくなりすぎたら、アクション、ミューテーション、ゲッターを別々のファイルに分割してください。</target>
        </trans-unit>
        <trans-unit id="5dfd062060191d75d85aa467d9473a70ac205ad2" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;obj&lt;/code&gt; is a computed property that returns an Object from the store, the &lt;code&gt;v-model&lt;/code&gt; here will attempt to directly mutate &lt;code&gt;obj.message&lt;/code&gt; when the user types in the input. In strict mode, this will result in an error because the mutation is not performed inside an explicit Vuex mutation handler.</source>
          <target state="translated">仮定 &lt;code&gt;obj&lt;/code&gt; がストアから戻るオブジェクト、こと計算特性である &lt;code&gt;v-model&lt;/code&gt; ここでは直接変異させる試みる &lt;code&gt;obj.message&lt;/code&gt; とき入力におけるユーザタイプ。厳密モードでは、ミューテーションは明示的なVuexミューテーションハンドラ内で実行されないため、これはエラーになります。</target>
        </trans-unit>
        <trans-unit id="6d84d9b230182d02f5132507784662fee81bd183" translate="yes" xml:space="preserve">
          <source>Asynchronicity combined with state mutation can make your program very hard to reason about. For example, when you call two methods both with async callbacks that mutate the state, how do you know when they are called and which callback was called first? This is exactly why we want to separate the two concepts. In Vuex, &lt;strong&gt;mutations are synchronous transactions&lt;/strong&gt;:</source>
          <target state="translated">非同期性と状態の変化を組み合わせると、プログラムの推論が非常に難しくなります。たとえば、状態を変更する非同期コールバックで2つのメソッドを呼び出す場合、それらがいつ呼び出され、どのコールバックが最初に呼び出されたかをどのようにして知ることができますか？これが、2つの概念を分離したい理由です。Vuexでは、&lt;strong&gt;ミュー&lt;/strong&gt;テーション&lt;strong&gt;は同期トランザクション&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="b626c6a5b4f21b273497b11b0696d3709db0b3b9" translate="yes" xml:space="preserve">
          <source>Asynchronous logic should be encapsulated in, and can be composed with &lt;strong&gt;actions&lt;/strong&gt;.</source>
          <target state="translated">非同期ロジックはカプセル化する必要があり、&lt;strong&gt;アクション&lt;/strong&gt;で構成できます。</target>
        </trans-unit>
        <trans-unit id="b24ba5aae3b57ed131c31fce3d9e7c01ee0a8934" translate="yes" xml:space="preserve">
          <source>At the center of every Vuex application is the &lt;strong&gt;store&lt;/strong&gt;. A &quot;store&quot; is basically a container that holds your application &lt;strong&gt;state&lt;/strong&gt;. There are two things that make a Vuex store different from a plain global object:</source>
          <target state="translated">すべてのVuexアプリケーションの中心は&lt;strong&gt;ストア&lt;/strong&gt;です。「ストア」は基本的に、アプリケーションの&lt;strong&gt;状態&lt;/strong&gt;を保持するコンテナです。Vuexストアをプレーンなグローバルオブジェクトと異なるものにする2つの点があります。</target>
        </trans-unit>
        <trans-unit id="c7d1a78232de1c9a47af6445001c58c1d1a7ff3f" translate="yes" xml:space="preserve">
          <source>Binding Helpers with Namespace</source>
          <target state="translated">名前空間を持つバインディングヘルパー</target>
        </trans-unit>
        <trans-unit id="2b82d0b3ff29a71b23bd07d252bf2496be796144" translate="yes" xml:space="preserve">
          <source>Built-in Logger Plugin</source>
          <target state="translated">内蔵ロガープラグイン</target>
        </trans-unit>
        <trans-unit id="9b63c58271c9e6140433eb13c24cac57c216ef45" translate="yes" xml:space="preserve">
          <source>By committing mutations, a plugin can be used to sync a data source to the store. For example, to sync a websocket data source to the store (this is just a contrived example, in reality the &lt;code&gt;createWebSocketPlugin&lt;/code&gt; function can take some additional options for more complex tasks):</source>
          <target state="translated">ミューテーションをコミットすることにより、プラグインを使用してデータソースをストアに同期できます。たとえば、WebSocketデータソースをストアに同期するには（これは単なる &lt;code&gt;createWebSocketPlugin&lt;/code&gt; な例ですが、実際には、createWebSocketPlugin関数は、より複雑なタスクのためにいくつかの追加オプションを取ることができます）：</target>
        </trans-unit>
        <trans-unit id="f6129d443ac8169bdc5fb7a33f1a6e3a49e6acbc" translate="yes" xml:space="preserve">
          <source>By default, actions, mutations and getters inside modules are still registered under the &lt;strong&gt;global namespace&lt;/strong&gt; - this allows multiple modules to react to the same mutation/action type.</source>
          <target state="translated">デフォルトでは、モジュール内のアクション、ミューテーション、ゲッターは引き続き&lt;strong&gt;グローバルネームスペースに&lt;/strong&gt;登録され&lt;strong&gt;ます。&lt;/strong&gt;これにより、複数のモジュールが同じミューテーション/アクションタイプに反応できるようになります。</target>
        </trans-unit>
        <trans-unit id="51ce5306c9b50098f499e2c37705e5ca375897a5" translate="yes" xml:space="preserve">
          <source>By defining and separating the concepts involved in state management and enforcing rules that maintain independence between views and states, we give our code more structure and maintainability.</source>
          <target state="translated">状態管理に関わる概念を定義・分離し、ビューと状態間の独立性を維持するルールを実施することで、コードに構造性と保守性を持たせています。</target>
        </trans-unit>
        <trans-unit id="5f057ce6f76c7748c97610c88355154f282ad2c0" translate="yes" xml:space="preserve">
          <source>By providing the &lt;code&gt;store&lt;/code&gt; option to the root instance, the store will be injected into all child components of the root and will be available on them as &lt;code&gt;this.$store&lt;/code&gt;. Let's update our &lt;code&gt;Counter&lt;/code&gt; implementation:</source>
          <target state="translated">ルートインスタンスに &lt;code&gt;store&lt;/code&gt; オプションを提供することにより、ストアはルートのすべての子コンポーネントに挿入され、これらの子コンポーネントで &lt;code&gt;this.$store&lt;/code&gt; として使用できるようになります。 &lt;code&gt;Counter&lt;/code&gt; の実装を更新しましょう：</target>
        </trans-unit>
        <trans-unit id="afbfca3e9562078c83014d5d713ed214293086dc" translate="yes" xml:space="preserve">
          <source>Caveat for Plugin Developers</source>
          <target state="translated">プラグイン開発者のための注意点</target>
        </trans-unit>
        <trans-unit id="b802f993bec634c517b9f6ea60df4c1f6d0862f1" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;entry&lt;/code&gt; from the webpack config above to &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt;.</source>
          <target state="translated">変更し &lt;code&gt;entry&lt;/code&gt; に上記のWebPACKの設定から &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dce2cc7e2a5aca96dce40c7472c844313c6128f9" translate="yes" xml:space="preserve">
          <source>Checkout the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/counter-hot&quot;&gt;counter-hot example&lt;/a&gt; to play with hot-reload.</source>
          <target state="translated">ホットリロードを試すには、&lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/counter-hot&quot;&gt;カウンターホットの例&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="4fa10bacb249d780150d867ebb85a6f26364c8f3" translate="yes" xml:space="preserve">
          <source>Commit a mutation. &lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;root: true&lt;/code&gt; that allows to commit root mutations in &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;namespaced modules&lt;/a&gt;. &lt;a href=&quot;../guide/mutations&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">突然変異をコミットします。 &lt;code&gt;options&lt;/code&gt; は &lt;code&gt;root: true&lt;/code&gt; を指定でき&lt;a href=&quot;../guide/modules#namespacing&quot;&gt;ます&lt;/a&gt;。これにより、名前空間付きモジュールでルート変更をコミットできます。&lt;a href=&quot;../guide/mutations&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abb9b61bf1bcc0d24bf3814462346ec637d49ab2" translate="yes" xml:space="preserve">
          <source>Commit with Payload</source>
          <target state="translated">ペイロードでのコミット</target>
        </trans-unit>
        <trans-unit id="ed6c4a7e621ba1c9ba60ff20a8e8dcf01877ef46" translate="yes" xml:space="preserve">
          <source>Committing Mutations Inside Plugins</source>
          <target state="translated">プラグイン内での変異のコミット</target>
        </trans-unit>
        <trans-unit id="ace0d08016e7028b4da846721e8e8ac868a1df57" translate="yes" xml:space="preserve">
          <source>Committing Mutations in Components</source>
          <target state="translated">コンポーネントの突然変異のコミット</target>
        </trans-unit>
        <trans-unit id="1f6dc35fce777380808e0419957ee6d4ef776d2a" translate="yes" xml:space="preserve">
          <source>Component Binding Helpers</source>
          <target state="translated">コンポーネントバインディングヘルパー</target>
        </trans-unit>
        <trans-unit id="4d8cf2331522b00be9ba0f265b611e2039ac37bf" translate="yes" xml:space="preserve">
          <source>Components Can Still Have Local State</source>
          <target state="translated">コンポーネントはまだローカルステートを持つことができます。</target>
        </trans-unit>
        <trans-unit id="b15cc8250e54a4e4e49adf02d259f1fa59279242" translate="yes" xml:space="preserve">
          <source>Composing Actions</source>
          <target state="translated">アクションの構成</target>
        </trans-unit>
        <trans-unit id="ede404da36f4056ccf7af05d460f44cb9c43066f" translate="yes" xml:space="preserve">
          <source>Consult the setup in &lt;a href=&quot;https://vue-loader.vuejs.org/en/workflow/testing.html&quot;&gt;vue-loader documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://vue-loader.vuejs.org/en/workflow/testing.html&quot;&gt;vue-loaderのドキュメントの&lt;/a&gt;設定を参照してください。</target>
        </trans-unit>
        <trans-unit id="da10239b688b761162ce39505c1fb91b8a0f2cff" translate="yes" xml:space="preserve">
          <source>Create component computed options that return the evaluated value of a getter. &lt;a href=&quot;../guide/getters#the-mapgetters-helper&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">ゲッターの評価された値を返すコンポーネント計算オプションを作成します。&lt;a href=&quot;../guide/getters#the-mapgetters-helper&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31bb75db599ebdfdee4a1705ea2cde4fc02ae7e9" translate="yes" xml:space="preserve">
          <source>Create component computed options that return the sub tree of the Vuex store. &lt;a href=&quot;../guide/state#the-mapstate-helper&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Vuexストアのサブツリーを返すコンポーネント計算オプションを作成します。&lt;a href=&quot;../guide/state#the-mapstate-helper&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dbfc6c00c0be1ce1d1c67ae2ab7ad29e56233ee" translate="yes" xml:space="preserve">
          <source>Create component methods options that commit a mutation. &lt;a href=&quot;../guide/mutations#committing-mutations-in-components&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">ミューテーションをコミットするコンポーネントメソッドオプションを作成します。&lt;a href=&quot;../guide/mutations#committing-mutations-in-components&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abafed37072bae96880b76a80729da6f20135f55" translate="yes" xml:space="preserve">
          <source>Create component methods options that dispatch an action. &lt;a href=&quot;../guide/actions#dispatching-actions-in-components&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">アクションをディスパッチするコンポーネントメソッドオプションを作成します。&lt;a href=&quot;../guide/actions#dispatching-actions-in-components&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e2d6b72bf5a70877397f0095b2d65aff35b1892" translate="yes" xml:space="preserve">
          <source>Create namespaced component binding helpers. The returned object contains &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; and &lt;code&gt;mapMutations&lt;/code&gt; that are bound with the given namespace. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">名前空間を持つコンポーネントバインディングヘルパーを作成します。返されるオブジェクトには、指定された名前空間にバインドされた &lt;code&gt;mapState&lt;/code&gt; 、 &lt;code&gt;mapGetters&lt;/code&gt; 、 &lt;code&gt;mapActions&lt;/code&gt; 、 &lt;code&gt;mapMutations&lt;/code&gt; が含まれています。&lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9ad68aa689b0ae8f0f0130cf5684aa9556b2ca9" translate="yes" xml:space="preserve">
          <source>Create the following webpack config (together with proper &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;&lt;code&gt;.babelrc&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">次のwebpack設定を（適切な&lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt; &lt;code&gt;.babelrc&lt;/code&gt; &lt;/a&gt;と共に）作成します。</target>
        </trans-unit>
        <trans-unit id="9105fc825a43c6d4845f7a03ee377cd299c7a10e" translate="yes" xml:space="preserve">
          <source>Creating multiple stores that use the same module (e.g. To &lt;a href=&quot;https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons&quot;&gt;avoid stateful singletons in the SSR&lt;/a&gt; when the &lt;code&gt;runInNewContext&lt;/code&gt; option is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;'once'&lt;/code&gt;);</source>
          <target state="translated">同じモジュールを使用する複数のストアを作成する（たとえば、 &lt;code&gt;runInNewContext&lt;/code&gt; オプションが &lt;code&gt;false&lt;/code&gt; または &lt;code&gt;'once'&lt;/code&gt; のときに&lt;a href=&quot;https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons&quot;&gt;SSRでステートフルシングルトン&lt;/a&gt;を回避するため）。</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="40d9b9f619dbd27ad649a2fb2ed512704a8498dc" translate="yes" xml:space="preserve">
          <source>Dev Build</source>
          <target state="translated">デブビルド</target>
        </trans-unit>
        <trans-unit id="500633464b5e072d2c92585f64d2a894aa70607e" translate="yes" xml:space="preserve">
          <source>Development vs. Production</source>
          <target state="translated">開発と生産</target>
        </trans-unit>
        <trans-unit id="3802d9202faed1ee478163e33ce9ddf939795ae9" translate="yes" xml:space="preserve">
          <source>Direct Download / CDN</source>
          <target state="translated">直接ダウンロード/CDN</target>
        </trans-unit>
        <trans-unit id="ea82e3864abf2011a82f27aa87646711a6dde792" translate="yes" xml:space="preserve">
          <source>Dispatch an action. &lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;root: true&lt;/code&gt; that allows to dispatch root actions in &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;namespaced modules&lt;/a&gt;. Returns a Promise that resolves all triggered action handlers. &lt;a href=&quot;../guide/actions&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">アクションをディスパッチします。 &lt;code&gt;options&lt;/code&gt; は &lt;code&gt;root: true&lt;/code&gt; を持つことができ、&lt;a href=&quot;../guide/modules#namespacing&quot;&gt;名前空間モジュールで&lt;/a&gt; rootアクションをディスパッチできます。トリガーされたすべてのアクションハンドラーを解決するPromiseを返します。&lt;a href=&quot;../guide/actions&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5de1b3bf84cda5dd071c256e4397b905445d1ed" translate="yes" xml:space="preserve">
          <source>Dispatching Actions</source>
          <target state="translated">派遣行為</target>
        </trans-unit>
        <trans-unit id="7bbf007bb6622957664e35e62427c33b4787bbb3" translate="yes" xml:space="preserve">
          <source>Dispatching Actions in Components</source>
          <target state="translated">コンポーネントでのアクションのディスパッチ</target>
        </trans-unit>
        <trans-unit id="18d9131cd512bae245202d7fdc5bab5cceca6887" translate="yes" xml:space="preserve">
          <source>Due to using a single state tree, all state of our application is contained inside one big object. However, as our application grows in scale, the store can get really bloated.</source>
          <target state="translated">単一のステートツリーを使用しているため、アプリケーションのすべてのステートは1つの大きなオブジェクトの中に含まれています。しかし、アプリケーションの規模が大きくなると、ストアが肥大化してしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="e38587c029f9616f99732e5fadca02a9d8f2a6d2" translate="yes" xml:space="preserve">
          <source>Dynamic Module Registration</source>
          <target state="translated">動的モジュール登録</target>
        </trans-unit>
        <trans-unit id="2eff12ca8da9deedbd39f6bb9fd354742d118c9c" translate="yes" xml:space="preserve">
          <source>Dynamic module registration makes it possible for other Vue plugins to also leverage Vuex for state management by attaching a module to the application's store. For example, the &lt;a href=&quot;https://github.com/vuejs/vuex-router-sync&quot;&gt;&lt;code&gt;vuex-router-sync&lt;/code&gt;&lt;/a&gt; library integrates vue-router with vuex by managing the application's route state in a dynamically attached module.</source>
          <target state="translated">動的モジュール登録により、アプリケーションのストアにモジュールをアタッチすることにより、他のVueプラグインも状態管理にVuexを利用できるようになります。たとえば、&lt;a href=&quot;https://github.com/vuejs/vuex-router-sync&quot;&gt; &lt;code&gt;vuex-router-sync&lt;/code&gt; &lt;/a&gt;ライブラリは、動的に接続されたモジュールでアプリケーションのルート状態を管理することにより、vue-routerをvuexと統合します。</target>
        </trans-unit>
        <trans-unit id="9e3580cb8f8917bfac5059a2f1b0b379d39800d4" translate="yes" xml:space="preserve">
          <source>Each module can contain &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;mutations&lt;/code&gt; similar to the root options. A module's state will be attached to the store's root state using the module's key. A module's mutations and getters will only receives the module's local state as the first argument instead of the root state, and module actions' &lt;code&gt;context.state&lt;/code&gt; will also point to the local state.</source>
          <target state="translated">各モジュールには、ルートオプションと同様の &lt;code&gt;state&lt;/code&gt; と &lt;code&gt;mutations&lt;/code&gt; を含めることができます。モジュールの状態は、モジュールのキーを使用してストアのルート状態にアタッチされます。モジュールのミューテーションとゲッターは、ルート状態ではなく、モジュールのローカル状態のみを最初の引数として受け取り、モジュールアクションの &lt;code&gt;context.state&lt;/code&gt; もローカル状態を指します。</target>
        </trans-unit>
        <trans-unit id="d6af0b4fa90bb496d791139a634a4d2d65a25408" translate="yes" xml:space="preserve">
          <source>Example testing a getter:</source>
          <target state="translated">ゲッターをテストする例。</target>
        </trans-unit>
        <trans-unit id="dd8e6bd0108987b857bb2a736cd9e6e1f11f7746" translate="yes" xml:space="preserve">
          <source>Example testing a mutation using Mocha + Chai (you can use any framework/assertion libraries you like):</source>
          <target state="translated">Mocha+Chaiを使った突然変異のテスト例(好きなフレームワーク/アサーションライブラリを使うことができます)。</target>
        </trans-unit>
        <trans-unit id="4dadb731f14e104d4245f8a4e7627c9bb1d8c139" translate="yes" xml:space="preserve">
          <source>Example testing an async action:</source>
          <target state="translated">非同期アクションをテストする例。</target>
        </trans-unit>
        <trans-unit id="cd172f61d02f40968010ccf686bd62765d497609" translate="yes" xml:space="preserve">
          <source>Exposes registered getters. Read only.</source>
          <target state="translated">登録されたゲッターを公開します。読み取り専用。</target>
        </trans-unit>
        <trans-unit id="e7e1190595d9109275e6d9d5c10a089a3981a13d" translate="yes" xml:space="preserve">
          <source>Finally, if we make use of &lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async / await&lt;/a&gt;, we can compose our actions like this:</source>
          <target state="translated">最後に、&lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async / await&lt;/a&gt;を使用すると、次のようにアクションを作成できます。</target>
        </trans-unit>
        <trans-unit id="841c8a4f0fbdf7bd78d33837ca0ec3734ac74a01" translate="yes" xml:space="preserve">
          <source>Flux libraries are like glasses: you&amp;rsquo;ll know when you need them.</source>
          <target state="translated">Fluxライブラリはメガネのようなものです。いつ必要になるかがわかります。</target>
        </trans-unit>
        <trans-unit id="38238c24d7f78b5d636a16e313302582a752f404" translate="yes" xml:space="preserve">
          <source>For any non-trivial app, we will likely need to leverage modules. Here's an example project structure:</source>
          <target state="translated">トリビアルでないアプリの場合は、モジュールを活用する必要があるでしょう。以下にプロジェクト構造の例を示します。</target>
        </trans-unit>
        <trans-unit id="033826f9380de6f34a8b452670d3506eb71f91c9" translate="yes" xml:space="preserve">
          <source>For mutations and modules, you need to use the &lt;code&gt;store.hotUpdate()&lt;/code&gt; API method:</source>
          <target state="translated">ミューテーションとモジュールの場合、 &lt;code&gt;store.hotUpdate()&lt;/code&gt; APIメソッドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="52511d0a336b3eb2bef841ae607141d7cff1fb7f" translate="yes" xml:space="preserve">
          <source>For problem one, passing props can be tedious for deeply nested components, and simply doesn't work for sibling components. For problem two, we often find ourselves resorting to solutions such as reaching for direct parent/child instance references or trying to mutate and synchronize multiple copies of the state via events. Both of these patterns are brittle and quickly lead to unmaintainable code.</source>
          <target state="translated">問題1については、プロップを渡すのは、深く入れ子になっているコンポーネントでは面倒で、兄弟コンポーネントでは単に動作しません。2つ目の問題については、親子インスタンスの直接参照に手を伸ばしたり、イベントを介して状態の複数のコピーを変異させて同期させようとするなどの解決策に頼ることがよくあります。これらのパターンはどちらも脆く、すぐにメンテナンス性の低いコードになってしまいます。</target>
        </trans-unit>
        <trans-unit id="bea63837c28f9e496db300536e9f97becac0fe11" translate="yes" xml:space="preserve">
          <source>Force the Vuex store into strict mode. In strict mode any mutations to Vuex state outside of mutation handlers will throw an Error.</source>
          <target state="translated">Vuexストアをストリクトモードにします。ストリクトモードでは、突然変異ハンドラ以外でVuexの状態に変異を加えると、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="320e36f6db4da7afda899f2251cea1a84a74c2fd" translate="yes" xml:space="preserve">
          <source>Form Handling</source>
          <target state="translated">モールドハンドリング</target>
        </trans-unit>
        <trans-unit id="8f92675b7ffe5ac821405fab6ddb6dee755e7a33" translate="yes" xml:space="preserve">
          <source>Furthermore, add the below line into anywhere in your code before using Vuex:</source>
          <target state="translated">さらに、Vuexを使用する前に、以下の行をコードの任意の場所に追加してください。</target>
        </trans-unit>
        <trans-unit id="e156a94f2c9e52e0ddb1f3009ed07dd2abf8f227" translate="yes" xml:space="preserve">
          <source>Furthermore, you can create namespaced helpers by using &lt;code&gt;createNamespacedHelpers&lt;/code&gt;. It returns an object having new component binding helpers that are bound with the given namespace value:</source>
          <target state="translated">さらに、 &lt;code&gt;createNamespacedHelpers&lt;/code&gt; を使用して名前空間付きヘルパーを作成できます。指定された名前空間の値でバインドされた新しいコンポーネントバインディングヘルパーを持つオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="3bbbe89e1bf4029f9a507d85d668e0d1d5478d40" translate="yes" xml:space="preserve">
          <source>Getters</source>
          <target state="translated">Getters</target>
        </trans-unit>
        <trans-unit id="a2c7b1aaac2b0cd5b5c8cf82e9116fb532a36719" translate="yes" xml:space="preserve">
          <source>Getters will also receive other getters as the 2nd argument:</source>
          <target state="translated">ゲッターは第2引数として他のゲッターも受け取ります。</target>
        </trans-unit>
        <trans-unit id="d5976d58530e9ba51288bd1c3ba468cfba584344" translate="yes" xml:space="preserve">
          <source>Getters will receive the state as their 1st argument:</source>
          <target state="translated">ゲッターは第一引数として国家を受け取ります。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">はじめに</target>
        </trans-unit>
        <trans-unit id="fca659dd312a705a6e05d1f829f26c05b73a3925" translate="yes" xml:space="preserve">
          <source>Getting Vuex State into Vue Components</source>
          <target state="translated">Vuex の状態を Vue コンポーネントに取り込む</target>
        </trans-unit>
        <trans-unit id="722346bbd4db03c1c92c2a13e486f0e957996d98" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt;.</source>
          <target state="translated">移動 &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">ガイド</target>
        </trans-unit>
        <trans-unit id="45a02043733710be9556d86b3bc87f17a5cbb0c2" translate="yes" xml:space="preserve">
          <source>Here's an example of the &lt;a href=&quot;https://jsfiddle.net/n9jmu5v7/1269/&quot;&gt;most basic Vuex counter app&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/n9jmu5v7/1269/&quot;&gt;最も基本的なVuexカウンターアプリの&lt;/a&gt;例を次に示します。</target>
        </trans-unit>
        <trans-unit id="7e74485fd2af89802a7ce36b6ae42c0bfcc32ed2" translate="yes" xml:space="preserve">
          <source>Hot Reloading</source>
          <target state="translated">ホットリロード</target>
        </trans-unit>
        <trans-unit id="c75202151698b65793216f709dd23fa91c67ca82" translate="yes" xml:space="preserve">
          <source>Hot swap new actions and mutations. &lt;a href=&quot;../guide/hot-reload&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">ホットスワップの新しいアクションとミューテーション。&lt;a href=&quot;../guide/hot-reload&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a9fe831345a6e109e78580913b99472521a13a7" translate="yes" xml:space="preserve">
          <source>However, the simplicity quickly breaks down when we have &lt;strong&gt;multiple components that share a common state&lt;/strong&gt;:</source>
          <target state="translated">ただし、&lt;strong&gt;共通の状態を共有する複数のコンポーネントがある&lt;/strong&gt;場合、単純さはすぐに破綻し&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c5371d6ce87417e1b9eefdc865251be6386c405f" translate="yes" xml:space="preserve">
          <source>However, this pattern causes the component to rely on the global store singleton. When using a module system, it requires importing the store in every component that uses store state, and also requires mocking when testing the component.</source>
          <target state="translated">しかし、このパターンでは、コンポーネントがグローバルストアのシングルトンに依存してしまいます。モジュールシステムを使用する場合、ストアの状態を使用するすべてのコンポーネントでストアをインポートする必要があり、また、コンポーネントをテストする際にモックが必要になります。</target>
        </trans-unit>
        <trans-unit id="b36b5bee1a64a661bc0d45de384b9124cbd72bfe" translate="yes" xml:space="preserve">
          <source>If more than one component needs to make use of this, we have to either duplicate the function, or extract it into a shared helper and import it in multiple places - both are less than ideal.</source>
          <target state="translated">複数のコンポーネントがこれを利用する必要がある場合、関数を複製するか、共有ヘルパーに抽出して複数の場所にインポートしなければなりません-どちらも理想的ではありません。</target>
        </trans-unit>
        <trans-unit id="bcd403966a8c64a6cc2f12e14145c0930fd23c8f" translate="yes" xml:space="preserve">
          <source>If we use a plain object to declare the state of the module, then that state object will be shared by reference and cause cross store/module state pollution when it's mutated.</source>
          <target state="translated">モジュールの状態を宣言するためにプレーンなオブジェクトを使うと、その状態オブジェクトは参照によって共有され、それが突然変異したときにクロスストア/モジュールの状態汚染を引き起こすことになります。</target>
        </trans-unit>
        <trans-unit id="b7ec52a51a8cf587b9d439ecdf520d3332d63b46" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; you probably don't need this.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;を使用している場合は、おそらくこれは必要ありません。</target>
        </trans-unit>
        <trans-unit id="cee9eac37fcab09966f32a737634f82881a4edd4" translate="yes" xml:space="preserve">
          <source>If you have spies available in your testing environment (for example via &lt;a href=&quot;http://sinonjs.org/&quot;&gt;Sinon.JS&lt;/a&gt;), you can use them instead of the &lt;code&gt;testAction&lt;/code&gt; helper:</source>
          <target state="translated">テスト環境で（たとえば&lt;a href=&quot;http://sinonjs.org/&quot;&gt;Sinon.JS&lt;/a&gt;を介して）スパイを使用できる場合は、 &lt;code&gt;testAction&lt;/code&gt; ヘルパーの代わりにそれらを使用できます。</target>
        </trans-unit>
        <trans-unit id="99253187df56aff1e087c7f8349702f7e584c5c0" translate="yes" xml:space="preserve">
          <source>If you pass a function that returns an object, the returned object is used as the root state. This is useful when you want to reuse the state object especially for module reuse. &lt;a href=&quot;../guide/modules#module-reuse&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">オブジェクトを返す関数を渡すと、返されたオブジェクトがルート状態として使用されます。これは、特にモジュールの再利用のために、状態オブジェクトを再利用する場合に役立ちます。&lt;a href=&quot;../guide/modules#module-reuse&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09433d887f39cc66b122d2113ece04bd4c9edb90" translate="yes" xml:space="preserve">
          <source>If you prefer using a package manager such as NPM or Yarn, install it with the following commands:</source>
          <target state="translated">NPMやYarnなどのパッケージマネージャを使いたい場合は、以下のコマンドでインストールしてください。</target>
        </trans-unit>
        <trans-unit id="d3c23688fd4c0302fe8a3ccf68a85702b829cacd" translate="yes" xml:space="preserve">
          <source>If you want to learn Vuex in an interactive way you can check out this &lt;a href=&quot;https://scrimba.com/g/gvuex&quot;&gt;Vuex course on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">インタラクティブな方法でVuexを学びたい場合は、この&lt;a href=&quot;https://scrimba.com/g/gvuex&quot;&gt;VuexコースをScrimba&lt;/a&gt;でチェックしてください。スクリーンキャストとコードプレイグラウンドを組み合わせて、いつでも一時停止して遊ぶことができます。</target>
        </trans-unit>
        <trans-unit id="f3eb7c190d4d6d7796c724c80957f823f5be66cc" translate="yes" xml:space="preserve">
          <source>If you want to map a getter to a different name, use an object:</source>
          <target state="translated">ゲッターを別の名前にマッピングしたい場合は、オブジェクトを使用します。</target>
        </trans-unit>
        <trans-unit id="20e00848ec8ade0a6824f9de7344231d1bfc9ba4" translate="yes" xml:space="preserve">
          <source>If you want to register global actions in namespaced modules, you can mark it with &lt;code&gt;root: true&lt;/code&gt; and place the action definition to function &lt;code&gt;handler&lt;/code&gt;. For example:</source>
          <target state="translated">名前空間モジュールにグローバルアクションを登録する場合は、それを &lt;code&gt;root: true&lt;/code&gt; マークし、アクション定義を関数 &lt;code&gt;handler&lt;/code&gt; ます。例えば：</target>
        </trans-unit>
        <trans-unit id="4f4b8e63a24cc27e082d0c2aea79d7dec7762531" translate="yes" xml:space="preserve">
          <source>If you want to use global state and getters, &lt;code&gt;rootState&lt;/code&gt; and &lt;code&gt;rootGetters&lt;/code&gt; are passed as the 3rd and 4th arguments to getter functions, and also exposed as properties on the &lt;code&gt;context&lt;/code&gt; object passed to action functions.</source>
          <target state="translated">グローバルステートとゲッターを使用する場合、 &lt;code&gt;rootState&lt;/code&gt; と &lt;code&gt;rootGetters&lt;/code&gt; は3番目と4番目の引数としてゲッター関数に渡され、アクション関数に渡される &lt;code&gt;context&lt;/code&gt; オブジェクトのプロパティとして公開されます。</target>
        </trans-unit>
        <trans-unit id="6fcf9a3ab85ce67825ec590efb360c383d7dfca6" translate="yes" xml:space="preserve">
          <source>If you want your modules to be more self-contained or reusable, you can mark it as namespaced with &lt;code&gt;namespaced: true&lt;/code&gt;. When the module is registered, all of its getters, actions and mutations will be automatically namespaced based on the path the module is registered at. For example:</source>
          <target state="translated">モジュールをより自己完結型または再利用可能にする場合は、 &lt;code&gt;namespaced: true&lt;/code&gt; 使用して、モジュールをnamespacedとしてマークできます。モジュールが登録されると、そのすべてのゲッター、アクション、ミューテーションは、モジュールが登録されているパスに基づいて自動的に名前空間が設定されます。例えば：</target>
        </trans-unit>
        <trans-unit id="a5c0c63467aaecb0aa7b51168b383f900b5a513b" translate="yes" xml:space="preserve">
          <source>If you've never built a large-scale SPA and jump right into Vuex, it may feel verbose and daunting. That's perfectly normal - if your app is simple, you will most likely be fine without Vuex. A simple &lt;a href=&quot;https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch&quot;&gt;store pattern&lt;/a&gt; may be all you need. But if you are building a medium-to-large-scale SPA, chances are you have run into situations that make you think about how to better handle state outside of your Vue components, and Vuex will be the natural next step for you. There's a good quote from Dan Abramov, the author of Redux:</source>
          <target state="translated">大規模なSPAを構築したことがなく、すぐにVuexにジャンプした場合、冗長で気が遠くなるかもしれません。これは完全に正常なことです。アプリがシンプルであれば、Vuexがなくても大丈夫でしょう。単純な&lt;a href=&quot;https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch&quot;&gt;ストアパターン&lt;/a&gt;で十分です。しかし、中規模から大規模のSPAを構築している場合は、Vueコンポーネントの外部で状態をより適切に処理する方法を考えるような状況に遭遇する可能性があり、Vuexが自然な次のステップになります。 Reduxの作者であるDan Abramovからの良い引用があります：</target>
        </trans-unit>
        <trans-unit id="c6537ddc12952ad16232d8a921be6b7d5a76a6d6" translate="yes" xml:space="preserve">
          <source>If your getters have complicated computation, it is worth testing them. Getters are also very straightforward to test for the same reason as mutations.</source>
          <target state="translated">ゲッターが複雑な計算をする場合は、テストする価値があります。ゲッターもまた、突然変異と同じ理由でテストするのが非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="4de758dad2a92aec248785ac4d6dbc0ff778d9aa" translate="yes" xml:space="preserve">
          <source>If your mutations and actions are written properly, the tests should have no direct dependency on Browser APIs after proper mocking. Thus you can simply bundle the tests with webpack and run it directly in Node. Alternatively, you can use &lt;code&gt;mocha-loader&lt;/code&gt; or Karma + &lt;code&gt;karma-webpack&lt;/code&gt; to run the tests in real browsers.</source>
          <target state="translated">ミューテーションとアクションが適切に記述されている場合、適切なモックの後、テストはブラウザAPIに直接依存しません。したがって、テストをwebpackにバンドルして、直接Nodeで実行できます。または、 &lt;code&gt;mocha-loader&lt;/code&gt; またはKarma + &lt;code&gt;karma-webpack&lt;/code&gt; を使用して、実際のブラウザーでテストを実行することもできます。</target>
        </trans-unit>
        <trans-unit id="b21dc6e7af159e44f13e61d052a381cc5930fcfa" translate="yes" xml:space="preserve">
          <source>In most cases, the payload should be an object so that it can contain multiple fields, and the recorded mutation will also be more descriptive:</source>
          <target state="translated">ほとんどの場合、ペイロードはオブジェクトでなければならないので、複数のフィールドを含むことができ、記録された突然変異もより記述的になります。</target>
        </trans-unit>
        <trans-unit id="b379a9de19b6c2947713c2e819c098b0d0414341" translate="yes" xml:space="preserve">
          <source>In practice, we often use ES2015 &lt;a href=&quot;https://github.com/lukehoban/es6features#destructuring&quot;&gt;argument destructuring&lt;/a&gt; to simplify the code a bit (especially when we need to call &lt;code&gt;commit&lt;/code&gt; multiple times):</source>
          <target state="translated">実際には、ES2015 &lt;a href=&quot;https://github.com/lukehoban/es6features#destructuring&quot;&gt;引数&lt;/a&gt;分解を使用してコードを少し単純化することがよくあります（特に、 &lt;code&gt;commit&lt;/code&gt; を複数回呼び出す必要がある場合）。</target>
        </trans-unit>
        <trans-unit id="3857e213dc0f7b8c7391de2df6fe7f4ad9600a0c" translate="yes" xml:space="preserve">
          <source>In strict mode, whenever Vuex state is mutated outside of mutation handlers, an error will be thrown. This ensures that all state mutations can be explicitly tracked by debugging tools.</source>
          <target state="translated">厳密なモードでは、Vuex の状態が突然変異ハンドラ以外の場所で突然変異した場合、エラーがスローされます。これにより、デバッグツールですべての状態の突然変異を明示的に追跡できるようになります。</target>
        </trans-unit>
        <trans-unit id="f605f46f5b670a253f694d77a6479a46bf60c051" translate="yes" xml:space="preserve">
          <source>In such cases, you can pass the module namespace string as the first argument to the helpers so that all bindings are done using that module as the context. The above can be simplified to:</source>
          <target state="translated">このような場合、ヘルパーの第一引数にモジュールの名前空間文字列を渡すことで、すべてのバインディングがそのモジュールをコンテキストとして使用して行われるようにすることができます。上記は以下のように簡略化できます。</target>
        </trans-unit>
        <trans-unit id="fb4ca597574fefd3c18365a4df91a07d3925f51b" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;vuex&lt;/code&gt; after Vue and it will install itself automatically:</source>
          <target state="translated">Vueの後に &lt;code&gt;vuex&lt;/code&gt; を含めると、自動的にインストールされます。</target>
        </trans-unit>
        <trans-unit id="4edd5883cfc0f50d6093450192a5526d804c388e" translate="yes" xml:space="preserve">
          <source>Inside a module's mutations and getters, the first argument received will be &lt;strong&gt;the module's local state&lt;/strong&gt;.</source>
          <target state="translated">モジュールのミューテーションとゲッターの中で、最初に受け取る引数は&lt;strong&gt;、モジュールのローカル状態&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="457ba19288441fafbf211b7b6c88681a0845bc6a" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;mocha-loader&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mocha-loader&lt;/code&gt; をインストールします。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="9d0fe35d22060e945e08d2b96b5abfd85eb87e88" translate="yes" xml:space="preserve">
          <source>Instead of mutating the state, actions commit mutations.</source>
          <target state="translated">状態を突然変異させる代わりに、アクションは突然変異を起こします。</target>
        </trans-unit>
        <trans-unit id="fb1e51da35f8b4fc5e80bad74fa44c9f09edf0fe" translate="yes" xml:space="preserve">
          <source>It is a commonly seen pattern to use constants for mutation types in various Flux implementations. This allows the code to take advantage of tooling like linters, and putting all constants in a single file allows your collaborators to get an at-a-glance view of what mutations are possible in the entire application:</source>
          <target state="translated">Fluxの様々な実装で、突然変異型に定数を使用するのはよく見られるパターンです。これにより、リンターのようなツールを利用することができます。また、すべての定数を1つのファイルにまとめておくことで、アプリケーション全体でどのような変異が可能なのかが一目でわかるようになります。</target>
        </trans-unit>
        <trans-unit id="b3f113c6b42082f72c3757fb134ac642d34ef542" translate="yes" xml:space="preserve">
          <source>It is a self-contained app with the following parts:</source>
          <target state="translated">以下のような部分がある自己完結型のアプリです。</target>
        </trans-unit>
        <trans-unit id="3ed4288f050eb852b800df4047f36461f3b17cbb" translate="yes" xml:space="preserve">
          <source>It may be likely that you want to preserve the previous state when registering a new module, such as preserving state from a Server Side Rendered app. You can achieve this with &lt;code&gt;preserveState&lt;/code&gt; option: &lt;code&gt;store.registerModule('a', module, { preserveState: true })&lt;/code&gt;</source>
          <target state="translated">サーバー側レンダリングアプリの状態を保持するなど、新しいモジュールを登録するときに以前の状態を保持したい場合があります。これは、 &lt;code&gt;preserveState&lt;/code&gt; オプションを使用して実現できます： &lt;code&gt;store.registerModule('a', module, { preserveState: true })&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35dface9e340cb4e3bddcda3e4f2453cf5b8832e" translate="yes" xml:space="preserve">
          <source>It's possible for a &lt;code&gt;store.dispatch&lt;/code&gt; to trigger multiple action handlers in different modules. In such a case the returned value will be a Promise that resolves when all triggered handlers have been resolved.</source>
          <target state="translated">&lt;code&gt;store.dispatch&lt;/code&gt; が異なるモジュールで複数のアクションハンドラーをトリガーすることが可能です。このような場合、戻り値は、トリガーされたすべてのハンドラーが解決されたときに解決されるPromiseになります。</target>
        </trans-unit>
        <trans-unit id="d9285043eca58d77420a4ea528c9c0140b7f99e5" translate="yes" xml:space="preserve">
          <source>Let's register a simple action:</source>
          <target state="translated">簡単なアクションを登録してみましょう。</target>
        </trans-unit>
        <trans-unit id="e58183fe873032e36b18fd13feeb2f3de6adac51" translate="yes" xml:space="preserve">
          <source>Let's start with a simple Vue counter app:</source>
          <target state="translated">まずは簡単なVueのカウンターアプリを使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="3c4e2ff1708a0052c627ff0c7963ae29daba2c37" translate="yes" xml:space="preserve">
          <source>Method-Style Access</source>
          <target state="translated">メソッドスタイルアクセス</target>
        </trans-unit>
        <trans-unit id="64f4a0ce2e411202b8f65d464a7de482b8f37081" translate="yes" xml:space="preserve">
          <source>Module Local State</source>
          <target state="translated">モジュール ローカルステート</target>
        </trans-unit>
        <trans-unit id="da07abb5f2f59744fb9d34a53f63697e0f2d1603" translate="yes" xml:space="preserve">
          <source>Module Reuse</source>
          <target state="translated">モジュールの再利用</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="f4e46025da22a7ac6c15f6c0d760b1ec96373a5b" translate="yes" xml:space="preserve">
          <source>Most commonly used in plugins. &lt;a href=&quot;../guide/plugins&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">プラグインで最も一般的に使用されます。&lt;a href=&quot;../guide/plugins&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="415ace164c00364e28e4d1cc0b1dea319d4e4fe4" translate="yes" xml:space="preserve">
          <source>Multiple views may depend on the same piece of state.</source>
          <target state="translated">複数のビューは、同じ状態のピースに依存する可能性があります。</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="104200b8a17f6d972a707d856a1247d4c7c79f01" translate="yes" xml:space="preserve">
          <source>Mutations Follow Vue's Reactivity Rules</source>
          <target state="translated">突然変異はVueの反応性のルールに従う</target>
        </trans-unit>
        <trans-unit id="1c4ca77f8cfecf119f2abce71ca721d4bcfe55b6" translate="yes" xml:space="preserve">
          <source>Mutations Must Be Synchronous</source>
          <target state="translated">突然変異は同期的でなければならない</target>
        </trans-unit>
        <trans-unit id="654ac141ada51cc2648d26957205d691ce5cdaec" translate="yes" xml:space="preserve">
          <source>Mutations are very straightforward to test, because they are just functions that completely rely on their arguments. One trick is that if you are using ES2015 modules and put your mutations inside your &lt;code&gt;store.js&lt;/code&gt; file, in addition to the default export, you should also export the mutations as a named export:</source>
          <target state="translated">ミューテーションは引数に完全に依存する関数にすぎないため、テストは非常に簡単です。1つのトリックは、ES2015モジュールを使用していて、mutationを &lt;code&gt;store.js&lt;/code&gt; ファイル内に置く場合、デフォルトのエクスポートに加えて、mutationを名前付きエクスポートとしてエクスポートする必要があることです。</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="f0146eaf3d75ae19152beec5a891e0df9b9d3793" translate="yes" xml:space="preserve">
          <source>Namespaced getters and actions will receive localized &lt;code&gt;getters&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt;. In other words, you can use the module assets without writing prefix in the same module. Toggling between namespaced or not does not affect the code inside the module.</source>
          <target state="translated">名前空間付きのゲッターとアクションは、ローカライズされた &lt;code&gt;getters&lt;/code&gt; を受け取り、 &lt;code&gt;dispatch&lt;/code&gt; して &lt;code&gt;commit&lt;/code&gt; ます。つまり、同じモジュールでプレフィックスを記述せずにモジュールアセットを使用できます。名前空間の有無を切り替えても、モジュール内のコードには影響しません。</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="4820b6a8eaff4049273790823038a2d97641ee6b" translate="yes" xml:space="preserve">
          <source>New in 2.5.0</source>
          <target state="translated">2.5.0の新機能</target>
        </trans-unit>
        <trans-unit id="ee5b92286bff361e6506cbde70ab9d79b67f9e22" translate="yes" xml:space="preserve">
          <source>New in 3.1.0</source>
          <target state="translated">3.1.0の新機能</target>
        </trans-unit>
        <trans-unit id="94cbec932a3607b921845482469e8e3e43a2cef8" translate="yes" xml:space="preserve">
          <source>Next, we will discuss each core concept in much finer details, starting with &lt;a href=&quot;state&quot;&gt;State&lt;/a&gt;.</source>
          <target state="translated">次に、&lt;a href=&quot;state&quot;&gt;State&lt;/a&gt;から始めて、各コアコンセプトについてさらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="8a19151987fbe02547ee0f70513d32dd282c4ac0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mapState&lt;/code&gt; returns an object. How do we use it in combination with other local computed properties? Normally, we'd have to use a utility to merge multiple objects into one so that we can pass the final object to &lt;code&gt;computed&lt;/code&gt;. However with the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread operator&lt;/a&gt; (which is a stage-4 ECMAScript proposal), we can greatly simplify the syntax:</source>
          <target state="translated">&lt;code&gt;mapState&lt;/code&gt; はオブジェクトを返すことに注意してください。他のローカル計算プロパティと組み合わせて使用​​するにはどうすればよいですか？通常、ユーティリティを使用して複数のオブジェクトを1つにマージし、最終的なオブジェクトを &lt;code&gt;computed&lt;/code&gt; 渡すことができるようにする必要があります。ただし、&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;オブジェクトスプレッドオペレーター&lt;/a&gt;（ステージ4 ECMAScriptの提案）を使用すると、構文を大幅に簡略化できます。</target>
        </trans-unit>
        <trans-unit id="383f040aea7fdc521540d519355364a1d7f735a8" translate="yes" xml:space="preserve">
          <source>Note that getters accessed as properties are cached as part of Vue's reactivity system.</source>
          <target state="translated">プロパティとしてアクセスされたゲッターは、Vue の反応性システムの一部としてキャッシュされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ee0bf46abe7c412da05c2c7e1afee2ada212118c" translate="yes" xml:space="preserve">
          <source>Note that getters accessed via methods will run each time you call them, and the result is not cached.</source>
          <target state="translated">メソッドからアクセスしたゲッターは、呼び出すたびに実行され、結果はキャッシュされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="93fca34876045ca8e7715e28c6d04cb4373157ba" translate="yes" xml:space="preserve">
          <source>Note the logger plugin takes state snapshots, so use it only during development.</source>
          <target state="translated">logger プラグインは状態のスナップショットを取るので、開発中のみ使用することに注意してください。</target>
        </trans-unit>
        <trans-unit id="11f45dfd75b6d4fbcfd55b7ac788bd4b130224b1" translate="yes" xml:space="preserve">
          <source>Note we are performing a flow of asynchronous operations, and recording the side effects (state mutations) of the action by committing them.</source>
          <target state="translated">非同期操作のフローを実行し、コミットすることでアクションの副作用(状態の変化)を記録していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ab293ff1751dac6b50aacc1c946da9ff9bd12a5a" translate="yes" xml:space="preserve">
          <source>Now imagine we are debugging the app and looking at the devtool's mutation logs. For every mutation logged, the devtool will need to capture a &quot;before&quot; and &quot;after&quot; snapshots of the state. However, the asynchronous callback inside the example mutation above makes that impossible: the callback is not called yet when the mutation is committed, and there's no way for the devtool to know when the callback will actually be called - any state mutation performed in the callback is essentially un-trackable!</source>
          <target state="translated">アプリをデバッグして、devtool の突然変異ログを見ていると想像してみてください。突然変異がログに記録されるたびに、devtool は状態の &quot;before&quot; と &quot;after&quot; のスナップショットをキャプチャする必要があります。しかし、上の例の突然変異の中にある非同期コールバックはそれを不可能にします。突然変異がコミットされたときにはコールバックはまだ呼び出されておらず、実際にいつコールバックが呼び出されるかをdevtoolは知ることができません。</target>
        </trans-unit>
        <trans-unit id="93b9e7a0a6529c120d308e3a9afc60556aa4685a" translate="yes" xml:space="preserve">
          <source>Now you can do:</source>
          <target state="translated">これでできるようになりました。</target>
        </trans-unit>
        <trans-unit id="cab930ccc32a830cf1b2daffb710e302771e1ccf" translate="yes" xml:space="preserve">
          <source>Now, you can access the state object as &lt;code&gt;store.state&lt;/code&gt;, and trigger a state change with the &lt;code&gt;store.commit&lt;/code&gt; method:</source>
          <target state="translated">これで、 &lt;code&gt;store.state&lt;/code&gt; として状態オブジェクトにアクセスし、 &lt;code&gt;store.commit&lt;/code&gt; メソッドで状態変更をトリガーできます。</target>
        </trans-unit>
        <trans-unit id="ace4a2b4fe085d950494ad9721a19fbdb4b869ed" translate="yes" xml:space="preserve">
          <source>Object Spread Operator</source>
          <target state="translated">オブジェクト拡散演算子</target>
        </trans-unit>
        <trans-unit id="4e55a0d58d5e1d3dd2c370978eeab3967aadea55" translate="yes" xml:space="preserve">
          <source>Object-Style Commit</source>
          <target state="translated">オブジェクトスタイルコミット</target>
        </trans-unit>
        <trans-unit id="af6888b6f45f7db98c78eb748575fc0a520bf758" translate="yes" xml:space="preserve">
          <source>On to Actions</source>
          <target state="translated">アクションへ</target>
        </trans-unit>
        <trans-unit id="be28144bfe8196f5de9245ef24f38b80c1795631" translate="yes" xml:space="preserve">
          <source>One important rule to remember is that &lt;strong&gt;mutation handler functions must be synchronous&lt;/strong&gt;. Why? Consider the following example:</source>
          <target state="translated">覚えて&lt;strong&gt;おくべき&lt;/strong&gt;重要なルールの1つは、&lt;strong&gt;ミューテーションハンドラー関数は同期でなければならないということ&lt;/strong&gt;です。どうして？次の例について考えてみます。</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="22f632f9f25219b387e3b3f91a16935bbf27d29a" translate="yes" xml:space="preserve">
          <source>Plugins are not allowed to directly mutate state - similar to your components, they can only trigger changes by committing mutations.</source>
          <target state="translated">プラグインは状態を直接変異させることはできません-コンポーネントと同様に、変異をコミットすることでのみ変更をトリガーすることができます。</target>
        </trans-unit>
        <trans-unit id="184f9c5d6a512ea46935550bc3405af620cc2aa9" translate="yes" xml:space="preserve">
          <source>Prefer initializing your store's initial state with all desired fields upfront.</source>
          <target state="translated">お店の初期状態を、希望するすべてのフィールドを前もって初期化することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e7e706a353f493baa85f48336645f1af9ce6a62b" translate="yes" xml:space="preserve">
          <source>Preserving state</source>
          <target state="translated">状態の維持</target>
        </trans-unit>
        <trans-unit id="fe5671922bc7f67cfabfa60ab97a9542ac21f39f" translate="yes" xml:space="preserve">
          <source>Promise</source>
          <target state="translated">Promise</target>
        </trans-unit>
        <trans-unit id="8dc7952272c26facc9a2c5604edbd77344108471" translate="yes" xml:space="preserve">
          <source>Property-Style Access</source>
          <target state="translated">物件別アクセス</target>
        </trans-unit>
        <trans-unit id="5fffd76e54cabe19ee1677cc2622cd23e6e275e9" translate="yes" xml:space="preserve">
          <source>Reactively watch &lt;code&gt;fn&lt;/code&gt;'s return value, and call the callback when the value changes. &lt;code&gt;fn&lt;/code&gt; receives the store's state as the first argument, and getters as the second argument. Accepts an optional options object that takes the same options as &lt;a href=&quot;https://vuejs.org/v2/api/#vm-watch&quot;&gt;Vue's &lt;code&gt;vm.$watch&lt;/code&gt; method&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; の戻り値を反応的に監視し、値が変化したときにコールバックを呼び出します。 &lt;code&gt;fn&lt;/code&gt; は、最初の引数としてストアの状態を受け取り、2番目の引数としてゲッターを受け取ります。&lt;a href=&quot;https://vuejs.org/v2/api/#vm-watch&quot;&gt;Vueの &lt;code&gt;vm.$watch&lt;/code&gt; メソッド&lt;/a&gt;と同じオプションを取るオプションのオプションオブジェクトを受け入れます。</target>
        </trans-unit>
        <trans-unit id="75e4ab33b7b5dc7455e9eadf2e7119121508fb6e" translate="yes" xml:space="preserve">
          <source>Register Global Action in Namespaced Modules</source>
          <target state="translated">名前空間モジュールにグローバルアクションを登録する</target>
        </trans-unit>
        <trans-unit id="de6210ec05f575ccd3825af5410dca87db3c1a7e" translate="yes" xml:space="preserve">
          <source>Register a dynamic module. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">動的モジュールを登録します。&lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad2bb0219d3b7cad70e9aeaf8b370461d8c5f459" translate="yes" xml:space="preserve">
          <source>Register actions on the store. The handler function receives a &lt;code&gt;context&lt;/code&gt; object that exposes the following properties:</source>
          <target state="translated">ストアにアクションを登録します。ハンドラー関数は、次のプロパティを公開する &lt;code&gt;context&lt;/code&gt; オブジェクトを受け取ります。</target>
        </trans-unit>
        <trans-unit id="0c3c4cb0360b08ab239d9d6ce7ef5979c7bd75c9" translate="yes" xml:space="preserve">
          <source>Register getters on the store. The getter function receives the following arguments:</source>
          <target state="translated">ストアにゲッターを登録します。ゲッター関数は以下の引数を受け取ります。</target>
        </trans-unit>
        <trans-unit id="b656445541eada906150dd7ca28e7277b3f8ac2d" translate="yes" xml:space="preserve">
          <source>Register mutations on the store. The handler function always receives &lt;code&gt;state&lt;/code&gt; as the first argument (will be module local state if defined in a module), and receives a second &lt;code&gt;payload&lt;/code&gt; argument if there is one.</source>
          <target state="translated">ミューテーションをストアに登録します。ハンドラー関数は常に最初の引数として &lt;code&gt;state&lt;/code&gt; を受け取り（モジュールで定義されている場合はモジュールローカル状態になります）、2番目の &lt;code&gt;payload&lt;/code&gt; 引数がある場合はそれを受け取ります。</target>
        </trans-unit>
        <trans-unit id="17a6292e850aa27ddd8a69f3670d7bf427ff4201" translate="yes" xml:space="preserve">
          <source>Register the same module multiple times in the same store.</source>
          <target state="translated">同一店舗で同一モジュールを複数回登録する。</target>
        </trans-unit>
        <trans-unit id="9adccc4f4e3ee229d76671c447375a4b4430cf1a" translate="yes" xml:space="preserve">
          <source>Registered getters are exposed on &lt;code&gt;store.getters&lt;/code&gt;.</source>
          <target state="translated">登録されたゲッターは &lt;code&gt;store.getters&lt;/code&gt; で公開されます。</target>
        </trans-unit>
        <trans-unit id="e74661ca249919f9eff75810910ad50f600b9f27" translate="yes" xml:space="preserve">
          <source>Replace that Object with a fresh one. For example, using the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread syntax&lt;/a&gt; we can write it like this:</source>
          <target state="translated">そのオブジェクトを新しいオブジェクトに置き換えます。たとえば、&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;オブジェクトスプレッド構文&lt;/a&gt;を使用すると、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="cfc7d1d9a1abac11e07fd8298b3033a2dd367be4" translate="yes" xml:space="preserve">
          <source>Replace the store's root state. Use this only for state hydration / time-travel purposes.</source>
          <target state="translated">ストアのルートステートを入れ替えます。状態のハイドレーション/タイムトラベル目的のみに使用します。</target>
        </trans-unit>
        <trans-unit id="7ec9eede60ad8e8637510a86e616531533ada02f" translate="yes" xml:space="preserve">
          <source>Running Tests</source>
          <target state="translated">テストの実行</target>
        </trans-unit>
        <trans-unit id="11b20f83f47c6fa0a2ecb66cf17c37a8bf3312ce" translate="yes" xml:space="preserve">
          <source>Running in Browser</source>
          <target state="translated">ブラウザでの実行</target>
        </trans-unit>
        <trans-unit id="27b89784a5a88ae4dea9d0fe0a57d6ac83db22be" translate="yes" xml:space="preserve">
          <source>Running in Browser with Karma + karma-webpack</source>
          <target state="translated">Karma+karma-webpackでブラウザでの実行</target>
        </trans-unit>
        <trans-unit id="cbd1c1641d5f61fff635a6b95f6786707cdb60a6" translate="yes" xml:space="preserve">
          <source>Running in Node</source>
          <target state="translated">ノードでの実行</target>
        </trans-unit>
        <trans-unit id="b7a73f532334578b3a16beb74895158fa37aca37" translate="yes" xml:space="preserve">
          <source>Similar to plugins, we can let the build tools handle that:</source>
          <target state="translated">プラグインと同様に、ビルドツールに任せればいいのです。</target>
        </trans-unit>
        <trans-unit id="6440404824fd3c3690de22244c1449cd72882e79" translate="yes" xml:space="preserve">
          <source>Similarly, inside module actions, &lt;code&gt;context.state&lt;/code&gt; will expose the local state, and root state will be exposed as &lt;code&gt;context.rootState&lt;/code&gt;:</source>
          <target state="translated">同様に、モジュールアクション内では、 &lt;code&gt;context.state&lt;/code&gt; はローカル状態を公開し、ルート状態は &lt;code&gt;context.rootState&lt;/code&gt; として公開されます。</target>
        </trans-unit>
        <trans-unit id="025e718449a36bec79871ddaaf94c1265848b2f1" translate="yes" xml:space="preserve">
          <source>Since 3.1.0, &lt;code&gt;subscribeAction&lt;/code&gt; can also specify whether the subscribe handler should be called &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; an action dispatch (the default behavior is &lt;em&gt;before&lt;/em&gt;):</source>
          <target state="translated">3.1.0以降、 &lt;code&gt;subscribeAction&lt;/code&gt; は、アクションディスパッチの&lt;em&gt;前&lt;/em&gt;と&lt;em&gt;後の&lt;/em&gt;どちらでサブスクライブハンドラを呼び出すかを指定することもできます（デフォルトの動作は&lt;em&gt;beforeです&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="f3fd68e0c5995c6798e0356b50e929c10917b3a4" translate="yes" xml:space="preserve">
          <source>Since a Vuex store's state is made reactive by Vue, when we mutate the state, Vue components observing the state will update automatically. This also means Vuex mutations are subject to the same reactivity caveats when working with plain Vue:</source>
          <target state="translated">Vuexストアの状態はVueによってリアクティブにされるため、状態を変異させると、その状態を観測しているVueコンポーネントが自動的に更新されます。これはまた、Vuex の変異は、プレーンな Vue で作業する場合と同じ反応性の注意事項の対象となることを意味します。</target>
        </trans-unit>
        <trans-unit id="92041cc87d58be0a729eade29063235fe14b3c9c" translate="yes" xml:space="preserve">
          <source>Single State Tree</source>
          <target state="translated">シングルステートツリー</target>
        </trans-unit>
        <trans-unit id="5f6ffb7192daf8fe93bcac0572129c5101463336" translate="yes" xml:space="preserve">
          <source>So how do we display state inside the store in our Vue components? Since Vuex stores are reactive, the simplest way to &quot;retrieve&quot; state from it is simply returning some store state from within a &lt;a href=&quot;https://vuejs.org/guide/computed.html&quot;&gt;computed property&lt;/a&gt;:</source>
          <target state="translated">では、ストア内の状態をVueコンポーネントにどのように表示するのでしょうか。Vuexストアはリアクティブなので、Vuexストアから状態を「取得」する最も簡単な方法は、&lt;a href=&quot;https://vuejs.org/guide/computed.html&quot;&gt;計算されたプロパティ&lt;/a&gt;内からストア状態を単に返すことです。</target>
        </trans-unit>
        <trans-unit id="54d205729e342259f235761f9ebec2b225fe9abb" translate="yes" xml:space="preserve">
          <source>So why don't we extract the shared state out of the components, and manage it in a global singleton? With this, our component tree becomes a big &quot;view&quot;, and any component can access the state or trigger actions, no matter where they are in the tree!</source>
          <target state="translated">では、コンポーネントから共有状態を抽出して、グローバルなシングルトンで管理してはどうでしょうか?これにより、コンポーネントツリーが大きな「ビュー」になり、どのコンポーネントもツリーのどこにいても状態にアクセスしたり、アクションをトリガーしたりすることができるようになります。</target>
        </trans-unit>
        <trans-unit id="f9f500529b87d6c41aa1c9ce2a53ab85b0f73f09" translate="yes" xml:space="preserve">
          <source>Sometimes a plugin may want to receive &quot;snapshots&quot; of the state, and also compare the post-mutation state with pre-mutation state. To achieve that, you will need to perform a deep-copy on the state object:</source>
          <target state="translated">プラグインがステートの「スナップショット」を受け取りたい場合があり、また、ミューテーション後のステートとミューテーション前のステートを比較したい場合があります。そのためには、ステートオブジェクトのディープコピーを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="ae8a5bdac2cd3270ab81602ae7fc6131bdbc35db" translate="yes" xml:space="preserve">
          <source>Sometimes we may need to compute derived state based on store state, for example filtering through a list of items and counting them:</source>
          <target state="translated">たとえば、アイテムのリストをフィルタリングして数えるなど、ストアの状態に基づいて派生した状態を計算する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="35ae76006ac7e393b8d6ac1ac6f19a1ddefd3da2" translate="yes" xml:space="preserve">
          <source>Sometimes we may need to create multiple instances of a module, for example:</source>
          <target state="translated">モジュールのインスタンスを複数作成する必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="13e4487543b6d8b06a46672cfa73442042e5fe18" translate="yes" xml:space="preserve">
          <source>Specific when defined in a module</source>
          <target state="translated">モジュールで定義されている場合は特定</target>
        </trans-unit>
        <trans-unit id="aabf420288f022d987bce3f9558b9c31ba749e69" translate="yes" xml:space="preserve">
          <source>Start &lt;code&gt;webpack-dev-server&lt;/code&gt; using the config.</source>
          <target state="translated">スタート &lt;code&gt;webpack-dev-server&lt;/code&gt; 設定を使用します。</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="9e2f83ae922aab27ffe541f2875e43e6786c6d9f" translate="yes" xml:space="preserve">
          <source>StoreOptions.actions</source>
          <target state="translated">StoreOptions.actions</target>
        </trans-unit>
        <trans-unit id="7c2fb974fe6ac37076408fe6492caf0b5a840a6c" translate="yes" xml:space="preserve">
          <source>StoreOptions.devtools</source>
          <target state="translated">StoreOptions.devtools</target>
        </trans-unit>
        <trans-unit id="27bc45330a80e26b40635dc4a8b8fc17abc36877" translate="yes" xml:space="preserve">
          <source>StoreOptions.getters</source>
          <target state="translated">StoreOptions.getters</target>
        </trans-unit>
        <trans-unit id="13d89889e279cf3f4db38944cc0e1b9022ac7e5b" translate="yes" xml:space="preserve">
          <source>StoreOptions.modules</source>
          <target state="translated">StoreOptions.modules</target>
        </trans-unit>
        <trans-unit id="f35c2bfcf842e192031830ea98d80cec6e137cc2" translate="yes" xml:space="preserve">
          <source>StoreOptions.mutations</source>
          <target state="translated">StoreOptions.mutations</target>
        </trans-unit>
        <trans-unit id="9b08c590c8720def20c8cc4d49a23a43f356dabe" translate="yes" xml:space="preserve">
          <source>StoreOptions.plugins</source>
          <target state="translated">StoreOptions.plugins</target>
        </trans-unit>
        <trans-unit id="249ab110bf5289e564529ec006774bd6849ef3fa" translate="yes" xml:space="preserve">
          <source>StoreOptions.state</source>
          <target state="translated">StoreOptions.state</target>
        </trans-unit>
        <trans-unit id="057f939fdf0b4897b3dea09feff450cb50fdf3a3" translate="yes" xml:space="preserve">
          <source>StoreOptions.strict</source>
          <target state="translated">StoreOptions.strict</target>
        </trans-unit>
        <trans-unit id="7c183131363f4251f89993f5090afc10d8f0caad" translate="yes" xml:space="preserve">
          <source>Strict Mode</source>
          <target state="translated">厳格なモード</target>
        </trans-unit>
        <trans-unit id="cb4be8ac142fac6db9e88ed567eba8eb3225184f" translate="yes" xml:space="preserve">
          <source>Subscribe to store actions. The &lt;code&gt;handler&lt;/code&gt; is called for every dispatched action and receives the action descriptor and current store state as arguments:</source>
          <target state="translated">ストアアクションにサブスクライブします。 &lt;code&gt;handler&lt;/code&gt; 、すべてのアクションを派遣し、引数として行動記述子と現在のストアの状態を受信するために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cf1e862a182cd71e72218de4a57d6428ba414773" translate="yes" xml:space="preserve">
          <source>Subscribe to store mutations. The &lt;code&gt;handler&lt;/code&gt; is called after every mutation and receives the mutation descriptor and post-mutation state as arguments:</source>
          <target state="translated">ミューテーションを登録してください。 &lt;code&gt;handler&lt;/code&gt; 、すべての変異後に呼び出され、引数として突然変異記述子とポスト変異状態を受信されています。</target>
        </trans-unit>
        <trans-unit id="4a190c880575f8d6d89a23b4172d04f0a311e4e6" translate="yes" xml:space="preserve">
          <source>Taking State Snapshots</source>
          <target state="translated">状態のスナップショットの取得</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="c59410bf3ca2f20fd8b0393728deccf2dc47f93a" translate="yes" xml:space="preserve">
          <source>Testing Actions</source>
          <target state="translated">テスト動作</target>
        </trans-unit>
        <trans-unit id="34e8d11332da2e378672d0a243a1d14c5129d499" translate="yes" xml:space="preserve">
          <source>Testing Getters</source>
          <target state="translated">テスティングゲッター</target>
        </trans-unit>
        <trans-unit id="97aad71ba2619e15a2576f93a06f963d9f14710f" translate="yes" xml:space="preserve">
          <source>Testing Mutations</source>
          <target state="translated">変異のテスト</target>
        </trans-unit>
        <trans-unit id="75a5f0cdaf9e2b8de2bd8a7b0367c1b182465746" translate="yes" xml:space="preserve">
          <source>The &quot;Vuex way&quot; to deal with it is binding the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;'s value and call an action on the &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="translated">これを処理するための「Vuexの方法」は、 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; の値をバインドし、 &lt;code&gt;input&lt;/code&gt; または &lt;code&gt;change&lt;/code&gt; イベントでアクションを呼び出します。</target>
        </trans-unit>
        <trans-unit id="7f04c49ca29bd705949d5268ee1592e8506b75b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;createLogger&lt;/code&gt; function takes a few options:</source>
          <target state="translated">&lt;code&gt;createLogger&lt;/code&gt; の機能は、いくつかのオプションをとります。</target>
        </trans-unit>
        <trans-unit id="7f82a0b0f64bd49ff203795584f21da841843a62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapGetters&lt;/code&gt; Helper</source>
          <target state="translated">&lt;code&gt;mapGetters&lt;/code&gt; ヘルパー</target>
        </trans-unit>
        <trans-unit id="98e2bb1175bd22373105493a5a1bff66a0f61906" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapGetters&lt;/code&gt; helper simply maps store getters to local computed properties:</source>
          <target state="translated">&lt;code&gt;mapGetters&lt;/code&gt; ヘルパーは、単にローカル計算されたプロパティに格納ゲッターをマッピングします。</target>
        </trans-unit>
        <trans-unit id="1c64da128ff2a5fa70401dea47d5ef1a1c1ebe06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapState&lt;/code&gt; Helper</source>
          <target state="translated">&lt;code&gt;mapState&lt;/code&gt; ヘルパー</target>
        </trans-unit>
        <trans-unit id="536ee7b8ae92c527384d1572270e55ace22c2cdd" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;actions&lt;/strong&gt;, the possible ways the state could change in reaction to user inputs from the &lt;strong&gt;view&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;アクション&lt;/strong&gt;、状態はからのユーザ入力に反応して変化する可能性が考えられる方法&lt;strong&gt;ビュー&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="44d7e5a292944a9b8f0f212a5769200231c994ce" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state&lt;/strong&gt;, the source of truth that drives our app;</source>
          <target state="translated">&lt;strong&gt;状態&lt;/strong&gt;、我々のアプリを駆動真理の源。</target>
        </trans-unit>
        <trans-unit id="c7a29052af8d9c9885446ea356702c7246ba9728" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;view&lt;/strong&gt;, a declarative mapping of the &lt;strong&gt;state&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong&gt;ビュー&lt;/strong&gt;の宣言的マッピング&lt;strong&gt;状態&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6efff60c6e384f46bfee8d934ae7afa0e3123d5a" translate="yes" xml:space="preserve">
          <source>The Simplest Store</source>
          <target state="translated">一番シンプルなお店</target>
        </trans-unit>
        <trans-unit id="bad57ff3f59fd1cdbd6a9c2eb4f3c380f8789e16" translate="yes" xml:space="preserve">
          <source>The data you store in Vuex follows the same rules as the &lt;code&gt;data&lt;/code&gt; in a Vue instance, ie the state object must be plain. &lt;strong&gt;See also:&lt;/strong&gt;&lt;a href=&quot;https://vuejs.org/v2/api/#data&quot;&gt;Vue#data&lt;/a&gt;.</source>
          <target state="translated">Vuexに保存する &lt;code&gt;data&lt;/code&gt; は、Vueインスタンスのデータと同じルールに従います。つまり、状態オブジェクトはプレーンでなければなりません。&lt;strong&gt;参照：&lt;/strong&gt;&lt;a href=&quot;https://vuejs.org/v2/api/#data&quot;&gt;Vue＃data&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b279e03c4074677e1ff56b9ff66e460fb14fa89" translate="yes" xml:space="preserve">
          <source>The first argument can optionally be a namespace string. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">最初の引数は、オプションで名前空間文字列にすることができます。&lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bcb1f41246213850c11b36c10d1fea79e5d77bc" translate="yes" xml:space="preserve">
          <source>The first thing to know is that &lt;code&gt;store.dispatch&lt;/code&gt; can handle Promise returned by the triggered action handler and it also returns Promise:</source>
          <target state="translated">最初に知って &lt;code&gt;store.dispatch&lt;/code&gt; ことは、store.dispatchがトリガーされたアクションハンドラーによって返されたPromiseを処理できることと、Promiseを返すことです。</target>
        </trans-unit>
        <trans-unit id="33d9183239b6fa2ab9370efe48b42def65630f59" translate="yes" xml:space="preserve">
          <source>The getters will be exposed on the &lt;code&gt;store.getters&lt;/code&gt; object, and you access values as properties:</source>
          <target state="translated">getterは &lt;code&gt;store.getters&lt;/code&gt; オブジェクトで公開され、プロパティとして値にアクセスします。</target>
        </trans-unit>
        <trans-unit id="188d06901f5c54b49ca05463c758d45fe516d6f3" translate="yes" xml:space="preserve">
          <source>The logger file can also be included directly via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, and will expose the &lt;code&gt;createVuexLogger&lt;/code&gt; function globally.</source>
          <target state="translated">ロガーファイルは、 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを介して直接含めることもでき、 &lt;code&gt;createVuexLogger&lt;/code&gt; 関数をグローバルに公開します。</target>
        </trans-unit>
        <trans-unit id="7f53ab8729ac1f593a9e9d471a3a3f15e2c84ca7" translate="yes" xml:space="preserve">
          <source>The main parts we want to unit test in Vuex are mutations and actions.</source>
          <target state="translated">Vuexでユニットテストしたい主な部分は、突然変異とアクションです。</target>
        </trans-unit>
        <trans-unit id="5f7f524307005481f2e4aca2c93d29527f99f1e2" translate="yes" xml:space="preserve">
          <source>The module's state will be exposed as &lt;code&gt;store.state.myModule&lt;/code&gt; and &lt;code&gt;store.state.nested.myModule&lt;/code&gt;.</source>
          <target state="translated">モジュールの状態は、 &lt;code&gt;store.state.myModule&lt;/code&gt; および &lt;code&gt;store.state.nested.myModule&lt;/code&gt; として公開されます。</target>
        </trans-unit>
        <trans-unit id="fbed472d8720aba4f0e28e8c80ccedb98ce30b99" translate="yes" xml:space="preserve">
          <source>The only way to actually change state in a Vuex store is by committing a mutation. Vuex mutations are very similar to events: each mutation has a string &lt;strong&gt;type&lt;/strong&gt; and a &lt;strong&gt;handler&lt;/strong&gt;. The handler function is where we perform actual state modifications, and it will receive the state as the first argument:</source>
          <target state="translated">Vuexストアで実際に状態を変更する唯一の方法は、ミューテーションをコミットすることです。Vuexミューテーションはイベントとよく似ています。各ミューテーションには文字列&lt;strong&gt;タイプ&lt;/strong&gt;と&lt;strong&gt;ハンドラーがあり&lt;/strong&gt;ます。ハンドラー関数は、実際の状態変更を実行する場所であり、最初の引数として状態を受け取ります。</target>
        </trans-unit>
        <trans-unit id="a6a0b4e8e1721ea8c21549fafae87877e2734097" translate="yes" xml:space="preserve">
          <source>The only way to mutate the state is by committing &lt;strong&gt;mutations&lt;/strong&gt;, which are synchronous transactions.</source>
          <target state="translated">状態を変異させるための唯一の方法は、コミットしている&lt;strong&gt;変異&lt;/strong&gt;同期トランザクションです。</target>
        </trans-unit>
        <trans-unit id="46e235aa33469d6967a6809446c33b1593819a40" translate="yes" xml:space="preserve">
          <source>The plugin will be used by default. For production, you will need &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; for webpack or &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; for Browserify to convert the value of &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for the final build.</source>
          <target state="translated">プラグインはデフォルトで使用されます。生産のために、あなたが必要となります&lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePluginを&lt;/a&gt; WebPACKのためか、&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; Browserifyはの値に変換するため &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; に &lt;code&gt;false&lt;/code&gt; 最終ビルドのために。</target>
        </trans-unit>
        <trans-unit id="f01042e3fecd699c90149ef1ee5ae1c35a436639" translate="yes" xml:space="preserve">
          <source>The root state object for the Vuex store. &lt;a href=&quot;../guide/state&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Vuexストアのルート状態オブジェクト。&lt;a href=&quot;../guide/state&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0280fc5ea89ec8da31027d69c613be9a3c9680dc" translate="yes" xml:space="preserve">
          <source>The root state. Read only.</source>
          <target state="translated">ルートの状態。読み取り専用。</target>
        </trans-unit>
        <trans-unit id="2c3de3def96fcc05fedc5eb419a984266aa2428b" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(commit: function, ...args: any[])&lt;/code&gt;</source>
          <target state="translated">2番目のオブジェクト引数のメンバーは関数にすることができます。 &lt;code&gt;function(commit: function, ...args: any[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26cd7f1bcabc21254ac5b9199d279b0ef8555a89" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(dispatch: function, ...args: any[])&lt;/code&gt;</source>
          <target state="translated">2番目のオブジェクト引数のメンバーは関数にすることができます。 &lt;code&gt;function(dispatch: function, ...args: any[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fdcb9da7768a075ddd1fe33f0287a0514029824" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(state: any)&lt;/code&gt;</source>
          <target state="translated">2番目のオブジェクト引数のメンバーは関数にすることができます。 &lt;code&gt;function(state: any)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="038cb5b264feb5642de1de9d5ce3def91138027b" translate="yes" xml:space="preserve">
          <source>The single state tree does not conflict with modularity - in later chapters we will discuss how to split your state and mutations into sub modules.</source>
          <target state="translated">単一の状態ツリーはモジュール化と矛盾しません-後の章では、状態と変異をサブモジュールに分割する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="b7e90dfde3eb455667e93149720981dac77b8e85" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;window.Promise&lt;/code&gt; will be available automatically.</source>
          <target state="translated">次に &lt;code&gt;window.Promise&lt;/code&gt; が自動的に使用可能になります。</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="e5b6185e9c9c13a311c71ea345f0a1bcffe543f2" translate="yes" xml:space="preserve">
          <source>This is actually the exact same problem with &lt;code&gt;data&lt;/code&gt; inside Vue components. So the solution is also the same - use a function for declaring module state (supported in 2.3.0+):</source>
          <target state="translated">これは実際には、Vueコンポーネント内の &lt;code&gt;data&lt;/code&gt; とまったく同じ問題です。したがって、解決策も同じです-モジュールの状態を宣言するための関数を使用します（2.3.0以降でサポートされています）：</target>
        </trans-unit>
        <trans-unit id="32e874b1aade463ecb43dfd8a24212e0197c777b" translate="yes" xml:space="preserve">
          <source>This is an simple representation of the concept of &quot;one-way data flow&quot;:</source>
          <target state="translated">これは「一方通行のデータの流れ」という概念をシンプルに表現したものです。</target>
        </trans-unit>
        <trans-unit id="e4ae803eb94d79146b96a33ead3a2a7574ab90f7" translate="yes" xml:space="preserve">
          <source>This is the basic idea behind Vuex, inspired by &lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; and &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;. Unlike the other patterns, Vuex is also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates.</source>
          <target state="translated">これは、&lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot;&gt;Flux&lt;/a&gt;、&lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt;、&lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;に触発されたVuexの背後にある基本的なアイデアです。他のパターンとは異なり、Vuexは、効率的な更新のためにその細かい反応性システムを利用するためにVue.js用に特別に調整されたライブラリ実装でもあります。</target>
        </trans-unit>
        <trans-unit id="1ac43b405b6b649d36442b0894b012509c8256f1" translate="yes" xml:space="preserve">
          <source>This may look silly at first sight: if we want to increment the count, why don't we just call &lt;code&gt;store.commit('increment')&lt;/code&gt; directly? Remember that &lt;strong&gt;mutations have to be synchronous&lt;/strong&gt;? Actions don't. We can perform &lt;strong&gt;asynchronous&lt;/strong&gt; operations inside an action:</source>
          <target state="translated">これは一見するとばかげているように見えるかもしれません。カウントをインクリメントする場合は、直接 &lt;code&gt;store.commit('increment')&lt;/code&gt; を呼び出さないのはなぜですか？&lt;strong&gt;変異は同期している必要があることを&lt;/strong&gt;覚えていますか？アクションはしません。アクション内で&lt;strong&gt;非同期&lt;/strong&gt;操作を実行できます。</target>
        </trans-unit>
        <trans-unit id="2fad06b8194c84f29399e28d3869f1cd5156e9bf" translate="yes" xml:space="preserve">
          <source>To dispatch actions or commit mutations in the global namespace, pass &lt;code&gt;{ root: true }&lt;/code&gt; as the 3rd argument to &lt;code&gt;dispatch&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt;.</source>
          <target state="translated">グローバルネームスペースでアクションをディスパッチまたは変更をコミットするには、 &lt;code&gt;dispatch&lt;/code&gt; および &lt;code&gt;commit&lt;/code&gt; 3番目の引数として &lt;code&gt;{ root: true }&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="c9a17f7fd54b6a036cf2a11b136e992ee23b897e" translate="yes" xml:space="preserve">
          <source>To enable strict mode, simply pass in &lt;code&gt;strict: true&lt;/code&gt; when creating a Vuex store:</source>
          <target state="translated">ストリクトモードを有効にするには、Vuexストアを作成するときに &lt;code&gt;strict: true&lt;/code&gt; 渡すだけです。</target>
        </trans-unit>
        <trans-unit id="b4555cdaed64feb01f23395f68a87fbe45b67dce" translate="yes" xml:space="preserve">
          <source>To handle asynchronous operations, let's introduce &lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt;.</source>
          <target state="translated">非同期操作を処理するために、&lt;a href=&quot;actions&quot;&gt;アクションを&lt;/a&gt;導入しましょう。</target>
        </trans-unit>
        <trans-unit id="4195b1d72692d3750d2a410e7d9981a761f2d655" translate="yes" xml:space="preserve">
          <source>To help with that, Vuex allows us to divide our store into &lt;strong&gt;modules&lt;/strong&gt;. Each module can contain its own state, mutations, actions, getters, and even nested modules - it's fractal all the way down:</source>
          <target state="translated">これを支援するために、Vuexではストアを&lt;strong&gt;モジュール&lt;/strong&gt;に分割でき&lt;strong&gt;ます&lt;/strong&gt;。各モジュールには、独自の状態、ミューテーション、アクション、ゲッター、さらにはネストされたモジュールさえ含めることができます-それはずっと下のフラクタルです：</target>
        </trans-unit>
        <trans-unit id="47c12dedfc5d2ae19c1382030d2827746c9b159b" translate="yes" xml:space="preserve">
          <source>To stop subscribing, call the returned unsubscribe function.</source>
          <target state="translated">購読を停止するには、返されたunsubscribe関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="b38919feb133ed92197ba6b4d1ca2851ce856830" translate="yes" xml:space="preserve">
          <source>To stop watching, call the returned unwatch function.</source>
          <target state="translated">ウォッチを停止するには、返された unwatch 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Scrimbaのレッスンを試してみる</target>
        </trans-unit>
        <trans-unit id="eb9df75c2e4aa99920a38d6895f257e82c103c0e" translate="yes" xml:space="preserve">
          <source>Turn the devtools on or off for a particular vuex instance. For instance passing false tells the Vuex store to not subscribe to devtools plugin. Useful for if you have multiple stores on a single page.</source>
          <target state="translated">特定の vuex インスタンスに対して devtools をオンまたはオフにします。例えば false を渡すと、Vuex ストアは devtools プラグインを購読しないようになります。一つのページに複数のストアがある場合に便利です。</target>
        </trans-unit>
        <trans-unit id="6d53cb5abedd0ebe3cd4c7395842755f71c30dbc" translate="yes" xml:space="preserve">
          <source>Two-way Computed Property</source>
          <target state="translated">双方向計算されたプロパティ</target>
        </trans-unit>
        <trans-unit id="58a34f2bdebff21a52c61f411732c8009ceffd74" translate="yes" xml:space="preserve">
          <source>Unregister a dynamic module. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">動的モジュールの登録を解除します。&lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;細部&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e189823fb0c39c232d21cb4f56d5d5263ffa4a9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt;, or</source>
          <target state="translated">使用 &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt; 、または</target>
        </trans-unit>
        <trans-unit id="b49c80c66c6311a904333a467355c7e6bf1e59e1" translate="yes" xml:space="preserve">
          <source>Using Constants for Mutation Types</source>
          <target state="translated">変異型に定数を使用する</target>
        </trans-unit>
        <trans-unit id="2a3ef6422ba574dc83a7da5c0294678dde94d811" translate="yes" xml:space="preserve">
          <source>Using Vuex doesn't mean you should put &lt;strong&gt;all&lt;/strong&gt; the state in Vuex. Although putting more state into Vuex makes your state mutations more explicit and debuggable, sometimes it could also make the code more verbose and indirect. If a piece of state strictly belongs to a single component, it could be just fine leaving it as local state. You should weigh the trade-offs and make decisions that fit the development needs of your app.</source>
          <target state="translated">Vuexを使用しても、&lt;strong&gt;すべて&lt;/strong&gt;の状態をVuexに置く必要があるわけではありません。より多くの状態をVuexに入れると、状態の変化がより明示的でデバッグ可能になりますが、コードがより冗長で間接的になることもあります。状態の一部が1つのコンポーネントに厳密に属している場合は、ローカル状態のままにしておいても問題はありません。トレードオフを比較検討し、アプリの開発ニーズに合った決定を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="0c1ee6f0263ee019fc5e3fcd7fa266eb225b6cc7" translate="yes" xml:space="preserve">
          <source>Using store state in a component simply involves returning the state within a computed property, because the store state is reactive. Triggering changes simply means committing mutations in component methods.</source>
          <target state="translated">ストア・ステートはリアクティブであるため、コンポーネントでストア・ステートを使用すると、単純に計算されたプロパティ内のステートを返すことになります。変更をトリガーするということは、単にコンポーネント・メソッドに突然変異をコミットすることを意味します。</target>
        </trans-unit>
        <trans-unit id="de0b33121be26507e3433bd94203e17aa9b5f222" translate="yes" xml:space="preserve">
          <source>Vuex</source>
          <target state="translated">Vuex</target>
        </trans-unit>
        <trans-unit id="f0d6f301a857638a6008e626f1c08e4b841279dd" translate="yes" xml:space="preserve">
          <source>Vuex allows us to define &quot;getters&quot; in the store. You can think of them as computed properties for stores. Like computed properties, a getter's result is cached based on its dependencies, and will only re-evaluate when some of its dependencies have changed.</source>
          <target state="translated">Vuexでは、ストア内で「ゲッター」を定義することができます。これは、ストアの計算されたプロパティのようなものと考えることができます。計算されたプロパティと同様に、ゲッターの結果は依存関係に基づいてキャッシュされ、依存関係の一部が変更された場合にのみ再評価されます。</target>
        </trans-unit>
        <trans-unit id="0e2cd15820316b9d525f31489d6930bdf8394d91" translate="yes" xml:space="preserve">
          <source>Vuex comes with a logger plugin for common debugging usage:</source>
          <target state="translated">Vuexには、一般的なデバッグ用のロガープラグインが付属しています。</target>
        </trans-unit>
        <trans-unit id="97c7149a09097949a0cfcc2fbe94537dc69fb1ce" translate="yes" xml:space="preserve">
          <source>Vuex doesn't really restrict how you structure your code. Rather, it enforces a set of high-level principles:</source>
          <target state="translated">Vuexは、コードの構造を制限するものではありません。むしろ、一連の高レベルの原則を強制します。</target>
        </trans-unit>
        <trans-unit id="d17df34d062fc479eb107a94c88abf9ec059beae" translate="yes" xml:space="preserve">
          <source>Vuex helps us deal with shared state management with the cost of more concepts and boilerplate. It's a trade-off between short term and long term productivity.</source>
          <target state="translated">Vuexは、より多くの概念や定型文を犠牲にして、共有状態管理に対処するのに役立ちます。これは、短期的な生産性と長期的な生産性のトレードオフです。</target>
        </trans-unit>
        <trans-unit id="4865c12b8c32edd994472010e09de64c7196db52" translate="yes" xml:space="preserve">
          <source>Vuex is a &lt;strong&gt;state management pattern + library&lt;/strong&gt; for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. It also integrates with Vue's official &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;devtools extension&lt;/a&gt; to provide advanced features such as zero-config time-travel debugging and state snapshot export / import.</source>
          <target state="translated">Vuexは、Vue.jsアプリケーション用の&lt;strong&gt;状態管理パターン+ライブラリ&lt;/strong&gt;です。これは、状態が予測可能な方法でのみ変更できることを保証するルールにより、アプリケーション内のすべてのコンポーネントの集中ストアとして機能します。また、Vueの公式の&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;devtools拡張機能&lt;/a&gt;と統合して、zero-configタイムトラベルデバッグや状態スナップショットのエクスポート/インポートなどの高度な機能を提供します。</target>
        </trans-unit>
        <trans-unit id="0ab5b1ceae85cef3c7070700973eed24ddceb3f1" translate="yes" xml:space="preserve">
          <source>Vuex provides a mechanism to &quot;inject&quot; the store into all child components from the root component with the &lt;code&gt;store&lt;/code&gt; option (enabled by &lt;code&gt;Vue.use(Vuex)&lt;/code&gt;):</source>
          <target state="translated">Vuexは、 &lt;code&gt;store&lt;/code&gt; オプション（ &lt;code&gt;Vue.use(Vuex)&lt;/code&gt; によって有効化）を使用して、ルートコンポーネントからすべての子コンポーネントにストアを「挿入」するメカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="29e6083d0ea2da692697abc408390a78b3fbb6a1" translate="yes" xml:space="preserve">
          <source>Vuex requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;Promise&lt;/a&gt;. If your supporting browsers do not implement Promise (e.g. IE), you can use a polyfill library, such as &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;es6-promise&lt;/a&gt;.</source>
          <target state="translated">Vuexには&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;Promise&lt;/a&gt;が必要です。サポートするブラウザーがPromise（IEなど）を実装していない場合は、&lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;es6-promise&lt;/a&gt;などのポリフィルライブラリを使用できます。</target>
        </trans-unit>
        <trans-unit id="a7c44a44a893f704da779f2a6753cb99fdabc86c" translate="yes" xml:space="preserve">
          <source>Vuex stores accept the &lt;code&gt;plugins&lt;/code&gt; option that exposes hooks for each mutation. A Vuex plugin is simply a function that receives the store as the only argument:</source>
          <target state="translated">Vuexストアは、各ミューテーションのフックを公開する &lt;code&gt;plugins&lt;/code&gt; オプションを受け入れます。Vuexプラグインは、ストアを唯一の引数として受け取る関数です。</target>
        </trans-unit>
        <trans-unit id="f9de6b1a8f9893aec2c24f2eb638d08f8c27963a" translate="yes" xml:space="preserve">
          <source>Vuex stores are reactive. When Vue components retrieve state from it, they will reactively and efficiently update if the store's state changes.</source>
          <target state="translated">Vuex ストアはリアクティブです。Vue コンポーネントがそこから状態を取得すると、ストアの状態が変化した場合に反応的に効率的に更新します。</target>
        </trans-unit>
        <trans-unit id="d1005b8dfed9f5da523d44fa0408fb96e863b48e" translate="yes" xml:space="preserve">
          <source>Vuex supports hot-reloading mutations, modules, actions and getters during development, using webpack's &lt;a href=&quot;https://webpack.js.org/guides/hot-module-replacement/&quot;&gt;Hot Module Replacement API&lt;/a&gt;. You can also use it in Browserify with the &lt;a href=&quot;https://github.com/AgentME/browserify-hmr/&quot;&gt;browserify-hmr&lt;/a&gt; plugin.</source>
          <target state="translated">Vuexは、webpackの&lt;a href=&quot;https://webpack.js.org/guides/hot-module-replacement/&quot;&gt;Hot Module Replacement API&lt;/a&gt;を使用して、開発中のホットリロードミューテーション、モジュール、アクション、ゲッターをサポートしています。&lt;a href=&quot;https://github.com/AgentME/browserify-hmr/&quot;&gt;browserify-hmr&lt;/a&gt;プラグインを使用してBrowserifyで使用することもできます。</target>
        </trans-unit>
        <trans-unit id="1c91ec10df2bcecd2b18c0eb4c34783559fcaf6b" translate="yes" xml:space="preserve">
          <source>Vuex uses a &lt;strong&gt;single state tree&lt;/strong&gt; - that is, this single object contains all your application level state and serves as the &quot;single source of truth&quot;. This also means usually you will have only one store for each application. A single state tree makes it straightforward to locate a specific piece of state, and allows us to easily take snapshots of the current app state for debugging purposes.</source>
          <target state="translated">Vuexは&lt;strong&gt;単一の状態ツリーを&lt;/strong&gt;使用します。つまり、この単一のオブジェクトはすべてのアプリケーションレベルの状態を含み、「真の単一のソース」として機能します。これは、通常、アプリケーションごとにストアが1つしかないことも意味します。単一の状態ツリーを使用すると、特定の状態を簡単に特定でき、デバッグのために現在のアプリの状態のスナップショットを簡単に取得できます。</target>
        </trans-unit>
        <trans-unit id="daddb132dbb693223d1a8285c450a768b5e90526" translate="yes" xml:space="preserve">
          <source>Vuex.Store</source>
          <target state="translated">Vuex.Store</target>
        </trans-unit>
        <trans-unit id="e27d6d35e937e025eb96c09b1248e5c2676afd99" translate="yes" xml:space="preserve">
          <source>Vuex.Store Constructor Options</source>
          <target state="translated">Vuex.Store コンストラクタ オプション</target>
        </trans-unit>
        <trans-unit id="a12ddea81e37a47b9cf92721a2c3b3dce724518b" translate="yes" xml:space="preserve">
          <source>Vuex.Store Instance Methods</source>
          <target state="translated">Vuex.Store インスタンスメソッド</target>
        </trans-unit>
        <trans-unit id="bf2e5bd997aabdf6407575808a7810ae806bc168" translate="yes" xml:space="preserve">
          <source>Vuex.Store Instance Properties</source>
          <target state="translated">Vuex.Store インスタンス プロパティ</target>
        </trans-unit>
        <trans-unit id="f9f831a5e0694e0c14522dd98fa88137c445d453" translate="yes" xml:space="preserve">
          <source>Vuex.Store.commit()</source>
          <target state="translated">Vuex.Store.commit()</target>
        </trans-unit>
        <trans-unit id="6525945e6ceed925f1b32505317c836dca657a7b" translate="yes" xml:space="preserve">
          <source>Vuex.Store.dispatch()</source>
          <target state="translated">Vuex.Store.dispatch()</target>
        </trans-unit>
        <trans-unit id="875eca0d2c435721934d6e21026feaf2c458121e" translate="yes" xml:space="preserve">
          <source>Vuex.Store.getters</source>
          <target state="translated">Vuex.Store.getters</target>
        </trans-unit>
        <trans-unit id="36f6be1d986b4f405099f5f30b602d52e9e30867" translate="yes" xml:space="preserve">
          <source>Vuex.Store.hotUpdate()</source>
          <target state="translated">Vuex.Store.hotUpdate()</target>
        </trans-unit>
        <trans-unit id="da4335e82262f6f8d6790534c7ad0926cc4745e2" translate="yes" xml:space="preserve">
          <source>Vuex.Store.registerModule()</source>
          <target state="translated">Vuex.Store.registerModule()</target>
        </trans-unit>
        <trans-unit id="94ac4b985f66595cf0a6092e1a82c5ad38bbb16b" translate="yes" xml:space="preserve">
          <source>Vuex.Store.replaceState()</source>
          <target state="translated">Vuex.Store.replaceState()</target>
        </trans-unit>
        <trans-unit id="4f304b4fdb3bf5548021e12438f19b8a3c837429" translate="yes" xml:space="preserve">
          <source>Vuex.Store.state</source>
          <target state="translated">Vuex.Store.state</target>
        </trans-unit>
        <trans-unit id="646d93a6768d3e6602cdefd17248482210916c01" translate="yes" xml:space="preserve">
          <source>Vuex.Store.subscribe()</source>
          <target state="translated">Vuex.Store.subscribe()</target>
        </trans-unit>
        <trans-unit id="f3e660b4b4bcbf28c208b2cb1849c08db1e4a864" translate="yes" xml:space="preserve">
          <source>Vuex.Store.subscribeAction()</source>
          <target state="translated">Vuex.Store.subscribeAction()</target>
        </trans-unit>
        <trans-unit id="ae9d201aeec49d5494691627724de63760974852" translate="yes" xml:space="preserve">
          <source>Vuex.Store.unregisterModule()</source>
          <target state="translated">Vuex.Store.unregisterModule()</target>
        </trans-unit>
        <trans-unit id="a78a21d356c3413617b93e60de03e3c4c85613bf" translate="yes" xml:space="preserve">
          <source>Vuex.Store.watch()</source>
          <target state="translated">Vuex.Store.watch()</target>
        </trans-unit>
        <trans-unit id="972f097fe8de7d9024e0cac7324df8bc2bd5d8a7" translate="yes" xml:space="preserve">
          <source>We can also pass a string array to &lt;code&gt;mapState&lt;/code&gt; when the name of a mapped computed property is the same as a state sub tree name.</source>
          <target state="translated">マップされた計算済みプロパティの名前が状態サブツリー名と同じである場合、文字列配列を &lt;code&gt;mapState&lt;/code&gt; に渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="62a0d6990ce81e2c8fb572ac1e1a0f61bc100c86" translate="yes" xml:space="preserve">
          <source>We can now easily make use of it inside any component:</source>
          <target state="translated">これで、どんなコンポーネントの中でも簡単に活用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="4e679c86924ed36ac40c73653131acb30c335823" translate="yes" xml:space="preserve">
          <source>What is Vuex?</source>
          <target state="translated">Vuexとは?</target>
        </trans-unit>
        <trans-unit id="4f7cb23fbc792a907900b6c227a08a9ce44bbb08" translate="yes" xml:space="preserve">
          <source>What is a &quot;State Management Pattern&quot;?</source>
          <target state="translated">状態管理パターン」とは?</target>
        </trans-unit>
        <trans-unit id="bfb57f97eebc790fb0f996df58cf05c904d765fe" translate="yes" xml:space="preserve">
          <source>When Should I Use It?</source>
          <target state="translated">いつ使うべきか?</target>
        </trans-unit>
        <trans-unit id="7049f8d400f975057b510f35754e4b4a55b8a447" translate="yes" xml:space="preserve">
          <source>When a component needs to make use of multiple store state properties or getters, declaring all these computed properties can get repetitive and verbose. To deal with this we can make use of the &lt;code&gt;mapState&lt;/code&gt; helper which generates computed getter functions for us, saving us some keystrokes:</source>
          <target state="translated">コンポーネントが複数のストア状態プロパティまたはゲッターを使用する必要がある場合、これらすべての計算されたプロパティを宣言すると、反復的で冗長になる可能性があります。これに対処するために、計算されたgetter関数を生成する &lt;code&gt;mapState&lt;/code&gt; ヘルパーを使用して、キーストロークをいくつか節約できます。</target>
        </trans-unit>
        <trans-unit id="c17e29a6e47a7d53eb7540fe5f43fd3c7ec25ef4" translate="yes" xml:space="preserve">
          <source>When adding new properties to an Object, you should either:</source>
          <target state="translated">オブジェクトに新しいプロパティを追加するときは、次のいずれかを実行します。</target>
        </trans-unit>
        <trans-unit id="efff342070587a8120ff0a0f2a1a6c593581e9da" translate="yes" xml:space="preserve">
          <source>When binding a namespaced module to components with the &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; and &lt;code&gt;mapMutations&lt;/code&gt; helpers, it can get a bit verbose:</source>
          <target state="translated">名前空間付きモジュールをコンポーネントに &lt;code&gt;mapState&lt;/code&gt; 、 &lt;code&gt;mapGetters&lt;/code&gt; 、 &lt;code&gt;mapActions&lt;/code&gt; 、 &lt;code&gt;mapMutations&lt;/code&gt; ヘルパーでバインドすると、少し冗長になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="99195dc5710842be6bed30d96a1def16fb32d71c" translate="yes" xml:space="preserve">
          <source>When used with a module system, you must explicitly install Vuex via &lt;code&gt;Vue.use()&lt;/code&gt;:</source>
          <target state="translated">モジュールシステムで使用する場合は、 &lt;code&gt;Vue.use()&lt;/code&gt; を使用してVuexを明示的にインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="77c1ff3694c93e3a5898ebf5b137f7620c5e12dd" translate="yes" xml:space="preserve">
          <source>When using Vuex in strict mode, it could be a bit tricky to use &lt;code&gt;v-model&lt;/code&gt; on a piece of state that belongs to Vuex:</source>
          <target state="translated">厳密モードでVuexを使用する場合、Vuexに属する状態の一部で &lt;code&gt;v-model&lt;/code&gt; を使用するのは少し難しいかもしれません。</target>
        </trans-unit>
        <trans-unit id="fd5fb9660a82033a1f5e0bdd5e988d5fee11ea79" translate="yes" xml:space="preserve">
          <source>When using object-style commit, the entire object will be passed as the payload to mutation handlers, so the handler remains the same:</source>
          <target state="translated">オブジェクトスタイルのコミットを使用する場合、オブジェクト全体がペイロードとして突然変異ハンドラに渡されるので、ハンドラはそのままです。</target>
        </trans-unit>
        <trans-unit id="64b97d35575f008d89a5abcf758506366a1df6c9" translate="yes" xml:space="preserve">
          <source>When you set &lt;code&gt;preserveState: true&lt;/code&gt;, the module is registered, actions, mutations and getters are added to the store, but the state not. It's assumed that your store state already contains state for that module and you don't want to overwrite it.</source>
          <target state="translated">&lt;code&gt;preserveState: true&lt;/code&gt; を設定すると、モジュールが登録され、アクション、ミューテーション、ゲッターがストアに追加されますが、状態は追加されません。ストアの状態にはすでにそのモジュールの状態が含まれており、それを上書きしたくないと想定しています。</target>
        </trans-unit>
        <trans-unit id="e0672c57fbbf8e8ecf0e7b63699f5a7c92edcd4d" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;store.state.count&lt;/code&gt; changes, it will cause the computed property to re-evaluate, and trigger associated DOM updates.</source>
          <target state="translated">たび &lt;code&gt;store.state.count&lt;/code&gt; の変化、それは再評価に計算されたプロパティを引き起こし、トリガ関連するDOMの更新されます。</target>
        </trans-unit>
        <trans-unit id="a085ea0f1aa78bea832392da9c502369be0887a2" translate="yes" xml:space="preserve">
          <source>Whether to use constants is largely a preference - it can be helpful in large projects with many developers, but it's totally optional if you don't like them.</source>
          <target state="translated">定数を使うかどうかは主に好みの問題です-多くの開発者がいる大規模なプロジェクトでは便利ですが、それが好きでない場合は完全に任意です。</target>
        </trans-unit>
        <trans-unit id="4de67a4d313139fb2f1d0ad9d2c13d0921ddb131" translate="yes" xml:space="preserve">
          <source>Yarn</source>
          <target state="translated">Yarn</target>
        </trans-unit>
        <trans-unit id="63134a6d55a8d86ebefa1d7e28dd4e4938a617f5" translate="yes" xml:space="preserve">
          <source>You can also pass arguments to getters by returning a function. This is particularly useful when you want to query an array in the store:</source>
          <target state="translated">関数を返すことで、引数をゲッターに渡すこともできます。これは、ストア内の配列を問い合わせたい場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="23de97b968754adb5c8071394c94800b27c8ebc7" translate="yes" xml:space="preserve">
          <source>You can also remove a dynamically registered module with &lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt;. Note you cannot remove static modules (declared at store creation) with this method.</source>
          <target state="translated">また、 &lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt; を使用して、動的に登録されたモジュールを削除することもできます。このメソッドでは、静的モジュール（ストアの作成時に宣言された）を削除できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d29c54157aed563d47280cf164e51dba16933038" translate="yes" xml:space="preserve">
          <source>You can commit mutations in components with &lt;code&gt;this.$store.commit('xxx')&lt;/code&gt;, or use the &lt;code&gt;mapMutations&lt;/code&gt; helper which maps component methods to &lt;code&gt;store.commit&lt;/code&gt; calls (requires root &lt;code&gt;store&lt;/code&gt; injection):</source>
          <target state="translated">&lt;code&gt;this.$store.commit('xxx')&lt;/code&gt; を使用してコンポーネントの変更をコミットするか、コンポーネントのメソッドを &lt;code&gt;store.commit&lt;/code&gt; 呼び出しにマップする &lt;code&gt;mapMutations&lt;/code&gt; ヘルパーを使用できます（ルート &lt;code&gt;store&lt;/code&gt; インジェクションが必要です）。</target>
        </trans-unit>
        <trans-unit id="1215721038a305c2ecee17f52181bc37f1909ea8" translate="yes" xml:space="preserve">
          <source>You can dispatch actions in components with &lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt;, or use the &lt;code&gt;mapActions&lt;/code&gt; helper which maps component methods to &lt;code&gt;store.dispatch&lt;/code&gt; calls (requires root &lt;code&gt;store&lt;/code&gt; injection):</source>
          <target state="translated">&lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt; を使用してコンポーネントのアクションをディスパッチするか、コンポーネントのメソッドを &lt;code&gt;store.dispatch&lt;/code&gt; 呼び出しにマップする &lt;code&gt;mapActions&lt;/code&gt; ヘルパーを使用できます（ルート &lt;code&gt;store&lt;/code&gt; インジェクションが必要です）。</target>
        </trans-unit>
        <trans-unit id="8881848045fd86241cc9c9d7d92edbe765adb62d" translate="yes" xml:space="preserve">
          <source>You can include it via CDN:</source>
          <target state="translated">CDN経由で入れることができます。</target>
        </trans-unit>
        <trans-unit id="25c0fe7b987a059291687c75ef24f147484cb473" translate="yes" xml:space="preserve">
          <source>You can pass an additional argument to &lt;code&gt;store.commit&lt;/code&gt;, which is called the &lt;strong&gt;payload&lt;/strong&gt; for the mutation:</source>
          <target state="translated">&lt;code&gt;store.commit&lt;/code&gt; の&lt;strong&gt;ペイロード&lt;/strong&gt;と呼ばれる追加の引数をstore.commitに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="3669fc0f4547fc417e6184797578f0ae3a315436" translate="yes" xml:space="preserve">
          <source>You can register a module &lt;strong&gt;after&lt;/strong&gt; the store has been created with the &lt;code&gt;store.registerModule&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;store.registerModule&lt;/code&gt; メソッドでストアを作成した&lt;strong&gt;後&lt;/strong&gt;、モジュールを登録できます。</target>
        </trans-unit>
        <trans-unit id="535a2512801117d140454c6e5cb378ba940f4b23" translate="yes" xml:space="preserve">
          <source>You cannot directly call a mutation handler. Think of it more like event registration: &quot;When a mutation with type &lt;code&gt;increment&lt;/code&gt; is triggered, call this handler.&quot; To invoke a mutation handler, you need to call &lt;code&gt;store.commit&lt;/code&gt; with its type:</source>
          <target state="translated">変異ハンドラーを直接呼び出すことはできません。それをイベント登録のように考えてください：「型が &lt;code&gt;increment&lt;/code&gt; れるミューテーションがトリガーされたら、このハンドラーを呼び出します。」変異ハンドラを呼び出すには、 &lt;code&gt;store.commit&lt;/code&gt; をそのタイプで呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="daa96a4f6ba2541961bc6b0ba61ad44c19c2cd8d" translate="yes" xml:space="preserve">
          <source>You cannot directly mutate the store's state. The only way to change a store's state is by explicitly &lt;strong&gt;committing mutations&lt;/strong&gt;. This ensures every state change leaves a track-able record, and enables tooling that helps us better understand our applications.</source>
          <target state="translated">ストアの状態を直接変更することはできません。ストアの状態を変更する唯一の方法は、明示的に変更&lt;strong&gt;をコミットすること&lt;/strong&gt;です。これにより、すべての状態変化が追跡可能な記録を残すことが保証され、アプリケーションの理解を深めるのに役立つツールが有効になります。</target>
        </trans-unit>
        <trans-unit id="360fc60f946b0e1fb46441c21ec094cefc382a47" translate="yes" xml:space="preserve">
          <source>You don't need to do this when using global script tags.</source>
          <target state="translated">グローバルスクリプトタグを使用している場合は必要ありません。</target>
        </trans-unit>
        <trans-unit id="c70f3011e5bb2100175201538c23d3b8d06c1f46" translate="yes" xml:space="preserve">
          <source>You may care about unpredictable namespacing for your modules when you create a &lt;a href=&quot;plugins&quot;&gt;plugin&lt;/a&gt; that provides the modules and let users add them to a Vuex store. Your modules will be also namespaced if the plugin users add your modules under a namespaced module. To adapt this situation, you may need to receive a namespace value via your plugin option:</source>
          <target state="translated">モジュールを提供する&lt;a href=&quot;plugins&quot;&gt;プラグイン&lt;/a&gt;を作成し、ユーザーがそれらをVuexストアに追加できるようにする場合、モジュールの予測不可能な名前空間に注意する必要があります。プラグインユーザーが名前空間モジュールの下にモジュールを追加すると、モジュールも名前空間になります。この状況に適応するには、プラグインオプションを介して名前空間の値を受け取る必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="3f63bbd45ca0e396d20716f1a9faff811b1810cb" translate="yes" xml:space="preserve">
          <source>You will have to clone directly from GitHub and build &lt;code&gt;vuex&lt;/code&gt; yourself if you want to use the latest dev build.</source>
          <target state="translated">最新の開発ビルドを使用する場合は、GitHubから直接クローンを作成し、 &lt;code&gt;vuex&lt;/code&gt; を自分でビルドする必要があります。</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="c0b7cc8520ca125ff38dd308c300837ea02ab867" translate="yes" xml:space="preserve">
          <source>createNamespacedHelpers</source>
          <target state="translated">createNamespacedHelpers</target>
        </trans-unit>
        <trans-unit id="59211592ba313c330272b3b02e6654aaf2030698" translate="yes" xml:space="preserve">
          <source>createNamespacedHelpers()</source>
          <target state="translated">createNamespacedHelpers()</target>
        </trans-unit>
        <trans-unit id="b853518a7253a67751993712323af2afe8d26a75" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">デフォルト： &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="05b145cfb6fbc24d08a8e01155c0aa2bf8460c87" translate="yes" xml:space="preserve">
          <source>dispatch</source>
          <target state="translated">dispatch</target>
        </trans-unit>
        <trans-unit id="6ec8d967f553282c8a0b78d6540dfc8d420a3ef0" translate="yes" xml:space="preserve">
          <source>getters</source>
          <target state="translated">getters</target>
        </trans-unit>
        <trans-unit id="191d360d6e9259ceda69018c10b131806a257339" translate="yes" xml:space="preserve">
          <source>hotUpdate</source>
          <target state="translated">hotUpdate</target>
        </trans-unit>
        <trans-unit id="7f3c4da8402c9feb0a967e99e24a689f07ad9538" translate="yes" xml:space="preserve">
          <source>mapActions</source>
          <target state="translated">mapActions</target>
        </trans-unit>
        <trans-unit id="1c9faade8425f6bc337e39a55a39ae4126bc894c" translate="yes" xml:space="preserve">
          <source>mapActions()</source>
          <target state="translated">mapActions()</target>
        </trans-unit>
        <trans-unit id="c5092a452ac716aa7395be56d5a3e111411ab603" translate="yes" xml:space="preserve">
          <source>mapGetters</source>
          <target state="translated">mapGetters</target>
        </trans-unit>
        <trans-unit id="4bed8eb971d49de14d01396cd2061d4908c28770" translate="yes" xml:space="preserve">
          <source>mapGetters()</source>
          <target state="translated">mapGetters()</target>
        </trans-unit>
        <trans-unit id="a837f5acfc97cfd8166f5f0c59fcbb7dfc666465" translate="yes" xml:space="preserve">
          <source>mapMutations</source>
          <target state="translated">mapMutations</target>
        </trans-unit>
        <trans-unit id="80e0f1f5c3583f0fd0d207c7f3df5c3aba3bd7ec" translate="yes" xml:space="preserve">
          <source>mapMutations()</source>
          <target state="translated">mapMutations()</target>
        </trans-unit>
        <trans-unit id="e5461d7d29007a5a5aa44df5c418d146a0695054" translate="yes" xml:space="preserve">
          <source>mapState</source>
          <target state="translated">mapState</target>
        </trans-unit>
        <trans-unit id="2d1ce243674082e4c821c3525927a44e71d4d016" translate="yes" xml:space="preserve">
          <source>mapState()</source>
          <target state="translated">mapState()</target>
        </trans-unit>
        <trans-unit id="4580485d482a9037af94f68af98adf23819cbdf4" translate="yes" xml:space="preserve">
          <source>modules</source>
          <target state="translated">modules</target>
        </trans-unit>
        <trans-unit id="3db5c1d36e4a153d7b5cda1e2d65b175222ccf09" translate="yes" xml:space="preserve">
          <source>mutations</source>
          <target state="translated">mutations</target>
        </trans-unit>
        <trans-unit id="440c3339cb056522cd1edf391e616ceb636e1a08" translate="yes" xml:space="preserve">
          <source>plugins</source>
          <target state="translated">plugins</target>
        </trans-unit>
        <trans-unit id="3f170c2be21627360e728ba4b0f15e0c20cc0126" translate="yes" xml:space="preserve">
          <source>registerModule</source>
          <target state="translated">registerModule</target>
        </trans-unit>
        <trans-unit id="eb49199248380da5116beeb5a5bdf9606ac21f82" translate="yes" xml:space="preserve">
          <source>replaceState</source>
          <target state="translated">replaceState</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="41eaab877ca3a0e3aa14f5a4b7981f590e3c2bd6" translate="yes" xml:space="preserve">
          <source>strict</source>
          <target state="translated">strict</target>
        </trans-unit>
        <trans-unit id="4c91330c57b1f26f16a92bbcb0653bc2a60a5b88" translate="yes" xml:space="preserve">
          <source>subscribe</source>
          <target state="translated">subscribe</target>
        </trans-unit>
        <trans-unit id="c8be9eb77e0a063aa55220d426f0169f12707d24" translate="yes" xml:space="preserve">
          <source>subscribeAction</source>
          <target state="translated">subscribeAction</target>
        </trans-unit>
        <trans-unit id="575fade49b23c513149d6cbd60de79f6715e014d" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Array&amp;lt;Function&amp;gt;&lt;/code&gt;</source>
          <target state="translated">タイプ： &lt;code&gt;Array&amp;lt;Function&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="501ad78bfb628eb307d521b862f9d31d47e25be6" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Boolean&lt;/code&gt;</source>
          <target state="translated">タイプ： &lt;code&gt;Boolean&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f896effac2d60505acabced97b30bbb769a74db" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object | Function&lt;/code&gt;</source>
          <target state="translated">タイプ： &lt;code&gt;Object | Function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="459de9ab6bbb747b424aa86431b8923f3e3cebed" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">タイプ： &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0adf6137f83fccfe39fef3d4143300d0f0d7953d" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;{ [key: string]: Function }&lt;/code&gt;</source>
          <target state="translated">タイプ： &lt;code&gt;{ [key: string]: Function }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116a5df420232cc247b1f0bf6bbbec8667db410b" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;{ [type: string]: Function }&lt;/code&gt;</source>
          <target state="translated">タイプ： &lt;code&gt;{ [type: string]: Function }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a69e7241a5b047759b4617f9a2bc7130db75edc" translate="yes" xml:space="preserve">
          <source>unregisterModule</source>
          <target state="translated">unregisterModule</target>
        </trans-unit>
        <trans-unit id="292b0901993f7e9d9a0d9b80542f9e59505ba5be" translate="yes" xml:space="preserve">
          <source>watch</source>
          <target state="translated">watch</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
