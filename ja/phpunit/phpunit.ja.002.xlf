<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="phpunit">
    <body>
      <group id="phpunit">
        <trans-unit id="c16d5f07f74e355b21d87741daea434449781182" translate="yes" xml:space="preserve">
          <source>Unit Tests are primarily written as a good practice to help developers identify and fix bugs, to refactor code and to serve as documentation for a unit of software under test. To achieve these benefits, unit tests ideally should cover all the possible paths in a program. One unit test usually covers one specific path in one function or method. However a test method is not necessarily an encapsulated, independent entity. Often there are implicit dependencies between test methods, hidden in the implementation scenario of a test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa47641d8db125127eb4e59fac4adb4c27367ef" translate="yes" xml:space="preserve">
          <source>Unit testing offers many advantages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445aba2719a870b6e92645a8ccd5a419539809d0" translate="yes" xml:space="preserve">
          <source>Unit tests provide working examples for how to use an API and can significantly aid documentation efforts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78d1e8d58204a4228725045ba5ff0aba05d455b" translate="yes" xml:space="preserve">
          <source>Use colors in output. On Windows, use &lt;a href=&quot;https://github.com/adoxa/ansicon&quot;&gt;ANSICON&lt;/a&gt; or &lt;a href=&quot;https://github.com/Maximus5/ConEmu&quot;&gt;ConEmu&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3573b4a4a51e4a7fdce706f212629595077148d5" translate="yes" xml:space="preserve">
          <source>Useless Tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927f9977ea2ebafd827eafa66188862aacda3031" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;phpVersion&lt;/code&gt; and &lt;code&gt;phpVersionOperator&lt;/code&gt; attributes, a required PHP version can be specified. The example below will only add the &lt;code&gt;/path/to/*Test.php&lt;/code&gt; files and &lt;code&gt;/path/to/MyTest.php&lt;/code&gt; file if the PHP version is at least 5.3.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f6b359741e89cdab7e53453eda4e764da26b20" translate="yes" xml:space="preserve">
          <source>Using the Composite DataSet we can aggregate both fixture files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4b7a6f06e90f419c8119bdaffc00c67e2166ae" translate="yes" xml:space="preserve">
          <source>Usually when using PHPUnit your testcases would extend the &lt;code&gt;PHPUnit\Framework\TestCase&lt;/code&gt; class in the following way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fba657a2566a29bb2eae7ad600ea97c18865719" translate="yes" xml:space="preserve">
          <source>Variations</source>
          <target state="translated">Variations</target>
        </trans-unit>
        <trans-unit id="a5d747bbb33afd9305aaffa5bfd0514ceefd9a15" translate="yes" xml:space="preserve">
          <source>Various software metrics exist to measure code coverage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8089893a67ec03da73e4b81bfbe04d0d61b65c" translate="yes" xml:space="preserve">
          <source>Verify outcome</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968a2dc859429ff332a18fe4f68d1bc3f083b912" translate="yes" xml:space="preserve">
          <source>Verify that you can reproduce the defect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515bca6bd8d57e897b38ffb481f512e10f333f1b" translate="yes" xml:space="preserve">
          <source>Verifying PHPUnit PHAR Releases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f6c76b8a2c217f0b522b06bb568e49150522f6" translate="yes" xml:space="preserve">
          <source>Verifying the state of the database after your test has run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4226ba146a6442cd5b7bc379dce83e15dc118e1f" translate="yes" xml:space="preserve">
          <source>We can now modify our test-case to look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74a1403765c15c77c1fa571bc693a220acc9037" translate="yes" xml:space="preserve">
          <source>We can now run the database test suite using different configurations from the command-line interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc92c8ed3137ce5da83bf715f291250acbaa082" translate="yes" xml:space="preserve">
          <source>We don't have the release manager's public key (&lt;code&gt;6372C20A&lt;/code&gt;) in our local system. In order to proceed with the verification we need to retrieve the release manager's public key from a key server. One such server is &lt;code&gt;pgp.uni-mainz.de&lt;/code&gt;. The public key servers are linked together, so you should be able to connect to any key server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95e979c279f198d114fc1ef2d6062fa2c6b5d1c" translate="yes" xml:space="preserve">
          <source>We first use the &lt;code&gt;getMockBuilder()&lt;/code&gt; method that is provided by the &lt;code&gt;PHPUnit\Framework\TestCase&lt;/code&gt; class to set up a mock object for the &lt;code&gt;Observer&lt;/code&gt;. Since we give an array as the second (optional) parameter for the &lt;code&gt;getMock()&lt;/code&gt; method, only the &lt;code&gt;update()&lt;/code&gt; method of the &lt;code&gt;Observer&lt;/code&gt; class is replaced by a mock implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe05c08006ff0a8ce21d34d52ae92caedbb9b25e" translate="yes" xml:space="preserve">
          <source>We have to fix up the Query Table call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b17a72d479f56ce5347129ab513ff650e8232b2" translate="yes" xml:space="preserve">
          <source>We then wrap the Flat XML DataSet into a Replacement DataSet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6521e2d9cf4c4b8c30cee3301b63ec6b1f151d3e" translate="yes" xml:space="preserve">
          <source>We want to verify PHPUnit's PHP Archive (&lt;code&gt;phpunit.phar&lt;/code&gt;) against its detached signature (&lt;code&gt;phpunit.phar.asc&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7912e65563f990d380c3a7b1fe9013f351937498" translate="yes" xml:space="preserve">
          <source>What PHPUnit cannot help you with is the fact that database tests are very slow compared to tests not using the database. Depending on how large the interactions with your database are your tests could run a considerable amount of time. However, if you keep the amount of data used for each test small and try to test as much code using non-database tests you can easily get away in under a minute even for large test suites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad378f1367aa73f06a572f140feae837a7657f59" translate="yes" xml:space="preserve">
          <source>What about the Database Schema (DDL)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115684ae5a4f0ea9d4f32a8dae7dc26e1ca72887" translate="yes" xml:space="preserve">
          <source>What can I do, when I get a &amp;ldquo;Too much Connections&amp;rdquo; Error?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c83e4a9267735ea2a8a452869dd4e283f9096fa" translate="yes" xml:space="preserve">
          <source>What happens when you have two tests with slightly different setups? There are two possibilities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93725b738940b2c0445b887a973d77f12a3a4b3e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--colors&lt;/code&gt; is used without any value, &lt;code&gt;auto&lt;/code&gt; is the chosen value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c52d1e14412e2cdd24581efb9b8f0c8a891a49" translate="yes" xml:space="preserve">
          <source>When a comparison fails PHPUnit creates textual representations of the input values and compares those. Due to that implementation a diff might show more problems than actually exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7b2b56c3bb7baccf57768f31f22cba6408cce1" translate="yes" xml:space="preserve">
          <source>When a test depends on a test that uses data providers, the depending test will be executed when the test it depends upon is successful for at least one data set. The result of a test that uses data providers cannot be injected into a depending test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83186dd5b2868bce96efb067330d4ec7fd33e75" translate="yes" xml:space="preserve">
          <source>When a test has a data provider that uses named sets, each iteration of the data gets the current name appended to the end of the default test name. See &lt;a href=&quot;textui#textui.examples.TestCaseClass.php&quot;&gt;Example 3.1&lt;/a&gt; for an example of named data sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8d2ea27a9b8d141da38c928ee1911dac9633b2" translate="yes" xml:space="preserve">
          <source>When a test has a data provider, each iteration of the data gets the current index appended to the end of the default test name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928de2897eb690b5e2463dfe5714db6ab366857d" translate="yes" xml:space="preserve">
          <source>When a test is run in a separate process, PHPUnit will attempt to preserve the global state from the parent process by serializing all globals in the parent process and unserializing them in the child process. This can cause problems if the parent process contains globals that are not serializable. To fix this, you can prevent PHPUnit from preserving global state with the &lt;code&gt;@preserveGlobalState&lt;/code&gt; annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5087899f9ddca43147b61cf42ce219f784ed6d6" translate="yes" xml:space="preserve">
          <source>When a test receives input from both a &lt;code&gt;@dataProvider&lt;/code&gt; method and from one or more tests it &lt;code&gt;@depends&lt;/code&gt; on, the arguments from the data provider will come before the ones from depended-upon tests. The arguments from depended-upon tests will be the same for each data set. See &lt;a href=&quot;writing-tests-for-phpunit#writing-tests-for-phpunit.data-providers.examples.DependencyAndDataProviderCombo.php&quot;&gt;Example 2.9&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f39ec370243fced00c1b53d74960cd74dab84f5" translate="yes" xml:space="preserve">
          <source>When invoked as shown above, the PHPUnit command-line test runner will look for a &lt;code&gt;ArrayTest.php&lt;/code&gt; sourcefile in the current working directory, load it, and expect to find a &lt;code&gt;ArrayTest&lt;/code&gt; test case class. It will then execute the tests of that class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8c257df4624e54c7d61c98bf07c4bfb68faef2" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;false&lt;/code&gt;, the error handler installed by &lt;code&gt;convertErrorsToExceptions&lt;/code&gt; will not convert &lt;code&gt;E_NOTICE&lt;/code&gt;, &lt;code&gt;E_USER_NOTICE&lt;/code&gt;, or &lt;code&gt;E_STRICT&lt;/code&gt; errors to exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002a6f78e7e4d71c9647e3e9d3f68886ae01fde9" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;false&lt;/code&gt;, the error handler installed by &lt;code&gt;convertErrorsToExceptions&lt;/code&gt; will not convert &lt;code&gt;E_WARNING&lt;/code&gt; or &lt;code&gt;E_USER_WARNING&lt;/code&gt; errors to exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2924e217edcd774dc23569abb58a9b2d78ee16dc" translate="yes" xml:space="preserve">
          <source>When testing a fluent interface, it is sometimes useful to have a stubbed method return a reference to the stubbed object. &lt;a href=&quot;test-doubles#test-doubles.stubs.examples.StubTest4.php&quot;&gt;Example 9.5&lt;/a&gt; shows how you can use &lt;code&gt;returnSelf()&lt;/code&gt; to achieve this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ea43a722b4accbde6ee894dec3f96eb881f12e" translate="yes" xml:space="preserve">
          <source>When testing that relies on php functions that trigger errors like &lt;code&gt;fopen&lt;/code&gt; it can sometimes be useful to use error suppression while testing. This allows you to check the return values by suppressing notices that would lead to a phpunit &lt;code&gt;PHPUnit\Framework\Error\Notice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990bfb73867024d395d16a9cdf248f1795bbe0cb" translate="yes" xml:space="preserve">
          <source>When the first guestbook entry is deleted from the dataset only &amp;ldquo;id&amp;rdquo;, &amp;ldquo;content&amp;rdquo; and &amp;ldquo;created&amp;rdquo; would be columns of the guestbook table, since &amp;ldquo;user&amp;rdquo; is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc33515038d480815dce350ef54023bb52c7fc20" translate="yes" xml:space="preserve">
          <source>When the generated output would be long to read PHPUnit will split it up and provide a few lines of context around every difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4f1e8bf1982f3bb75b49b47e526b8b0d793935" translate="yes" xml:space="preserve">
          <source>When the stubbed method call should return a calculated value instead of a fixed one (see &lt;code&gt;returnValue()&lt;/code&gt;) or an (unchanged) argument (see &lt;code&gt;returnArgument()&lt;/code&gt;), you can use &lt;code&gt;returnCallback()&lt;/code&gt; to have the stubbed method return the result of a callback function or method. See &lt;a href=&quot;test-doubles#test-doubles.stubs.examples.StubTest6.php&quot;&gt;Example 9.7&lt;/a&gt; for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f8f19211f4e2927067d73b212aa0ebae6a020c" translate="yes" xml:space="preserve">
          <source>When the test execution terminates before the &lt;code&gt;tearDown()&lt;/code&gt; method is invoked the directory will stay in the filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be8b46c5b8942250c3eba0b21ebd928f347b844" translate="yes" xml:space="preserve">
          <source>When using a large number of datasets it's useful to name each one with string key instead of default numeric. Output will be more verbose as it'll contain that name of a dataset that breaks a test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50169aa0190de9a1300c679d3bcfb09f2855798b" translate="yes" xml:space="preserve">
          <source>When we are writing a test in which we cannot (or chose not to) use a real depended-on component (DOC), we can replace it with a Test Double. The Test Double doesn't have to behave exactly like the real DOC; it merely has to provide the same API as the real one so that the SUT thinks it is the real one!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e98073b7e27b0f4684172a48b1494f7ed971bf" translate="yes" xml:space="preserve">
          <source>When writing custom assertions it is the best practice to follow how PHPUnit's own assertions are implemented. As you can see in &lt;a href=&quot;extending-phpunit#extending-phpunit.examples.Assert.php&quot;&gt;Example 14.1&lt;/a&gt;, the &lt;code&gt;assertTrue()&lt;/code&gt; method is just a wrapper around the &lt;code&gt;isTrue()&lt;/code&gt; and &lt;code&gt;assertThat()&lt;/code&gt; methods: &lt;code&gt;isTrue()&lt;/code&gt; creates a matcher object that is passed on to &lt;code&gt;assertThat()&lt;/code&gt; for evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59585f24f15b219823e254de9f0db222aea80f8" translate="yes" xml:space="preserve">
          <source>When you agree on coordinating your activities with the supplier of a package, you can write the tests together. Do this in such a way that the tests reveal as many assumptions as possible. Hidden assumptions are the death of cooperation. With the tests, you document exactly what you expect from the supplied package. The supplier will know the package is complete when all the tests run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e12d1d42441315a63147ea08d4f830cf12dc03" translate="yes" xml:space="preserve">
          <source>When you are working on a new test case class, you might want to begin by writing empty test methods such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc1c81606a083020d621842df8391fd0f600c77" translate="yes" xml:space="preserve">
          <source>When you document assumptions with tests, you own the tests. The supplier of the package -- who you make assumptions about -- knows nothing about your tests. If you want to have a closer relationship with the supplier of a package, you can use the tests to communicate and coordinate your activities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b227323596cb1d49d216c73d52a59fbd5c9c6c81" translate="yes" xml:space="preserve">
          <source>When you get a defect report, your impulse might be to fix the defect as quickly as possible. Experience shows that this impulse will not serve you well; it is likely that the fix for the defect causes another defect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80af9e23609590d6899ef8d3901fc68097d07e39" translate="yes" xml:space="preserve">
          <source>When you need to add new functionality to the system, write the tests first. Then, you will be done developing when the test runs. This practice will be discussed in detail in the next chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a06ba48d153db1ee538c313ddd441fa8fc16ee" translate="yes" xml:space="preserve">
          <source>When you need to make a change to the internal structure of the software you are working on to make it easier to understand and cheaper to modify without changing its observable behavior, a test suite is invaluable in applying these so called &lt;a href=&quot;http://martinfowler.com/bliki/DefinitionOfRefactoring.html&quot;&gt;refactorings&lt;/a&gt; safely. Otherwise, you might not notice the system breaking while you are carrying out the restructuring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee25f858f8dc07f3b69a592734c66c2c0832323" translate="yes" xml:space="preserve">
          <source>When your application interacts with a web service you want to test it without actually interacting with the web service. To make the stubbing and mocking of web services easy, the &lt;code&gt;getMockFromWsdl()&lt;/code&gt; can be used just like &lt;code&gt;getMock()&lt;/code&gt; (see above). The only difference is that &lt;code&gt;getMockFromWsdl()&lt;/code&gt; returns a stub or mock based on a web service description in WSDL and &lt;code&gt;getMock()&lt;/code&gt; returns a stub or mock based on a PHP class or interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7903c1b33bff5cb437ad68da9b2ea5f628df7f7e" translate="yes" xml:space="preserve">
          <source>Whenever a test fails PHPUnit tries its best to provide you with as much context as possible that can help to identify the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0709917e388ac8733124d676879302ae3b1a068d" translate="yes" xml:space="preserve">
          <source>Whenever you are tempted to type something into a &lt;code&gt;print&lt;/code&gt; statement or a debugger expression, write it as a test instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e937368555fce02eeb1adfa4f2e97ac617a86c71" translate="yes" xml:space="preserve">
          <source>While this is very convenient for editing with Excel or OpenOffice, you cannot specify NULL values with the CSV dataset. An empty column will lead to the database default empty value being inserted into the column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0bf6edecb4d699b5c1f0cd67b77dbc2e51f71ef" translate="yes" xml:space="preserve">
          <source>Whitelisting Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184f652d531056bd963c11d37ccd5526523caa00" translate="yes" xml:space="preserve">
          <source>Whitelisting Files for Code Coverage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c7429c642e4aea1befd537be31240728fcb172" translate="yes" xml:space="preserve">
          <source>Will PHPUnit (re-)create the database schema for each test?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="b2d890362b7721a4a0b744a62a04801a95ca52ea" translate="yes" xml:space="preserve">
          <source>Without a virtual filesystem such as vfsStream we cannot test the &lt;code&gt;setDirectory()&lt;/code&gt; method in isolation from external influence (see &lt;a href=&quot;test-doubles#test-doubles.mocking-the-filesystem.examples.ExampleTest.php&quot;&gt;Example 9.22&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f71680b834fbbe95782fba63d95147a749c8be11" translate="yes" xml:space="preserve">
          <source>Without the error suppression the test would fail reporting &lt;code&gt;fopen(/is-not-writeable/file): failed to open stream:
    No such file or directory&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dedccc4867405a3471be8233f4ebe9a6a2bb2de6" translate="yes" xml:space="preserve">
          <source>Write all the rows in the data-tables into the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbbfaf5377d2e03efa933060317a93421ed5861" translate="yes" xml:space="preserve">
          <source>Write an automated test that fails now but will succeed when the defect is fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0c42ef3cef9d392f3dcac3d09402d1957f6344" translate="yes" xml:space="preserve">
          <source>Write custom assertions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f709732b2211c2a981b1be285ece585e168e3822" translate="yes" xml:space="preserve">
          <source>Write custom assertions and utility methods in an abstract subclass of &lt;code&gt;PHPUnit\Framework\TestCase&lt;/code&gt; and derive your test case classes from that class. This is one of the easiest ways to extend PHPUnit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a3852a23915596995ef8635dc6fbd161c3dfce" translate="yes" xml:space="preserve">
          <source>Writing Tests for PHPUnit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f063b9902b860031f4c625394b61325a4440e2df" translate="yes" xml:space="preserve">
          <source>XML DataSet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a211ee8d43cfaa8129da355009a4dfe2c9d149d" translate="yes" xml:space="preserve">
          <source>Xdebug is not distributed as part of PHPUnit. If you receive a notice while running tests that the Xdebug extension is not loaded, it means that Xdebug is either not installed or not configured properly. Before you can use the code coverage analysis features in PHPUnit, you should read &lt;a href=&quot;http://xdebug.org/docs/install&quot;&gt;the Xdebug installation guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab582c7e8e9b5fe420c617b0de1cf591044edbc" translate="yes" xml:space="preserve">
          <source>YAML DataSet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92116dc581c2238ebeff646dd12b48fd3c73d53c" translate="yes" xml:space="preserve">
          <source>You can also assert the result of complex queries with the Query Table approach, just specify a result name with a query and compare it to a dataset:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc5fa00c7042ab0755b71b736e98f12f97c3cb3" translate="yes" xml:space="preserve">
          <source>You can always write more tests. However, you will quickly find that only a fraction of the tests you can imagine are actually useful. What you want is to write tests that fail even though you think they should work, or tests that succeed even though you think they should fail. Another way to think of it is in cost/benefit terms. You want to write tests that will pay you back with information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a078cfc20a1095c008a47b877929c52dcf17f7ba" translate="yes" xml:space="preserve">
          <source>You can construct the DataSet on your own:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0ece83c2819ca556ba1bbe02db176b21c66ad6" translate="yes" xml:space="preserve">
          <source>You can create a CSV DataSet by calling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faaae67de0688c386d3951e4268fbd9886d58198" translate="yes" xml:space="preserve">
          <source>You can create a flat xml dataset instance from within your Database TestCase by calling the &lt;code&gt;createFlatXmlDataSet($filename)&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd55e47e6f5448be88daf55231adfb811342e4b6" translate="yes" xml:space="preserve">
          <source>You can create a xml dataset instance from within your Database TestCase by calling the &lt;code&gt;createXmlDataSet($filename)&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1fd4cb18bb341f1f611051d4eb5390bf51f2e1" translate="yes" xml:space="preserve">
          <source>You can either create a dataset for the complete database as shown in &lt;code&gt;testGuestbook()&lt;/code&gt;, or restrict it to a set of specified table names with a whitelist as shown in &lt;code&gt;testFilteredGuestbook()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f7cc1a377c1b4d060eaa2721f4972418ff9fe7b" translate="yes" xml:space="preserve">
          <source>You can hold your impulse in check by doing the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="439557ef6ce462ccc9abe19f1c0c6834640046d2" translate="yes" xml:space="preserve">
          <source>You can make use of this by specifying arbitrary queries for your tables, for example restricting rows, column or adding &lt;code&gt;ORDER BY&lt;/code&gt; clauses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59729c99eefa0308f0c82103df85c243c42ab048" translate="yes" xml:space="preserve">
          <source>You can provide a blacklist of static attributes that are to be excluded from the backup and restore operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237329f4706c8047eb918f75173ecc73be0f89a9" translate="yes" xml:space="preserve">
          <source>You can use a &lt;em&gt;mock object&lt;/em&gt; &quot;as an observation point that is used to verify the indirect outputs of the SUT as it is exercised. Typically, the mock object also includes the functionality of a test stub in that it must return values to the SUT if it hasn't already failed the tests but the emphasis is on the verification of the indirect outputs. Therefore, a mock object is a lot more than just a test stub plus assertions; it is used in a fundamentally different way&quot; (Gerard Meszaros).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a9f9b403d591a5b39991a8cb2753b779d55e93" translate="yes" xml:space="preserve">
          <source>You can use the Database (DB) DataSet from the Connection and compare it to a File-Based DataSet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6ad16fdeaf557b757b56ce17b64851641f61d7" translate="yes" xml:space="preserve">
          <source>You can wrap test cases or test suites in a subclass of &lt;code&gt;PHPUnit_Extensions_TestDecorator&lt;/code&gt; and use the Decorator design pattern to perform some actions before and after the test runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b411f985dfd24d4d5a43b3e5fafa146531086a" translate="yes" xml:space="preserve">
          <source>You do not want to modify considerable amount of test code for little changes in your production code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1166c18cc123a82d7f724936aa93187490a0ef4" translate="yes" xml:space="preserve">
          <source>You may also use the downloaded PHAR file directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ee9de3287ccffd61d361237d08e22eb63cecfc" translate="yes" xml:space="preserve">
          <source>You need to setup test data in (possibly much) more than two tables to get reasonable initial data for the methods you want to test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605def75161cce7a74547ef770e763d8f697e38f" translate="yes" xml:space="preserve">
          <source>You probably know this scenario from your daily work and projects, where you want to put your fresh or experienced PHPUnit skills to work and get stuck by one of the following problems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f371634166190eaf82bc041670a87fc6a2dcb00a" translate="yes" xml:space="preserve">
          <source>You should be as specific as possible when testing exceptions. Testing for classes that are too generic might lead to undesirable side-effects. Accordingly, testing for the &lt;code&gt;Exception&lt;/code&gt; class with &lt;code&gt;@expectedException&lt;/code&gt; or &lt;code&gt;setExpectedException()&lt;/code&gt; is no longer permitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b376e5a6c1ec649252349f9914ce87243a3529" translate="yes" xml:space="preserve">
          <source>You want to be able to read and understand the test code easily, even months after writing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b013c701ed496ba56f01c975e4081827666f70" translate="yes" xml:space="preserve">
          <source>You won't need additional files for assertions and can specify them directly in the TestCase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ede8d917a46c3eb5e5fb6e455b4243b4b94f73d" translate="yes" xml:space="preserve">
          <source>Your business logic performs a mix of SELECT, INSERT, UPDATE and DELETE statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e408787b79a3308258aca3560fbc83d290773a29" translate="yes" xml:space="preserve">
          <source>and &lt;em&gt;fixture2.xml&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78da1b13adfdedef3f1bdb6aaf4c3e389aad03b" translate="yes" xml:space="preserve">
          <source>assertArrayHasKey()</source>
          <target state="translated">assertArrayHasKey()</target>
        </trans-unit>
        <trans-unit id="2953b43f13241d2e3cd276715de3bff946c20d30" translate="yes" xml:space="preserve">
          <source>assertArraySubset()</source>
          <target state="translated">assertArraySubset()</target>
        </trans-unit>
        <trans-unit id="a0c879edb53ee997bd7d82bd1fbc196e632b95d9" translate="yes" xml:space="preserve">
          <source>assertClassHasAttribute()</source>
          <target state="translated">assertClassHasAttribute()</target>
        </trans-unit>
        <trans-unit id="3c2ab1335fd5a18000ffe25079ed36c51847dd61" translate="yes" xml:space="preserve">
          <source>assertClassHasStaticAttribute()</source>
          <target state="translated">assertClassHasStaticAttribute()</target>
        </trans-unit>
        <trans-unit id="d4d83fecf7ab236a0a17aac75ff7f4dd28930221" translate="yes" xml:space="preserve">
          <source>assertContains()</source>
          <target state="translated">assertContains()</target>
        </trans-unit>
        <trans-unit id="688e3b55f1e31b0801c63033e34994afe7d59380" translate="yes" xml:space="preserve">
          <source>assertContainsOnly()</source>
          <target state="translated">assertContainsOnly()</target>
        </trans-unit>
        <trans-unit id="0c8af844c8fccefb6537fe00845eeea118bbd356" translate="yes" xml:space="preserve">
          <source>assertContainsOnlyInstancesOf()</source>
          <target state="translated">assertContainsOnlyInstancesOf()</target>
        </trans-unit>
        <trans-unit id="961c3e8662def888f4511a97c4f41e3757d19e7f" translate="yes" xml:space="preserve">
          <source>assertCount()</source>
          <target state="translated">assertCount()</target>
        </trans-unit>
        <trans-unit id="96ceb5ab03b2a734958bb1dd795383194a3d95c2" translate="yes" xml:space="preserve">
          <source>assertDirectoryExists()</source>
          <target state="translated">assertDirectoryExists()</target>
        </trans-unit>
        <trans-unit id="4544c145eddcc1b4575bb4cdd70a13848be84f70" translate="yes" xml:space="preserve">
          <source>assertDirectoryIsReadable()</source>
          <target state="translated">assertDirectoryIsReadable()</target>
        </trans-unit>
        <trans-unit id="34a0a31ad30c150a9e5247abc4fb085d7367d1ca" translate="yes" xml:space="preserve">
          <source>assertDirectoryIsWritable()</source>
          <target state="translated">assertDirectoryIsWritable()</target>
        </trans-unit>
        <trans-unit id="174d89589791a9491723378104e29bf46c03dbf6" translate="yes" xml:space="preserve">
          <source>assertEmpty()</source>
          <target state="translated">assertEmpty()</target>
        </trans-unit>
        <trans-unit id="9a5438a52e50bca545784cf7955c28bb2d98442c" translate="yes" xml:space="preserve">
          <source>assertEqualXMLStructure()</source>
          <target state="translated">assertEqualXMLStructure()</target>
        </trans-unit>
        <trans-unit id="23ccb551a3cdb1d2bd5c433b6c1d201359698e8e" translate="yes" xml:space="preserve">
          <source>assertEquals()</source>
          <target state="translated">assertEquals()</target>
        </trans-unit>
        <trans-unit id="6d46d5b6994420e250f3385039725d27ac3ecb42" translate="yes" xml:space="preserve">
          <source>assertFalse()</source>
          <target state="translated">assertFalse()</target>
        </trans-unit>
        <trans-unit id="c20b9f1a89ade2bfc6804ff44de2b0c75c7bda92" translate="yes" xml:space="preserve">
          <source>assertFileEquals()</source>
          <target state="translated">assertFileEquals()</target>
        </trans-unit>
        <trans-unit id="654f4244568f9ec544b303f3e1ed51205d669205" translate="yes" xml:space="preserve">
          <source>assertFileExists()</source>
          <target state="translated">assertFileExists()</target>
        </trans-unit>
        <trans-unit id="58bde623ebc5a2b744a207aa641050ab3fd58f8b" translate="yes" xml:space="preserve">
          <source>assertFileIsReadable()</source>
          <target state="translated">assertFileIsReadable()</target>
        </trans-unit>
        <trans-unit id="c68fa67118b75c3d4a1f0efd62378313d3113816" translate="yes" xml:space="preserve">
          <source>assertFileIsWritable()</source>
          <target state="translated">assertFileIsWritable()</target>
        </trans-unit>
        <trans-unit id="d79190d5b985d820ee4285db5373b9f6e44e3624" translate="yes" xml:space="preserve">
          <source>assertGreaterThan()</source>
          <target state="translated">assertGreaterThan()</target>
        </trans-unit>
        <trans-unit id="d30c28860338bc110c65a0e74fbe208c835a5543" translate="yes" xml:space="preserve">
          <source>assertGreaterThanOrEqual()</source>
          <target state="translated">assertGreaterThanOrEqual()</target>
        </trans-unit>
        <trans-unit id="bcafb217fb4f91be35bb7855a99c304df46f0415" translate="yes" xml:space="preserve">
          <source>assertInfinite()</source>
          <target state="translated">assertInfinite()</target>
        </trans-unit>
        <trans-unit id="f29777c90474ee551ac8002f589576c2d13ed4ff" translate="yes" xml:space="preserve">
          <source>assertInstanceOf()</source>
          <target state="translated">assertInstanceOf()</target>
        </trans-unit>
        <trans-unit id="a14e8e87a44fab357571956b107842d15cc9cd43" translate="yes" xml:space="preserve">
          <source>assertInternalType()</source>
          <target state="translated">assertInternalType()</target>
        </trans-unit>
        <trans-unit id="ed60d782ca77fcdf5ecb50a50a6b12b4aa21c26b" translate="yes" xml:space="preserve">
          <source>assertIsReadable()</source>
          <target state="translated">assertIsReadable()</target>
        </trans-unit>
        <trans-unit id="7c70571c21b9c255b3b874ab2c70cb977bcc167c" translate="yes" xml:space="preserve">
          <source>assertIsWritable()</source>
          <target state="translated">assertIsWritable()</target>
        </trans-unit>
        <trans-unit id="fbe7df4f678c83d5efbdf61919cd943803f139f8" translate="yes" xml:space="preserve">
          <source>assertJsonFileEqualsJsonFile()</source>
          <target state="translated">assertJsonFileEqualsJsonFile()</target>
        </trans-unit>
        <trans-unit id="28dbfdff7f46a430978277b473d19ebc0ab18a8a" translate="yes" xml:space="preserve">
          <source>assertJsonStringEqualsJsonFile()</source>
          <target state="translated">assertJsonStringEqualsJsonFile()</target>
        </trans-unit>
        <trans-unit id="b0bf6fda1b66a2c05bd5b4a85fae7a0da44ceef6" translate="yes" xml:space="preserve">
          <source>assertJsonStringEqualsJsonString()</source>
          <target state="translated">assertJsonStringEqualsJsonString()</target>
        </trans-unit>
        <trans-unit id="5ed936b15a579166dd241321758f48de026405b8" translate="yes" xml:space="preserve">
          <source>assertLessThan()</source>
          <target state="translated">assertLessThan()</target>
        </trans-unit>
        <trans-unit id="2ff7c6828a81e20d73b86a95f2bfad68c64eb0b9" translate="yes" xml:space="preserve">
          <source>assertLessThanOrEqual()</source>
          <target state="translated">assertLessThanOrEqual()</target>
        </trans-unit>
        <trans-unit id="cb8ff9ef384b09e12546f6577d926fbe708457a9" translate="yes" xml:space="preserve">
          <source>assertNan()</source>
          <target state="translated">assertNan()</target>
        </trans-unit>
        <trans-unit id="e7bcdbce6f11f87ce1c9b5e0f80ae2686479b45b" translate="yes" xml:space="preserve">
          <source>assertNull()</source>
          <target state="translated">assertNull()</target>
        </trans-unit>
        <trans-unit id="daa66dd44d78be88c535a424c886e05f83dfe921" translate="yes" xml:space="preserve">
          <source>assertObjectHasAttribute()</source>
          <target state="translated">assertObjectHasAttribute()</target>
        </trans-unit>
        <trans-unit id="49b69a515c563526ed56083eeaa0b3f5a35dd459" translate="yes" xml:space="preserve">
          <source>assertRegExp()</source>
          <target state="translated">assertRegExp()</target>
        </trans-unit>
        <trans-unit id="df4b41e034cb3fb9cbfb8c7d0282908291bb7729" translate="yes" xml:space="preserve">
          <source>assertSame()</source>
          <target state="translated">assertSame()</target>
        </trans-unit>
        <trans-unit id="5ab4e871ad3cb768ca57420fcff36afc7846db53" translate="yes" xml:space="preserve">
          <source>assertStringEndsWith()</source>
          <target state="translated">assertStringEndsWith()</target>
        </trans-unit>
        <trans-unit id="722ed30f2b6991c0dde3b61a96aaf9a77a963f4b" translate="yes" xml:space="preserve">
          <source>assertStringEqualsFile()</source>
          <target state="translated">assertStringEqualsFile()</target>
        </trans-unit>
        <trans-unit id="d4d11de435f688fc4a15c4086b65541c8ff9576d" translate="yes" xml:space="preserve">
          <source>assertStringMatchesFormat()</source>
          <target state="translated">assertStringMatchesFormat()</target>
        </trans-unit>
        <trans-unit id="ed2b8fe213436da04bb2ec4123a90169f1cb278f" translate="yes" xml:space="preserve">
          <source>assertStringMatchesFormatFile()</source>
          <target state="translated">assertStringMatchesFormatFile()</target>
        </trans-unit>
        <trans-unit id="1cb66de67f876bdbe76e70cce0c9221219d00043" translate="yes" xml:space="preserve">
          <source>assertStringStartsWith()</source>
          <target state="translated">assertStringStartsWith()</target>
        </trans-unit>
        <trans-unit id="040de4ae88cba81c3d3a61b56e2d5a8a6cd4214b" translate="yes" xml:space="preserve">
          <source>assertThat()</source>
          <target state="translated">assertThat()</target>
        </trans-unit>
        <trans-unit id="a1fe128ba75fa817bbdd95449b30363cc8d8e330" translate="yes" xml:space="preserve">
          <source>assertTrue()</source>
          <target state="translated">assertTrue()</target>
        </trans-unit>
        <trans-unit id="16e7c06470e678ce6643bcc65a4a7f292000a02e" translate="yes" xml:space="preserve">
          <source>assertXmlFileEqualsXmlFile()</source>
          <target state="translated">assertXmlFileEqualsXmlFile()</target>
        </trans-unit>
        <trans-unit id="26d75addf4ae3317e3f0ab65664753edab70a8a1" translate="yes" xml:space="preserve">
          <source>assertXmlStringEqualsXmlFile()</source>
          <target state="translated">assertXmlStringEqualsXmlFile()</target>
        </trans-unit>
        <trans-unit id="145b4f7f69ec5df4adba1328742fb5f422e41906" translate="yes" xml:space="preserve">
          <source>assertXmlStringEqualsXmlString()</source>
          <target state="translated">assertXmlStringEqualsXmlString()</target>
        </trans-unit>
        <trans-unit id="978d00dde011c95df5d89a506062e2a7562fb626" translate="yes" xml:space="preserve">
          <source>convertErrorsToExceptions</source>
          <target state="translated">convertErrorsToExceptions</target>
        </trans-unit>
        <trans-unit id="af6864cd9015ff0e9aacd657c2fa2eb4827b59d3" translate="yes" xml:space="preserve">
          <source>convertNoticesToExceptions</source>
          <target state="translated">convertNoticesToExceptions</target>
        </trans-unit>
        <trans-unit id="2429b52a4818bb6fa6ba35442ed1d755d37476b0" translate="yes" xml:space="preserve">
          <source>convertWarningsToExceptions</source>
          <target state="translated">convertWarningsToExceptions</target>
        </trans-unit>
        <trans-unit id="5c1fbc1be607e4191f388fde6043defa3dd9c4db" translate="yes" xml:space="preserve">
          <source>forceCoversAnnotation</source>
          <target state="translated">forceCoversAnnotation</target>
        </trans-unit>
        <trans-unit id="3c1c518262f2ecc3844375807272f6051c4e067a" translate="yes" xml:space="preserve">
          <source>phpunit UnitTest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6dbd075e0264852bf66054810ba76350adbae6f" translate="yes" xml:space="preserve">
          <source>phpunit UnitTest UnitTest.php</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3594ac45a6f4809d908a03c0802a9806d1fc1c36" translate="yes" xml:space="preserve">
          <source>timeoutForLargeTests</source>
          <target state="translated">timeoutForLargeTests</target>
        </trans-unit>
        <trans-unit id="bdc16f7d773e4b7fc038cce005d41d6c52b2345d" translate="yes" xml:space="preserve">
          <source>timeoutForMediumTests</source>
          <target state="translated">timeoutForMediumTests</target>
        </trans-unit>
        <trans-unit id="a6dca61e251aea5eb30244ab82d118c907482e6f" translate="yes" xml:space="preserve">
          <source>timeoutForSmallTests</source>
          <target state="translated">timeoutForSmallTests</target>
        </trans-unit>
        <trans-unit id="4ccfdd2606dd6d436bdbce99e9f436a8561c098a" translate="yes" xml:space="preserve">
          <source>to keep track of the tests that you have to write. The problem with empty test methods is that they are interpreted as a success by the PHPUnit framework. This misinterpretation leads to the test reports being useless -- you cannot see whether a test is actually successful or just not yet implemented. Calling &lt;code&gt;$this-&amp;gt;fail()&lt;/code&gt; in the unimplemented test method does not help either, since then the test will be interpreted as a failure. This would be just as wrong as interpreting an unimplemented test as a success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ee72296d42470b3297273534b56130c2b1b8c8" translate="yes" xml:space="preserve">
          <source>vfsStream gives the test developer full control over what the filesystem environment looks like to the tested code.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
