<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="q">
    <body>
      <group id="q">
        <trans-unit id="f0981f1324a7c67a6d8e261ad6608dee5ae431a3" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2017 Kristopher Michael Kowal</source>
          <target state="translated">&amp;copy;2009&amp;ndash;2017 Kristopher Michael Kowal</target>
        </trans-unit>
        <trans-unit id="47c94724aa92750cfd8f557bf2484c29260f72d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt; returns a promise, which will become resolved with the same fulfillment value or rejection reason as &lt;code&gt;promise&lt;/code&gt;. However, if &lt;code&gt;callback&lt;/code&gt; returns a promise, the resolution of the returned promise will be delayed until the promise returned from &lt;code&gt;callback&lt;/code&gt; is finished. Furthermore, if the returned promise rejects, that rejection will be passed down the chain instead of the previous result.</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; 同じ履行価値または拒否の理由と解決されるようになる約束、返す &lt;code&gt;promise&lt;/code&gt; 。ただし、 &lt;code&gt;callback&lt;/code&gt; がプロミスを返す場合、返されたプロミスの解決は、 &lt;code&gt;callback&lt;/code&gt; から返されたプロミスが完了するまで遅延されます。さらに、返されたpromiseが拒否された場合、その拒否は前の結果ではなくチェーンに渡されます。</target>
        </trans-unit>
        <trans-unit id="9e255e440478d966ef66bd07a0d3f82cca6ed20e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;makeNodeResolver()&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;makeNodeResolver()&lt;/code&gt; メソッド</target>
        </trans-unit>
        <trans-unit id="9d7d1abc096fefcb950638f2a44550fc3d76142f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify(value)&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;notify(value)&lt;/code&gt; メソッド</target>
        </trans-unit>
        <trans-unit id="43e4032a7c51a1aef78351b37f12b8a6abbafe4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;promise&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;promise&lt;/code&gt; 財産</target>
        </trans-unit>
        <trans-unit id="9002548e37f987a07036927f332519aeed75bea5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reject(reason)&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;reject(reason)&lt;/code&gt; メソッド</target>
        </trans-unit>
        <trans-unit id="d9ec58771c2d55ed24df135dfeca968af1cddd8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolve(value)&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;resolve(value)&lt;/code&gt; メソッド</target>
        </trans-unit>
        <trans-unit id="228842e8684d06b61fdbb531b50d1865755241e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;Q.nsend&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;Q.nsend&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b5d0f804b538f7886b440ac8e8865def7aa705d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;promise.fail&lt;/code&gt; (for non-ES5 browsers)</source>
          <target state="translated">&lt;em&gt;エイリアス：&lt;/em&gt; &lt;code&gt;promise.fail&lt;/code&gt; （ES5以外のブラウザーの場合）</target>
        </trans-unit>
        <trans-unit id="2118449aa2a3bda191f7a26ce83eefb29454a841" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;promise.fin&lt;/code&gt; (for non-ES5 browsers)</source>
          <target state="translated">&lt;em&gt;エイリアス：&lt;/em&gt; &lt;code&gt;promise.fin&lt;/code&gt; （非ES5ブラウザー用）</target>
        </trans-unit>
        <trans-unit id="edfe6bc410ab1b3a0acc4435d6a21fe2e5fe9b07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;promise.send&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;promise.send&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f7076e434da58268bca551d18ff2736f04dbf61" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alias&lt;/em&gt;: &lt;code&gt;Q.denodeify&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;エイリアス&lt;/em&gt;： &lt;code&gt;Q.denodeify&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d3962fdfa3dbe8bde2a4417e8f88935beabeb63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deprecated Alias&lt;/em&gt;: &lt;code&gt;Q.nmapply&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;非推奨のエイリアス&lt;/em&gt;： &lt;code&gt;Q.nmapply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db96878e56374a9ebdefa960f6ec863036138e90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deprecated Alias&lt;/em&gt;: &lt;code&gt;Q.nmcall&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;非推奨のエイリアス&lt;/em&gt;： &lt;code&gt;Q.nmcall&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f84fcdb12cce76069ceb62581a6a0c0f88dfb8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deprecated:&lt;/em&gt;&lt;code&gt;promise.observeEstimate&lt;/code&gt; or a similar interface is due to replace this method in version 2. Progress does not compose well. &lt;a href=&quot;https://github.com/kriskowal/gtor#progress-and-estimated-time-to-completion&quot;&gt;https://github.com/kriskowal/gtor#progress-and-estimated-time-to-completion&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;非推奨：&lt;/em&gt; &lt;code&gt;promise.observeEstimate&lt;/code&gt; または同様のインターフェースは、バージョン2でこのメソッドを置き換える&lt;em&gt;予定です&lt;/em&gt;。進行状況がうまく構成されません。&lt;a href=&quot;https://github.com/kriskowal/gtor#progress-and-estimated-time-to-completion&quot;&gt;https://github.com/kriskowal/gtor#progress-and-estimated-time-to-completion&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ba06898cc9f24bd326cb6c5201c4d462c0857bf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Experimental Alias&lt;/em&gt;: &lt;code&gt;promise.mapply&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;実験的なエイリアス&lt;/em&gt;： &lt;code&gt;promise.mapply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7914a9c5bdbf06c996e490a2801a150d0bf14874" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Experimental Alias&lt;/em&gt;: &lt;code&gt;promise.mcall&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;実験的なエイリアス&lt;/em&gt;： &lt;code&gt;promise.mcall&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f419c6734901c9ba6632fe76d2fbc802a9b0437d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Introduced in version 1.1.0 (November 2014)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;バージョン1.1.0で導入（2014年11月）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14ca715bb1f30393c961e3d1ccb89277911e98f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;No Static Counterpart&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;静的な対応はありません&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a414d0df4a72cd1169cdbd51cdcd526c8a6745d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static Alias:&lt;/em&gt;&lt;code&gt;Q.try&lt;/code&gt; (ES5 browsers only)</source>
          <target state="translated">&lt;em&gt;静的エイリアス：&lt;/em&gt; &lt;code&gt;Q.try&lt;/code&gt; （ES5ブラウザーのみ）</target>
        </trans-unit>
        <trans-unit id="3e29674d2681d615252c778a6b6c5a9b611162b3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The Golden Rule of &lt;code&gt;done&lt;/code&gt; vs. &lt;code&gt;then&lt;/code&gt; usage is: either &lt;code&gt;return&lt;/code&gt; your promise to someone else, or if the chain ends with you, call &lt;code&gt;done&lt;/code&gt; to terminate it. Terminating with &lt;code&gt;catch&lt;/code&gt; is not sufficient because the catch handler may itself throw an error.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;done&lt;/code&gt; と &lt;code&gt;then&lt;/code&gt; の使用法のゴールデンルールは、約束を他の誰かに &lt;code&gt;return&lt;/code&gt; か、チェーンが終了した場合は &lt;code&gt;done&lt;/code&gt; を呼び出して終了します。で終了 &lt;code&gt;catch&lt;/code&gt; catchハンドラ自体がエラーをスローすることがあるため十分ではありません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba6b98fa9f88a673e8952daf8ef9d6dfd171413d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This functionality is experimental.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;この機能は実験的なものです。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="630214b5d545b217b93c5bae4d74868ba4f6edd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;note&lt;/strong&gt;: In the latest github, this method is called Q.Promise, but if you are using the npm package version 0.9.7 or below, the method is called Q.promise (lowercase vs uppercase p).</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：最新のgithubでは、このメソッドはQ.Promiseと呼ばれていますが、npmパッケージバージョン0.9.7以下を使用している場合、メソッドはQ.promise（小文字と大文字のp）と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="360fde535483e090afa91e4f8bcbdf00421e7a52" translate="yes" xml:space="preserve">
          <source>A settable property that lets you turn on long stack trace support. If turned on, &quot;stack jumps&quot; will be tracked across asynchronous promise operations, so that if an uncaught error is thrown by &lt;code&gt;done&lt;/code&gt; or a rejection reason's &lt;code&gt;stack&lt;/code&gt; property is inspected in a rejection callback, a long stack trace is produced.</source>
          <target state="translated">長いスタックトレースサポートを有効にする設定可能なプロパティ。オンにすると、「スタックジャンプ」が非同期のpromiseオペレーション全体で追跡されるため、 &lt;code&gt;done&lt;/code&gt; によってキャッチされないエラーがスローされるか、拒否コールバックで拒否理由の &lt;code&gt;stack&lt;/code&gt; プロパティが検査されると、長いスタックトレースが生成されます。</target>
        </trans-unit>
        <trans-unit id="6d7d5d1de342dd19dac409116a1790776a3c96bc" translate="yes" xml:space="preserve">
          <source>A settable property that will intercept any uncaught errors that would otherwise be thrown in the next tick of the event loop, usually as a result of &lt;code&gt;done&lt;/code&gt;. Can be useful for getting the full stack trace of an error in browsers, which is not usually possible with &lt;code&gt;window.onerror&lt;/code&gt;.</source>
          <target state="translated">通常は &lt;code&gt;done&lt;/code&gt; の結果として、イベントループの次のティックでスローされるキャッチされていないエラーをインターセプトする設定可能なプロパティ。ブラウザでのエラーの完全なスタックトレースを取得するのに役立ちます。通常、 &lt;code&gt;window.onerror&lt;/code&gt; では不可能です。</target>
        </trans-unit>
        <trans-unit id="cc164fcfb8a39667ad143fc8a656a4c1a9bc4df1" translate="yes" xml:space="preserve">
          <source>A sugar method, equivalent to &lt;code&gt;promise.then(function () { return value; })&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;promise.then(function () { return value; })&lt;/code&gt; と同等の砂糖メソッド。</target>
        </trans-unit>
        <trans-unit id="8f9e7fe97f002fa8b6eae38edd5277d4beffbd97" translate="yes" xml:space="preserve">
          <source>A sugar method, equivalent to &lt;code&gt;promise.then(function () { throw reason; })&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;promise.then(function () { throw reason; })&lt;/code&gt; と同等の砂糖メソッド。</target>
        </trans-unit>
        <trans-unit id="9e0ddce10f1069e658b3bfcee13483384e1381b3" translate="yes" xml:space="preserve">
          <source>A sugar method, equivalent to &lt;code&gt;promise.then(undefined, onRejected)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;promise.then(undefined, onRejected)&lt;/code&gt; と同等の砂糖メソッド。</target>
        </trans-unit>
        <trans-unit id="c91134fdc4cd8b26846af66ab5e62f37ef68fa35" translate="yes" xml:space="preserve">
          <source>A sugar method, equivalent to &lt;code&gt;promise.then(undefined, undefined, onProgress)&lt;/code&gt;. The &lt;code&gt;onProgress&lt;/code&gt; handler receives values that were sent to this promise either from the &lt;code&gt;notify&lt;/code&gt; method of the corresponding deferred, or from the promise that this promise became by virtue of being returned from a handler.</source>
          <target state="translated">&lt;code&gt;promise.then(undefined, undefined, onProgress)&lt;/code&gt; と同等の砂糖メソッド。 &lt;code&gt;onProgress&lt;/code&gt; ハンドラのいずれかから、この約束に送信された値受信 &lt;code&gt;notify&lt;/code&gt; 対応する遅延、またはこの約束は、ハンドラから返されるのおかげでなった約束からの方法。</target>
        </trans-unit>
        <trans-unit id="fb15cb0ae41ac3c447a303c95d175aaf01577b70" translate="yes" xml:space="preserve">
          <source>Attaches a handler that will observe the value of the promise when it becomes fulfilled, returning a promise for that same value, perhaps deferred but not replaced by the promise returned by the &lt;code&gt;onFulfilled&lt;/code&gt; handler.</source>
          <target state="translated">promiseの値が満たされたときにその値を監視するハンドラーをアタッチし、同じ値のpromiseを返します。おそらく延期されますが、 &lt;code&gt;onFulfilled&lt;/code&gt; ハンドラーによって返されたpromiseに置き換えられません。</target>
        </trans-unit>
        <trans-unit id="286b1a5cc64d77383fc9aef74dda8bc27ead7742" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;notify&lt;/code&gt; with a value causes &lt;code&gt;promise&lt;/code&gt; to be notified of progress with that value. That is, any &lt;code&gt;onProgress&lt;/code&gt; handlers registered with &lt;code&gt;promise&lt;/code&gt; or promises derived from &lt;code&gt;promise&lt;/code&gt; will be called with the progress value.</source>
          <target state="translated">値を指定して &lt;code&gt;notify&lt;/code&gt; を呼び出すと、 &lt;code&gt;promise&lt;/code&gt; にその値の進行状況が通知されます。つまり、 &lt;code&gt;promise&lt;/code&gt; または &lt;code&gt;promise&lt;/code&gt; から派生したpromiseに登録されている &lt;code&gt;onProgress&lt;/code&gt; ハンドラーは、progress値で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c4f3ddc374fc41ceadf05240b53010c4536134a0" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;reject&lt;/code&gt; with a reason causes &lt;code&gt;promise&lt;/code&gt; to be rejected with that reason.</source>
          <target state="translated">理由付きで &lt;code&gt;reject&lt;/code&gt; を呼び出すと、 &lt;code&gt;promise&lt;/code&gt; はその理由付きで拒否されます。</target>
        </trans-unit>
        <trans-unit id="8a5425c48a55640821fe47530cf201775e1ef8ff" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;resolve&lt;/code&gt; with a fulfilled promise causes &lt;code&gt;promise&lt;/code&gt; to be fulfilled with the passed promise's fulfillment value.</source>
          <target state="translated">呼び出し &lt;code&gt;resolve&lt;/code&gt; 満たさ約束の原因はと &lt;code&gt;promise&lt;/code&gt; 渡された約束の履行値で満たされなければ。</target>
        </trans-unit>
        <trans-unit id="813a4a7641c9b6bd9bbdc971a738d65fb5e45d55" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;resolve&lt;/code&gt; with a non-promise value causes &lt;code&gt;promise&lt;/code&gt; to be fulfilled with that value.</source>
          <target state="translated">呼び出し &lt;code&gt;resolve&lt;/code&gt; 原因が非約束値と &lt;code&gt;promise&lt;/code&gt; 、その値を満たさなければ。</target>
        </trans-unit>
        <trans-unit id="7011bdd155303903e358ec08c68cd3a6d93575fc" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;resolve&lt;/code&gt; with a pending promise causes &lt;code&gt;promise&lt;/code&gt; to wait on the passed promise, becoming fulfilled with its fulfillment value or rejected with its rejection reason (or staying pending forever, if the passed promise does).</source>
          <target state="translated">保留中のプロミスで &lt;code&gt;resolve&lt;/code&gt; を呼び出すと、プロミスは渡された &lt;code&gt;promise&lt;/code&gt; を待機し、フルフィルメント値で満たされるか、拒否理由で拒否されます（または、渡されたプロミスがそうである場合は永久に保留されたままです）。</target>
        </trans-unit>
        <trans-unit id="6acc2e709ed1c95cfc1a249306618feb62d7ecda" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;resolve&lt;/code&gt; with a rejected promise causes &lt;code&gt;promise&lt;/code&gt; to be rejected with the passed promise's rejection reason.</source>
          <target state="translated">呼び出し &lt;code&gt;resolve&lt;/code&gt; 拒否された約束の原因は、と &lt;code&gt;promise&lt;/code&gt; 渡された約束の拒絶理由で拒否されます。</target>
        </trans-unit>
        <trans-unit id="4e270f7316cd8465770c808a872e50d981955d54" translate="yes" xml:space="preserve">
          <source>Calls a Node.js-style function with the given array of arguments, returning a promise that is fulfilled if the Node.js function calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</source>
          <target state="translated">与えられた引数の配列でNode.jsスタイルの関数を呼び出し、Node.js関数が結果を持ってコールバックした場合は約束を返し、エラーを持ってコールバックした場合は拒否します(または同期的にスローします)。例を示します。</target>
        </trans-unit>
        <trans-unit id="30912d3497e790cf1cb567d187ab2a29c5c0a405" translate="yes" xml:space="preserve">
          <source>Calls a Node.js-style function with the given variadic arguments, returning a promise that is fulfilled if the Node.js function calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</source>
          <target state="translated">与えられた可変引数でNode.jsスタイルの関数を呼び出し、Node.js関数が結果を持ってコールバックした場合は約束を返し、エラーを持ってコールバックした場合は拒否します(または同期的にスローします)。例を示します。</target>
        </trans-unit>
        <trans-unit id="ea81644f23eac4e3da8f7f52fea4fc9b35e1c8f0" translate="yes" xml:space="preserve">
          <source>Calls a Node.js-style method with the given arguments array, returning a promise that is fulfilled if the method calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</source>
          <target state="translated">与えられた引数配列を持つ Node.js スタイルのメソッドを呼び出し、そのメソッドが結果を返した場合は約束を返し、エラーを返した場合は拒否します (または同期的にスローします)。例を示します。</target>
        </trans-unit>
        <trans-unit id="b7515f9aab2d0076fc370a8befe0541a8ab1b175" translate="yes" xml:space="preserve">
          <source>Calls a Node.js-style method with the given variadic arguments, returning a promise that is fulfilled if the method calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</source>
          <target state="translated">与えられた variadic 引数を持つ Node.js スタイルのメソッドを呼び出し、メソッドが結果を返した場合は約束を返し、エラーを返した場合は拒否します (または同期的に引数を投げます)。例を示します。</target>
        </trans-unit>
        <trans-unit id="a810371fa4c94a6ce7ad4af13115b6cafd48de09" translate="yes" xml:space="preserve">
          <source>Care should be taken not to introduce control-flow hazards and security holes when forwarding messages to promises. The functions above, particularly &lt;code&gt;then&lt;/code&gt;, are carefully crafted to prevent a poorly crafted or malicious promise from breaking the invariants like not applying callbacks multiple times or in the same turn of the event loop.</source>
          <target state="translated">メッセージをpromiseに転送するときに、制御フローの危険とセキュリティホールを導入しないように注意する必要があります。特に、上記の機能 &lt;code&gt;then&lt;/code&gt; 、慎重にコールバックを複数回適用しないように、またはイベントループの同じ順番に不変条件を壊すから不十分細工や悪質な約束を防ぐために作られています。</target>
        </trans-unit>
        <trans-unit id="79db3d64d910483618c2a0f35c05edf9799c43ef" translate="yes" xml:space="preserve">
          <source>Core Promise</source>
          <target state="translated">コアプロミス</target>
        </trans-unit>
        <trans-unit id="caa6108533eba773194abce34b359c7a9b0238a6" translate="yes" xml:space="preserve">
          <source>Core Promise Methods</source>
          <target state="translated">コアプロミスの方法</target>
        </trans-unit>
        <trans-unit id="2fba880dc7d33f80254834d185041f3f7d80b24f" translate="yes" xml:space="preserve">
          <source>Creates a new version of &lt;code&gt;func&lt;/code&gt; that accepts any combination of promise and non-promise values, converting them to their fulfillment values before calling the original &lt;code&gt;func&lt;/code&gt;. The returned version also always returns a promise: if &lt;code&gt;func&lt;/code&gt; does a &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt;, then &lt;code&gt;Q.promised(func)&lt;/code&gt; will return fulfilled or rejected promise, respectively.</source>
          <target state="translated">元の &lt;code&gt;func&lt;/code&gt; を呼び出す前に、promise値とnon-promise値の任意の組み合わせを受け入れる &lt;code&gt;func&lt;/code&gt; の新しいバージョンを作成し、フルフィルメント値に変換します。返されたバージョンも必ず約束を返します場合 &lt;code&gt;func&lt;/code&gt; はない &lt;code&gt;return&lt;/code&gt; または &lt;code&gt;throw&lt;/code&gt; 、その後、 &lt;code&gt;Q.promised(func)&lt;/code&gt; 満たしたり、それぞれの約束を拒否返します。</target>
        </trans-unit>
        <trans-unit id="4c38227424efde920d83633b331700c062c735e6" translate="yes" xml:space="preserve">
          <source>Creates a promise-returning function from a Node.js-style function, optionally binding it with the given variadic arguments. An example:</source>
          <target state="translated">Node.jsスタイルの関数からプロミスを返す関数を作成します。例を示します。</target>
        </trans-unit>
        <trans-unit id="73898e6817218495671980abb0510aa5f928f5c4" translate="yes" xml:space="preserve">
          <source>Creates a promise-returning function from a Node.js-style method, optionally binding it with the given variadic arguments. An example:</source>
          <target state="translated">Node.jsスタイルのメソッドからプロミスを返す関数を作成します。例を示します。</target>
        </trans-unit>
        <trans-unit id="20457947466b5a4446435b2cd8859b4fabfb0a71" translate="yes" xml:space="preserve">
          <source>Custom Messaging</source>
          <target state="translated">カスタムメッセージング</target>
        </trans-unit>
        <trans-unit id="75fa48c8c7a2cb4f89ad8c76224f011589ab9f64" translate="yes" xml:space="preserve">
          <source>Custom Messaging API (Advanced)</source>
          <target state="translated">カスタムメッセージング API (詳細)</target>
        </trans-unit>
        <trans-unit id="4b4df21f5e0c20682e7715d55ffa3b7308180032" translate="yes" xml:space="preserve">
          <source>Deferreds are cool because they separate the promise part from the resolver part. So:</source>
          <target state="translated">Deferredsがクールなのは、約束の部分とリゾルバーの部分を分離しているからです。だから</target>
        </trans-unit>
        <trans-unit id="e727dc9f8b51e23ab82e57412e76770fce6e8db5" translate="yes" xml:space="preserve">
          <source>Error Handling and Tracking</source>
          <target state="translated">エラー処理とトラッキング</target>
        </trans-unit>
        <trans-unit id="a7458ec3892a2bebe00f22cd004670aea656d9b9" translate="yes" xml:space="preserve">
          <source>Exceptions thrown by &lt;code&gt;done&lt;/code&gt; will have long stack traces, if &lt;code&gt;Q.longStackSupport&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;Q.onerror&lt;/code&gt; is set, exceptions will be delivered there instead of thrown in a future turn.</source>
          <target state="translated">&lt;code&gt;Q.longStackSupport&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に設定されている場合、doneによってスローさ &lt;code&gt;done&lt;/code&gt; 例外は長いスタックトレースを持ちます。 &lt;code&gt;Q.onerror&lt;/code&gt; が設定されている場合、例外は将来のターンでスローされるのではなく、そこに配信されます。</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="3d8a4d046ac6da809fb06221161eeb7ead75fe7b" translate="yes" xml:space="preserve">
          <source>Gets an array of reasons belonging to rejected promises that currently have not been handled, i.e. no &lt;code&gt;onRejected&lt;/code&gt; callbacks have been called for them, they haven't been chained off of, etc. Generally these represent potentially-&quot;lost&quot; errors, so this array should be empty except possibly at times when you are passing a rejected promise around asynchronously so that someone can handle the rejection later.</source>
          <target state="translated">現在処理されていない拒否されたプロミスに属する理由の配列を取得します。つまり、それらに対して &lt;code&gt;onRejected&lt;/code&gt; コールバックが呼び出されていない、それらがオフにチェーンされていないなどの理由を取得します。通常、これらは潜在的に「失われた」エラーを表すため、この配列誰かが後で拒否を処理できるように、拒否されたプロミスを非同期で渡す場合を除いて、空にする必要があります。</target>
        </trans-unit>
        <trans-unit id="e38e1618908cfeefc0e5e089fa149954e44b2b83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; is a function, assumes it's a Node.js-style callback, and calls it as either &lt;code&gt;callback(rejectionReason)&lt;/code&gt; when/if &lt;code&gt;promise&lt;/code&gt; becomes rejected, or as &lt;code&gt;callback(null, fulfillmentValue)&lt;/code&gt; when/if &lt;code&gt;promise&lt;/code&gt; becomes fulfilled. If &lt;code&gt;callback&lt;/code&gt; is not a function, simply returns &lt;code&gt;promise&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; が関数の場合、Node.jsスタイルのコールバックであると想定し、 &lt;code&gt;promise&lt;/code&gt; が拒否されたとき/ &lt;code&gt;callback(rejectionReason)&lt;/code&gt; 、または &lt;code&gt;promise&lt;/code&gt; が満たされたとき/ &lt;code&gt;callback(null, fulfillmentValue)&lt;/code&gt; として呼び出します。 &lt;code&gt;callback&lt;/code&gt; が関数でない場合、単に &lt;code&gt;promise&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="d870c0bb953c968f7f6f954238c49781793205a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;resolver&lt;/code&gt; throws an exception, the returned promise will be rejected with that thrown exception as the rejection reason.</source>
          <target state="translated">&lt;code&gt;resolver&lt;/code&gt; が例外をスローした場合、返されたpromiseは拒否された例外を拒否理由として拒否されます。</target>
        </trans-unit>
        <trans-unit id="f0e800167077bfcca263f0edfc7b87d23872cdb2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is a Q promise, returns the promise.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; がQ promiseの場合、promiseを返します。</target>
        </trans-unit>
        <trans-unit id="3463f13b311cd838c032d85d849d7d3b447f2dea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is a promise from another library it is coerced into a Q promise (where possible).</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; が別のライブラリからのプロミスである場合、それはQプロミスに強制されます（可能な場合）。</target>
        </trans-unit>
        <trans-unit id="f6647050a594ab7d676c6f7d488ca83cd8876d0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is not a promise, returns a promise that is fulfilled with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; がpromiseでない場合は、 &lt;code&gt;value&lt;/code&gt; で満たされたpromiseを返します。</target>
        </trans-unit>
        <trans-unit id="02f5bfe583e29dae0f1bfe10ee899b8a530dbe5b" translate="yes" xml:space="preserve">
          <source>If the static version of &lt;code&gt;Q.delay&lt;/code&gt; is passed only a single argument, it returns a promise that will be fulfilled with &lt;code&gt;undefined&lt;/code&gt; after at least &lt;code&gt;ms&lt;/code&gt; milliseconds have passed. (If it's called with two arguments, it uses the usual static-counterpart translation, i.e. &lt;code&gt;Q.delay(value, ms)&lt;/code&gt; is equivalent to &lt;code&gt;Q(value).delay(ms)&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;Q.delay&lt;/code&gt; の静的バージョンに単一の引数のみが渡された場合、少なくとも &lt;code&gt;ms&lt;/code&gt; ミリ秒が経過した後に &lt;code&gt;undefined&lt;/code&gt; で満たされるpromiseを返します。（2つの引数で呼び出された場合、通常の静的対応変換を使用します。つまり、 &lt;code&gt;Q.delay(value, ms)&lt;/code&gt; は &lt;code&gt;Q(value).delay(ms)&lt;/code&gt; と同等です。）</target>
        </trans-unit>
        <trans-unit id="add3eb1e5208d60fe31c3687c61b5f403b45c7ee" translate="yes" xml:space="preserve">
          <source>In all cases where a promise is resolved (i.e. either fulfilled or rejected), the resolution is permanent and cannot be reset. Attempting to call &lt;code&gt;resolve&lt;/code&gt;, &lt;code&gt;reject&lt;/code&gt;, or &lt;code&gt;notify&lt;/code&gt; if &lt;code&gt;promise&lt;/code&gt; is already resolved will be a no-op.</source>
          <target state="translated">約束が解決された（つまり、履行または拒否された）すべての場合、解決は永続的であり、リセットできません。 &lt;code&gt;resolve&lt;/code&gt; 、 &lt;code&gt;reject&lt;/code&gt; 、または &lt;code&gt;promise&lt;/code&gt; がすでに解決されているかどうかを &lt;code&gt;notify&lt;/code&gt; することを試みても、何も起こりません。</target>
        </trans-unit>
        <trans-unit id="2b1f77e2a8190c99f6bc8adc65c47d9eba56075b" translate="yes" xml:space="preserve">
          <source>In its static form, it is aliased as &lt;code&gt;Q.try&lt;/code&gt;, since it has semantics similar to a &lt;code&gt;try&lt;/code&gt; block (but handling both synchronous exceptions and asynchronous rejections). This allows code like</source>
          <target state="translated">静的な形式では、 &lt;code&gt;try&lt;/code&gt; ブロックに似たセマンティクス（ただし、同期例外と非同期拒否の両方を処理する）であるため、 &lt;code&gt;Q.try&lt;/code&gt; としてエイリアスされます。これにより、次のようなコードが可能になります</target>
        </trans-unit>
        <trans-unit id="0e3f6c6c47261e255742e05dc9d19d1aacf67ca1" translate="yes" xml:space="preserve">
          <source>Interfacing with Node.js Callbacks</source>
          <target state="translated">Node.js コールバックとの連携</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="6bb3f3a74ab5d643aef7bd0c90e11c56b3838c4d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;then&lt;/code&gt;, but &quot;spreads&quot; the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls &lt;code&gt;onRejected&lt;/code&gt; with the first rejected promise's rejection reason.</source>
          <target state="translated">同様に &lt;code&gt;then&lt;/code&gt; 、しかし、「スプレッド」可変長履行ハンドラに配列。配列内のいずれかの &lt;code&gt;onRejected&lt;/code&gt; が拒否された場合、代わりに最初の拒否されたpromiseの拒否理由を指定してonRejectedを呼び出します。</target>
        </trans-unit>
        <trans-unit id="6834ebe5b4c4edb612e9ee32bf8b353cd01491ac" translate="yes" xml:space="preserve">
          <source>Like a &lt;code&gt;finally&lt;/code&gt; clause, allows you to observe either the fulfillment or rejection of a promise, but to do so without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded, like closing a database connection, shutting a server down, or deleting an unneeded key from an object.</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; 節と同様に、promiseの履行または拒否を監視できますが、最終値を変更せずに実行できます。これは、データベース接続を閉じる、サーバーをシャットダウンする、オブジェクトから不要なキーを削除するなど、ジョブが成功したかどうかに関係なくリソースを収集するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="1d6aa98cb2cb7bd2f69117491e4e8f5f13e91c37" translate="yes" xml:space="preserve">
          <source>Most promise methods have &quot;static&quot; counterparts on the main &lt;code&gt;Q&lt;/code&gt; object, which will accept either a promise or a non-promise, and in the latter case create a fulfilled promise first. For example, &lt;code&gt;Q.when(5, onFulfilled)&lt;/code&gt; is equivalent to &lt;code&gt;Q(5).then(onFulfilled)&lt;/code&gt;. All others have static counterparts that are named the same as the promise method.</source>
          <target state="translated">ほとんどのpromiseメソッドは、メインの &lt;code&gt;Q&lt;/code&gt; オブジェクトに「静的な」対応物があり、promiseまたはnon-promiseのいずれかを受け入れ、後者の場合、最初に満たされたpromiseを作成します。たとえば、 &lt;code&gt;Q.when(5, onFulfilled)&lt;/code&gt; は &lt;code&gt;Q(5).then(onFulfilled)&lt;/code&gt; と同等です。他のすべてのオブジェクトには、promiseメソッドと同じ名前の静的な対応物があります。</target>
        </trans-unit>
        <trans-unit id="13fb576ea389ec07587f2efe71056e870f3606ab" translate="yes" xml:space="preserve">
          <source>Much like &lt;code&gt;then&lt;/code&gt;, but with different behavior around unhandled rejection. If there is an unhandled rejection, either because &lt;code&gt;promise&lt;/code&gt; is rejected and no &lt;code&gt;onRejected&lt;/code&gt; callback was provided, or because &lt;code&gt;onFulfilled&lt;/code&gt; or &lt;code&gt;onRejected&lt;/code&gt; threw an error or returned a rejected promise, the resulting rejection reason is thrown as an exception in a future turn of the event loop.</source>
          <target state="translated">多くのように &lt;code&gt;then&lt;/code&gt; 、しかし、未処理の拒絶の周りに異なる動作をします。 &lt;code&gt;promise&lt;/code&gt; が拒否され、 &lt;code&gt;onRejected&lt;/code&gt; コールバックが提供されなかったため、または &lt;code&gt;onFulfilled&lt;/code&gt; または &lt;code&gt;onRejected&lt;/code&gt; がエラーをスローしたか、拒否されたプロミスを返したために、未処理の拒否があった場合、結果の拒否理由は、イベントループの将来のターンで例外としてスローされます。 。</target>
        </trans-unit>
        <trans-unit id="69f80067dcce936df962961121dbfe23a9e48842" translate="yes" xml:space="preserve">
          <source>Note that if a Node.js-style API calls back with more than one non-error parameter (e.g. &lt;a href=&quot;http://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback&quot;&gt;&lt;code&gt;child_process.execFile&lt;/code&gt;&lt;/a&gt;), Q packages these into an array as the promise's fulfillment value when doing the translation.</source>
          <target state="translated">Node.jsスタイルのAPIが複数の非エラーパラメータ（たとえば、&lt;a href=&quot;http://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback&quot;&gt; &lt;code&gt;child_process.execFile&lt;/code&gt; &lt;/a&gt;）でコールバックする場合、Qは、変換を行うときに、これらをプロミスのフルフィルメント値として配列にパッケージ化します。</target>
        </trans-unit>
        <trans-unit id="96aaccd957a283b851a22d1d19be6b95869ff337" translate="yes" xml:space="preserve">
          <source>Note that if you have a &lt;em&gt;method&lt;/em&gt; that uses the Node.js callback pattern, as opposed to just a &lt;em&gt;function&lt;/em&gt;, you will need to bind its &lt;code&gt;this&lt;/code&gt; value before passing it to &lt;code&gt;nfbind&lt;/code&gt;, like so:</source>
          <target state="translated">&lt;em&gt;関数&lt;/em&gt;だけではなく、Node.jsコールバックパターンを使用する&lt;em&gt;メソッド&lt;/em&gt;がある場合は、 &lt;code&gt;this&lt;/code&gt; 値をバインドしてから &lt;code&gt;nfbind&lt;/code&gt; に渡す必要があることに注意してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81a18822d86a6015f99c23268915b7a5af8b24d2" translate="yes" xml:space="preserve">
          <source>Note that this example only works because &lt;code&gt;FS.readFile&lt;/code&gt; is a &lt;em&gt;function&lt;/em&gt; exported from a module, not a &lt;em&gt;method&lt;/em&gt; on an object. For methods, e.g. &lt;code&gt;redisClient.get&lt;/code&gt;, you must bind the method to an instance before passing it to &lt;code&gt;Q.nfapply&lt;/code&gt; (or, generally, as an argument to any function call):</source>
          <target state="translated">&lt;code&gt;FS.readFile&lt;/code&gt; はモジュールからエクスポートされた&lt;em&gt;関数&lt;/em&gt;であり、オブジェクトの&lt;em&gt;メソッド&lt;/em&gt;ではないため、この例は機能することに注意してください。方法については、例えば &lt;code&gt;redisClient.get&lt;/code&gt; は、あなたがそれを渡す前に、インスタンスにメソッドをバインドする必要があります &lt;code&gt;Q.nfapply&lt;/code&gt; （任意の関数呼び出しの引数として、一般的に、または）：</target>
        </trans-unit>
        <trans-unit id="a6db6293c0d5001e6f96b2d11dfe8c9cdd298f3f" translate="yes" xml:space="preserve">
          <source>Note that this will result in the same return value/thrown exception translation as explained above for &lt;code&gt;fbind&lt;/code&gt;.</source>
          <target state="translated">これにより、上記の &lt;code&gt;fbind&lt;/code&gt; で説明したのと同じ戻り値/スロー例外の変換が行われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="985ba7e7f893aa9f3723657bbeebc63e206d0629" translate="yes" xml:space="preserve">
          <source>Promise Creation</source>
          <target state="translated">約束の創造</target>
        </trans-unit>
        <trans-unit id="f7dac5dee122443b910400ee35793e2eca25c396" translate="yes" xml:space="preserve">
          <source>Promise Methods</source>
          <target state="translated">プロミスの方法</target>
        </trans-unit>
        <trans-unit id="f1d46e5761361fc66ff5ba7db05edb32598e6da3" translate="yes" xml:space="preserve">
          <source>Promise-for-Array</source>
          <target state="translated">Promise-for-Array</target>
        </trans-unit>
        <trans-unit id="c8ab2ca63d38aed84bff8299bffa6e85932741ad" translate="yes" xml:space="preserve">
          <source>Promise-for-Array Methods</source>
          <target state="translated">アレイの約束のための方法</target>
        </trans-unit>
        <trans-unit id="ed29a3b76c93c87ac007e026b2969daa083ade34" translate="yes" xml:space="preserve">
          <source>Promise-for-Function</source>
          <target state="translated">Promise-for-Function</target>
        </trans-unit>
        <trans-unit id="6a0f6c01a0201f474dcba6fe03b353f09247a4df" translate="yes" xml:space="preserve">
          <source>Promise-for-Function Methods</source>
          <target state="translated">機能を約束する方法</target>
        </trans-unit>
        <trans-unit id="1d74958f915b9a8d09ad81f764c3e3ad5c8f3e75" translate="yes" xml:space="preserve">
          <source>Promise-for-Object</source>
          <target state="translated">Promise-for-Object</target>
        </trans-unit>
        <trans-unit id="c05db34be2fd0069344eeabde7ac2039cb5bb813" translate="yes" xml:space="preserve">
          <source>Promise-for-Object Methods</source>
          <target state="translated">オブジェクトに対する約束メソッド</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="c564adc0672165d0247a601f040788fb7f7cc8cd" translate="yes" xml:space="preserve">
          <source>Q object</source>
          <target state="translated">キューオブジェクト</target>
        </trans-unit>
        <trans-unit id="eb4c479556196d662563ac704263f35f8b48f245" translate="yes" xml:space="preserve">
          <source>Q provides a number of functions for interfacing with Node.js style &lt;code&gt;(err, result)&lt;/code&gt; callback APIs.</source>
          <target state="translated">Qは、Node.jsスタイル &lt;code&gt;(err, result)&lt;/code&gt; コールバックAPI とインターフェースするための多数の関数を提供します。</target>
        </trans-unit>
        <trans-unit id="7ba55744b39630d1585977c7fa135ac1654beef6" translate="yes" xml:space="preserve">
          <source>Q()</source>
          <target state="translated">Q()</target>
        </trans-unit>
        <trans-unit id="11ebf3d51b7d3cb4a808730bc74db97b03f5b0ca" translate="yes" xml:space="preserve">
          <source>Q(value)</source>
          <target state="translated">Q(value)</target>
        </trans-unit>
        <trans-unit id="882e9b9f3692eb8dea0e2c3fe21be3ff2e02e787" translate="yes" xml:space="preserve">
          <source>Q.Promise()</source>
          <target state="translated">Q.Promise()</target>
        </trans-unit>
        <trans-unit id="9ac23459bf64c4b05451ebf2ca588dfac36875a0" translate="yes" xml:space="preserve">
          <source>Q.Promise(resolver)</source>
          <target state="translated">Q.Promise(resolver)</target>
        </trans-unit>
        <trans-unit id="0954da9e4575d1d71de230a8796f79dc6b629ad2" translate="yes" xml:space="preserve">
          <source>Q.async()</source>
          <target state="translated">Q.async()</target>
        </trans-unit>
        <trans-unit id="28a5183740e005625501d3f8c933834f080b1115" translate="yes" xml:space="preserve">
          <source>Q.async(generatorFunction)</source>
          <target state="translated">Q.async(generatorFunction)</target>
        </trans-unit>
        <trans-unit id="da1dd7ad69401ce1b8380cd36799985b78a61256" translate="yes" xml:space="preserve">
          <source>Q.defer()</source>
          <target state="translated">Q.defer()</target>
        </trans-unit>
        <trans-unit id="f2492beb7cfbb6ace0a70545c4779ad96a6d6a42" translate="yes" xml:space="preserve">
          <source>Q.delay()</source>
          <target state="translated">Q.delay()</target>
        </trans-unit>
        <trans-unit id="879a7909385aaa69995f5ed0959b15930bd7259c" translate="yes" xml:space="preserve">
          <source>Q.delay(ms)</source>
          <target state="translated">Q.delay(ms)</target>
        </trans-unit>
        <trans-unit id="0bd5a326633d7bb4e6ce000d400eabafd43bda84" translate="yes" xml:space="preserve">
          <source>Q.getUnhandledReasons()</source>
          <target state="translated">Q.getUnhandledReasons()</target>
        </trans-unit>
        <trans-unit id="9866b21660ebdec962d906ff4f56405f3e32f300" translate="yes" xml:space="preserve">
          <source>Q.isPromise()</source>
          <target state="translated">Q.isPromise()</target>
        </trans-unit>
        <trans-unit id="4b735857b55ce96cf90b310ceb2e6797edc45ec4" translate="yes" xml:space="preserve">
          <source>Q.isPromise(value)</source>
          <target state="translated">Q.isPromise(value)</target>
        </trans-unit>
        <trans-unit id="55c3dcb3c0feaf08a68e0811ed963f531c793ebe" translate="yes" xml:space="preserve">
          <source>Q.isPromiseAlike()</source>
          <target state="translated">Q.isPromiseAlike()</target>
        </trans-unit>
        <trans-unit id="24f2d105d4ebf6c8dae5ec4ae15ac280019ee153" translate="yes" xml:space="preserve">
          <source>Q.isPromiseAlike(value)</source>
          <target state="translated">Q.isPromiseAlike(value)</target>
        </trans-unit>
        <trans-unit id="c2fb27cb639a68751537ed4014a0f2c9e4039b07" translate="yes" xml:space="preserve">
          <source>Q.longStackSupport</source>
          <target state="translated">Q.longStackSupport</target>
        </trans-unit>
        <trans-unit id="9ba21e8771c43e0c5b3ff64bb59d136f97fe290e" translate="yes" xml:space="preserve">
          <source>Q.nbind()</source>
          <target state="translated">Q.nbind()</target>
        </trans-unit>
        <trans-unit id="73aa048f6834dacdf4ccad16feaf700f6b42f3f5" translate="yes" xml:space="preserve">
          <source>Q.nbind(nodeMethod, thisArg, ...args)</source>
          <target state="translated">Q.nbind(nodeMethod,thisArg,...args)</target>
        </trans-unit>
        <trans-unit id="743f41ca1df2fea22e9a577892626be3e16e5351" translate="yes" xml:space="preserve">
          <source>Q.nfapply()</source>
          <target state="translated">Q.nfapply()</target>
        </trans-unit>
        <trans-unit id="f234d437a215f6f703e63dc30682a678611fec89" translate="yes" xml:space="preserve">
          <source>Q.nfapply(nodeFunc, args)</source>
          <target state="translated">Q.nfapply(nodeFunc,args)</target>
        </trans-unit>
        <trans-unit id="0c1e82892deb61b7b860618d939f3d7091d242dc" translate="yes" xml:space="preserve">
          <source>Q.nfbind()</source>
          <target state="translated">Q.nfbind()</target>
        </trans-unit>
        <trans-unit id="0c45f18ec104f210c6b7116e40f7a806c1448447" translate="yes" xml:space="preserve">
          <source>Q.nfbind(nodeFunc, ...args)</source>
          <target state="translated">Q.nfbind(nodeFunc,...args)</target>
        </trans-unit>
        <trans-unit id="c0a71ed8061857043b8a7b5d527b49307a73f9ad" translate="yes" xml:space="preserve">
          <source>Q.nfcall()</source>
          <target state="translated">Q.nfcall()</target>
        </trans-unit>
        <trans-unit id="490ef403baa03ccba3767a8588b6ff026a3920b0" translate="yes" xml:space="preserve">
          <source>Q.nfcall(func, ...args)</source>
          <target state="translated">Q.nfcall(func,...args)</target>
        </trans-unit>
        <trans-unit id="e6e27d72f79eb51ae254b36d719ce33a7bf80a2a" translate="yes" xml:space="preserve">
          <source>Q.ninvoke(object, methodName, ...args)</source>
          <target state="translated">Q.ninvoke(object,methodName,...args)</target>
        </trans-unit>
        <trans-unit id="2d263471f26606370fbf2b9b51ff4a7984c0e597" translate="yes" xml:space="preserve">
          <source>Q.npost()</source>
          <target state="translated">Q.npost()</target>
        </trans-unit>
        <trans-unit id="f65d84570e85d3d2ad4a08371d02f4f6d729fb37" translate="yes" xml:space="preserve">
          <source>Q.npost(object, methodName, args)</source>
          <target state="translated">Q.npost(object,methodName,args)</target>
        </trans-unit>
        <trans-unit id="636ae9916f42d07e87429073f308d52770a407af" translate="yes" xml:space="preserve">
          <source>Q.nsend()</source>
          <target state="translated">Q.nsend()</target>
        </trans-unit>
        <trans-unit id="c9714f6688c88106b1f05b60931fb43548eb44c9" translate="yes" xml:space="preserve">
          <source>Q.onerror</source>
          <target state="translated">Q.onerror</target>
        </trans-unit>
        <trans-unit id="16e6cc497544e2eb96cd75c7a7315f971579a9f3" translate="yes" xml:space="preserve">
          <source>Q.promised()</source>
          <target state="translated">Q.promised()</target>
        </trans-unit>
        <trans-unit id="b5af761b8969966f90d181b2b65ae641e3c0f9b9" translate="yes" xml:space="preserve">
          <source>Q.promised(func)</source>
          <target state="translated">Q.promised(func)</target>
        </trans-unit>
        <trans-unit id="00271436e145204dc99905a90c22e8d13dac2424" translate="yes" xml:space="preserve">
          <source>Q.reject()</source>
          <target state="translated">Q.reject()</target>
        </trans-unit>
        <trans-unit id="670d58a9aad977eca252eb777e966c7ed825fc1c" translate="yes" xml:space="preserve">
          <source>Q.reject(reason)</source>
          <target state="translated">Q.reject(reason)</target>
        </trans-unit>
        <trans-unit id="fbed2787ebf6c6a97f008c1188a6640fd4f584f5" translate="yes" xml:space="preserve">
          <source>Q.resetUnhandledRejections()</source>
          <target state="translated">Q.resetUnhandledRejections()</target>
        </trans-unit>
        <trans-unit id="60050db89bc695ad23268569789c31dce5615f30" translate="yes" xml:space="preserve">
          <source>Q.spawn()</source>
          <target state="translated">Q.spawn()</target>
        </trans-unit>
        <trans-unit id="d5a10c950d3c8298f22f64a67519ee0ad7b5a250" translate="yes" xml:space="preserve">
          <source>Q.spawn(generatorFunction)</source>
          <target state="translated">Q.spawn(generatorFunction)</target>
        </trans-unit>
        <trans-unit id="ebe579f01595c1801ef833889f7a340c46ac5509" translate="yes" xml:space="preserve">
          <source>Q.stopUnhandledRejectionTracking()</source>
          <target state="translated">Q.stopUnhandledRejectionTracking()</target>
        </trans-unit>
        <trans-unit id="33b74d4d2f5b0f0333df3173df500e7c71ccd205" translate="yes" xml:space="preserve">
          <source>Q.try()</source>
          <target state="translated">Q.try()</target>
        </trans-unit>
        <trans-unit id="8c380d0d1ec98a3914061b4960fe7bbff101c28c" translate="yes" xml:space="preserve">
          <source>Resets Q's internal tracking of unhandled rejections, but keeps unhandled rejection tracking on. This method is exposed mainly for testing and diagnostic purposes, where you may have accumulated some unhandled rejections but want to re-start with a clean slate.</source>
          <target state="translated">Qの未処理のリジェクトの内部トラッキングをリセットしますが、未処理のリジェクトのトラッキングはオンにしておきます。このメソッドは主にテストや診断の目的で使用されます。</target>
        </trans-unit>
        <trans-unit id="1f6bd0c6782da5037bf1018e122daf7cb635ea7e" translate="yes" xml:space="preserve">
          <source>Returns a &quot;deferred&quot; object with a:</source>
          <target state="translated">を持つ &quot;derred&quot; オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="5b6b7cdc79f9deb6a3bd5f887df8ef0f6b3285bd" translate="yes" xml:space="preserve">
          <source>Returns a &quot;state snapshot&quot; object, which will be in one of three forms:</source>
          <target state="translated">状態のスナップショット」オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="1bf5b4c519699a61bcf3f6f21005b68935f02138" translate="yes" xml:space="preserve">
          <source>Returns a function suitable for passing to a Node.js API. That is, it has a signature &lt;code&gt;(err, result)&lt;/code&gt; and will reject &lt;code&gt;deferred.promise&lt;/code&gt; with &lt;code&gt;err&lt;/code&gt; if &lt;code&gt;err&lt;/code&gt; is given, or fulfill it with &lt;code&gt;result&lt;/code&gt; if that is given.</source>
          <target state="translated">Node.js APIに渡すのに適した関数を返します。つまり、署名 &lt;code&gt;(err, result)&lt;/code&gt; あり、 &lt;code&gt;err&lt;/code&gt; が指定 &lt;code&gt;deferred.promise&lt;/code&gt; ている場合はdeferred.promiseを &lt;code&gt;err&lt;/code&gt; で拒否し、それが指定されている場合は &lt;code&gt;result&lt;/code&gt; でそれを実行します。</target>
        </trans-unit>
        <trans-unit id="e747d88e6199a0b1d79671b8e080502aeb1211ae" translate="yes" xml:space="preserve">
          <source>Returns a new function that calls a function asynchronously with the given variadic arguments, and returns a promise. Notably, any synchronous return values or thrown exceptions are transformed, respectively, into fulfillment values or rejection reasons for the promise returned by this new function.</source>
          <target state="translated">与えられた可変引数で関数を非同期的に呼び出し、約束を返す新しい関数を返します。注目すべきは、同期的な戻り値やスローされた例外は、それぞれ、この新しい関数によって返された約束の履行値や拒否理由に変換されることです。</target>
        </trans-unit>
        <trans-unit id="5983ce0ac83174b5716d73e16b5bb6aa91e0d311" translate="yes" xml:space="preserve">
          <source>Returns a promise for an array of the property names of an object. Essentially equivalent to</source>
          <target state="translated">オブジェクトのプロパティ名の配列に対するプロミスを返します。基本的には</target>
        </trans-unit>
        <trans-unit id="c65bd90cb68c31c693d15905092abe0176f14227" translate="yes" xml:space="preserve">
          <source>Returns a promise for the result of calling a function, with the given array of arguments. Essentially equivalent to</source>
          <target state="translated">関数をコールした結果に対する約束を、指定した引数の配列で返します。基本的には</target>
        </trans-unit>
        <trans-unit id="d4790f371165b929370d52a3f3a73fecfc53035a" translate="yes" xml:space="preserve">
          <source>Returns a promise for the result of calling a function, with the given variadic arguments. Has the same return value/thrown exception translation as explained above for &lt;code&gt;fbind&lt;/code&gt;.</source>
          <target state="translated">指定された可変引数を使用して、関数の呼び出し結果のpromiseを返します。上記の &lt;code&gt;fbind&lt;/code&gt; で説明したのと同じ戻り値/スロー例外の変換があります。</target>
        </trans-unit>
        <trans-unit id="c1d51d66c0a571661a75fe96cb963112aba7327a" translate="yes" xml:space="preserve">
          <source>Returns a promise for the result of calling the named method of an object with the given array of arguments. The object itself is &lt;code&gt;this&lt;/code&gt; in the function, just like a synchronous method call. Essentially equivalent to</source>
          <target state="translated">指定された引数の配列でオブジェクトの名前付きメソッドを呼び出した結果のpromiseを返します。オブジェクト自体は、同期メソッド呼び出しと同様に、関数内の &lt;code&gt;this&lt;/code&gt; です。本質的に同等</target>
        </trans-unit>
        <trans-unit id="a90c007c0c35faf384030c2f7dd1e50f4a010227" translate="yes" xml:space="preserve">
          <source>Returns a promise for the result of calling the named method of an object with the given variadic arguments. The object itself is &lt;code&gt;this&lt;/code&gt; in the function, just like a synchronous method call.</source>
          <target state="translated">指定された可変引数を使用して、オブジェクトの名前付きメソッドを呼び出した結果のpromiseを返します。オブジェクト自体は、同期メソッド呼び出しと同様に、関数内の &lt;code&gt;this&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3c48232f587ed7ad0d385891e35b261cbaa9a5c1" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.</source>
          <target state="translated">各約束の履行値を含む配列で履行された約束、または最初に拒絶される約束と同じ拒絶理由で拒絶された約束を返します。</target>
        </trans-unit>
        <trans-unit id="0022238e74976d00e82acaa8a274cb6c392e64e0" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected.</source>
          <target state="translated">約束の状態のスナップショットの配列を用いて約束が履行された約束を返しますが、 元の約束がすべて解決した後、つまり、約束が履行されたか拒否されたかのいずれかになった後にのみ、約束が履行されます。</target>
        </trans-unit>
        <trans-unit id="97db047eaca017371e1e76ef3177deea98068b52" translate="yes" xml:space="preserve">
          <source>Returns a promise that is rejected with &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; で拒否されたpromiseを返します。</target>
        </trans-unit>
        <trans-unit id="0daf6de4a47a33bfbd591eb02625358dd75dff9f" translate="yes" xml:space="preserve">
          <source>Returns a promise that will have the same result as &lt;code&gt;promise&lt;/code&gt;, but will only be fulfilled after at least &lt;code&gt;ms&lt;/code&gt; milliseconds have passed. If &lt;code&gt;promise&lt;/code&gt; is rejected, the resulting promise will be rejected immediately.</source>
          <target state="translated">同じ結果になります約束を返し &lt;code&gt;promise&lt;/code&gt; 、しかし少なくとも、後にのみ成就される &lt;code&gt;ms&lt;/code&gt; （ミリ秒）が経過しています。場合は &lt;code&gt;promise&lt;/code&gt; 拒否され、結果の約束はすぐに拒否されます。</target>
        </trans-unit>
        <trans-unit id="eb58b3c4289b05a010dec7098dd3415ff2e098fe" translate="yes" xml:space="preserve">
          <source>Returns a promise that will have the same result as &lt;code&gt;promise&lt;/code&gt;, except that if &lt;code&gt;promise&lt;/code&gt; is not fulfilled or rejected before &lt;code&gt;ms&lt;/code&gt; milliseconds, the returned promise will be rejected with an &lt;code&gt;Error&lt;/code&gt; with the given &lt;code&gt;message&lt;/code&gt;. If &lt;code&gt;message&lt;/code&gt; is not supplied, the message will be &lt;code&gt;&quot;Timed out after &quot; + ms + &quot; ms&quot;&lt;/code&gt;.</source>
          <target state="translated">戻り値と同じ結果になります約束 &lt;code&gt;promise&lt;/code&gt; 場合ことを除いて、 &lt;code&gt;promise&lt;/code&gt; する前に満たされたり拒否されていない &lt;code&gt;ms&lt;/code&gt; （ミリ秒）、返された約束はして拒否されます &lt;code&gt;Error&lt;/code&gt; 与えられたとの &lt;code&gt;message&lt;/code&gt; 。 &lt;code&gt;message&lt;/code&gt; が提供されない場合、メッセージは &lt;code&gt;&quot;Timed out after &quot; + ms + &quot; ms&quot;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="7d15d66a64b918e09fa184d65145361d365119dd" translate="yes" xml:space="preserve">
          <source>Returns a promise to get the named property of an object. Essentially equivalent to</source>
          <target state="translated">オブジェクトの名前付きプロパティを取得する約束を返します。基本的には</target>
        </trans-unit>
        <trans-unit id="9adfe33c327736b089c7d2a364b68a8d64ae0dbf" translate="yes" xml:space="preserve">
          <source>Returns whether a given promise is in the fulfilled state. When the static version is used on non-promises, the result is always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">指定されたプロミスが履行済みの状態かどうかを返します。静的バージョンを非Promiseで使用すると、結果は常に &lt;code&gt;true&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="64c65a525a7dbcb351cdf4333b7322e7608ee527" translate="yes" xml:space="preserve">
          <source>Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">指定されたpromiseが保留状態かどうかを返します。静的バージョンを非Promiseで使用すると、結果は常に &lt;code&gt;false&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="92d3ca70546718ee6e890398be5378777a129658" translate="yes" xml:space="preserve">
          <source>Returns whether a given promise is in the rejected state. When the static version is used on non-promises, the result is always &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">指定されたpromiseが拒否された状態かどうかを返します。静的バージョンを非Promiseで使用すると、結果は常に &lt;code&gt;false&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="ba86bb02211418bc983b6ce2c35e95ac19ab4605" translate="yes" xml:space="preserve">
          <source>Returns whether the given value is a Q promise.</source>
          <target state="translated">与えられた値がQ約束であるかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="68ef929f0eba73a555b1ac5226e0f5c0c1e90154" translate="yes" xml:space="preserve">
          <source>Returns whether the given value is a promise (i.e. it's an object with a &lt;code&gt;then&lt;/code&gt; function).</source>
          <target state="translated">指定された値がプロミス（つまり、 &lt;code&gt;then&lt;/code&gt; 関数を持つオブジェクト）であるかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="88fd4e439ddcf95e2f7937761348b973d2b2f3fa" translate="yes" xml:space="preserve">
          <source>Sends an arbitrary message to a promise, with the given array of arguments.</source>
          <target state="translated">任意のメッセージを、引数の配列を指定してプロミスに送信します。</target>
        </trans-unit>
        <trans-unit id="603aff8440ff59673505e95f9cd4bed2c77a8e2a" translate="yes" xml:space="preserve">
          <source>Several of these are usually used in their static form, and thus listed here as such. Nevertheless, they also exist on each Q promise, in case you somehow have a promise for a Node.js-style function or for an object with Node.js-style methods.</source>
          <target state="translated">これらのいくつかは通常は静的な形で使用されるため、ここではそのような形でリストアップされています。それでも、Node.jsスタイルの関数やNode.jsスタイルのメソッドを持つオブジェクトのためのプロミスを何らかの形で持っている場合に備えて、これらは各Qのプロミスにも存在しています。</target>
        </trans-unit>
        <trans-unit id="5e2542f83068d64d5e8755b069131c1444cd541b" translate="yes" xml:space="preserve">
          <source>Some methods are named the same as JavaScript reserved words, like &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;finally&lt;/code&gt;. This helps show the very clear parallel between standard synchronous language constructs and asynchronous promise operations. However, such use of words as property names is only supported as of the ECMAScript 5 edition of the JavaScript language, which isn't implemented in certain older browsers like IE8, Safari 5, Android 2.2, or PhantomJS 1.8. If you're targeting those browsers, and aren't using a language like CoffeeScript that takes care of this for you, use their aliases instead, or escape them like &lt;code&gt;Q[&quot;try&quot;](...)&lt;/code&gt; or &lt;code&gt;promise[&quot;catch&quot;](...)&lt;/code&gt;.</source>
          <target state="translated">一部のメソッドは、 &lt;code&gt;try&lt;/code&gt; 、 &lt;code&gt;catch&lt;/code&gt; 、 &lt;code&gt;finally&lt;/code&gt; など、JavaScriptの予約語と同じ名前が付けられています。これは、標準の同期言語構造と非同期のPromise操作の間の非常に明確な並列性を示すのに役立ちます。ただし、プロパティ名としてのこのような単語の使用は、JavaScript言語のECMAScript 5エディションでのみサポートされており、IE8、Safari 5、Android 2.2、PhantomJS 1.8などの特定の古いブラウザーでは実装されていません。これらのブラウザーを対象としていて、CoffeeScriptのようにこれを処理する言語を使用していない場合は、代わりにそれらのエイリアスを使用するか、 &lt;code&gt;Q[&quot;try&quot;](...)&lt;/code&gt; または &lt;code&gt;promise[&quot;catch&quot;](...)&lt;/code&gt; ようにエスケープします。「]（...） 。</target>
        </trans-unit>
        <trans-unit id="fe8265d31c1eb002f8a5beaa04cd7992e8fec565" translate="yes" xml:space="preserve">
          <source>State Inspection</source>
          <target state="translated">国家検査</target>
        </trans-unit>
        <trans-unit id="d2cae58d2aadc3a254ead471a3388630dd330a43" translate="yes" xml:space="preserve">
          <source>State Inspection Methods</source>
          <target state="translated">状態検査の方法</target>
        </trans-unit>
        <trans-unit id="9d6d276e3a747e7c1e8d386c17de0ea65fb9ea73" translate="yes" xml:space="preserve">
          <source>Synchronously calls &lt;code&gt;resolver(resolve, reject, notify)&lt;/code&gt; and returns a promise whose state is controlled by the functions passed to &lt;code&gt;resolver&lt;/code&gt;. This is an alternative promise-creation API that has the same power as the deferred concept, but without introducing another conceptual entity.</source>
          <target state="translated">同期的に &lt;code&gt;resolver(resolve, reject, notify)&lt;/code&gt; を呼び出し、resolverに渡された関数によって状態が制御されるpromiseを返し &lt;code&gt;resolver&lt;/code&gt; 。これは、据え置き概念と同じ機能を備えた別のプロミス作成APIですが、別の概念エンティティーを導入していません。</target>
        </trans-unit>
        <trans-unit id="5138b0b95faef656f8475291af8ee7602c47f01a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Q&lt;/code&gt; promise constructor establishes the basic API for performing operations on objects: &quot;get&quot;, &quot;put&quot;, &quot;del&quot;, &quot;post&quot;, &quot;apply&quot;, and &quot;keys&quot;. This set of &quot;operators&quot; can be extended by creating promises that respond to messages with other operator names, and by sending corresponding messages to those promises.</source>
          <target state="translated">&lt;code&gt;Q&lt;/code&gt; の「GET」、「PUT」、「デル」、「ポスト」、「適用」、および「キー」：約束のコンストラクタは、基本的なオブジェクトに対して操作を実行するためのAPIを確立します。この「オペレーター」のセットは、他のオペレーター名のメッセージに応答するプロミスを作成し、対応するメッセージをそれらのプロミスに送信することによって拡張できます。</target>
        </trans-unit>
        <trans-unit id="1847a01ac55630b4b20e4c4f43e66c92da807144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; methods control the state of the &lt;code&gt;promise&lt;/code&gt; property, which you can hand out to others while keeping the authority to modify its state to yourself. The &lt;code&gt;notify&lt;/code&gt; method is for progress notification, and the &lt;code&gt;makeNodeResolver&lt;/code&gt; method is for interfacing with Node.js (see below).</source>
          <target state="translated">&lt;code&gt;resolve&lt;/code&gt; と &lt;code&gt;reject&lt;/code&gt; の方法はの状態を制御 &lt;code&gt;promise&lt;/code&gt; 自分にその状態を変更する権限を維持しながら、あなたが他の人に配ることができますプロパティを、。 &lt;code&gt;notify&lt;/code&gt; 方法は、進捗通知するためのものであり、 &lt;code&gt;makeNodeResolver&lt;/code&gt; の方法は、Node.jsの（下記参照）とインターフェースするためのものです。</target>
        </trans-unit>
        <trans-unit id="7f0ff16f4ad2b2d2481fca6ad296d4b8b4a6c769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;then&lt;/code&gt; method from the &lt;a href=&quot;http://promises-aplus.github.com/promises-spec/&quot;&gt;Promises/A+ specification&lt;/a&gt;, with an additional progress handler.</source>
          <target state="translated">&lt;a href=&quot;http://promises-aplus.github.com/promises-spec/&quot;&gt;Promises / A +仕様&lt;/a&gt;の &lt;code&gt;then&lt;/code&gt; メソッド。追加の進捗ハンドラーがあります。</target>
        </trans-unit>
        <trans-unit id="d3457508f40bcbc1f796ff61e05a2ed206574bd5" translate="yes" xml:space="preserve">
          <source>The better strategy for methods would be to use &lt;code&gt;Q.nbind&lt;/code&gt;, as shown below.</source>
          <target state="translated">以下に示すように、メソッドのより良い戦略は &lt;code&gt;Q.nbind&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="eb418a497047c89804571a36c1d1b7e6f4b77732" translate="yes" xml:space="preserve">
          <source>The better strategy for methods would be to use &lt;code&gt;Q.npost&lt;/code&gt;, as shown below.</source>
          <target state="translated">以下に示すように、メソッドのより良い戦略は &lt;code&gt;Q.npost&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="41655a54c78b92067b5dab99b966942bcb07d6f3" translate="yes" xml:space="preserve">
          <source>The same warning about functions vs. methods applies for &lt;code&gt;nfcall&lt;/code&gt; as it does for &lt;code&gt;nfapply&lt;/code&gt;. In this case, the better strategy would be to use &lt;code&gt;Q.ninvoke&lt;/code&gt;.</source>
          <target state="translated">メソッド対関数についての同じ警告が適用されるため &lt;code&gt;nfcall&lt;/code&gt; それがために行うように &lt;code&gt;nfapply&lt;/code&gt; 。この場合、より良い戦略は &lt;code&gt;Q.ninvoke&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="f5b2974b679580a4410845f580024f2878ce6671" translate="yes" xml:space="preserve">
          <source>The state snapshots will be in the same form as those retrieved via &lt;a href=&quot;#promiseinspect&quot;&gt;&lt;code&gt;promise.inspect&lt;/code&gt;&lt;/a&gt;, i.e. either &lt;code&gt;{ state: &quot;fulfilled&quot;, value: v }&lt;/code&gt; or &lt;code&gt;{ state: &quot;rejected&quot;, reason: r }&lt;/code&gt;.</source>
          <target state="translated">状態のスナップショットは&lt;a href=&quot;#promiseinspect&quot;&gt; &lt;code&gt;promise.inspect&lt;/code&gt; &lt;/a&gt;を介して取得したものと同じ形式になります。つまり、 &lt;code&gt;{ state: &quot;fulfilled&quot;, value: v }&lt;/code&gt; フルフィルド &quot;、値：v}または &lt;code&gt;{ state: &quot;rejected&quot;, reason: r }&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="9cfd32e0efc3b8c3fdbb3068c66c59b3ea630cee" translate="yes" xml:space="preserve">
          <source>This can be useful for creating functions that accept either promises or non-promise values, and for ensuring that the function always returns a promise even in the face of unintentional thrown exceptions.</source>
          <target state="translated">これは、プロミスまたは非プロミス値を受け入れる関数を作成したり、意図せずに例外が投げられた場合でも関数が常にプロミスを返すことを保証したりするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="79f5bf5e47f3de995cddb6ce7012b6dac7752cca" translate="yes" xml:space="preserve">
          <source>This immediately runs a generator function, and forwards any uncaught errors to &lt;code&gt;Q.onerror&lt;/code&gt;. An uncaught error is deemed to occur if the function returns a rejected promise. Note that this automatically occurs if the generator function throws an error, e.g. by &lt;code&gt;yield&lt;/code&gt;ing on a promise that becomes rejected without surrounding that code with a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;:</source>
          <target state="translated">これはすぐにジェネレーター関数を実行し、キャッチされていないエラーを &lt;code&gt;Q.onerror&lt;/code&gt; に転送します。関数が拒否されたpromiseを返す場合、キャッチされないエラーが発生したと見なされます。ジェネレータ関数はにより例えば、エラーをスローした場合、これが自動的に発生することに注意してください &lt;code&gt;yield&lt;/code&gt; でそのコードを囲むことなく、拒否されてしまう約束をINGの &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b0035faccac5d31823e7b8f9471ab2567c5b543" translate="yes" xml:space="preserve">
          <source>This is a convenient way to insert a delay into a promise chain, or even simply to get a nicer syntax for &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">これは、promiseチェーンに遅延を挿入する、または単に &lt;code&gt;setTimeout&lt;/code&gt; のより良い構文を取得するための便利な方法です。</target>
        </trans-unit>
        <trans-unit id="d7604c57af26baec990f4a086808bf4136848896" translate="yes" xml:space="preserve">
          <source>This is an experimental tool for converting a generator function into a deferred function. This has the potential of reducing nested callbacks in engines that support &lt;code&gt;yield&lt;/code&gt;. See &lt;a href=&quot;https://github.com/kriskowal/q/tree/v1/examples/async-generators&quot;&gt;the generators example&lt;/a&gt; for further information.</source>
          <target state="translated">これは、ジェネレーター関数を遅延関数に変換するための実験的なツールです。これは、 &lt;code&gt;yield&lt;/code&gt; をサポートするエンジンでネストされたコールバックを減らす可能性があります。詳細について&lt;a href=&quot;https://github.com/kriskowal/q/tree/v1/examples/async-generators&quot;&gt;は、ジェネレータの例&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7b95b44864ccfaaed5a35e0535f4f8c3a34b1821" translate="yes" xml:space="preserve">
          <source>This is especially useful in conjunction with &lt;code&gt;all&lt;/code&gt;, for example:</source>
          <target state="translated">これは、 &lt;code&gt;all&lt;/code&gt; と組み合わせて使用​​すると特に役立ちます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="32fcca162135cbde7a932dd83c691e00ba2d31f1" translate="yes" xml:space="preserve">
          <source>This method is especially useful in its static form for wrapping functions to ensure that they are always asynchronous, and that any thrown exceptions (intentional or accidental) are appropriately transformed into a returned rejected promise. For example:</source>
          <target state="translated">このメソッドは、関数が常に非同期であることを保証するために関数をラップするための静的な形式で特に有用です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="078b7a22c80d4b52b31a45a5be24ee13a153f9d1" translate="yes" xml:space="preserve">
          <source>This method is often used in its static form on arrays of promises, in order to execute a number of operations concurrently and be notified when they all finish, regardless of success or failure. For example:</source>
          <target state="translated">このメソッドは、多くの操作を同時に実行して、成功か失敗かに関係なく、すべての操作が終了したときに通知されるようにするために、静的な形式でプロミスの配列でよく使用されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="bca04acd5b32f09aaabaeadd82401f6a9d10205a" translate="yes" xml:space="preserve">
          <source>This method is often used in its static form on arrays of promises, in order to execute a number of operations concurrently and be notified when they all succeed. For example:</source>
          <target state="translated">このメソッドは、多くの操作を同時に実行し、すべての操作が成功したときに通知されるようにするために、静的な形式でプロミスの配列でよく使用されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b9a0f1ffc43ccbe82153a50b9f1aac4fbf891920" translate="yes" xml:space="preserve">
          <source>This method is useful for creating dual promise/callback APIs, i.e. APIs that return promises but also accept Node.js-style callbacks. For example:</source>
          <target state="translated">このメソッドはデュアルプロミス/コールバックAPI、つまりプロミスを返すAPIを作成するのに便利ですが、Node.jsスタイルのコールバックも受け付けることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="60502da155455484d77f5a0328f9ea0b9393ceef" translate="yes" xml:space="preserve">
          <source>This method should be used to terminate chains of promises that will not be passed elsewhere. Since exceptions thrown in &lt;code&gt;then&lt;/code&gt; callbacks are consumed and transformed into rejections, exceptions at the end of the chain are easy to accidentally, silently ignore. By arranging for the exception to be thrown in a future turn of the event loop, so that it won't be caught, it causes an &lt;code&gt;onerror&lt;/code&gt; event on the browser &lt;code&gt;window&lt;/code&gt;, or an &lt;code&gt;uncaughtException&lt;/code&gt; event on Node.js's &lt;code&gt;process&lt;/code&gt; object.</source>
          <target state="translated">このメソッドは、他の場所に渡されないpromiseのチェーンを終了するために使用する必要があります。中に例外がスローされますので &lt;code&gt;then&lt;/code&gt; のコールバックが消費や拒否に変換され、チェーンの最後に例外が誤って、黙って無視するのは簡単です。例外がキャッチされないように、イベントループの将来のターンで例外がスローされるように &lt;code&gt;process&lt;/code&gt; ことで、ブラウザー &lt;code&gt;window&lt;/code&gt; で &lt;code&gt;onerror&lt;/code&gt; イベントが発生するか、Node.jsのプロセスオブジェクトで &lt;code&gt;uncaughtException&lt;/code&gt; イベントが発生します。</target>
        </trans-unit>
        <trans-unit id="042d4b4dd699dc89c4160022cbcff2282982df14" translate="yes" xml:space="preserve">
          <source>Turns off unhandled rejection tracking, which provides a slight efficiency boost if you don't find that debug information helpful. It also prevents Q from printing any unhandled rejection reasons upon process exit in Node.js.</source>
          <target state="translated">手つかずの拒絶の追跡をオフにして、デバッグ情報が役に立つと思わない場合に、少しだけ効率を上げます。また、Node.jsのプロセス終了時にQがアンハンドレッドリジェクトの理由を印刷しないようにします。</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="5486a0e8e13b0b039dc58793f09b6e6eb6465317" translate="yes" xml:space="preserve">
          <source>Utility Methods</source>
          <target state="translated">ユーティリティーの方法</target>
        </trans-unit>
        <trans-unit id="09347fef1e383dddcf741804bf4e99f85d0e1502" translate="yes" xml:space="preserve">
          <source>You can give the promise to any number of consumers and all of them will observe the resolution independently. Because the capability of observing a promise is separated from the capability of resolving the promise, none of the recipients of the promise have the ability to &quot;trick&quot; other recipients with misinformation (or indeed interfere with them in any way).</source>
          <target state="translated">任意の数の消費者に約束を与えることができ、そのすべての消費者が独立して解決を観測する。約束を観察する能力と、約束を解決する能力は切り離されているので、約束の受信者の誰一人として、他の受信者を誤情報で「騙す」能力を持っていません(実際には何らかの形で妨害することもあります)。</target>
        </trans-unit>
        <trans-unit id="3dad4dba1d1723fcad6e15603dbb57d9eb8c1d47" translate="yes" xml:space="preserve">
          <source>You can give the resolver to any number of producers and whoever resolves the promise first wins. Furthermore, none of the producers can observe that they lost unless you give them the promise part too.</source>
          <target state="translated">リゾルバーは何人のプロデューサーにでも渡すことができ、最初に約束を解決した人が勝ちです。さらに、プロデューサーにも約束の部分を与えない限り、誰も負けたことを観察することはできません。</target>
        </trans-unit>
        <trans-unit id="b552347e9ea988c3bfb5a98430abefe4890a0612" translate="yes" xml:space="preserve">
          <source>deferred.makeNodeResolver()</source>
          <target state="translated">deferred.makeNodeResolver()</target>
        </trans-unit>
        <trans-unit id="f3dd025a8d4a054c822920f0ba5de808ffb543dc" translate="yes" xml:space="preserve">
          <source>deferred.notify()</source>
          <target state="translated">deferred.notify()</target>
        </trans-unit>
        <trans-unit id="7ae5f295d0eb41704b39bc5842bf2ce85f03ed37" translate="yes" xml:space="preserve">
          <source>deferred.notify(value)</source>
          <target state="translated">deferred.notify(value)</target>
        </trans-unit>
        <trans-unit id="51aff75a8bb3dba096f7ef45bfa25d57989b7308" translate="yes" xml:space="preserve">
          <source>deferred.reject()</source>
          <target state="translated">deferred.reject()</target>
        </trans-unit>
        <trans-unit id="2e1baf2b707a8a04db342470b867446047254723" translate="yes" xml:space="preserve">
          <source>deferred.reject(reason)</source>
          <target state="translated">deferred.reject(reason)</target>
        </trans-unit>
        <trans-unit id="cfb0f049b85a87aa2cde9c0157e6b08e14268cc9" translate="yes" xml:space="preserve">
          <source>deferred.resolve()</source>
          <target state="translated">deferred.resolve()</target>
        </trans-unit>
        <trans-unit id="befc66d1724d1825fe5f08090872429281f20402" translate="yes" xml:space="preserve">
          <source>deferred.resolve(value)</source>
          <target state="translated">deferred.resolve(value)</target>
        </trans-unit>
        <trans-unit id="52ea1a94dca9d9de516850ab44fd61bf7075fe94" translate="yes" xml:space="preserve">
          <source>promise.all()</source>
          <target state="translated">promise.all()</target>
        </trans-unit>
        <trans-unit id="4fdc5ffdfdf55894a8d09d6b2a7e9b6c34e132b7" translate="yes" xml:space="preserve">
          <source>promise.allSettled()</source>
          <target state="translated">promise.allSettled()</target>
        </trans-unit>
        <trans-unit id="1cc9a0db4c7fcd3384610224407ec2777e3dc602" translate="yes" xml:space="preserve">
          <source>promise.catch(onRejected)</source>
          <target state="translated">promise.catch(onRejected)</target>
        </trans-unit>
        <trans-unit id="146243766c3634deef7a297881b6b5208185f561" translate="yes" xml:space="preserve">
          <source>promise.delay()</source>
          <target state="translated">promise.delay()</target>
        </trans-unit>
        <trans-unit id="2a7412d9f5c9daf01d777e686a98f1abf1afcb5e" translate="yes" xml:space="preserve">
          <source>promise.delay(ms)</source>
          <target state="translated">promise.delay(ms)</target>
        </trans-unit>
        <trans-unit id="d2996b2db982c1ad9f988c0174e1a83f557d7eaf" translate="yes" xml:space="preserve">
          <source>promise.dispatch()</source>
          <target state="translated">promise.dispatch()</target>
        </trans-unit>
        <trans-unit id="ec7d2c18116eb168623d0d1e51d8b4073c39880a" translate="yes" xml:space="preserve">
          <source>promise.dispatch(operator, args)</source>
          <target state="translated">promise.dispatch(operator,args)</target>
        </trans-unit>
        <trans-unit id="9a0cf288f13aeb03b856717b03bc373c5cd15a31" translate="yes" xml:space="preserve">
          <source>promise.done()</source>
          <target state="translated">promise.done()</target>
        </trans-unit>
        <trans-unit id="312ee94b5f936b9eddb2048065a56320cc827899" translate="yes" xml:space="preserve">
          <source>promise.done(onFulfilled, onRejected, onProgress)</source>
          <target state="translated">promise.doen(onFulfilled,onRejected,onProgress)</target>
        </trans-unit>
        <trans-unit id="b765f0e53eb8734fdd8c3c46e0acd5a399b5e8b4" translate="yes" xml:space="preserve">
          <source>promise.fail()</source>
          <target state="translated">promise.fail()</target>
        </trans-unit>
        <trans-unit id="2363fed5cbbc9268dfb81147ff068794f88df559" translate="yes" xml:space="preserve">
          <source>promise.fapply()</source>
          <target state="translated">promise.fapply()</target>
        </trans-unit>
        <trans-unit id="b85320cfc4cf64d95bb6874a1fd4a2b1783807ba" translate="yes" xml:space="preserve">
          <source>promise.fapply(args)</source>
          <target state="translated">promise.fapply(args)</target>
        </trans-unit>
        <trans-unit id="3c0ed4209942fbdd63be60406b99f472d48c7453" translate="yes" xml:space="preserve">
          <source>promise.fbind()</source>
          <target state="translated">promise.fbind()</target>
        </trans-unit>
        <trans-unit id="8d41630b9a8617df4c09bc487678779d3dec126d" translate="yes" xml:space="preserve">
          <source>promise.fbind(...args) &lt;em&gt;(deprecated)&lt;/em&gt;</source>
          <target state="translated">promise.fbind（... args）&lt;em&gt;（非推奨）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b85ab74c3e71c8c2b12b03c568275bdea12ebd2" translate="yes" xml:space="preserve">
          <source>promise.fcall(...args)</source>
          <target state="translated">promise.fcall(...args)</target>
        </trans-unit>
        <trans-unit id="d548d47776ef0cec99c45a44dc83c8ff07312015" translate="yes" xml:space="preserve">
          <source>promise.finally()</source>
          <target state="translated">promise.finally()</target>
        </trans-unit>
        <trans-unit id="bf49254f5d29c37f6040f64d1f26ea16c52e33c1" translate="yes" xml:space="preserve">
          <source>promise.finally(callback)</source>
          <target state="translated">promise.finally(callback)</target>
        </trans-unit>
        <trans-unit id="9e8022ac49bf93c0e5087b717dc46244945f8b0f" translate="yes" xml:space="preserve">
          <source>promise.get()</source>
          <target state="translated">promise.get()</target>
        </trans-unit>
        <trans-unit id="e15313100014b0645e13cd1c2a1feb57293c2912" translate="yes" xml:space="preserve">
          <source>promise.get(propertyName)</source>
          <target state="translated">promise.get(propertyName)</target>
        </trans-unit>
        <trans-unit id="9cb4b7ca15eb28baba089f11ef9448dafe88a806" translate="yes" xml:space="preserve">
          <source>promise.inspect()</source>
          <target state="translated">promise.inspect()</target>
        </trans-unit>
        <trans-unit id="1724d9e876338209189774c3e48e44a586f5e9ea" translate="yes" xml:space="preserve">
          <source>promise.invoke(methodName, ...args)</source>
          <target state="translated">promise.invoke(methodName,...args)</target>
        </trans-unit>
        <trans-unit id="7c09faaa6df9377a9b5147c742b14f023a77e5ef" translate="yes" xml:space="preserve">
          <source>promise.isFulfilled()</source>
          <target state="translated">promise.isFulfilled()</target>
        </trans-unit>
        <trans-unit id="48e45bc731c06c99933188a40132b98dbd4b2674" translate="yes" xml:space="preserve">
          <source>promise.isPending()</source>
          <target state="translated">promise.isPending()</target>
        </trans-unit>
        <trans-unit id="471ff3f638b345b3050c54d32a015e7c52999bc7" translate="yes" xml:space="preserve">
          <source>promise.isRejected()</source>
          <target state="translated">promise.isRejected()</target>
        </trans-unit>
        <trans-unit id="29b1f857bf941f5bd9601ee101ee3edbb84c93f9" translate="yes" xml:space="preserve">
          <source>promise.keys()</source>
          <target state="translated">promise.keys()</target>
        </trans-unit>
        <trans-unit id="6ff256e4c6bec7b11d1b7e22762b682f91ea6e04" translate="yes" xml:space="preserve">
          <source>promise.nodeify()</source>
          <target state="translated">promise.nodeify()</target>
        </trans-unit>
        <trans-unit id="324a86e90f88eead1d976e8f00169816845c2162" translate="yes" xml:space="preserve">
          <source>promise.nodeify(callback)</source>
          <target state="translated">promise.nodeify(callback)</target>
        </trans-unit>
        <trans-unit id="0b79ada9209b9b82f998371b35df0bf5021b6ce8" translate="yes" xml:space="preserve">
          <source>promise.post()</source>
          <target state="translated">promise.post()</target>
        </trans-unit>
        <trans-unit id="a5086c648ff9e298e5764b192d029d865bf7e670" translate="yes" xml:space="preserve">
          <source>promise.post(methodName, args)</source>
          <target state="translated">promise.post(methodName,args)</target>
        </trans-unit>
        <trans-unit id="ecd8a93afeec7d91e2a744aa4b43c753d91e7863" translate="yes" xml:space="preserve">
          <source>promise.progress()</source>
          <target state="translated">promise.progress()</target>
        </trans-unit>
        <trans-unit id="aea845ef3439bec565fe51d8a1ac31942fa2aee4" translate="yes" xml:space="preserve">
          <source>promise.progress(onProgress)</source>
          <target state="translated">promise.progress(onProgress)</target>
        </trans-unit>
        <trans-unit id="b7a4297677bab31d0523909b8cd795efae143235" translate="yes" xml:space="preserve">
          <source>promise.send()</source>
          <target state="translated">promise.send()</target>
        </trans-unit>
        <trans-unit id="9bcd0bee9c1133c14f5afc59526295381468b471" translate="yes" xml:space="preserve">
          <source>promise.spread()</source>
          <target state="translated">promise.spread()</target>
        </trans-unit>
        <trans-unit id="5528e00f9e67324699fc92867a4cb208e85e2463" translate="yes" xml:space="preserve">
          <source>promise.spread(onFulfilled, onRejected)</source>
          <target state="translated">promise.spread(onFulfilled,onRejected)</target>
        </trans-unit>
        <trans-unit id="8d746bb714f5af94ff4fc66460e9e0b111f7844b" translate="yes" xml:space="preserve">
          <source>promise.tap()</source>
          <target state="translated">promise.tap()</target>
        </trans-unit>
        <trans-unit id="6a924580a7854f76a65fe49fb9ae46524ef52433" translate="yes" xml:space="preserve">
          <source>promise.tap(onFulfilled)</source>
          <target state="translated">promise.tap(onFulfilled)</target>
        </trans-unit>
        <trans-unit id="c0c5e160b8d6524eb2d96121be26c1682dbae995" translate="yes" xml:space="preserve">
          <source>promise.then()</source>
          <target state="translated">promise.then()</target>
        </trans-unit>
        <trans-unit id="98a9c3255c84b1e429307707ba63fb94c5b81167" translate="yes" xml:space="preserve">
          <source>promise.then(onFulfilled, onRejected, onProgress)</source>
          <target state="translated">promise.then(onFulfilled,onRejected,onProgress)</target>
        </trans-unit>
        <trans-unit id="4161af8ef4b10a5328cd7a2fbe1f1e372a894d12" translate="yes" xml:space="preserve">
          <source>promise.thenReject()</source>
          <target state="translated">promise.thenReject()</target>
        </trans-unit>
        <trans-unit id="44ff3f45d91e2d292bdf05e92b2f04d17c120608" translate="yes" xml:space="preserve">
          <source>promise.thenReject(reason)</source>
          <target state="translated">promise.thenReject(reason)</target>
        </trans-unit>
        <trans-unit id="f9eb06abcde059740519a949eea5966dc008ef34" translate="yes" xml:space="preserve">
          <source>promise.thenResolve()</source>
          <target state="translated">promise.thenResolve()</target>
        </trans-unit>
        <trans-unit id="afa9f132a365f033bef3aa97051878a982f6f652" translate="yes" xml:space="preserve">
          <source>promise.thenResolve(value)</source>
          <target state="translated">promise.thenResolve(value)</target>
        </trans-unit>
        <trans-unit id="dbb049ee1d870010daf461c74a9cf3cd24b4eda9" translate="yes" xml:space="preserve">
          <source>promise.timeout()</source>
          <target state="translated">promise.timeout()</target>
        </trans-unit>
        <trans-unit id="bc0257d2fcba197a8698b89285a1891d2eb7247d" translate="yes" xml:space="preserve">
          <source>promise.timeout(ms, message)</source>
          <target state="translated">promise.timeout(ms,message)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
