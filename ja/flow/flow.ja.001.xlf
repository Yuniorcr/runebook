<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="flow">
    <body>
      <group id="flow">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy;2013&amp;ndash;present Facebook Inc.</target>
        </trans-unit>
        <trans-unit id="503a7ef34e5694be261272081a6d34cc44e0d368" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVAXAngBwKZgCCAxhgJZwB2YAvGKmGAD5gDe2+AXGAOSE8AaMDgCGWeCIAm3AM4YATmUoBzAL6MGzNhzzceAIUHCxE6WEoBXALYAjPPNUBudMGBgA8gGlUxKnLBQAIy0YAAUIqQUlNwk5FQAlLQAfGyaMghkGMQAFmERcZQAdDqJrJqMxCIyBHw83PJ4GBby1PlRhaLicFKFMHgqGNnOjBVVNYb1jc2tkVQdJt2SYADUYIEADMNgqqg7Lm4AcnAYHp5gFpS+Vlb9J1Bw8mD28g8yAISorr6U-lAATCFQuxcHghJ1TKoYrNKIkaCkyq5GOlMjkwiVUoiRpVqrx+JMmi1jF0en0BkNPm4sWNeBMwA0CdRwYsVmtNhTGDtEaogA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVAXAngBwKZgCCAxhgJZwB2YAvGKmGAD5gDe2+AXGAOSE8AaMDgCGWeCIAm3AM4YATmUoBzAL6MGzNhzzceAIUHCxE6WEoBXALYAjPPNUBudMGBgA8gGlUxKnLBQAIy0YAAUIqQUlNwk5FQAlLQAfGyaMghkGMQAFmERcZQAdDqJrJqMxCIyBHw83PJ4GBby1PlRhaLicFKFMHgqGNnOjBVVNYb1jc2tkVQdJt2SYADUYIEADMNgqqg7Lm4AcnAYHp5gFpS+Vlb9J1Bw8mD28g8yAISorr6U-lAATCFQuxcHghJ1TKoYrNKIkaCkyq5GOlMjkwiVUoiRpVqrx+JMmi1jF0en0BkNPm4sWNeBMwA0CdRwYsVmtNhTGDtEaogA&quot;&gt;https://flow.org/try&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="eabf0a1897fda94c2e7ebc351cec25f06658c93f" translate="yes" xml:space="preserve">
          <source>(Example adapted from the &lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt;&lt;code&gt;react-router&lt;/code&gt; documentation&lt;/a&gt;.)</source>
          <target state="translated">（&lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt; &lt;code&gt;react-router&lt;/code&gt; のドキュメント&lt;/a&gt;からの変更例。）</target>
        </trans-unit>
        <trans-unit id="42553dcf511140edb9c7fe5b095d179ad3d34209" translate="yes" xml:space="preserve">
          <source>.flowconfig</source>
          <target state="translated">.flowconfig</target>
        </trans-unit>
        <trans-unit id="2a0c7002997e311437a0c70c2313661b929d09ce" translate="yes" xml:space="preserve">
          <source>.flowconfig [declarations]</source>
          <target state="translated">.flowconfig [宣言]</target>
        </trans-unit>
        <trans-unit id="d3dd6ba8743bbd7b4542e5b7d98c01e397699462" translate="yes" xml:space="preserve">
          <source>.flowconfig [ignore]</source>
          <target state="translated">.flowconfig [無視]</target>
        </trans-unit>
        <trans-unit id="4cd3ed66f9dc2ea1ae8c5970c30160743de16d59" translate="yes" xml:space="preserve">
          <source>.flowconfig [include]</source>
          <target state="translated">.flowconfig [include]</target>
        </trans-unit>
        <trans-unit id="3ea7d542265be35c8d390fac59fd3922fa10029f" translate="yes" xml:space="preserve">
          <source>.flowconfig [libs]</source>
          <target state="translated">.flowconfig [libs]</target>
        </trans-unit>
        <trans-unit id="c19cd00744af8fb6b750b055353a165de408ef34" translate="yes" xml:space="preserve">
          <source>.flowconfig [lints]</source>
          <target state="translated">.flowconfig [lints]</target>
        </trans-unit>
        <trans-unit id="2be99164d570a360166709ab948593a53e747ee5" translate="yes" xml:space="preserve">
          <source>.flowconfig [options]</source>
          <target state="translated">.flowconfig [options]</target>
        </trans-unit>
        <trans-unit id="84e57eb03e551cd373c767c8c1b1d4e0b233bd32" translate="yes" xml:space="preserve">
          <source>.flowconfig [untyped]</source>
          <target state="translated">.flowconfig [untyped]</target>
        </trans-unit>
        <trans-unit id="6e95572239f9d638c63d382400d10b3a21062e5b" translate="yes" xml:space="preserve">
          <source>.flowconfig [version]</source>
          <target state="translated">.flowconfig [バージョン]</target>
        </trans-unit>
        <trans-unit id="f75dc1d3fd7cae440d82a0aa033937f60c951c83" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-check-your-code&quot;&gt;Check your code&lt;/a&gt; for type errors.</source>
          <target state="translated">&lt;a href=&quot;#toc-check-your-code&quot;&gt;&lt;/a&gt;型エラーがないかコードを確認してください。</target>
        </trans-unit>
        <trans-unit id="8bab6e4eae9423dd12abe68c046f07b864298440" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-initialize-your-project&quot;&gt;Initialize your project&lt;/a&gt; with &lt;code&gt;flow init&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toc-initialize-your-project&quot;&gt;&lt;/a&gt; &lt;code&gt;flow init&lt;/code&gt; を使用してプロジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="3d9e05645c42f52a6d394efa517892368a0d28c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;Determine&lt;/a&gt; which files Flow will monitor with &lt;code&gt;// @flow&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;&lt;/a&gt;Flowが &lt;code&gt;// @flow&lt;/code&gt; 監視するファイルを決定します。</target>
        </trans-unit>
        <trans-unit id="336448ab183f9e44d80f92a10e044c594b5d94a9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-write-flow-code&quot;&gt;Write Flow code&lt;/a&gt; for your project.</source>
          <target state="translated">&lt;a href=&quot;#toc-write-flow-code&quot;&gt;&lt;/a&gt;プロジェクトのフローコードを記述します。</target>
        </trans-unit>
        <trans-unit id="34cd8914987eabdf3008fb9dec6130b2e2a3a08a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a type that models React nested array data structure for children. &lt;code&gt;ReactNodeWithoutStrings&lt;/code&gt; uses &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; to be an arbitrarily nested array of null, boolean, or React elements.</source>
          <target state="translated">&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;は、子のReactネスト配列データ構造をモデル化するタイプです。 &lt;code&gt;ReactNodeWithoutStrings&lt;/code&gt; は、&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;を使用して、null、boolean、またはReact要素の任意にネストされた配列になります。</target>
        </trans-unit>
        <trans-unit id="e273fef233f652d4764944c36bc8e7d44f3499a9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../types#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; is the type of a React element like &lt;code&gt;&amp;lt;div/&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;MyComponent/&amp;gt;&lt;/code&gt;. Notably elements are not the same as components!</source>
          <target state="translated">&lt;a href=&quot;../types#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;&amp;lt;div/&amp;gt;&lt;/code&gt; や &lt;code&gt;&amp;lt;MyComponent/&amp;gt;&lt;/code&gt; ようなReact要素のタイプです。特に要素はコンポーネントと同じではありません！</target>
        </trans-unit>
        <trans-unit id="0f4966d59ad6be431d4d59785410831a89f983b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; is the general type for children, but sometimes you might want to use &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; while excluding some primitives like strings and numbers. &lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt;The React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; component&lt;/a&gt; does this, for example.</source>
          <target state="translated">&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;は子供向けの一般的なタイプですが、文字列や数値などのいくつかのプリミティブを除外しながら&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;を使用したい場合があります。たとえば、&lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt; React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; コンポーネント&lt;/a&gt;がこれを行います。</target>
        </trans-unit>
        <trans-unit id="7cf7f34d3e52f3dec53af2db9a70edf0af8a23b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES modules&lt;/a&gt; have two kinds of exports: A &lt;strong&gt;named&lt;/strong&gt; export and a &lt;strong&gt;default&lt;/strong&gt; export. Flow supports the ability to declare either or both of these kinds of exports within a &lt;code&gt;declare module&lt;/code&gt; body as follows:</source>
          <target state="translated">&lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ESモジュールに&lt;/a&gt;は、&lt;strong&gt;名前付き&lt;/strong&gt;エクスポートと&lt;strong&gt;デフォルト&lt;/strong&gt;エクスポートの2種類のエクスポートがあり&lt;strong&gt;ます&lt;/strong&gt;。フローは、次のように、 &lt;code&gt;declare module&lt;/code&gt; 本体内でこれらの種類のエクスポートのいずれかまたは両方を宣言する機能をサポートします。</target>
        </trans-unit>
        <trans-unit id="17c120254fa9c516a881da71a463bb260e63bcd7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://facebook.github.io/react-native/docs/tabbarios.html&quot;&gt;React Native&amp;rsquo;s &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; component&lt;/a&gt; only allows React element children and those elements &lt;em&gt;must&lt;/em&gt; have a component type of &lt;code&gt;&amp;lt;TabBarIOS.Item&amp;gt;&lt;/code&gt;. You are expected to use &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; like:</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/react-native/docs/tabbarios.html&quot;&gt;React Nativeの &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; コンポーネント&lt;/a&gt;はReact要素の子のみを許可し、それらの要素には &lt;code&gt;&amp;lt;TabBarIOS.Item&amp;gt;&lt;/code&gt; のコンポーネントタイプが&lt;em&gt;必要&lt;/em&gt;です。次のように &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="cf8957393a72df26897385761d8aa21a45d75df4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt;The React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; component&lt;/a&gt; will allow any primitive value or any React element as its children. However, &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; does not allow strings or numbers as children! You could use &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; as the children type for &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt;, however &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; includes strings which we don&amp;rsquo;t want for &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt;. So we need to create our own type.</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt;React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; コンポーネント&lt;/a&gt;は、任意のプリミティブ値または任意のReact要素をその子として許可します。ただし、 &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; は子として文字列または数値を許可しません！あなたが使用することができ&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; を&lt;/a&gt;ため、子供のタイプとして &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 、しかし&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; は、&lt;/a&gt;我々が望んでいない文字列を含んでいる &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 。したがって、独自のタイプを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="ad2498aaf0a179d73775581b93f384fe069a1601" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://frantic.im/using-redux-with-flow&quot;&gt;Using Redux with Flow&lt;/a&gt; - Alex Kotliarskyi</source>
          <target state="translated">&lt;a href=&quot;http://frantic.im/using-redux-with-flow&quot;&gt;FlowでのReduxの使用&lt;/a&gt; -Alex Kotliarskyi</target>
        </trans-unit>
        <trans-unit id="8449c031ca7fc8f782a895f5de5db0cd2312f7ea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://redux.js.org&quot;&gt;Redux&lt;/a&gt; has three major parts that should be typed:</source>
          <target state="translated">&lt;a href=&quot;http://redux.js.org&quot;&gt;Reduxに&lt;/a&gt;は、入力する必要がある3つの主要部分があります。</target>
        </trans-unit>
        <trans-unit id="d778c6db4ed26b14b4bcc87859b7232d009a05a6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://redux.js.org/docs/basics/Reducers.html&quot;&gt;Reducers&lt;/a&gt; take the state and actions that we&amp;rsquo;ve typed and pulls them together for one method.</source>
          <target state="translated">&lt;a href=&quot;http://redux.js.org/docs/basics/Reducers.html&quot;&gt;レデューサー&lt;/a&gt;は、入力した状態とアクションを受け取り、それらを1つのメソッドにまとめます。</target>
        </trans-unit>
        <trans-unit id="1e1a716310cc261310c0720a3defabf948f65c71" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://atom.io/packages/autocomplete-flow&quot;&gt;autocomplete-flow&lt;/a&gt; is another purpose-built tool that only does one thing. This package, as the name suggests, will give your flow enabled code autocomplete suggestions and nothing else.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io/packages/autocomplete-flow&quot;&gt;autocomplete-flow&lt;/a&gt;は、1つのことだけを実行する専用のツールです。このパッケージは、名前が示すように、フロー対応コードのオートコンプリートの提案のみを提供します。</target>
        </trans-unit>
        <trans-unit id="70aa1aa8e107ff621d1e0476ca9e4b0d1b64169e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://atom.io/packages/flow-ide&quot;&gt;Flow-IDE&lt;/a&gt; is a smaller package that only provides you with a linter and autocomplete functionality. It, too, currently lacks support for on-the-fly linting.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io/packages/flow-ide&quot;&gt;Flow-IDE&lt;/a&gt;は、リンターとオートコンプリート機能のみを提供する小さなパッケージです。また、現在、オンザフライリンティングのサポートが不足しています。</target>
        </trans-unit>
        <trans-unit id="0ef7fc7d336d051de3c6fc08efe1aa750a6c3fd1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://atom.io/packages/ide-flowtype&quot;&gt;Flow for Atom IDE&lt;/a&gt; is extracted from Nuclide, and works with the &lt;a href=&quot;https://ide.atom.io/&quot;&gt;Atom IDE&lt;/a&gt; UI. It brings the core features you expect in a full-featured IDE into Atom, such as language-aware autocomplete, diagnostics, go-to-definition, type hints, and symbol outlines.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io/packages/ide-flowtype&quot;&gt;Atom IDEのフロー&lt;/a&gt;はNuclideから抽出され、&lt;a href=&quot;https://ide.atom.io/&quot;&gt;Atom IDE&lt;/a&gt; UIで動作します。これは、言語認識オートコンプリート、診断、定義への移行、タイプヒント、シンボルアウトラインなど、フル機能のIDEで期待されるコア機能をAtomにもたらします。</target>
        </trans-unit>
        <trans-unit id="f392cb41c6c533748c908f516d743440fc3fc957" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt; has several editor integrations for using Flow.</source>
          <target state="translated">&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Codeに&lt;/a&gt;は、フローを使用するためのいくつかのエディター統合があります。</target>
        </trans-unit>
        <trans-unit id="3f30e103a4115c80055634733b0aa13e5b344c45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;Watchman&lt;/a&gt; must be installed and the &lt;code&gt;watchman&lt;/code&gt; binary must be in the PATH.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;夜警を&lt;/a&gt;インストールする必要がありますし、 &lt;code&gt;watchman&lt;/code&gt; バイナリがPATHに存在する必要があります。</target>
        </trans-unit>
        <trans-unit id="f963c3075e23bb3cf6001267bae91bbb9c401ba6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-nonstrict-import&quot;&gt;&lt;code&gt;nonstrict-import&lt;/code&gt;&lt;/a&gt;: Triggers an error when importing from a module which is not also &lt;code&gt;@flow strict&lt;/code&gt;. This is very important, because it means that when a file is marked as strict, all of its dependencies are strict as well.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-nonstrict-import&quot;&gt; &lt;code&gt;nonstrict-import&lt;/code&gt; &lt;/a&gt;： &lt;code&gt;@flow strict&lt;/code&gt; でもないモジュールからインポートすると、エラーが発生します。これは、ファイルがstrictとしてマークされている場合、その依存関係もすべてstrictであることを意味するため、非常に重要です。</target>
        </trans-unit>
        <trans-unit id="23dc038c2ecb0a3dd5d8efa5dc006412b7663f59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-sketchy-null&quot;&gt;&lt;code&gt;sketchy-null&lt;/code&gt;&lt;/a&gt;: Triggers an error when doing an existence check on a value that could be null/undefined or falsey.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-sketchy-null&quot;&gt; &lt;code&gt;sketchy-null&lt;/code&gt; &lt;/a&gt;：null / undefinedまたはfalseである可能性のある値の存在チェックを実行するときにエラーをトリガーします。</target>
        </trans-unit>
        <trans-unit id="56b2dc1b2d6f50b7b575c022bf5062e97e364ce7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unclear-type&quot;&gt;&lt;code&gt;unclear-type&lt;/code&gt;&lt;/a&gt;: Triggers an error when using &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, or &lt;code&gt;any&lt;/code&gt; in a type annotation.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unclear-type&quot;&gt; &lt;code&gt;unclear-type&lt;/code&gt; &lt;/a&gt;：型注釈で &lt;code&gt;Object&lt;/code&gt; 、 &lt;code&gt;Function&lt;/code&gt; 、または &lt;code&gt;any&lt;/code&gt; を使用するときにエラーをトリガーします。</target>
        </trans-unit>
        <trans-unit id="acccc45b43c76d68c5b6f5a5cb4efb4873e9f331" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unsafe-getters-setters&quot;&gt;&lt;code&gt;unsafe-getters-setters&lt;/code&gt;&lt;/a&gt;: Triggers an error when using getters and setters, which can be unsafe.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unsafe-getters-setters&quot;&gt; &lt;code&gt;unsafe-getters-setters&lt;/code&gt; &lt;/a&gt;：ゲッターとセッターを使用するときにエラーをトリガーします。これは安全ではない可能性があります。</target>
        </trans-unit>
        <trans-unit id="50e62738926445ab80ca91b62a51deef77f07c6d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-import&quot;&gt;&lt;code&gt;untyped-import&lt;/code&gt;&lt;/a&gt;: Triggers an error when importing from an untyped module.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-import&quot;&gt; &lt;code&gt;untyped-import&lt;/code&gt; &lt;/a&gt;：型なしモジュールからインポートするときにエラーをトリガーします。</target>
        </trans-unit>
        <trans-unit id="d428c85916fe38ed4c6c020088009c38838b5b26" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-type-import&quot;&gt;&lt;code&gt;untyped-type-import&lt;/code&gt;&lt;/a&gt;: Triggers an error when importing a type from an untyped module.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-type-import&quot;&gt; &lt;code&gt;untyped-type-import&lt;/code&gt; &lt;/a&gt;：型なしモジュールから型をインポートするときにエラーをトリガーします。</target>
        </trans-unit>
        <trans-unit id="8f07b8879f1946951cbf77557ef11a9915432823" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;Exact object types&lt;/a&gt; disable width subtyping, and do not allow additional properties to exist.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;正確なオブジェクトタイプは&lt;/a&gt;、幅のサブタイプを無効にし、追加のプロパティの存在を許可しません。</target>
        </trans-unit>
        <trans-unit id="7bb6540eba761465bf65a5ccdd99346953e691d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; already supports Flow by default. All you need to do is &lt;a href=&quot;https://flow.org/en/install/&quot;&gt;install Flow&lt;/a&gt; and create a &lt;code&gt;.flowconfig&lt;/code&gt; file by running &lt;code&gt;flow init&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React Appは&lt;/a&gt;既にデフォルトでFlowをサポートしています。すべてを行う必要がある&lt;a href=&quot;https://flow.org/en/install/&quot;&gt;フローをインストール&lt;/a&gt;して作成 &lt;code&gt;.flowconfig&lt;/code&gt; の実行して、ファイル &lt;code&gt;flow init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5375300eb5712965cf5fc5cb3cf56433133be9cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;&lt;code&gt;flow-remove-types&lt;/code&gt;&lt;/a&gt; is a small CLI tool for stripping Flow type annotations from files. It&amp;rsquo;s a lighter-weight alternative to Babel for projects that don&amp;rsquo;t need everything Babel provides.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt; &lt;code&gt;flow-remove-types&lt;/code&gt; &lt;/a&gt;は、ファイルからフロータイプの注釈を取り除くための小さなCLIツールです。これは、Babelが提供するすべてを必要としないプロジェクトのためのBabelの軽量な代替品です。</target>
        </trans-unit>
        <trans-unit id="518c67db26b37e0a41e20d16b7df11d4b116b8cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/neoclide/coc.nvim&quot;&gt;Coc&lt;/a&gt; is an intellisense engine for vim8 &amp;amp; neovim.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/neoclide/coc.nvim&quot;&gt;Coc&lt;/a&gt;はvim8とneovimのインテリセンスエンジンです。</target>
        </trans-unit>
        <trans-unit id="79e9310832926dd892f262feeb40312198e89414" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=flowtype.flow-for-vscode&quot;&gt;Flow Language Support&lt;/a&gt; provides all the functionality you would expect &amp;mdash; linting, intellisense, type tooltips and click-to-definition. It&amp;rsquo;s stable and under active development.</source>
          <target state="translated">&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=flowtype.flow-for-vscode&quot;&gt;フロー言語サポート&lt;/a&gt;は、リンティング、インテリセンス、タイプツールチップ、クリックして定義など、期待するすべての機能を提供します。安定しており、活発に開発されています。</target>
        </trans-unit>
        <trans-unit id="7c85b0e7dccf1df1c9799d9517b8f07ae7d48726" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/@cdebotton/redux-and-flowtype-69ff1dd09036#.fsrm1amlk&quot;&gt;Redux and Flowtype&lt;/a&gt; - Christian de Botton</source>
          <target state="translated">&lt;a href=&quot;https://medium.com/@cdebotton/redux-and-flowtype-69ff1dd09036#.fsrm1amlk&quot;&gt;ReduxとFlowtype&lt;/a&gt; -Christian de Botton</target>
        </trans-unit>
        <trans-unit id="b2bbb899b8c317c50fa7f4bf67ae90e51c42f496" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://nuclide.io&quot;&gt;Nuclide&lt;/a&gt; is a full IDE created by people at Facebook that has support for Flow built-in. It provides a linter, autocomplete and type coverage support, click-to-definition and type description on hover.</source>
          <target state="translated">&lt;a href=&quot;https://nuclide.io&quot;&gt;Nuclide&lt;/a&gt;は、組み込みのFlowをサポートするFacebookの人々によって作成された完全なIDEです。リンター、オートコンプリート、タイプカバレッジサポート、ホバー時のクリックによる定義、タイプの説明を提供します。</target>
        </trans-unit>
        <trans-unit id="9706104248435c91942f7078e78f2cbaa21d2931" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt; can be integrated with Flow by using &lt;a href=&quot;https://packagecontrol.io&quot;&gt;Package Control&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt;は、&lt;a href=&quot;https://packagecontrol.io&quot;&gt;パッケージコントロール&lt;/a&gt;を使用してフローと統合できます。</target>
        </trans-unit>
        <trans-unit id="832311cb20bd2c6c6484e62e8e290372fda23e34" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;tools/babel&quot;&gt; &lt;h3&gt; Babel &lt;/h3&gt; &lt;p&gt; Learn how to use Flow with Babel &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/flow-remove-types&quot;&gt; &lt;h3&gt; flow-remove-types &lt;/h3&gt; &lt;p&gt; Learn how to use Flow with flow-remove-types &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/create-react-app&quot;&gt; &lt;h3&gt; Create React App &lt;/h3&gt; &lt;p&gt; Learn how to use Flow with Create React App &lt;/p&gt; &lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;tools/babel&quot;&gt; &lt;h3&gt; バベル &lt;/h3&gt; &lt;p&gt; FlowをBabelで使用する方法を学ぶ &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/flow-remove-types&quot;&gt; &lt;h3&gt; フロー削除タイプ &lt;/h3&gt; &lt;p&gt; Flow-remove-typesでFlowを使用する方法を学ぶ &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/create-react-app&quot;&gt; &lt;h3&gt; Reactアプリを作成する &lt;/h3&gt; &lt;p&gt; Create React AppでFlowを使用する方法を学ぶ &lt;/p&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d3edbcd8340616b98a8bb730d5f2bfb4883db8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Call&amp;lt;F, T...&amp;gt;&lt;/code&gt; is a type that represents the result of calling the given &lt;a href=&quot;../functions&quot;&gt;function type&lt;/a&gt;&lt;code&gt;F&lt;/code&gt; with 0 or more arguments &lt;code&gt;T...&lt;/code&gt;. This is analogous to calling a function at runtime (or more specifically, it&amp;rsquo;s analogous to calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;code&gt;Function.prototype.call&lt;/code&gt;&lt;/a&gt;), but at the type level; this means that function type calls happens statically, i.e. not at runtime.</source>
          <target state="translated">&lt;code&gt;$Call&amp;lt;F, T...&amp;gt;&lt;/code&gt; は、指定された&lt;a href=&quot;../functions&quot;&gt;関数タイプ&lt;/a&gt; &lt;code&gt;F&lt;/code&gt; を0個以上の引数 &lt;code&gt;T...&lt;/code&gt; で呼び出した結果を表すタイプです。これは、実行時に関数を呼び出すのと似ています（より具体的には、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt; &lt;code&gt;Function.prototype.call&lt;/code&gt; &lt;/a&gt;を呼び出すのと似ています）が、型レベルです。これは、関数タイプの呼び出しが静的に、つまり実行時に行われないことを意味します。</target>
        </trans-unit>
        <trans-unit id="f2241c9b7c945bd4d93f1e03d981bbd35f587e2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Call&lt;/code&gt; can be very powerful because it allows you to make calls in type-land that you would otherwise have to do at runtime. The type-land calls happen statically and will be erased at runtime.</source>
          <target state="translated">&lt;code&gt;$Call&lt;/code&gt; は、タイプランドで実行時に呼び出さなくてはならないため、非常に強力です。タイプランドの呼び出しは静的に行われ、実行時に消去されます。</target>
        </trans-unit>
        <trans-unit id="9c25dd66acf1845fd7317530f17f429c5d475619" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; is the type that represents the type of every element inside an &lt;a href=&quot;../arrays&quot;&gt;array&lt;/a&gt;, &lt;a href=&quot;../tuples&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;../objects&quot;&gt;object&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt;, that matches the given &lt;em&gt;key&lt;/em&gt; type &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; は、&lt;a href=&quot;../arrays&quot;&gt;配列&lt;/a&gt;、&lt;a href=&quot;../tuples&quot;&gt;タプル、&lt;/a&gt;または&lt;a href=&quot;../objects&quot;&gt;オブジェクト&lt;/a&gt;型 &lt;code&gt;T&lt;/code&gt; 内のすべての要素の型を表す型であり、指定された&lt;em&gt;キー&lt;/em&gt;型 &lt;code&gt;K&lt;/code&gt; と一致し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="508e7e8d64ef136cbb4051692a66a33f7f03d8bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Exact&amp;lt;{name: string}&amp;gt;&lt;/code&gt; is a synonym for &lt;code&gt;{|name:string|}&lt;/code&gt; as in the &lt;a href=&quot;../objects#toc-exact-object-types&quot;&gt;Object documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$Exact&amp;lt;{name: string}&amp;gt;&lt;/code&gt; は、&lt;a href=&quot;../objects#toc-exact-object-types&quot;&gt;オブジェクトドキュメントの&lt;/a&gt;ように、 &lt;code&gt;{|name:string|}&lt;/code&gt; 同義語です。</target>
        </trans-unit>
        <trans-unit id="1f560c59c278bbced6c01735997cd392ca4dcce5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; converts a type &lt;code&gt;T&lt;/code&gt; to a non-maybe type. In other words, the values of &lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; are the values of &lt;code&gt;T&lt;/code&gt; except for &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; 型を非多型に変換します。つまり、 &lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; の値は、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; を除いて &lt;code&gt;T&lt;/code&gt; の値です。</target>
        </trans-unit>
        <trans-unit id="af15b84204f891abb40fd24979cfba73a49edad8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; is a type that represents the read-only version of a given &lt;a href=&quot;../objects&quot;&gt;object type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;. A read-only object type is an object type whose keys are all &lt;a href=&quot;../interfaces#toc-interface-property-variance-read-only-and-write-only&quot;&gt;read-only&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; は、特定の&lt;a href=&quot;../objects&quot;&gt;オブジェクト型&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; の読み取り専用バージョンを表す型です。読み取り専用オブジェクトタイプは、キーがすべて&lt;a href=&quot;../interfaces#toc-interface-property-variance-read-only-and-write-only&quot;&gt;読み取り&lt;/a&gt;専用のオブジェクトタイプです。</target>
        </trans-unit>
        <trans-unit id="98b234ef2ba7237b91129403279d8a12d8b8a498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; is the type that represents the runtime object rest operation, e.g.: &lt;code&gt;const {foo, ...rest} = obj&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are both &lt;a href=&quot;../objects&quot;&gt;object types&lt;/a&gt;. The resulting type from this operation will be an object type containing &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s &lt;em&gt;own&lt;/em&gt; properties that are not &lt;em&gt;own&lt;/em&gt; properties in &lt;code&gt;B&lt;/code&gt;. In flow, we treat all properties on &lt;a href=&quot;(../objects#toc-exact-object-types)&quot;&gt;exact object types&lt;/a&gt; as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;own&lt;/a&gt;. In in-exact objects, a property may or may not be own.</source>
          <target state="translated">&lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; は、ランタイムオブジェクトレスト操作を表すタイプです。例： &lt;code&gt;const {foo, ...rest} = obj&lt;/code&gt; 。ここで、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; はどちらも&lt;a href=&quot;../objects&quot;&gt;オブジェクトタイプ&lt;/a&gt;です。この操作から得られた型が含まれているオブジェクトのタイプとなり &lt;code&gt;A&lt;/code&gt; さん&lt;em&gt;自身の&lt;/em&gt;ないプロパティ&lt;em&gt;自身&lt;/em&gt;のプロパティ &lt;code&gt;B&lt;/code&gt; を。フローでは、&lt;a href=&quot;(../objects#toc-exact-object-types)&quot;&gt;正確なオブジェクトタイプの&lt;/a&gt;すべてのプロパティを&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;独自のもの&lt;/a&gt;として扱います。完全一致オブジェクトでは、プロパティは所有されている場合とされていない場合があります。</target>
        </trans-unit>
        <trans-unit id="d802f2267a06e1a2022c679c8bde31819cb03ed1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$TupleMap&amp;lt;T, F&amp;gt;&lt;/code&gt; takes an iterable type &lt;code&gt;T&lt;/code&gt; (e.g.: &lt;a href=&quot;../tuples&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;), and a &lt;a href=&quot;../functions&quot;&gt;function type&lt;/a&gt;&lt;code&gt;F&lt;/code&gt;, and returns the iterable type obtained by mapping the type of each value in the iterable with the provided function type &lt;code&gt;F&lt;/code&gt;. This is analogous to the Javascript function &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$TupleMap&amp;lt;T, F&amp;gt;&lt;/code&gt; は、反復可能型 &lt;code&gt;T&lt;/code&gt; （例：&lt;a href=&quot;../tuples&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../arrays&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;）と&lt;a href=&quot;../functions&quot;&gt;関数型&lt;/a&gt; &lt;code&gt;F&lt;/code&gt; を取り、反復可能型の各値の型を提供された関数型 &lt;code&gt;F&lt;/code&gt; にマッピングすることにより取得した反復可能型を返します。これはJavaScript関数 &lt;code&gt;map&lt;/code&gt; 似ています。</target>
        </trans-unit>
        <trans-unit id="1f76db9419791028b16c53d50170a640dded7f72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Values&amp;lt;T&amp;gt;&lt;/code&gt; represents the union type of all the value types (not the values, but their &lt;em&gt;types&lt;/em&gt;!) of the enumerable properties in an &lt;a href=&quot;../objects&quot;&gt;Object Type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$Values&amp;lt;T&amp;gt;&lt;/code&gt; は、&lt;a href=&quot;../objects&quot;&gt;オブジェクトタイプ&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; の列挙可能なプロパティのすべての値タイプ（値ではなく、その&lt;em&gt;タイプ&lt;/em&gt;！）の共用体タイプを表します。</target>
        </trans-unit>
        <trans-unit id="2594799d46ec0811bd7e6e9354b8cae3d1f1d6a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.flowconfig&lt;/code&gt; format</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 形式</target>
        </trans-unit>
        <trans-unit id="2f61adc534681a552a76146f3a893058257fd34c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/path/to/root/&lt;/code&gt; (automatically included)</source>
          <target state="translated">&lt;code&gt;/path/to/root/&lt;/code&gt; （自動的に含まれる）</target>
        </trans-unit>
        <trans-unit id="4eb684af2fc8a1193252507702d321d75c5eef22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@flow strict-local&lt;/code&gt; is the same as &lt;code&gt;@flow strict&lt;/code&gt;, except it does not require its dependencies to also be strict (i.e. it is &amp;ldquo;locally&amp;rdquo; strict). It does not have a separate configuration: it uses the same configuration as Flow Strict, just without the &lt;code&gt;nonstrict-import&lt;/code&gt; rule.</source>
          <target state="translated">&lt;code&gt;@flow strict-local&lt;/code&gt; は、依存関係も厳密である必要がないことを除いて、 &lt;code&gt;@flow strict&lt;/code&gt; と同じです（つまり、「ローカル」に厳密です）。個別の構成はありません。非厳密 &lt;code&gt;nonstrict-import&lt;/code&gt; ルールを除いて、Flow Strictと同じ構成を使用します。</target>
        </trans-unit>
        <trans-unit id="8f9cde7197917421c3115f9339175348c4255a20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array&lt;/code&gt; Type</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="a803aafb511370111befd33436b887e6bb708e91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array&lt;/code&gt; Type Shorthand Syntax</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 型の省略構文</target>
        </trans-unit>
        <trans-unit id="3331a137b8616e6d3a4d9711f6d95d677a4a97c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Function&lt;/code&gt; Type</source>
          <target state="translated">&lt;code&gt;Function&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="2cbf7e5430db7626ac9af791d16644934975cb21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; takes an &lt;a href=&quot;../objects&quot;&gt;object type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;, and a &lt;a href=&quot;../functions&quot;&gt;function type&lt;/a&gt;&lt;code&gt;F&lt;/code&gt;, and returns the object type obtained by mapping the type of each value in the object with the provided function type &lt;code&gt;F&lt;/code&gt;. In other words, &lt;code&gt;$ObjMap&lt;/code&gt; will &lt;a href=&quot;#toc-call&quot;&gt;call&lt;/a&gt; (at the type level) the given function type &lt;code&gt;F&lt;/code&gt; for every property value type in &lt;code&gt;T&lt;/code&gt;, and return the resulting object type from those calls.</source>
          <target state="translated">&lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; は、&lt;a href=&quot;../objects&quot;&gt;オブジェクト型&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; と&lt;a href=&quot;../functions&quot;&gt;関数型&lt;/a&gt; &lt;code&gt;F&lt;/code&gt; を取り、オブジェクト内の各値の型を提供された関数型 &lt;code&gt;F&lt;/code&gt; にマッピングすることにより取得したオブジェクト型を返します。換言すれば、 &lt;code&gt;$ObjMap&lt;/code&gt; あろう&lt;a href=&quot;#toc-call&quot;&gt;呼び出し&lt;/a&gt;与えられた関数型（タイプレベル） &lt;code&gt;F&lt;/code&gt; 内のすべてのプロパティ値タイプの &lt;code&gt;T&lt;/code&gt; 、及びそれらの呼び出しに起因するオブジェクトの型を返します。</target>
        </trans-unit>
        <trans-unit id="681cf2b1552373c6dcf1f86ee33a93ff337de143" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ObjMapi&amp;lt;T, F&amp;gt;&lt;/code&gt; is similar to &lt;a href=&quot;#toc-objmap&quot;&gt;&lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt;&lt;/a&gt;. The difference is that function type &lt;code&gt;F&lt;/code&gt; will be &lt;a href=&quot;#toc-call&quot;&gt;called&lt;/a&gt; with both the key and value types of the elements of the object type &lt;code&gt;T&lt;/code&gt;, instead of just the value types. For example:</source>
          <target state="translated">&lt;code&gt;ObjMapi&amp;lt;T, F&amp;gt;&lt;/code&gt; に似て&lt;a href=&quot;#toc-objmap&quot;&gt; &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; &lt;/a&gt;。違いは、関数型 &lt;code&gt;F&lt;/code&gt; は、値型だけでなく、オブジェクト型 &lt;code&gt;T&lt;/code&gt; の要素のキー型と値型の両方で&lt;a href=&quot;#toc-call&quot;&gt;呼び出される&lt;/a&gt;ことです。例えば：</target>
        </trans-unit>
        <trans-unit id="767b77f7a41bfeed131973627af17f7e6faa58cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object&lt;/code&gt; Type</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="1544818dc3132ba28560d73844cabcd76ae68cc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.AbstractComponent&amp;lt;Config, Instance&amp;gt;&lt;/code&gt; (v0.89.0+) represents a component with a config of type Config and instance of type Instance.</source>
          <target state="translated">&lt;code&gt;React.AbstractComponent&amp;lt;Config, Instance&amp;gt;&lt;/code&gt; （v0.89.0 +）は、タイプConfigの構成とタイプInstanceのインスタンスを持つコンポーネントを表します。</target>
        </trans-unit>
        <trans-unit id="7a05b510244008460c777eeffe9a1d99b0b3f433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Component&amp;lt;Props, State&amp;gt;&lt;/code&gt; is a &lt;a href=&quot;https://flow.org/en/types/generics/&quot;&gt;generic type&lt;/a&gt; that takes two type arguments. Props and state. The second type argument, &lt;code&gt;State&lt;/code&gt;, is optional. By default it is undefined so you can see in the example above we did not include &lt;code&gt;State&lt;/code&gt;. We will learn more about state in the next section&amp;hellip;</source>
          <target state="translated">&lt;code&gt;React.Component&amp;lt;Props, State&amp;gt;&lt;/code&gt; は、2つの型引数を取る&lt;a href=&quot;https://flow.org/en/types/generics/&quot;&gt;ジェネリック型&lt;/a&gt;です。小道具と状態。2番目の型引数 &lt;code&gt;State&lt;/code&gt; はオプションです。デフォルトでは未定義なので、上記の例で &lt;code&gt;State&lt;/code&gt; が含まれていないことがわかります。次のセクションで状態について詳しく学びます&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9230540e79b96189b0ea859004424e54a1e6f63f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; does not include intrinsic JSX element types like &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt;. See &lt;a href=&quot;#toc-react-elementtype&quot;&gt;&lt;code&gt;React.ElementType&lt;/code&gt;&lt;/a&gt; if you also want to include JSX intrinsics.</source>
          <target state="translated">&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; は、 &lt;code&gt;div&lt;/code&gt; や &lt;code&gt;span&lt;/code&gt; などの組み込みのJSX要素タイプは含まれません。JSX組み込み関数も含めたい場合は、&lt;a href=&quot;#toc-react-elementtype&quot;&gt; &lt;code&gt;React.ElementType&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="58f1f75b8bcd9618953c69318f7620eb7b4295c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; is also the return type of &lt;code&gt;React.createElement()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; は、 &lt;code&gt;React.createElement()&lt;/code&gt; の戻り型でもあります。</target>
        </trans-unit>
        <trans-unit id="adc63cd1289ababfe9d45f2979b42f2a3e435bb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticAnimationEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent&quot;&gt;AnimationEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticAnimationEvent&amp;lt;T&amp;gt;&lt;/code&gt; （&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent&quot;&gt;AnimationEvent）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c5e5304c53ff7a14b0db24ef11da3dbb99b2b14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticCompositionEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent&quot;&gt;CompositionEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticCompositionEvent&amp;lt;T&amp;gt;&lt;/code&gt; のための&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent&quot;&gt;CompositionEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c96f9ac107f248ffac9f8626b279676bd8718958" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticDragEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DragEvent&quot;&gt;DragEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticDragEvent&amp;lt;T&amp;gt;&lt;/code&gt; のための&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DragEvent&quot;&gt;DragEventです&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa52bea770e564d49631a007def85a111217c029" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt;Event&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; のための&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt;イベント&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96c79f952aac07c545dc47e57d9d9cd7d49c791f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticFocusEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent&quot;&gt;FocusEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticFocusEvent&amp;lt;T&amp;gt;&lt;/code&gt; のため&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent&quot;&gt;のFocusEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5996e654c7c893a828a52a8b60b3799f8e789a81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticInputEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/InputEvent&quot;&gt;InputEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticInputEvent&amp;lt;T&amp;gt;&lt;/code&gt; のため&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/InputEvent&quot;&gt;のInputEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2026e5307092d1d6c43fff4a1ac451cb1d8596f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent&quot;&gt;KeyboardEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt; （&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent&quot;&gt;KeyboardEvent）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4fc35b5921c09e6284b8b4d64655b2075c7403d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt; のため&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;のMouseEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8f969c201611aa63546668fd0d4a5fb4be56f6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent&quot;&gt;TouchEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt; （&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent&quot;&gt;TouchEvent）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5392d56e034e56ed7cf9f986f6a8e54736cf46cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticTransitionEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent&quot;&gt;TransitionEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticTransitionEvent&amp;lt;T&amp;gt;&lt;/code&gt; のための&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent&quot;&gt;TransitionEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="693da3b475fb277ea5f089a6fe5960e4093a8bf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticUIEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticUIEvent&amp;lt;T&amp;gt;&lt;/code&gt; のため&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;たUIEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75c836ef8f10b19801a470eac5c6ed743d951e99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticWheelEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent&quot;&gt;WheelEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticWheelEvent&amp;lt;T&amp;gt;&lt;/code&gt; のための&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent&quot;&gt;WheelEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd8d3fb84c2e2653143777ce2230d40aeb161b2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[untyped]&lt;/code&gt; instead causes a file to be ignored by the typechecker as if it had &lt;code&gt;noflow&lt;/code&gt; in it, resolve modules as &lt;code&gt;any&lt;/code&gt; typ, but allow them to NOT be ignored by the module resolver. Any matching file is skipped by Flow (not even parsed, like other &lt;code&gt;noflow&lt;/code&gt; files!), but can still be &lt;code&gt;require()&lt;/code&gt;&amp;lsquo;d.</source>
          <target state="translated">&lt;code&gt;[untyped]&lt;/code&gt; 代わりに[untyped]を指定すると、ファイルは &lt;code&gt;noflow&lt;/code&gt; を持っているかのようにタイプチェッカーによって無視され、モジュールは &lt;code&gt;any&lt;/code&gt; typ として解決されますが、モジュールリゾルバーによって無視されないようにします。任意の一致するファイルは、フロー（さらには他と同様に、解析されないことによってスキップされ &lt;code&gt;noflow&lt;/code&gt; の！ファイル）、まだすることができます &lt;code&gt;require()&lt;/code&gt; D」。</target>
        </trans-unit>
        <trans-unit id="a4734a96ab71cb9256e40d7ef655d0b7aec2769d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9980c61e3e10b0171dab78805e509842f78d6bfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;babel_loose_array_spread&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;babel_loose_array_spread&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9328c95d646b4ac7120c78217d7dabde5057c2d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; - declares a block-scoped variable, assigning a value that cannot be re-assigned. (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const&quot;&gt;MDN&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; -ブロックスコープの変数を宣言し、再割り当てできない値を割り当てます。（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const&quot;&gt;MDN&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="c35bdf03258530159bd15512b8348c3d41d5a19d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; - variables that &lt;strong&gt;cannot&lt;/strong&gt; be reassigned.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; -再割り当て&lt;strong&gt;できない&lt;/strong&gt;変数。</target>
        </trans-unit>
        <trans-unit id="ec86decd5f7af51264833626096e4ddd7664c147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;emoji&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;emoji&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96920174b4323d8c30fdb2a3ec074673a3d14b1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.class_instance_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.class_instance_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="171137be6be377f3d07f41d4691b38066b388d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.class_static_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.class_static_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9f45cd53162169474b7a6388eccd7f001dfae9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.decorators&lt;/code&gt;&lt;em&gt;&lt;code&gt;(ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.decorators&lt;/code&gt;&lt;em&gt;&lt;code&gt;(ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="972a4a3dbe0f7550710ef309f72472fb16297ecb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.export_star_as&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.export_star_as&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="638056fd7e6c68417a3a146dfca7047b22c08d8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.nullish_coalescing&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.nullish_coalescing&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e869212f0b8e102de1941c727fdebe6d2a890181" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.optional_chaining&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.optional_chaining&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93d7450678ff784f4a91b7939b3f1d2d0f196f78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exact_by_default&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;exact_by_default&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f0b3658b2908fca30f69af8b284b05c29e2e0d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;experimental.const_params&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;experimental.const_params&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42e3942bab511fa03988ce07bb75a9d0d7c74847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f1&lt;/code&gt; can return a value that &lt;code&gt;FuncType&lt;/code&gt; never does, so code that relies on &lt;code&gt;FuncType&lt;/code&gt; might not be safe if &lt;code&gt;f1&lt;/code&gt; is used. Its type is not a subtype of &lt;code&gt;FuncType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f1&lt;/code&gt; は &lt;code&gt;FuncType&lt;/code&gt; が決してしない値を &lt;code&gt;FuncType&lt;/code&gt; 可能性があるため、 &lt;code&gt;f1&lt;/code&gt; を使用する場合、FuncTypeに依存するコードは安全ではない可能性があります。そのタイプはのサブタイプではありません &lt;code&gt;FuncType&lt;/code&gt; の。</target>
        </trans-unit>
        <trans-unit id="726638e0c45c973078425c1f460e13663c6df9ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f2&lt;/code&gt; can&amp;rsquo;t handle all the argument values that &lt;code&gt;FuncType&lt;/code&gt; does, so code that relies on &lt;code&gt;FuncType&lt;/code&gt; can&amp;rsquo;t safely use &lt;code&gt;f2&lt;/code&gt;. Its type is also not a subtype of &lt;code&gt;FuncType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f2&lt;/code&gt; は &lt;code&gt;FuncType&lt;/code&gt; が行うすべての引数値を処理できないため、 &lt;code&gt;FuncType&lt;/code&gt; に依存するコードは安全に使用できません &lt;code&gt;f2&lt;/code&gt; を。その型も &lt;code&gt;FuncType&lt;/code&gt; のサブタイプではありません。</target>
        </trans-unit>
        <trans-unit id="5400ddcebeeba38d292672ea4e21ae521f4c3c92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f3&lt;/code&gt; can accept all the argument values that &lt;code&gt;FuncType&lt;/code&gt; does, and only returns values that &lt;code&gt;FuncType&lt;/code&gt; does, so its type is a subtype of &lt;code&gt;FuncType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f3&lt;/code&gt; は、 &lt;code&gt;FuncType&lt;/code&gt; が使用するすべての引数値を受け入れることができます。は、が行う、 &lt;code&gt;FuncType&lt;/code&gt; は、そのタイプがのサブタイプであるので、ありません &lt;code&gt;FuncType&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="0aae29a82fc10cee61f896dcf30eeebb3766c146" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flowlint-next-line&lt;/code&gt; works the same as &lt;code&gt;flowlint-line&lt;/code&gt;, except it applies its settings to the next line instead of the current line:</source>
          <target state="translated">&lt;code&gt;flowlint-next-line&lt;/code&gt; は、設定を現在の行ではなく次の行に適用することを除いて、 &lt;code&gt;flowlint-line&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="a48e34cc7b299416a8e2b7ea16e6d555b35b2019" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include_warnings&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;include_warnings&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d8ddac7ae75b7a8f7db9fd921f2cf55bd4b2c66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lazy_mode&lt;/code&gt;&lt;em&gt;&lt;code&gt;(fs|ide|watchman|none)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;lazy_mode&lt;/code&gt;&lt;em&gt;&lt;code&gt;(fs|ide|watchman|none)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="336c7ba3afe701528a0e2b671be4925b95c96b3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; - declares a block-scoped variable, optionally assigning a value. (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; -必要に応じて値を割り当て、ブロックスコープ変数を宣言する。（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="447b3a2dddaad4f848e312d7d33f3c96c59892d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; - variables that &lt;strong&gt;can&lt;/strong&gt; be reassigned.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; と &lt;code&gt;var&lt;/code&gt; 再割り当て&lt;strong&gt;可能な&lt;/strong&gt;変数。</target>
        </trans-unit>
        <trans-unit id="da67888b6c142ef501bff7964e43c869c753300c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log.file&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;log.file&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10b72cfa901df08cc8fe7be85a5ce76b92d3830e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_header_tokens&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;max_header_tokens&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7127e551c98174c6634c2da74d89fefc7432f7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixed&lt;/code&gt; will accept any type of value. Strings, numbers, objects, functions&amp;ndash; anything will work.</source>
          <target state="translated">&lt;code&gt;mixed&lt;/code&gt; は、あらゆるタイプの値を受け入れます。文字列、数値、オブジェクト、関数&amp;ndash;何でも機能します。</target>
        </trans-unit>
        <trans-unit id="51164f8b8016f0d8abcae69123c2523293287daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.file_ext&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.file_ext&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8bd5bc2f73b98906fb7419179328c69ef4d9e356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.ignore_non_literal_requires&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.ignore_non_literal_requires&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fa5897539c2a2f8f6f118e08172c4bc433245c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.name_mapper.extension&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string -&amp;gt; string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.name_mapper.extension&lt;/code&gt; &lt;em&gt; &lt;code&gt;(string -&amp;gt; string)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="695be517c6a87b361f0a94a84ee335146ea99233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.name_mapper&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex -&amp;gt; string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.name_mapper&lt;/code&gt; &lt;em&gt; &lt;code&gt;(regex -&amp;gt; string)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f6d453a4f39af3bbcc8e866a62bb026e067f3ccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.system.node.main_field&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.system.node.main_field&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2b55b3985b54cfcb20f350998122314d8f82eca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3917f0b66e443088994451f0883b66faaf5a2a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.system&lt;/code&gt;&lt;em&gt;&lt;code&gt;(node|haste)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.system&lt;/code&gt;&lt;em&gt;&lt;code&gt;(node|haste)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac108e4226f0003b79c994c5e9872aae99cf04e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.use_strict&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.use_strict&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3c7cf33182d09b184a1acd84332f6a07f1a0cdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;munge_underscores&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;munge_underscores&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ee2c2db77365d69cc88bb148e9b038199c9e52b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no_flowlib&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;no_flowlib&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aec71172404443d710062cd2dbcdb5a433b974cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; および &lt;code&gt;void&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59ea58ab1aea5c130c466795049be1f9aaf0803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; also appear in other types.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; および &lt;code&gt;void&lt;/code&gt; は、他の型にも現れます。</target>
        </trans-unit>
        <trans-unit id="e8c9111ee40b4a3593b8970efac417f8ac70f84d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-router&lt;/code&gt; version 4 asks for a &lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt;function as the children to its &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; component&lt;/a&gt;. You would provide a function as the children to &lt;code&gt;react-router&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;react-router&lt;/code&gt; バージョン4は、&lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt;その &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; コンポーネントの子として機能を&lt;/a&gt;要求します。あなたは子供たちに機能を提供するでしょう &lt;code&gt;react-router&lt;/code&gt; ように react-routerの。</target>
        </trans-unit>
        <trans-unit id="0094d54f0f90d0220f6da062cdc9c6ae6eae5fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server.max_workers&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;server.max_workers&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f189fba493378458484495c789f0c1fe55185671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.dirs&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.dirs&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57b914d6e4aade39e538cecd6f22441853012d68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.hash_table_pow&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.hash_table_pow&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e5bb5de55179a3c1994c86e08d6ba8959cf26035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.heap_size&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.heap_size&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb32a4afd21311d7f593b3de1374f83ef370676" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.log_level&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.log_level&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5afdf22d252e5f159714f331f56a1183c8db4629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.minimum_available&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.minimum_available&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6af14e5c0d4307ffde1e14ef7590be5942e679aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strip_root&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;&amp;le;0.48</source>
          <target state="translated">&lt;code&gt;strip_root&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;&amp;le;0.48</target>
        </trans-unit>
        <trans-unit id="b7056b5cc505c600e004961cb933f9821121eb2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress_comment&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;suppress_comment&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72b91edcfd78ab9e6e183d55d0e45a396ff7018c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress_type&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;suppress_type&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8ad04f97245289d4e39fc158bdfbcdf56d0bf99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;temp_dir&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;temp_dir&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0eca817f39a368fc9aa5bd8f12866ffd32eaa21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;traces&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;traces&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c75e6afcf9d83a43fbddc117b5707c6525bca25f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof Component&lt;/code&gt; can also be your React class component or stateless functional component.</source>
          <target state="translated">&lt;code&gt;typeof Component&lt;/code&gt; は、Reactクラスコンポーネントまたはステートレス機能コンポーネントにもなります。</target>
        </trans-unit>
        <trans-unit id="e11876a8dc567e2d922f662f5f89f99f143a6ebc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; inherits behaviors of inference</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; は推論の振る舞いを継承します</target>
        </trans-unit>
        <trans-unit id="eb1cf1f4297c1b2ae089f4080f05438696aa41b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; inherits behaviors of other types</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; は他のタイプの動作を継承します</target>
        </trans-unit>
        <trans-unit id="8bc3bf8b12c02f9c49ba612a2afbc618a8714ac2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; type syntax</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; type構文</target>
        </trans-unit>
        <trans-unit id="e9340dc40167bf2df1900dd5ff09de7ee451b582" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; (&lt;code&gt;void&lt;/code&gt; in Flow types)</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; （フロータイプでは &lt;code&gt;void&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e10bde5813a41a4b1af5888a4a46a6bbc121f9a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; - declares a variable, optionally assigning a value. (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&quot;&gt;MDN&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; -変数を宣言し、オプションで値を割り当てます。（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&quot;&gt;MDN&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="3849f1997a58ce69bfb01dd3b43d461870cc5bea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; と &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="618a581b65ff5f5e5889511d3cd080ab05886f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;exports.js&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;exports.js&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b33f07a5ba2608771292c96cae619e974a5fb21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;imports.js&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;imports.js&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2656931fc434aca0157a011d0d37c9e6f677adfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Classes&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Classes&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f4be936250abf866d7156093839a04de7c1cd2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Don&amp;rsquo;t forget to mention &lt;code&gt;@flow&lt;/code&gt; on top of file, otherwise flow won&amp;rsquo;t report errors&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;ファイルの先頭に &lt;code&gt;@flow&lt;/code&gt; を含めることを忘れないでください&lt;/em&gt;&lt;/strong&gt;。&lt;strong&gt;&lt;em&gt;そうしないと、flowはエラーを報告しません&lt;/em&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="4284c426f28b28ecfd869ea4f96a80f7f8690134" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Interfaces&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Interfaces&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f17253c245d87ac973fc5293b5a15ab24ab8bdc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Type Aliases&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;タイプエイリアス&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cbe8982c76a4cc7f7e9adfc12449f681674cbb61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;You should follow &lt;a href=&quot;../any&quot;&gt;all the same rules&lt;/a&gt; as &lt;code&gt;any&lt;/code&gt; when using &lt;code&gt;Function&lt;/code&gt;.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;あなたは従うべき&lt;a href=&quot;../any&quot;&gt;すべて同じルール&lt;/a&gt;として、 &lt;code&gt;any&lt;/code&gt; 使用して &lt;code&gt;Function&lt;/code&gt; 。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2811438566c8ce65b8a6941e70fbece78eceaa1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A group of different possible types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;可能なタイプのグループ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae678a78ebebf05c595f0cdf9e9e80e85d991358" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A single type:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;単一のタイプ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e53a0237f152f0b316bc97b2fc063f3efa825e84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A type based on another type:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;別のタイプに基づくタイプ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d99a25c652d8cfb74b77ae022021f7dccc449527" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An arbitrary type that could be anything:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;何でもよい任意のタイプ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="17486ec505dad1463a8b0dc8465986bb70f1e04b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency files&lt;/strong&gt;. These are the files which are needed in order to typecheck the focused or dependent files.</source>
          <target state="translated">&lt;strong&gt;依存ファイル&lt;/strong&gt;。これらは、フォーカスされたファイルまたは依存ファイルをタイプチェックするために必要なファイルです。</target>
        </trans-unit>
        <trans-unit id="348b0bbf82732cfba30377f2a246a2d29c935065" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependent files&lt;/strong&gt;. These are the files which depend on the focused files. Changes to the focused files might cause type errors in the dependent files.</source>
          <target state="translated">&lt;strong&gt;依存ファイル&lt;/strong&gt;。これらは、フォーカスされたファイルに依存するファイルです。フォーカスされたファイルを変更すると、依存ファイルでタイプエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2881ee068ac6090c9feffed65593bbb03cba2056" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Filesystem lazy mode&lt;/strong&gt;. Flow treats any file which has changed on the filesystem as focused. This mode is easier to use from the commandline, but a rebase can make every file appear focused.</source>
          <target state="translated">&lt;strong&gt;ファイルシステム遅延モード&lt;/strong&gt;。フローは、ファイルシステムで変更されたファイルをフォーカスされたものとして扱います。このモードはコマンドラインから使用する方が簡単ですが、リベースを使用すると、すべてのファイルに焦点を当てることができます。</target>
        </trans-unit>
        <trans-unit id="4d1871c2ba972fbc1e0adeb69045b60c7b76dcb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Focused files&lt;/strong&gt;. These are the files which the user cares about.</source>
          <target state="translated">&lt;strong&gt;集中ファイル&lt;/strong&gt;。これらは、ユーザーが気にするファイルです。</target>
        </trans-unit>
        <trans-unit id="4c72412e2b545e519f06a9eb3fbf56d6fbd15299" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IDE lazy mode&lt;/strong&gt;. The IDE tells Flow which files have been opened and closed via &lt;code&gt;flow lsp&lt;/code&gt;. Flow treats any file which has ever been opened since the Flow server started as focused.</source>
          <target state="translated">&lt;strong&gt;IDE遅延モード&lt;/strong&gt;。IDEは、 &lt;code&gt;flow lsp&lt;/code&gt; を介して開いたファイルと閉じたファイルをFlowに通知します。フローは、フローサーバーの起動以降に開かれたすべてのファイルをフォーカスされたものとして扱います。</target>
        </trans-unit>
        <trans-unit id="4a2bb6782e12dafbea5a42ed08ba22dd8335a4a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Arrays are also sometimes used as tuples in JavaScript, these are annotated differently in Flow. See the Tuple docs for more information.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;配列はJavaScriptでタプルとして使用されることもあります。これらはFlowでは異なる注釈が付けられます。詳細については、タプルのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d0c839a0690df63ac56fe1bed5a7b464ba8c43db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Because &lt;a href=&quot;#toc-react-elementprops&quot;&gt;&lt;code&gt;React.ElementProps&lt;/code&gt;&lt;/a&gt; does not preserve the optionality of &lt;code&gt;defaultProps&lt;/code&gt;, &lt;a href=&quot;#toc-react-elementconfig&quot;&gt;&lt;code&gt;React.ElementConfig&lt;/code&gt;&lt;/a&gt; (which does) is more often the right choice, especially for simple props pass-through as with &lt;a href=&quot;../hoc#toc-supporting-defaultprops-with-react-elementconfig&quot;&gt;higher-order components&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;ので&lt;a href=&quot;#toc-react-elementprops&quot;&gt; &lt;code&gt;React.ElementProps&lt;/code&gt; は&lt;/a&gt;のオプ保存しない &lt;code&gt;defaultProps&lt;/code&gt; を、&lt;a href=&quot;#toc-react-elementconfig&quot;&gt; &lt;code&gt;React.ElementConfig&lt;/code&gt; &lt;/a&gt;（い）簡単な小道具がパススルー特に用と同様に、より頻繁に正しい選択である&lt;a href=&quot;../hoc#toc-supporting-defaultprops-with-react-elementconfig&quot;&gt;高次成分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fab5833ac1b21ea7a10d50df5d9bc2a182d5de9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you don&amp;rsquo;t need to use the &lt;code&gt;Props&lt;/code&gt; type again you could also define it inline: &lt;code&gt;extends React.Component&amp;lt;{ foo: number, bar?: string }&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;Props&lt;/code&gt; タイプを再度使用する必要がない場合は、インラインで定義することもできます： &lt;code&gt;extends React.Component&amp;lt;{ foo: number, bar?: string }&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d95a1829d723b06d07fce08d5fc4c83da0c5b2f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you don&amp;rsquo;t need to use the &lt;code&gt;State&lt;/code&gt; type again you could also define it inline: &lt;code&gt;extends React.Component&amp;lt;{}, { count: number }&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;State&lt;/code&gt; タイプを再度使用する必要がない場合は、インラインで定義することもできます： &lt;code&gt;extends React.Component&amp;lt;{}, { count: number }&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45fe059278697f2928479023e38c3ab10a142464" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want methods like &lt;code&gt;map()&lt;/code&gt; and &lt;code&gt;forEach()&lt;/code&gt; or to handle a &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as a normal JavaScript array then React provides the &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children&quot;&gt;&lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt; to do just this. It has functions like &lt;code&gt;React.Children.toArray(props.children)&lt;/code&gt; that you can use to treat your &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as a flat array.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;map()&lt;/code&gt; や &lt;code&gt;forEach()&lt;/code&gt; などのメソッドが必要な場合、または&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;を通常のJavaScript配列として処理する場合、Reactはこれを行うための&lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children&quot;&gt; &lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt;を提供します。&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;処理に使用できる &lt;code&gt;React.Children.toArray(props.children)&lt;/code&gt; のような関数があります。をフラット配列として。</target>
        </trans-unit>
        <trans-unit id="981e303e077480a1b13e37cfcb658e9d478c6764" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want to use optional function parameters you&amp;rsquo;ll need to use the include comment form.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;オプションの関数パラメーターを使用する場合は、コメントを含めるフォームを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7d43ad66341153296b7a88ebc68288f393965e36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In 0.89.0+, React.ComponentType</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; 0.89.0以降では、React.ComponentType</target>
        </trans-unit>
        <trans-unit id="7417850e8b9171bcdaf44485d8c88475bdf0d461" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Previously object types used semicolons &lt;code&gt;;&lt;/code&gt; for splitting name-value pairs. While the syntax is still valid, you should use commas &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;以前のオブジェクトタイプではセミコロンが使用されていました &lt;code&gt;;&lt;/code&gt; 名前と値のペアを分割するため。構文がまだ有効である間は、カンマを使用する必要があり &lt;code&gt;,&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87767fc2be8bc1d1db6ace0faafec6c1caffc4b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; React uses its own event system so it is important to use the &lt;code&gt;SyntheticEvent&lt;/code&gt; types instead of the DOM types such as &lt;code&gt;Event&lt;/code&gt;, &lt;code&gt;KeyboardEvent&lt;/code&gt;, and &lt;code&gt;MouseEvent&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; Reactは独自のイベントシステムを使用するため、 &lt;code&gt;Event&lt;/code&gt; 、 &lt;code&gt;KeyboardEvent&lt;/code&gt; 、 &lt;code&gt;MouseEvent&lt;/code&gt; などのDOMタイプの代わりに &lt;code&gt;SyntheticEvent&lt;/code&gt; タイプを使用することが重要です。</target>
        </trans-unit>
        <trans-unit id="8f2bf27d4821a0d74e94cf2b6f04fa28b458b80e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;*variantOf&lt;/code&gt; types below are not a part of Flow, they are being used to explain variance.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;以下の &lt;code&gt;*variantOf&lt;/code&gt; タイプはフローの一部ではなく、分散を説明するために使用されています。</target>
        </trans-unit>
        <trans-unit id="102f82e83d1493ee86dfa63526c074eb08db5191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The parentheses are necessary to avoid ambiguity with other syntax.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;括弧は、他の構文とのあいまいさを避けるために必要です。</target>
        </trans-unit>
        <trans-unit id="7f324099a923e249d53f34a12f3516e9e72c0142" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is because of &lt;a href=&quot;https://flow.org/en/lang/width-subtyping/&quot;&gt;&amp;ldquo;width subtyping&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;これは&lt;a href=&quot;https://flow.org/en/lang/width-subtyping/&quot;&gt;「幅のサブタイプ」の&lt;/a&gt;ためです。</target>
        </trans-unit>
        <trans-unit id="50be581c452b3e6bead6ab798ba2bb803100f906" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is just shorthand for &lt;code&gt;module.name_mapper='^\(.*\)\.EXTENSION$' -&amp;gt; 'TEMPLATE'&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;これは &lt;code&gt;module.name_mapper='^\(.*\)\.EXTENSION$' -&amp;gt; 'TEMPLATE'&lt;/code&gt; 省略形です）</target>
        </trans-unit>
        <trans-unit id="beb96f00dcbfc7e17127978d7b2257796cddaa5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is not the proper solution to the above problem, it was being used for demonstration only. The correct solution is annotating the function like this:</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;これは上記の問題に対する適切な解決策ではなく、デモンストレーションのみに使用されていました。正しい解決策は、次のように関数に注釈を付けることです。</target>
        </trans-unit>
        <trans-unit id="eaf59b7f203d1ba63f5e98b4e246170ccb103da4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; To get the element instance, like &lt;code&gt;HTMLButtonElement&lt;/code&gt; in the example above, it is a common mistake to use &lt;code&gt;event.target&lt;/code&gt; instead of &lt;code&gt;event.currentTarget&lt;/code&gt;. The reason why you want to use &lt;code&gt;event.currentTarget&lt;/code&gt; is that &lt;code&gt;event.target&lt;/code&gt; may be the wrong element due to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation&quot;&gt;event propagation&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;上の例の &lt;code&gt;HTMLButtonElement&lt;/code&gt; のように要素インスタンスを取得する場合、 &lt;code&gt;event.target&lt;/code&gt; ではなくevent.targetを使用するのはよくある間違い &lt;code&gt;event.currentTarget&lt;/code&gt; 。 &lt;code&gt;event.currentTarget&lt;/code&gt; を使用する理由は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation&quot;&gt;イベントの伝播が&lt;/a&gt;原因で &lt;code&gt;event.target&lt;/code&gt; が誤った要素になる可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="51bb4c125cd4418ed706f35e265efaf1c78dea88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Typing context values requires Flow 0.70 or later.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;コンテキスト値を入力するには、フロー0.70以降が必要です。</target>
        </trans-unit>
        <trans-unit id="0963a4d340e3fcd46ba3fd94010ce7b45a5555b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Watch out for comments! Take the following:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;コメントに！次の点を考慮してください。</target>
        </trans-unit>
        <trans-unit id="c19727e7a33fbaf5adc662298c963e80689873d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Watch out for whitespace! Take the following:</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;空白に&lt;strong&gt;注意してください&lt;/strong&gt;！次の点を考慮してください。</target>
        </trans-unit>
        <trans-unit id="cdf1510cc13fa0938c540a829729b695b1f7fe47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; We import &lt;code&gt;React&lt;/code&gt; as a namespace here with &lt;code&gt;import * as React from 'react'&lt;/code&gt; instead of as a default with &lt;code&gt;import React from 'react'&lt;/code&gt;. When importing React as an ES module you may use either style, but importing as a namespace gives you access to React&amp;rsquo;s &lt;a href=&quot;../types&quot;&gt;utility types&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;私たちは、インポート &lt;code&gt;React&lt;/code&gt; ここで名前空間として &lt;code&gt;import * as React from 'react'&lt;/code&gt; でデフォルトとして代わりの &lt;code&gt;import React from 'react'&lt;/code&gt; 。ReactをESモジュールとしてインポートするときは、どちらのスタイルも使用できますが、名前空間としてインポートすると、Reactの&lt;a href=&quot;../types&quot;&gt;ユーティリティタイプに&lt;/a&gt;アクセスできます。</target>
        </trans-unit>
        <trans-unit id="5ec9e52dafaf04b0fca35e642b34088ae3ccf8ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; We&amp;rsquo;re going to go through a stripped down example for demonstrating how to make use of type cast expressions. This example is not solved well in practice.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;タイプキャスト式の使用方法を示すために、簡単な例を使用します。この例は実際にはうまく解決されていません。</target>
        </trans-unit>
        <trans-unit id="13714a09cafc3db44b0f21e686d8c767ffcc7bcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; While importing React with a default import works:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;デフォルトのインポートでReactをインポートすると、次のように機能します。</target>
        </trans-unit>
        <trans-unit id="66a1c90af7e35b36d5177b1f056c71e3827448ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;module.name_mapper.extension&lt;/code&gt; multiple times for different extensions.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;module.name_mapper.extension&lt;/code&gt; を指定できます異なる拡張子に対して複数回。</target>
        </trans-unit>
        <trans-unit id="e953a25a8164a088aa27a99871bd1034fa4f7aa5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;sharedmemory.dirs&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;sharedmemory.dirs&lt;/code&gt; は複数回指定できます。</target>
        </trans-unit>
        <trans-unit id="cad40a5701acf5649fe5798b08c924b1a91443a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;suppress_comment&lt;/code&gt; multiple times. If you do define any &lt;code&gt;suppress_comment&lt;/code&gt;s, the built-in &lt;code&gt;$FlowFixMe&lt;/code&gt; suppression will be erased in favor of the regexps you specify. If you wish to use &lt;code&gt;$FlowFixMe&lt;/code&gt; with some additional custom suppression comments, you must manually specify &lt;code&gt;\\(.\\|\n\\)*\\$FlowFixMe&lt;/code&gt; in your custom list of suppressions.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;suppress_comment&lt;/code&gt; は複数回指定できます。 &lt;code&gt;suppress_comment&lt;/code&gt; を定義すると、組み込みの &lt;code&gt;$FlowFixMe&lt;/code&gt; 抑制が消去され、指定した正規表現が優先されます。追加のカスタム抑制コメントで &lt;code&gt;$FlowFixMe&lt;/code&gt; を使用する場合は、抑制のカスタムリストで &lt;code&gt;\\(.\\|\n\\)*\\$FlowFixMe&lt;/code&gt; を手動で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b3ef30213691916dbfdadddd670829ca29768fca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;suppress_type&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;suppress_type&lt;/code&gt; は複数回指定できます。</target>
        </trans-unit>
        <trans-unit id="229ab2d563e326e0866c16c2ecaf54037d4f3e62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You don&amp;rsquo;t need to make &lt;code&gt;foo&lt;/code&gt; nullable in your &lt;code&gt;Props&lt;/code&gt; type. Flow will make sure that &lt;code&gt;foo&lt;/code&gt; is optional if you have a default prop for &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;Props&lt;/code&gt; タイプで &lt;code&gt;foo&lt;/code&gt; を nullにできるようにする必要はありません。フローは、ことを確認します &lt;code&gt;foo&lt;/code&gt; はあなたがデフォルトの小道具がある場合はオプションです &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8dbdf0ca4a737e620de55f8736bb8082cbf733a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You need to use &lt;code&gt;import * as React from 'react'&lt;/code&gt; here instead of &lt;code&gt;import React from 'react'&lt;/code&gt; to get access to the &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; type. We explain why that is in the &lt;a href=&quot;../types&quot;&gt;React Type Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;あなたが使用する必要が &lt;code&gt;import * as React from 'react'&lt;/code&gt; の代わりに、ここで &lt;code&gt;import React from 'react'&lt;/code&gt; へのアクセスを得るために&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; の&lt;/a&gt;タイプを。それが&lt;a href=&quot;../types&quot;&gt;React Type Reference&lt;/a&gt;にある理由を説明します。</target>
        </trans-unit>
        <trans-unit id="e4e73965c0849c76958d2605758705535cf6dda6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You&amp;rsquo;ll probably want to add a &lt;code&gt;prepublish&lt;/code&gt; script that runs this transform as well, so that it runs before you publish your code to the npm registry.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;おそらく &lt;code&gt;prepublish&lt;/code&gt; を追加する必要がありますあなたはNPMレジストリへのあなたのコードを公開する前に、それが実行されるように、これは同様に変換を実行するスクリプトを。</target>
        </trans-unit>
        <trans-unit id="d0d8dc4eae5a24d3928bd38400456f9cbe5313d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can specify &lt;code&gt;module.file_ext&lt;/code&gt; multiple times</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;module.file_ext&lt;/code&gt; を指定できます複数回</target>
        </trans-unit>
        <trans-unit id="277f1b76997cbec25e723aaaf5fe3c78b6b009ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can specify &lt;code&gt;module.name_mapper&lt;/code&gt; multiple times</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;module.name_mapper&lt;/code&gt; を指定できます複数回</target>
        </trans-unit>
        <trans-unit id="0cf4d9235824eed02c46e2f1d98a8ce97a15b5b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can specify &lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt; multiple times</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt; は複数回指定できます</target>
        </trans-unit>
        <trans-unit id="fd3867675ccb5b52461008d6e03fb348c8a53b40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Special thanks to&lt;/strong&gt;: &lt;a href=&quot;https://github.com/jareware&quot;&gt;Jarno Rantanen&lt;/a&gt; for building &lt;a href=&quot;https://github.com/jareware/flotate&quot;&gt;flotate&lt;/a&gt; and supporting us merging his syntax upstream into Flow.</source>
          <target state="translated">&lt;strong&gt;特別な感謝&lt;/strong&gt;：&lt;a href=&quot;https://github.com/jareware/flotate&quot;&gt;フロート&lt;/a&gt;を構築し、彼の構文を上流にフローにマージすることをサポートしてくれた&lt;a href=&quot;https://github.com/jareware&quot;&gt;ヤルノ&lt;/a&gt;ランタネン。</target>
        </trans-unit>
        <trans-unit id="01a48fcac72977e1bf1c5fb03ed59c9380790e6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Try to provide a libdef for each third-party library your project uses&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プロジェクトが使用する各サードパーティライブラリにlibdefを提供するようにしてください&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f43a1aec0402c2b241ef1d914c61cefd59f011c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unchecked files&lt;/strong&gt;. All other files.</source>
          <target state="translated">&lt;strong&gt;未チェックのファイル&lt;/strong&gt;。他のすべてのファイル。</target>
        </trans-unit>
        <trans-unit id="a874bf28f6bc203a4ab83ee91607e029bb99dfcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Do not mistake &lt;code&gt;any&lt;/code&gt; with &lt;code&gt;mixed&lt;/code&gt;. &lt;a href=&quot;../mixed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;誤解しないでください &lt;code&gt;any&lt;/code&gt; と &lt;code&gt;mixed&lt;/code&gt; 。&lt;a href=&quot;../mixed&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cc4bce83d85500a6f45865d989cce18fc4a43ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Flow does not infer generic types. If you want something to have a generic type, &lt;strong&gt;annotate it&lt;/strong&gt;. Otherwise, Flow may infer a type that is less polymorphic than you expect.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;フローはジェネリック型を推測しません。何かにジェネリック型を&lt;strong&gt;付け&lt;/strong&gt;たい場合は、&lt;strong&gt;注釈を付けます&lt;/strong&gt;。そうしないと、Flowは、予想よりも多態性の低い型を推測する場合があります。</target>
        </trans-unit>
        <trans-unit id="a280dc6a74b332873e229283e81f56eb6ccce4ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; For performance purposes, we always recommend you annotate with concrete arguments when you can. &lt;code&gt;_&lt;/code&gt; is not unsafe, but it is slower than explicitly specifying the type arguments.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;パフォーマンス上の理由から、可能な場合は常に具体的な引数で注釈を付けることをお勧めします。 &lt;code&gt;_&lt;/code&gt; は安全ではありませんが、型引数を明示的に指定するよりも低速です。</target>
        </trans-unit>
        <trans-unit id="31f870561ad37a87582f2c7ee2fa8398d4fae0b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Watchman lazy mode&lt;/strong&gt;. When starting up, Flow treats any file as focused if it has changed since the mergebase with master (the common ancestor of the current commit and the master branch). Any subsequent file that changes is also focused. After a rebase which changes the mergebase, Flow may restart the server if it estimates that a restart is faster than a recheck.</source>
          <target state="translated">&lt;strong&gt;夜警レイジーモード&lt;/strong&gt;。起動時、フローは、マスター（現在のコミットとマスターブランチの共通の祖先）とのマージベース以降に変更された場合、すべてのファイルをフォーカスされたものとして扱います。変更される後続のファイルもすべてフォーカスされます。mergebaseを変更するリベースの後、再チェックが再チェックよりも速いとフローが予測した場合、Flowはサーバーを再起動する場合があります。</target>
        </trans-unit>
        <trans-unit id="95b4924a0b182cfffbd184b94a6565475c510c1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;error:&lt;/strong&gt; Lints with severity &lt;code&gt;error&lt;/code&gt; are treated exactly the same as any other Flow error.</source>
          <target state="translated">&lt;strong&gt;エラー：&lt;/strong&gt;重大度 &lt;code&gt;error&lt;/code&gt; Lintsある、他のフローエラーとまったく同じように扱われます。</target>
        </trans-unit>
        <trans-unit id="1a03a729136b36f5838887b635904e593801ed41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flow-typed/myLibDef.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flow-typed/myLibDef.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e33c8943ab39266d98f3fccd3a3499ba35474f73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flow-typed/some-commonjs-module.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flow-typed/some-commonjs-module.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6bddb02bd60e0167f1a6757b72ddc9ab8cccab64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flow-typed/some-es-module.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flow-typed/some-es-module.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f98671d24b241f481d2118b0f7963a30771b5ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;off:&lt;/strong&gt; The lint is ignored. Setting a lint to &lt;code&gt;off&lt;/code&gt; is similar to suppressing a type error with a suppression comment, except with much more granularity.</source>
          <target state="translated">&lt;strong&gt;off：&lt;/strong&gt; lintは無視されます。lintを &lt;code&gt;off&lt;/code&gt; に設定することは、より細かいことを除いて、抑制コメントで型エラーを抑制するのと似ています。</target>
        </trans-unit>
        <trans-unit id="d023c19a616c35ca9826c7a2ffac16870361f13d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;settings over a block of code:&lt;/strong&gt; A pair of &lt;code&gt;flowlint&lt;/code&gt; comments can be used to apply a certain setting over a block of code. For example, to disabling the untyped-type-import lint over a block of type imports would look like this:</source>
          <target state="translated">&lt;strong&gt;コードブロックに対する設定：&lt;/strong&gt;一対の &lt;code&gt;flowlint&lt;/code&gt; コメントを使用して、コードブロックに対して特定の設定を適用できます。たとえば、型インポートのブロックに対して型なし型インポートlintを無効にするには、次のようになります。</target>
        </trans-unit>
        <trans-unit id="31146238339ea53d1542596a43e6ef00dc10cce7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;settings over a file:&lt;/strong&gt; A &lt;code&gt;flowlint&lt;/code&gt; comment doesn&amp;rsquo;t have to have a matching comment to form a block. An unmatched comment simply applies its settings to the rest of the file. You could use this, for example, to suppress all sketchy-null-check lints in a particular file:</source>
          <target state="translated">&lt;strong&gt;：ファイルオーバーの設定&lt;/strong&gt; A &lt;code&gt;flowlint&lt;/code&gt; のコメントはブロックを形成するために、一致するコメントをする必要はありません。一致しないコメントは、その設定をファイルの残りの部分に適用するだけです。たとえば、これを使用して、特定のファイル内のすべての不完全なnullチェックのリントを抑制することができます。</target>
        </trans-unit>
        <trans-unit id="fa2579b9e2d9cbad84fbd5f31d89ceb484a456f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;settings over part of a line:&lt;/strong&gt; The settings applied by &lt;code&gt;flowlint&lt;/code&gt; start and end right at the comment itself. This means that you can do things like</source>
          <target state="translated">&lt;strong&gt;行の一部&lt;/strong&gt;の設定&lt;strong&gt;：&lt;/strong&gt;コメント自体で &lt;code&gt;flowlint&lt;/code&gt; 開始と終了によって適用される設定。つまり、次のようなことができます</target>
        </trans-unit>
        <trans-unit id="feb7c9b56545cc3391e09e0d2b8bd5709fa97489" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;warn:&lt;/strong&gt; Warnings are a new severity level introduced by the linting framework. They are treated differently than errors in a couple of ways:</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;警告は、lintingフレームワークによって導入された新しい重大度レベルです。それらはいくつかの方法でエラーとは異なって扱われます：</target>
        </trans-unit>
        <trans-unit id="8f637424e74ed1ebcadcdbadc0c7f23a162bdc46" translate="yes" xml:space="preserve">
          <source>@flow - Parse this file with Flow syntax allowed and typecheck it.</source>
          <target state="translated">@flow-このファイルを Flow 構文が許可されている状態でパースし、それを typecheck する。</target>
        </trans-unit>
        <trans-unit id="dab817ff7a654e90ff5dd7173e93ea494624263b" translate="yes" xml:space="preserve">
          <source>@noflow - Parse this file with Flow syntax allowed and do not typecheck it. This is meant as an escape hatch to suppress Flow in a file without having to delete all the Flow-specific syntax.</source>
          <target state="translated">@noflow-Flow 構文を許可した状態でこのファイルをパースし、タイプチェックを行わない。これは、Flow固有の構文をすべて削除することなく、ファイル内のFlowを抑制するためのエスケープハッチとして意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="d5517ef60c8c970054ed9b5ae5d4d8803202583f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; is the type at a given key &lt;code&gt;k&lt;/code&gt;. As of Flow v0.36.0, &lt;code&gt;k&lt;/code&gt; must be a literal string.</source>
          <target state="translated">A &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; 指定されたキーであるタイプ &lt;code&gt;k&lt;/code&gt; 。Flow v0.36.0以降、 &lt;code&gt;k&lt;/code&gt; はリテラル文字列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3e7f5ef7659179e8cb5f3ac39ecffed44e573698" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Boolean&lt;/code&gt; is a wrapper object created by the global &lt;code&gt;new Boolean(x)&lt;/code&gt; constructor.</source>
          <target state="translated">A &lt;code&gt;Boolean&lt;/code&gt; グローバルで作成されたラッパーオブジェクトである &lt;code&gt;new Boolean(x)&lt;/code&gt; コンストラクタ。</target>
        </trans-unit>
        <trans-unit id="f4b4c1e23604a85feb14553cd867329fa18edcb9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Number&lt;/code&gt; is a wrapper object created by the global &lt;code&gt;new Number(x)&lt;/code&gt; constructor.</source>
          <target state="translated">A &lt;code&gt;Number&lt;/code&gt; グローバルで作成されたラッパーオブジェクトで &lt;code&gt;new Number(x)&lt;/code&gt; コンストラクタ。</target>
        </trans-unit>
        <trans-unit id="7ff4f95a14f0f15fb91feaff17eb578d01d42954" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; takes a single type argument, &lt;code&gt;typeof Component&lt;/code&gt;. &lt;code&gt;typeof Component&lt;/code&gt; is the component type of the React element. For an intrinsic element, &lt;code&gt;typeof Component&lt;/code&gt; will be the string literal for the intrinsic you used. Here are a few examples with DOM intrinsics:</source>
          <target state="translated">A &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; 、シングルタイプの引数を取る &lt;code&gt;typeof Component&lt;/code&gt; 。 &lt;code&gt;typeof Component&lt;/code&gt; は、React要素のコンポーネントタイプです。組み込み要素の場合、 &lt;code&gt;typeof Component&lt;/code&gt; は、使用した組み込みの文字列リテラルになります。次に、DOM組み込み関数の例をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="3cc9f3a301444a49c02a8ccdf90391c3099669bb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper object created by the global &lt;code&gt;new String(x)&lt;/code&gt; constructor.</source>
          <target state="translated">A &lt;code&gt;String&lt;/code&gt; グローバルで作成されたラッパー・オブジェクトである &lt;code&gt;new String(x)&lt;/code&gt; コンストラクタ。</target>
        </trans-unit>
        <trans-unit id="1aa87ca478a9e8203d1f48b664ee80f4bde77cca" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;boolean&lt;/code&gt; is a literal value like &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; or the result of an expression like &lt;code&gt;a === b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; のようなリテラル値である &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; 等式の結果 &lt;code&gt;a === b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eae9db4713f41ce51d4836cd52cd83cf66fe6bba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;flowlint-line&lt;/code&gt; comment works similarly to a &lt;code&gt;flowlint&lt;/code&gt; comment, except it only applies its settings to the current line instead of applying them for the rest of the file. The primary use for &lt;code&gt;flowlint-line&lt;/code&gt; comments is to suppress a lint on a particular line:</source>
          <target state="translated">&lt;code&gt;flowlint-line&lt;/code&gt; コメントは、と同様に動作します &lt;code&gt;flowlint&lt;/code&gt; それが唯一の代わりに、ファイルの残りのためにそれらを適用する現在の行にその設定を適用する以外、コメント。 &lt;code&gt;flowlint-line&lt;/code&gt; コメントの主な用途は、特定の線のリ​​ントを抑制することです。</target>
        </trans-unit>
        <trans-unit id="3dbdddd5ad4de5b2edfb46887933757af099bccf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;number&lt;/code&gt; is a literal value like &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt; or the result of an expression like &lt;code&gt;parseFloat(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; のようなリテラル値である &lt;code&gt;42&lt;/code&gt; 又は &lt;code&gt;3.14&lt;/code&gt; 等式の結果 &lt;code&gt;parseFloat(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="810376c88abf15447cb20ec803309eab84ccf149" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;string&lt;/code&gt; is a literal value like &lt;code&gt;&quot;foo&quot;&lt;/code&gt; or the result of an expression like &lt;code&gt;&quot;&quot; + 42&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; のようなリテラル値である &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 等式の結果 &lt;code&gt;&quot;&quot; + 42&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86a442d2c56258fa63e09bdf1e3922431ce6755c" translate="yes" xml:space="preserve">
          <source>A React children array can be a single value or an array nested to any level. It is designed to be used with the &lt;a href=&quot;https://reactjs.org/docs/react-api.html#reactchildren&quot;&gt;&lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt;.</source>
          <target state="translated">Reactの子配列は、単一の値または任意のレベルにネストされた配列にすることができます。&lt;a href=&quot;https://reactjs.org/docs/react-api.html#reactchildren&quot;&gt; &lt;code&gt;React.Children&lt;/code&gt; APIで&lt;/a&gt;使用するように設計されています。</target>
        </trans-unit>
        <trans-unit id="1ac20284b90912b5ee342718a932002c471e7063" translate="yes" xml:space="preserve">
          <source>A React element is the type for the value of a JSX element:</source>
          <target state="translated">React要素はJSX要素の値の型です。</target>
        </trans-unit>
        <trans-unit id="5d4c2e7721c9d46456be0ebe1e112134378df4c1" translate="yes" xml:space="preserve">
          <source>A class or function component with config &lt;code&gt;Config&lt;/code&gt; may be used in places that expect &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; が必要な場所で、 &lt;code&gt;Config&lt;/code&gt; のクラスまたは関数コンポーネントを使用できます。</target>
        </trans-unit>
        <trans-unit id="5c97c303f1555df5edf4bfe277f9d6c3317ef0a7" translate="yes" xml:space="preserve">
          <source>A common use case for higher-order components is to inject a prop. The HOC automatically sets a prop and returns a component which no longer requires that prop. For example, consider a navigation prop, or in the case of &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;react-redux&lt;/code&gt; a &lt;code&gt;store&lt;/code&gt; prop&lt;/a&gt;. How would one type this?</source>
          <target state="translated">高次コンポーネントの一般的な使用例は、小道具を注入することです。HOCは自動的に小道具を設定し、その小道具を必要としなくなったコンポーネントを返します。例えば、ナビゲーション支柱、またはの場合に考える&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;react-redux&lt;/code&gt; &lt;code&gt;store&lt;/code&gt; 小道具を&lt;/a&gt;。これはどのように入力するのでしょうか？</target>
        </trans-unit>
        <trans-unit id="30dbf123853c4a0e8c3631a140f89f123c49780e" translate="yes" xml:space="preserve">
          <source>A libdef is a special file that informs Flow about the type signature of some specific third-party module or package of modules that your application uses. If you&amp;rsquo;re familiar with languages that have header files (like &lt;code&gt;C++&lt;/code&gt;), you can think of libdefs as a similar concept.</source>
          <target state="translated">libdefは、アプリケーションが使用する特定のサードパーティモジュールまたはモジュールのパッケージのタイプシグネチャについてFlowに通知する特別なファイルです。ヘッダーファイルがある言語（ &lt;code&gt;C++&lt;/code&gt; ）に精通している場合は、libdefsを同様の概念と考えることができます。</target>
        </trans-unit>
        <trans-unit id="ca822c818a1e02043f7fd8c1f3e2121e587ff173" translate="yes" xml:space="preserve">
          <source>A popular pattern in React is the &lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;higher-order component pattern&lt;/a&gt;, so it&amp;rsquo;s important that we can provide effective types for higher-order components in Flow. If you don&amp;rsquo;t already know what a higher-order component is then make sure to read the &lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;React documentation on higher-order components&lt;/a&gt; before continuing.</source>
          <target state="translated">Reactでよく使用されるパターンは&lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;高次コンポーネントパターン&lt;/a&gt;です。そのため、Flowの高次コンポーネントに効果的なタイプを提供できることが重要です。高次コンポーネントがまだ分からない場合は、続行&lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;する&lt;/a&gt;前に、高次コンポーネントに関するReactのドキュメントを必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="2f8e9dfe25e3835aaff6cc6ecae3f02d157188cb" translate="yes" xml:space="preserve">
          <source>A static type checker uses either the names or the structure of the types in order to compare them against other types. Checking against the name is nominal typing and checking against the structure is structural typing.</source>
          <target state="translated">静的型チェッカは、他の型と比較するために、型の名前や構造のいずれかを使用します。名前をチェックするのは名目型付けで、構造をチェックするのは構造型付けです。</target>
        </trans-unit>
        <trans-unit id="671a4ff4e804eebb070be2fc14388832f1511e9d" translate="yes" xml:space="preserve">
          <source>A type is something like a string, a boolean, an object, or a class. They have names and they have structures. Primitives like strings or booleans have a very simple structure and only go by one name.</source>
          <target state="translated">型とは、文字列、ブーリアン、オブジェクト、クラスのようなものです。これらには名前と構造があります。文字列やブール値のようなプリミティブは非常にシンプルな構造をしていて、名前は一つしかありません。</target>
        </trans-unit>
        <trans-unit id="41848119547f63e0f0117b445db59a03ebf4ba0e" translate="yes" xml:space="preserve">
          <source>A type like &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt; describes a set of possible values. A &lt;code&gt;number&lt;/code&gt; describes every possible number, so a single number (such as &lt;code&gt;42&lt;/code&gt;) would be a &lt;em&gt;subtype&lt;/em&gt; of the &lt;code&gt;number&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 、 &lt;code&gt;boolean&lt;/code&gt; 、または &lt;code&gt;string&lt;/code&gt; のようなタイプは、可能な値のセットを記述します。 &lt;code&gt;number&lt;/code&gt; すべての可能な数を記述するので、（例えば、単一の番号 &lt;code&gt;42&lt;/code&gt; ）であろう&lt;em&gt;サブタイプ&lt;/em&gt;の &lt;code&gt;number&lt;/code&gt; タイプ。</target>
        </trans-unit>
        <trans-unit id="084f378a5689bc62abec28cce79f808d15cc2701" translate="yes" xml:space="preserve">
          <source>A variable of type &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is some object type, can be assigned objects &lt;code&gt;o&lt;/code&gt; that contain a subset of the properties included in &lt;code&gt;T&lt;/code&gt;. For each property &lt;code&gt;p: S&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;, the type of a potential binding of &lt;code&gt;p&lt;/code&gt; in &lt;code&gt;o&lt;/code&gt; must be compatible with &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">型の変数 &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; は、いくつかのオブジェクト型では、オブジェクトを割り当てることができ &lt;code&gt;o&lt;/code&gt; をに含まれるプロパティのサブセットを含むこと &lt;code&gt;T&lt;/code&gt; を。各プロパティ &lt;code&gt;p: S&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt; について、 &lt;code&gt;p&lt;/code&gt; in &lt;code&gt;o&lt;/code&gt; の潜在的なバインディングのタイプは &lt;code&gt;S&lt;/code&gt; と互換性がある必要があります。</target>
        </trans-unit>
        <trans-unit id="2271b14edc45904cc47bb0f92baf4a74500757a6" translate="yes" xml:space="preserve">
          <source>ALE</source>
          <target state="translated">ALE</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="c2c9357e2d1358b4ed63794b3bdbb571d911a366" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;@flow strict&lt;/code&gt; to a file and fix all errors that appear. Because Flow Strict requires dependencies to also be strict (if the &lt;code&gt;nonstrict-import&lt;/code&gt; rule is enabled), start at the leaves of the dependency tree and work up from there. Do not add &lt;code&gt;$FlowFixMe&lt;/code&gt; to suppress the new errors as they appear; just add &lt;code&gt;@flow strict&lt;/code&gt; once all issues have been resolved. Since the most common reasons for using &lt;code&gt;$FlowFixMe&lt;/code&gt; stem from reliance on untyped dependencies or behavior, future issues should be greatly reduced once Flow Strict is enabled.</source>
          <target state="translated">&lt;code&gt;@flow strict&lt;/code&gt; をファイルに追加し、表示されるすべてのエラーを修正します。Flow Strictでは依存関係も厳格である必要があるため（ &lt;code&gt;nonstrict-import&lt;/code&gt; ルールが有効になっている場合）、依存関係ツリーのリーフから開始し、そこから作業を進めます。 &lt;code&gt;$FlowFixMe&lt;/code&gt; を追加して、新しいエラーを抑制しないでください。すべての問題が解決したら、 &lt;code&gt;@flow strict&lt;/code&gt; 追加するだけです。 &lt;code&gt;$FlowFixMe&lt;/code&gt; を使用する最も一般的な理由は、型指定されていない依存関係または動作に依存しているため、Flow Strictを有効にすると、将来の問題を大幅に減らす必要があります。</target>
        </trans-unit>
        <trans-unit id="348f08f4c30937769280d29589632be81dce564d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;[strict]&lt;/code&gt; section to the &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">追加 &lt;code&gt;[strict]&lt;/code&gt; にセクションを &lt;code&gt;.flowconfig&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="debff0c0e31df0c3b54bd63967abba908318fd7b" translate="yes" xml:space="preserve">
          <source>Add this to your ~/.vimrc</source>
          <target state="translated">これを ~/.vimrc に追加します。</target>
        </trans-unit>
        <trans-unit id="ef87c5c8a2b16d4c56ca61522bd746bf5ccd2856" translate="yes" xml:space="preserve">
          <source>Adding Flow types to your React components is incredibly powerful. After typing your component, Flow will statically ensure that you are using the component in the way it was designed to be used.</source>
          <target state="translated">ReactコンポーネントにFlowの型を追加することは、信じられないほど強力です。コンポーネントをタイプした後、Flow は静的に、コンポーネントを使用するように設計された方法で使用していることを保証します。</target>
        </trans-unit>
        <trans-unit id="ce3f0d181c2f06a4552c99e371dfc2c79d5925f9" translate="yes" xml:space="preserve">
          <source>Adding State</source>
          <target state="translated">状態の追加</target>
        </trans-unit>
        <trans-unit id="3bfb8073e6bb1f0689467760321027edeffeb0e7" translate="yes" xml:space="preserve">
          <source>Adding defaults to parameterized generics</source>
          <target state="translated">パラメータ化されたジェネリックにデフォルトを追加する</target>
        </trans-unit>
        <trans-unit id="24102cd54654562a4cca3094ba42e1695bfc0400" translate="yes" xml:space="preserve">
          <source>Adding type annotations is an important part of your interaction with Flow.</source>
          <target state="translated">タイプアノテーションを追加することは、Flowを使用する上で重要な要素です。</target>
        </trans-unit>
        <trans-unit id="dd4b16fc77256848662e64369cda76926181fdf0" translate="yes" xml:space="preserve">
          <source>Adding types to generics</source>
          <target state="translated">ジェネリックにタイプを追加する</target>
        </trans-unit>
        <trans-unit id="c46c2e1f44bf89eeaca616b1006a75c2f1f9f078" translate="yes" xml:space="preserve">
          <source>Additionally, note that function parameters are considered const (i.e., treated as if they were declared with &lt;code&gt;const&lt;/code&gt; rather than &lt;code&gt;let&lt;/code&gt;). This feature is not yet configurable in Flow Strict; it is always on.</source>
          <target state="translated">さらに、関数パラメーターはconstと見なされる（つまり、 &lt;code&gt;let&lt;/code&gt; ではなく &lt;code&gt;const&lt;/code&gt; で宣言されているかのように扱われる）ことに注意してください。この機能は、Flow Strictではまだ設定できません。常にオンです。</target>
        </trans-unit>
        <trans-unit id="084523950d9700bad04af812baabda38d1775c92" translate="yes" xml:space="preserve">
          <source>Additionally, one of the things that also makes &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; more powerful than &lt;a href=&quot;#toc-propertytype&quot;&gt;&lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt;&lt;/a&gt; is that you can use it with generics. For example:</source>
          <target state="translated">さらに、 &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; が&lt;a href=&quot;#toc-propertytype&quot;&gt; &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; &lt;/a&gt;よりも強力になる理由の1つは、ジェネリックで使用できることです。例えば：</target>
        </trans-unit>
        <trans-unit id="e9a588006a751b6eac3899c1c33719e0d1f574b8" translate="yes" xml:space="preserve">
          <source>Additionally, other utility types, such as &lt;a href=&quot;#toc-objmap&quot;&gt;&lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, may strip any read/write annotations, so &lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; is a handy way to quickly make the object read-only again after operating on it:</source>
          <target state="translated">さらに、&lt;a href=&quot;#toc-objmap&quot;&gt; &lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;などの他のユーティリティタイプは、読み取り/書き込み注釈を削除する可能性があるため、 &lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; は、オブジェクトを操作した後、オブジェクトをすばやく読み取り専用にする便利な方法です。</target>
        </trans-unit>
        <trans-unit id="9165abaadf3796191a41d4c4e2ff7bee612bceba" translate="yes" xml:space="preserve">
          <source>Adds completions to omnifunc</source>
          <target state="translated">omnifuncに補完を追加</target>
        </trans-unit>
        <trans-unit id="9d9855d155abfb00319d620ad3008e951f075bcb" translate="yes" xml:space="preserve">
          <source>Adoption</source>
          <target state="translated">Adoption</target>
        </trans-unit>
        <trans-unit id="7823f6ab865766bbd1127e26841e44993df0966b" translate="yes" xml:space="preserve">
          <source>Again, if you import React with: &lt;code&gt;import React from 'react'&lt;/code&gt; you will be able to access &lt;code&gt;React.Component&lt;/code&gt;, &lt;code&gt;React.createElement()&lt;/code&gt;, &lt;code&gt;React.Children&lt;/code&gt;, and other JavaScript &lt;em&gt;values&lt;/em&gt;. However, you will not be able to access &lt;a href=&quot;#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&lt;/code&gt;&lt;/a&gt; or other Flow &lt;em&gt;types&lt;/em&gt;. You will need to use a named type import like: &lt;code&gt;import type {Node} from 'react'&lt;/code&gt; in addition to your default import.</source>
          <target state="translated">繰り返しますが、Reactをインポートする場合： &lt;code&gt;import React from 'react'&lt;/code&gt; から &lt;code&gt;React.Component&lt;/code&gt; 、 &lt;code&gt;React.createElement()&lt;/code&gt; 、 &lt;code&gt;React.Children&lt;/code&gt; 、およびその他のJavaScript &lt;em&gt;値&lt;/em&gt;にアクセスでき&lt;em&gt;ます&lt;/em&gt;。ただし、&lt;a href=&quot;#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&lt;/code&gt; 、&lt;/a&gt;またはその他のフロー&lt;em&gt;タイプ&lt;/em&gt;にはアクセスできません。デフォルトのインポートに加えて、 &lt;code&gt;import type {Node} from 'react'&lt;/code&gt; ような名前付きタイプのインポートを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6960f0d48dae2ed291e229a0c18667430af5ad7c" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;react-dom&lt;/code&gt; JSX intrinsics have &lt;code&gt;React.Node&lt;/code&gt; as their children type. &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;, and all the rest.</source>
          <target state="translated">すべての &lt;code&gt;react-dom&lt;/code&gt; JSX組み込みには、子タイプとして &lt;code&gt;React.Node&lt;/code&gt; があります。 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 、およびその他すべて。</target>
        </trans-unit>
        <trans-unit id="ca3d3759b20a58e23b6e490416571783c4b57d09" translate="yes" xml:space="preserve">
          <source>All of these different expressions create a new type which is a result of the types of values and the operations run on them.</source>
          <target state="translated">これらの異なる式はすべて、値の型とその上で実行される操作の結果である新しい型を作成します。</target>
        </trans-unit>
        <trans-unit id="0f113e33ce14591dd70d6193beb553131d41f5f0" translate="yes" xml:space="preserve">
          <source>All of this is why Flow has contravariant inputs (accepts less specific types to be passed in), and covariant outputs (allows more specific types to be returned).</source>
          <target state="translated">これらすべての理由から、Flowは対照的な入力(渡される特定の型の数が少ないことを受け入れる)と共分散出力(返される特定の型の数が多いことを受け入れる)を持っています。</target>
        </trans-unit>
        <trans-unit id="f47b935eb4737e5a19c994e524b19f17133d6b8b" translate="yes" xml:space="preserve">
          <source>Also a tuple type cannot be passed into to an &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; type, since then you could mutate the tuple in an unsafe way.</source>
          <target state="translated">また、タプル型を &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; 型に渡すことはできません。安全でない方法でタプルを変更する可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="1e224fe065210d7ea5bc4ecdfb975d62ba96cb27" translate="yes" xml:space="preserve">
          <source>Also recommended, but optional as it may be too noisy in some codebases: &lt;code&gt;sketchy-null&lt;/code&gt;</source>
          <target state="translated">また推奨されますが、一部のコードベースではノイズが多すぎる可能性があるためオプションです： &lt;code&gt;sketchy-null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6650e3d7dff1ebe1979e6edf742206dcb5d30b21" translate="yes" xml:space="preserve">
          <source>Also, a longer tuple can&amp;rsquo;t be used in place of a shorter one.</source>
          <target state="translated">また、長いタプルを短いタプルの代わりに使用することはできません。</target>
        </trans-unit>
        <trans-unit id="ed76d08a5750c0ac19262fa4c88e1912b27bd2c6" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;../config/options#toc-lazy-mode-fs-ide-watchman-none&quot;&gt;you can set the lazy mode from the &lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">または、&lt;a href=&quot;../config/options#toc-lazy-mode-fs-ide-watchman-none&quot;&gt; &lt;code&gt;.flowconfig&lt;/code&gt; &lt;/a&gt;からレイジーモードを設定できます。</target>
        </trans-unit>
        <trans-unit id="82c66bd79d3d4ffdc185a7185952761a2c8c3f10" translate="yes" xml:space="preserve">
          <source>Alternatively, the legacy &lt;a href=&quot;#toc-vim-flow&quot;&gt;vim-flow&lt;/a&gt; extension is Flow-specific, and provides fewer features.</source>
          <target state="translated">または、レガシーの&lt;a href=&quot;#toc-vim-flow&quot;&gt;vim-flow&lt;/a&gt;拡張はフロー固有であり、提供する機能が少なくなります。</target>
        </trans-unit>
        <trans-unit id="05c96e450e44289cd41c687e74cce15c9214f0aa" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;[declarations]&lt;/code&gt; section might look like:</source>
          <target state="translated">&lt;code&gt;[declarations]&lt;/code&gt; セクションの例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="90be5ce7c515603e4e6a07b492b34ad2c170d26e" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;[ignore]&lt;/code&gt; section might look like:</source>
          <target state="translated">&lt;code&gt;[ignore]&lt;/code&gt; セクションの例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="63ef3849ebab36d15f3096be1da4ba961dfdabbb" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;[untyped]&lt;/code&gt; section might look like:</source>
          <target state="translated">&lt;code&gt;[untyped]&lt;/code&gt; セクションの例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="c58b06aa29f634eb5b80b5c46b1dd5e2a95f3710" translate="yes" xml:space="preserve">
          <source>An important attribute of every type system is whether they are structural or nominal, they can even be mixed within a single type system. So it&amp;rsquo;s important to know the difference.</source>
          <target state="translated">すべての型システムの重要な属性は、それらが構造的であるか名義的であるかに関係なく、単一の型システム内で混合することさえできます。したがって、違いを知ることが重要です。</target>
        </trans-unit>
        <trans-unit id="7534a2c6b02aff918f4734ba9f0cb833213dab75" translate="yes" xml:space="preserve">
          <source>An indexer can be optionally named, for documentation purposes:</source>
          <target state="translated">文書化のために、オプションでインデクサの名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="02f5dca0f3fb11ce7b28ee592bf4f726a45875a4" translate="yes" xml:space="preserve">
          <source>And that is it. Your project is now Flow-enabled.</source>
          <target state="translated">これで完了です。あなたのプロジェクトがFlow対応になりました。</target>
        </trans-unit>
        <trans-unit id="bc97cb67c24efbdbd68974b88a3db4e9f3a4fc10" translate="yes" xml:space="preserve">
          <source>And use:</source>
          <target state="translated">そして、使用する。</target>
        </trans-unit>
        <trans-unit id="8b778ae534c485f0d6739866e99f8bc63e2331d8" translate="yes" xml:space="preserve">
          <source>Another way to add support for Flow in Vim is to use &lt;a href=&quot;https://github.com/autozimu/LanguageClient-neovim&quot;&gt;LanguageClient-neovim&lt;/a&gt;.</source>
          <target state="translated">VimでFlowのサポートを追加する別の方法は、&lt;a href=&quot;https://github.com/autozimu/LanguageClient-neovim&quot;&gt;LanguageClient-neovim&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="c37c50bfab9118a52fdf0a7f80769cc4ab540351" translate="yes" xml:space="preserve">
          <source>Another way to add support for Flow in Vim is to use &lt;a href=&quot;https://github.com/flowtype/vim-flow&quot;&gt;vim-flow&lt;/a&gt;.</source>
          <target state="translated">VimでFlowのサポートを追加する別の方法は、&lt;a href=&quot;https://github.com/flowtype/vim-flow&quot;&gt;vim-flow&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="92210bddb4211d0e6c83515a4f9b3f1b1a7a39c8" translate="yes" xml:space="preserve">
          <source>Any Types</source>
          <target state="translated">任意のタイプ</target>
        </trans-unit>
        <trans-unit id="d75e5f7ff95f6863097f6d1ec2a9d80aba28a579" translate="yes" xml:space="preserve">
          <source>Any directory under &lt;code&gt;/path/to/otherProject&lt;/code&gt; named &lt;code&gt;coolStuff/&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/path/to/otherProject&lt;/code&gt; の下にある &lt;code&gt;coolStuff/&lt;/code&gt; という名前のディレクトリ</target>
        </trans-unit>
        <trans-unit id="9e3d4ca42d4885ee40721656532f3228027ab154" translate="yes" xml:space="preserve">
          <source>Any file in &lt;code&gt;/path/to/otherProject/&lt;/code&gt; that ends in &lt;code&gt;.js&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/path/to/otherProject/&lt;/code&gt; にあり、 &lt;code&gt;.js&lt;/code&gt; で終わるファイル</target>
        </trans-unit>
        <trans-unit id="ff45287734d6e5c2d42e27a8403e84e9cdd43925" translate="yes" xml:space="preserve">
          <source>Any file or directory under &lt;code&gt;.*/src/foo&lt;/code&gt; or under &lt;code&gt;.*/src/bar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.*/src/foo&lt;/code&gt; または &lt;code&gt;.*/src/bar&lt;/code&gt; 下のファイルまたはディレクトリ</target>
        </trans-unit>
        <trans-unit id="619cdeb72fa14a27c15ad77831a5eef22d615f19" translate="yes" xml:space="preserve">
          <source>Any file or directory under a directory named &lt;code&gt;__tests__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__tests__&lt;/code&gt; という名前のディレクトリの下のファイルまたはディレクトリ</target>
        </trans-unit>
        <trans-unit id="0c3253b58f788b30811429ab97032f8e98a1859d" translate="yes" xml:space="preserve">
          <source>Any file or directory under a directory named &lt;code&gt;third_party&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;third_party&lt;/code&gt; という名前のディレクトリの下にあるファイルまたはディレクトリ</target>
        </trans-unit>
        <trans-unit id="7cc44198b1e6e1b795a7e8aa32c3da295d676830" translate="yes" xml:space="preserve">
          <source>Any file that ends with the extension &lt;code&gt;.decl.js&lt;/code&gt;</source>
          <target state="translated">拡張子が &lt;code&gt;.decl.js&lt;/code&gt; で終わるすべてのファイル</target>
        </trans-unit>
        <trans-unit id="1bffc382d25466b833b5b2837da78952a00737fd" translate="yes" xml:space="preserve">
          <source>Any file that ends with the extension &lt;code&gt;.ignore.js&lt;/code&gt;</source>
          <target state="translated">拡張子が &lt;code&gt;.ignore.js&lt;/code&gt; で終わるすべてのファイル</target>
        </trans-unit>
        <trans-unit id="f72b4d45c679b8fd5b66d19514cb30c2b70941fd" translate="yes" xml:space="preserve">
          <source>Any file that ends with the extension &lt;code&gt;.untype.js&lt;/code&gt;</source>
          <target state="translated">拡張子 &lt;code&gt;.untype.js&lt;/code&gt; で終わるすべてのファイル</target>
        </trans-unit>
        <trans-unit id="d8058d8ae00a7724bf520d87b91a727d4fba9de4" translate="yes" xml:space="preserve">
          <source>Any options that are omitted will use their default values. Some options can be overridden with command line flags.</source>
          <target state="translated">省略されたオプションはすべてデフォルト値を使用します。いくつかのオプションは、コマンドラインフラグで上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="158d7a05937714067b015b61e36e2e34b536b32d" translate="yes" xml:space="preserve">
          <source>Any type can appear as the super type or type of an opaque type alias.</source>
          <target state="translated">どのようなタイプでも、スーパータイプや不透明なタイプのエイリアスのタイプとして現れることができます。</target>
        </trans-unit>
        <trans-unit id="f8b9550f4f85978cbf264304833e5597e61caa6b" translate="yes" xml:space="preserve">
          <source>Any type can appear inside a type alias.</source>
          <target state="translated">どのような型でも、型のエイリアスの中に現れることができます。</target>
        </trans-unit>
        <trans-unit id="b8269fc02f1c810c6ff4db59298ada4596018447" translate="yes" xml:space="preserve">
          <source>Anything goes in, Nothing comes out</source>
          <target state="translated">何が入っても何も出てこない</target>
        </trans-unit>
        <trans-unit id="1847f280fe6a7cfd6c208240da7d0ab7f1c91ffb" translate="yes" xml:space="preserve">
          <source>Array Types</source>
          <target state="translated">配列型</target>
        </trans-unit>
        <trans-unit id="83c584ea41caf5a381449f3d3b97037f78283560" translate="yes" xml:space="preserve">
          <source>Array access is unsafe</source>
          <target state="translated">配列アクセスは安全ではありません</target>
        </trans-unit>
        <trans-unit id="3170d1b3f6bc73372a7270faffd2e78add925812" translate="yes" xml:space="preserve">
          <source>Arrays are a special list-like type of object in JavaScript. You can create arrays a couple different ways.</source>
          <target state="translated">配列は、JavaScriptではリストのような特殊なタイプのオブジェクトです。配列を作成する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="2eff12655bfd37e8aba34fc4ce9e8a7b43bbf939" translate="yes" xml:space="preserve">
          <source>Arrow Functions</source>
          <target state="translated">矢印関数</target>
        </trans-unit>
        <trans-unit id="9deec36383ee4f0d0aa3b179bc68ebbe9f7b8c48" translate="yes" xml:space="preserve">
          <source>As Flow gets smarter and smarter, it will figure out the types of properties in more scenarios.</source>
          <target state="translated">Flowがどんどん賢くなっていくと、より多くのシナリオでプロパティの種類を把握できるようになります。</target>
        </trans-unit>
        <trans-unit id="5ce04ebbe35f0d095625abc02e93781430c8c957" translate="yes" xml:space="preserve">
          <source>As Flow gets smarter and smarter, there should be fewer instances of these scenarios.</source>
          <target state="translated">フローが賢くなるにつれて、これらのシナリオのインスタンスは少なくなるはずです。</target>
        </trans-unit>
        <trans-unit id="bc029ffe889a5bffa6b1132bfb40c2eb845b9647" translate="yes" xml:space="preserve">
          <source>As Flow is made to be smarter it may be possible in the future to fix this problem, but for now you should be aware of it.</source>
          <target state="translated">Flowはよりスマートになるように作られているので、将来的にはこの問題を修正できるかもしれませんが、今のところは注意が必要です。</target>
        </trans-unit>
        <trans-unit id="afba3e48afe0dd342bba029cc69e818d6ff61285" translate="yes" xml:space="preserve">
          <source>As a motivating example, consider this common idiom in React:</source>
          <target state="translated">モチベーションを上げる例として、Reactでよく使われるイディオムを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d994c8247e9b514f90a5e611ee46421248799ee9" translate="yes" xml:space="preserve">
          <source>As a result of having weak dynamic typing, JavaScript doesn&amp;rsquo;t have any of these, you can use any type at any time.</source>
          <target state="translated">動的な型付けが弱いため、JavaScriptにはこれらがなく、いつでも任意の型を使用できます。</target>
        </trans-unit>
        <trans-unit id="ede9cdf7589df1689a4530c061cb9167ab6ff6e9" translate="yes" xml:space="preserve">
          <source>As a workaround, you can specify the property not present in &lt;code&gt;A&lt;/code&gt; as optional. For example:</source>
          <target state="translated">回避策として、 &lt;code&gt;A&lt;/code&gt; に存在しないプロパティをオプションとして指定できます。例えば：</target>
        </trans-unit>
        <trans-unit id="668bad0a3b1e2602a10cbca6af8ca3251f27e688" translate="yes" xml:space="preserve">
          <source>As an example, this would not work:</source>
          <target state="translated">例として、これではうまくいきません。</target>
        </trans-unit>
        <trans-unit id="b11d09cc159c523df3005c0738393c9419eb41da" translate="yes" xml:space="preserve">
          <source>As explained in the &lt;a href=&quot;options&quot;&gt;&lt;code&gt;sharedmemory.dirs&lt;/code&gt;&lt;/a&gt; option&amp;rsquo;s description, Flow needs to create a file on a filesystem for older kernels. &lt;code&gt;sharedmemory.dirs&lt;/code&gt; specifies a list of locations where the shared memory file can be created. For each location, Flow will check to make sure the filesystem has enough space for the shared memory file. If Flow will likely run out of space, it skips that location and tries the next. This option lets you configure the minimum amount of space needed on a filesystem for shared memory.</source>
          <target state="translated">&lt;a href=&quot;options&quot;&gt; &lt;code&gt;sharedmemory.dirs&lt;/code&gt; &lt;/a&gt;オプションの説明で説明されているように、フローは古いカーネルのファイルシステムにファイルを作成する必要があります。 &lt;code&gt;sharedmemory.dirs&lt;/code&gt; は、共有メモリファイルを作成できる場所のリストを指定します。各場所について、フローはファイルシステムに共有メモリファイル用の十分なスペースがあることを確認します。 Flowがスペースを使い果たす可能性がある場合、その場所をスキップして次の場所を試行します。このオプションを使用すると、ファイルシステムで共有メモリ用に必要な最小容量を構成できます。</target>
        </trans-unit>
        <trans-unit id="2073dcd9de74f00e347d42b3bc3960e160aea0a5" translate="yes" xml:space="preserve">
          <source>As the name hints, &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; is the type representing the set difference of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, i.e. &lt;code&gt;A \ B&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are both &lt;a href=&quot;../objects&quot;&gt;object types&lt;/a&gt;. Here&amp;rsquo;s an example:</source>
          <target state="translated">名前からわかるように、 &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; は、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; のセットの差を表す&lt;a href=&quot;../objects&quot;&gt;タイプ&lt;/a&gt;です。つまり、 &lt;code&gt;A \ B&lt;/code&gt; で、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; はどちらもオブジェクトタイプです。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="4d3ad0d71f6c8ca89c8bf0a20c87797e4687d205" translate="yes" xml:space="preserve">
          <source>As this example shows, declaration files must be written with care: it is up to the programmer to ensure they are correct, otherwise they may hide type errors.</source>
          <target state="translated">この例が示すように、宣言ファイルは注意して書かなければなりません。</target>
        </trans-unit>
        <trans-unit id="462ea53149f64cdf8d1c87506946781343ce500f" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the example is not a random one. &lt;code&gt;$Diff&lt;/code&gt; is exactly what the React definition file uses to define the type of the props accepted by a React Component.</source>
          <target state="translated">お気づきかもしれませんが、この例はランダムなものではありません。 &lt;code&gt;$Diff&lt;/code&gt; は、React定義ファイルがReactコンポーネントが受け入れる小道具のタイプを定義するために使用するものとまったく同じです。</target>
        </trans-unit>
        <trans-unit id="75050d15c413d5f7a029e56def34919e7565c848" translate="yes" xml:space="preserve">
          <source>Asserting types in this way works the same as types do anywhere else.</source>
          <target state="translated">このようにして型をアサートすることは、型が他のどこにでもあるのと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="b7d56c19c3e1b18d86bf5280c85cef8d6ab8b6c5" translate="yes" xml:space="preserve">
          <source>Assume we have two classes, which have a subtype relationship:</source>
          <target state="translated">サブタイプの関係にある2つのクラスがあるとします。</target>
        </trans-unit>
        <trans-unit id="65b9fcb33e463a779d0c4da859a5125301fe7b6c" translate="yes" xml:space="preserve">
          <source>Async functions implicitly return a promise, so the return type must always be a &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">非同期関数は暗黙的にpromiseを返すため、戻り値の型は常に &lt;code&gt;Promise&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="9f01eb47108bfcd61bcd85d17fd5db43d8fe4fc5" translate="yes" xml:space="preserve">
          <source>Autocomplete-Flow</source>
          <target state="translated">Autocomplete-Flow</target>
        </trans-unit>
        <trans-unit id="7e6cbee16a2c2ad4b26fab2aa6ec8127618ef362" translate="yes" xml:space="preserve">
          <source>Available Lint Rules</source>
          <target state="translated">利用可能なリントルール</target>
        </trans-unit>
        <trans-unit id="48315d4da6f457296128d582ea2ac7a8107a6caa" translate="yes" xml:space="preserve">
          <source>Available options</source>
          <target state="translated">利用可能なオプション</target>
        </trans-unit>
        <trans-unit id="5701e01de65130c0af0004b67af666b5f9d12faa" translate="yes" xml:space="preserve">
          <source>Avoid leaking &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">漏洩しないでください &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="cc9d9ae632880006314a40c1e1b1e575e801e3d5" translate="yes" xml:space="preserve">
          <source>Babel also &lt;a href=&quot;https://flow.org/en/tools/create-react-app/&quot;&gt;works out of the box with Create React App&lt;/a&gt;, just install Flow and create a &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">Babel &lt;a href=&quot;https://flow.org/en/tools/create-react-app/&quot;&gt;は、そのままでCreate React App&lt;/a&gt;でも機能します &lt;code&gt;.flowconfig&lt;/code&gt; インストールして.flowconfigを作成するだけです。</target>
        </trans-unit>
        <trans-unit id="1d82284dd6071c5a7679a0d983aaaae31a00b7b5" translate="yes" xml:space="preserve">
          <source>Be liberal with enabling Flow Strict. Unlike adding or removing &lt;code&gt;@flow&lt;/code&gt;, adding or removing &lt;code&gt;@flow strict&lt;/code&gt; (by itself) does not change Flow coverage. It only prevents or allows certain new unsafe behavior from being added in the future. Even if in the future Flow Strict has to be disabled for the file, at least unsafe behavior was prevented from being added in the meantime.</source>
          <target state="translated">Flow Strictを有効にして自由に行動する。 &lt;code&gt;@flow&lt;/code&gt; を追加または削除するのとは異なり、 &lt;code&gt;@flow strict&lt;/code&gt; （それ自体で）追加または削除しても、フローカバレッジは変更されません。将来的に追加される特定の新しい安全でない動作を防止または許可するだけです。将来的には、ファイルに対してFlow Strictを無効にする必要がある場合でも、少なくとも安全でない動作が追加されるのを防ぐことができました。</target>
        </trans-unit>
        <trans-unit id="1680d3465c06ca53c16148fde39b55e52752431c" translate="yes" xml:space="preserve">
          <source>Because Flow understands JavaScript so well, it doesn&amp;rsquo;t need many of these types. You should only ever have to do a minimal amount of work to describe your code to Flow and it will &lt;em&gt;infer&lt;/em&gt; the rest. A lot of the time, Flow can understand your code without any types at all.</source>
          <target state="translated">FlowはJavaScriptをよく理解しているため、これらのタイプの多くは必要ありません。Flowにコードを記述するために必要な作業は最小限で済み、残りは&lt;em&gt;推論&lt;/em&gt;されます。多くの場合、Flowはタイプをまったく含まないコードを理解できます。</target>
        </trans-unit>
        <trans-unit id="404fd91c9a9d241d6c9be8858eb9756bb6b4582e" translate="yes" xml:space="preserve">
          <source>Because of how contravariance works, contravariant properties also become write-only when used. Which can be useful over normal properties.</source>
          <target state="translated">反転がどのように働くかということで、反転プロパティは使用されると書き込み専用になります。これは通常のプロパティよりも便利です。</target>
        </trans-unit>
        <trans-unit id="c880f74f55ee33062612978400cf2ed6b594d1f2" translate="yes" xml:space="preserve">
          <source>Because of how covariance works, covariant properties also become read-only when used. Which can be useful over normal properties.</source>
          <target state="translated">共分散がどのように働くかということで、共分散特性も使用すると読み放題になります。これは通常のプロパティよりも便利です。</target>
        </trans-unit>
        <trans-unit id="3d81cf8083f23d6f8c59a3bff90779ac704e0cb6" translate="yes" xml:space="preserve">
          <source>Because of the &lt;code&gt;typeof value === 'string'&lt;/code&gt; check, Flow knows the &lt;code&gt;value&lt;/code&gt; can only be a &lt;code&gt;string&lt;/code&gt; inside of the &lt;code&gt;if&lt;/code&gt; statement. This is known as a &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;refinement&lt;/a&gt;.</source>
          <target state="translated">そのための &lt;code&gt;typeof value === 'string'&lt;/code&gt; チェック、フローは知っている &lt;code&gt;value&lt;/code&gt; 唯一の可能 &lt;code&gt;string&lt;/code&gt; の内部 &lt;code&gt;if&lt;/code&gt; 陳述。これは&lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;リファインメント&lt;/a&gt;として知られています。</target>
        </trans-unit>
        <trans-unit id="6f57fb076b23f64a15463c71736ac7493ef61f03" translate="yes" xml:space="preserve">
          <source>Because of this behavior, it is a best practice to find or write libdefs for as many of the third-party libraries that you use as you can. We recommend checking out the &lt;code&gt;flow-typed&lt;/code&gt;&lt;a href=&quot;https://github.com/flowtype/flow-typed/blob/master/README.md&quot;&gt;tool and repository&lt;/a&gt; , which helps you quickly find and install pre-existing libdefs for your third-party dependencies.</source>
          <target state="translated">この動作のため、使用するサードパーティライブラリのできるだけ多くのlibdefsを検索または作成することをお勧めします。 &lt;code&gt;flow-typed&lt;/code&gt; &lt;a href=&quot;https://github.com/flowtype/flow-typed/blob/master/README.md&quot;&gt;ツールとリポジトリを&lt;/a&gt;チェックアウトすることをお勧めします。これは、サードパーティの依存関係の既存のlibdefをすばやく見つけてインストールするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="839f87b3fae494fd4e8b9480d1e5f45008a0dc7e" translate="yes" xml:space="preserve">
          <source>Because type casts work the same as all other type annotations, you can only cast values to less specific types. You cannot change the type or make it something more specific.</source>
          <target state="translated">型キャストは他のすべての型アノテーションと同じように動作するため、より特定の型にしか値をキャストすることができません。型を変更したり、より特定の型にしたりすることはできません。</target>
        </trans-unit>
        <trans-unit id="c07a19a41d787635a8e85b3b78306e9c1d7ff5d9" translate="yes" xml:space="preserve">
          <source>Before spending the time to write your own libdef, we recommend that you look to see if there is already a libdef for the third-party code that you&amp;rsquo;re addressing. &lt;code&gt;flow-typed&lt;/code&gt; is a &lt;a href=&quot;https://github.com/flowtype/flow-typed/&quot;&gt;tool and repository&lt;/a&gt; for sharing common libdefs within the Flow community &amp;ndash; so it&amp;rsquo;s a good way to knock out a good chunk of any public libdefs you might need for your project.</source>
          <target state="translated">独自のlibdefを作成するために時間をかける前に、対処しているサードパーティコード用のlibdefがすでにあるかどうかを確認することをお勧めします。 &lt;code&gt;flow-typed&lt;/code&gt; は、Flowコミュニティ内で共通のlibdefを共有するための&lt;a href=&quot;https://github.com/flowtype/flow-typed/&quot;&gt;ツールとリポジトリです&lt;/a&gt;。そのため、プロジェクトに必要となる可能性のあるパブリックlibdefのかなりの部分をノックアウトするための良い方法です。</target>
        </trans-unit>
        <trans-unit id="ffd8520b4ea61ae236ddd4d1f4143845bd5bc375" translate="yes" xml:space="preserve">
          <source>Before we show how to type a React class component with Flow, let us first show how you would write a React class component &lt;em&gt;without&lt;/em&gt; Flow but with React&amp;rsquo;s prop types. You would extend &lt;code&gt;React.Component&lt;/code&gt; and add a static &lt;code&gt;propTypes&lt;/code&gt; property.</source>
          <target state="translated">フローを使用してReactクラスコンポーネントを入力する方法を示す前に、フロー&lt;em&gt;なし&lt;/em&gt;でReactのプロップタイプを使用して、Reactクラスコンポーネント&lt;em&gt;を&lt;/em&gt;作成する方法を最初に示します。 &lt;code&gt;React.Component&lt;/code&gt; を拡張し、静的な &lt;code&gt;propTypes&lt;/code&gt; プロパティを追加します。</target>
        </trans-unit>
        <trans-unit id="2b1e005429a327929c485a9cce3808a1145b8aa0" translate="yes" xml:space="preserve">
          <source>Behavior of generics</source>
          <target state="translated">ジェネリック医薬品の挙動</target>
        </trans-unit>
        <trans-unit id="e82cf40f53265657d5832c1308bdb8b249dbe424" translate="yes" xml:space="preserve">
          <source>Bivariance</source>
          <target state="translated">Bivariance</target>
        </trans-unit>
        <trans-unit id="408adf1c6e528212e5ff5ec2ce7d7e888977db8a" translate="yes" xml:space="preserve">
          <source>Bivariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">共分散&lt;em&gt;は&lt;/em&gt;&lt;strong&gt;サブタイプを&lt;/strong&gt;受け入れます。</target>
        </trans-unit>
        <trans-unit id="bf56a8499cffbc9b99a5c626b8e4f47f74fb6f88" translate="yes" xml:space="preserve">
          <source>Bivariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">共分散&lt;em&gt;は&lt;/em&gt;&lt;strong&gt;スーパータイプを&lt;/strong&gt;受け入れます。</target>
        </trans-unit>
        <trans-unit id="bcd9e69ceceba4abeefdd82a9dfed379a6547be2" translate="yes" xml:space="preserve">
          <source>Boolean types need you to be explicit by converting non-booleans. You can do that with &lt;code&gt;Boolean(x)&lt;/code&gt; or &lt;code&gt;!!x&lt;/code&gt;.</source>
          <target state="translated">ブール型では、非ブールを変換することによって明示的にする必要があります。これは &lt;code&gt;Boolean(x)&lt;/code&gt; または &lt;code&gt;!!x&lt;/code&gt; 実行できます。</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="aeaf4741c43124d50887c3856fa57da08ef729d3" translate="yes" xml:space="preserve">
          <source>Booleans are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; values in JavaScript. The &lt;code&gt;boolean&lt;/code&gt; type in Flow accepts these values.</source>
          <target state="translated">ブール値は、JavaScriptでは &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; の値です。フローの &lt;code&gt;boolean&lt;/code&gt; 型はこれらの値を受け入れます。</target>
        </trans-unit>
        <trans-unit id="1845c94e71026f36d7237c0f0214aa3d8c3ce37d" translate="yes" xml:space="preserve">
          <source>Booleans: like &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">ブール値： &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; など</target>
        </trans-unit>
        <trans-unit id="7494e6ec8cd7b2eb5a14c1e063217659a8a1ed3a" translate="yes" xml:space="preserve">
          <source>Broken example:</source>
          <target state="translated">壊れた例</target>
        </trans-unit>
        <trans-unit id="f031d4d730e754281da3ddefefd685153cc7e2c0" translate="yes" xml:space="preserve">
          <source>But Flow should understand that this function cannot invalidate this refinement, right?</source>
          <target state="translated">でも、この関数はこのリファインを無効にすることはできないとFlowは理解しているはずですよね?</target>
        </trans-unit>
        <trans-unit id="421430d7200437b9bff784aea6c385eb54e83ace" translate="yes" xml:space="preserve">
          <source>But JavaScript ignores these comments, so all it has is the valid syntax.</source>
          <target state="translated">しかし、JavaScriptはこれらのコメントを無視するので、有効な構文しかありません。</target>
        </trans-unit>
        <trans-unit id="9bcf9a6dad7d351fd124803ac3fa5511232e6ff7" translate="yes" xml:space="preserve">
          <source>But as soon as you change the shape it will start to cause errors.</source>
          <target state="translated">しかし、形を変えた途端にエラーが出始めます。</target>
        </trans-unit>
        <trans-unit id="961b391c2d9d40cf6976473efc025458ffadca5a" translate="yes" xml:space="preserve">
          <source>But now we have a problem. Our &lt;code&gt;typeof obj&lt;/code&gt; annotation also gets this new annotation which defeats the entire purpose.</source>
          <target state="translated">しかし今、私たちは問題を抱えています。私たち &lt;code&gt;typeof obj&lt;/code&gt; 注釈も全体の目的に反し、この新しい注釈を取得します。</target>
        </trans-unit>
        <trans-unit id="0a7b7f1f4fc53f9d61a2d8e4846e79d6d5218c5c" translate="yes" xml:space="preserve">
          <source>But suppose you only want to allow strings in your function. For that you can add types.</source>
          <target state="translated">しかし、関数内で文字列だけを許可したいとします。そのためには、型を追加することができます。</target>
        </trans-unit>
        <trans-unit id="eeada9e2d3835e3320e9297e7d171eb9198c4546" translate="yes" xml:space="preserve">
          <source>But we also need to compare the types of the values. If both objects had a key &lt;code&gt;foo&lt;/code&gt; but one was a &lt;code&gt;number&lt;/code&gt; and the other was a &lt;code&gt;string&lt;/code&gt;, then one would not be the subtype of the other.</source>
          <target state="translated">ただし、値のタイプを比較する必要もあります。両方のオブジェクトにキー &lt;code&gt;foo&lt;/code&gt; があり、一方が &lt;code&gt;number&lt;/code&gt; でもう一方が &lt;code&gt;string&lt;/code&gt; 場合、一方は他方のサブタイプにはなりません。</target>
        </trans-unit>
        <trans-unit id="0b1dae6be8224d27747e5314d54153e505cce8cb" translate="yes" xml:space="preserve">
          <source>But when objects are sealed, Flow will not allow you to add new properties to them.</source>
          <target state="translated">しかし、オブジェクトが封印されている場合、Flowではオブジェクトに新しいプロパティを追加することができません。</target>
        </trans-unit>
        <trans-unit id="66ff1b2d0fd5745355740b15ee2b612dc315d816" translate="yes" xml:space="preserve">
          <source>But when you have properties that overlap by having the same name, it creates an intersection of the property type as well.</source>
          <target state="translated">しかし、同じ名前を持つことで重なるプロパティがある場合は、プロパティタイプも同じように交点ができてしまいます。</target>
        </trans-unit>
        <trans-unit id="30753facf6dcd87d6a5e7d8483dce119cb47531c" translate="yes" xml:space="preserve">
          <source>But when you use &lt;code&gt;typeof&lt;/code&gt;, you&amp;rsquo;re taking the results of Flow&amp;rsquo;s inference and asserting it as a type. While this can be very useful, it can also lead to some unexpected results.</source>
          <target state="translated">しかし、 &lt;code&gt;typeof&lt;/code&gt; を使用すると、フローの推論の結果を取得し、それを型としてアサートします。これは非常に便利ですが、予期しない結果が生じることもあります。</target>
        </trans-unit>
        <trans-unit id="402c1e1505aa711e14641f9e0cbdd3c126cb8608" translate="yes" xml:space="preserve">
          <source>But you can use any to cast to whatever type you want.</source>
          <target state="translated">でも、好きなタイプにキャストするには、どれを使ってもいいんです。</target>
        </trans-unit>
        <trans-unit id="380728668d9cfaeeebed3b2bcfa77a400e52a7a2" translate="yes" xml:space="preserve">
          <source>But you can&amp;rsquo;t possibly create a value which is both a &lt;em&gt;number and a string&lt;/em&gt;, but you can create a type for it. There&amp;rsquo;s no practical use for creating types like this, but it&amp;rsquo;s a side effect of how intersection types work.</source>
          <target state="translated">ただし、&lt;em&gt;数値と文字列の&lt;/em&gt;両方である値を作成することはできませんが、そのための型を作成することはできます。このようなタイプを作成する実用的な使用法はありませんが、交差タイプの機能の副作用です。</target>
        </trans-unit>
        <trans-unit id="a559e18c54711bce2c3c1b5537b218d29bf4a48b" translate="yes" xml:space="preserve">
          <source>But you&amp;rsquo;ll want to use more specific types for your actions using disjoint unions and each individual type of action.</source>
          <target state="translated">ただし、分離した共用体と個々のタイプのアクションを使用して、より具体的なタイプのアクションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="75d7327a8eec333652ce1fe3a29a224e1b4e6477" translate="yes" xml:space="preserve">
          <source>By casting the value to any, you can then cast to whatever you want.</source>
          <target state="translated">値を任意のものにキャストすることで、好きなものにキャストすることができます。</target>
        </trans-unit>
        <trans-unit id="ea11ddf576cb4458685c2b63ba3622020aced4f3" translate="yes" xml:space="preserve">
          <source>By checking every possible value, Flow might catch errors that will not actually occur when the code is run. Flow does this in order to be &lt;em&gt;&amp;ldquo;sound&amp;rdquo;&lt;/em&gt;.</source>
          <target state="translated">可能なすべての値をチェックすることにより、コードの実行時に実際には発生しないエラーをフローがキャッチする場合があります。Flowはこれを&lt;em&gt;「サウンド」&lt;/em&gt;にするために行います。</target>
        </trans-unit>
        <trans-unit id="888a90a8461cf1dcf2dfa9475b824abf2a140082" translate="yes" xml:space="preserve">
          <source>By checking the typeof our value and testing to see if it is a number, Flow knows that inside of that block it is only a number. We can then write code which treats our value as a number inside of that block.</source>
          <target state="translated">値の型をチェックし、それが数値であるかどうかをテストすることで、Flowはそのブロック内では数値であることを知っています。これで、ブロック内で値を数値として扱うコードを書くことができます。</target>
        </trans-unit>
        <trans-unit id="41e166bbfa292c608c082d1714c483c0896b791e" translate="yes" xml:space="preserve">
          <source>By default it is 536870912 (2^29 bytes, which is half a gigabyte).</source>
          <target state="translated">デフォルトでは536870912(2^29バイト、ギガバイトの半分)です。</target>
        </trans-unit>
        <trans-unit id="50633f3514931f4fa2e84559a298e46e3f897949" translate="yes" xml:space="preserve">
          <source>By default this is 0.</source>
          <target state="translated">デフォルトでは0になっています。</target>
        </trans-unit>
        <trans-unit id="15c3b3f03676e9fef47c839d9f3979c86d9e53d7" translate="yes" xml:space="preserve">
          <source>By default this is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="53bf9ecbf110fc31e84ab1d4ed08e51aaa3096ed" translate="yes" xml:space="preserve">
          <source>By default this option is set to &lt;code&gt;/dev/shm&lt;/code&gt; and &lt;code&gt;/tmp&lt;/code&gt;</source>
          <target state="translated">デフォルトでは、このオプションは &lt;code&gt;/dev/shm&lt;/code&gt; および &lt;code&gt;/tmp&lt;/code&gt; に設定されています</target>
        </trans-unit>
        <trans-unit id="0c9574b97e4aad17c08cdb93e1e1659dc17a8a5d" translate="yes" xml:space="preserve">
          <source>By default when you re-assign a variable, Flow will give it the type of all possible assignments.</source>
          <target state="translated">デフォルトでは、変数を再代入すると、Flowはその変数に可能なすべての代入の型を与えます。</target>
        </trans-unit>
        <trans-unit id="134864792720213ebc4bc0075f47cc4f80136ea2" translate="yes" xml:space="preserve">
          <source>By default, Flow will look for files with the extensions &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.mjs&lt;/code&gt; and &lt;code&gt;.json&lt;/code&gt;. You can override this behavior with this option.</source>
          <target state="translated">デフォルトでは、フローの拡張子を持つファイルを探します &lt;code&gt;.js&lt;/code&gt; ファイル、 &lt;code&gt;.jsx&lt;/code&gt; の、 &lt;code&gt;.mjs&lt;/code&gt; と &lt;code&gt;.json&lt;/code&gt; 。このオプションでこの動作を上書きできます。</target>
        </trans-unit>
        <trans-unit id="c01f8c4e09478deb33d4af8e9963cfec032edd46" translate="yes" xml:space="preserve">
          <source>By default, Flow will look in directories named &lt;code&gt;node_modules&lt;/code&gt; for node modules. You can configure this behavior with this option.</source>
          <target state="translated">デフォルトでは、Flowはノードモジュールの &lt;code&gt;node_modules&lt;/code&gt; という名前のディレクトリを検索します。このオプションでこの動作を構成できます。</target>
        </trans-unit>
        <trans-unit id="09b5075116fd3869d9cadd377bad839d72504028" translate="yes" xml:space="preserve">
          <source>By default, the Flow server will typecheck all your code. This way it can answer questions like &amp;ldquo;are there any Flow errors anywhere in my code&amp;rdquo;. This is very useful for tooling, like a continuous integration hook which prevents code changes which introduce Flow errors.</source>
          <target state="translated">デフォルトでは、フローサーバーはすべてのコードをタイプチェックします。これにより、「コード内のどこかにフローエラーはありますか」などの質問に答えることができます。これは、フローエラーを引き起こすコードの変更を防ぐ継続的インテグレーションフックなどのツールに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="fd76a70149a54159a0fc3b1090cb3ea08262b1cc" translate="yes" xml:space="preserve">
          <source>By default, this is set to 19 (Table size is 2^19, which is 8 megabytes)</source>
          <target state="translated">デフォルトでは19に設定されています(テーブルサイズは2^19で8メガバイト)。</target>
        </trans-unit>
        <trans-unit id="7ff7ddf4cc91afce590edc441693a3db98fd3736" translate="yes" xml:space="preserve">
          <source>By default, this is set to 26843545600 (25 * 2^30 bytes, which is 25GiB)</source>
          <target state="translated">デフォルトでは、これは26843545600(25*2^30バイト、つまり25GiB)に設定されています。</target>
        </trans-unit>
        <trans-unit id="acbb4b73f95bada54b37ed5bbd4fe52f109cb99a" translate="yes" xml:space="preserve">
          <source>CLI Commands</source>
          <target state="translated">CLIコマンド</target>
        </trans-unit>
        <trans-unit id="6d43703db2da8bdf8468b95d1594c5dba316eb10" translate="yes" xml:space="preserve">
          <source>Calculates a config object from props and default props. This is most useful for annotating HOCs that are abstracted over configs. See our &lt;a href=&quot;../hoc&quot;&gt;docs on writing HOCs&lt;/a&gt; for more information.</source>
          <target state="translated">小道具とデフォルトの小道具から設定オブジェクトを計算します。これは、構成上で抽象化されたHOCに注釈を付ける場合に最も役立ちます。詳細については、&lt;a href=&quot;../hoc&quot;&gt;HOCの記述&lt;/a&gt;に関するドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="97da5c1835399f071d43358b9774ddca050daf60" translate="yes" xml:space="preserve">
          <source>Callable Objects</source>
          <target state="translated">呼び出し可能なオブジェクト</target>
        </trans-unit>
        <trans-unit id="3a313789e66d78fc3c3729e779158ab414b6007d" translate="yes" xml:space="preserve">
          <source>Callable objects can be typed, for example:</source>
          <target state="translated">呼び出し可能なオブジェクトは、例えば型付けすることができます。</target>
        </trans-unit>
        <trans-unit id="c139cc9f6d79ac3a638f7ccf61f2b9637d567c2a" translate="yes" xml:space="preserve">
          <source>Cannot use mutating array methods on tuples</source>
          <target state="translated">タプルで配列の突然変異メソッドを使用できない</target>
        </trans-unit>
        <trans-unit id="ee70a9dd51b9b3a375656ccfb82a0044b5db1ef2" translate="yes" xml:space="preserve">
          <source>Caret ranges, which allow changes that do not modify the left-most non-zero digit (e.g. &lt;code&gt;^0.13.0&lt;/code&gt; expands into &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt;, and &lt;code&gt;^0.13.1&lt;/code&gt; expands into &lt;code&gt;&amp;gt;=0.13.1 &amp;lt;0.14.0&lt;/code&gt;, whereas &lt;code&gt;^1.2.3&lt;/code&gt; expands into &lt;code&gt;&amp;gt;=1.2.3 &amp;lt;2.0.0&lt;/code&gt;).</source>
          <target state="translated">左端のゼロ以外の数字を変更しない変更を可能にするキャレット範囲（たとえば、 &lt;code&gt;^0.13.0&lt;/code&gt; は &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt; に拡張され、 &lt;code&gt;^0.13.1&lt;/code&gt; は &lt;code&gt;&amp;gt;=0.13.1 &amp;lt;0.14.0&lt;/code&gt; 拡張されます.0、一方 &lt;code&gt;^1.2.3&lt;/code&gt; は &lt;code&gt;&amp;gt;=1.2.3 &amp;lt;2.0.0&lt;/code&gt; に展開されます）。</target>
        </trans-unit>
        <trans-unit id="6fe0f312fa3428aa6c4fdee3743c37967749d48e" translate="yes" xml:space="preserve">
          <source>Check Your Code</source>
          <target state="translated">コードを確認する</target>
        </trans-unit>
        <trans-unit id="b73433b77514508ea8a1cefa58845c9ce4425fe1" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://flow.org/en/linting&quot;&gt;linting docs&lt;/a&gt; for more information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://flow.org/en/linting&quot;&gt;lintingのドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="18c18b8a20dbe7477ce5e5b3ea1624b99b154cdc" translate="yes" xml:space="preserve">
          <source>Checks JavaScript files for type errors on save</source>
          <target state="translated">保存時にJavaScriptファイルの型エラーをチェック</target>
        </trans-unit>
        <trans-unit id="dcf75191c585bfb6059ad203f7ce5630a589a405" translate="yes" xml:space="preserve">
          <source>Children</source>
          <target state="translated">Children</target>
        </trans-unit>
        <trans-unit id="ea7d82eca3471176f477c2cedc92c146814951f8" translate="yes" xml:space="preserve">
          <source>Choosing Focused Files</source>
          <target state="translated">フォーカスされたファイルの選択</target>
        </trans-unit>
        <trans-unit id="dd9e83c06b2948588c35a377c68a9e504e82cd53" translate="yes" xml:space="preserve">
          <source>Class Components</source>
          <target state="translated">クラスコンポーネント</target>
        </trans-unit>
        <trans-unit id="a292b9b612431489a82ca75b9a01310364d94fec" translate="yes" xml:space="preserve">
          <source>Class Fields (Properties)</source>
          <target state="translated">クラスフィールド(プロパティ</target>
        </trans-unit>
        <trans-unit id="c29b94bc81534772a515451e3a6176277b7a484c" translate="yes" xml:space="preserve">
          <source>Class Generics</source>
          <target state="translated">クラスジェネリック</target>
        </trans-unit>
        <trans-unit id="3d9f77136533c6ff7b7e86c9e68a8e0e99ad867e" translate="yes" xml:space="preserve">
          <source>Class Methods</source>
          <target state="translated">クラスメソッド</target>
        </trans-unit>
        <trans-unit id="00da90a4700b284083533dbd6e4a5418d77ae7c4" translate="yes" xml:space="preserve">
          <source>Class Syntax</source>
          <target state="translated">クラス構文</target>
        </trans-unit>
        <trans-unit id="970423396db9a5db3ab146030f36eab03c9bccf9" translate="yes" xml:space="preserve">
          <source>Class Types</source>
          <target state="translated">クラスの種類</target>
        </trans-unit>
        <trans-unit id="7ef245513b7358326754969c6ff56632c31d10bb" translate="yes" xml:space="preserve">
          <source>Class generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use a class as a type you need to pass parameters for each of its generics.</source>
          <target state="translated">クラスジェネリックは&lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;パラメータ化されています&lt;/a&gt;。クラスを型として使用する場合、そのジェネリックのそれぞれにパラメーターを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="1ac68839be9322d234cbe8b1175e8660eac2c1db" translate="yes" xml:space="preserve">
          <source>Classes (when being used as a type), type aliases, and interfaces all require that you pass type arguments. Functions and function types do not have parameterized generics.</source>
          <target state="translated">クラス(型として使用される場合)、型のエイリアス、インタフェースはすべて、型の引数を渡す必要があります。関数や関数型にはパラメータ化されたジェネリックはありません。</target>
        </trans-unit>
        <trans-unit id="3164faf12698fd9d5a1ee175d4e32c8f3b28733b" translate="yes" xml:space="preserve">
          <source>Classes are nominally typed</source>
          <target state="translated">クラスは名目上型付けされています。</target>
        </trans-unit>
        <trans-unit id="09580fd8cc5532206f6976398f34d1aa760f93c6" translate="yes" xml:space="preserve">
          <source>Classes can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">クラスは独自の&lt;a href=&quot;../generics&quot;&gt;ジェネリックを&lt;/a&gt;持つこともできます。</target>
        </trans-unit>
        <trans-unit id="5fda3adeadc4a4501aa999874c1179a4ba1c688c" translate="yes" xml:space="preserve">
          <source>Classes can create generics by placing the type parameter list before the body of the class.</source>
          <target state="translated">クラスは、クラスのボディの前にタイプ・パラメータ・リストを配置することでジェネリックを作成することができます。</target>
        </trans-unit>
        <trans-unit id="1b808e1e4ae68ed6db8b6f4a3b08980e0757a73a" translate="yes" xml:space="preserve">
          <source>Classes in Flow are identical to normal JavaScript classes, but with added types.</source>
          <target state="translated">Flowのクラスは通常のJavaScriptのクラスと同じですが、型が追加されています。</target>
        </trans-unit>
        <trans-unit id="452b035012ae20e8fba0cecbb4575853da83a21c" translate="yes" xml:space="preserve">
          <source>Classes in Flow are nominally typed. This means that when you have two separate classes you cannot use one in place of the other even when they have the same exact properties and methods.</source>
          <target state="translated">Flowのクラスは名目上型付けされています。これは、2つの別々のクラスを持っている場合、たとえ同じプロパティやメソッドを持っていても、一方を他方の代わりに使うことはできないということを意味しています。</target>
        </trans-unit>
        <trans-unit id="c07a614cc79da75bb9b47692238ba51e242a3c47" translate="yes" xml:space="preserve">
          <source>Classes with generics</source>
          <target state="translated">ジェネリックを使ったクラス</target>
        </trans-unit>
        <trans-unit id="a3966ac02425c85de4503912eef3010180d093f6" translate="yes" xml:space="preserve">
          <source>Classifying Files</source>
          <target state="translated">ファイルの分類</target>
        </trans-unit>
        <trans-unit id="4060649bc0fbf1a753996c990ce6ff425ec633c7" translate="yes" xml:space="preserve">
          <source>Comment Types</source>
          <target state="translated">どのようにタイプ</target>
        </trans-unit>
        <trans-unit id="e20aa320a16fc33b19be9bd963333288cc2fbcd3" translate="yes" xml:space="preserve">
          <source>Comment support was added in v0.23.0. Lines beginning with zero or more spaces followed by an &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;💩&lt;/code&gt; are ignored. For example:</source>
          <target state="translated">コメントのサポートはv0.23.0で追加されました。0個以上のスペースで始まり、その後に &lt;code&gt;#&lt;/code&gt; または &lt;code&gt;;&lt;/code&gt; が続く行 または &lt;code&gt;💩&lt;/code&gt; は無視されます。例えば：</target>
        </trans-unit>
        <trans-unit id="7a3c18b9e3a38eaea2ce3317736de762da172d50" translate="yes" xml:space="preserve">
          <source>Comment type annotation</source>
          <target state="translated">コメントタイプのアノテーション</target>
        </trans-unit>
        <trans-unit id="3fdb12dbd0fc63c594f614d2015983c4d8a7cc47" translate="yes" xml:space="preserve">
          <source>Comment type include</source>
          <target state="translated">コメントタイプには以下が含まれます。</target>
        </trans-unit>
        <trans-unit id="2a30d59a808479157403fbf163a7b1b950362562" translate="yes" xml:space="preserve">
          <source>Comment types syntax</source>
          <target state="translated">構文の種類</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="77cd370c5563644ed24d98dbd212c70fede32f4e" translate="yes" xml:space="preserve">
          <source>CommonJS modules have a single value that is exported (the &lt;code&gt;module.exports&lt;/code&gt; value). To describe the type of this single value within a &lt;code&gt;declare module&lt;/code&gt; body, you&amp;rsquo;ll use the &lt;code&gt;declare module.exports&lt;/code&gt; syntax:</source>
          <target state="translated">CommonJSモジュールには、エクスポートされる単一の値（ &lt;code&gt;module.exports&lt;/code&gt; 値）があります。 &lt;code&gt;declare module&lt;/code&gt; 本体内でこの単一の値のタイプを説明するには、 &lt;code&gt;declare module.exports&lt;/code&gt; 構文を使用します。</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="357ded9bfca85d8cbd26f40a3524ddda69561b80" translate="yes" xml:space="preserve">
          <source>Conceptually one can think of declaration mode as if Flow still typechecks the files but acts as if there is a comment that matches &lt;code&gt;suppress_comment&lt;/code&gt; on every line.</source>
          <target state="translated">概念的には、宣言モードを、フローがファイルをタイプチェックするかのように考えることができますが、すべての行の &lt;code&gt;suppress_comment&lt;/code&gt; に一致するコメントがあるかのように機能します。</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="17e8e4decf7d96f7f04f6c0aaf456c37aae4e8a7" translate="yes" xml:space="preserve">
          <source>Configure ALE to use the &lt;code&gt;flow-language-server&lt;/code&gt; linter for JavaScript files:</source>
          <target state="translated">JavaScriptファイルに &lt;code&gt;flow-language-server&lt;/code&gt; linter を使用するように ALEを構成します。</target>
        </trans-unit>
        <trans-unit id="b41a81e0d51029fe68417fdfc1818a6ce70ba9c2" translate="yes" xml:space="preserve">
          <source>Configuring Lints from the CLI</source>
          <target state="translated">CLIからリントを設定する</target>
        </trans-unit>
        <trans-unit id="8e2382fbc54df1efc6f7e32e65cd9c5d7c95a4c6" translate="yes" xml:space="preserve">
          <source>Configuring Lints in the &lt;code&gt;.flowconfig&lt;/code&gt;</source>
          <target state="translated">で設定Lints &lt;code&gt;.flowconfig&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="100fcd8a929b3ce3c89e968bb90a967ea5146ece" translate="yes" xml:space="preserve">
          <source>Configuring Lints with Comments</source>
          <target state="translated">コメントでリントを設定する</target>
        </trans-unit>
        <trans-unit id="ea1be7edf59f5de51b594f9fbae2368f8449e70c" translate="yes" xml:space="preserve">
          <source>Configuring lint settings with &lt;code&gt;flowlint&lt;/code&gt; comments allows you to specify different settings within a file and different settings to different regions of different files. These comments come in three forms:</source>
          <target state="translated">&lt;code&gt;flowlint&lt;/code&gt; コメントを使用してlint設定を構成すると、ファイル内のさまざまな設定と、さまざまなファイルのさまざまな領域にさまざまな設定を指定できます。これらのコメントには3つの形式があります。</target>
        </trans-unit>
        <trans-unit id="5459dd4dd0d0aff9d4c5e0bb04ffd680814c6d9f" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;TypeLetters&lt;/code&gt; which described the strings: &amp;ldquo;A&amp;rdquo;, &amp;ldquo;B&amp;rdquo;, &amp;ldquo;C&amp;rdquo;, and a &lt;code&gt;TypeNumbers&lt;/code&gt; which described the numbers: 1, 2, 3. Neither of them would be a subtype of the other, as they each contain a completely different set of values.</source>
          <target state="translated">検討 &lt;code&gt;TypeLetters&lt;/code&gt; 文字列を記載：「A」、「B」、「C」、および &lt;code&gt;TypeNumbers&lt;/code&gt; 番号を記載：彼ら各々が含むように1、2、3いずれもそれらのは、他のサブタイプであろう完全に異なる値のセット。</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="bd6cc06a58d88fe388d82365f6c350095732e612" translate="yes" xml:space="preserve">
          <source>Contravariance</source>
          <target state="translated">Contravariance</target>
        </trans-unit>
        <trans-unit id="cb180a0b2985d8db3f02bd050b0c5682ab094c05" translate="yes" xml:space="preserve">
          <source>Contravariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">反変&lt;em&gt;はしない&lt;/em&gt;&lt;strong&gt;サブタイプを&lt;/strong&gt;受け入れ。</target>
        </trans-unit>
        <trans-unit id="c1af28bd0de937b51db3bbee9579b53603a2e45c" translate="yes" xml:space="preserve">
          <source>Contravariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">反変&lt;em&gt;は&lt;/em&gt;&lt;strong&gt;スーパータイプを&lt;/strong&gt;受け入れます。</target>
        </trans-unit>
        <trans-unit id="f1840a661bb88bcb72aa63857962824a747fab2e" translate="yes" xml:space="preserve">
          <source>Contravariant (write-only) properties on interfaces</source>
          <target state="translated">インターフェイス上の矛盾した (書き込み専用)プロパティ</target>
        </trans-unit>
        <trans-unit id="d37d133ea5c1b52753b3893f902c233ee8442bb5" translate="yes" xml:space="preserve">
          <source>Covariance</source>
          <target state="translated">Covariance</target>
        </trans-unit>
        <trans-unit id="2f10ee60c3d51dffb8e99aab19b27d99124ad7c4" translate="yes" xml:space="preserve">
          <source>Covariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">共分散&lt;em&gt;はしません&lt;/em&gt;&lt;strong&gt;スーパータイプを&lt;/strong&gt;受け入れ。</target>
        </trans-unit>
        <trans-unit id="a1fa2bb1d0052e924cece0736a3a2248a64883bc" translate="yes" xml:space="preserve">
          <source>Covariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">共分散&lt;em&gt;は&lt;/em&gt;&lt;strong&gt;サブタイプを&lt;/strong&gt;受け入れます。</target>
        </trans-unit>
        <trans-unit id="6a3e204ca6009adaaa624087ce1b64b315a8aef0" translate="yes" xml:space="preserve">
          <source>Covariant (read-only) properties on interfaces</source>
          <target state="translated">インターフェースの共分散(読み取り専用)プロパティ</target>
        </trans-unit>
        <trans-unit id="a1d8b1686c9450f38df6ec567189c88fa8e65f62" translate="yes" xml:space="preserve">
          <source>Create React App</source>
          <target state="translated">Reactアプリを作成する</target>
        </trans-unit>
        <trans-unit id="0bf0dd44b7766be1f57889796955a258d3203142" translate="yes" xml:space="preserve">
          <source>Create as many generics as you need</source>
          <target state="translated">必要な数だけジェネリックを作成</target>
        </trans-unit>
        <trans-unit id="03ce361cea65e5018df3a6c27de3a6593ce0f4ed" translate="yes" xml:space="preserve">
          <source>Creating Library Definitions</source>
          <target state="translated">ライブラリ定義の作成</target>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes" xml:space="preserve">
          <source>Declaration Files</source>
          <target state="translated">宣言ファイル</target>
        </trans-unit>
        <trans-unit id="6c41a0185a4a9cfa2f6df6a748ac7876baa85cb0" translate="yes" xml:space="preserve">
          <source>Declaration mode should only be used for existing third-party code. You should never use this for code under your control.</source>
          <target state="translated">宣言モードは、既存のサードパーティのコードにのみ使用してください。自分の管理下にあるコードには絶対に使用してはいけません。</target>
        </trans-unit>
        <trans-unit id="7377158aaae022f9ae166beb589c5befa8f2034b" translate="yes" xml:space="preserve">
          <source>Declaring A CommonJS Module</source>
          <target state="translated">CommonJSモジュールの宣言</target>
        </trans-unit>
        <trans-unit id="e7912896131236a8a65370bdd893e2009c32c266" translate="yes" xml:space="preserve">
          <source>Declaring A Global Class</source>
          <target state="translated">グローバルクラスの宣言</target>
        </trans-unit>
        <trans-unit id="cf300a0c751ae6bb5689acc80a14bec33cc3173d" translate="yes" xml:space="preserve">
          <source>Declaring A Global Function</source>
          <target state="translated">グローバル関数の宣言</target>
        </trans-unit>
        <trans-unit id="fa2144a7e4ab0959082b21d1945383339a3043f8" translate="yes" xml:space="preserve">
          <source>Declaring A Global Type</source>
          <target state="translated">グローバルタイプの宣言</target>
        </trans-unit>
        <trans-unit id="f140a982a9c52716db37b4e9e5e30630eacfa6f6" translate="yes" xml:space="preserve">
          <source>Declaring A Global Variable</source>
          <target state="translated">グローバル変数の宣言</target>
        </trans-unit>
        <trans-unit id="cf71778c169e234024b86addcbe9ddb1f9d5a9b2" translate="yes" xml:space="preserve">
          <source>Declaring A Module</source>
          <target state="translated">モジュールの宣言</target>
        </trans-unit>
        <trans-unit id="e4ce9329aeac94bfdbc95574fafe7358b946c293" translate="yes" xml:space="preserve">
          <source>Declaring An ES Module</source>
          <target state="translated">ES モジュールの宣言</target>
        </trans-unit>
        <trans-unit id="af087002f31d0ea4e967c16e89ad0e158cdeb097" translate="yes" xml:space="preserve">
          <source>Default Exports</source>
          <target state="translated">デフォルトのエクスポート</target>
        </trans-unit>
        <trans-unit id="7f3b8d79c1988be2a2ba2d6f29be574f525f239e" translate="yes" xml:space="preserve">
          <source>Defines a magical comment that suppresses any Flow errors on the following line. For example:</source>
          <target state="translated">次の行のフローエラーを抑制する魔法のコメントを定義する。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b4e96ce5110d5704ac6b16c56748c7a82fa4b290" translate="yes" xml:space="preserve">
          <source>Depth Subtyping</source>
          <target state="translated">深度サブタイプ</target>
        </trans-unit>
        <trans-unit id="bb3a537f6961c44f6476a0cf4c7c5e6d20651cc7" translate="yes" xml:space="preserve">
          <source>Detailed guides, tips, and resources on how to integrate Flow with different JavaScript tools.</source>
          <target state="translated">FlowをさまざまなJavaScriptツールと統合する方法についての詳細なガイド、ヒント、およびリソース。</target>
        </trans-unit>
        <trans-unit id="5397d84bf20e2c90a75c1c0e9296db893360d2d5" translate="yes" xml:space="preserve">
          <source>Detailed guides, tips, and resources on how to integrate Flow with different code editors.</source>
          <target state="translated">Flowをさまざまなコードエディタに統合する方法についての詳細なガイド、ヒント、リソース。</target>
        </trans-unit>
        <trans-unit id="07b29e4715401afbf688a87a35ce231b8ef245ab" translate="yes" xml:space="preserve">
          <source>Developers like coding in JavaScript because it helps them move fast. The language facilitates fast prototyping of ideas via dynamic typing. The runtime provides the means for fast iteration on those ideas via dynamic compilation. This fuels a fast edit-refresh cycle, which promises an immersive coding experience that is quite appealing to creative developers.</source>
          <target state="translated">開発者はJavaScriptでコーディングするのが好きです。この言語は、動的な型付けによってアイデアのプロトタイプを高速に作成することを可能にします。ランタイムは、動的なコンパイルによって、アイデアの高速な反復処理のための手段を提供します。これにより、高速な編集・更新サイクルが促進され、クリエイティブな開発者にとって魅力的な没入型のコーディング体験が約束されます。</target>
        </trans-unit>
        <trans-unit id="d112a1cd5683bcc108f9cd368dc51e0007d4b649" translate="yes" xml:space="preserve">
          <source>Developers will often use Flow and React together, so it is important that Flow can effectively type both common and advanced React patterns. This guide will teach you how to use Flow to create safer React applications.</source>
          <target state="translated">開発者はFlowとReactを一緒に使うことが多いので、Flowが一般的なReactパターンと高度なReactパターンの両方を効果的に入力できることが重要です。このガイドでは、より安全なReactアプリケーションを作成するためのFlowの使い方をお教えします。</target>
        </trans-unit>
        <trans-unit id="1e6b556971ea4a33002387413d405d2f43ba4f6b" translate="yes" xml:space="preserve">
          <source>Different sections are available to specify different behaviours, and by combining them most use cases are expected to be met.</source>
          <target state="translated">異なる動作を指定するために異なるセクションが用意されており、それらを組み合わせることで、ほとんどのユースケースが満たされることが期待されています。</target>
        </trans-unit>
        <trans-unit id="13f50eb9f26820d014db96a7378f60b1d9165a9e" translate="yes" xml:space="preserve">
          <source>Disjoint Unions</source>
          <target state="translated">バラバラの組合</target>
        </trans-unit>
        <trans-unit id="1a7f91bafa50063f1996b902994e106982ff9d56" translate="yes" xml:space="preserve">
          <source>Disjoint unions require you to use a single property to distinguish each object type. You cannot distinguish two different objects by different properties.</source>
          <target state="translated">Disjoint unions は、各オブジェクトのタイプを区別するために単一のプロパティを使用する必要があります。2 つの異なるオブジェクトを異なるプロパティで区別することはできません。</target>
        </trans-unit>
        <trans-unit id="e9068ebe4e81ef4f2881aa16d8729d7d6e800dff" translate="yes" xml:space="preserve">
          <source>Disjoint unions with exact types</source>
          <target state="translated">正確な型を持つ不協和</target>
        </trans-unit>
        <trans-unit id="aa4adede3310c0d7e145943b47a01ec740a946a3" translate="yes" xml:space="preserve">
          <source>Each line in the &lt;code&gt;[libs]&lt;/code&gt; section is a path to the library file or directory which you would like to include. These paths can be relative to the project root directory or absolute. Including a directory recursively includes all the files under that directory as library files.</source>
          <target state="translated">&lt;code&gt;[libs]&lt;/code&gt; セクションの各行は、含めたいライブラリファイルまたはディレクトリへのパスです。これらのパスは、プロジェクトのルートディレクトリに対する相対パスまたは絶対パスです。ディレクトリを含めると、そのディレクトリの下にあるすべてのファイルがライブラリファイルとして再帰的に含まれます。</target>
        </trans-unit>
        <trans-unit id="099f5c6226bea98d0b45888f6a9ff773168bded9" translate="yes" xml:space="preserve">
          <source>Each of the members of a intersection type can be any type, even another intersection type.</source>
          <target state="translated">交差型の各メンバは、別の交差型であっても、どのような型であっても構いません。</target>
        </trans-unit>
        <trans-unit id="9e5ead45d63220a36e13146ef22daf86e2c2fcea" translate="yes" xml:space="preserve">
          <source>Each of the members of a union type can be any type, even another union type.</source>
          <target state="translated">ユニオン型の各メンバは、他のユニオン型であっても、任意の型にすることができます。</target>
        </trans-unit>
        <trans-unit id="04062df0a5ebcde8394ccd8dfdb3632bb2dce1a6" translate="yes" xml:space="preserve">
          <source>Early in React&amp;rsquo;s history the library provided &lt;a href=&quot;https://facebook.github.io/react/docs/typechecking-with-proptypes.html&quot;&gt;&lt;code&gt;PropTypes&lt;/code&gt;&lt;/a&gt; which performed basic runtime checks. Flow is much more powerful as it can tell you when you are misusing a component without running your code.</source>
          <target state="translated">Reactの歴史の早い段階で、ライブラリは基本的なランタイムチェックを実行する&lt;a href=&quot;https://facebook.github.io/react/docs/typechecking-with-proptypes.html&quot;&gt; &lt;code&gt;PropTypes&lt;/code&gt; &lt;/a&gt;を提供しました。フローは、コードを実行せずにコンポーネントを誤用している場合に通知できるため、はるかに強力です。</target>
        </trans-unit>
        <trans-unit id="d8fbeb27c5847478b31ce446787b9e3281657271" translate="yes" xml:space="preserve">
          <source>Editor plugins are provided and maintained by the community. If you have trouble configuring or using a specific plugin for your IDE, please visit the project&amp;rsquo;s repo or search for a community provided answer.</source>
          <target state="translated">エディタプラグインは、コミュニティによって提供および保守されています。IDEの特定のプラグインの設定または使用に問題がある場合は、プロジェクトのリポジトリにアクセスするか、コミュニティ提供の回答を検索してください。</target>
        </trans-unit>
        <trans-unit id="ed63036d8730b34c2af3aa53fe984d9883388a1c" translate="yes" xml:space="preserve">
          <source>Editors</source>
          <target state="translated">Editors</target>
        </trans-unit>
        <trans-unit id="d89a5ec1140ce5dd978c2baf15972fdf48b8b61f" translate="yes" xml:space="preserve">
          <source>Emacs</source>
          <target state="translated">Emacs</target>
        </trans-unit>
        <trans-unit id="cf46938375da84aa280715be40f3710755292d16" translate="yes" xml:space="preserve">
          <source>Enables traces on all error output (showing additional details about the flow of types through the system), to the depth specified. This can be very expensive, so is disabled by default.</source>
          <target state="translated">指定された深さまで、すべてのエラー出力のトレースを有効にします(システムを介した型の流れに関する追加の詳細を表示します)。これは非常に高額になる可能性があるので、デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="f2dcc58367a1736e48cc9750d5d4e0f214c570ef" translate="yes" xml:space="preserve">
          <source>Enabling Flow Strict for a file means that several previously-allowed patterns will now trigger a Flow error. Each disallowed pattern has a corresponding &lt;a href=&quot;https://flow.org/en/linting/&quot;&gt;Flow Lint&lt;/a&gt; rule which triggers the error. The list of rules enabled for &lt;code&gt;@flow strict&lt;/code&gt; is configured in each &lt;code&gt;.flowconfig&lt;/code&gt;. Here are the recommended rules:</source>
          <target state="translated">ファイルに対してFlow Strictを有効にすると、以前は許可されていたいくつかのパターンがFlowエラーをトリガーするようになります。許可されていない各パターンには、エラーをトリガーする対応する&lt;a href=&quot;https://flow.org/en/linting/&quot;&gt;フローリント&lt;/a&gt;ルールがあります。 &lt;code&gt;@flow strict&lt;/code&gt; に対して有効なルールのリストは、各 &lt;code&gt;.flowconfig&lt;/code&gt; で構成されます。推奨されるルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9362e9d124ec7b068004f2f5d44579aee1193e70" translate="yes" xml:space="preserve">
          <source>Enabling Flow Strict in a .flowconfig</source>
          <target state="translated">.flowconfig でフローストリクトを有効にする</target>
        </trans-unit>
        <trans-unit id="0fe43e985b9f3cede92eed08e9cb385d404eea59" translate="yes" xml:space="preserve">
          <source>Enforcing that a component only gets a single child.</source>
          <target state="translated">コンポーネントが単一の子を取得するだけであることを強制します。</target>
        </trans-unit>
        <trans-unit id="af6da05f12e48d3f287a21a34dc14f0f0b6d9b9d" translate="yes" xml:space="preserve">
          <source>Equally specific inputs and outputs &amp;mdash; Good</source>
          <target state="translated">等しく特定の入力と出力&amp;mdash;良い</target>
        </trans-unit>
        <trans-unit id="1c01289049ee253c54bfc3dcb7ad87f71ff8dc18" translate="yes" xml:space="preserve">
          <source>Even as we treat our value as just one of the types, we do not get an error because it satisfies all of them.</source>
          <target state="translated">自分の値を型の一つとして扱っても、全てを満たしているのでエラーにはなりません。</target>
        </trans-unit>
        <trans-unit id="fe29fc3f9fec6b884383a4b8a8698b488827777d" translate="yes" xml:space="preserve">
          <source>Even code that will cause runtime errors will not be caught by Flow:</source>
          <target state="translated">ランタイムエラーが発生するコードであっても、Flowがキャッチすることはありません。</target>
        </trans-unit>
        <trans-unit id="47439ca5ded64f9ae2fef50d130387798195a012" translate="yes" xml:space="preserve">
          <source>Event Handling</source>
          <target state="translated">イベント処理</target>
        </trans-unit>
        <trans-unit id="9c18bb5b6450b86bbb2ec82c62983e3decf5661e" translate="yes" xml:space="preserve">
          <source>Eventually, some features of Flow Strict could become the default behavior of Flow, if those features prove successful and achieve widespread adoption.</source>
          <target state="translated">最終的には、Flow Strictのいくつかの機能が成功し、広く普及すれば、Flowのデフォルト動作になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="79794fb5666aa8f0653b4ce2e5a3fce9b026918b" translate="yes" xml:space="preserve">
          <source>Every Flow project contains a &lt;code&gt;.flowconfig&lt;/code&gt; file. You can configure Flow by modifying &lt;code&gt;.flowconfig&lt;/code&gt;. New projects or projects that are starting to use Flow can generate a default &lt;code&gt;.flowconfig&lt;/code&gt; by running &lt;code&gt;flow init&lt;/code&gt;.</source>
          <target state="translated">すべてのFlowプロジェクトには、 &lt;code&gt;.flowconfig&lt;/code&gt; ファイルが含まれています。 &lt;code&gt;.flowconfig&lt;/code&gt; を変更してフローを構成できます。新しいプロジェクトまたはFlowの使用を開始するプロジェクトは、 &lt;code&gt;flow init&lt;/code&gt; を実行することにより、デフォルトの &lt;code&gt;.flowconfig&lt;/code&gt; を生成できます。</target>
        </trans-unit>
        <trans-unit id="5fcb8d8758ed57d0a770a341b51dba1c53659f15" translate="yes" xml:space="preserve">
          <source>Every function in JavaScript can be called with a special context named &lt;code&gt;this&lt;/code&gt;. You can call a function with any context that you want.</source>
          <target state="translated">JavaScriptのすべての関数は、 &lt;code&gt;this&lt;/code&gt; という特別なコンテキストで呼び出すことができます。必要なコンテキストで関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="68197336316b778965bfb2950ace8adb822267f0" translate="yes" xml:space="preserve">
          <source>Exact object types</source>
          <target state="translated">正確なオブジェクトタイプ</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="dc536fab9433d34f6445a813d5f0c31792e7fa5f" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0C4TwDgpgBACghgJzgWygXigbwFBSgI0QC4oB+AZ2AQEsA7AcwBpsBfbAMwFdaBjYagPa0oyEADFuPABTsBAkvCTIAlCUo0GWXFGrsoMuQDpCCZVrx4eQ8gIA2EQ7YH0pAIh4ALCDwDWEACYAhK7KANzaAJAIEMCcCMKyAsaIoVAA9GlQ7E4A7lAQCAgCCOSGUACSeiACnFBWyMgQtMBQwF511nYOTkw6LTnFPuTabHja0bHxUK7+EOxwnLYt6nT0ruEsQA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">例（&lt;a href=&quot;https://flow.org/try/#0C4TwDgpgBACghgJzgWygXigbwFBSgI0QC4oB+AZ2AQEsA7AcwBpsBfbAMwFdaBjYagPa0oyEADFuPABTsBAkvCTIAlCUo0GWXFGrsoMuQDpCCZVrx4eQ8gIA2EQ7YH0pAIh4ALCDwDWEACYAhK7KANzaAJAIEMCcCMKyAsaIoVAA9GlQ7E4A7lAQCAgCCOSGUACSeiACnFBWyMgQtMBQwF511nYOTkw6LTnFPuTabHja0bHxUK7+EOxwnLYt6nT0ruEsQA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="e72839950b0f419947ce4f283294a67029092005" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTU4iAFJgAAsmAGsIXhgoAE8AByoQTAVlF3cvHypUFDQAcnZDEulsLPQrWw5cR2VObkQEJqV6ACZOCSA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">例（&lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTU4iAFJgAAsmAGsIXhgoAE8AByoQTAVlF3cvHypUFDQAcnZDEulsLPQrWw5cR2VObkQEJqV6ACZOCSA&quot;&gt;https://flow.org/try&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="894360e5088d7910eaab73bfa4ad7d6cf97c6f8c" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTW4UPigATwAHKhBMBWUXdy8fKlQUNABydkMs6WwE9CtbDlxHZU5uRAQKpXoAJk4JIA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">例（&lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTW4UPigATwAHKhBMBWUXdy8fKlQUNABydkMs6WwE9CtbDlxHZU5uRAQKpXoAJk4JIA&quot;&gt;https://flow.org/try&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="d65710bb9e0679950b0a2fa1e6f5d7c468d7acd2" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQUGESUVBtClAoj1J4hhtUiSlMWMhYfABRGkEAC3CsVy8APmTU1PTiaVi4OnCAAwAVeuxmz1BgwlAAEioJgu0+LJJHUGQx3KdckmxpuZ8+QYTi0D4ExD4gA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQUGESUVBtClAoj1J4hhtUiSlMWMhYfABRGkEAC3CsVy8APmTU1PTiaVi4OnCAAwAVeuxmz1BgwlAAEioJgu0+LJJHUGQx3KdckmxpuZ8+QYTi0D4ExD4gA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="80f15d97ffae3b57327c19c2c3876da3f190b457" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQcUxJaVjIWHwAURpBAAtwrFcvAD5k1NThEmJMuDpwgAMAFULsUs9QYMJQABIqLtJ4hj5QGhJHUGQO0Cj5kmxegaoojxHtPmaEm1S+BMQ+IA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQcUxJaVjIWHwAURpBAAtwrFcvAD5k1NThEmJMuDpwgAMAFULsUs9QYMJQABIqLtJ4hj5QGhJHUGQO0Cj5kmxegaoojxHtPmaEm1S+BMQ+IA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="322dc85522b6f01f651a645f66ddad7a2d200735" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRo3UmRxKRlk0Bz4zDzJaUwa0DJkABUlAFtMWG5kMLCk1PSaedA6-FgAvLhVMIADABIGLpkNUABGTYTejVEjgAYbhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRo3UmRxKRlk0Bz4zDzJaUwa0DJkABUlAFtMWG5kMLCk1PSaedA6-FgAvLhVMIADABIGLpkNUABGTYTejVEjgAYbhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d33740834b3eef6ebff52fd563f9384fd43212e0" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRoyZAAVJQBbTFhuZDCwpNT0mj7QN1JYALy4VTCAAwASBhz4zDzJaUwNUABGCYSazVE1gAYDhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRoyZAAVJQBbTFhuZDCwpNT0mj7QN1JYALy4VTCAAwASBhz4zDzJaUwNUABGCYSazVE1gAYDhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="17498ea196f44dae076810df274fc7a54473ddb1" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKABTkBcoRArgLYBGyWAlHQB8ocqADUoAIwBuIA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKABTkBcoRArgLYBGyWAlHQB8ocqADUoAIwBuIA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="190c678983df25c000784ac0118a1c78a00727f4" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QAClgAjAFaNQAbwA+oclM7EMNAOahZAApr4AtqNLEtsgL4BKAQD4ZiAJCox4gHTkBoHgCYAzKBAA5AHkAFQBRAEIZbUVQZVUNM1AAB3J2dlJKUFUFGkzySCwjUFwMdiyieAJoTMNQXQMijEgFaDh4DPsyLHxiGlAnAG5EU1YOIidSFiweKTktGLj1TVN3aRiAcmV10FMhlDBuHhEJSenzAb8wAB4AWjvQfBo2PT1SGiJsyFhiUCNib-Y4XCyFQdzB4IhkKh0JhILAACUKNQ6PQbgA3IzsDC0ZiINg0TigbiedzHSRRUAAagWWBUS209UMPzMln4NmkiFAoAcYCcrncXl8ARCEVAAGVVCxSKB6AQFGQHlilmw0eQVOR3lEtNSlLT4podPomcsADQyuUsDXrIh6QjkQrlTqkbq9foSIYjPFjN3iU6eWbyGl0hIrQTSBRSTa07a7ZDEsl+85AA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QAClgAjAFaNQAbwA+oclM7EMNAOahZAApr4AtqNLEtsgL4BKAQD4ZiAJCox4gHTkBoHgCYAzKBAA5AHkAFQBRAEIZbUVQZVUNM1AAB3J2dlJKUFUFGkzySCwjUFwMdiyieAJoTMNQXQMijEgFaDh4DPsyLHxiGlAnAG5EU1YOIidSFiweKTktGLj1TVN3aRiAcmV10FMhlDBuHhEJSenzAb8wAB4AWjvQfBo2PT1SGiJsyFhiUCNib-Y4XCyFQdzB4IhkKh0JhILAACUKNQ6PQbgA3IzsDC0ZiINg0TigbiedzHSRRUAAagWWBUS209UMPzMln4NmkiFAoAcYCcrncXl8ARCEVAAGVVCxSKB6AQFGQHlilmw0eQVOR3lEtNSlLT4podPomcsADQyuUsDXrIh6QjkQrlTqkbq9foSIYjPFjN3iU6eWbyGl0hIrQTSBRSTa07a7ZDEsl+85AA&quot;&gt;https://flow.org/try&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="f3309c09c3ccaba2a2970b1e441c41e351e404c8" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QACnLFijUAEEx5egB5OxDDQDmoAD4ACmvgC2AI1LEAfAEoBx0AG9EASFSjiAOgAO+djiE8ATAGZzqAByAPIAKgCiAIRSMvKKyiqWLuTs7KSUoMqg5DQZ5JBYRqC4GOyZRPAE0HnQ7LCZNCzQ+JSkoDoGRmUYkNnQcPDpdmRY+MQ02WIA3IgAvqwcRI48EtLEsgpYSqqWggDaAOTk+iwHALozKGDcPCJiplOgqHIAtG+g+I2wurqkNFywYigIzEQHsSKRZCoN4w2Fw+EIxFIqFgABKFGodHoLwAbl0MLRmIg2DROKBuN4BMJHBIACToqjBLFrDbxVQabR6Qwmcz8Sw2UCCp5gRyudyeXzeHgBMAhCLRADKyhYbXoBEmbXcCVA9IxTIYLPkTmNljV+FALByNFgRDcHmyNHoJXZWHq2GGpFG40mxDmC1JSzE3lWsU220SVMOx1OF2QFLuxG8DyAA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QACnLFijUAEEx5egB5OxDDQDmoAD4ACmvgC2AI1LEAfAEoBx0AG9EASFSjiAOgAO+djiE8ATAGZzqAByAPIAKgCiAIRSMvKKyiqWLuTs7KSUoMqg5DQZ5JBYRqC4GOyZRPAE0HnQ7LCZNCzQ+JSkoDoGRmUYkNnQcPDpdmRY+MQ02WIA3IgAvqwcRI48EtLEsgpYSqqWggDaAOTk+iwHALozKGDcPCJiplOgqHIAtG+g+I2wurqkNFywYigIzEQHsSKRZCoN4w2Fw+EIxFIqFgABKFGodHoLwAbl0MLRmIg2DROKBuN4BMJHBIACToqjBLFrDbxVQabR6Qwmcz8Sw2UCCp5gRyudyeXzeHgBMAhCLRADKyhYbXoBEmbXcCVA9IxTIYLPkTmNljV+FALByNFgRDcHmyNHoJXZWHq2GGpFG40mxDmC1JSzE3lWsU220SVMOx1OF2QFLuxG8DyAA&quot;&gt;https://flow.org/try&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="5a53b2289397b07076fab02c5763eb1c53631c66" translate="yes" xml:space="preserve">
          <source>Example with custom project root:</source>
          <target state="translated">カスタムプロジェクトルートを使用した例。</target>
        </trans-unit>
        <trans-unit id="8be9eff630c8880ea37c3c71e5c9f1754569ead1" translate="yes" xml:space="preserve">
          <source>Existential Type (&lt;code&gt;*&lt;/code&gt;)</source>
          <target state="translated">存在タイプ（ &lt;code&gt;*&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="7b6e2ec966477f28252b7545083426821a4c2c4e" translate="yes" xml:space="preserve">
          <source>Explicit versions, (e.g. &lt;code&gt;0.22.0&lt;/code&gt;, which only matches &lt;code&gt;0.22.0&lt;/code&gt;).</source>
          <target state="translated">明示的なバージョンで、（例えば &lt;code&gt;0.22.0&lt;/code&gt; のみ一致し、 &lt;code&gt;0.22.0&lt;/code&gt; を）。</target>
        </trans-unit>
        <trans-unit id="2e0e14ad5753e9c7b526a0cc660e1f093709bbc2" translate="yes" xml:space="preserve">
          <source>Exporting Wrapped Components</source>
          <target state="translated">ラッピングされたコンポーネントのエクスポート</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="2113c9e9296853fb527db9a13ccff3f1ceb1a1d8" translate="yes" xml:space="preserve">
          <source>Fields added outside of the class definition need to be annotated within the body of the class.</source>
          <target state="translated">クラス定義外で追加されたフィールドは、クラス本体内で注釈を付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="4a066fa7f532f77d0e18961512951af8ba154e40" translate="yes" xml:space="preserve">
          <source>Fields are annotated within the body of the class with the field name followed by a colon &lt;code&gt;:&lt;/code&gt; and the type.</source>
          <target state="translated">フィールドは、クラスの本体内でフィールド名の後にコロン &lt;code&gt;:&lt;/code&gt; と型が続く注釈が付けられます。</target>
        </trans-unit>
        <trans-unit id="64f266c0fe1d54849f0f9ed285666ffc97ff5171" translate="yes" xml:space="preserve">
          <source>Figuring out types statically</source>
          <target state="translated">静的に型を把握する</target>
        </trans-unit>
        <trans-unit id="4530df8ca3479183e9a0b8b7820de3c8dd0aa307" translate="yes" xml:space="preserve">
          <source>Finally, if we had a &lt;code&gt;TypeA&lt;/code&gt; which described the numbers 1 through 3, and a &lt;code&gt;TypeB&lt;/code&gt; which described the numbers 3 through 5. Neither of them would be a subtype of the other. Even though they both have 3 and describe numbers, they each have some unique items.</source>
          <target state="translated">最後に、1から3までの数字を表す &lt;code&gt;TypeA&lt;/code&gt; と、3から5までの数字を表す &lt;code&gt;TypeB&lt;/code&gt; がある場合、どちらも他方のサブタイプにはなりません。どちらも3つあり、番号を説明していますが、それぞれにいくつかのユニークなアイテムがあります。</target>
        </trans-unit>
        <trans-unit id="0087380702d2e1d3b16fa67500a178f79cae05f8" translate="yes" xml:space="preserve">
          <source>Finally, precision enables useful developer tools to be built. In particular, the quality of results reported by Flow when the developer asks for the type of an expression, the definition reaching a reference, or the set of possible completions at a point through an IDE is correlated with the precision of Flow&amp;rsquo;s analysis.</source>
          <target state="translated">最後に、精度により、有用な開発者ツールを構築できます。特に、開発者が式のタイプ、参照に到達する定義、またはIDEを介したある時点で可能な完了のセットを要求したときにFlowによって報告される結果の品質は、Flowの分析の精度と相関関係があります。</target>
        </trans-unit>
        <trans-unit id="07c5cf005d2302c6d3946a6acb658df51d720297" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;ll have yet another &lt;code&gt;SubClass&lt;/code&gt; that accepts a value of a more specific type.</source>
          <target state="translated">最後に、さらに特定の型の値を受け入れる別の &lt;code&gt;SubClass&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="dac3b0962e00de97e4f2ee26698e83fa3a80f1ef" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;flow-remove-types&lt;/code&gt; with either &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">最初に、&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;または&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npmの&lt;/a&gt;いずれかで &lt;code&gt;flow-remove-types&lt;/code&gt; をインストールします。</target>
        </trans-unit>
        <trans-unit id="cd2eea5de09d8e90691b2d177dd08996669f26aa" translate="yes" xml:space="preserve">
          <source>First we&amp;rsquo;ll setup a couple of classes that extend one another.</source>
          <target state="translated">最初に、互いに拡張するいくつかのクラスをセットアップします。</target>
        </trans-unit>
        <trans-unit id="456cf8a255eb59ebf894cb52911a86af4e0bff54" translate="yes" xml:space="preserve">
          <source>Fixed example:</source>
          <target state="translated">固定例。</target>
        </trans-unit>
        <trans-unit id="86eff8eb789b097ddca83f2c9c4617ed23605105" translate="yes" xml:space="preserve">
          <source>Flow</source>
          <target state="translated">Flow</target>
        </trans-unit>
        <trans-unit id="5f486e379bef52ad99c92a90171eb0881d4b0d3f" translate="yes" xml:space="preserve">
          <source>Flow + Redux resources</source>
          <target state="translated">フロー+Reduxリソース</target>
        </trans-unit>
        <trans-unit id="55ec9aab6133cd88e4cf42e5ab878820aef8afea" translate="yes" xml:space="preserve">
          <source>Flow CLI</source>
          <target state="translated">フローCLI</target>
        </trans-unit>
        <trans-unit id="8b609ab9406ce02a4ce30abc841ff2dba941e173" translate="yes" xml:space="preserve">
          <source>Flow For Sublime Text 2 and 3</source>
          <target state="translated">崇高なテキスト2と3のための流れ</target>
        </trans-unit>
        <trans-unit id="aa235a6660a8f1b9aa16724f3a8222516b8f655e" translate="yes" xml:space="preserve">
          <source>Flow Strict</source>
          <target state="translated">流れの厳しさ</target>
        </trans-unit>
        <trans-unit id="f2ec6e6dfc95e327edb4e1795150f27d42969c4f" translate="yes" xml:space="preserve">
          <source>Flow Strict is configured in each &lt;code&gt;.flowconfig&lt;/code&gt;. To enable:</source>
          <target state="translated">Flow Strictは、各 &lt;code&gt;.flowconfig&lt;/code&gt; で構成されます。有効にする：</target>
        </trans-unit>
        <trans-unit id="8095395f626e2f4759824d2de551bb30bbe955c2" translate="yes" xml:space="preserve">
          <source>Flow also supports importing the type of values exported by other modules using &lt;a href=&quot;../typeof&quot;&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Flowは、&lt;a href=&quot;../typeof&quot;&gt; &lt;code&gt;typeof&lt;/code&gt; &lt;/a&gt;を使用して他のモジュールによってエクスポートされた値のタイプのインポートもサポートしています。</target>
        </trans-unit>
        <trans-unit id="b5565b1d0068dc56bcf908f48c68d08d32bae353" translate="yes" xml:space="preserve">
          <source>Flow also supports using the &lt;a href=&quot;https://tc39.github.io/proposal-class-public-fields/&quot;&gt;class properties syntax&lt;/a&gt;.</source>
          <target state="translated">フローは、&lt;a href=&quot;https://tc39.github.io/proposal-class-public-fields/&quot;&gt;クラスプロパティ構文の&lt;/a&gt;使用もサポートしています。</target>
        </trans-unit>
        <trans-unit id="e84982c22a83ff1714857618c803fc295ca0cb49" translate="yes" xml:space="preserve">
          <source>Flow and &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; are designed to work great together. It takes just a few steps to set them up together.</source>
          <target state="translated">Flowと&lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt;は、連携して機能するように設計されています。それらを一緒に設定するには、ほんの数ステップしかかかりません。</target>
        </trans-unit>
        <trans-unit id="5ccb8cfec36d4d1243e598e54059dcef046eb1fd" translate="yes" xml:space="preserve">
          <source>Flow and Babel work well together, so it doesn&amp;rsquo;t take much to adopt Flow as a React user who already uses Babel. If you need to setup Babel with Flow, you can follow &lt;a href=&quot;https://flow.org/en/tools/babel/&quot;&gt;this guide&lt;/a&gt;.</source>
          <target state="translated">FlowとBabelは連携して機能するため、FlowをすでにBabelを使用しているReactユーザーとして採用するのにそれほど時間はかかりません。FlowでBabelを設定する必要がある場合は、&lt;a href=&quot;https://flow.org/en/tools/babel/&quot;&gt;このガイドに&lt;/a&gt;従ってください。</target>
        </trans-unit>
        <trans-unit id="12bd6e3068284e323e6e5441c7cbe62cfa2eaa15" translate="yes" xml:space="preserve">
          <source>Flow can either infer the type from the value you are assigning to it or you can provide it with a type.</source>
          <target state="translated">フローは、割り当てている値から型を推論するか、型を提供することができます。</target>
        </trans-unit>
        <trans-unit id="72ce261a07a9b54acdbe6ade8c25b4096bc1b01e" translate="yes" xml:space="preserve">
          <source>Flow can handle both CommonJS and ES modules, but there are some relevant differences between the two that need to be considered when using &lt;code&gt;declare module&lt;/code&gt;.</source>
          <target state="translated">FlowはCommonJSとESの両方のモジュールを処理できますが、 &lt;code&gt;declare module&lt;/code&gt; を使用するときに考慮する必要がある2つの間にいくつかの関連する違いがあります。</target>
        </trans-unit>
        <trans-unit id="c4fd2a75a67392ac133c52fa3dfe6c46849561bc" translate="yes" xml:space="preserve">
          <source>Flow can infer the type of object literals in two different ways depending on how they are used.</source>
          <target state="translated">Flowは、オブジェクトリテラルの種類を使用方法に応じて2つの方法で推論することができます。</target>
        </trans-unit>
        <trans-unit id="98d85338f7ba2bc3651bb2436f50fc5aeb15f4f6" translate="yes" xml:space="preserve">
          <source>Flow can typecheck your React components that use the &lt;a href=&quot;https://reactjs.org/docs/context.html&quot;&gt;context API&lt;/a&gt; introduced in React 16.3.</source>
          <target state="translated">フローは、React 16.3で導入された&lt;a href=&quot;https://reactjs.org/docs/context.html&quot;&gt;コンテキストAPI&lt;/a&gt;を使用するReactコンポーネントをタイプチェックできます。</target>
        </trans-unit>
        <trans-unit id="6944ed8c8b4918d2dec469bbf6c3dc20723ec0d8" translate="yes" xml:space="preserve">
          <source>Flow cannot understand the types of my higher order React component, how can I help it?</source>
          <target state="translated">Flowは私の高次のReactコンポーネントの種類を理解することができません、どのようにそれを助けることができますか?</target>
        </trans-unit>
        <trans-unit id="183d1f29f5ed63eb14ac2b0f3910cf9d83903afb" translate="yes" xml:space="preserve">
          <source>Flow checks your code for errors through &lt;strong&gt;static type annotations&lt;/strong&gt;. These &lt;em&gt;types&lt;/em&gt; allow you to tell Flow how you want your code to work, and Flow will make sure it does work that way.</source>
          <target state="translated">フローは、&lt;strong&gt;静的型注釈&lt;/strong&gt;を通じてコードのエラーをチェックします。これらの&lt;em&gt;タイプを&lt;/em&gt;使用すると、コードにどのように機能させたいかをFlowに伝えることができ、Flowはそのように機能することを確認します。</target>
        </trans-unit>
        <trans-unit id="04032a68a1402eaf71bab9646202a4ad15b6268c" translate="yes" xml:space="preserve">
          <source>Flow chooses what is natural for JavaScript, and should behave the way you expect it to.</source>
          <target state="translated">Flow は JavaScript にとって自然なものを選択し、期待通りの動作をするようにします。</target>
        </trans-unit>
        <trans-unit id="032ca5c444d8fb1a1677e49ec7f5f65de9cb839b" translate="yes" xml:space="preserve">
          <source>Flow contains a linting framework that can tell you about more than just type errors. This framework is highly configurable in order to show you the information you want and hide the information you don&amp;rsquo;t.</source>
          <target state="translated">フローには、入力エラーだけでなく、それ以上のことを通知できるリンティングフレームワークが含まれています。このフレームワークは、必要な情報を表示し、不要な情報を非表示にするために高度に構成可能です。</target>
        </trans-unit>
        <trans-unit id="8a9a662da9d9494227dfb8c32f7a3a00aa8eb74d" translate="yes" xml:space="preserve">
          <source>Flow does all sorts of type inference on your code so that you don&amp;rsquo;t have to type annotate anything. Generally, inference avoids getting in your way while still preventing you from introducing bugs.</source>
          <target state="translated">Flowはコードに対してあらゆる種類の型推論を行うため、何も型注釈を付ける必要はありません。一般に、推論はバグの発生を防ぎながら邪魔にならないようにします。</target>
        </trans-unit>
        <trans-unit id="c4a7493c100b0d7186e5d7a811ec01b5c49ff79d" translate="yes" xml:space="preserve">
          <source>Flow does not do this because it would be extremely inconvenient to use. You would be forced to refine the type of every value you get when accessing an array.</source>
          <target state="translated">Flowがこれをしないのは、使い方が非常に不便になるからです。配列にアクセスする際に、取得するすべての値の型を絞り込むことを余儀なくされることになります。</target>
        </trans-unit>
        <trans-unit id="25bf8feebd194c6ea5f28b8c0c675bd8e2749e24" translate="yes" xml:space="preserve">
          <source>Flow does not keep track of side effects, so any function call may potentially nullify your check. This is called &lt;a href=&quot;lang/refinements#toc-refinement-invalidations&quot;&gt;refinement invalidation&lt;/a&gt;.</source>
          <target state="translated">フローは副作用を追跡しないため、関数呼び出しによってチェックが無効になる可能性があります。これは、&lt;a href=&quot;lang/refinements#toc-refinement-invalidations&quot;&gt;絞り込みの無効化&lt;/a&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="f3f46e4e936a3e8537064c3745c26d7fd98211da" translate="yes" xml:space="preserve">
          <source>Flow doesn&amp;rsquo;t track refinements made in separated function calls.</source>
          <target state="translated">フローは、個別の関数呼び出しで行われた改良を追跡しません。</target>
        </trans-unit>
        <trans-unit id="59a4ef57b455273cbb11be7412569d3ac42e4710" translate="yes" xml:space="preserve">
          <source>Flow for Atom IDE</source>
          <target state="translated">Atom IDEの流れ</target>
        </trans-unit>
        <trans-unit id="44fdaae0716bb1f8df6934754643b2d31169e8f0" translate="yes" xml:space="preserve">
          <source>Flow has &lt;a href=&quot;../primitives&quot;&gt;primitive types&lt;/a&gt; for literal values, but can also use literal values as types.</source>
          <target state="translated">フローにはリテラル値の&lt;a href=&quot;../primitives&quot;&gt;プリミティブ型&lt;/a&gt;がありますが、リテラル値を型として使用することもできます。</target>
        </trans-unit>
        <trans-unit id="46a176a435a62da90c46dd0328bea203b7bb04be" translate="yes" xml:space="preserve">
          <source>Flow has a powerful ability to infer the types of your programs. The majority of your code can rely on it. Still, there are places where you&amp;rsquo;ll want to add types.</source>
          <target state="translated">フローには、プログラムのタイプを推測する強力な機能があります。コードの大部分はそれに依存することができます。それでも、タイプを追加したい場所があります。</target>
        </trans-unit>
        <trans-unit id="91780aa64a146a3b1363ded13b2a26ff2a5703d2" translate="yes" xml:space="preserve">
          <source>Flow has builtin library definitions. Setting this to &lt;code&gt;true&lt;/code&gt; will tell Flow to ignore the builtin library definitions.</source>
          <target state="translated">フローには組み込みのライブラリ定義があります。これを &lt;code&gt;true&lt;/code&gt; に設定すると、組み込みライブラリ定義を無視するようにFlowに指示します。</target>
        </trans-unit>
        <trans-unit id="825a2af8b1f4018e85d11b13cda08105f2561dfc" translate="yes" xml:space="preserve">
          <source>Flow has worked with Nuclide directly on adding support for the new warning severity level. Certain features are likely to be in other editors, but others might not yet be implemented.</source>
          <target state="translated">FlowはNuclideと直接協力して、新しい警告の重要度レベルのサポートを追加しました。特定の機能は他のエディタにも搭載される可能性がありますが、他の機能はまだ実装されていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="1f749e30856c0772a3eb06d3b18fcad17982d0c5" translate="yes" xml:space="preserve">
          <source>Flow is a static type checker for JavaScript that we built at Facebook. The overall mission of Flow is to deliver an immersive coding experience for JavaScript developers&amp;mdash;a fast edit-refresh cycle&amp;mdash;even as the codebase evolves and grows. In engineering terms, we identify two concrete goals that are important to this mission: &lt;em&gt;precision&lt;/em&gt; and &lt;em&gt;speed&lt;/em&gt;. These goals pervasively drive the design and implementation.</source>
          <target state="translated">Flowは、Facebookで作成したJavaScriptの静的型チェッカーです。Flowの全体的な使命は、コードベースが進化し成長しても、JavaScript開発者に没入型のコーディングエクスペリエンスを提供することです。つまり、編集とリフレッシュのサイクルが速くなります。エンジニアリングの観点から、このミッションにとって重要な2つの具体的な目標、&lt;em&gt;精度&lt;/em&gt;と&lt;em&gt;速度&lt;/em&gt;を特定します。これらの目標は、設計と実装を広範に推進します。</target>
        </trans-unit>
        <trans-unit id="e37ba63533b865ecc3dbf31c3bc219eae3775a54" translate="yes" xml:space="preserve">
          <source>Flow is a static type checker for your JavaScript code. It does a lot of work to make you more productive. Making you code faster, smarter, more confidently, and to a bigger scale.</source>
          <target state="translated">Flowは、JavaScriptコードの静的型チェッカーです。より生産性を高めるために多くの仕事をしてくれます。より速く、より賢く、より自信を持って、より大きなスケールでコードを書くことができます。</target>
        </trans-unit>
        <trans-unit id="eccc6e8d7aae412ab111e4ae2e8f9d87e9acb8a6" translate="yes" xml:space="preserve">
          <source>Flow is not &lt;a href=&quot;https://flow.org/en/lang/types-and-expressions/#soundness-and-completeness&quot;&gt;complete&lt;/a&gt;, so it cannot check all code perfectly. Instead, Flow will make conservative assumptions to try to be sound.</source>
          <target state="translated">フローは&lt;a href=&quot;https://flow.org/en/lang/types-and-expressions/#soundness-and-completeness&quot;&gt;完全&lt;/a&gt;ではないため、すべてのコードを完全にチェックすることはできません。代わりに、Flowは、健全であることを試みるために保守的な仮定を行います。</target>
        </trans-unit>
        <trans-unit id="f5a3fb20b94174faf688a6da7dfab78f503bda2d" translate="yes" xml:space="preserve">
          <source>Flow needs a way to be able to figure out the type of every expression. But it can&amp;rsquo;t just run your code to figure it out, if it did it would be affected by any issues that your code has. For example, if you created an infinite loop Flow would wait for it to finish forever.</source>
          <target state="translated">フローには、すべての式のタイプを把握できる方法が必要です。ただし、コードを実行してそれを理解することはできません。実行した場合、コードにある問題の影響を受けます。たとえば、無限ループを作成した場合、フローはそれが永久に終了するまで待機します。</target>
        </trans-unit>
        <trans-unit id="c320f7d736c792bfa9520f9145672090f7b71c98" translate="yes" xml:space="preserve">
          <source>Flow needs to compare more than just sets of primitive values, it also needs to be able to compare objects, functions, and every other type that appears in the language.</source>
          <target state="translated">Flowは、単にプリミティブ値のセットを比較するだけでなく、オブジェクト、関数、その他言語に登場するあらゆるタイプを比較できるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="197f7b0842bf7c4d39085530e1c9d6e1647ccda5" translate="yes" xml:space="preserve">
          <source>Flow needs to know which files to parse and of those how to handle any Flow types within them. For third party libraries you may wish to not parse, parse but not preserve types, or parse but not raise errors, depending on the quality and compatibility of their Flow implementation.</source>
          <target state="translated">Flowは、どのファイルを解析するか、また、その中のFlowの型をどのように扱うかを知る必要がある。サードパーティのライブラリについては、Flowの実装の品質や互換性に応じて、解析しない、解析しても型を保存しない、解析してもエラーを発生させないなどの方法が考えられます。</target>
        </trans-unit>
        <trans-unit id="fa11ea1401156a6f5d8e119dec34779c7787d52c" translate="yes" xml:space="preserve">
          <source>Flow needs to know which files to read and watch for changes. This set of files is determined by taking all included files and excluding all the ignored files.</source>
          <target state="translated">フローは、どのファイルを読み込んで変更を監視するかを知る必要があります。このファイルのセットは、すべてのインクルードされたファイルを取り、無視されたファイルをすべて除外することで決定されます。</target>
        </trans-unit>
        <trans-unit id="e74d4f194fac00619d8f08bc6cfdf7a46e8a3401" translate="yes" xml:space="preserve">
          <source>Flow provides a set of utility types to operate on other types, and can be useful for different scenarios.</source>
          <target state="translated">フローは、他のタイプで動作するユーティリティタイプのセットを提供しており、さまざまなシナリオで役立ちます。</target>
        </trans-unit>
        <trans-unit id="1431a76ac3b525222744b6e84e9e4ddfb3690671" translate="yes" xml:space="preserve">
          <source>Flow reads &lt;code&gt;package.json&lt;/code&gt; files for the &lt;code&gt;&quot;name&quot;&lt;/code&gt; and &lt;code&gt;&quot;main&quot;&lt;/code&gt; fields to figure out the name of the module and which file should be used to provide that module.</source>
          <target state="translated">フローは、 &lt;code&gt;&quot;name&quot;&lt;/code&gt; フィールドと &lt;code&gt;&quot;main&quot;&lt;/code&gt; フィールドの &lt;code&gt;package.json&lt;/code&gt; ファイルを読み取り、モジュールの名前と、そのモジュールを提供するために使用するファイルを把握します。</target>
        </trans-unit>
        <trans-unit id="e11220e33346b1bf7474cc77bed10da16b3fdb63" translate="yes" xml:space="preserve">
          <source>Flow requires type annotations at module boundaries to make sure it can scale. To read more about that, check out our &lt;a href=&quot;https://medium.com/flow-type/asking-for-required-annotations-64d4f9c1edf8&quot;&gt;blog post&lt;/a&gt; about that.</source>
          <target state="translated">フローは、スケーリングできることを確認するために、モジュール境界で型注釈を必要とします。詳しくは、&lt;a href=&quot;https://medium.com/flow-type/asking-for-required-annotations-64d4f9c1edf8&quot;&gt;ブログ記事を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="84d0f858caf5dd7487404da9c0e086ed565c074e" translate="yes" xml:space="preserve">
          <source>Flow supports a comment-based syntax, which makes it possible to use Flow without having to compile your files.</source>
          <target state="translated">Flowはコメントベースの構文をサポートしており、ファイルをコンパイルすることなくFlowを使用することができます。</target>
        </trans-unit>
        <trans-unit id="25dce24924ffe50d06ea3c27504223de08877a30" translate="yes" xml:space="preserve">
          <source>Flow tracks the specific type of the value you pass through a generic, letting you use it later.</source>
          <target state="translated">フローは、ジェネリックに渡した値の特定の型を追跡し、後で使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="4543e6960bdd40f7fd529d611087695f4d5149d5" translate="yes" xml:space="preserve">
          <source>Flow tries to avoid parsing non-flow files. This means Flow needs to start lexing a file to see if it has &lt;code&gt;@flow&lt;/code&gt; or &lt;code&gt;@noflow&lt;/code&gt; in it. This option lets you configure how much of the file Flow lexes before it decides there is no relevant docblock.</source>
          <target state="translated">フローは、非フローファイルの解析を回避しようとします。 &lt;code&gt;@flow&lt;/code&gt; 、 &lt;code&gt;@noflow&lt;/code&gt; flowまたは@noflowが含まれているかどうかを確認するために、フローはファイルの字句解析を開始する必要があります。このオプションを使用すると、関連するdocblockがないと判断する前に、ファイルフローlexesの量を構成できます。</target>
        </trans-unit>
        <trans-unit id="52553dd61330137688c84a4912b70f866c01b523" translate="yes" xml:space="preserve">
          <source>Flow tries to be as sound and complete as possible. But because JavaScript was not designed around a type system, Flow sometimes has to make a tradeoff. When this happens Flow tends to favor soundness over completeness, ensuring that code doesn&amp;rsquo;t have any bugs.</source>
          <target state="translated">フローは、できるだけ健全で完全なものになるように努めます。しかし、JavaScriptは型システムを中心に設計されていないため、Flowはトレードオフを行わなければならない場合があります。この場合、フローは完全性よりも健全性を優先する傾向があり、コードにバグがないことを確認します。</target>
        </trans-unit>
        <trans-unit id="7d011e99cc7dbd500d87676f164a01cb49e80345" translate="yes" xml:space="preserve">
          <source>Flow tries to work out of the box as much as possible, but can be configured to work with any codebase.</source>
          <target state="translated">フローは可能な限り箱から出して動作するようにしていますが、どのようなコードベースでも動作するように設定することができます。</target>
        </trans-unit>
        <trans-unit id="eb7d367d74212ddc0e35250289a131174450c8b9" translate="yes" xml:space="preserve">
          <source>Flow understands these conversions and will allow any of them as part of an &lt;code&gt;if&lt;/code&gt; statement and other types of expressions.</source>
          <target state="translated">Flowはこれらの変換を理解し、 &lt;code&gt;if&lt;/code&gt; ステートメントやその他のタイプの式の一部としてそれらを許可します。</target>
        </trans-unit>
        <trans-unit id="5bea5ed86f8a457903d5905c971362464ec56214" translate="yes" xml:space="preserve">
          <source>Flow was designed for easy adoption, so it allows you opt-out of type checking in certain situations, permitting unsafe behaviors. But since many codebases now have a high adoption of Flow types, this trade-off can be flipped. You can use &lt;em&gt;Flow Strict&lt;/em&gt; to disallow previously-allowed unsafe patterns. This gives you improved safety guarantees that catch more bugs and make refactoring easier. And you can implement these stronger guarantees incrementally, on a file-by-file basis.</source>
          <target state="translated">フローは簡単に採用できるように設計されているため、特定の状況で型チェックをオプトアウトして、安全でない動作を許可できます。しかし、多くのコードベースでは現在、フロータイプの採用率が高いため、このトレードオフを取り消すことができます。&lt;em&gt;Flow Strict&lt;/em&gt;を使用して、以前に許可された安全でないパターンを禁止できます。これにより、より多くのバグをキャッチしてリファクタリングを容易にする安全性の保証が向上します。また、これらのより強力な保証をファイルごとに段階的に実装できます。</target>
        </trans-unit>
        <trans-unit id="1595a2bf188fc4b7ef46616052b38b6e681bb494" translate="yes" xml:space="preserve">
          <source>Flow will be run as part of create-react-app&amp;rsquo;s scripts.</source>
          <target state="translated">フローはcreate-react-appのスクリプトの一部として実行されます。</target>
        </trans-unit>
        <trans-unit id="338d618c9a13ce96682c1d7e15f73ae7f8964da4" translate="yes" xml:space="preserve">
          <source>Flow will infer the type of your default props from &lt;code&gt;static defaultProps&lt;/code&gt; so you don&amp;rsquo;t have to add any type annotations to use default props.</source>
          <target state="translated">フローは &lt;code&gt;static defaultProps&lt;/code&gt; からデフォルトの小道具のタイプを推測するため、デフォルトの小道具を使用するためにタイプアノテーションを追加する必要はありません。</target>
        </trans-unit>
        <trans-unit id="9184e4b7870b602025b0689241850daf93e22df5" translate="yes" xml:space="preserve">
          <source>Flow will infer types from the way you use a context&amp;rsquo;s &lt;code&gt;{Provider,Consumer}&lt;/code&gt; pair:</source>
          <target state="translated">フローは、コンテキストの &lt;code&gt;{Provider,Consumer}&lt;/code&gt; ペアの使用方法から型を推測します。</target>
        </trans-unit>
        <trans-unit id="3e54a4925e33a70ee19276a34ddf5663b9fa39c5" translate="yes" xml:space="preserve">
          <source>Flow will only accept strings and number when concatenating them to strings.</source>
          <target state="translated">Flowは、文字列と数字を連結して文字列にする場合にのみ、文字列と数字を受け付けます。</target>
        </trans-unit>
        <trans-unit id="5eab08add042bdc755cadabf5fe2a07bc373a954" translate="yes" xml:space="preserve">
          <source>Flow will unsoundly allow this last cast to succeed. If this behavior is not wanted, then this utility type should be avoided.</source>
          <target state="translated">フローは、この最後のキャストを成功させることを不健全に許します。この動作を望まない場合は、このユーティリティタイプは避けるべきです。</target>
        </trans-unit>
        <trans-unit id="9fb359e7b8aa5962ece67701ffa1a8439b019086" translate="yes" xml:space="preserve">
          <source>Flow will use &lt;code&gt;bar.js&lt;/code&gt; to provide the &lt;code&gt;&quot;kittens&quot;&lt;/code&gt; module.</source>
          <target state="translated">Flowは &lt;code&gt;bar.js&lt;/code&gt; を使用して &lt;code&gt;&quot;kittens&quot;&lt;/code&gt; モジュールを提供します。</target>
        </trans-unit>
        <trans-unit id="db39464b47c1acee0eb7fa411eeb1a89946c2d9f" translate="yes" xml:space="preserve">
          <source>Flow&amp;rsquo;s editor integration is primarily via the &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;Language Server Protocol&lt;/a&gt;. There are &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/implementors/tools/&quot;&gt;many vim LSP clients&lt;/a&gt; to choose from, such as &lt;a href=&quot;#toc-ale&quot;&gt;ALE&lt;/a&gt;.</source>
          <target state="translated">Flowのエディター統合は、主に&lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;Language Server Protocolを&lt;/a&gt;介して行われます。あり&lt;a href=&quot;https://microsoft.github.io/language-server-protocol/implementors/tools/&quot;&gt;、多くのvim LSPクライアント&lt;/a&gt;などから選択する、&lt;a href=&quot;#toc-ale&quot;&gt;ALEは&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35e134c2f20bf81b3b896daf47c04ac35fee3088" translate="yes" xml:space="preserve">
          <source>Flow&amp;rsquo;s shared memory lives in a memory mapped file. On more modern versions of Linux (3.17+), there is a system call &lt;code&gt;memfd_create&lt;/code&gt; which allows Flow to create the file anonymously and only in memory. However, in older kernels, Flow needs to create a file on the file system. Ideally this file lives on a memory-backed tmpfs. This option lets you decide where that file is created.</source>
          <target state="translated">フローの共有メモリは、メモリマップファイルにあります。Linuxの最新バージョン（3.17以降）では、フローがファイルを匿名でメモリ内にのみ作成できるようにするシステムコール &lt;code&gt;memfd_create&lt;/code&gt; があります。ただし、古いカーネルでは、Flowはファイルシステム上にファイルを作成する必要があります。理想的には、このファイルはメモリでバックアップされたtmpfs上にあります。このオプションでは、ファイルを作成する場所を決定できます。</target>
        </trans-unit>
        <trans-unit id="a151dc47e59f85e9ca3816a57d33d5371e099290" translate="yes" xml:space="preserve">
          <source>Flow-IDE</source>
          <target state="translated">Flow-IDE</target>
        </trans-unit>
        <trans-unit id="4dbea89f685901895c4ece7a62f739b66b6c8c38" translate="yes" xml:space="preserve">
          <source>Flow-Language-Support</source>
          <target state="translated">Flow-Language-Support</target>
        </trans-unit>
        <trans-unit id="52981c30a079c03c2816af01a0b63be9bf496116" translate="yes" xml:space="preserve">
          <source>Flow: Goals</source>
          <target state="translated">流れ:目標</target>
        </trans-unit>
        <trans-unit id="193cbf05588eacbb65a1c0ac7089a698e31d43b1" translate="yes" xml:space="preserve">
          <source>Flowlint Comments</source>
          <target state="translated">フローリントのコメント</target>
        </trans-unit>
        <trans-unit id="189ce1cc1d3d009f899bc0f0bdf7826fa8c95970" translate="yes" xml:space="preserve">
          <source>Follow the &lt;a href=&quot;https://github.com/w0rp/ale#3-installation&quot;&gt;instructions&lt;/a&gt; in the ALE README.</source>
          <target state="translated">ALE READMEの&lt;a href=&quot;https://github.com/w0rp/ale#3-installation&quot;&gt;指示&lt;/a&gt;に従ってください。</target>
        </trans-unit>
        <trans-unit id="6a6549a69a2a1d5be1e060e92d176ddae49cb2f2" translate="yes" xml:space="preserve">
          <source>Following our example from &lt;a href=&quot;#toc-objmap&quot;&gt;&lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, let&amp;rsquo;s assume that &lt;code&gt;run&lt;/code&gt; takes an array of functions, instead of an object, and maps over them returning an array of the function call results. We could annotate its return type like this:</source>
          <target state="translated">&lt;a href=&quot;#toc-objmap&quot;&gt; &lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;例に従って、 &lt;code&gt;run&lt;/code&gt; がオブジェクトではなく関数の配列を受け取り、それらをマップして関数呼び出しの結果の配列を返すと仮定します。この戻り型に次のように注釈を付けることができます。</target>
        </trans-unit>
        <trans-unit id="8a4d289d3b1dd5ba9aa2a66d282cd434d4d6eef2" translate="yes" xml:space="preserve">
          <source>For a full list of available lint rules, see the &lt;a href=&quot;https://flow.org/en/linting/rule-reference/&quot;&gt;Lint Rule Reference&lt;/a&gt;.</source>
          <target state="translated">使用可能なlintルールの完全なリストについては、「lint &lt;a href=&quot;https://flow.org/en/linting/rule-reference/&quot;&gt;ルールリファレンス」を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8b22a41ca2285196cb7b3e9c1ec2990d2a5b7b1" translate="yes" xml:space="preserve">
          <source>For cases like this where it&amp;rsquo;s useful to assert the absence of a property, Flow provides a special syntax for &lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;&amp;ldquo;exact&amp;rdquo; object types&lt;/a&gt;.</source>
          <target state="translated">このような、プロパティがないことをアサートすると便利な場合のために、Flowは&lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;「正確な」オブジェクトタイプの&lt;/a&gt;特別な構文を提供します。</target>
        </trans-unit>
        <trans-unit id="2ea9b94790107e111f7ed5653f532123efce19c9" translate="yes" xml:space="preserve">
          <source>For classes that take type parameters, you must also provide the parameter. For example:</source>
          <target state="translated">型のパラメータを取るクラスの場合は、パラメータも提供する必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="c6f67e406326ac835e3cac37e1771059c44a2f4c" translate="yes" xml:space="preserve">
          <source>For example if you want to get a normal JavaScript array from a &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; see the following example:</source>
          <target state="translated">たとえば、 &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; から通常のJavaScript配列を取得する場合は、次の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="eb4d70e0d036fa1748a5b85d77f3bc5e2328c134" translate="yes" xml:space="preserve">
          <source>For example, Flow uses structural typing for objects and functions, but nominal typing for classes.</source>
          <target state="translated">例えば、Flowではオブジェクトや関数には構造的な型付けを使用しますが、クラスには名目的な型付けを使用します。</target>
        </trans-unit>
        <trans-unit id="7349dc404f299437995005ad91a4e45b836943bc" translate="yes" xml:space="preserve">
          <source>For example, a type alias with a generic is parameterized. When you go to use it you will have to provide a type argument.</source>
          <target state="translated">例えば、ジェネリックを持つ型のエイリアスはパラメータ化されています。それを使いに行くときには、型の引数を与えなければなりません。</target>
        </trans-unit>
        <trans-unit id="019f85d55639d616f40bcfd5b84f65f5245b2f0d" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;/path/to/root/.flowconfig&lt;/code&gt; contains the following &lt;code&gt;[include]&lt;/code&gt; section:</source>
          <target state="translated">たとえば、/ &lt;code&gt;/path/to/root/.flowconfig&lt;/code&gt; に次の &lt;code&gt;[include]&lt;/code&gt; セクションが含まれている場合：</target>
        </trans-unit>
        <trans-unit id="8308d7d3a3b1e0a7a0c7ff7fe6095b8469e2ca83" translate="yes" xml:space="preserve">
          <source>For example, if we had a &lt;code&gt;TypeA&lt;/code&gt; which described the numbers 1 through 3, and a &lt;code&gt;TypeB&lt;/code&gt; which described the numbers 1 through 5: &lt;code&gt;TypeA&lt;/code&gt; would be considered a &lt;em&gt;subtype&lt;/em&gt; of &lt;code&gt;TypeB&lt;/code&gt;, because &lt;code&gt;TypeA&lt;/code&gt; is a subset of &lt;code&gt;TypeB&lt;/code&gt;.</source>
          <target state="translated">我々が持っていた場合、例えば、 &lt;code&gt;TypeA&lt;/code&gt; 3を介し番号1に記載し、 &lt;code&gt;TypeB&lt;/code&gt; 5までの数字1を説明： &lt;code&gt;TypeA&lt;/code&gt; 考えられる&lt;em&gt;サブタイプ&lt;/em&gt;の &lt;code&gt;TypeB&lt;/code&gt; ため、 &lt;code&gt;TypeA&lt;/code&gt; の部分集合である &lt;code&gt;TypeB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b1f46c1686b7fc66c7fe476a788c1c2f746e357" translate="yes" xml:space="preserve">
          <source>For example, if we had an &lt;code&gt;ObjectA&lt;/code&gt; which contained the key &lt;code&gt;foo&lt;/code&gt;, and an &lt;code&gt;ObjectB&lt;/code&gt; which contained the keys &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. Then it&amp;rsquo;s possible that &lt;code&gt;ObjectB&lt;/code&gt; is a subtype of &lt;code&gt;ObjectA&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;ObjectA&lt;/code&gt; があった場合キー含ま &lt;code&gt;foo&lt;/code&gt; 、そして &lt;code&gt;ObjectB&lt;/code&gt; に含まれるキーは &lt;code&gt;foo&lt;/code&gt; と &lt;code&gt;bar&lt;/code&gt; 。次に、 &lt;code&gt;ObjectB&lt;/code&gt; がObjectAのサブタイプである可能性があり &lt;code&gt;ObjectA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23d2a83693c74cdf1216f4c41606ab3b6344cfb1" translate="yes" xml:space="preserve">
          <source>For example, if we have a value with a union type that is a &lt;code&gt;number&lt;/code&gt;, a &lt;code&gt;boolean&lt;/code&gt;, or a &lt;code&gt;string&lt;/code&gt;, we can treat the number case separately by using JavaScript&amp;rsquo;s &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="translated">たとえば、 &lt;code&gt;number&lt;/code&gt; 、 &lt;code&gt;boolean&lt;/code&gt; 、または &lt;code&gt;string&lt;/code&gt; である共用体型の値がある場合、JavaScriptの &lt;code&gt;typeof&lt;/code&gt; 演算子を使用して、数値の大文字と小文字を個別に処理できます。</target>
        </trans-unit>
        <trans-unit id="6f0bba8ae13a9f5893bc26e1914082a5b9531069" translate="yes" xml:space="preserve">
          <source>For example, if you do:</source>
          <target state="translated">例えば、そうすると。</target>
        </trans-unit>
        <trans-unit id="65cad2079cddef1c7f55821c6579030cdb56abc4" translate="yes" xml:space="preserve">
          <source>For example, if you get a property on an object typed &lt;code&gt;any&lt;/code&gt;, the resulting value will also have the type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;any&lt;/code&gt; と入力されたオブジェクトのプロパティを取得すると、結果の値も &lt;code&gt;any&lt;/code&gt; 型になります。</target>
        </trans-unit>
        <trans-unit id="0d2c0eb517854e42dedcf683011bb1eed6441385" translate="yes" xml:space="preserve">
          <source>For example, if you merge two objects with a property named prop, one with a type of number and another with a type of boolean, the resulting object will have an intersection of number and boolean.</source>
          <target state="translated">例えば、propという名前のプロパティを持つ2つのオブジェクトをマージした場合、1つは数値型、もう1つはブール値型で、結果として得られるオブジェクトは数値とブール値の交点になります。</target>
        </trans-unit>
        <trans-unit id="0ff184d53e398a510529293cf769afe6beb5de53" translate="yes" xml:space="preserve">
          <source>For example, if you use &lt;code&gt;typeof&lt;/code&gt; with a class you need to remember that classes are &lt;em&gt;nominally&lt;/em&gt; typed instead of &lt;em&gt;structurally&lt;/em&gt; typed. So that two classes with the same exact shape are not considered equivalent.</source>
          <target state="translated">たとえば、クラスで &lt;code&gt;typeof&lt;/code&gt; を使用する場合、クラスは&lt;em&gt;構造的に&lt;/em&gt;型付けされるのではなく、&lt;em&gt;名目上&lt;/em&gt;型付けされることを覚えておく必要があります。そのため、形状がまったく同じ2つのクラスは同等とは見なされません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="725f953bd64b3a92b317e1b1004670c00e1cbdb9" translate="yes" xml:space="preserve">
          <source>For example, imagine we have a function for handling a response from a server after we&amp;rsquo;ve sent it a request. When the request is successful, we&amp;rsquo;ll get back an object with a &lt;code&gt;success&lt;/code&gt; property which is &lt;code&gt;true&lt;/code&gt; and a &lt;code&gt;value&lt;/code&gt; that we&amp;rsquo;ve updated.</source>
          <target state="translated">たとえば、リクエストを送信した後、サーバーからのレスポンスを処理する関数があるとします。リクエストが成功すると、 &lt;code&gt;true&lt;/code&gt; である &lt;code&gt;success&lt;/code&gt; プロパティと更新した &lt;code&gt;value&lt;/code&gt; を持つオブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="3102783616c1fb2ad801701f0f1fe894f5a7f3c4" translate="yes" xml:space="preserve">
          <source>For example, in order to know if you are calling a function correctly, Flow needs to compare the arguments you are passing with the parameters the function expects.</source>
          <target state="translated">例えば、関数を正しく呼び出しているかどうかを知るために、Flowは渡した引数と関数が期待するパラメータを比較する必要があります。</target>
        </trans-unit>
        <trans-unit id="b4c3b99484dfdd0c8d74a80cfc7020381cb7fd5b" translate="yes" xml:space="preserve">
          <source>For example, instead of accepting &lt;code&gt;number&lt;/code&gt; type, we could accept only the literal value &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;number&lt;/code&gt; 型を受け入れる代わりに、リテラル値 &lt;code&gt;2&lt;/code&gt; のみを受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="0d7e7c460bdc5abc1277e2c78f9349f50b395124" translate="yes" xml:space="preserve">
          <source>For example, the following code will not report any errors:</source>
          <target state="translated">例えば、以下のコードではエラーは報告されません。</target>
        </trans-unit>
        <trans-unit id="be2868a9fb7a2e636970247ed66a6e565dcb7b90" translate="yes" xml:space="preserve">
          <source>For example, the following function for cloning an object.</source>
          <target state="translated">例えば、オブジェクトをクローニングするための以下のような関数があります。</target>
        </trans-unit>
        <trans-unit id="c57d353ecaa5b9ae469153e8bd0494c2759cfd0e" translate="yes" xml:space="preserve">
          <source>For example, to figure out the result of the following expression, Flow needs to figure out what its values are first.</source>
          <target state="translated">例えば、以下の式の結果を求めるためには、Flowはまずその値が何であるかを把握する必要があります。</target>
        </trans-unit>
        <trans-unit id="c6c8a9ac1f5c16025ef387a60063c1bc2ea40cd1" translate="yes" xml:space="preserve">
          <source>For example, when you create an intersection of two objects with different sets of properties, it will result in an object with all of the properties.</source>
          <target state="translated">例えば、異なるプロパティのセットを持つ2つのオブジェクトの交点を作成すると、結果的にすべてのプロパティを持つオブジェクトが作成されます。</target>
        </trans-unit>
        <trans-unit id="be0defaf069697775abe92858214aa6eab2ca76b" translate="yes" xml:space="preserve">
          <source>For example, when you use literal values in Flow, their inferred type is the primitive that it belongs to. Thus, the number 42 has the inferred type of &lt;code&gt;number&lt;/code&gt;. You can see this when you use &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">たとえば、フローでリテラル値を使用する場合、それらの推定型はそれが属するプリミティブです。したがって、数値42には、推定されたタイプの &lt;code&gt;number&lt;/code&gt; ます。 &lt;code&gt;typeof&lt;/code&gt; を使用すると、これを確認できます。</target>
        </trans-unit>
        <trans-unit id="7a78f29fa972df73a82d620ebcbf55256b542d21" translate="yes" xml:space="preserve">
          <source>For example, you can create an intersection of a number and a string.</source>
          <target state="translated">例えば、数字と文字列の交点を作ることができます。</target>
        </trans-unit>
        <trans-unit id="c6bf9aa556ae7aa47497704d8a136318cf4656ef" translate="yes" xml:space="preserve">
          <source>For example, you can write:</source>
          <target state="translated">例えば、こんな風に書くことができます。</target>
        </trans-unit>
        <trans-unit id="41cd59ae29edba6c60d70a4800b3539e40d937dc" translate="yes" xml:space="preserve">
          <source>For example, you could be accessing an element that is out of the bounds of the array.</source>
          <target state="translated">例えば、配列の範囲外の要素にアクセスしているとします。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="8e7b3364aed4ab54bcb5fbf0be1c986544a80686" translate="yes" xml:space="preserve">
          <source>For files in your project without this flag, the Flow background process skips and ignores the code (unless you call &lt;code&gt;flow check --all&lt;/code&gt;, which is beyond the scope of basic usage).</source>
          <target state="translated">このフラグのないプロジェクト内のファイルの場合、フローバックグラウンドプロセスはコードをスキップして無視します（ &lt;code&gt;flow check --all&lt;/code&gt; を呼び出さない限り、これは基本的な使用の範囲を超えています）。</target>
        </trans-unit>
        <trans-unit id="6adf72d1444fb7909aee272ad9e96f51f02d4b69" translate="yes" xml:space="preserve">
          <source>For instance, in this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0sDciiNsAOxJ4SlHABUAnukqgAvKABCpSgGEmmAZQF45APlDpG6MvtAAeZaPUZB2vAG8AdC6OwTAX1A5plOQCIAIwBXHBxBf1BgPR5+ITwAcW1KLGQaRVDwgXlQAAoHHxkAGlAaAAtkaAATdgEPAEp5A3MQsMFvXzkC3y9BVWg0gGsu3MazOJJYaEonOABzXJYaAZpByiqWeo89B3LKmu0Pc2BWrJjeCbwMtoEALgoOHCcbTXspGXNdiura+6paJ4AOVgVUo2xyogkvlySS0qXSmUE9S4QA&quot;&gt;example&lt;/a&gt;, we don&amp;rsquo;t type the HOC (setType), but the component created with it, &lt;code&gt;Button&lt;/code&gt;. To do so, we use the type &lt;code&gt;React.ComponentType&lt;/code&gt;.</source>
          <target state="translated">たとえば、この&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0sDciiNsAOxJ4SlHABUAnukqgAvKABCpSgGEmmAZQF45APlDpG6MvtAAeZaPUZB2vAG8AdC6OwTAX1A5plOQCIAIwBXHBxBf1BgPR5+ITwAcW1KLGQaRVDwgXlQAAoHHxkAGlAaAAtkaAATdgEPAEp5A3MQsMFvXzkC3y9BVWg0gGsu3MazOJJYaEonOABzXJYaAZpByiqWeo89B3LKmu0Pc2BWrJjeCbwMtoEALgoOHCcbTXspGXNdiura+6paJ4AOVgVUo2xyogkvlySS0qXSmUE9S4QA&quot;&gt;例&lt;/a&gt;では、HOC（setType）を入力しませんが、それを使用して作成されたコンポーネント、 &lt;code&gt;Button&lt;/code&gt; ます。そのためには、タイプ &lt;code&gt;React.ComponentType&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="fdce77763d38af3a8b71abca1c0293dafa227070" translate="yes" xml:space="preserve">
          <source>For more on lazy modes, see the &lt;a href=&quot;../lang/lazy-modes&quot;&gt;lazy modes docs&lt;/a&gt;.</source>
          <target state="translated">レイジーモードの詳細については、 &lt;a href=&quot;../lang/lazy-modes&quot;&gt;レイジーモードのドキュメントを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c03eb76d06156d9151d583bf5017b60d060c9e8f" translate="yes" xml:space="preserve">
          <source>For objects like these, Flow provides a special kind of property, called an &amp;ldquo;indexer property.&amp;rdquo; An indexer property allows reads and writes using any key that matches the indexer key type.</source>
          <target state="translated">このようなオブジェクトに対して、Flowは「インデクサープロパティ」と呼ばれる特別な種類のプロパティを提供します。インデクサープロパティでは、インデクサーのキータイプと一致する任意のキーを使用した読み取りと書き込みが可能です。</target>
        </trans-unit>
        <trans-unit id="4ab0510537ce0eb4731a9b80070bc58fde2f4090" translate="yes" xml:space="preserve">
          <source>For that reason (and others), it&amp;rsquo;s useful to write types for important functions.</source>
          <target state="translated">そのため（そしてその他の理由で）、重要な関数の型を記述すると便利です。</target>
        </trans-unit>
        <trans-unit id="bdccfdba2af4464ab5f05d14e93c225840b2b001" translate="yes" xml:space="preserve">
          <source>For the &lt;a href=&quot;#toc-write-flow-code&quot;&gt;code above&lt;/a&gt;, running &lt;code&gt;flow&lt;/code&gt; will yield:</source>
          <target state="translated">&lt;a href=&quot;#toc-write-flow-code&quot;&gt;上記&lt;/a&gt;のコードの場合、 &lt;code&gt;flow&lt;/code&gt; 実行するをすると次の。</target>
        </trans-unit>
        <trans-unit id="0fff3409e13cd93e88e21ac5285c632cc985eaba" translate="yes" xml:space="preserve">
          <source>Forcing Flow to Treat a File as Focused</source>
          <target state="translated">ファイルをフォーカスされたものとして扱うための強制フロー</target>
        </trans-unit>
        <trans-unit id="cc51c13e52ce8d73c0bb48b450274afb9f82073c" translate="yes" xml:space="preserve">
          <source>Fortunately, JavaScript is already written using files as modules, so we modularize our analysis simply by asking that modules have explicitly typed signatures. (We still infer types for the vast majority of code &amp;ldquo;local&amp;rdquo; to modules.) Coincidentally, developers consider this good software engineering practice anyway.</source>
          <target state="translated">幸い、JavaScriptはすでにファイルをモジュールとして使用して記述されているため、モジュールに明示的に型指定された署名を要求するだけで分析をモジュール化します。（大部分のコードの型はモジュールに対して「ローカル」であると私たちはまだ推測しています。）偶然にも、開発者はとにかくこの優れたソフトウェアエンジニアリング手法を検討しています。</target>
        </trans-unit>
        <trans-unit id="1c86bf0b4a5d6b8fe12a31c428cd9618f1707a5a" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 機能させる</target>
        </trans-unit>
        <trans-unit id="751924331feba79685bd7ca453e7d70d1ee39798" translate="yes" xml:space="preserve">
          <source>Function Declarations</source>
          <target state="translated">関数宣言</target>
        </trans-unit>
        <trans-unit id="cec90ffa8d067cfb33c2b7e5ea59f57a4ab51f07" translate="yes" xml:space="preserve">
          <source>Function Parameters</source>
          <target state="translated">機能パラメータ</target>
        </trans-unit>
        <trans-unit id="8b80c6d0c0eb90a4193c11e2b8f639ce9765572d" translate="yes" xml:space="preserve">
          <source>Function Returns</source>
          <target state="translated">関数の戻り値</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes" xml:space="preserve">
          <source>Function Types</source>
          <target state="translated">機能の種類</target>
        </trans-unit>
        <trans-unit id="7cc900b0e76620e1c35c363651461063a5b2d0d3" translate="yes" xml:space="preserve">
          <source>Function parameters can also have defaults. This is a feature of ECMAScript 2015.</source>
          <target state="translated">関数のパラメータにはデフォルトを持つこともできます。これはECMAScript 2015の機能です。</target>
        </trans-unit>
        <trans-unit id="e686426824459378af5e98ab82feb0bfc1faa0e2" translate="yes" xml:space="preserve">
          <source>Function parameters can have types by adding a colon &lt;code&gt;:&lt;/code&gt; followed by the type after the name of the parameter.</source>
          <target state="translated">関数パラメーターは、コロンを追加することにより型を持つことができます &lt;code&gt;:&lt;/code&gt; パラメーター名の後に型が続きます。</target>
        </trans-unit>
        <trans-unit id="e20f19430f4406d7d479bb1219578533f21581f6" translate="yes" xml:space="preserve">
          <source>Function parameters with defaults</source>
          <target state="translated">デフォルトの関数パラメータ</target>
        </trans-unit>
        <trans-unit id="e628cf6d4cf7f3f60c7c92cf5e2c6d4764b18a50" translate="yes" xml:space="preserve">
          <source>Function returns can also add a type using a colon &lt;code&gt;:&lt;/code&gt; followed by the type after the list of parameters.</source>
          <target state="translated">関数の戻り値は、コロンを使用して型を追加することもできます &lt;code&gt;:&lt;/code&gt; パラメータのリストの後に型が続きます。</target>
        </trans-unit>
        <trans-unit id="31bf38f4775fc5c5a798a785e09ec45b75300cf9" translate="yes" xml:space="preserve">
          <source>Function types can create generics in the same way as normal functions, by adding the type parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; before the function type parameter list.</source>
          <target state="translated">関数型は、関数型パラメーターリストの前に型パラメーターリスト &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; を追加することにより、通常の関数と同じ方法でジェネリックを作成できます。</target>
        </trans-unit>
        <trans-unit id="1696fa363249b910e5a51ac92f7e2be6cd65b5b4" translate="yes" xml:space="preserve">
          <source>Function types with generics</source>
          <target state="translated">ジェネリックを持つ関数型</target>
        </trans-unit>
        <trans-unit id="3f7381fb33fff215013d059733e6eb1073506aa9" translate="yes" xml:space="preserve">
          <source>Functions are structurally typed</source>
          <target state="translated">関数は構造的に型付けされています</target>
        </trans-unit>
        <trans-unit id="7a2f0bb1d54ff79eaaada0c3765d727c899bb522" translate="yes" xml:space="preserve">
          <source>Functions can create generics by adding the type parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; before the function parameter list.</source>
          <target state="translated">関数は、関数パラメーターリストの前に型パラメーターリスト &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; を追加することでジェネリックを作成できます。</target>
        </trans-unit>
        <trans-unit id="d02cbcdf0a2a69aa715691fa238dfa6ccdc16a05" translate="yes" xml:space="preserve">
          <source>Functions can have optional parameters where a question mark &lt;code&gt;?&lt;/code&gt; comes after the parameter name.</source>
          <target state="translated">関数には、疑問符のあるオプションのパラメーターを含めることができます &lt;code&gt;?&lt;/code&gt; パラメータ名の後に続きます。</target>
        </trans-unit>
        <trans-unit id="cf63b2e1b9aafbb240f7e1deca5b67f9988ef437" translate="yes" xml:space="preserve">
          <source>Functions have two places where types are applied: Parameters (input) and the return value (output).</source>
          <target state="translated">関数には型が適用される場所が2箇所あります。パラメータ(入力)と戻り値(出力)です。</target>
        </trans-unit>
        <trans-unit id="3c12be471a4e96534a926aacb0df7453eb2cbcca" translate="yes" xml:space="preserve">
          <source>Functions with generics</source>
          <target state="translated">ジェネリックを持つ関数</target>
        </trans-unit>
        <trans-unit id="0c9ce2261f9d73896e79a1421f34d061659a9e49" translate="yes" xml:space="preserve">
          <source>General Best Practices</source>
          <target state="translated">一般的なベストプラクティス</target>
        </trans-unit>
        <trans-unit id="67ac7fcb0777deb807997c9f4b924988984d0fbd" translate="yes" xml:space="preserve">
          <source>Generally, the type you should first try when adding a type for the children of your React component is &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一般に、Reactコンポーネントの子の型を追加するときに最初に試すべき型は&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
          <target state="translated">一般的なタイプ</target>
        </trans-unit>
        <trans-unit id="f9d7e3ac4698ff4fedd01cf6807aee7a9efac823" translate="yes" xml:space="preserve">
          <source>Generic types act as bounds</source>
          <target state="translated">一般的な型は境界として機能します</target>
        </trans-unit>
        <trans-unit id="f8c73c016669e4acd2b923bc11fc67ea9ad59c62" translate="yes" xml:space="preserve">
          <source>Generic types work a lot like variables or function parameters except that they are used for types. You can use them whenever they are in scope.</source>
          <target state="translated">ジェネリック型は、型として使用されることを除いては、変数や関数のパラメータとよく似た働きをします。スコープ内であればいつでも使用することができます。</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">ジェネリクス</target>
        </trans-unit>
        <trans-unit id="1b3bd820ca45310f82d504b4fd55b7117cc37547" translate="yes" xml:space="preserve">
          <source>Generics (sometimes referred to as polymorphic types) are a way of abstracting a type away.</source>
          <target state="translated">ジェネリック(多相型と呼ばれることもあります)は、型を抽象化する方法です。</target>
        </trans-unit>
        <trans-unit id="a6fd94560566e4986674c54d1df1a19a7110e683" translate="yes" xml:space="preserve">
          <source>Generics act like variables</source>
          <target state="translated">ジェネリックは変数のように動作します。</target>
        </trans-unit>
        <trans-unit id="ef394c1226958fc727e62243c4cb43ac0e4cd5cf" translate="yes" xml:space="preserve">
          <source>Generics allow you to hold onto the more specific type while adding a constraint. In this way types on generics act as &amp;ldquo;bounds&amp;rdquo;.</source>
          <target state="translated">ジェネリックスを使用すると、制約を追加するときに、より具体的なタイプを保持できます。このようにして、ジェネリックの型は「境界」として機能します。</target>
        </trans-unit>
        <trans-unit id="4aadf67c9db3328742fd5a86fc24b21a1a76c43e" translate="yes" xml:space="preserve">
          <source>Generics can be used within functions, function types, classes, type aliases, and interfaces.</source>
          <target state="translated">ジェネリックは、関数、関数型、クラス、型のエイリアス、インターフェイス内で使用できます。</target>
        </trans-unit>
        <trans-unit id="7faae52c2d4462ab2eaff369392d43e6c1364b8c" translate="yes" xml:space="preserve">
          <source>Generics sometimes allow you to pass types in like arguments to a function. These are known as parameterized generics (or parametric polymorphism).</source>
          <target state="translated">ジェネリックでは、関数の引数のように型を渡すことができる場合があります。これはパラメータ化されたジェネリック(またはパラメトリックポリモルフィズム)として知られています。</target>
        </trans-unit>
        <trans-unit id="0d8ccea6ce861b3356a8a1401bc73a5e10e8c648" translate="yes" xml:space="preserve">
          <source>Generics track values around</source>
          <target state="translated">ジェネリックは、周囲の値を追跡します。</target>
        </trans-unit>
        <trans-unit id="cfcb0c850227d5c43ba836a3ca78b5b97f74a944" translate="yes" xml:space="preserve">
          <source>Gets the instance type for a React element. The instance will be different for various component types:</source>
          <target state="translated">React要素のインスタンス型を取得します。インスタンスは様々なコンポーネントタイプで異なります。</target>
        </trans-unit>
        <trans-unit id="236e116424d14004e90c27673c86a646ef19fa8e" translate="yes" xml:space="preserve">
          <source>Gets the props for a React element type, &lt;em&gt;without&lt;/em&gt; preserving the optionality of &lt;code&gt;defaultProps&lt;/code&gt;. &lt;code&gt;typeof Component&lt;/code&gt; could be the type of a React class component, a stateless functional component, or a JSX intrinsic string. This type is used for the &lt;code&gt;props&lt;/code&gt; property on &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; のオプションを保持&lt;em&gt;せずに&lt;/em&gt;、React要素タイプの小道具を取得します。 &lt;code&gt;typeof Component&lt;/code&gt; は、Reactクラスコンポーネント、ステートレス機能コンポーネント、またはJSX組み込み文字列のタイプです。このタイプは、&lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;props&lt;/code&gt; プロパティに使用されます。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">はじめに</target>
        </trans-unit>
        <trans-unit id="0ea124ff781dabd2f0647eac33da1b5dda4dac00" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt; representing instances of a class &lt;code&gt;C&lt;/code&gt;, the type &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; is the type of the class &lt;code&gt;C&lt;/code&gt;. For example:</source>
          <target state="translated">クラス &lt;code&gt;C&lt;/code&gt; のインスタンスを表すタイプ &lt;code&gt;T&lt;/code&gt; が与えられた場合、タイプ &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; はクラス &lt;code&gt;C&lt;/code&gt; のタイプです。例えば：</target>
        </trans-unit>
        <trans-unit id="851df84ffecc429e99c3dd230d56812d1b5b6739" translate="yes" xml:space="preserve">
          <source>Have a question about using Flow? Check here first!</source>
          <target state="translated">Flowの使い方についてご質問がありますか?まずはこちらをチェック</target>
        </trans-unit>
        <trans-unit id="2ddc501d850ae3a0f6c0d81b4cee3f2a7263c9d2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;props.children&lt;/code&gt; will be an array of arrays. Specifically &lt;code&gt;props.children&lt;/code&gt; will be &lt;code&gt;[[1, 2], [3, 4]]&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;props.children&lt;/code&gt; は配列の配列になります。具体的には、 &lt;code&gt;props.children&lt;/code&gt; は &lt;code&gt;[[1, 2], [3, 4]]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="3827f0f684068e8b08cda57d14ca02f9de4d36d2" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;React.Node&lt;/code&gt; as the prop type for children:</source>
          <target state="translated">子供のプロップタイプとしての &lt;code&gt;React.Node&lt;/code&gt; の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="c801032aa18d6a477cf713f1624762e4f08d3af9" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;React.Node&lt;/code&gt; being used as the return type to &lt;code&gt;render()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; の戻り値の型として使用されている &lt;code&gt;React.Node&lt;/code&gt; の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="bdd7a2f9607a075cf7fd0924bbed317c0eec84d4" translate="yes" xml:space="preserve">
          <source>Here is an example of how you could use the &lt;code&gt;.flowconfig&lt;/code&gt; directives.</source>
          <target state="translated">以下は、 &lt;code&gt;.flowconfig&lt;/code&gt; ディレクティブの使用例です。</target>
        </trans-unit>
        <trans-unit id="aa528d54a7d8103f41c0bfd3b9b8fae4b3e30c90" translate="yes" xml:space="preserve">
          <source>Here is how you may use &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; with &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; to construct a component with a specific set of props:</source>
          <target state="translated">&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; を&lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;と一緒に使用して、特定のプロップセットでコンポーネントを構築する方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="535fabe7a4cb455852726d03b7da421c7856e385" translate="yes" xml:space="preserve">
          <source>Here is how you would type the &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; component in Flow:</source>
          <target state="translated">フローに &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; コンポーネントを入力する方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="af8389a6ecc318bb6ebf315d56db66ecc756233e" translate="yes" xml:space="preserve">
          <source>Here the input value can only be a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">ここで入力された値は、唯一の可能 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25234e5462d0d0721c9abf9cb778d69feaeba093" translate="yes" xml:space="preserve">
          <source>Here the input value could be either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">ここで、入力値は &lt;code&gt;string&lt;/code&gt; または &lt;code&gt;number&lt;/code&gt; いずれかになります。</target>
        </trans-unit>
        <trans-unit id="87b8649ae5d0883f7fd9dfda5cfcf802e8591bd6" translate="yes" xml:space="preserve">
          <source>Here the passed in value is an unknown type, it could be any type and the function would still work.</source>
          <target state="translated">ここでは、渡された値は未知の型であり、任意の型であっても関数は動作します。</target>
        </trans-unit>
        <trans-unit id="17a73674e1d8aaed9bcfe2a7bd9df88099e17a9f" translate="yes" xml:space="preserve">
          <source>Here the return type will be the same as the type of whatever value is passed into the function.</source>
          <target state="translated">ここでは、戻り値の型は関数に渡された値の型と同じになります。</target>
        </trans-unit>
        <trans-unit id="13bad31d551f7ce53902bee6f5b588e74599b66e" translate="yes" xml:space="preserve">
          <source>Here you can see a pseudo-example of a nominal type system erroring out when you&amp;rsquo;re trying to put a &lt;code&gt;Bar&lt;/code&gt; where a &lt;code&gt;Foo&lt;/code&gt; is required because they have different names.</source>
          <target state="translated">ここでは、名前が異なるために &lt;code&gt;Foo&lt;/code&gt; が必要な場所に &lt;code&gt;Bar&lt;/code&gt; を配置しようとすると、名義型システムがエラーになる疑似例を見ることができます。</target>
        </trans-unit>
        <trans-unit id="098e77f7a550b2cf510ca26c4aeb1fba8e8580b9" translate="yes" xml:space="preserve">
          <source>Here you can see a pseudo-example of a structural type system passing when you&amp;rsquo;re trying to put a Bar where a &lt;code&gt;Foo&lt;/code&gt; is required because their structure is exactly the same.</source>
          <target state="translated">ここでは、 &lt;code&gt;Foo&lt;/code&gt; が必要な場所にBarを配置しようとしているときに構造型システムが通過する疑似例を示しています。これらの構造はまったく同じであるためです。</target>
        </trans-unit>
        <trans-unit id="9d42546ad988361114be19ba4faa6ffd09713b98" translate="yes" xml:space="preserve">
          <source>Here you can see the syntax for arrow functions with and without types added.</source>
          <target state="translated">ここでは、型が追加されている場合とされていない場合の矢印関数の構文を見ることができます。</target>
        </trans-unit>
        <trans-unit id="d3699f0333712613b9e8dd3485f37fca22346ed0" translate="yes" xml:space="preserve">
          <source>Here you can see the syntax for function declarations with and without types added.</source>
          <target state="translated">ここでは、型が追加されている場合とされていない場合の関数宣言の構文を見ることができます。</target>
        </trans-unit>
        <trans-unit id="56b22036dfc0a76c4f96b2794020b9590adaecf9" translate="yes" xml:space="preserve">
          <source>Here you can see the syntax for writing types that are functions.</source>
          <target state="translated">ここでは、関数である型を書くための構文を見ることができます。</target>
        </trans-unit>
        <trans-unit id="7fac12a07532dfa0ddfc895f9ad228b8e092de33" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a possible declaration of this function, which is very similar to our first example:</source>
          <target state="translated">この関数の可能な宣言は次のとおりです。これは、最初の例と非常によく似ています。</target>
        </trans-unit>
        <trans-unit id="fbf28fb6962ce31b4060a59b6e700daf856a84f6" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;showFoo&lt;/code&gt; is a boolean which controls whether or not to display the &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; element. If &lt;code&gt;showFoo&lt;/code&gt; is true, then this evaluates to &lt;code&gt;{&amp;lt;Foo/&amp;gt;}&lt;/code&gt;. If &lt;code&gt;showFoo&lt;/code&gt; is false, then this evaluates to &lt;code&gt;{false}&lt;/code&gt;, which doesn&amp;rsquo;t display anything.</source>
          <target state="translated">ここで、 &lt;code&gt;showFoo&lt;/code&gt; はブール値で、 &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; 要素を表示するかどうかを制御します。場合 &lt;code&gt;showFoo&lt;/code&gt; が真である場合、この評価し &lt;code&gt;{&amp;lt;Foo/&amp;gt;}&lt;/code&gt; 。 &lt;code&gt;showFoo&lt;/code&gt; がfalseの場合、これは &lt;code&gt;{false}&lt;/code&gt; と評価され、何も表示されません。</target>
        </trans-unit>
        <trans-unit id="a9f4df1640a61e73a368f05d84051cfbe689fd43" translate="yes" xml:space="preserve">
          <source>Here, Flow will complain on the &lt;code&gt;export&lt;/code&gt;, asking for a type annotation. Flow wants you to annotate exports returned by a generic function. The type of &lt;code&gt;Array.prototype.map&lt;/code&gt; is &lt;code&gt;map&amp;lt;U&amp;gt;(callbackfn: (value: T, index: number, array: Array&amp;lt;T&amp;gt;) =&amp;gt; U, thisArg?: any): Array&amp;lt;U&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;U&amp;gt;&lt;/code&gt; corresponds to what is called a &lt;a href=&quot;types/generics&quot;&gt;generic&lt;/a&gt;, to express the fact that the type of the function passed to map is linked to the type of the array.</source>
          <target state="translated">ここで、フローは、タイプアノテーションを要求する &lt;code&gt;export&lt;/code&gt; に不満を示します。フローでは、ジェネリック関数によって返されたエクスポートに注釈を付ける必要があります。 &lt;code&gt;Array.prototype.map&lt;/code&gt; のタイプは &lt;code&gt;map&amp;lt;U&amp;gt;(callbackfn: (value: T, index: number, array: Array&amp;lt;T&amp;gt;) =&amp;gt; U, thisArg?: any): Array&amp;lt;U&amp;gt;&lt;/code&gt; です。 &lt;code&gt;&amp;lt;U&amp;gt;&lt;/code&gt; と呼ばれるものに対応&lt;a href=&quot;types/generics&quot;&gt;一般的な&lt;/a&gt;マップに渡される機能のタイプは、アレイのタイプにリンクされていることを表現するために、。</target>
        </trans-unit>
        <trans-unit id="ee8ceb048fbb5cd5fd5303e935623ce260603c2b" translate="yes" xml:space="preserve">
          <source>Here, a work around would be to extract the part of the value you&amp;rsquo;re interested in, or to move the if check inside the &lt;code&gt;setTimeout&lt;/code&gt; call:</source>
          <target state="translated">ここでの回避 &lt;code&gt;setTimeout&lt;/code&gt; は、関心のある値の一部を抽出するか、またはsetTimeout呼び出し内でifチェックを移動することです。</target>
        </trans-unit>
        <trans-unit id="cc00b92fae87138445b8db76c9ab4f421cd563cb" translate="yes" xml:space="preserve">
          <source>Higher-order Components</source>
          <target state="translated">高次成分</target>
        </trans-unit>
        <trans-unit id="9afcd5258af293b3e8dd22ec752eba0c2f251483" translate="yes" xml:space="preserve">
          <source>How to use Flow from the command line. Including how to manage the Flow background process.</source>
          <target state="translated">コマンドラインからのFlowの使い方。Flowのバックグラウンドプロセスを管理する方法を含む。</target>
        </trans-unit>
        <trans-unit id="c6b59c452c954d9defbf04ad89b295d7369263a0" translate="yes" xml:space="preserve">
          <source>However it is limited in that this string only describes so much about the type.</source>
          <target state="translated">しかし、この文字列は型について多くのことを記述しているにすぎないという点で制限されています。</target>
        </trans-unit>
        <trans-unit id="a35ae847b7dbe7d8fd62853289ce430ad193bce8" translate="yes" xml:space="preserve">
          <source>However sometimes there isn&amp;rsquo;t a pre-existing libdef or you have third-party code that isn&amp;rsquo;t public and/or you really just need to write a libdef yourself. To do this you&amp;rsquo;ll start by creating a &lt;code&gt;.js&lt;/code&gt; file for each libdef you&amp;rsquo;re going to write and put them in the &lt;code&gt;/flow-typed&lt;/code&gt; directory at the root of your project. In these libdef file(s) you&amp;rsquo;ll use a special set of Flow syntax (explained below) to describe the interfaces of the relevant third-party code.</source>
          <target state="translated">ただし、既存のlibdefがない場合や、公開されていないサードパーティのコードがある場合や、実際にlibdefを作成する必要がある場合もあります。これを行うには、まず、作成するlibdefごとに &lt;code&gt;.js&lt;/code&gt; ファイルを作成し、プロジェクトのルートにある &lt;code&gt;/flow-typed&lt;/code&gt; ディレクトリに配置します。これらのlibdefファイルでは、関連するサードパーティコードのインターフェイスを記述するために、特別な一連のフロー構文（以下で説明）を使用します。</target>
        </trans-unit>
        <trans-unit id="1dabc8a9daa16baa576a945117465517c0ab5c57" translate="yes" xml:space="preserve">
          <source>However, Flow has &lt;a href=&quot;types/functions#toc-predicate-functions&quot;&gt;predicates functions&lt;/a&gt; that can do these checks via &lt;code&gt;%checks&lt;/code&gt;.</source>
          <target state="translated">ただし、フローには、 &lt;code&gt;%checks&lt;/code&gt; を介してこれらのチェックを実行できる&lt;a href=&quot;types/functions#toc-predicate-functions&quot;&gt;述語関数&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="27bb39d29e968deb761d41de85ea44344a3e8143" translate="yes" xml:space="preserve">
          <source>However, Flow will flag an error in the code below:</source>
          <target state="translated">しかし、Flowでは以下のコードでエラーフラグを立てます。</target>
        </trans-unit>
        <trans-unit id="067267fea785830c12b74c19441557fb234dc53a" translate="yes" xml:space="preserve">
          <source>However, evolving and growing a JavaScript codebase is notoriously challenging. Developers cannot move fast when they break stuff. They hit frequent interruptions, spending a lot of time debugging silly mistakes, unraveling assumptions and guarantees made by libraries written by others, etc.</source>
          <target state="translated">しかし、JavaScript のコードベースを進化させ、成長させることは困難なこととして知られています。開発者は、何かを壊したときに素早く動くことができません。頻繁に中断が発生したり、くだらないミスのデバッグに多くの時間を費やしたり、他の人が書いたライブラリの仮定や保証を解き明かしたりします。</target>
        </trans-unit>
        <trans-unit id="0a3b394df7ec3cd961692cc5e230a54570e64cb9" translate="yes" xml:space="preserve">
          <source>However, if you need to opt-out of the type checker, and don&amp;rsquo;t want to go all the way to &lt;code&gt;any&lt;/code&gt;, you can instead use &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt;. (Note that &lt;a href=&quot;../any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; is unsafe and should be avoided). For historical reasons, the &lt;code&gt;Function&lt;/code&gt; keyword is still available.</source>
          <target state="translated">しかし、あなたはオプトアウト型チェッカーのに必要な、すべての道に行きたくない場合は &lt;code&gt;any&lt;/code&gt; 、あなたの代わりに使用することができます &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt; 。（&lt;a href=&quot;../any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;も安全ではなく、回避する必要があることに注意してください）。歴史的な理由により、 &lt;code&gt;Function&lt;/code&gt; キーワードは引き続き使用できます。</target>
        </trans-unit>
        <trans-unit id="6d77a143534e87e9a163d3e3ce0aca8c4103e016" translate="yes" xml:space="preserve">
          <source>However, if you need to opt-out of the type checker, and don&amp;rsquo;t want to go all the way to &lt;code&gt;any&lt;/code&gt;, you could use &lt;code&gt;{[key:string]:any}&lt;/code&gt;. (Note that &lt;a href=&quot;../any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; is unsafe and should be avoided). For historical reasons, the &lt;code&gt;Object&lt;/code&gt; keyword is still available. In previous versions of Flow, &lt;code&gt;Object&lt;/code&gt; was the same as &lt;code&gt;{[key:string]:any}&lt;/code&gt;.</source>
          <target state="translated">あなたはオプトアウト型チェッカーのに必要な、すべての道に行きたくない場合は、 &lt;code&gt;any&lt;/code&gt; 、あなたが使用することができます &lt;code&gt;{[key:string]:any}&lt;/code&gt; 。（&lt;a href=&quot;../any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;も安全ではなく、回避する必要があることに注意してください）。歴史的な理由により、 &lt;code&gt;Object&lt;/code&gt; キーワードは引き続き使用できます。Flowの以前のバージョンでは、 &lt;code&gt;Object&lt;/code&gt; は &lt;code&gt;{[key:string]:any}&lt;/code&gt; と同じでした。</target>
        </trans-unit>
        <trans-unit id="f1e2c14006b12ab5491178ce01f3a9550f02756c" translate="yes" xml:space="preserve">
          <source>However, if you want to do anything more powerful with the React children API then you will need a strong intuition of how React handles children. Let us look at a couple of cases before continuing to help build that intuition.</source>
          <target state="translated">しかし、React children API を使ってより強力なことをしたいのであれば、React がどのように子を扱うのかについての強い直感が必要になります。その直観を構築する前に、いくつかのケースを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="f5931dcbe633762171ccee54a6f7889d2181ea61" translate="yes" xml:space="preserve">
          <source>However, it currently lacks support for on-the-fly type-checking (showing your type errors before you save your file).</source>
          <target state="translated">しかし、現在のところ、オンザフライのタイプチェック(ファイルを保存する前にタイプエラーを表示する)のサポートが不足しています。</target>
        </trans-unit>
        <trans-unit id="aec4e47a3799d3abd4efe1fc37df16b029a38bb9" translate="yes" xml:space="preserve">
          <source>However, it is not valid to use an object containing an &lt;code&gt;Person&lt;/code&gt; instance where an object containing a &lt;code&gt;Employee&lt;/code&gt; instance is expected.</source>
          <target state="translated">ただし、 &lt;code&gt;Employee&lt;/code&gt; インスタンスを含むオブジェクトが想定されている場所で、 &lt;code&gt;Person&lt;/code&gt; インスタンスを含むオブジェクトを使用することは無効です。</target>
        </trans-unit>
        <trans-unit id="d215123d1e8037cb7806bba06a88351e172e211e" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s often useful to know that a property is definitely absent.</source>
          <target state="translated">ただし、プロパティが確実に存在しないことを知っておくと役立つことがよくあります。</target>
        </trans-unit>
        <trans-unit id="9313de9dcdc57923e98881e802d0f7c94f24fa15" translate="yes" xml:space="preserve">
          <source>However, sometimes a Flow user might not care about all the code. If they are editing a file &lt;code&gt;foo.js&lt;/code&gt;, they might only want Flow to typecheck the subset of the repository needed to answer questions about &lt;code&gt;foo.js&lt;/code&gt;. Since Flow would only check a smaller number of files, this would be faster. This is the motivation behind Flow&amp;rsquo;s lazy modes.</source>
          <target state="translated">ただし、場合によっては、Flowユーザーがすべてのコードを気にする必要はありません。ファイル &lt;code&gt;foo.js&lt;/code&gt; を編集している場合、フローは &lt;code&gt;foo.js&lt;/code&gt; に関する質問に回答するために必要なリポジトリのサブセットをタイプチェックするだけでよいでしょう。Flowは少数のファイルしかチェックしないため、これはより高速になります。これがFlowのレイジーモードの背後にある動機です。</target>
        </trans-unit>
        <trans-unit id="0388504fdb624bb29d41874d436a861dd6df6661" translate="yes" xml:space="preserve">
          <source>However, there is also a fourth category.</source>
          <target state="translated">しかし、第四のカテゴリーもあります。</target>
        </trans-unit>
        <trans-unit id="bfac9f3c31434613c3dc25580cc54920b60f8937" translate="yes" xml:space="preserve">
          <source>However, this only happens with the inferred type. If you specify the literal type, it will be used in &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">ただし、これは推論された型でのみ発生します。リテラルタイプを指定すると、 &lt;code&gt;typeof&lt;/code&gt; で使用されます。</target>
        </trans-unit>
        <trans-unit id="60d9e12a6689ca1896d012bac4c1760061cf255c" translate="yes" xml:space="preserve">
          <source>However, to get around this you could use &lt;strong&gt;exact object types&lt;/strong&gt;.</source>
          <target state="translated">ただし、これを回避するには、&lt;strong&gt;正確なオブジェクトタイプを&lt;/strong&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="bf88ecdb532f0e02d70968558133c0d7b18ba5f0" translate="yes" xml:space="preserve">
          <source>However, type refinements can be lost. For instance, calling a function after refining the type of an object&amp;rsquo;s property will invalidate this refinement. Consult the &lt;a href=&quot;https://flow.org/en/lang/refinements/#toc-refinement-invalidations&quot;&gt;Refinement Invalidations&lt;/a&gt; docs for more details, to understand why Flow works this way, and how you can avoid this common pitfall.</source>
          <target state="translated">ただし、型の改良は失われる可能性があります。たとえば、オブジェクトのプロパティのタイプを絞り込んだ後で関数を呼び出すと、この絞り込みが無効になります。詳細については、&lt;a href=&quot;https://flow.org/en/lang/refinements/#toc-refinement-invalidations&quot;&gt;絞り込みの無効化の&lt;/a&gt;ドキュメントを参照して、フローがこのように機能する理由と、この一般的な落とし穴を回避する方法を理解してください。</target>
        </trans-unit>
        <trans-unit id="5fd3ba2f001a6fd526870acba3decc8fde5c658e" translate="yes" xml:space="preserve">
          <source>However, you can use the &lt;code&gt;+&lt;/code&gt; operator on strings or numbers, so this would also be valid.</source>
          <target state="translated">ただし、文字列または数値に &lt;code&gt;+&lt;/code&gt; 演算子を使用できるため、これも有効です。</target>
        </trans-unit>
        <trans-unit id="e35f724efeda49c47595a6cc2bbf2976ebcaafa9" translate="yes" xml:space="preserve">
          <source>I checked that &lt;code&gt;foo.bar&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, but Flow still thinks it is. Why does this happen and how can I fix it?</source>
          <target state="translated">私は &lt;code&gt;foo.bar&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; ではないことを確認しましたが、Flowはまだnullであると考えています。なぜこれが発生し、どうすれば修正できますか？</target>
        </trans-unit>
        <trans-unit id="6081ec65c275b7812a118a8d9487bec229a111d3" translate="yes" xml:space="preserve">
          <source>I checked that my object is of type A, so why does Flow still believe it&amp;rsquo;s A | B?</source>
          <target state="translated">私のオブジェクトがタイプAであることを確認したので、なぜFlowはまだそれがAであると考えているのですか？B？</target>
        </trans-unit>
        <trans-unit id="ab8ec6fa322ac3cb67fd8d12de1df1c19353b3b3" translate="yes" xml:space="preserve">
          <source>I got a &amp;ldquo;Missing type annotation&amp;rdquo; error. Where does it come from?</source>
          <target state="translated">「型注釈がありません」というエラーが発生しました。それはどこから来たのですか？</target>
        </trans-unit>
        <trans-unit id="547872d29b34bba7a1f46637da9812595a6bd96e" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m in a closure and Flow ignores the if check that asserts that &lt;code&gt;foo.bar&lt;/code&gt; is defined. Why?</source>
          <target state="translated">私はクロージャーにいるので、フローは &lt;code&gt;foo.bar&lt;/code&gt; が定義されていることをアサートするifチェックを無視します。どうして？</target>
        </trans-unit>
        <trans-unit id="1edc681e64e9bedc4b73a1b622b1bcd9c0221235" translate="yes" xml:space="preserve">
          <source>IDE Integration</source>
          <target state="translated">IDEの統合</target>
        </trans-unit>
        <trans-unit id="fa469552ea8a6956e0d85bd15a5b32e813e35a32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is, say, &lt;code&gt;5&lt;/code&gt;, then this displays &amp;ldquo;[5 comments]&amp;rdquo;. However, if &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then this displays &amp;ldquo;0&amp;rdquo; instead of displaying nothing. (This problem is unique to &lt;code&gt;number&lt;/code&gt; because &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; are the only falsy values which React renders with a visible result.) This could be subtly dangerous: if this immediately follows another numerical value, it might appear to the user that we have multiplied that value by 10! Instead, we should do a proper conditional check:</source>
          <target state="translated">場合は &lt;code&gt;count&lt;/code&gt; ある、と言う &lt;code&gt;5&lt;/code&gt; と、このディスプレイ「[5件のコメント]」。ただし、 &lt;code&gt;count&lt;/code&gt; が &lt;code&gt;0&lt;/code&gt; の場合、何も表示されず、「0」が表示されます。（この問題は &lt;code&gt;number&lt;/code&gt; 固有です &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;NaN&lt;/code&gt; は、Reactが表示する結果を表示する唯一の偽の値であるためです。）これは微妙に危険である可能性があります。これが別の数値の直後に続く場合、乗算したように見えるかもしれません10の値！代わりに、適切な条件チェックを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="39ad3382b221945428b6a2b474dff72bfb56707e" translate="yes" xml:space="preserve">
          <source>If Flow doesn&amp;rsquo;t know which index you are trying to access it will return all possible types.</source>
          <target state="translated">Flowがアクセスしようとしているインデックスがわからない場合、可能なすべてのタイプを返します。</target>
        </trans-unit>
        <trans-unit id="2c9c0dec7bafe53d2bbdf7d9959ddffbd2d70581" translate="yes" xml:space="preserve">
          <source>If Flow is unable to figure out what the exact type is for each value, Flow must figure out what every possible value is and check to make sure that the code around it will still work with all of the possible types.</source>
          <target state="translated">Flowが各値の正確な型を把握できない場合、Flowは可能なすべての値を把握し、その周りのコードが可能なすべての型でも動作することを確認しなければなりません。</target>
        </trans-unit>
        <trans-unit id="5acb8edfcd1e9dfddc6d2572d420f5b201ed318e" translate="yes" xml:space="preserve">
          <source>If a third-party library that has no type information is used by your project, Flow will treat it like any other untyped dependency and mark all of its exports as &lt;code&gt;any&lt;/code&gt;. Interestingly, this is the only place that Flow will implicitly inject &lt;code&gt;any&lt;/code&gt; into your program.</source>
          <target state="translated">タイプ情報のないサードパーティライブラリがプロジェクトで使用されている場合、Flowはそれを他の型なし依存関係と同様に扱い、すべてのエクスポートを &lt;code&gt;any&lt;/code&gt; としてマークします。興味深いことに、これは、Flowがプログラムに暗黙的に &lt;code&gt;any&lt;/code&gt; を注入する唯一の場所です。</target>
        </trans-unit>
        <trans-unit id="3eab7b55f7ee09f03bc495ed43d0061345e8a4e3" translate="yes" xml:space="preserve">
          <source>If no suppression comments are specified in your config, Flow will apply one default: &lt;code&gt;// $FlowFixMe&lt;/code&gt;.</source>
          <target state="translated">構成で抑制コメントが指定されていない場合、Flowは1つのデフォルトを適用します： &lt;code&gt;// $FlowFixMe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ab896379f8da8ccf06ebdb7660f6a676591eb88" translate="yes" xml:space="preserve">
          <source>If statements, functions, and other conditionally run code can all prevent Flow from being able to figure out precisely what a type will be.</source>
          <target state="translated">if文、関数、その他の条件付きで実行されるコードはすべて、Flowが型が何であるかを正確に把握できないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="b0c36449a1266a96a5edfbb603756422dc5a110c" translate="yes" xml:space="preserve">
          <source>If the values are numbers, then the expression results in a number. If the values are strings, then the expression results in a string. There are a number of different possibilities here, so Flow must look up what the values are.</source>
          <target state="translated">値が数値の場合、式の結果は数値になります。値が文字列の場合、式の結果は文字列となる。ここには多くの異なる可能性があるので、Flowは値が何であるかを調べなければなりません。</target>
        </trans-unit>
        <trans-unit id="5f9ff1c70b75813f87b337ccc40269423119c893" translate="yes" xml:space="preserve">
          <source>If these values on the object happen to be other objects, we would have to compare those against one another. We need to compare every value recursively until we can decide if we have a subtype or not.</source>
          <target state="translated">オブジェクト上のこれらの値がたまたま他のオブジェクトであった場合、それらの値を互いに比較しなければなりません。サブタイプがあるかどうかを判断できるようになるまで、すべての値を再帰的に比較する必要があります。</target>
        </trans-unit>
        <trans-unit id="dd58caf9f3de4a63117623155b1513d6eb2999e3" translate="yes" xml:space="preserve">
          <source>If this option is unspecified, Flow will always use the &lt;code&gt;&quot;main&quot;&lt;/code&gt; field.</source>
          <target state="translated">このオプションが指定されていない場合、フローは常に &lt;code&gt;&quot;main&quot;&lt;/code&gt; フィールドを使用します。</target>
        </trans-unit>
        <trans-unit id="76fac6bacf9983c96845e23339cd8c3466f2c7a7" translate="yes" xml:space="preserve">
          <source>If we cast through any, we can return a type which is more useful.</source>
          <target state="translated">任意のものをキャストすれば、より便利な型を返すことができます。</target>
        </trans-unit>
        <trans-unit id="a6d8ac03b1e20b9356423c837abe3ce7a0f6c016" translate="yes" xml:space="preserve">
          <source>If we now create a declaration file &lt;code&gt;src/Misc.js.flow&lt;/code&gt;, the declarations in it will be used instead of the code in &lt;code&gt;src/Misc.js&lt;/code&gt;. Let&amp;rsquo;s say we have the following declarations in &lt;code&gt;src/Misc.js.flow&lt;/code&gt;.</source>
          <target state="translated">ここで宣言ファイル &lt;code&gt;src/Misc.js.flow&lt;/code&gt; を作成すると、その中の宣言が &lt;code&gt;src/Misc.js&lt;/code&gt; のコードの代わりに使用されます。 &lt;code&gt;src/Misc.js.flow&lt;/code&gt; に次の宣言があるとします。</target>
        </trans-unit>
        <trans-unit id="fff93b7378aeb2b38b2090807b263b7014c5548e" translate="yes" xml:space="preserve">
          <source>If we prevented any code from ever writing a new value to the object through the &lt;code&gt;person&lt;/code&gt; variable, it would be safe to use the &lt;code&gt;employee&lt;/code&gt; variable. Flow provides a syntax for this:</source>
          <target state="translated">コードが &lt;code&gt;person&lt;/code&gt; 変数を介してオブジェクトに新しい値を書き込まないようにした場合、 &lt;code&gt;employee&lt;/code&gt; 変数を使用しても安全です。フローはこれのための構文を提供します：</target>
        </trans-unit>
        <trans-unit id="89439f8728f3f378c6012b648cca5749466a7c15" translate="yes" xml:space="preserve">
          <source>If we want to know whether one type is the subtype of another, we need to look at all the possible values for both types and figure out if the other has a &lt;em&gt;subset&lt;/em&gt; of the values.</source>
          <target state="translated">あるタイプが別のタイプのサブタイプであるかどうかを知りたい場合は、両方のタイプで考えられるすべての値を調べ、もう一方に値の&lt;em&gt;サブセット&lt;/em&gt;があるかどうかを調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="ffa5a5ea5efd7aef02382e7722a00a675b7afec3" translate="yes" xml:space="preserve">
          <source>If we want to validate what kinds of types are coming into our &lt;code&gt;cloneObject&lt;/code&gt; method from before, we could write the following annotation:</source>
          <target state="translated">以前から &lt;code&gt;cloneObject&lt;/code&gt; メソッドにどのような種類のデータが入ってくるのかを検証したい場合は、次の注釈を書くことができます。</target>
        </trans-unit>
        <trans-unit id="d9caf10c12ea9af18781cd6eef9ed4499bd31209" translate="yes" xml:space="preserve">
          <source>If we write into the &lt;code&gt;who&lt;/code&gt; property of the &lt;code&gt;person&lt;/code&gt; object, we&amp;rsquo;ve also changed the value of &lt;code&gt;employee.who&lt;/code&gt;, which is explicitly annotated to be an &lt;code&gt;Employee&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; &lt;code&gt;who&lt;/code&gt; プロパティに書いた場合オブジェクト、我々はまた、の値が変更されました &lt;code&gt;employee.who&lt;/code&gt; 明示的であることを注釈され、 &lt;code&gt;Employee&lt;/code&gt; インスタンスを。</target>
        </trans-unit>
        <trans-unit id="c0385bbba6e8a638e5b435911862d68f61aa402d" translate="yes" xml:space="preserve">
          <source>If you add the following to your configuration:</source>
          <target state="translated">設定に以下を追加すると</target>
        </trans-unit>
        <trans-unit id="2f6349a666bc7969b6c4063795a6da2f8498120d" translate="yes" xml:space="preserve">
          <source>If you already have a strong intuition about how React children work then feel free to &lt;a href=&quot;#examples&quot;&gt;skip to our examples demonstrating how to type various children patterns that commonly show up in React components&lt;/a&gt;.</source>
          <target state="translated">Reactの子がどのように機能するかについてすでに強い直感を持っている場合は&lt;a href=&quot;#examples&quot;&gt;、Reactコンポーネントに一般的に表示されるさまざまな子のパターンを入力する方法を示す例&lt;/a&gt;にスキップしても構いません。</target>
        </trans-unit>
        <trans-unit id="de34b40fb825239268317ed36dbb1e00f0c6608b" translate="yes" xml:space="preserve">
          <source>If you are using CommonJS you can also require React:</source>
          <target state="translated">CommonJSを使用している場合はReactも必要になります。</target>
        </trans-unit>
        <trans-unit id="25ad5bd918b70efe676da28a844513e673fd63f9" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have Babel setup already, you can do that by following &lt;a href=&quot;http://babeljs.io/docs/setup/&quot;&gt;this guide&lt;/a&gt;.</source>
          <target state="translated">まだBabelを設定していない場合は、次のようにして設定できます &lt;a href=&quot;http://babeljs.io/docs/setup/&quot;&gt;このガイドにてください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a69f0a892b7706fd7d381a10e9090d3be16821d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to add the type of your element instance you can also use &lt;code&gt;SyntheticEvent&lt;/code&gt; with &lt;em&gt;no&lt;/em&gt; type arguments like so: &lt;code&gt;SyntheticEvent&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">要素インスタンスのタイプを追加したくない場合は、 &lt;code&gt;SyntheticEvent&lt;/code&gt; を&lt;em&gt;noで&lt;/em&gt;使用することもできます。&lt;em&gt;&lt;/em&gt; &lt;code&gt;SyntheticEvent&amp;lt;&amp;gt;&lt;/code&gt; ように、タイプ引数。</target>
        </trans-unit>
        <trans-unit id="20d32713b2839dd2173444b2f9b4d7dcc4fe36ce" translate="yes" xml:space="preserve">
          <source>If you enable the &lt;code&gt;nonstrict-import&lt;/code&gt; rule in your Flow Strict configuration (recommended), then all dependencies of a strict file must also be strict. While this the optimal goal, for large pre-existing codebases it may be beneficial to allow some of the benefits of Flow Strict to be put in use before all dependencies are strict.</source>
          <target state="translated">有効にした場合 &lt;code&gt;nonstrict-import&lt;/code&gt; Flow Strict構成で非厳密インポートルール（推奨）、厳密ファイルのすべての依存関係も厳密である必要があります。これは最適な目標ですが、既存の大規模なコードベースの場合、すべての依存関係が厳格になる前にFlow Strictの利点の一部を使用できるようにすると有益な場合があります。</target>
        </trans-unit>
        <trans-unit id="7868511a9d06a4f8edf5d7a840c67f28e5c7774f" translate="yes" xml:space="preserve">
          <source>If you have an object that sometimes does not have a property you can make it an &lt;em&gt;optional property&lt;/em&gt; by adding a question mark &lt;code&gt;?&lt;/code&gt; after the property name in the object type.</source>
          <target state="translated">プロパティを持たないことがあるオブジェクトがある場合は、疑問符を追加することで&lt;em&gt;オプションのプロパティに&lt;/em&gt;することができます &lt;code&gt;?&lt;/code&gt; オブジェクトタイプのプロパティ名の後。</target>
        </trans-unit>
        <trans-unit id="4f24b7927c9085b7c250ed90664e78d83cbf1e68" translate="yes" xml:space="preserve">
          <source>If you need a return type for your component &lt;code&gt;render()&lt;/code&gt; methods then you should use &lt;code&gt;React.Node&lt;/code&gt;. However, if you need a generic type for a children prop, use &lt;code&gt;?React.Node&lt;/code&gt;; children can be undefined, when &lt;code&gt;render()&lt;/code&gt; can&amp;rsquo;t return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">コンポーネントの &lt;code&gt;render()&lt;/code&gt; メソッドの戻り値の型が必要な場合は、 &lt;code&gt;React.Node&lt;/code&gt; を使用する必要があります。ただし、子プロップのジェネリック型が必要な場合は、 &lt;code&gt;?React.Node&lt;/code&gt; を使用します。 &lt;code&gt;render()&lt;/code&gt; が戻らない場合、子は未定義にすることができます &lt;code&gt;undefined&lt;/code&gt; をない。</target>
        </trans-unit>
        <trans-unit id="abe11ee943e5dc689dcff158386be0fb8f22ac39" translate="yes" xml:space="preserve">
          <source>If you only want to specify some of the type arguments, you can use &lt;code&gt;_&lt;/code&gt; to let flow infer a type for you:</source>
          <target state="translated">型引数の一部のみを指定する場合は、 &lt;code&gt;_&lt;/code&gt; を使用できますをしてフローに型を推測させるます。</target>
        </trans-unit>
        <trans-unit id="a9a33f8497f3a49e54f6d651972b743d6f34b7b8" translate="yes" xml:space="preserve">
          <source>If you pass in a single value then &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that single value. Here &lt;code&gt;props.children&lt;/code&gt; will be the number 42. Importantly, &lt;code&gt;props.children&lt;/code&gt; will not be an array! It will be &lt;em&gt;exactly&lt;/em&gt; the number 42.</source>
          <target state="translated">あなたが単一の値を渡す場合、 &lt;code&gt;props.children&lt;/code&gt; はなり&lt;em&gt;まさに&lt;/em&gt;その単一の値。ここ &lt;code&gt;props.children&lt;/code&gt; は重要なことは、数42になります &lt;code&gt;props.children&lt;/code&gt; が配列されません！そうなる&lt;em&gt;正確に&lt;/em&gt;数42。</target>
        </trans-unit>
        <trans-unit id="0ccc08faa8b174c05c639636e1b782f03a991965" translate="yes" xml:space="preserve">
          <source>If you pass in no children when creating an element of &lt;code&gt;MyComponent&lt;/code&gt; then &lt;code&gt;props.children&lt;/code&gt; will not be set. If you try to access &lt;code&gt;props.children&lt;/code&gt;, it will be undefined.</source>
          <target state="translated">&lt;code&gt;MyComponent&lt;/code&gt; の要素を作成するときに子を渡さない場合、 &lt;code&gt;props.children&lt;/code&gt; は設定されません。アクセスしようとすると &lt;code&gt;props.children&lt;/code&gt; とすると、未定義になります。</target>
        </trans-unit>
        <trans-unit id="34ece29e3b89f75f011bf7528980bbd49fd066fa" translate="yes" xml:space="preserve">
          <source>If you then put all your source files in a &lt;code&gt;src&lt;/code&gt; directory you can compile them to another directory by running:</source>
          <target state="translated">次に、すべてのソースファイルを &lt;code&gt;src&lt;/code&gt; に入れますディレクトリに配置それらを別のディレクトリにコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="062faa0de803caab920638881f00d7513c947ac6" translate="yes" xml:space="preserve">
          <source>If you try to export a wrapped component, chances are that you&amp;rsquo;ll run into a missing annotation error:</source>
          <target state="translated">ラップされたコンポーネントをエクスポートしようとすると、アノテーションが見つからないというエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="309fcc8f3cc112f1e5bcf47ecdb839392b2659c4" translate="yes" xml:space="preserve">
          <source>If you want a way to opt-out of using the type checker, &lt;code&gt;any&lt;/code&gt; is the way to do it. &lt;strong&gt;Using &lt;code&gt;any&lt;/code&gt; is completely unsafe, and should be avoided whenever possible.&lt;/strong&gt;</source>
          <target state="translated">タイプチェッカーの使用をオプトアウトする方法が必要な場合は、 &lt;code&gt;any&lt;/code&gt; それを行うことができます。&lt;strong&gt; &lt;code&gt;any&lt;/code&gt; の&lt;/strong&gt;&lt;strong&gt;使用は完全に安全ではないため、可能な限り回避する必要があります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b005b1abd0cefd6c2751db329291eac30a6cd45" translate="yes" xml:space="preserve">
          <source>If you want to allow missing properties, use &lt;a href=&quot;../objects#toc-optional-object-type-properties&quot;&gt;optional property&lt;/a&gt; syntax, where the &lt;code&gt;?&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt; the colon. It is also possible to combine both syntaxes for an optional maybe type, for example &lt;code&gt;{value?:?number}&lt;/code&gt;.</source>
          <target state="translated">欠落しているプロパティを許可する場合は、&lt;a href=&quot;../objects#toc-optional-object-type-properties&quot;&gt;オプションのプロパティ&lt;/a&gt;構文を使用します &lt;code&gt;?&lt;/code&gt; コロンの&lt;em&gt;前に&lt;/em&gt;置かれます。オプションの多分タイプの両方の構文を組み合わせることも可能です。たとえば、 &lt;code&gt;{value?:?number}&lt;/code&gt; のます。</target>
        </trans-unit>
        <trans-unit id="f07f6bae6a75d430c4180eacf06f3bed1b73ebfb" translate="yes" xml:space="preserve">
          <source>If you want to have Flow treat a comment as if it were normal syntax, you can do so by adding a double colon &lt;code&gt;::&lt;/code&gt; to the start of the comment.</source>
          <target state="translated">Flowがコメントを通常の構文であるかのように処理したい場合は、ダブルコロンを追加することでできます &lt;code&gt;::&lt;/code&gt; :は、コメントの先頭にを。</target>
        </trans-unit>
        <trans-unit id="1b5ea02b142df74d92e6a6f721434f19c8193978" translate="yes" xml:space="preserve">
          <source>If you want to make it &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt; you can use parenthesis like: &lt;code&gt;(?Type)[]&lt;/code&gt;</source>
          <target state="translated">あなたはそれをしたい場合は &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt; あなたのような括弧を使用することができます &lt;code&gt;(?Type)[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="483317a13682411d8f1235de07f55cf867ba1719" translate="yes" xml:space="preserve">
          <source>If you wanted to use a class structurally you could do that by mixing them with objects as interfaces:</source>
          <target state="translated">構造的にクラスを使いたい場合は、インターフェースとしてオブジェクトと混ぜて使うことができます。</target>
        </trans-unit>
        <trans-unit id="d14412dd9ea135c9d1850cdc133b518a3da76d23" translate="yes" xml:space="preserve">
          <source>If you would like to add a type annotation to &lt;code&gt;defaultProps&lt;/code&gt; you can define the type as</source>
          <target state="translated">タイプ注釈を &lt;code&gt;defaultProps&lt;/code&gt; に追加する場合場合は、タイプを次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="0bd6e77a91375cf371a7745722382dbe962d5dda" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://atom.io&quot;&gt;Atom&lt;/a&gt; you have a bunch of options to integrate Flow into your code base.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io&quot;&gt;Atom&lt;/a&gt;を使用している場合は、Flowをコードベースに統合するための多くのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="67b20f92754a07891c76908aee9f1c454fc3a6ad" translate="yes" xml:space="preserve">
          <source>If your component does have &lt;code&gt;defaultProps&lt;/code&gt;, you don&amp;rsquo;t want to just add &lt;code&gt;Props&lt;/code&gt; as a type argument to &lt;code&gt;trivialHOC&lt;/code&gt; because that will get rid of the &lt;code&gt;defaultProps&lt;/code&gt; information that flow has about your component.</source>
          <target state="translated">あなたのコンポーネントが持っている場合は &lt;code&gt;defaultProps&lt;/code&gt; を、あなただけ追加したくない &lt;code&gt;Props&lt;/code&gt; するタイプの引数として &lt;code&gt;trivialHOC&lt;/code&gt; それは取り払うますので、 &lt;code&gt;defaultProps&lt;/code&gt; に関するフロー defaultProps情報。</target>
        </trans-unit>
        <trans-unit id="780a6023120264ade0b9dac9868692f3f30232eb" translate="yes" xml:space="preserve">
          <source>If your component has no &lt;code&gt;defaultProps&lt;/code&gt;, you can use &lt;code&gt;Props&lt;/code&gt; as a type argument for &lt;code&gt;Config&lt;/code&gt;.</source>
          <target state="translated">コンポーネントに &lt;code&gt;defaultProps&lt;/code&gt; がない場合は、 &lt;code&gt;Config&lt;/code&gt; の型引数として &lt;code&gt;Props&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="df8b42d3edaced78a9cf76e1330bae86b8d96c3b" translate="yes" xml:space="preserve">
          <source>If your context has a default value, Flow will type your consumer component accordingly:</source>
          <target state="translated">コンテキストにデフォルト値が設定されている場合、Flowはそれに応じてコンシューマコンポーネントを入力します。</target>
        </trans-unit>
        <trans-unit id="ae552724b48e29ed087f56eabc416631aed983c9" translate="yes" xml:space="preserve">
          <source>Ignores are processed AFTER includes. If you both include and ignore a file it will be ignored.</source>
          <target state="translated">無視はincludeの後に処理されます。インクルードと無視の両方を行った場合、ファイルは無視されます。</target>
        </trans-unit>
        <trans-unit id="90a346f6dee87e3209abc8b71fd3cfad11fc7766" translate="yes" xml:space="preserve">
          <source>Imagine the following &lt;code&gt;concat&lt;/code&gt; function for concatenating two strings together.</source>
          <target state="translated">次の &lt;code&gt;concat&lt;/code&gt; 想像してください2つの文字列を連結関数を。</target>
        </trans-unit>
        <trans-unit id="07e019c33eb53f751e20f583889e44cde2c245d3" translate="yes" xml:space="preserve">
          <source>Imagine we have the type &lt;code&gt;?number&lt;/code&gt;, if we want to use that value as a &lt;code&gt;number&lt;/code&gt; we&amp;rsquo;ll need to first check that it is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">我々が持っているタイプ想像 &lt;code&gt;?number&lt;/code&gt; 、私たちのように、その値を使用したい場合は、 &lt;code&gt;number&lt;/code&gt; 我々はそれがないことを最初に確認する必要があります &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6798e3c1aa807d4333e350015401a7abc70e80e3" translate="yes" xml:space="preserve">
          <source>Imagine writing the following &lt;code&gt;identity&lt;/code&gt; function which returns whatever value was passed.</source>
          <target state="translated">渡された値を返す次の &lt;code&gt;identity&lt;/code&gt; 関数を書くことを想像してみてください。</target>
        </trans-unit>
        <trans-unit id="ff623f8a9cd9b8f5349b3bb1da56c38d35cc87a1" translate="yes" xml:space="preserve">
          <source>Importing and exporting types</source>
          <target state="translated">タイプのインポートとエクスポート</target>
        </trans-unit>
        <trans-unit id="8b69719d369c12ce9cd0e7524c2b8530f01cb19f" translate="yes" xml:space="preserve">
          <source>Importing and exporting values</source>
          <target state="translated">値のインポートとエクスポート</target>
        </trans-unit>
        <trans-unit id="13534d9f1d5e200c3a0748880d5480a40ed54ff0" translate="yes" xml:space="preserve">
          <source>Impossible intersection types</source>
          <target state="translated">不可能な交差点の種類</target>
        </trans-unit>
        <trans-unit id="36f5825f27a921e30d7ea8251d8987b448c8e07c" translate="yes" xml:space="preserve">
          <source>In 0.89.0, we introduced &lt;a href=&quot;../types#toc-react-abstractcomponent&quot;&gt;&lt;code&gt;React.AbstractComponent&lt;/code&gt;&lt;/a&gt;, which gives you more expressive power when writing HOCs and library definitions.</source>
          <target state="translated">0.89.0で、React.AbstractComponentを導入し&lt;a href=&quot;../types#toc-react-abstractcomponent&quot;&gt; &lt;code&gt;React.AbstractComponent&lt;/code&gt; &lt;/a&gt;。これにより、HOCとライブラリ定義を作成する際の表現力が高まります。</target>
        </trans-unit>
        <trans-unit id="d23cd461e61670be17a5cbf84c124cd9f286a1b6" translate="yes" xml:space="preserve">
          <source>In Flow every value and expression has a type.</source>
          <target state="translated">Flowでは、すべての値や式は型を持っています。</target>
        </trans-unit>
        <trans-unit id="0b86cc8dc870697405ea856ce5507108777717a2" translate="yes" xml:space="preserve">
          <source>In Flow these fall into two groups:</source>
          <target state="translated">フローでは、これらは2つのグループに分類されます。</target>
        </trans-unit>
        <trans-unit id="18a40bb39b26a81dd8b90a84e6fcc2a7aa9f4ec7" translate="yes" xml:space="preserve">
          <source>In Flow this will cause an error because if you are expecting to get a return value of a &lt;code&gt;City&lt;/code&gt;, you may be using something that doesn&amp;rsquo;t exist on &lt;code&gt;Noun&lt;/code&gt;, which could easily cause an error at runtime.</source>
          <target state="translated">Flow では、 &lt;code&gt;City&lt;/code&gt; の戻り値を取得することを期待している場合、 &lt;code&gt;Noun&lt;/code&gt; に存在しないものを使用している可能性があるため、実行時にエラーが発生しやすく、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="878790a54a5224ef661b3530ee00eb752ab21af0" translate="yes" xml:space="preserve">
          <source>In Flow you can &lt;a href=&quot;../literals&quot;&gt;use union types similar to enums&lt;/a&gt;:</source>
          <target state="translated">フローでは&lt;a href=&quot;../literals&quot;&gt;、列挙型と同様のユニオンタイプ&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="e7fb60b92b4e843cc692009677f907537c735a2b" translate="yes" xml:space="preserve">
          <source>In Flow you can create tuples using the &lt;code&gt;[type, type, type]&lt;/code&gt; syntax.</source>
          <target state="translated">Flowでは、 &lt;code&gt;[type, type, type]&lt;/code&gt; 構文を使用してタプルを作成できます。</target>
        </trans-unit>
        <trans-unit id="1aed1690eff4b4d2b58bb1fcd12c1d5c6f001410" translate="yes" xml:space="preserve">
          <source>In Flow you don&amp;rsquo;t type annotate &lt;code&gt;this&lt;/code&gt; and Flow will check whatever context you call the function with.</source>
          <target state="translated">フローでは、 &lt;code&gt;this&lt;/code&gt; 注釈を入力する必要はありません。フローは、関数を呼び出すコンテキストをチェックします。</target>
        </trans-unit>
        <trans-unit id="1866b0c88cce2b9c6a8fee29c5128f64a2f80305" translate="yes" xml:space="preserve">
          <source>In Flow, it is considered safe to pass an object with extra properties where a normal object type is expected.</source>
          <target state="translated">Flowでは、通常のオブジェクト型が期待されるところでは、余分なプロパティを持つオブジェクトを渡しても安全だと考えられています。</target>
        </trans-unit>
        <trans-unit id="ce986f956cc22b12a2a6bfffc8a5a0edb258999c" translate="yes" xml:space="preserve">
          <source>In Flow, most of the time when you pass one type into another you lose the original type. So that when you pass a specific type into a less specific one Flow &amp;ldquo;forgets&amp;rdquo; it was once something more specific.</source>
          <target state="translated">フローでは、ほとんどの場合、あるタイプを別のタイプに渡すと、元のタイプが失われます。そのため、特定のタイプを特定性の低いものに渡す場合、フローは「忘れる」ことで、以前はより特定的なものでした。</target>
        </trans-unit>
        <trans-unit id="9a9bbf724831d747e94152055fbfe4af4a218e78" translate="yes" xml:space="preserve">
          <source>In Flow, there is a similar &lt;code&gt;typeof&lt;/code&gt; operator, but it&amp;rsquo;s much more powerful.</source>
          <target state="translated">Flowには、同様の &lt;code&gt;typeof&lt;/code&gt; 演算子がありますが、はるかに強力です。</target>
        </trans-unit>
        <trans-unit id="41f1a84e9859f569ee928b713503208cbf3bc5fb" translate="yes" xml:space="preserve">
          <source>In JavaScript there are many types of values: numbers, strings, booleans, functions, objects, and more.</source>
          <target state="translated">JavaScriptには、数値、文字列、ブーリアン、関数、オブジェクトなど、多くの種類の値があります。</target>
        </trans-unit>
        <trans-unit id="e94f6f8db81e235b729c1d11091229874c69e47d" translate="yes" xml:space="preserve">
          <source>In JavaScript, accessing a property that doesn&amp;rsquo;t exist evaluates to &lt;code&gt;undefined&lt;/code&gt;. This is a common source of errors in JavaScript programs, so Flow turns these into type errors.</source>
          <target state="translated">JavaScriptでは、存在しないプロパティにアクセスすると、 &lt;code&gt;undefined&lt;/code&gt; と評価されます。これはJavaScriptプログラムの一般的なエラーの原因であるため、Flowはこれらをタイプエラーに変換します。</target>
        </trans-unit>
        <trans-unit id="607c3a17b963c6542847246278eb0d806eb5228c" translate="yes" xml:space="preserve">
          <source>In Nuclide, Flow warnings are distinct from Flow errors and rendered in a different color.</source>
          <target state="translated">Nuclideでは、フロー警告はフローエラーとは区別され、異なる色で表示されます。</target>
        </trans-unit>
        <trans-unit id="8602c23e7637c0b355d504e31ab6ce9a57961195" translate="yes" xml:space="preserve">
          <source>In addition to classes, React also supports stateless functional components. You type these components like you would type a function:</source>
          <target state="translated">クラスに加えて、React はステートレスな機能コンポーネントもサポートしています。これらのコンポーネントは、関数をタイプするのと同じようにタイプします。</target>
        </trans-unit>
        <trans-unit id="5c3523d972cffa078864d6aecc1b5016808eb504" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;type&lt;/code&gt; in &lt;code&gt;?type&lt;/code&gt;, maybe types can also be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?type&lt;/code&gt; の &lt;code&gt;type&lt;/code&gt; に加えて、型は &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;void&lt;/code&gt; でもかまいません。</target>
        </trans-unit>
        <trans-unit id="a2ee11de69f40000610dfec7ac07ec5df1cfe68c" translate="yes" xml:space="preserve">
          <source>In addition to their set type, default parameters can also be &lt;code&gt;void&lt;/code&gt; or omitted altogether. However, they cannot be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">それらのセットタイプに加えて、デフォルトパラメータも &lt;code&gt;void&lt;/code&gt; か、完全に省略することができます。ただし、 &lt;code&gt;null&lt;/code&gt; にすることはできません。</target>
        </trans-unit>
        <trans-unit id="76f3ea7a16fcff8d257f8c2b1bf73e609afb8ca9" translate="yes" xml:space="preserve">
          <source>In addition to their set type, these optional parameters can either be &lt;code&gt;void&lt;/code&gt; or omitted altogether. However, they cannot be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">これらのオプションパラメータは、セットタイプに加えて、 &lt;code&gt;void&lt;/code&gt; することも完全に省略することもできます。ただし、 &lt;code&gt;null&lt;/code&gt; にすることはできません。</target>
        </trans-unit>
        <trans-unit id="05442271873e7bd4801123e6c257336f2ff42022" translate="yes" xml:space="preserve">
          <source>In addition to their set value type, these optional properties can either be &lt;code&gt;void&lt;/code&gt; or omitted altogether. However, they cannot be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">設定値タイプに加えて、これらのオプションのプロパティは、 &lt;code&gt;void&lt;/code&gt; することも完全に省略することもできます。ただし、 &lt;code&gt;null&lt;/code&gt; にすることはできません。</target>
        </trans-unit>
        <trans-unit id="eee0e3df17d7390f34a9ec9aa8fb61edb49a05a1" translate="yes" xml:space="preserve">
          <source>In all forms, whitespace and asterisks between words are ignored, allowing for flexible formatting.</source>
          <target state="translated">すべての形式で、単語間の空白やアスタリスクは無視され、柔軟な書式設定が可能になります。</target>
        </trans-unit>
        <trans-unit id="fc7fa03e8c32cc9ea9869eea330877a166bc87da" translate="yes" xml:space="preserve">
          <source>In an ideal world, every type checker would be both sound &lt;em&gt;and&lt;/em&gt; complete so that it catches &lt;em&gt;every&lt;/em&gt; error that &lt;em&gt;will&lt;/em&gt; happen at runtime.</source>
          <target state="translated">理想的な世界では、実行時に発生&lt;em&gt;する&lt;/em&gt;&lt;em&gt;すべての&lt;/em&gt;エラーをキャッチできるように、すべてのタイプチェッカーが健全&lt;em&gt;で&lt;/em&gt;完全なものに&lt;em&gt;なり&lt;/em&gt;ます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0e980406b01916b102c664aa8bc420ac8164cdd8" translate="yes" xml:space="preserve">
          <source>In case you&amp;rsquo;re looking for something even more minimal, &lt;a href=&quot;https://atom.io/packages/linter-flow&quot;&gt;linter-flow&lt;/a&gt; may be worth your attention. It only lints your code and provides no other features, but it does support on-the-fly linting.</source>
          <target state="translated">あなたがさらにもっと最小限の何かを探しているなら、&lt;a href=&quot;https://atom.io/packages/linter-flow&quot;&gt;リンターフロー&lt;/a&gt;注目する価値があります。コードをリントするだけで他の機能は提供しませんが、オンザフライリンティングをサポートします。</target>
        </trans-unit>
        <trans-unit id="9bffcd7b9f6bc8c106a178e285d7f231f68f3d4e" translate="yes" xml:space="preserve">
          <source>In general, programs have several different categories of types:</source>
          <target state="translated">一般的に、プログラムにはいくつかの異なる種類のカテゴリがあります。</target>
        </trans-unit>
        <trans-unit id="fd7f4f3ed72057427360f7865505bb3424508d31" translate="yes" xml:space="preserve">
          <source>In general, the function subtyping rule is this: A function type &lt;code&gt;B&lt;/code&gt; is a subtype of a function type &lt;code&gt;A&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s inputs are a superset of &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s, and &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s outputs are a subset of &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s. The subtype must accept &lt;em&gt;at least&lt;/em&gt; the same inputs as its parent, and must return &lt;em&gt;at most&lt;/em&gt; the same outputs.</source>
          <target state="translated">一般に、関数のサブタイピングルールは次のとおりです &lt;code&gt;B&lt;/code&gt; の入力が &lt;code&gt;A&lt;/code&gt; のスーパーセットであり、かつ &lt;code&gt;B&lt;/code&gt; の出力が &lt;code&gt;A&lt;/code&gt; のサブセットである場合にのみ、関数タイプ &lt;code&gt;B&lt;/code&gt; は関数タイプ &lt;code&gt;A&lt;/code&gt; のサブタイプです。。サブタイプは&lt;em&gt;、少なくとも&lt;/em&gt;その親と同じ入力を受け入れ&lt;em&gt;、最大&lt;/em&gt;で同じ出力を返す必要があります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a36883ee8e26a0df06cf9d297126b7d9d0279d23" translate="yes" xml:space="preserve">
          <source>In most editors, Flow warnings are likely to be rendered the same way as other warnings are rendered by that editor.</source>
          <target state="translated">ほとんどのエディタでは、フロー警告は、他の警告がそのエディタによってレンダリングされるのと同じ方法でレンダリングされる可能性が高い。</target>
        </trans-unit>
        <trans-unit id="3519b95ac1b03c724bc36beb2d830f52032a8ec0" translate="yes" xml:space="preserve">
          <source>In order to create a type cast expression around a &lt;code&gt;value&lt;/code&gt;, add a colon &lt;code&gt;:&lt;/code&gt; with the &lt;code&gt;Type&lt;/code&gt; and wrap the expression with parentheses &lt;code&gt;(&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">周りの型キャスト式を作成するためには &lt;code&gt;value&lt;/code&gt; 、コロンを追加 &lt;code&gt;:&lt;/code&gt; と &lt;code&gt;Type&lt;/code&gt; し、括弧付き表現をラップ &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a95a2762627991309d591271ba0f2cb553d8347" translate="yes" xml:space="preserve">
          <source>In order to make this safe, Flow would have to mark every single array access as &amp;ldquo;&lt;em&gt;possibly undefined&amp;rdquo;&lt;/em&gt;.</source>
          <target state="translated">これを安全にするために、フローはすべての単一の配列アクセスを「&lt;em&gt;おそらく未定義」&lt;/em&gt;としてマークする必要が&lt;em&gt;あり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="bf1c4a34bb0b2870f57375eef532ff3033ee975a" translate="yes" xml:space="preserve">
          <source>In order to type your Redux &lt;a href=&quot;http://redux.js.org/docs/advanced/AsyncActions.html#async-action-creators&quot;&gt;thunk actions&lt;/a&gt;, you&amp;rsquo;ll add types for &lt;code&gt;ThunkAction&lt;/code&gt; as a function &lt;code&gt;Dispatch&lt;/code&gt;, and &lt;code&gt;GetState&lt;/code&gt;. &lt;code&gt;GetState&lt;/code&gt; is a function that returns an &lt;code&gt;Object&lt;/code&gt;. &lt;code&gt;Dispatch&lt;/code&gt; accepts a disjoint union of &lt;code&gt;Action&lt;/code&gt;, &lt;code&gt;ThunkAction&lt;/code&gt;, &lt;code&gt;PromiseAction&lt;/code&gt; and &lt;code&gt;Array&amp;lt;Action&amp;gt;&lt;/code&gt; and can return &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Redux &lt;a href=&quot;http://redux.js.org/docs/advanced/AsyncActions.html#async-action-creators&quot;&gt;サンクアクション&lt;/a&gt;を入力するには、 &lt;code&gt;ThunkAction&lt;/code&gt; のタイプを関数 &lt;code&gt;Dispatch&lt;/code&gt; および &lt;code&gt;GetState&lt;/code&gt; として追加します。 &lt;code&gt;GetState&lt;/code&gt; は、 &lt;code&gt;Object&lt;/code&gt; を返す関数です。 &lt;code&gt;Dispatch&lt;/code&gt; は、 &lt;code&gt;Action&lt;/code&gt; 、 &lt;code&gt;ThunkAction&lt;/code&gt; 、 &lt;code&gt;PromiseAction&lt;/code&gt; 、および &lt;code&gt;Array&amp;lt;Action&amp;gt;&lt;/code&gt; 素結合を受け入れ、 &lt;code&gt;any&lt;/code&gt; を返すことができます。</target>
        </trans-unit>
        <trans-unit id="463948e140100316fb05c0438cb2fb9b2c50f529" translate="yes" xml:space="preserve">
          <source>In order to type your Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html#action-creators&quot;&gt;action creators&lt;/a&gt;, you&amp;rsquo;ll want to split up your &lt;code&gt;Action&lt;/code&gt; disjoint union into separate action types.</source>
          <target state="translated">Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html#action-creators&quot;&gt;アクションクリエーター&lt;/a&gt;を入力するには、 &lt;code&gt;Action&lt;/code&gt; 分離ユニオンを別々のアクションタイプに分割する必要があります。</target>
        </trans-unit>
        <trans-unit id="a6ed0c1cedb4575cb7b5ef3b66fc0929b6243133" translate="yes" xml:space="preserve">
          <source>In other words, we must engineer Flow&amp;rsquo;s analysis to be extremely fast&amp;mdash;it must respond to code changes without noticeable delay, while still being precise enough in practice.</source>
          <target state="translated">言い換えれば、フローの分析を非常に高速に行うように設計する必要があります。実際の精度を維持しながら、大幅な遅延なしにコードの変更に対応する必要があります。</target>
        </trans-unit>
        <trans-unit id="9ed3794afb3687160903becf6fab09177a6b9c44" translate="yes" xml:space="preserve">
          <source>In other words, we want Flow&amp;rsquo;s analysis to be precise in practice&amp;mdash;it must model essential characteristics of the language accurately enough to understand the difference between idiomatic code and unintentional mistakes.</source>
          <target state="translated">言い換えれば、実際にはFlowの分析を正確にする必要があります。これは、慣用的なコードと意図しない間違いの違いを理解するのに十分正確に言語の本質的な特性をモデル化する必要があります。</target>
        </trans-unit>
        <trans-unit id="9fb052ce5832a38b07cfb4b3b186920962dddf8c" translate="yes" xml:space="preserve">
          <source>In principle, this overhead can be mitigated by adding a layer of types to the codebase, and building tools that use type information to solve the above problems. For example, types can be used to identify bugs, to document interfaces of libraries, and so on.</source>
          <target state="translated">原則として、このオーバーヘッドは、コードベースに型のレイヤーを追加し、上記の問題を解決するために型情報を利用するツールを構築することで緩和することができます。例えば、型はバグの識別やライブラリのインターフェースの文書化などに利用することができます。</target>
        </trans-unit>
        <trans-unit id="46c0c160ff60aaa1954f2f13af37869b4cd1f894" translate="yes" xml:space="preserve">
          <source>In situations like this one, you can leverage the &lt;code&gt;$Keys&amp;lt;T&amp;gt;&lt;/code&gt; operator. Let&amp;rsquo;s see another example, this time using &lt;code&gt;$Keys&lt;/code&gt;:</source>
          <target state="translated">このような状況では、 &lt;code&gt;$Keys&amp;lt;T&amp;gt;&lt;/code&gt; 演算子を利用できます。今度は &lt;code&gt;$Keys&lt;/code&gt; を使用する別の例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="07ca63a4c55eeea9fee508bfce14ba359d037e35" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://facebook.github.io/react/docs/handling-events.html&quot;&gt;React docs &amp;ldquo;Handling Events&amp;rdquo; section&lt;/a&gt; a few different recommendations are provided on how to define event handlers. If you are using Flow we recommend that you use &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;property initializer syntax&lt;/a&gt; as it is the easiest to statically type. Property initializer syntax looks like this:</source>
          <target state="translated">では&lt;a href=&quot;https://facebook.github.io/react/docs/handling-events.html&quot;&gt;ドキュメント「イベント処理」セクションに反応&lt;/a&gt;いくつかの異なる勧告は、イベントハンドラを定義する方法に設けられています。フローを使用している場合は、静的&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;初期化&lt;/a&gt;が最も簡単なプロパティ初期化子構文を使用することをお勧めします。プロパティ初期化子の構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="045b4893ca1ae9c77490fd71764ad7b6d77ffa63" translate="yes" xml:space="preserve">
          <source>In the above case, we&amp;rsquo;re using literal values as &lt;code&gt;K&lt;/code&gt;, similarly to &lt;a href=&quot;#toc-propertytype&quot;&gt;&lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt;&lt;/a&gt;. However, when using &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt;, &lt;code&gt;K&lt;/code&gt; is allowed to be any type, as long as that type exists on the keys of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">上記のケースでは、&lt;a href=&quot;#toc-propertytype&quot;&gt; &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; &lt;/a&gt;と同様に、リテラル値を &lt;code&gt;K&lt;/code&gt; として使用しています。ただし、 &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; 使用する場合、 &lt;code&gt;T&lt;/code&gt; のキーにその型が存在する限り、 &lt;code&gt;K&lt;/code&gt; は任意の型にすることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="3f5298183f55322a9608c40096489e4fbda648b8" translate="yes" xml:space="preserve">
          <source>In the case of objects, a &lt;strong&gt;missing&lt;/strong&gt; property is not the same thing as an explicitly &lt;code&gt;undefined&lt;/code&gt; property.</source>
          <target state="translated">オブジェクトの場合、&lt;strong&gt;欠落している&lt;/strong&gt;プロパティは明示的に &lt;code&gt;undefined&lt;/code&gt; プロパティと同じではありません。</target>
        </trans-unit>
        <trans-unit id="4dd1fcffc78ce1a79e176af9465300a76e634c4a" translate="yes" xml:space="preserve">
          <source>In the code below, value can either be &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;B&quot;&lt;/code&gt;.</source>
          <target state="translated">以下のコードでは、値は &lt;code&gt;&quot;A&quot;&lt;/code&gt; または &lt;code&gt;&quot;B&quot;&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="de4288f8d4aaa876255c7f68bbbad7dd659c5cbb" translate="yes" xml:space="preserve">
          <source>In the example above we are using a &lt;a href=&quot;https://facebook.github.io/react/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous&quot;&gt;React &lt;code&gt;setState()&lt;/code&gt; updater function&lt;/a&gt; but you could also pass a partial state object to &lt;code&gt;setState()&lt;/code&gt;.</source>
          <target state="translated">上記の例では、&lt;a href=&quot;https://facebook.github.io/react/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous&quot;&gt;React &lt;code&gt;setState()&lt;/code&gt; アップデーター関数を使用して&lt;/a&gt;いますが、部分的な状態オブジェクトを &lt;code&gt;setState()&lt;/code&gt; に渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="78c833515da3868b1bb8e2586fa68f8aa20ca1b3" translate="yes" xml:space="preserve">
          <source>In the example above, the type of &lt;code&gt;Country&lt;/code&gt; is equivalent to &lt;code&gt;type Country = 'US' | 'IT' | 'FR'&lt;/code&gt;, but Flow was able to extract it from the keys of &lt;code&gt;countries&lt;/code&gt;.</source>
          <target state="translated">上記の例では、 &lt;code&gt;Country&lt;/code&gt; のタイプは、 &lt;code&gt;type Country = 'US' | 'IT' | 'FR'&lt;/code&gt; と同じです。'IT' | 'FR'ですが、Flowは &lt;code&gt;countries&lt;/code&gt; のキーからそれを抽出することができました。</target>
        </trans-unit>
        <trans-unit id="937e9cdc3d741999bdf658703ba5d2d9ee3fef52" translate="yes" xml:space="preserve">
          <source>In the first case, the exported types of a module are declared in a &lt;em&gt;declaration file&lt;/em&gt;&lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt;, that is located in the same directory as the corresponding &lt;em&gt;implementation file&lt;/em&gt;&lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt;. The declaration file completely shadows the colocated implementation. In other words, Flow will completely ignore &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; and just read &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; instead.</source>
          <target state="translated">最初のケースでは、モジュールのエクスポートされたタイプは、対応する&lt;em&gt;実装ファイル&lt;/em&gt; &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; と同じディレクトリにある&lt;em&gt;宣言ファイル&lt;/em&gt; &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; で&lt;em&gt;宣言&lt;/em&gt;&lt;em&gt;されます&lt;/em&gt;。宣言ファイルは、共存する実装を完全に隠蔽します。つまり、フローは &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; を完全に無視し、代わりに &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; を読み取るだけです。</target>
        </trans-unit>
        <trans-unit id="0f92740913668ddf1132fafd30e60ebce2409efa" translate="yes" xml:space="preserve">
          <source>In the following example, say you want to finish writing the function &lt;code&gt;fooList&lt;/code&gt; without bothering to mock up its dependencies first: a function &lt;code&gt;foo&lt;/code&gt; that takes a &lt;code&gt;number&lt;/code&gt; and returns a &lt;code&gt;string&lt;/code&gt;, and a class &lt;code&gt;List&lt;/code&gt; that has a &lt;code&gt;map&lt;/code&gt; method. You can do this by including declarations for &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">次の例では、最初に依存関係をモックアップせずに関数 &lt;code&gt;fooList&lt;/code&gt; の作成を終了したいとします。 &lt;code&gt;number&lt;/code&gt; を受け取って &lt;code&gt;string&lt;/code&gt; を返す関数 &lt;code&gt;foo&lt;/code&gt; と、 &lt;code&gt;map&lt;/code&gt; メソッドを持つクラス &lt;code&gt;List&lt;/code&gt; です。これを行うには、 &lt;code&gt;List&lt;/code&gt; と &lt;code&gt;foo&lt;/code&gt; の宣言を含めます。</target>
        </trans-unit>
        <trans-unit id="a2326d39f5c6c0c33efe4e847e245df6cca55d45" translate="yes" xml:space="preserve">
          <source>In the following example, we forget to properly annotate &lt;code&gt;identity&lt;/code&gt; with a generic type, so we run into trouble when we try to assign it to &lt;code&gt;func&lt;/code&gt;. On the other hand, &lt;code&gt;genericIdentity&lt;/code&gt; is properly typed, and we are able to use it as expected.</source>
          <target state="translated">次の例では、 &lt;code&gt;identity&lt;/code&gt; にジェネリック型を適切に注釈するのを忘れているため、 &lt;code&gt;func&lt;/code&gt; に割り当てようとすると問題が発生します。一方、 &lt;code&gt;genericIdentity&lt;/code&gt; は適切に型指定されているため、期待どおりに使用できます。</target>
        </trans-unit>
        <trans-unit id="1f9d0bf254d010bdd633b1f172693e7ad6fbe077" translate="yes" xml:space="preserve">
          <source>In the previous section we showed how refinement is lost after a function call. The exact same thing happens within closures, since Flow does not track how your value might change before the closure is called.</source>
          <target state="translated">前のセクションでは、関数呼び出し後に洗練が失われることを示しました。クロージャが呼び出される前に値がどのように変化するかをFlowは追跡しないため、クロージャの中でも全く同じことが起こります。</target>
        </trans-unit>
        <trans-unit id="26926ea42a5a5143965f679a788052c45d4b2dee" translate="yes" xml:space="preserve">
          <source>In the second case, the implementation file is missing entirely. &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; is treated as if it is named &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">2番目のケースでは、実装ファイルが完全に欠落しています。 &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; は、 &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; という名前の場合と同様に扱われます。</target>
        </trans-unit>
        <trans-unit id="b39b2010529d0c2ccb12cf90571d17f75bb0be7e" translate="yes" xml:space="preserve">
          <source>In the second example, the first use of &lt;code&gt;?.&lt;/code&gt; is valid, since &lt;code&gt;foo&lt;/code&gt; is potentially nullish, but the second use of &lt;code&gt;?.&lt;/code&gt; is unnecessary. The left-hand-side of the second &lt;code&gt;?.&lt;/code&gt; (&lt;code&gt;foo?.bar&lt;/code&gt;) can only be nullish as a result of &lt;code&gt;foo&lt;/code&gt; being nullish, and when &lt;code&gt;foo&lt;/code&gt; is nullish, short-circuiting lets us avoid the second &lt;code&gt;?.&lt;/code&gt; altogether!</source>
          <target state="translated">2番目の例では、 &lt;code&gt;?.&lt;/code&gt; の最初の使用。 &lt;code&gt;foo&lt;/code&gt; はnullになる可能性があるため有効ですが、 &lt;code&gt;?.&lt;/code&gt; 2番目の使用法です。不要です。2番目の左側 &lt;code&gt;?.&lt;/code&gt; （ &lt;code&gt;foo?.bar&lt;/code&gt; ）は、 &lt;code&gt;foo&lt;/code&gt; がnullishの結果としてのみnullishになる可能性があり、 &lt;code&gt;foo&lt;/code&gt; がnullishの場合、ショートサーキットにより2番目の &lt;code&gt;?.&lt;/code&gt; 回避できます。完全に！</target>
        </trans-unit>
        <trans-unit id="fe1405a89cd32b054392c7923e187f575819c2aa" translate="yes" xml:space="preserve">
          <source>In this guide we will assume you know &lt;a href=&quot;https://facebook.github.io/react/docs/hello-world.html&quot;&gt;the React basics&lt;/a&gt; and focus on adding types for patterns you are already familiar with. We will be using examples based on &lt;code&gt;react-dom&lt;/code&gt;, but all of these patterns work in other environments like &lt;code&gt;react-native&lt;/code&gt; as well.</source>
          <target state="translated">このガイドでは&lt;a href=&quot;https://facebook.github.io/react/docs/hello-world.html&quot;&gt;、読者がReactの基本&lt;/a&gt;を理解していることを前提とし、すでにおなじみのパターンにタイプを追加することに焦点を当てます。ここでは &lt;code&gt;react-dom&lt;/code&gt; に基づく例を使用しますが、これらのパターンはすべて、 &lt;code&gt;react-native&lt;/code&gt; などの他の環境でも機能します。</target>
        </trans-unit>
        <trans-unit id="1725f004837e7311155dfaefd968a330b6660337" translate="yes" xml:space="preserve">
          <source>In type systems, &lt;strong&gt;&lt;em&gt;soundness&lt;/em&gt;&lt;/strong&gt; is the ability for a type checker to catch every single error that &lt;em&gt;might&lt;/em&gt; happen at runtime. This comes at the cost of sometimes catching errors that will not actually happen at runtime.</source>
          <target state="translated">型システムでは、&lt;strong&gt;&lt;em&gt;健全性&lt;/em&gt;&lt;/strong&gt;は型チェッカーが実行時に発生する&lt;em&gt;可能性のある&lt;/em&gt;すべてのエラーをキャッチする機能です。これは、実行時に実際には発生しないエラーをときどきキャッチするという代償を伴います。</target>
        </trans-unit>
        <trans-unit id="0c22f8d1c20f6a2e728f54e6d0eb1c49eaf70b92" translate="yes" xml:space="preserve">
          <source>In which &lt;code&gt;props.children&lt;/code&gt; would be the array &lt;code&gt;['hello', ' ', &amp;lt;strong&amp;gt;world&amp;lt;/strong&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">これで &lt;code&gt;props.children&lt;/code&gt; は、配列になります &lt;code&gt;['hello', ' ', &amp;lt;strong&amp;gt;world&amp;lt;/strong&amp;gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ace6df33f153a56a5ba7bd262d1c9b70a75f2081" translate="yes" xml:space="preserve">
          <source>In which &lt;code&gt;props.children&lt;/code&gt; would be the array &lt;code&gt;['hello', ' world']&lt;/code&gt;.</source>
          <target state="translated">どの &lt;code&gt;props.children&lt;/code&gt; が配列 &lt;code&gt;['hello', ' world']&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="379e9d202df0a82bef07b8db10eab0a058f9a77e" translate="yes" xml:space="preserve">
          <source>Indexer properties can be mixed with named properties:</source>
          <target state="translated">インデクサのプロパティは、名前付きのプロパティと混合することができます。</target>
        </trans-unit>
        <trans-unit id="2bdd61bb5045aa0f67014c84f13de75c521599ec" translate="yes" xml:space="preserve">
          <source>Initialize Your Project</source>
          <target state="translated">プロジェクトの初期化</target>
        </trans-unit>
        <trans-unit id="8f1c0c5725c5ba0a7b766ec69cb3fb2725c240c3" translate="yes" xml:space="preserve">
          <source>Injecting Props</source>
          <target state="translated">小道具の注入</target>
        </trans-unit>
        <trans-unit id="830945c41eb45cbd674fe46b49ac731ee56e9c2d" translate="yes" xml:space="preserve">
          <source>Inlining declarations in regular code</source>
          <target state="translated">レギュラーコードでの宣言のインライン化</target>
        </trans-unit>
        <trans-unit id="9f834cdcbee4998ebcf13d92d61227888d432240" translate="yes" xml:space="preserve">
          <source>Inside of &lt;code&gt;otherMethod()&lt;/code&gt; we sometimes remove &lt;code&gt;prop&lt;/code&gt;. Flow doesn&amp;rsquo;t know if the &lt;code&gt;if (value.prop)&lt;/code&gt; check is still true, so it invalidates the refinement.</source>
          <target state="translated">&lt;code&gt;otherMethod()&lt;/code&gt; の内部では、時々 &lt;code&gt;prop&lt;/code&gt; を削除します。フローは、 &lt;code&gt;if (value.prop)&lt;/code&gt; チェックがまだ真であるかどうかを認識しないため、絞り込みが無効になります。</target>
        </trans-unit>
        <trans-unit id="59233b6f1516ac12e9141c55c7ddd0c26f41e51e" translate="yes" xml:space="preserve">
          <source>Inside of the else block we know that value must be &lt;code&gt;&quot;B&quot;&lt;/code&gt; because it can only be &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;B&quot;&lt;/code&gt; and we&amp;rsquo;ve removed &lt;code&gt;&quot;A&quot;&lt;/code&gt; from the possibilities.</source>
          <target state="translated">elseブロックの内部では、値は &lt;code&gt;&quot;B&quot;&lt;/code&gt; なければならないことがわかっています。これは、値が &lt;code&gt;&quot;A&quot;&lt;/code&gt; または &lt;code&gt;&quot;B&quot;&lt;/code&gt; のみであり、可能性から &lt;code&gt;&quot;A&quot;&lt;/code&gt; を削除したためです。</target>
        </trans-unit>
        <trans-unit id="e1d0007e9fb3d8a6684762ca326d9d60b18283cd" translate="yes" xml:space="preserve">
          <source>Inside of the if block we know that value must be &lt;code&gt;&quot;A&quot;&lt;/code&gt; because that&amp;rsquo;s the only time the if-statement will be truthy.</source>
          <target state="translated">ifブロックの内部では、値が &lt;code&gt;&quot;A&quot;&lt;/code&gt; なければならないことがわかっています。これは、ifステートメントが真実になるのはこのときだけだからです。</target>
        </trans-unit>
        <trans-unit id="4d19f21faddc0369982f34fb998d7a87e3e3ab91" translate="yes" xml:space="preserve">
          <source>Install the Package Control plugin if you don&amp;rsquo;t have it</source>
          <target state="translated">ない場合は、パッケージ制御プラグインをインストールします。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="287044f73b2dcfe1503bb32ec13af489f09a4131" translate="yes" xml:space="preserve">
          <source>Instance is optional and is mixed by default.</source>
          <target state="translated">インスタンスはオプションで、デフォルトでは混合されています。</target>
        </trans-unit>
        <trans-unit id="42265abaed207a8433bf897fbee94fabb9b7efc6" translate="yes" xml:space="preserve">
          <source>Instead of typing out a full include every time, you can also use the type annotation shorthand with a single colon &lt;code&gt;:&lt;/code&gt; at the start of the comment.</source>
          <target state="translated">代わりにフルを入力するたびに含まれ、あなたはまた、1つのコロンと型注釈速記を使用することができます &lt;code&gt;:&lt;/code&gt; コメントの開始時に。</target>
        </trans-unit>
        <trans-unit id="4f9d52dffb6f20d8a91f95ec202f836667e53109" translate="yes" xml:space="preserve">
          <source>Instead we can assert the type within the function using a type assertion and now we&amp;rsquo;re validating our inputs.</source>
          <target state="translated">代わりに、型アサーションを使用して関数内で型をアサートできます。これで、入力を検証しています。</target>
        </trans-unit>
        <trans-unit id="8a0cda6edccbb3f27daf363a3f9e17bc75002fbb" translate="yes" xml:space="preserve">
          <source>Instead we can create a generic (or polymorphic type) in our function and use it in place of other types.</source>
          <target state="translated">その代わりに、関数内に汎用型(または多相型)を作成して、他の型の代わりに使用することができます。</target>
        </trans-unit>
        <trans-unit id="18d4d0b561fd6c9ad913387087267f2acae3ec97" translate="yes" xml:space="preserve">
          <source>Instead you must ensure the value is a certain type by refining it.</source>
          <target state="translated">その代わりに、値を絞り込むことで、値が特定の型であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="bc437265bdc77498fe50689b8604c4782c5d0c38" translate="yes" xml:space="preserve">
          <source>Instead, Flow needs to be able to figure out the type of a value by analyzing it without running it (static analysis). It works its way through every known type and starts to figure out what all the expressions around them result in.</source>
          <target state="translated">その代わり、Flowは値を実行せずに解析することで値の型を把握できるようにする必要があります(静的解析)。Flowは、既知のすべての型を調べて、その周りのすべての式が何をもたらすのかを把握し始めます。</target>
        </trans-unit>
        <trans-unit id="cc0d73bb17ba9a6bc2ab84e4aeee29d97f21d5f9" translate="yes" xml:space="preserve">
          <source>Instead, if we create a union type of both object types, Flow will be able to know which object we&amp;rsquo;re using based on the success property.</source>
          <target state="translated">代わりに、両方のオブジェクトタイプのユニオンタイプを作成すると、Flowは、successプロパティに基づいて、使用しているオブジェクトを知ることができます。</target>
        </trans-unit>
        <trans-unit id="09971a8657fbf9e085d4cbb5f761ac73cf61af5d" translate="yes" xml:space="preserve">
          <source>Instead, you can use &lt;code&gt;interface&lt;/code&gt; in order to declare the structure of the class that you are expecting.</source>
          <target state="translated">代わりに、期待するクラスの構造を宣言するために &lt;code&gt;interface&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="7c9832840de0bf07db6e7e769199b00197d92be2" translate="yes" xml:space="preserve">
          <source>Instead, you could add a type to your generic like you would with a function parameter.</source>
          <target state="translated">その代わりに、関数のパラメータと同じようにジェネリックに型を追加することができます。</target>
        </trans-unit>
        <trans-unit id="4a7f5be1f3824ca58b2047493f6f9764ebebd43f" translate="yes" xml:space="preserve">
          <source>Interface Generics</source>
          <target state="translated">インターフェースジェネリック</target>
        </trans-unit>
        <trans-unit id="5c9516afee7b643e69c589c7e2bd6bb8f850ec3e" translate="yes" xml:space="preserve">
          <source>Interface Methods</source>
          <target state="translated">インターフェースメソッド</target>
        </trans-unit>
        <trans-unit id="8e3d0bc70c93775ccb76349f5bd2dd104013f378" translate="yes" xml:space="preserve">
          <source>Interface Properties</source>
          <target state="translated">インターフェースのプロパティ</target>
        </trans-unit>
        <trans-unit id="21a1595cfcababf257ea39c1df3d595d9106d56e" translate="yes" xml:space="preserve">
          <source>Interface Syntax</source>
          <target state="translated">インタフェース構文</target>
        </trans-unit>
        <trans-unit id="70f73f412d22faa3833d1fbb1c9b469c337baa08" translate="yes" xml:space="preserve">
          <source>Interface Types</source>
          <target state="translated">インターフェースの種類</target>
        </trans-unit>
        <trans-unit id="74724adee3fa147f0cfea79a04b9867eafea6d0a" translate="yes" xml:space="preserve">
          <source>Interface generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use an interface you need to pass parameters for each of its generics.</source>
          <target state="translated">インターフェイスジェネリックは&lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;パラメータ化されています&lt;/a&gt;。インターフェースを使用する場合、ジェネリックのそれぞれにパラメーターを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="ff0e2f95a23bc1a0a798148519f6dbf839797446" translate="yes" xml:space="preserve">
          <source>Interface properties are &lt;a href=&quot;https://flow.org/en/lang/variance/&quot;&gt;invariant&lt;/a&gt; by default. But you can add modifiers to make them covariant (read-only) or contravariant (write-only).</source>
          <target state="translated">インターフェースのプロパティはデフォルトでは&lt;a href=&quot;https://flow.org/en/lang/variance/&quot;&gt;不変&lt;/a&gt;です。ただし、修飾子を追加して、それらを共変（読み取り専用）または反変（書き込み専用）にすることができます。</target>
        </trans-unit>
        <trans-unit id="d3b1f8821225ec65ee0716fe750fde20ad499768" translate="yes" xml:space="preserve">
          <source>Interface properties can be optional as well.</source>
          <target state="translated">インターフェースのプロパティもオプションで指定できます。</target>
        </trans-unit>
        <trans-unit id="5eda7a98fcca8f4914f0766acaea5b5c31ce76c1" translate="yes" xml:space="preserve">
          <source>Interface property variance (read-only and write-only)</source>
          <target state="translated">インタフェースプロパティの分散(読み取り専用および書き込み専用</target>
        </trans-unit>
        <trans-unit id="8d1aa740c66ddff084a50256d6d5d30cf43e7c72" translate="yes" xml:space="preserve">
          <source>Interfaces are created using the keyword &lt;code&gt;interface&lt;/code&gt; followed by its name and a block which contains the body of the type definition.</source>
          <target state="translated">インターフェースは、キーワード &lt;code&gt;interface&lt;/code&gt; 後にその名前と型定義の本体を含むブロックを続けて作成されます。</target>
        </trans-unit>
        <trans-unit id="402c6f12d8378d77232d585fd7b337e32915eab4" translate="yes" xml:space="preserve">
          <source>Interfaces as maps</source>
          <target state="translated">マップとしてのインターフェイス</target>
        </trans-unit>
        <trans-unit id="1a13b883b189e50bf8951cacdf198f7feb8f80b6" translate="yes" xml:space="preserve">
          <source>Interfaces can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">インターフェイスは独自の&lt;a href=&quot;../generics&quot;&gt;ジェネリックを&lt;/a&gt;持つこともできます。</target>
        </trans-unit>
        <trans-unit id="5b5667cb6fa2d471880ebd263d10231bc9b5599a" translate="yes" xml:space="preserve">
          <source>Interfaces with generics</source>
          <target state="translated">ジェネリックとのインターフェース</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">交差点の種類</target>
        </trans-unit>
        <trans-unit id="9a31764a6d7e0f5c4582676c60aee1f2a34282cc" translate="yes" xml:space="preserve">
          <source>Intersection ranges, which are ANDed together, (e.g. &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt;, which matches &lt;code&gt;0.13.0&lt;/code&gt; and &lt;code&gt;0.13.5&lt;/code&gt; but not &lt;code&gt;0.14.0&lt;/code&gt;).</source>
          <target state="translated">AND &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt; 交差範囲（例&amp;gt; 0.10.1 &amp;lt;0.14.0。これは &lt;code&gt;0.13.0&lt;/code&gt; および &lt;code&gt;0.13.5&lt;/code&gt; に一致しますが、0.14.0には一致しませ &lt;code&gt;0.14.0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5f08815e0988cf77077de263c1ad9e7aa5845e9e" translate="yes" xml:space="preserve">
          <source>Intersection type syntax</source>
          <target state="translated">交差点型構文</target>
        </trans-unit>
        <trans-unit id="626a19ac04f2c67f93200f15583f19cead27a82f" translate="yes" xml:space="preserve">
          <source>Intersection types are any number of types which are joined by an ampersand &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">交差タイプは、アンパサンド &lt;code&gt;&amp;amp;&lt;/code&gt; で結合された任意のタイプのタイプです。</target>
        </trans-unit>
        <trans-unit id="8f7c84eb5f66c165a2d5dcc86fb36cae890387ee" translate="yes" xml:space="preserve">
          <source>Intersection types are the opposite of union types. When calling a function that accepts an intersection type, we must pass in &lt;strong&gt;&lt;em&gt;all of those types&lt;/em&gt;&lt;/strong&gt;. But inside of our function we only have to treat it as &lt;strong&gt;&lt;em&gt;any one of those types&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">交差タイプは、共用体タイプの反対です。交差型を受け入れる関数を呼び出すときは、&lt;strong&gt;&lt;em&gt;それらのすべての&lt;/em&gt;&lt;/strong&gt;型を渡す必要があり&lt;strong&gt;&lt;em&gt;ます&lt;/em&gt;&lt;/strong&gt;。しかし、関数の内部では&lt;strong&gt;&lt;em&gt;、それらをこれらのタイプのいずれか1つ&lt;/em&gt;&lt;/strong&gt;として扱う必要があり&lt;strong&gt;&lt;em&gt;ます&lt;/em&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="05fd5c57befbf7fcd9f20936b84629f69018650a" translate="yes" xml:space="preserve">
          <source>Intersection types require all in, but one out</source>
          <target state="translated">交差点のタイプは、すべての入力が必要ですが、1つの出力が必要です。</target>
        </trans-unit>
        <trans-unit id="b7a19c5413699eccc99e2d547ef6d10a7c3d1bef" translate="yes" xml:space="preserve">
          <source>Intersections of exact object types may not work as you expect. If you need to combine exact object types, use object type spread:</source>
          <target state="translated">厳密なオブジェクト型の交点は、思ったように動作しないことがあります。正確なオブジェクトタイプを組み合わせる必要がある場合は、オブジェクトタイプのスプレッドを使用してください。</target>
        </trans-unit>
        <trans-unit id="ef1118f07f2f0b37c8e805eac5ac7941bb61730b" translate="yes" xml:space="preserve">
          <source>Intersections of object types</source>
          <target state="translated">オブジェクトタイプの交点</target>
        </trans-unit>
        <trans-unit id="2abe56a8a00ed911e647b0d623cffa17d4460d9d" translate="yes" xml:space="preserve">
          <source>Invariance</source>
          <target state="translated">Invariance</target>
        </trans-unit>
        <trans-unit id="da76716b09b6ac18a389bcf77588eef885895f86" translate="yes" xml:space="preserve">
          <source>Invariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">不変性&lt;em&gt;は&lt;/em&gt;&lt;strong&gt;サブタイプを&lt;/strong&gt;受け入れ&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6653bcb7fefb5beca9669e196871c6f423594c47" translate="yes" xml:space="preserve">
          <source>Invariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">不変性&lt;em&gt;は&lt;/em&gt;&lt;strong&gt;スーパータイプを&lt;/strong&gt;受け入れ&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c6b07258a9d2edf9a12dc279bf478a7591587b4c" translate="yes" xml:space="preserve">
          <source>It can get a little bit more complicated than this.</source>
          <target state="translated">これよりも少し複雑になってしまうこともあります。</target>
        </trans-unit>
        <trans-unit id="1057c3d1333719898e827a2ee41fb627a60e7f29" translate="yes" xml:space="preserve">
          <source>It is also different from the &lt;code&gt;[declarations]&lt;/code&gt; section. This also does not typecheck the file contents, but &lt;code&gt;[declarations]&lt;/code&gt; does extract and use the signatures of functions, classes, etc, when checking other code.</source>
          <target state="translated">また、 &lt;code&gt;[declarations]&lt;/code&gt; セクションとは異なります。これもファイルの内容をタイプチェックしませんが、 &lt;code&gt;[declarations]&lt;/code&gt; は他のコードをチェックするときに、関数やクラスなどのシグネチャを抽出して使用します。</target>
        </trans-unit>
        <trans-unit id="d3fbd12c64d612ad1b02084fd80cefee8a6288b8" translate="yes" xml:space="preserve">
          <source>It is also possible to declare both &lt;strong&gt;named&lt;/strong&gt; and &lt;strong&gt;default&lt;/strong&gt; exports in the same &lt;code&gt;declare module&lt;/code&gt; body.</source>
          <target state="translated">同じ &lt;code&gt;declare module&lt;/code&gt; 本体で&lt;strong&gt;名前付き&lt;/strong&gt;エクスポートと&lt;strong&gt;デフォルト&lt;/strong&gt;エクスポートの両方を宣言することもでき&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f0d57b0ea07b126bc6a1382dc48f77a187c015b2" translate="yes" xml:space="preserve">
          <source>It is also possible to invalidate refinements, for example:</source>
          <target state="translated">また、例えば、リファインを無効にすることも可能です。</target>
        </trans-unit>
        <trans-unit id="c9db640a0ff9ca2d2098c8cf12f7a5222f3c36e9" translate="yes" xml:space="preserve">
          <source>It is common to have an empty &lt;code&gt;.flowconfig&lt;/code&gt; file for your project. However, you can &lt;a href=&quot;https://flow.org/en/config/&quot;&gt;configure and customize Flow&lt;/a&gt; in many ways through options available to be added to &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">プロジェクトには空の &lt;code&gt;.flowconfig&lt;/code&gt; ファイルを作成するのが一般的です。ただし、 &lt;code&gt;.flowconfig&lt;/code&gt; に追加できるオプションを使用して、&lt;a href=&quot;https://flow.org/en/config/&quot;&gt;フロー&lt;/a&gt;をさまざまな方法で構成およびカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="d64a8b56c9d350143c6c4049c479ee66c6fad872" translate="yes" xml:space="preserve">
          <source>It is often useful to share types in between modules (files). In Flow, you can export type aliases, interfaces, and classes from one file and import them in another.</source>
          <target state="translated">モジュール(ファイル)間で型を共有すると便利なことがよくあります。Flowでは、あるファイルから型のエイリアス、インターフェース、クラスをエクスポートし、別のファイルにインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="793822e10b49e7269fcbd5028ab19a2d3c9de56e" translate="yes" xml:space="preserve">
          <source>It may also be used as the return type of a stateless functional component:</source>
          <target state="translated">また、ステートレス関数コンポーネントの戻り値の型として使用することもできます。</target>
        </trans-unit>
        <trans-unit id="75369e827759c9f54ba9a23edbe8b02d79a3c6c7" translate="yes" xml:space="preserve">
          <source>It will compile to what you would expect: &lt;code&gt;React.createElement(MyComponent, {}, 42)&lt;/code&gt;.</source>
          <target state="translated">期待どおりにコンパイルされます： &lt;code&gt;React.createElement(MyComponent, {}, 42)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="083c10e6c6edff28e6273ebb5cfbc6a9d5dd4768" translate="yes" xml:space="preserve">
          <source>It would be hard to create a type for this because we&amp;rsquo;re creating a new object based on another object.</source>
          <target state="translated">別のオブジェクトに基づいて新しいオブジェクトを作成しているため、このタイプを作成するのは難しいでしょう。</target>
        </trans-unit>
        <trans-unit id="87f8da49eb8c969a18ca82d9274232c071921f87" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for JavaScript code to introduce &amp;ldquo;optional&amp;rdquo; values so that you have the option of leaving out the value or passing &lt;code&gt;null&lt;/code&gt; instead.</source>
          <target state="translated">JavaScriptコードが「オプション」の値を導入することはよくあるので、値を省略するか、代わりに &lt;code&gt;null&lt;/code&gt; を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="09d032ed6e922fe662f519234b7d555a3d8f5ecb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s safe to use an object with &amp;ldquo;extra&amp;rdquo; properties in a position that is annotated with a specific set of properties.</source>
          <target state="translated">特定のプロパティセットで注釈が付けられた位置に「追加の」プロパティを持つオブジェクトを使用しても安全です。</target>
        </trans-unit>
        <trans-unit id="64245667942d0f59a4c76fbe92eaa77e04d0970f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s valid to use an &lt;code&gt;Employee&lt;/code&gt; instance where a &lt;code&gt;Person&lt;/code&gt; instance is expected.</source>
          <target state="translated">&lt;code&gt;Person&lt;/code&gt; インスタンスが期待される場所で &lt;code&gt;Employee&lt;/code&gt; インスタンスを使用することは有効です。</target>
        </trans-unit>
        <trans-unit id="62185bdbfa583ea0a944a6564348a7230248cc32" translate="yes" xml:space="preserve">
          <source>JSX intrinsics like &lt;code&gt;div&lt;/code&gt; will give you their DOM instance. For &lt;code&gt;React.ElementRef&amp;lt;'div'&amp;gt;&lt;/code&gt; that would be &lt;code&gt;HTMLDivElement&lt;/code&gt;. For &lt;code&gt;React.ElementRef&amp;lt;'input'&amp;gt;&lt;/code&gt; that would be &lt;code&gt;HTMLInputElement&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;div&lt;/code&gt; のようなJSX組み込み関数は、DOMインスタンスを提供します。用 &lt;code&gt;React.ElementRef&amp;lt;'div'&amp;gt;&lt;/code&gt; になること &lt;code&gt;HTMLDivElement&lt;/code&gt; 。用 &lt;code&gt;React.ElementRef&amp;lt;'input'&amp;gt;&lt;/code&gt; となり &lt;code&gt;HTMLInputElement&lt;/code&gt; の。</target>
        </trans-unit>
        <trans-unit id="314a8a9290ad5ef0b2052cf134783f7c4c08b7c9" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;classes&lt;/a&gt; in Flow operate both as a value and a type.</source>
          <target state="translated">FlowのJavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;クラス&lt;/a&gt;は、値と型の両方として機能します。</target>
        </trans-unit>
        <trans-unit id="ff96432cd6c0749abc586d23ed4761948a7d9261" translate="yes" xml:space="preserve">
          <source>JavaScript also supports having rest parameters or parameters that collect an array of arguments at the end of a list of parameters. These have an ellipsis &lt;code&gt;...&lt;/code&gt; before them.</source>
          <target state="translated">JavaScriptは、残りのパラメーター、またはパラメーターのリストの最後に引数の配列を収集するパラメーターもサポートしています。これらには省略記号が &lt;code&gt;...&lt;/code&gt; 前にあります。</target>
        </trans-unit>
        <trans-unit id="33492c4de9d1778195557bc2a689c8efa4fb169f" translate="yes" xml:space="preserve">
          <source>JavaScript bugs can have significant impact at Facebook. Developers want to find and fix as many bugs as they can by the time their code rolls out into production. So we must care about soundness. At the same time, we must also care about not reporting too many spurious errors, because a low signal/noise ratio implies a low fix rate.</source>
          <target state="translated">JavaScriptのバグはFacebookで大きな影響を与える可能性があります。開発者は、コードが本番に出るまでにできるだけ多くのバグを見つけて修正したいと考えています。そのため、私たちは健全性に気を配らなければなりません。同時に、シグナル/ノイズ比が低いと修正率が低いことを意味するので、あまり多くのスプリアスエラーを報告しないように気をつけなければなりません。</target>
        </trans-unit>
        <trans-unit id="d19af2dce65e63655c2e776d25a142cbd6199eba" translate="yes" xml:space="preserve">
          <source>JavaScript can also implicitly convert other types of values into booleans.</source>
          <target state="translated">JavaScriptは、他の型の値を暗黙のうちにブーリアンに変換することもできます。</target>
        </trans-unit>
        <trans-unit id="485f1f2852599072f08415fb5cfd6b061d9a0dd4" translate="yes" xml:space="preserve">
          <source>JavaScript has a &lt;code&gt;typeof&lt;/code&gt; operator which returns a string describing a value.</source>
          <target state="translated">JavaScriptには、値を説明する文字列を返す &lt;code&gt;typeof&lt;/code&gt; 演算子があります。</target>
        </trans-unit>
        <trans-unit id="eecc786af80843327406bcc95d93039f0b604da8" translate="yes" xml:space="preserve">
          <source>JavaScript has a number of different primitive types (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures&quot;&gt;MDN&lt;/a&gt;):</source>
          <target state="translated">JavaScriptには、さまざまなプリミティブ型（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures&quot;&gt;MDN&lt;/a&gt;）がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="ce0fe7a86fd9b14d2fbe082506c653d7a9eeb404" translate="yes" xml:space="preserve">
          <source>JavaScript has both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;. Flow treats these as separate types: &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; (for &lt;code&gt;undefined&lt;/code&gt;).</source>
          <target state="translated">JavaScriptには &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; の両方があります。フローはこれらを別個のタイプとして扱います： &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;void&lt;/code&gt; （ &lt;code&gt;undefined&lt;/code&gt; の場合）。</target>
        </trans-unit>
        <trans-unit id="40359189cd32fdb5d25cf14079d2c89de3d26e61" translate="yes" xml:space="preserve">
          <source>JavaScript has three ways of declaring local variables:</source>
          <target state="translated">JavaScriptには、ローカル変数を宣言する3つの方法があります。</target>
        </trans-unit>
        <trans-unit id="377373e4c9e318e17a21d159b16d98d2f2d7a8f4" translate="yes" xml:space="preserve">
          <source>JavaScript implicitly converts other types of values into strings by concatenating them.</source>
          <target state="translated">JavaScriptは、他の型の値を連結することで暗黙のうちに文字列に変換します。</target>
        </trans-unit>
        <trans-unit id="db1d2f70ca60dcb812c319504dfac9c408dad07e" translate="yes" xml:space="preserve">
          <source>JavaScript: The Good and the Bad</source>
          <target state="translated">ジャバスクリプト 良いことと悪いこと</target>
        </trans-unit>
        <trans-unit id="1baa7d034b3c654fd892b56488a2e2906ca22f77" translate="yes" xml:space="preserve">
          <source>Just don&amp;rsquo;t forget to replace the declarations with proper implementations.</source>
          <target state="translated">宣言を適切な実装に置き換えることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="03cc07a06695efabc9bb1deed8b72855cef54594" translate="yes" xml:space="preserve">
          <source>Just like in functions, class methods can have annotations for both parameters (input) and returns (output).</source>
          <target state="translated">関数と同じように、クラスメソッドにもパラメータ (入力)とリターン (出力)の両方にアノテーションを付けることができます。</target>
        </trans-unit>
        <trans-unit id="f0796f6608e21ddf9f9cee05b46aec16a2404747" translate="yes" xml:space="preserve">
          <source>Just like other type imports, this code will be stripped away by a compiler and will not add a dependency on the other module.</source>
          <target state="translated">他の型のインポートと同様に、このコードはコンパイラによって取り除かれ、他のモジュールに依存関係を追加することはありません。</target>
        </trans-unit>
        <trans-unit id="6cfd51b40ca6ae71ea4ad94dee1f137fd72e5baa" translate="yes" xml:space="preserve">
          <source>Just note that &lt;code&gt;?Type[]&lt;/code&gt; is the equivalent of &lt;code&gt;?Array&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?Type[]&lt;/code&gt; は &lt;code&gt;?Array&amp;lt;T&amp;gt;&lt;/code&gt; と同等であり、 &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt; はないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4434db270fc0025e6dbf7944b0a7129f670d0468" translate="yes" xml:space="preserve">
          <source>LanguageClient-neovim</source>
          <target state="translated">LanguageClient-neovim</target>
        </trans-unit>
        <trans-unit id="95281a82e78ce2087d1012bf40625523f8488a7d" translate="yes" xml:space="preserve">
          <source>Languages like C++, Java, and Swift have primarily nominal type systems.</source>
          <target state="translated">C++、Java、Swiftなどの言語は、主に公称型システムを持っています。</target>
        </trans-unit>
        <trans-unit id="c792712a7965712fd189272a6613d98437d6180b" translate="yes" xml:space="preserve">
          <source>Languages like OCaml, Haskell, and Elm have primarily structural type systems.</source>
          <target state="translated">OCaml、Haskell、Elmなどの言語は、主に構造型システムを持っています。</target>
        </trans-unit>
        <trans-unit id="a8a1053bb6874133e95b37afbe211c7a892a815e" translate="yes" xml:space="preserve">
          <source>Lazy Modes</source>
          <target state="translated">怠惰なモード</target>
        </trans-unit>
        <trans-unit id="dfdfa63658de426609e22c38f88280bb9b75116d" translate="yes" xml:space="preserve">
          <source>Lazy mode tries to classify your code into four categories.</source>
          <target state="translated">遅延モードは、コードを4つのカテゴリに分類しようとします。</target>
        </trans-unit>
        <trans-unit id="3dbc910e4fff9344f64869a8a5fc5c3d4355ac06" translate="yes" xml:space="preserve">
          <source>Lazy mode will still find all the JavaScript files and parse them. But it won&amp;rsquo;t typecheck the unchecked files.</source>
          <target state="translated">レイジーモードでもすべてのJavaScriptファイルが検出され、解析されます。ただし、チェックされていないファイルはタイプチェックされません。</target>
        </trans-unit>
        <trans-unit id="ad97b5eba3e92f8085f952420bce8e282a6f3f53" translate="yes" xml:space="preserve">
          <source>Learn how the type system in Flow works: Subtyping, Variance, Refinements, and more.</source>
          <target state="translated">Flowの型システムがどのように機能するかを説明します。サブタイプ、分散、リファインメントなど。</target>
        </trans-unit>
        <trans-unit id="17c6582762d51b971201160cc102c9a657f98c40" translate="yes" xml:space="preserve">
          <source>Learn how to add Flow type annotations to your code: Primitives, Objects, Functions, Classes, and more.</source>
          <target state="translated">コードにフロー型アノテーションを追加する方法をご紹介します。プリミティブ、オブジェクト、関数、クラスなど。</target>
        </trans-unit>
        <trans-unit id="9061150cf645a8a07d4e182bd88b83043c6adeca" translate="yes" xml:space="preserve">
          <source>Learn how to configure Flow's linter to find potentially harmful code.</source>
          <target state="translated">有害な可能性のあるコードを検出するためのFlowのリンタの設定方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="ec546a6d98494e29fb29baba819e9036753ffc1c" translate="yes" xml:space="preserve">
          <source>Learn how to create and use library definitions for the third-party code your code depends on.</source>
          <target state="translated">あなたのコードが依存しているサードパーティのコードのためのライブラリ定義の作成方法と使用方法を学びます。</target>
        </trans-unit>
        <trans-unit id="81f0dff59c9c62d6cf866bb76b77e359a044ee03" translate="yes" xml:space="preserve">
          <source>Learn how to enable stricter type checking on a file-by-file basis.</source>
          <target state="translated">ファイル単位でより厳格な型チェックを有効にする方法を説明します。</target>
        </trans-unit>
        <trans-unit id="6b22d7b7814e7097977052e60714138c723c00f5" translate="yes" xml:space="preserve">
          <source>Learn how to use Flow to effectively type common and advanced React patterns.</source>
          <target state="translated">一般的なReactパターンと高度なReactパターンを効果的にタイプするためのFlowの使い方を学びます。</target>
        </trans-unit>
        <trans-unit id="2b9e35721f161da639af3e629c43a749a10c8d13" translate="yes" xml:space="preserve">
          <source>Learn how to write types in .flow files.</source>
          <target state="translated">.flowファイルでの型の書き方を学びます。</target>
        </trans-unit>
        <trans-unit id="89668dad1cc2803bc9a05873362cf34088114329" translate="yes" xml:space="preserve">
          <source>Less specific inputs &amp;mdash; Good</source>
          <target state="translated">あまり具体的でない入力&amp;mdash;良い</target>
        </trans-unit>
        <trans-unit id="923403997632248e58e2bb70246889bdff43c52c" translate="yes" xml:space="preserve">
          <source>Less specific outputs &amp;mdash; Bad</source>
          <target state="translated">具体的でない出力&amp;mdash;悪い</target>
        </trans-unit>
        <trans-unit id="56b22fadb66ce39178decbc7081dadaa222b6580" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a couple of more advanced examples:</source>
          <target state="translated">より高度な例をいくつか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4d2a79c6b93594188cbf9b55c1481295a10f9571" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a more general, and sometimes more convenient way to declare types for modules: &lt;code&gt;.flow&lt;/code&gt; files.</source>
          <target state="translated">モジュールの型を宣言する、より一般的で、時にはより便利な方法を見てみましょう： &lt;code&gt;.flow&lt;/code&gt; ファイル。</target>
        </trans-unit>
        <trans-unit id="e86757a83ce64508253852d9564cd9fe0caffc8b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite our function to handle each type individually.</source>
          <target state="translated">各タイプを個別に処理するように関数を書き換えましょう。</target>
        </trans-unit>
        <trans-unit id="9f80216838aa529f22c630c26f5b236d726d206d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a function type and a few functions. Which of the functions can be used safely in code that expects the given function type?</source>
          <target state="translated">関数タイプといくつかの関数があるとしましょう。指定された関数タイプを期待するコードで安全に使用できる関数はどれですか？</target>
        </trans-unit>
        <trans-unit id="19a72503865e9c4d4dbb4e6b8d83e9c6bb555f83" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see a couple of examples:</source>
          <target state="translated">いくつかの例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="3f378a2d680120a037a23d1a877c71075aaafcf4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see an example. Suppose you have a function called &lt;code&gt;run&lt;/code&gt; that takes an object of thunks (functions in the form &lt;code&gt;() =&amp;gt; A&lt;/code&gt;) as input:</source>
          <target state="translated">例を見てみましょう。サンクのオブジェクト &lt;code&gt;() =&amp;gt; A&lt;/code&gt; 形式の関数）を入力として受け取る &lt;code&gt;run&lt;/code&gt; という関数があるとします。</target>
        </trans-unit>
        <trans-unit id="32b252980a12fe72e87f2a649ca85e8a29abefd4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the simplest HOC:</source>
          <target state="translated">最も簡単なHOCから始めましょう。</target>
        </trans-unit>
        <trans-unit id="ffff4663a687b3c96978f5c3f0d326215fa1908f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at how you can type some example HOCs.</source>
          <target state="translated">HOCの例をいくつか入力する方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="f9b942f0b29382ee9e16a650bf2bb4ee6a83a2ac" translate="yes" xml:space="preserve">
          <source>Library Definitions</source>
          <target state="translated">ライブラリの定義</target>
        </trans-unit>
        <trans-unit id="de6d8b01f166fb75ee7809437032a5304f395753" translate="yes" xml:space="preserve">
          <source>Library definitions are considered strict (as they can be included in many different projects with contradicting strict configurations).</source>
          <target state="translated">ライブラリの定義は厳密とされています (矛盾する厳密な構成を持つ多くの異なるプロジェクトに含まれる可能性があるため)。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="1f94a87973cd7d8f6f84a5de26376923c65809ef" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-implicit-inexact-object&quot;&gt;&lt;code&gt;implicit-inexact-object&lt;/code&gt;&lt;/a&gt;, except triggers even when the &lt;code&gt;exact_by_default&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toc-implicit-inexact-object&quot;&gt; &lt;code&gt;implicit-inexact-object&lt;/code&gt; &lt;/a&gt;と同様ですが、 &lt;code&gt;exact_by_default&lt;/code&gt; オプションが &lt;code&gt;true&lt;/code&gt; に設定されている場合でもトリガーされます。</target>
        </trans-unit>
        <trans-unit id="99631d72797c2b4f916d1968332cece8d677359f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;typeof Component&lt;/code&gt; must be the type &lt;em&gt;of&lt;/em&gt; a React component so you need to use &lt;code&gt;typeof&lt;/code&gt; as in &lt;code&gt;React.ElementProps&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">同様&lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;typeof Component&lt;/code&gt; タイプでなければならない&lt;em&gt;の&lt;/em&gt;あなたが使用する必要があるように、コンポーネントを反応させ、 &lt;code&gt;typeof&lt;/code&gt; 演算のように &lt;code&gt;React.ElementProps&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afdeb072663138fc0c7eb121d5d1c44b8ac851c2" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;typeof Component&lt;/code&gt; must be the type &lt;em&gt;of&lt;/em&gt; a React component so you need to use &lt;code&gt;typeof&lt;/code&gt; as in &lt;code&gt;React.ElementRef&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">同様&lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;typeof Component&lt;/code&gt; タイプでなければならない&lt;em&gt;の&lt;/em&gt;あなたが使用する必要があるように、コンポーネントを反応させ、 &lt;code&gt;typeof&lt;/code&gt; 演算のように &lt;code&gt;React.ElementRef&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bfdd355019fb00dad0f94f122a17cd4e371ba06" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;typeof Component&lt;/code&gt; must be the type &lt;em&gt;of&lt;/em&gt; a React component so you need to use &lt;code&gt;typeof&lt;/code&gt; as in &lt;code&gt;React.Ref&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">同様&lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;typeof Component&lt;/code&gt; タイプでなければならない&lt;em&gt;の&lt;/em&gt;あなたが使用する必要があるように、コンポーネントを反応させ、 &lt;code&gt;typeof&lt;/code&gt; 演算のように &lt;code&gt;React.Ref&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbecb30c8c5786dd14c47738d4071ca6c0260abd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;React.ElementProps&amp;lt;typeof Component&amp;gt;&lt;/code&gt; this utility gets the type of a component&amp;rsquo;s props but &lt;em&gt;preserves&lt;/em&gt; the optionality of &lt;code&gt;defaultProps&lt;/code&gt;!</source>
          <target state="translated">同様 &lt;code&gt;React.ElementProps&amp;lt;typeof Component&amp;gt;&lt;/code&gt; このユーティリティは、コンポーネントの小道具の種類を取得しますが、&lt;em&gt;維持する&lt;/em&gt;のオプ &lt;code&gt;defaultProps&lt;/code&gt; を！</target>
        </trans-unit>
        <trans-unit id="d041aadefbd6307d2b548663eef27b76cecb7788" translate="yes" xml:space="preserve">
          <source>Like precision, speed also has other significant effects. When bugs are reported as the developer makes changes to code, they become part of the editing process&amp;mdash;the developer doesn&amp;rsquo;t need to run the code to detect bugs, and tracing bugs back to the code becomes simpler. Similarly, when the IDE can show the type of an expression, the definition reaching a reference, etc. as the developer is coding, we have observed that productivity can improve dramatically.</source>
          <target state="translated">精度と同様に、速度にも他の重要な影響があります。開発者がコードに変更を加えるときにバグが報告されると、それらは編集プロセスの一部になります。開発者はバグを検出するためにコードを実行する必要がなく、コードへのバグの追跡がより簡単になります。同様に、開発者がコーディングしているときにIDEが式のタイプ、参照に到達する定義などを表示できる場合、生産性が劇的に向上することがわかりました。</target>
        </trans-unit>
        <trans-unit id="59b86486aed4edafd59a372a9da15c32460385f0" translate="yes" xml:space="preserve">
          <source>Like this:</source>
          <target state="translated">こんな感じで。</target>
        </trans-unit>
        <trans-unit id="8f316525461e2a4c6c2b89d883cfb34c624544ab" translate="yes" xml:space="preserve">
          <source>Lint Rule Reference</source>
          <target state="translated">リントルールリファレンス</target>
        </trans-unit>
        <trans-unit id="d1bf3e3c86e73b07580c5c816b1b04837ea95e8f" translate="yes" xml:space="preserve">
          <source>Lint Settings Precedence</source>
          <target state="translated">リント設定の優先順位</target>
        </trans-unit>
        <trans-unit id="4dbc74e7618b9b038882a1a26b628723a0e3e49a" translate="yes" xml:space="preserve">
          <source>Lint settings can be specified in the &lt;code&gt;.flowconfig&lt;/code&gt; [lints] section as a list of &lt;code&gt;rule=severity&lt;/code&gt; pairs. These settings apply globally to the entire project.</source>
          <target state="translated">Lint設定は、 &lt;code&gt;.flowconfig&lt;/code&gt; [lints]セクションで &lt;code&gt;rule=severity&lt;/code&gt; ペアのリストとして指定できます。これらの設定は、プロジェクト全体にグローバルに適用されます。</target>
        </trans-unit>
        <trans-unit id="e24c1254981afd7ee28d2270b93ccfb59eae399a" translate="yes" xml:space="preserve">
          <source>Lint settings can be specified inside a file using &lt;code&gt;flowlint&lt;/code&gt; comments. These settings apply to a region of a file, or a single line, or part of a line. For more details see &lt;a href=&quot;flowlint-comments&quot;&gt;Flowlint Comments&lt;/a&gt;.</source>
          <target state="translated">Lint設定は、 &lt;code&gt;flowlint&lt;/code&gt; コメントを使用してファイル内で指定できます。これらの設定は、ファイルの領域、単一の行、または行の一部に適用されます。詳細については、&lt;a href=&quot;flowlint-comments&quot;&gt;Flowlintのコメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e5d62735922d047192446d6cc3f42ad67aea4c2d" translate="yes" xml:space="preserve">
          <source>Lint settings can be specified using the &lt;code&gt;--lints&lt;/code&gt; flag of a Flow server command as a comma-delimited list of &lt;code&gt;rule=severity&lt;/code&gt; pairs. These settings apply globally to the entire project.</source>
          <target state="translated">Lint設定は、フローサーバーコマンドの &lt;code&gt;--lints&lt;/code&gt; フラグを使用して、 &lt;code&gt;rule=severity&lt;/code&gt; ペアのコンマ区切りリストとして指定できます。これらの設定は、プロジェクト全体にグローバルに適用されます。</target>
        </trans-unit>
        <trans-unit id="24b2695bce6ad369789c8095fc314893c4855226" translate="yes" xml:space="preserve">
          <source>Lint settings in &lt;code&gt;flowlint&lt;/code&gt; comments have the highest priority, followed by lint rules in the &lt;code&gt;--lints&lt;/code&gt; flag, followed by the &lt;code&gt;.flowconfig&lt;/code&gt;. This order allows you to use &lt;code&gt;flowlint&lt;/code&gt; comments for fine-grained linting control, the &lt;code&gt;--lints&lt;/code&gt; flag for trying out new lint settings, and the &lt;code&gt;.flowconfig&lt;/code&gt; for stable project-wide settings.</source>
          <target state="translated">&lt;code&gt;flowlint&lt;/code&gt; コメントのLint設定が最も優先度が高く、次に &lt;code&gt;--lints&lt;/code&gt; フラグのlintルールが続き、その後に &lt;code&gt;.flowconfig&lt;/code&gt; が続きます。この順序は、あなたが使用することができます &lt;code&gt;flowlint&lt;/code&gt; 、きめの細かい糸くず制御のためのコメントを &lt;code&gt;--lints&lt;/code&gt; の新しい糸くずの設定を試すためのフラグ、および &lt;code&gt;.flowconfig&lt;/code&gt; 安定したプロジェクト全体の設定のために。</target>
        </trans-unit>
        <trans-unit id="b5dc277b08ab0a076088a55936d6bb1b36b56986" translate="yes" xml:space="preserve">
          <source>Linter-Flow</source>
          <target state="translated">Linter-Flow</target>
        </trans-unit>
        <trans-unit id="8740f6b1646315b108f5a7b7630739c109bdee42" translate="yes" xml:space="preserve">
          <source>Linting</source>
          <target state="translated">Linting</target>
        </trans-unit>
        <trans-unit id="0dad7bd175f8f98714812632da5a78ae6486cb98" translate="yes" xml:space="preserve">
          <source>Linting Overview</source>
          <target state="translated">リンティングの概要</target>
        </trans-unit>
        <trans-unit id="013e2bb1e1c48cce810f0e9392c090ca8d741740" translate="yes" xml:space="preserve">
          <source>List the lint rules to enable . These are strongly recommended:</source>
          <target state="translated">.Netflix を有効にするための lint ルールをリストアップします。これらを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="c5f9843abf3eea470a268920f6429a30a79e8c27" translate="yes" xml:space="preserve">
          <source>Literal Types</source>
          <target state="translated">リテラルタイプ</target>
        </trans-unit>
        <trans-unit id="fd4663b897abbd9f63aa1fb029df28511b239e0f" translate="yes" xml:space="preserve">
          <source>Look up types under cursor</source>
          <target state="translated">カーソルの下にあるタイプを調べる</target>
        </trans-unit>
        <trans-unit id="e8ed77b7f356c09433025e5f0c172332bccb8b7b" translate="yes" xml:space="preserve">
          <source>Makes Flow treat &lt;code&gt;require('foo.css')&lt;/code&gt; as if it were &lt;code&gt;require(PROJECT_ROOT + '/CSSFlowStub')&lt;/code&gt;.</source>
          <target state="translated">フローが &lt;code&gt;require('foo.css')&lt;/code&gt; を &lt;code&gt;require(PROJECT_ROOT + '/CSSFlowStub')&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="883a53b7e28c18b0803206061049c59ce3306d06" translate="yes" xml:space="preserve">
          <source>Maybe Types</source>
          <target state="translated">タイプ</target>
        </trans-unit>
        <trans-unit id="78d444312215f80221ea8f50dcd6255ebd40e280" translate="yes" xml:space="preserve">
          <source>Maybe types</source>
          <target state="translated">タイプ</target>
        </trans-unit>
        <trans-unit id="eeab6b1b5730d5897be20e8832d631c14302d02b" translate="yes" xml:space="preserve">
          <source>Maybe types accept the provided type as well as &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. So &lt;code&gt;?number&lt;/code&gt; would mean &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">たぶん型は提供された型と &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; を受け入れます。したがって、 &lt;code&gt;?number&lt;/code&gt; は、 &lt;code&gt;number&lt;/code&gt; 、 &lt;code&gt;null&lt;/code&gt; 、または &lt;code&gt;undefined&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="a099b97988d9786a09585297079102b85e29a055" translate="yes" xml:space="preserve">
          <source>Maybe types are for places where a value is optional and you can create them by adding a question mark in front of the type such as &lt;code&gt;?string&lt;/code&gt; or &lt;code&gt;?number&lt;/code&gt;.</source>
          <target state="translated">多分タイプは値がオプションである場所のためのもので、 &lt;code&gt;?string&lt;/code&gt; や &lt;code&gt;?number&lt;/code&gt; のようなタイプの前に疑問符を追加することでタイプを作成できます。</target>
        </trans-unit>
        <trans-unit id="0dc501bb2c0dd681d66351ee6c10f4bea3fa6bb6" translate="yes" xml:space="preserve">
          <source>Mixed Types</source>
          <target state="translated">混合タイプ</target>
        </trans-unit>
        <trans-unit id="38694f679fee1c9873abb6f0b39d8682bb35437c" translate="yes" xml:space="preserve">
          <source>Mixing nominal and structural typing</source>
          <target state="translated">名目タイプと構造タイプの混合</target>
        </trans-unit>
        <trans-unit id="a152ec7cc4a239412b5ec07e59dc705597177c82" translate="yes" xml:space="preserve">
          <source>Module Types</source>
          <target state="translated">モジュールの種類</target>
        </trans-unit>
        <trans-unit id="b2b4f329c4371fad34d57ca2c5ac16707d12ff70" translate="yes" xml:space="preserve">
          <source>More complex types like object or classes have more complex structures. They each get their own name even if they sometimes have the same structure overall.</source>
          <target state="translated">オブジェクトやクラスのようなより複雑な型は、より複雑な構造を持っています。全体的に同じ構造を持つことがあっても、それらはそれぞれ独自の名前を取得します。</target>
        </trans-unit>
        <trans-unit id="778013c00f70ed72cb3d9f3f32da1db73e971c69" translate="yes" xml:space="preserve">
          <source>More specific inputs &amp;mdash; Bad</source>
          <target state="translated">より具体的な入力&amp;mdash;悪い</target>
        </trans-unit>
        <trans-unit id="5ce86c0f6222882e371b81384532e8ef38f27254" translate="yes" xml:space="preserve">
          <source>More specific outputs &amp;mdash; Good</source>
          <target state="translated">より具体的な出力&amp;mdash;良い</target>
        </trans-unit>
        <trans-unit id="d01518022ba66aff4ed5b2b63c6552251faa6c8d" translate="yes" xml:space="preserve">
          <source>Most editors will likely display all Flow warnings, which is fine for small- to medium-scale projects, or projects with fewer unsuppressed warnings.</source>
          <target state="translated">これは、小規模から中規模のプロジェクトや、抑圧されていない警告が少ないプロジェクトには問題ありません。</target>
        </trans-unit>
        <trans-unit id="7b059f68400dbd84675bceaefa0fc9dee97bfc09" translate="yes" xml:space="preserve">
          <source>Most of the work that Flow does is comparing types against one another.</source>
          <target state="translated">フローが行う作業のほとんどは、タイプを互いに比較することです。</target>
        </trans-unit>
        <trans-unit id="865bd2fa28dfb2500c9d6ee7c2537c59e6ebb20a" translate="yes" xml:space="preserve">
          <source>Most people put the &lt;code&gt;.flowconfig&lt;/code&gt; in the root of their project (i.e. next to the &lt;code&gt;package.json&lt;/code&gt;). Some people put all their code in a &lt;code&gt;src/&lt;/code&gt; directory and therefore put the &lt;code&gt;.flowconfig&lt;/code&gt; at &lt;code&gt;src/.flowconfig&lt;/code&gt;.</source>
          <target state="translated">ほとんどの人は &lt;code&gt;.flowconfig&lt;/code&gt; をプロジェクトのルート（つまり、 &lt;code&gt;package.json&lt;/code&gt; の隣）に置きます。一部の人々は、すべてのコードを &lt;code&gt;src/&lt;/code&gt; ディレクトリに配置するため、 &lt;code&gt;.flowconfig&lt;/code&gt; を &lt;code&gt;src/.flowconfig&lt;/code&gt; に配置します。</target>
        </trans-unit>
        <trans-unit id="24fb36600e4f5f9c4147c6aae34b2eb550d7c78f" translate="yes" xml:space="preserve">
          <source>Most real JavaScript programs depend on third-party code and not just code immediately under the control of the project. That means a project using Flow may need to reference outside code that either doesn&amp;rsquo;t have type information or doesn&amp;rsquo;t have accurate and/or precise type information. In order to handle this, Flow supports the concept of a &amp;ldquo;library definition&amp;rdquo; (AKA &amp;ldquo;libdef&amp;rdquo;).</source>
          <target state="translated">ほとんどの実際のJavaScriptプログラムは、プロジェクトの制御下にあるコードだけでなく、サードパーティのコードに依存しています。つまり、フローを使用するプロジェクトは、型情報を持たないか、正確または正確な型情報を持たない外部コードを参照する必要がある場合があります。これを処理するために、フローは「ライブラリ定義」（別名「libdef」）の概念をサポートしています。</target>
        </trans-unit>
        <trans-unit id="3e58f860a0fe4e5d6b003e3170a2f45595516a83" translate="yes" xml:space="preserve">
          <source>Moving on to the next case. What happens if we have a single child, but that child is an array?</source>
          <target state="translated">次のケースに移ります。子が1人の場合ですが、その子が配列だった場合はどうなるでしょうか?</target>
        </trans-unit>
        <trans-unit id="0eaa6c704d21cdabb114c1eed0d1b20d3c99200e" translate="yes" xml:space="preserve">
          <source>Multiple children may also look like:</source>
          <target state="translated">複数の子供も似たような感じになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="df45cc95bf1aa33f0579b3915c74bbc29792fe71" translate="yes" xml:space="preserve">
          <source>NOTE: Because a given module cannot be both an ES module and a CommonJS module, it is an error to mix &lt;code&gt;declare export [...]&lt;/code&gt; with &lt;code&gt;declare module.exports: ...&lt;/code&gt; in the same &lt;code&gt;declare module&lt;/code&gt; body.</source>
          <target state="translated">注：特定のモジュールをESモジュールとCommonJSモジュールの両方にすることはできないため、同じ &lt;code&gt;declare module&lt;/code&gt; 本体で &lt;code&gt;declare module.exports: ...&lt;/code&gt; &lt;code&gt;declare export [...]&lt;/code&gt; と宣言宣言module.exports：...を混在させるとエラーになります。</target>
        </trans-unit>
        <trans-unit id="8fc9d5db4bce8ff6003105d5b34b50810aab147d" translate="yes" xml:space="preserve">
          <source>NOTE: For new code prefer &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt;. &lt;code&gt;Function&lt;/code&gt; has become an alias to &lt;code&gt;any&lt;/code&gt; and will be deprecated and removed in a future version of Flow.</source>
          <target state="translated">注：新しいコードの &lt;code&gt;any&lt;/code&gt; または &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt; 優先します。 &lt;code&gt;Function&lt;/code&gt; は &lt;code&gt;any&lt;/code&gt; のエイリアスになっており、Flowの将来のバージョンでは廃止され、削除される予定です。</target>
        </trans-unit>
        <trans-unit id="a4fc17a7e6e5fe579f60ff1988706b047d7ddb6f" translate="yes" xml:space="preserve">
          <source>NOTE: For new code, prefer &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;{[key:string]:any}&lt;/code&gt;. &lt;code&gt;Object&lt;/code&gt; is an alias to &lt;a href=&quot;../any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; and will be deprecated and removed in a future version of Flow.</source>
          <target state="translated">注：新しいコードの場合は、 &lt;code&gt;any&lt;/code&gt; または &lt;code&gt;{[key:string]:any}&lt;/code&gt; を使用してください。 &lt;code&gt;Object&lt;/code&gt; は&lt;a href=&quot;../any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;のエイリアスであり、Flowの将来のバージョンでは廃止され、削除される予定です。</target>
        </trans-unit>
        <trans-unit id="9bcc1eb8d16a0354aa6793057eb9ea662ddca8a2" translate="yes" xml:space="preserve">
          <source>NOTE: The syntax for declarations in a declaration file is the same as we&amp;rsquo;ve seen in &lt;a href=&quot;https://flow.org/en/libdefs/creation&quot;&gt;Creating Library Definitions section&lt;/a&gt;.</source>
          <target state="translated">注：宣言ファイル内の宣言の構文は、&lt;a href=&quot;https://flow.org/en/libdefs/creation&quot;&gt;ライブラリ定義の作成のセクションで説明し&lt;/a&gt;たものと同じです。</target>
        </trans-unit>
        <trans-unit id="eee4834f57293f261d87c33868be5aa7425351c9" translate="yes" xml:space="preserve">
          <source>NOTE: Using the &lt;code&gt;/flow-typed&lt;/code&gt; directory for libdefs is a convention that enables Flow to JustWork&amp;trade; out of the box and encourages consistency across projects that use Flow, but it is also possible to explicitly configure Flow to look elsewhere for libdefs using the &lt;a href=&quot;https://flow.org/en/config/libs&quot;&gt;&lt;code&gt;[libs]&lt;/code&gt; section of your &lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注：libdefsに &lt;code&gt;/flow-typed&lt;/code&gt; ディレクトリを使用することは、Flow to JustWork&amp;trade;をすぐに使用できるようにし、Flowを使用するプロジェクト全体の一貫性を促進する規則ですが、&lt;a href=&quot;https://flow.org/en/config/libs&quot;&gt; &lt;code&gt;[libs]&lt;/code&gt; あなたのセクション &lt;code&gt;.flowconfig&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88f2f30ba49708ae97f8d92b8a8a72e7ddff53df" translate="yes" xml:space="preserve">
          <source>Named Exports</source>
          <target state="translated">名目輸出</target>
        </trans-unit>
        <trans-unit id="e2dffcc7cffb0debfc5f8d1550386d2bb5e3bffe" translate="yes" xml:space="preserve">
          <source>Neither &lt;code&gt;@flow&lt;/code&gt; nor &lt;code&gt;@noflow&lt;/code&gt; - Parse this file with Flow syntax disallowed and do not typecheck it.</source>
          <target state="translated">&lt;code&gt;@flow&lt;/code&gt; も &lt;code&gt;@noflow&lt;/code&gt; も使用しない-Flow構文を使用してこのファイルを解析し、タイプチェックを行わないでください。</target>
        </trans-unit>
        <trans-unit id="9ed4452c065a3327032cb7f9b68de94c78e6bf1c" translate="yes" xml:space="preserve">
          <source>Neither will this:</source>
          <target state="translated">これもそうだろう。</target>
        </trans-unit>
        <trans-unit id="17e8fc5ffc9a8aadcb69cdfea49a7be7e3e01369" translate="yes" xml:space="preserve">
          <source>NeoBundle</source>
          <target state="translated">NeoBundle</target>
        </trans-unit>
        <trans-unit id="cb0c7f1b829e145b81d56e667505ff6ca3313917" translate="yes" xml:space="preserve">
          <source>Never used a type system before or just new to Flow? Let's get you up and running in a few minutes.</source>
          <target state="translated">タイプシステムを使ったことがない方、Flowは初めてですか?数分で使いこなせるようになります。</target>
        </trans-unit>
        <trans-unit id="4fa6d9c66b7b5cb1445a7a7985bc5a4c02e4f274" translate="yes" xml:space="preserve">
          <source>Newer versions of the JavaScript standard include a &lt;code&gt;Map&lt;/code&gt; class, but it is still very common to use objects as maps as well. In this use case, an object will likely have properties added to it and retrieved throughout its lifecycle. Furthermore, the property keys may not even be known statically, so writing out a type annotation would not be possible.</source>
          <target state="translated">JavaScript標準の新しいバージョンには &lt;code&gt;Map&lt;/code&gt; クラスが含まれていますが、オブジェクトをマップとして使用することも依然として非常に一般的です。この使用例では、オブジェクトにプロパティが追加され、そのライフサイクルを通じて取得される可能性があります。さらに、プロパティキーは静的にさえ知られていない可能性があるため、型注釈を書き出すことはできません。</target>
        </trans-unit>
        <trans-unit id="994a4af6c767d6bce3da94575735bc38736de599" translate="yes" xml:space="preserve">
          <source>Newlines and indentation after newlines are stripped, but watch out for whitespace when using a component with strict types around what children may be.</source>
          <target state="translated">改行と改行後のインデントは削除されますが、子要素の周りに厳格な型を持つコンポーネントを使用する場合は、空白に注意してください。</target>
        </trans-unit>
        <trans-unit id="c8b440e127a10dc6c8416450eb227c5047c30c36" translate="yes" xml:space="preserve">
          <source>Next we&amp;rsquo;ll add an else block to our if statement.</source>
          <target state="translated">次に、elseブロックをifステートメントに追加します。</target>
        </trans-unit>
        <trans-unit id="b08049f81dbbff0f0b72d5c90f11c3c94dbe857a" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll have a different &lt;code&gt;SubClass&lt;/code&gt; that returns a less specific type:</source>
          <target state="translated">次に、具体性の低いタイプを返す別の &lt;code&gt;SubClass&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="e898df75dae72ea5a3d9d46d76532d7a85a2015f" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll have a different &lt;code&gt;SubClass&lt;/code&gt; that returns a more specific type:</source>
          <target state="translated">次に、より具体的なタイプを返す別の &lt;code&gt;SubClass&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="ad7fad484146f11e6827ddde38d9848a5842febd" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll have another SubClass that accepts a value of a less specific type.</source>
          <target state="translated">次に、あまり具体的でない型の値を受け入れる別のサブクラスを作成します。</target>
        </trans-unit>
        <trans-unit id="03fcc5e78375c539a4046df66cd614afc3b96f5d" translate="yes" xml:space="preserve">
          <source>Nominal &amp;amp; Structural Typing</source>
          <target state="translated">公称および構造タイピング</target>
        </trans-unit>
        <trans-unit id="e8d7ae8d2ca23e63934856a596b9968693856079" translate="yes" xml:space="preserve">
          <source>Nominal typing</source>
          <target state="translated">公称タイピング</target>
        </trans-unit>
        <trans-unit id="7b7e96032e3f1e6663bd1bdc30dc00a06098260e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; will error if the object you are removing properties from does not have the property being removed, i.e. if &lt;code&gt;B&lt;/code&gt; has a key that doesn&amp;rsquo;t exist in &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">プロパティを削除するオブジェクトにプロパティが削除されていない場合、つまり &lt;code&gt;B&lt;/code&gt; に &lt;code&gt;A&lt;/code&gt; に存在しないキーがある場合、 &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; はエラーになります。</target>
        </trans-unit>
        <trans-unit id="3333e700ed17ae336d1331038ab7c3ede13160e7" translate="yes" xml:space="preserve">
          <source>Note that an array of type &lt;code&gt;$ReadOnlyArray&amp;lt;T&amp;gt;&lt;/code&gt; can still have mutable &lt;em&gt;elements&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;$ReadOnlyArray&amp;lt;T&amp;gt;&lt;/code&gt; 型の配列でも可変&lt;em&gt;要素を保持&lt;/em&gt;できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8d8fdec593b4fbb6674593ce345b2fc98b244bc1" translate="yes" xml:space="preserve">
          <source>Note that if you annotate your generic with variance sigils then Flow will check to make sure those types only appear in positions that make sense for that variance sigil. For example, you cannot declare a generic type parameter to behave covariantly and use it in a contravariant position:</source>
          <target state="translated">ジェネリックに分散記号をアノテーションした場合、Flowはそれらの型がその分散記号の意味を持つ位置にのみ現れるようにチェックすることに注意してください。例えば、共分散的に振る舞うようにジェネリック型パラメータを宣言して、それを逆分散的な位置で使用することはできません。</target>
        </trans-unit>
        <trans-unit id="d1ee3faa3af2380d9898eaa494128a6edeb62a34" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;.flow&lt;/code&gt; extension applies both to &lt;code&gt;.js&lt;/code&gt; files as well as &lt;code&gt;.json&lt;/code&gt; ones. The corresponding declaration files have extensions &lt;code&gt;.js.flow&lt;/code&gt; and &lt;code&gt;.json.flow&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;.flow&lt;/code&gt; 拡張子は &lt;code&gt;.js&lt;/code&gt; ファイルと &lt;code&gt;.json&lt;/code&gt; ファイルの両方に適用されることに注意してください。対応する宣言ファイルには、それぞれ拡張子 &lt;code&gt;.js.flow&lt;/code&gt; および &lt;code&gt;.json.flow&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="815e2ec516671c1e95e246519c4812a2e63caff8" translate="yes" xml:space="preserve">
          <source>Note that this lint does not trigger when we know a condition is always &lt;code&gt;false&lt;/code&gt;. It is a common idiom to use &lt;code&gt;invariant()&lt;/code&gt; or &lt;code&gt;invariant(false, ...)&lt;/code&gt; to throw in code that should be unreachable.</source>
          <target state="translated">条件が常に &lt;code&gt;false&lt;/code&gt; であることがわかっている場合、このlintはトリガーされないことに注意してください。到達できないはずのコードをスローするために &lt;code&gt;invariant()&lt;/code&gt; または &lt;code&gt;invariant(false, ...)&lt;/code&gt; を使用することは一般的な慣用法です。</target>
        </trans-unit>
        <trans-unit id="97abdd3aca893857a9659b8d5dc58e61b924f0e2" translate="yes" xml:space="preserve">
          <source>Note that when you have a value with a bound generic type, you can&amp;rsquo;t use it as if it were a more specific type.</source>
          <target state="translated">バインドされたジェネリック型の値がある場合、それをより具体的な型であるかのように使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3fa26fe5509b9dafc96225032b57c997a328ed0e" translate="yes" xml:space="preserve">
          <source>Note that you can also declare other things inside the body of the &lt;code&gt;declare module&lt;/code&gt;, and those things will be scoped to the body of the &lt;code&gt;declare module&lt;/code&gt; &amp;ndash; &lt;strong&gt;but they will not be exported from the module&lt;/strong&gt;:</source>
          <target state="translated">あなたもの体内に他のことを宣言することに注意してください &lt;code&gt;declare module&lt;/code&gt; 、およびそれらのものは本体にスコープされる &lt;code&gt;declare module&lt;/code&gt; - &lt;strong&gt;しかし、彼らは、モジュールからエクスポートされません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="54bffd8f0bade33130c198fcfbb3d3928227fba5" translate="yes" xml:space="preserve">
          <source>Note that you can also declare other things inside the body of the &lt;code&gt;declare module&lt;/code&gt;, and those things will be scoped to the body of the &lt;code&gt;declare module&lt;/code&gt;, &lt;strong&gt;but they will not be exported from the module&lt;/strong&gt;:</source>
          <target state="translated">あなたもの体内に他のことを宣言することに注意してください &lt;code&gt;declare module&lt;/code&gt; これらのものは本体にスコープされ、 &lt;code&gt;declare module&lt;/code&gt; 、&lt;strong&gt;しかし、彼らは、モジュールからエクスポートされません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c3611dae21abf03408abc2acf059be7215eea834" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;$ReadOnly&lt;/code&gt; is only for making read-only &lt;em&gt;object&lt;/em&gt; types. See the Array docs for how to &lt;a href=&quot;../arrays#toc-readonlyarray&quot;&gt;type read-only arrays with &lt;code&gt;$ReadOnlyArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注： &lt;code&gt;$ReadOnly&lt;/code&gt; は、読み取り専用の&lt;em&gt;オブジェクト&lt;/em&gt;タイプを作成するためだけの&lt;em&gt;もの&lt;/em&gt;です。&lt;a href=&quot;../arrays#toc-readonlyarray&quot;&gt; &lt;code&gt;$ReadOnlyArray&lt;/code&gt; &lt;/a&gt;配列を入力する方法については、配列ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d6be40aaa6de71f620ef0689323825354900d1e8" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; equivalent to &lt;code&gt;T&lt;/code&gt; with all its fields marked as optional. In particular, Flow unsoundly allows &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; to be used as a &lt;code&gt;T&lt;/code&gt; in several contexts. For example in</source>
          <target state="translated">注： &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; は、すべてのフィールドがオプションとしてマークされている &lt;code&gt;T&lt;/code&gt; と同等ではあり&lt;strong&gt;ません&lt;/strong&gt;。特に、Flowでは、いくつかのコンテキストで &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; を &lt;code&gt;T&lt;/code&gt; として使用できます。たとえば</target>
        </trans-unit>
        <trans-unit id="910cb2c37e2ad8674f98e665bc56e5aeb4d5a554" translate="yes" xml:space="preserve">
          <source>Note: If you add a type annotation to a rest parameter, it must always explicitly be an &lt;code&gt;Array&lt;/code&gt; type.</source>
          <target state="translated">注：型注釈をRESTパラメーターに追加する場合は、常に明示的に &lt;code&gt;Array&lt;/code&gt; 型にする必要があります。</target>
        </trans-unit>
        <trans-unit id="bc76abb2875c7659b6d7f4f248528d58f58a9924" translate="yes" xml:space="preserve">
          <source>Notice the types added to the parameter of the function along with a return type at the end of the function. You might be able to tell from looking at this code that there is an error in the return type since the function can also return an &lt;code&gt;int&lt;/code&gt;. However, you do not need to visually inspect the code since the Flow background process will be able to catch this error for you when you &lt;a href=&quot;#toc-check-your-code&quot;&gt;check your code&lt;/a&gt;.</source>
          <target state="translated">関数の最後に戻り値の型とともに、関数のパラメーターに追加された型に注意してください。このコードを見れば、関数が &lt;code&gt;int&lt;/code&gt; を返すこともできるので、戻り値の型にエラーがあることがわかるでしょう。ただし、コードを&lt;a href=&quot;#toc-check-your-code&quot;&gt;確認する&lt;/a&gt;ときにフローバックグラウンドプロセスでこのエラーを検出できるため、コードを視覚的に検査する必要はありません。</target>
        </trans-unit>
        <trans-unit id="c0d7a1a5c5c6adb2044345b94128cb7b17d10e58" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;flow&lt;/code&gt; will include a directory outside the &lt;code&gt;.flowconfig&lt;/code&gt; path in its check, ignore the &lt;code&gt;build&lt;/code&gt; directory and use the declarations in &lt;code&gt;lib&lt;/code&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;flow&lt;/code&gt; はチェックに &lt;code&gt;.flowconfig&lt;/code&gt; パスの外側のディレクトリを含め、 &lt;code&gt;build&lt;/code&gt; ディレクトリを無視して &lt;code&gt;lib&lt;/code&gt; の宣言を使用します。</target>
        </trans-unit>
        <trans-unit id="a044c31320a1c390eff0c847424350f19070f44e" translate="yes" xml:space="preserve">
          <source>Now Flow will complain when you try to write to any of these properties.</source>
          <target state="translated">これで、これらのプロパティに書き込もうとするとFlowが文句を言うようになりました。</target>
        </trans-unit>
        <trans-unit id="7b7f5bac6c35b92b712c9bf97b054fa867c2ca01" translate="yes" xml:space="preserve">
          <source>Now if you try to use &lt;code&gt;&amp;lt;MyComponent&amp;gt;&lt;/code&gt; with a string for &lt;code&gt;foo&lt;/code&gt; instead of a number you will get an error.</source>
          <target state="translated">ここで、数値の代わりに &lt;code&gt;foo&lt;/code&gt; の文字列で &lt;code&gt;&amp;lt;MyComponent&amp;gt;&lt;/code&gt; を使用しようとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="5b61c8302b29c6822902031839e12485c087afa1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see an example of the first case documented above. Suppose we have the following code in a file &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt;:</source>
          <target state="translated">次に、上記の最初のケースの例を見てみましょう。 &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; ファイルに次のコードがあるとします。</target>
        </trans-unit>
        <trans-unit id="fb52c53f4f22a6c6d90afe94da1c5cde383f8510" translate="yes" xml:space="preserve">
          <source>Now let's see how you would take this intuition and type the children of various React components.</source>
          <target state="translated">では、この直感を利用して、様々なReactコンポーネントの子をどのようにタイプするかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c47667d674268b42d8bc54bea9304a308b2c873f" translate="yes" xml:space="preserve">
          <source>Now suppose that instead of a boolean, we have a numerical value representing, say, the number of comments on a post. We want to display a count of the comments, unless there are no comments. We might naively try to do something similar to the boolean case:</source>
          <target state="translated">ここで、ブール値の代わりに、投稿に対するコメント数を表す数値があるとします。コメントがない場合を除いて、コメントの数を表示したいとします。素朴に、ブーリアンの場合と似たようなことをしようとするかもしれません。</target>
        </trans-unit>
        <trans-unit id="130ecc6b759fae2f2cbba2aade21537572c9ebf2" translate="yes" xml:space="preserve">
          <source>Now that all the setup and initialization is complete, you are ready to write actual Flow code. For each file that you have flagged with &lt;code&gt;// @flow&lt;/code&gt;, you now have the full power of Flow and its type-checking available to you. Here is an example Flow file:</source>
          <target state="translated">すべてのセットアップと初期化が完了したので、実際のフローコードを記述できます。 &lt;code&gt;// @flow&lt;/code&gt; でフラグを付けたファイルごとに、Flowの全機能とそのタイプチェックを利用できるようになります。次にフローファイルの例を示します。</target>
        </trans-unit>
        <trans-unit id="8a0aa492d72ba5e5ee4e490208cd56c9c6fd8b5b" translate="yes" xml:space="preserve">
          <source>Now type inference can keep working for &lt;code&gt;typeof obj&lt;/code&gt; which returns the expected shape of the object.</source>
          <target state="translated">これで、型推論は、オブジェクトの予想される形状を返す &lt;code&gt;typeof obj&lt;/code&gt; に対して機能し続けることができます。</target>
        </trans-unit>
        <trans-unit id="18e7605734b62fc321cd934a156de7bc5fd3f54f" translate="yes" xml:space="preserve">
          <source>Now wherever we use &lt;code&gt;this.props&lt;/code&gt; in our React component Flow will treat it as the &lt;code&gt;Props&lt;/code&gt; type we defined.</source>
          <target state="translated">これで、Reactコンポーネントフローで &lt;code&gt;this.props&lt;/code&gt; をどこで使用しても、定義した &lt;code&gt;Props&lt;/code&gt; タイプとして処理されます。</target>
        </trans-unit>
        <trans-unit id="cba47b2f9c45e1dcfda8b52779b4d36ece5cf6c4" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ll get a warning from Flow if you try to use numbers.</source>
          <target state="translated">数値を使用しようとすると、Flowから警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="abd74ca854ddc164ed4dd85269784a3b28f553e8" translate="yes" xml:space="preserve">
          <source>Now your code will not leak &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">これで、コードはリークし &lt;code&gt;any&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="d733ad521afc4421b4a66b432128c9bcdc2b5eec" translate="yes" xml:space="preserve">
          <source>Now, if you pass two values then &lt;code&gt;props.children&lt;/code&gt; will be an array. Specifically in this case &lt;code&gt;props.children&lt;/code&gt; will be &lt;code&gt;[1, 2]&lt;/code&gt;.</source>
          <target state="translated">ここで、2つの値を &lt;code&gt;props.children&lt;/code&gt; と、props.childrenは配列になります。特にこの場合、 &lt;code&gt;props.children&lt;/code&gt; は &lt;code&gt;[1, 2]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="be6e2a0e2bd898f29d9210b231319127fd00f218" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s Flowify the component we just wrote:</source>
          <target state="translated">次に、先ほど作成したコンポーネントをFlowifyしましょう。</target>
        </trans-unit>
        <trans-unit id="c7db6f471fb8404ecff0960ed4244da4532a2c7e" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s walk through different definitions of &lt;code&gt;method()&lt;/code&gt; in a couple different &lt;em&gt;subclasses&lt;/em&gt;.</source>
          <target state="translated">ここで、いくつかの異なる&lt;em&gt;サブクラス&lt;/em&gt;での &lt;code&gt;method()&lt;/code&gt; の異なる定義について見ていきましょう。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3fe7f794fc68b1034d0e3f564bf32dd7ffd089d7" translate="yes" xml:space="preserve">
          <source>Nuclide</source>
          <target state="translated">Nuclide</target>
        </trans-unit>
        <trans-unit id="63c0e833d1f670a8069d40968493548f0265ef94" translate="yes" xml:space="preserve">
          <source>Nuclide also comes with many other features including support for remote projects, hack, mercurial etc.</source>
          <target state="translated">Nuclideには、リモートプロジェクト、ハック、マーキュリアルなどのサポートを含む多くの機能が搭載されています。</target>
        </trans-unit>
        <trans-unit id="9e0b7a63508302d9d09c38742d062288dc1823d2" translate="yes" xml:space="preserve">
          <source>Nuclide v0.243.0 onward has support for working with Flow to limit the reported warnings to the working fileset. This allows Nuclide and Flow to work efficiently on large codebases with tens of thousands of unsuppressed warnings.</source>
          <target state="translated">Nuclide v0.243.0以降では、Flowとの連携により、報告される警告を作業ファイルセットに限定することができるようになりました。これにより、NuclideとFlowは、何万もの抑圧されていない警告を持つ大規模なコードベースで効率的に作業できるようになりました。</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="335e5e44a812438f93ba78ec1988eb2972404cb9" translate="yes" xml:space="preserve">
          <source>Numbers: like &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt;</source>
          <target state="translated">数字： &lt;code&gt;42&lt;/code&gt; や &lt;code&gt;3.14&lt;/code&gt; など</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">オブジェクトの種類</target>
        </trans-unit>
        <trans-unit id="9ed92c18b4e477381c353e8136dbc9d058b63386" translate="yes" xml:space="preserve">
          <source>Object type inference</source>
          <target state="translated">オブジェクト型推論</target>
        </trans-unit>
        <trans-unit id="0b9a72ed85754757a03a424a4f413c85cc295a74" translate="yes" xml:space="preserve">
          <source>Object type syntax</source>
          <target state="translated">オブジェクト型の構文</target>
        </trans-unit>
        <trans-unit id="cdea7c16abb43506671d0750b87a9ae17eb2398a" translate="yes" xml:space="preserve">
          <source>Object types can have optional properties where a question mark &lt;code&gt;?&lt;/code&gt; comes after the property name.</source>
          <target state="translated">オブジェクトタイプには、疑問符（ &lt;code&gt;?&lt;/code&gt; )が付いているオプションのプロパティがあります。プロパティ名の後に続きます。</target>
        </trans-unit>
        <trans-unit id="f85c54a239ca0dd9865eaee3f09163bc064e2fde" translate="yes" xml:space="preserve">
          <source>Object types try to match the syntax for objects in JavaScript as much as possible. Using curly braces &lt;code&gt;{}&lt;/code&gt; and name-value pairs using a colon &lt;code&gt;:&lt;/code&gt; split by commas &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">オブジェクト型は、JavaScriptのオブジェクトの構文にできるだけ一致するように試みます。中括弧用い &lt;code&gt;{}&lt;/code&gt; および結腸使用して、名前と値のペア &lt;code&gt;:&lt;/code&gt; コンマによって分割し &lt;code&gt;,&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1354578aed5c555826e657109cf8e1a80a7db3d0" translate="yes" xml:space="preserve">
          <source>Objects are structurally typed</source>
          <target state="translated">オブジェクトは構造的に型付けされています。</target>
        </trans-unit>
        <trans-unit id="9ab5bd450c651a40acb31c6d2173d2d8a317f03b" translate="yes" xml:space="preserve">
          <source>Objects as maps</source>
          <target state="translated">マップとしてのオブジェクト</target>
        </trans-unit>
        <trans-unit id="01a1617fcbeab1f400211a1e0e3d5541707fdd66" translate="yes" xml:space="preserve">
          <source>Objects can be used in many different ways in JavaScript. There are a number of different ways to type them in order to support all the different use cases.</source>
          <target state="translated">オブジェクトはJavaScriptでは様々な方法で使用することができます。さまざまなユースケースをサポートするために、オブジェクトのタイプにはさまざまな方法があります。</target>
        </trans-unit>
        <trans-unit id="a4eb44d5d295882356db532a105f60a76be3916a" translate="yes" xml:space="preserve">
          <source>Obsolete. Set this to &lt;code&gt;true&lt;/code&gt; to always strip the root directory from file paths in error messages when using &lt;code&gt;--json&lt;/code&gt;, &lt;code&gt;--from emacs&lt;/code&gt;, and &lt;code&gt;--from vim&lt;/code&gt;. Do not use this option. Instead, pass the command line flag &lt;code&gt;--strip-root&lt;/code&gt;.</source>
          <target state="translated">廃止されました。 &lt;code&gt;--json&lt;/code&gt; 、-- &lt;code&gt;--from emacs&lt;/code&gt; 、および &lt;code&gt;--from vim&lt;/code&gt; を使用するときにエラーメッセージのファイルパスからルートディレクトリを常に削除するには、これを &lt;code&gt;true&lt;/code&gt; に設定します。このオプションは使用しないでください。代わりに、コマンドラインフラグ &lt;code&gt;--strip-root&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="fd9b17a8cc9cfeab14950ff409781477ba7078b9" translate="yes" xml:space="preserve">
          <source>Often third-party libraries have broken type definitions or have type definitions only compatible with a certain version of Flow. In those cases it may be useful to use type information from the third-party libraries without typechecking their contents.</source>
          <target state="translated">サードパーティのライブラリでは、しばしば型定義が壊れていたり、特定のバージョンのFlowとしか互換性のない型定義を持っていたりすることがあります。このような場合、サードパーティライブラリの内容をタイプチェックせずに、サードパーティライブラリの型情報を使用することが有用な場合があります。</target>
        </trans-unit>
        <trans-unit id="adacc74ca82788d5eac49de1a84a330f45c46c00" translate="yes" xml:space="preserve">
          <source>Often, third-party code is organized in terms of modules rather than globals. To write a libdef that declares the presence of a module you&amp;rsquo;ll want to use the &lt;code&gt;declare module&lt;/code&gt; syntax:</source>
          <target state="translated">多くの場合、サードパーティのコードはグローバルではなくモジュールの観点から整理されています。モジュールの存在を宣言するlibdefを作成するには、 &lt;code&gt;declare module&lt;/code&gt; 構文を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b24bbeccf5137f66b11ed50187cc6eafef3213fa" translate="yes" xml:space="preserve">
          <source>On the flip-side, &lt;strong&gt;&lt;em&gt;completeness&lt;/em&gt;&lt;/strong&gt; is the ability for a type checker to only ever catch errors that &lt;em&gt;would&lt;/em&gt; happen at runtime. This comes at the cost of sometimes missing errors that will happen at runtime.</source>
          <target state="translated">フリップ側では、&lt;strong&gt;&lt;em&gt;完全に&lt;/em&gt;&lt;/strong&gt;しかエラーをキャッチするために型チェッカーのための能力である&lt;em&gt;だろう&lt;/em&gt;、実行時に起こります。これには、実行時に発生するエラーが欠落する場合があります。</target>
        </trans-unit>
        <trans-unit id="d37f56efe0e6015ca80498e8ea761c659a342927" translate="yes" xml:space="preserve">
          <source>Once all the dependencies of a &lt;code&gt;@flow strict-local&lt;/code&gt; file are strict, the file can be upgraded to a &lt;code&gt;@flow strict&lt;/code&gt; file. A &lt;code&gt;@flow strict&lt;/code&gt; file cannot depend on a &lt;code&gt;@flow strict-local&lt;/code&gt; file as this would break the &lt;code&gt;nonstrict-import&lt;/code&gt; rule.</source>
          <target state="translated">&lt;code&gt;@flow strict-local&lt;/code&gt; ファイルのすべての依存関係が厳密になると、ファイルを &lt;code&gt;@flow strict&lt;/code&gt; ファイルにアップグレードできます。 &lt;code&gt;@flow strict&lt;/code&gt; ファイルが依存することはできません &lt;code&gt;@flow strict-local&lt;/code&gt; これが壊れると、ファイル &lt;code&gt;nonstrict-import&lt;/code&gt; ルールを。</target>
        </trans-unit>
        <trans-unit id="2e418e3cfbf0c00ec225eae651536e321fd3bd30" translate="yes" xml:space="preserve">
          <source>Once you have &lt;a href=&quot;https://flow.org/en/install/&quot;&gt;installed&lt;/a&gt; Flow, you will want to get a feel of how to use Flow at the most basic level. For most new Flow projects, you will follow this general pattern:</source>
          <target state="translated">Flow を&lt;a href=&quot;https://flow.org/en/install/&quot;&gt;インストールし&lt;/a&gt;たら、最も基本的なレベルでFlowを使用する方法を感じてください。ほとんどの新しいFlowプロジェクトでは、次の一般的なパターンに従います。</target>
        </trans-unit>
        <trans-unit id="6ccb0b14eaa9c14dee4efd8a3cd89afe87b6ccb4" translate="yes" xml:space="preserve">
          <source>Once you have Babel setup, install &lt;code&gt;@babel/preset-flow&lt;/code&gt; with either &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">Babelのセットアップが完了したら、&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;または&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;を使用して &lt;code&gt;@babel/preset-flow&lt;/code&gt; をインストールします。</target>
        </trans-unit>
        <trans-unit id="f5fea1da9e23ea1d202b2729a702a3f535801fdd" translate="yes" xml:space="preserve">
          <source>One of the main contributors of Flow&amp;rsquo;s precision is path-sensitivity: the way types interact with runtime tests. The essence of many JavaScript idioms is to put together ad hoc sets of runtime values and to take them apart with shallow, structural (in)equality checks. In Flow, the set of runtime values that a variable may contain is described by its type, and a runtime test on that variable refines the type to a smaller set. This ability turns out to be quite powerful and general in practice.</source>
          <target state="translated">Flowの精度の主な貢献者の1つはパスセンシティビティです。つまり、型がランタイムテストと対話する方法です。多くのJavaScriptイディオムの本質は、実行時の値のアドホックセットをまとめ、それらを浅い構造的（不等）チェックで分解することです。フローでは、変数に含まれる可能性のあるランタイム値のセットはそのタイプによって記述され、その変数に対するランタイムテストはタイプをより小さなセットに絞り込みます。この能力は、実際には非常に強力で一般的であることがわかります。</target>
        </trans-unit>
        <trans-unit id="c922fe63b25cd49cec8888b01a561a5582a84a58" translate="yes" xml:space="preserve">
          <source>Only allowing a specific element type as children.</source>
          <target state="translated">特定の要素タイプのみを子として許可します。</target>
        </trans-unit>
        <trans-unit id="552faaf2aafbe53d107876ccee0f0634f915c3e5" translate="yes" xml:space="preserve">
          <source>Only one background process will be running at any given time, so if you run &lt;code&gt;flow status&lt;/code&gt; multiple times, it will use the same process.</source>
          <target state="translated">常に1つのバックグラウンドプロセスのみが実行されるため、 &lt;code&gt;flow status&lt;/code&gt; 複数回実行すると、同じプロセスが使用されます。</target>
        </trans-unit>
        <trans-unit id="e4a45cacdd8d7e9f0ebca1ec7bc3fb1f33c78855" translate="yes" xml:space="preserve">
          <source>Opaque Type Alias Syntax</source>
          <target state="translated">不透明型エイリアス構文</target>
        </trans-unit>
        <trans-unit id="65ea8514201b92749598f548009f0a4afe84c188" translate="yes" xml:space="preserve">
          <source>Opaque Type Alias Type Checking</source>
          <target state="translated">不透明タイプのエイリアスタイプのチェック</target>
        </trans-unit>
        <trans-unit id="961bf1b4717073b1bc912e5a6e9062ea360301f6" translate="yes" xml:space="preserve">
          <source>Opaque Type Aliases</source>
          <target state="translated">不透明なエイリアスタイプ</target>
        </trans-unit>
        <trans-unit id="6077a6482ea571ceaa9f7539cf7e9cbf318e56ce" translate="yes" xml:space="preserve">
          <source>Opaque type aliases are created using the words &lt;code&gt;opaque type&lt;/code&gt; followed by its name, an equals sign &lt;code&gt;=&lt;/code&gt;, and a type definition.</source>
          <target state="translated">不透明タイプのエイリアスは、 &lt;code&gt;opaque type&lt;/code&gt; という単語の後にその名前、等号 &lt;code&gt;=&lt;/code&gt; 、タイプ定義を続けて作成されます。</target>
        </trans-unit>
        <trans-unit id="ee9ac0643d45dfbbd750de612f57c1963700d825" translate="yes" xml:space="preserve">
          <source>Opaque type aliases are type aliases that do not allow access to their underlying type outside of the file in which they are defined.</source>
          <target state="translated">不透明型エイリアスとは、定義されているファイルの外部からその基礎となる型にアクセスできないようにする型エイリアスです。</target>
        </trans-unit>
        <trans-unit id="5f911be9170f1811fca0f4efce9cc2904081c303" translate="yes" xml:space="preserve">
          <source>Opaque type aliases can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;, and they work exactly as generics do in regular &lt;a href=&quot;../aliases#toc-type-alias-generics&quot;&gt;type aliases&lt;/a&gt;</source>
          <target state="translated">不透明な型エイリアスは独自の&lt;a href=&quot;../generics&quot;&gt;ジェネリックを&lt;/a&gt;持つこともでき、通常の&lt;a href=&quot;../aliases#toc-type-alias-generics&quot;&gt;型エイリアス&lt;/a&gt;でジェネリックが行うのとまったく同じように機能します。</target>
        </trans-unit>
        <trans-unit id="a9f3700878b30b619fa2c5143a86c38508c7ca4b" translate="yes" xml:space="preserve">
          <source>Opaque type aliases, like regular type aliases, may be used anywhere a type can be used.</source>
          <target state="translated">不透明な型のエイリアスは、通常の型のエイリアスのように、型が使用できる場所であればどこでも使用することができます。</target>
        </trans-unit>
        <trans-unit id="ddd2d4ec70a68949d8c75dd5fb57b7fa281e8e27" translate="yes" xml:space="preserve">
          <source>Optional Parameters</source>
          <target state="translated">オプションのパラメータ</target>
        </trans-unit>
        <trans-unit id="6eb1e4ba2d4c68b05e65e2f8b787201061244dd0" translate="yes" xml:space="preserve">
          <source>Optional function parameters</source>
          <target state="translated">オプションの関数パラメータ</target>
        </trans-unit>
        <trans-unit id="b20d0cae17674ab970acb532453aaf71edae6a61" translate="yes" xml:space="preserve">
          <source>Optional object properties</source>
          <target state="translated">オプションのオブジェクトプロパティ</target>
        </trans-unit>
        <trans-unit id="2d932cfadb898020aa3d7c79ba0029b42cc035ac" translate="yes" xml:space="preserve">
          <source>Optional object type properties</source>
          <target state="translated">オプションのオブジェクト型プロパティ</target>
        </trans-unit>
        <trans-unit id="7d05768bc14089a0cc0ad2e54b12a94fab4dbaf6" translate="yes" xml:space="preserve">
          <source>Optional parameters will accept missing, &lt;code&gt;undefined&lt;/code&gt;, or matching types. But they will not accept &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">オプションのパラメーターは、欠落、 &lt;code&gt;undefined&lt;/code&gt; 、または一致するタイプを受け入れます。しかし、それらは &lt;code&gt;null&lt;/code&gt; を受け入れません。</target>
        </trans-unit>
        <trans-unit id="5037e7b0dd30d22a12232b46317dc9e63f9ba600" translate="yes" xml:space="preserve">
          <source>Or as constructed wrapper objects.</source>
          <target state="translated">あるいは、構築されたラッパーオブジェクトとして。</target>
        </trans-unit>
        <trans-unit id="f26ec27bdcca139b8bc25d769f1290e1e51a3bf0" translate="yes" xml:space="preserve">
          <source>Or you could be accessing an element that does not exist if it is a &amp;ldquo;sparse array&amp;rdquo;.</source>
          <target state="translated">または、「スパース配列」の場合、存在しない要素にアクセスしている可能性があります。</target>
        </trans-unit>
        <trans-unit id="e404be6e42270a506b9fda4079e3cbb1faf93ee5" translate="yes" xml:space="preserve">
          <source>Or you could refine on the shape of objects.</source>
          <target state="translated">あるいは、オブジェクトの形状で絞り込むこともできます。</target>
        </trans-unit>
        <trans-unit id="36ccd6fa5b54b074d48b3c318b7724049b209ff5" translate="yes" xml:space="preserve">
          <source>Other Editors</source>
          <target state="translated">その他の編集者</target>
        </trans-unit>
        <trans-unit id="b01d9e5fc57d8be7b4d4cfaf9d867219b88b9c98" translate="yes" xml:space="preserve">
          <source>Other extensions that you may try are:</source>
          <target state="translated">他にも試してみたい拡張機能があります。</target>
        </trans-unit>
        <trans-unit id="55d5eb5f68ae162a0c0275477fbf7fd7aa314ea9" translate="yes" xml:space="preserve">
          <source>Other type systems will favor completeness instead, only reporting real errors in favor of possibly missing errors. Unit/Integration testing is an extreme form of this approach. Often this comes at the cost of missing the errors that are the most complicated to find, leaving that part up to the developer.</source>
          <target state="translated">他のタイプのシステムは、代わりに完全性を重視し、見落としている可能性のあるエラーの代わりに、実際のエラーのみを報告します。ユニット/統合テストは、このアプローチの極端な形です。多くの場合、このアプローチは、見つけるのが最も複雑なエラーを見落とす代償として、その部分を開発者に任せることになります。</target>
        </trans-unit>
        <trans-unit id="8d7bf5bf136e81f9388c1f4eca050d6d94e965d7" translate="yes" xml:space="preserve">
          <source>Others</source>
          <target state="translated">Others</target>
        </trans-unit>
        <trans-unit id="d10a332d2514aa48380a681c92c805bab5fc2c39" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;../types&quot;&gt;types reference&lt;/a&gt; has more information about both &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../types#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">私たちの&lt;a href=&quot;../types&quot;&gt;タイプの参照は、&lt;/a&gt;両方の詳細については持ってい&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../types#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7ec91907688dba7293db664f96aa7520dd5050d" translate="yes" xml:space="preserve">
          <source>Our first case is an element with no children:</source>
          <target state="translated">最初のケースは子供がいない要素です。</target>
        </trans-unit>
        <trans-unit id="3e4d85a254d099e6caabb9070a8f1a5835e74184" translate="yes" xml:space="preserve">
          <source>Outside the Defining File</source>
          <target state="translated">定義ファイルの外側</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="2bfd0b733d61ec42886bc0c31e24e1f1a0d24fdf" translate="yes" xml:space="preserve">
          <source>Parameterized generics</source>
          <target state="translated">パラメータ化されたジェネリック</target>
        </trans-unit>
        <trans-unit id="6aa250c187d7bae549c808c9085514424d802eea" translate="yes" xml:space="preserve">
          <source>Pathogen</source>
          <target state="translated">Pathogen</target>
        </trans-unit>
        <trans-unit id="3dd4db5ce7ea626f59e720f0c27096a22aa1ecd0" translate="yes" xml:space="preserve">
          <source>Precision</source>
          <target state="translated">Precision</target>
        </trans-unit>
        <trans-unit id="8a51f97f15da4dd4d5a94fab1a4108cee0b5e1d4" translate="yes" xml:space="preserve">
          <source>Precision also has other desirable consequences. When types are trustworthy, developers tend to rely on them to structure their code and reason about it, leading to cleaner and more efficient code with fewer dynamic checks. When type errors are trustworthy, developers can focus on what their code does rather than thinking about how to rewrite their code to satisfy (or work around) the type system.</source>
          <target state="translated">精度は他にも望ましい結果をもたらします。型が信頼できるものであれば、開発者はコードの構造化や推論を型に頼る傾向があり、動的なチェックが少なく、よりクリーンで効率的なコードにつながります。型エラーが信頼できる場合、開発者は型システムを満足させる(あるいは回避する)ためにコードをどのように書き換えるかを考えるよりも、自分のコードが何をするかに集中することができます。</target>
        </trans-unit>
        <trans-unit id="83590fe5defcf4d8a2747e7bff66e91f7879b09e" translate="yes" xml:space="preserve">
          <source>Precision usually comes at the cost of speed. But while a precise analysis is desirable, most of the appeal of JavaScript is lost if we slow down the edit-refresh cycle by making developers wait as we compile.</source>
          <target state="translated">正確さは通常、速度を犠牲にして得られます。しかし、正確な分析が望ましいとはいえ、コンパイル時に開発者を待たせることで編集・更新サイクルを遅くしてしまうと、JavaScriptの魅力のほとんどが失われてしまいます。</target>
        </trans-unit>
        <trans-unit id="257e6b97ae8767ca7162ae0be418d790074caf9b" translate="yes" xml:space="preserve">
          <source>Predicate Functions</source>
          <target state="translated">叙述関数</target>
        </trans-unit>
        <trans-unit id="8fcc548a63302b124fd2a2a6ebe6d394e16cc696" translate="yes" xml:space="preserve">
          <source>Prepare Your Code for Flow</source>
          <target state="translated">フローのためのコードの準備</target>
        </trans-unit>
        <trans-unit id="80015c28ef31d8e37f60f4672f12166e4717f624" translate="yes" xml:space="preserve">
          <source>Preparing a project for Flow requires only one command:</source>
          <target state="translated">Flow用のプロジェクトを準備する際に必要なコマンドは1つだけです。</target>
        </trans-unit>
        <trans-unit id="0334ecb0491c1c96b75c2abb7a0dde8caad5c58f" translate="yes" xml:space="preserve">
          <source>Preserving the Instance Type of a Component</source>
          <target state="translated">コンポーネントのインスタンス型を保持する</target>
        </trans-unit>
        <trans-unit id="f6675da1b1e3eb27ea3b95e0125a3fc19547c62c" translate="yes" xml:space="preserve">
          <source>Press Ctrl+Shift+P to bring up the Command Palette (or use Tools &amp;gt; Command Palette menu)</source>
          <target state="translated">Ctrl + Shift + Pを押してコマンドパレットを表示します（または[ツール]&amp;gt; [コマンドパレット]メニューを使用します）。</target>
        </trans-unit>
        <trans-unit id="4e34606590cc14f76b8a62ab4f8ca344fd2d5ed8" translate="yes" xml:space="preserve">
          <source>Prevent this from happening by cutting &lt;code&gt;any&lt;/code&gt; off as soon as possible by casting it to another type.</source>
          <target state="translated">別のタイプにキャストしてできるだけ早く切り取って &lt;code&gt;any&lt;/code&gt; これが起こらないようにしてください。</target>
        </trans-unit>
        <trans-unit id="d8f0896601269b7c415369db5197a7aa8c4bfad4" translate="yes" xml:space="preserve">
          <source>Primitive Types</source>
          <target state="translated">原始型</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="498f09c9f4966796c2534e5801feef8ccd4eed84" translate="yes" xml:space="preserve">
          <source>React allows you to grab the instance of an element or component with &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt; functions&lt;/a&gt;. To use a ref function add a &lt;a href=&quot;https://flow.org/en/types/maybe/&quot;&gt;maybe instance type&lt;/a&gt; to your class and assign your instance to that property in your ref function.</source>
          <target state="translated">Reactでは、&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; 関数を&lt;/a&gt;使用して要素またはコンポーネントのインスタンスを取得できます。ref関数を使用するには、&lt;a href=&quot;https://flow.org/en/types/maybe/&quot;&gt;多分インスタンスタイプ&lt;/a&gt;をクラスに追加し、インスタンスをref関数のそのプロパティに割り当てます。</target>
        </trans-unit>
        <trans-unit id="ce33237a4802f75e813a38036292316d4ce2343b" translate="yes" xml:space="preserve">
          <source>React allows you to pass &lt;em&gt;any&lt;/em&gt; value as the children of a React component. There are some creative uses of this capability such as using a function for children which could look like this:</source>
          <target state="translated">Reactでは、Reactコンポーネントの子として&lt;em&gt;任意の&lt;/em&gt;値を渡すことができます。この機能には、次のような子供向けの関数を使用するなど、いくつかの創造的な用途があります。</target>
        </trans-unit>
        <trans-unit id="177c1e000dc1d0316d4c2c3d73adf88cdc7bde20" translate="yes" xml:space="preserve">
          <source>React also supports default props on stateless functional components. Similarly to class components, default props for stateless functional components will work without any extra type annotations.</source>
          <target state="translated">React はステートレスな機能コンポーネントのデフォルトプロップもサポートしています。クラスコンポーネントと同様に、ステートレス機能コンポーネントのデフォルトプロップは、余分な型アノテーションなしで動作します。</target>
        </trans-unit>
        <trans-unit id="b4a8bc5b355decd0225ee33bd0badaf612842a37" translate="yes" xml:space="preserve">
          <source>React class components will be the class instance. So if you had &lt;code&gt;class Foo extends React.Component&amp;lt;{}&amp;gt; {}&lt;/code&gt; and used &lt;code&gt;React.ElementRef&amp;lt;typeof Foo&amp;gt;&lt;/code&gt; then the type would be the instance of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Reactクラスコンポーネントがクラスインスタンスになります。したがって、 &lt;code&gt;class Foo extends React.Component&amp;lt;{}&amp;gt; {}&lt;/code&gt; を &lt;code&gt;React.ElementRef&amp;lt;typeof Foo&amp;gt;&lt;/code&gt; 場合、タイプは &lt;code&gt;Foo&lt;/code&gt; のインスタンスになります。</target>
        </trans-unit>
        <trans-unit id="c111454a8a259a2534472c017a3802fd7ccb4ddd" translate="yes" xml:space="preserve">
          <source>React elements can have zero, one, or many children. Being able to type these children with Flow allows you to build expressive APIs with React children.</source>
          <target state="translated">React要素は、0個、1個、または多数の子を持つことができます。Flowでこれらの子をタイプできるようになると、Reactの子を使って表現力豊かなAPIを構築することができます。</target>
        </trans-unit>
        <trans-unit id="007c7fdccd509ac94dc704a539b8aed206e42677" translate="yes" xml:space="preserve">
          <source>React exports a handful of utility types that may be useful to you when typing advanced React patterns. In previous sections we have seen a few of them. The following is a complete reference for each of these types along with some examples for how/where to use them.</source>
          <target state="translated">React は、高度な React パターンを入力する際に便利なユーティリティタイプをエクスポートします。以前のセクションでは、そのうちのいくつかを見てきました。以下に、これらのタイプの完全なリファレンスと、それらを使用する方法や場所の例を示します。</target>
        </trans-unit>
        <trans-unit id="83f2828960b3b5c2589074d8fb5ec48d203a2618" translate="yes" xml:space="preserve">
          <source>React stateless functional components do not have a backing instance and so &lt;code&gt;React.ElementRef&amp;lt;typeof Bar&amp;gt;&lt;/code&gt; (when &lt;code&gt;Bar&lt;/code&gt; is &lt;code&gt;function Bar() {}&lt;/code&gt;) will give you the undefined type.</source>
          <target state="translated">Reactステートレス機能コンポーネントにはバッキングインスタンスがないため、 &lt;code&gt;React.ElementRef&amp;lt;typeof Bar&amp;gt;&lt;/code&gt; （ &lt;code&gt;Bar&lt;/code&gt; が &lt;code&gt;function Bar() {}&lt;/code&gt; ）は未定義のタイプを提供します。</target>
        </trans-unit>
        <trans-unit id="29ed07e15fc66a324459b85d24416800bceafaa3" translate="yes" xml:space="preserve">
          <source>React supports the notion of &lt;code&gt;defaultProps&lt;/code&gt; which you can think of as default function arguments. When you create an element and you did not include a prop with a default then React will substitute that prop with its corresponding value from &lt;code&gt;defaultProps&lt;/code&gt;. Flow supports this notion as well. To type default props add a &lt;code&gt;static defaultProps&lt;/code&gt; property to your class.</source>
          <target state="translated">Reactは &lt;code&gt;defaultProps&lt;/code&gt; の概念をサポートしています。これは、デフォルトの関数引数と考えることができます。要素を作成し、デフォルトのプロップを含めなかった場合、Reactはそのプロップを &lt;code&gt;defaultProps&lt;/code&gt; の対応する値に置き換えます。フローはこの概念もサポートしています。デフォルトの小道具を入力するには、 &lt;code&gt;static defaultProps&lt;/code&gt; プロパティをクラスに追加します。</target>
        </trans-unit>
        <trans-unit id="70287cb5f65a904f3e064a37b30a5a631627d2e6" translate="yes" xml:space="preserve">
          <source>Read more about &lt;a href=&quot;variance&quot;&gt;property variance&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;variance&quot;&gt;プロパティの分散の&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="61910c412c7b58b226db5d6ed180b312f69dc750" translate="yes" xml:space="preserve">
          <source>Reassigning unsealed object properties</source>
          <target state="translated">封印されていないオブジェクトのプロパティの再割り当て</target>
        </trans-unit>
        <trans-unit id="1bf2749de445e45162652ccf38c834bf918ba1b2" translate="yes" xml:space="preserve">
          <source>Reassigning variables</source>
          <target state="translated">変数の再割り当て</target>
        </trans-unit>
        <trans-unit id="d6101a7583b060dcae14c84065094e42d98e9a54" translate="yes" xml:space="preserve">
          <source>Recall that the instance type of a function component is &lt;code&gt;void&lt;/code&gt;. Our example above wraps a component in a function, so the returned component has the instance type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">関数コンポーネントのインスタンスタイプは &lt;code&gt;void&lt;/code&gt; であることを思い出してください。上記の例では、コンポーネントを関数でラップしているため、返されるコンポーネントのインスタンスタイプは &lt;code&gt;void&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="dda31a027bfa36f4ca8585837d08aaa1912d41bf" translate="yes" xml:space="preserve">
          <source>Reducers</source>
          <target state="translated">Reducers</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="7c12d3319cfff8593c41d6d684faf2f999524cf3" translate="yes" xml:space="preserve">
          <source>Redux state &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&quot;&gt;is meant to be immutable&lt;/a&gt;: creating a new state object instead of changing properties on a single object.</source>
          <target state="translated">Redux状態&lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&quot;&gt;は不変であることを意味し&lt;/a&gt;ます。単一のオブジェクトのプロパティを変更する代わりに、新しい状態オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="ed05f5c415303abb0d8305ee74bd6d2e8ce7eda3" translate="yes" xml:space="preserve">
          <source>Refinement Invalidations</source>
          <target state="translated">絞り込みの無効化</target>
        </trans-unit>
        <trans-unit id="43586e5f8885df744af66a163f9bd504927049f7" translate="yes" xml:space="preserve">
          <source>Refinement invalidation can also happen with &lt;a href=&quot;types/unions#toc-disjoint-unions&quot;&gt;disjoint unions&lt;/a&gt;. Any function call will invalidate any refinement.</source>
          <target state="translated">絞り込みの無効化は、 &lt;a href=&quot;types/unions#toc-disjoint-unions&quot;&gt;互いに素な共用体で&lt;/a&gt;ます。関数を呼び出すと、絞り込みが無効になります。</target>
        </trans-unit>
        <trans-unit id="a02ef029699599da7905088f0dc103f214ced944" translate="yes" xml:space="preserve">
          <source>Refinements are a frequently used aspect of many type systems. They are so ingrained in the way that we program and even the way that we think you might not even notice them.</source>
          <target state="translated">改良は多くの型システムで頻繁に使用されています。これらは、私たちがプログラムを組む方法や、あなたが気づかないかもしれないと思うような方法にまで染み付いています。</target>
        </trans-unit>
        <trans-unit id="0b89cb145cee7a8457a6e4dd2a97e9f0caac7219" translate="yes" xml:space="preserve">
          <source>Refinements can also come in other forms other than testing for equality:</source>
          <target state="translated">洗練されたものは、平等性のためのテスト以外の形でもよい。</target>
        </trans-unit>
        <trans-unit id="698e6391f48381c22849ea4013ae0a7dff98a9af" translate="yes" xml:space="preserve">
          <source>Refining Maybe types</source>
          <target state="translated">洗練されたかもしれないタイプ</target>
        </trans-unit>
        <trans-unit id="9452f08c2e094961ce428c428ee0585501ce1d09" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt; are different types.</source>
          <target state="translated">その &lt;code&gt;boolean&lt;/code&gt; と &lt;code&gt;Boolean&lt;/code&gt; は異なるタイプで。</target>
        </trans-unit>
        <trans-unit id="11f6d4fee5ab698ed0a3047ac64f1d9637774150" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; are different types.</source>
          <target state="translated">その &lt;code&gt;number&lt;/code&gt; を覚えて &lt;code&gt;Number&lt;/code&gt; は異なるタイプで。</target>
        </trans-unit>
        <trans-unit id="55b41046e32661a87f2a8fd34325d7734f4d4cd1" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are different types.</source>
          <target state="translated">その &lt;code&gt;string&lt;/code&gt; と &lt;code&gt;String&lt;/code&gt; は異なるタイプで。</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="3d6f80999c0c50a74e8acebc121f44bdbef82ae3" translate="yes" xml:space="preserve">
          <source>Requires Flow to be installed and available on your path.</source>
          <target state="translated">Flowがインストールされている必要があり、パス上で利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="33b4e56519b4614c59e8b72375bac3a885fdacaa" translate="yes" xml:space="preserve">
          <source>Requires JavaScript files to be marked with /* @flow */ at the top.</source>
          <target state="translated">JavaScript ファイルの先頭に /*@flow */を付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="0a7c549205648d46b232d0e6177754a236939fcb" translate="yes" xml:space="preserve">
          <source>Requires projects containing JavaScript files to be initialised with flow init.</source>
          <target state="translated">JavaScript ファイルを含むプロジェクトが flow init で初期化される必要があります。</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">Restパラメータ</target>
        </trans-unit>
        <trans-unit id="7af6341ba4a77c200422ad48589bc5fcb0b569c3" translate="yes" xml:space="preserve">
          <source>Return types ensure that every branch of your function returns the same type. This prevents you from accidentally not returning a value under certain conditions.</source>
          <target state="translated">リターン型は、関数のすべてのブランチが同じ型を返すことを保証します。これにより、特定の条件下で誤って値を返さないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="686039dfdbe08da5125ed6c00f4c1399d48dfd9b" translate="yes" xml:space="preserve">
          <source>Right, the &lt;code&gt;isLeapYear&lt;/code&gt; call in &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; will typecheck, since the &lt;code&gt;year&lt;/code&gt; parameter expects a &lt;code&gt;string&lt;/code&gt; in the declaration file.</source>
          <target state="translated">右、 &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; の &lt;code&gt;isLeapYear&lt;/code&gt; 呼び出しは、typecheckになります。 &lt;code&gt;year&lt;/code&gt; パラメーターは宣言ファイル内の &lt;code&gt;string&lt;/code&gt; を想定しているためです。</target>
        </trans-unit>
        <trans-unit id="67d0f5e7710e2e8d6a977594f3101bc9772e4d34" translate="yes" xml:space="preserve">
          <source>Run the Flow Background Process</source>
          <target state="translated">フローのバックグラウンドプロセスを実行する</target>
        </trans-unit>
        <trans-unit id="61ba9e06d750a8c11a8c53dbe4b159704d49a040" translate="yes" xml:space="preserve">
          <source>Run this command at the top level of your project to create one, empty file called &lt;a href=&quot;https://flow.org/en/config/&quot;&gt;&lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;. At its most basic level, &lt;code&gt;.flowconfig&lt;/code&gt; tells the Flow background process the root of where to begin checking Flow code for errors.</source>
          <target state="translated">プロジェクトの最上位でこのコマンドを実行して、&lt;a href=&quot;https://flow.org/en/config/&quot;&gt; &lt;code&gt;.flowconfig&lt;/code&gt; &lt;/a&gt;という名前の空のファイルを1つ作成します。最も基本的なレベルでは、 &lt;code&gt;.flowconfig&lt;/code&gt; はフローバックグラウンドプロセスに、フローコードのエラーチェックを開始する場所のルートを指示します。</target>
        </trans-unit>
        <trans-unit id="6e373532fbaa792fe51ef4bf5789af3104a5d987" translate="yes" xml:space="preserve">
          <source>Say you have the following directory structure, with your &lt;code&gt;.flowconfig&lt;/code&gt; in &lt;code&gt;mydir&lt;/code&gt;:</source>
          <target state="translated">あなたと、あなたは次のディレクトリ構造を持っていると言う &lt;code&gt;.flowconfig&lt;/code&gt; で &lt;code&gt;mydir&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3bfb431a612a3027c31b75652ccf295595fa76b2" translate="yes" xml:space="preserve">
          <source>Sealed objects</source>
          <target state="translated">封印された物体</target>
        </trans-unit>
        <trans-unit id="554e5e25f0d86fc7d48da5b753f3b192e04d6a22" translate="yes" xml:space="preserve">
          <source>Second example:</source>
          <target state="translated">第二の例。</target>
        </trans-unit>
        <trans-unit id="5437018c74686a42995bf3c86f110c73dfb010d3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/facebook/flow/issues/5725&quot;&gt;this GitHub issue for the original motivation&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/flow/issues/5725&quot;&gt;元の動機については、このGitHubの問題を&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="e6fc3fca1eed93ff9d9a6c2799720ebdd64e3698" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;[untyped]&lt;/code&gt;(untyped) for not typechecking files, and instead using &lt;code&gt;any&lt;/code&gt; for all contents.</source>
          <target state="translated">ファイルのタイプチェックを行わず、代わりにすべてのコンテンツに &lt;code&gt;any&lt;/code&gt; を使用する場合は、 &lt;code&gt;[untyped]&lt;/code&gt; （untyped）も参照してください。</target>
        </trans-unit>
        <trans-unit id="d10cc1add2564282fb8d240521737d52d850d2d5" translate="yes" xml:space="preserve">
          <source>See how we added &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;SomeOtherComponent&amp;gt;&lt;/code&gt; as children to &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt;? This is not allowed and &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; will throw an error. How do we make sure Flow does not allow this pattern?</source>
          <target state="translated">我々は追加する方法を参照してください &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;SomeOtherComponent&amp;gt;&lt;/code&gt; などの子どもへの &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; ？これは許可されておらず、 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; はエラーをスローします。Flowがこのパターンを許可しないことをどのように確認しますか？</target>
        </trans-unit>
        <trans-unit id="f741f4c166b4ccd4d41f13a13dece778f73df85a" translate="yes" xml:space="preserve">
          <source>Select &amp;lsquo;Flow for Sublime Text 2 and 3&amp;rsquo; to install</source>
          <target state="translated">インストールする「崇高なテキスト2および3のフロー」を選択します</target>
        </trans-unit>
        <trans-unit id="e6b4c56f97df36a6ecd6ed02f0d6868208b5ab27" translate="yes" xml:space="preserve">
          <source>Select Package Control: Install Package</source>
          <target state="translated">パッケージコントロールを選択します。パッケージのインストール</target>
        </trans-unit>
        <trans-unit id="5a51c55e03c6fe62b671bf2a091c73c068704caf" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the &lt;code&gt;export * as&lt;/code&gt; syntax from &lt;a href=&quot;https://github.com/leebyron/ecmascript-more-export-from&quot;&gt;leebyron&amp;rsquo;s proposal&lt;/a&gt;.</source>
          <target state="translated">これを &lt;code&gt;enable&lt;/code&gt; に設定して、フローが&lt;a href=&quot;https://github.com/leebyron/ecmascript-more-export-from&quot;&gt;leebyronの提案&lt;/a&gt;からの構文 &lt;code&gt;export * as&lt;/code&gt; 構文をサポートする必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="d2f2f8212166435e1e26351a8d0075e389cfc197" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the use of &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing&quot;&gt;nullish coalescing&lt;/a&gt; per the pending spec.</source>
          <target state="translated">これを &lt;code&gt;enable&lt;/code&gt; に設定して、フローが保留中の仕様に従って&lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing&quot;&gt;無効な合体&lt;/a&gt;の使用をサポートする必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="5ffd0d476596e4beacfa43c710cc9eca05a02fef" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the use of &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;optional chaining&lt;/a&gt; per the pending spec.</source>
          <target state="translated">これを &lt;code&gt;enable&lt;/code&gt; に設定して、フローが保留中の仕様に従って&lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;オプションのチェーン&lt;/a&gt;の使用をサポートする必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="a791224e1e0c6173296867136f2701fa594c4db9" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should ignore decorators.</source>
          <target state="translated">これを &lt;code&gt;ignore&lt;/code&gt; に設定して、フローがデコレーターを無視することを示します。</target>
        </trans-unit>
        <trans-unit id="7252ab4a3a45b3b2cf1e24f49aebbbc8df2bea70" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; and Flow will no longer complain when you use &lt;code&gt;require()&lt;/code&gt; with something other than a string literal.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定する &lt;code&gt;require()&lt;/code&gt; 、文字列リテラル以外のものでrequire（）を使用してもFlowは文句を言わなくなります。</target>
        </trans-unit>
        <trans-unit id="17b19723fab321f07b8d03e9886bc4fd290afff7" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; if you use a transpiler that adds &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; to the top of every module.</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; を追加するトランスパイラーを使用する場合は、これを &lt;code&gt;true&lt;/code&gt; に設定します。すべてのモジュールの先頭に。</target>
        </trans-unit>
        <trans-unit id="8f7810533f5b1afdbd99345ceeeb8bb80fe383b5" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to add emoji to the status messages that Flow outputs when it&amp;rsquo;s busy checking your project.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定して、プロジェクトのチェックでビジー状態のときにFlowが出力するステータスメッセージに絵文字を追加します。</target>
        </trans-unit>
        <trans-unit id="0a9e20b6f9ef8f6259569858fa3254651f50988f" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to check all files, not just those with &lt;code&gt;@flow&lt;/code&gt;.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定すると、 &lt;code&gt;@flow&lt;/code&gt; のファイルだけでなく、すべてのファイルがチェックされます。</target>
        </trans-unit>
        <trans-unit id="d2763696664697d56a9bd55ceed56c975dbfc607" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to check that array spread syntax is only used with arrays, not arbitrary iterables (such as &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;Set&lt;/code&gt;). This is useful if you transform your code with Babel in &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-spread#loose&quot;&gt;loose mode&lt;/a&gt; which makes this non-spec-compliant assumption at runtime.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定して、配列スプレッド構文が任意の反復可能オブジェクト（ &lt;code&gt;Map&lt;/code&gt; や &lt;code&gt;Set&lt;/code&gt; など）ではなく、配列でのみ使用されることを確認します。これは、実行時にこの仕様に準拠しない仮定を行う&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-spread#loose&quot;&gt;ルーズモード&lt;/a&gt;でBabelを使用してコードを変換する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="632e3852195a2720cf86c3695ec9f34205f83f66" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to have Flow treat underscore-prefixed class properties and methods as private. This should be used in conjunction with &lt;a href=&quot;https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js&quot;&gt;&lt;code&gt;jstransform&lt;/code&gt;&amp;rsquo;s ES6 class transform&lt;/a&gt;, which enforces the same privacy at runtime.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定すると、フローでアンダースコアが前に付けられたクラスのプロパティとメソッドがプライベートとして扱われます。これは、実行時に同じプライバシーを&lt;a href=&quot;https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js&quot;&gt; &lt;code&gt;jstransform&lt;/code&gt; &lt;/a&gt;するjstransformのES6クラス変換と組み合わせて使用​​する必要があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
